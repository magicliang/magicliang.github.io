<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>重读 Martin Fowler 的微服务论文原文 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="背景 Martin Fowler 和 James Lewis 于 2014 年发表的 “Microservices: a definition of this new architectural term” 是微服务架构领域最具影响力的文章之一。这篇文章并非提出微服务的概念（Netflix、Amazon 等公司早已在实践），而是对这一架构风格进行了系统性的定义和特征总结。 文章的核心论点是：微服务">
<meta property="og:type" content="article">
<meta property="og:title" content="重读 Martin Fowler 的微服务论文原文">
<meta property="og:url" content="https://magicliang.github.io/2018/03/20/%E9%87%8D%E8%AF%BB-Martin-Fowler-%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BA%E6%96%87%E5%8E%9F%E6%96%87/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="背景 Martin Fowler 和 James Lewis 于 2014 年发表的 “Microservices: a definition of this new architectural term” 是微服务架构领域最具影响力的文章之一。这篇文章并非提出微服务的概念（Netflix、Amazon 等公司早已在实践），而是对这一架构风格进行了系统性的定义和特征总结。 文章的核心论点是：微服务">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-102.jpg">
<meta property="article:published_time" content="2018-03-20T08:26:04.000Z">
<meta property="article:modified_time" content="2026-02-09T09:25:18.404Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="微服务">
<meta property="article:tag" content="架构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-102.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "重读 Martin Fowler 的微服务论文原文",
  "url": "https://magicliang.github.io/2018/03/20/%E9%87%8D%E8%AF%BB-Martin-Fowler-%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BA%E6%96%87%E5%8E%9F%E6%96%87/",
  "image": "https://magicliang.github.io/img/wall-paper-102.jpg",
  "datePublished": "2018-03-20T08:26:04.000Z",
  "dateModified": "2026-02-09T09:25:18.404Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2018/03/20/%E9%87%8D%E8%AF%BB-Martin-Fowler-%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BA%E6%96%87%E5%8E%9F%E6%96%87/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '重读 Martin Fowler 的微服务论文原文',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-102.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">重读 Martin Fowler 的微服务论文原文</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">重读 Martin Fowler 的微服务论文原文</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2018-03-20T08:26:04.000Z" title="Created 2018-03-20 16:26:04">2018-03-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-09T09:25:18.404Z" title="Updated 2026-02-09 17:25:18">2026-02-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">3.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>12mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>背景</h1>
<p>Martin Fowler 和 James Lewis 于 2014 年发表的 <a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html"><em>“Microservices: a definition of this new architectural term”</em></a> 是微服务架构领域最具影响力的文章之一。这篇文章并非提出微服务的概念（Netflix、Amazon 等公司早已在实践），而是对这一架构风格进行了系统性的定义和特征总结。</p>
<p>文章的核心论点是：微服务架构是一种将应用程序构建为 <strong>一组小型服务</strong> 的方法，每个服务运行在自己的进程中，通过轻量级机制（通常是 HTTP RESTful API）进行通信。</p>
<p>微服务也是面向服务的（Service-Oriented），但与传统 SOA 有本质区别。传统 SOA 倾向于将集成复杂度集中在 ESB（Enterprise Service Bus）中，试图用一个庞然大物来隐藏分布式系统的复杂性；而微服务则主张将智能放在端点（endpoint），保持通信管道的简单。</p>
<p>以下是对原文九个核心特征的重读和展开。</p>
<h2 id="组件化-componentization-与服务-services">组件化（Componentization）与服务（Services）</h2>
<p>Fowler 在文中区分了两种组件化方式：<strong>库（library）</strong> 和 <strong>服务（service）</strong>。库通过函数调用链接到程序中，与程序运行在同一进程；服务则是独立的进程，通过网络调用进行通信。</p>
<p>微服务选择以服务作为组件化的主要手段，其核心优势是 <strong>独立部署性</strong>（independently deployable）。修改一个库通常需要重新部署整个应用，而修改一个服务只需要重新部署该服务本身。</p>
<p>但服务化也引入了代价：</p>
<ul>
<li><strong>远程调用的开销</strong>：进程间通信比进程内调用慢几个数量级，且需要处理网络分区、超时等问题</li>
<li><strong>接口契约的刚性</strong>：服务间的 API 变更需要更谨慎的版本管理，因为调用方和被调用方是独立部署的</li>
<li><strong>分布式系统的固有复杂性</strong>：跨服务的事务、一致性、调试和监控都比单体应用困难</li>
</ul>
<p>Fowler 在文中坦承，服务边界的划分是一门艺术。划分得太细会导致&quot;分布式单体&quot;（distributed monolith）——服务之间高度耦合，失去了独立部署的优势；划分得太粗则退化为传统的单体应用。</p>
<h2 id="围绕业务功能的组织-organized-around-business-capabilities">围绕业务功能的组织（Organized around Business Capabilities）</h2>
<p>这一条直接引用了 <strong>Conway 定律</strong>（Conway’s Law）：</p>
<blockquote>
<p>Any organization that designs a system will produce a design whose structure is a copy of the organization’s communication structure.</p>
</blockquote>
<p>传统的团队组织方式是按技术层次划分：前端团队、后端团队、DBA 团队。这种划分方式下，一个业务需求的变更往往需要跨多个团队协调，导致沟通成本高、交付速度慢。</p>
<p>微服务主张 <strong>按业务功能（business capability）组织团队</strong>，每个团队拥有一个或多个服务的完整技术栈——从 UI 到数据库。这种组织方式的好处是：</p>
<ul>
<li>团队对业务领域有完整的理解，能做出更好的技术决策</li>
<li>变更通常在团队内部闭环，减少跨团队协调</li>
<li>团队规模保持在&quot;两个披萨&quot;（two-pizza team）的范围内，沟通效率高</li>
</ul>
<p>这与 DDD（Domain-Driven Design）中的 <strong>限界上下文（Bounded Context）</strong> 概念高度吻合：每个微服务对应一个限界上下文，拥有自己的领域模型和通用语言（Ubiquitous Language）。</p>
<h2 id="产品而非项目-products-not-projects">产品而非项目（Products not Projects）</h2>
<p>传统的软件开发模式是&quot;项目制&quot;：开发团队按照需求交付软件，然后移交给运维团队维护。开发团队对软件的后续运行状况不再负责。</p>
<p>Fowler 引用了 Amazon 的理念：<strong>“You build it, you run it”</strong>。微服务团队应该对服务的 <strong>全生命周期</strong> 负责——从设计、开发、测试到部署、监控和运维。</p>
<p>这种产品思维带来的改变是：</p>
<ul>
<li>开发者会更关注软件的运行时行为，因为半夜被 oncall 叫醒的是自己</li>
<li>团队会主动投资于可观测性（observability）、自动化运维等&quot;非功能性&quot;能力</li>
<li>服务的质量和稳定性成为团队的核心 KPI，而非仅仅是功能交付</li>
</ul>
<h2 id="智能端点与哑管道-smart-endpoints-and-dumb-pipes">智能端点与哑管道（Smart Endpoints and Dumb Pipes）</h2>
<p>这是微服务与传统 SOA 最鲜明的区别之一。</p>
<p>传统 SOA 倾向于将大量逻辑放在通信基础设施中：ESB 负责消息路由、协议转换、编排、转换等。这导致 ESB 成为系统中最复杂、最难维护的组件。</p>
<p>微服务的理念恰好相反：<strong>让通信管道尽可能简单（dumb pipes），将智能放在端点（smart endpoints）</strong>。这类似于 Unix 的设计哲学——每个程序做好一件事，通过管道（pipe）组合。</p>
<p>Fowler 提到了两种常见的通信方式：</p>
<ul>
<li><strong>RESTful HTTP</strong>：基于资源的 API 设计，利用 HTTP 协议本身的语义（GET/POST/PUT/DELETE），无需额外的协议层</li>
<li><strong>轻量级消息队列</strong>：如 RabbitMQ、ZeroMQ，仅负责消息的路由和投递，不包含业务逻辑。与 ESB 的区别在于，消息队列只是一个&quot;哑管道&quot;，所有的业务逻辑都在消息的生产者和消费者中</li>
</ul>
<h2 id="去中心化治理-decentralized-governance">去中心化治理（Decentralized Governance）</h2>
<p>集中式治理倾向于在单一平台上标准化技术栈——所有服务必须使用同一种语言、同一个框架、同一种数据库。这种做法的初衷是降低运维复杂度，但代价是限制了团队的技术选择自由。</p>
<p>微服务主张 <strong>去中心化的技术治理</strong>：每个团队可以根据服务的特点选择最合适的技术栈。例如：</p>
<ul>
<li>计算密集型服务可以用 C++ 或 Rust</li>
<li>快速迭代的业务服务可以用 Python 或 Node.js</li>
<li>数据处理服务可以用 Scala 或 Java</li>
</ul>
<p>Fowler 特别提到了 Netflix 的做法：Netflix 通过开源其内部工具（Hystrix、Eureka、Zuul 等），让各团队在共享基础设施的同时保持技术选择的自由度。</p>
<p>当然，去中心化治理并不意味着完全没有标准。团队之间仍然需要就 <strong>接口契约</strong>（API 格式、错误码规范）、<strong>可观测性标准</strong>（日志格式、指标命名）和 <strong>安全基线</strong> 达成共识。</p>
<h3 id="lookup-与-discovery：两种服务发现范式的本质区别">Lookup 与 Discovery：两种服务发现范式的本质区别</h3>
<p>在微服务架构中，服务之间的相互调用是常态。如何找到目标服务实例，是微服务治理的核心问题之一。这里需要区分两个常被混淆的概念：<strong>Lookup</strong> 和 <strong>Discovery</strong>。</p>
<h4 id="lookup：基于名称的静态查找">Lookup：基于名称的静态查找</h4>
<p><strong>Lookup</strong> 是命名服务的操作，其核心特征是：</p>
<ul>
<li><strong>基于预知名称</strong>：调用方必须预先知道目标服务的名称（如 JNDI name、DNS 域名），通过名称获取对象引用</li>
<li><strong>能力发现能力弱</strong>：本身不直接支持按能力查找；若需按能力查找，需额外配合 search 或 filter 机制（如 LDAP 的属性查询）</li>
<li><strong>依赖预先配置</strong>：名称与能力的映射在部署时已静态确定，依赖预先配置的目录结构</li>
<li><strong>典型场景</strong>：JNDI、DNS、服务注册表中的静态配置</li>
</ul>
<p>Lookup 假设调用方&quot;知道名字去找东西&quot;，这是一种<strong>静态的、配置驱动</strong>的服务访问方式。</p>
<h4 id="discovery：基于能力的动态发现">Discovery：基于能力的动态发现</h4>
<p><strong>Discovery</strong> 是面向动态环境的服务发现机制，其核心特征是：</p>
<ul>
<li><strong>主动声明能力</strong>：服务注册时主动声明自身能力（如接口、标签、元数据）</li>
<li><strong>按需求匹配</strong>：消费者可按能力需求（如&quot;需要支付功能&quot;）动态匹配可用实例，无需预知具体名称</li>
<li><strong>运行时动态感知</strong>：在运行时动态感知服务能力的变化（如实例扩缩容、故障转移）</li>
<li><strong>典型场景</strong>：Consul、Eureka、etcd、Kubernetes Service</li>
</ul>
<p>Discovery 让调用方&quot;描述需要什么能力，系统动态找到匹配的服务&quot;，这是一种<strong>动态的、能力驱动</strong>的服务访问方式。</p>
<h4 id="两者的核心对比">两者的核心对比</h4>
<table>
<thead>
<tr>
<th>维度</th>
<th>Lookup</th>
<th>Discovery</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>查找依据</strong></td>
<td>预知的名称</td>
<td>服务能力（接口、标签、元数据）</td>
</tr>
<tr>
<td><strong>配置方式</strong></td>
<td>静态配置（部署时确定）</td>
<td>动态注册（运行时更新）</td>
</tr>
<tr>
<td><strong>能力发现</strong></td>
<td>弱（需额外机制）</td>
<td>强（原生支持）</td>
</tr>
<tr>
<td><strong>动态性</strong></td>
<td>低（需人工或脚本更新）</td>
<td>高（自动感知变化）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>稳定的服务架构</td>
<td>动态扩缩容的云原生环境</td>
</tr>
</tbody>
</table>
<h4 id="在微服务中的实践">在微服务中的实践</h4>
<p>现代微服务架构通常采用 <strong>Discovery 模式</strong>，原因包括：</p>
<ol>
<li><strong>弹性伸缩</strong>：服务实例可以动态增减，Discovery 机制能自动感知变化</li>
<li><strong>故障转移</strong>：当实例宕机时，Discovery 能自动剔除不可用实例</li>
<li><strong>多版本共存</strong>：通过标签（如 <code>version=v1</code>、<code>env=production</code>）实现灰度发布</li>
<li><strong>负载均衡</strong>：Discovery 服务通常内置负载均衡策略</li>
</ol>
<p>然而，在某些场景下，<strong>Lookup 仍然有价值</strong>：</p>
<ul>
<li><strong>传统系统集成</strong>：与遗留系统的对接，这些系统可能使用固定的服务名称</li>
<li><strong>性能敏感场景</strong>：Lookup 的静态配置可以减少运行时的查询开销</li>
<li><strong>简单架构</strong>：服务数量少、变化不频繁的小型系统</li>
</ul>
<p>理解两者的本质差异，有助于我们在设计微服务架构时做出更合理的选择：<strong>在需要动态性和弹性的场景下优先使用 Discovery，在需要稳定性和性能的场景下可以考虑 Lookup</strong>。</p>
<h2 id="去中心化数据管理-decentralized-data-management">去中心化数据管理（Decentralized Data Management）</h2>
<p>这是微服务架构中最具争议性的特征之一。</p>
<p>传统单体应用通常共享一个数据库，所有模块通过 SQL JOIN 和事务来保证数据一致性。微服务主张 <strong>每个服务拥有自己的数据库</strong>（Database per Service），其他服务只能通过该服务的 API 访问其数据，不能直接访问其数据库。</p>
<p>这种做法的优势是：</p>
<ul>
<li>服务之间在数据层面完全解耦，可以独立演进数据库 schema</li>
<li>每个服务可以选择最适合自己的数据存储技术（关系型、文档型、图数据库等）</li>
<li>避免了&quot;集成数据库&quot;（integration database）模式下的紧耦合</li>
</ul>
<p>代价是：</p>
<ul>
<li><strong>跨服务查询变得困难</strong>：不能再用 SQL JOIN，需要通过 API 组合或 CQRS（Command Query Responsibility Segregation）模式</li>
<li><strong>分布式事务的复杂性</strong>：不能再依赖数据库事务来保证一致性，需要引入 Saga 模式或最终一致性（eventual consistency）</li>
<li><strong>数据冗余</strong>：不同服务可能需要维护同一份数据的副本</li>
</ul>
<p>Fowler 在文中引用了 DDD 的概念，指出不同服务对同一个业务实体可能有不同的理解（不同的限界上下文），因此共享数据库反而会导致模型的混乱。</p>
<h2 id="基础设施自动化-infrastructure-automation">基础设施自动化（Infrastructure Automation）</h2>
<p>微服务架构下，服务数量从个位数增长到数十甚至数百个，手动部署和运维变得不可行。因此，<strong>持续交付（Continuous Delivery）</strong> 和 <strong>基础设施自动化</strong> 成为微服务的必要前提。</p>
<p>Fowler 提到的关键实践包括：</p>
<ul>
<li><strong>持续集成（CI）</strong>：每次代码提交自动触发构建和测试</li>
<li><strong>持续部署（CD）</strong>：通过自动化流水线将服务部署到各个环境</li>
<li><strong>基础设施即代码（Infrastructure as Code）</strong>：使用 Terraform、Ansible 等工具管理基础设施</li>
<li><strong>自动化测试</strong>：包括单元测试、集成测试、契约测试（contract testing）和端到端测试</li>
</ul>
<p>文章发表于 2014 年，当时 Docker 刚刚兴起，Kubernetes 尚未发布。如今回看，容器化和容器编排技术的成熟极大地降低了微服务部署和运维的门槛，验证了 Fowler 对基础设施自动化重要性的判断。</p>
<h2 id="容错性设计-design-for-failure">容错性设计（Design for Failure）</h2>
<p>在单体应用中，一个组件的故障通常导致整个应用不可用。微服务架构下，服务之间通过网络通信，任何一次远程调用都可能因为网络故障、服务宕机或响应超时而失败。</p>
<p>因此，微服务必须 <strong>为失败而设计</strong>（Design for Failure）：</p>
<ul>
<li><strong>断路器模式（Circuit Breaker）</strong>：当下游服务的错误率超过阈值时，自动熔断请求，避免级联故障。Netflix 的 Hystrix 是这一模式的经典实现</li>
<li><strong>超时与重试</strong>：为每个远程调用设置合理的超时时间，并实现幂等性以支持安全重试</li>
<li><strong>舱壁模式（Bulkhead）</strong>：将不同的服务调用隔离在不同的线程池或进程中，防止一个慢服务拖垮整个系统</li>
<li><strong>实时监控与告警</strong>：监控每个服务的关键指标（延迟、错误率、吞吐量），在问题扩大之前及时发现</li>
</ul>
<p>Fowler 强调，微服务团队需要具备 <strong>运维能力</strong>，能够快速检测和响应生产环境中的故障。这与&quot;产品而非项目&quot;的理念一脉相承。</p>
<h2 id="演进式设计-evolutionary-design">演进式设计（Evolutionary Design）</h2>
<p>微服务架构的最后一个特征是 <strong>支持演进式设计</strong>。</p>
<p>Fowler 指出，微服务的关键优势不在于一开始就设计出完美的服务边界，而在于 <strong>当边界划分不合理时，可以相对容易地重构</strong>。与单体应用中模块边界逐渐模糊不同，微服务的进程边界是硬边界，迫使开发者更认真地思考服务间的依赖关系。</p>
<p>演进式设计的实践包括：</p>
<ul>
<li><strong>从单体开始</strong>（Monolith First）：Fowler 在后续文章中明确建议，除非团队已经有丰富的微服务经验，否则应该先构建单体应用，在业务领域理解成熟后再拆分为微服务</li>
<li><strong>可替换性</strong>：设计服务时考虑其可替换性——如果一个服务需要被完全重写，其影响范围应该被限制在该服务内部</li>
<li><strong>版本化是最后手段</strong>：尽量通过向后兼容的 API 演进来避免版本管理的复杂性。Postel 法则（“Be conservative in what you send, be liberal in what you accept”）在这里尤为适用</li>
</ul>
<h1>反思与批判</h1>
<p>重读这篇文章，有几点值得反思：</p>
<ol>
<li>
<p><strong>微服务不是银弹</strong>。Fowler 在文中多次提到微服务的代价（分布式系统复杂性、运维成本、数据一致性挑战），但这些警告在微服务的传播过程中往往被忽略。许多团队在没有足够基础设施和组织能力的情况下盲目采用微服务，反而降低了交付效率。</p>
</li>
<li>
<p><strong>组织结构是前提</strong>。微服务架构本质上是一种组织架构的映射（Conway 定律的逆向应用）。如果组织结构仍然是按技术层次划分的，强行采用微服务只会增加跨团队协调的成本。</p>
</li>
<li>
<p><strong>基础设施成熟度是门槛</strong>。2014 年时，实施微服务需要大量的自建基础设施。如今 Kubernetes、Service Mesh（Istio）、可观测性平台（Prometheus + Grafana）等技术的成熟，大幅降低了这一门槛，但仍然需要团队具备相应的运维能力。</p>
</li>
</ol>
<h1>参考资料</h1>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://martinfowler.com/articles/microservices.html">《Microservices: a definition of this new architectural term》</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://martinfowler.com/bliki/MonolithFirst.html">《MonolithFirst》</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://samnewman.io/books/building_microservices_2nd_edition/">《Building Microservices》 by Sam Newman</a></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2018/03/20/%E9%87%8D%E8%AF%BB-Martin-Fowler-%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BA%E6%96%87%E5%8E%9F%E6%96%87/">https://magicliang.github.io/2018/03/20/%E9%87%8D%E8%AF%BB-Martin-Fowler-%E7%9A%84%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%AE%BA%E6%96%87%E5%8E%9F%E6%96%87/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/">微服务</a><a class="post-meta__tags" href="/tags/%E6%9E%B6%E6%9E%84/">架构</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-102.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2019/12/17/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%9B%B8%E5%85%B3%E6%96%87%E7%8C%AE/" title="微服务相关文献"><img class="cover" src="/img/wall-paper-34.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-17</div><div class="info-item-2">微服务相关文献</div></div><div class="info-2"><div class="info-item-1">《提升团队的微服务落地能力》 </div></div></div></a><a class="pagination-related" href="/2026/02/07/%E9%87%8D%E8%AF%BB-Eric-Evans-%E7%9A%84-DDD-%E8%93%9D%E7%9A%AE%E4%B9%A6/" title="重读 Eric Evans 的 DDD 蓝皮书"><img class="cover" src="/img/wall-paper-166.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-07</div><div class="info-item-2">重读 Eric Evans 的 DDD 蓝皮书</div></div><div class="info-2"><div class="info-item-1">引言 软件系统的复杂性往往被误解为技术问题。在多年的开发实践中，我们习惯了用各种设计模式、架构框架、技术栈来应对复杂性，却忽略了一个根本事实：软件的核心复杂性在于领域本身，而非技术实现。Eric Evans 在《领域驱动设计》一书中提出了这一深刻见解，并给出了一套系统化的方法论——领域驱动设计。 DDD 不是一套必须严格遵守的规范，也不是一个可以简单套用的框架，它是一种思维方式，一种通过深入理解业务领域来构建高质量软件的方法论。重读这本经典著作，让我们重新审视这些核心理念。 通用语言 通用语言是 DDD 的基石。开发团队与领域专家共享同一套语言，这套语言不仅用于沟通，也体现在代码中。代码即文档，文档即代码。 在传统开发模式中，业务专家使用业务术语，技术人员使用技术术语，两者之间存在天然的语言鸿沟。业务需求被翻译成技术文档，技术文档又被翻译成代码，每个翻译环节都会产生信息丢失和误解。通用语言的提出，就是为了消除这种鸿沟。 通用语言应该由开发和业务专家共同构建，在持续的交流中不断完善。它体现在所有方面：需求讨论、文档、代码、测试。当领域专家能够阅读代码并理解其含义时，当开发人员能够直...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">背景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96-componentization-%E4%B8%8E%E6%9C%8D%E5%8A%A1-services"><span class="toc-number">1.1.</span> <span class="toc-text">组件化（Componentization）与服务（Services）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%B4%E7%BB%95%E4%B8%9A%E5%8A%A1%E5%8A%9F%E8%83%BD%E7%9A%84%E7%BB%84%E7%BB%87-organized-around-business-capabilities"><span class="toc-number">1.2.</span> <span class="toc-text">围绕业务功能的组织（Organized around Business Capabilities）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E5%93%81%E8%80%8C%E9%9D%9E%E9%A1%B9%E7%9B%AE-products-not-projects"><span class="toc-number">1.3.</span> <span class="toc-text">产品而非项目（Products not Projects）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E7%AB%AF%E7%82%B9%E4%B8%8E%E5%93%91%E7%AE%A1%E9%81%93-smart-endpoints-and-dumb-pipes"><span class="toc-number">1.4.</span> <span class="toc-text">智能端点与哑管道（Smart Endpoints and Dumb Pipes）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E6%B2%BB%E7%90%86-decentralized-governance"><span class="toc-number">1.5.</span> <span class="toc-text">去中心化治理（Decentralized Governance）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#lookup-%E4%B8%8E-discovery%EF%BC%9A%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E8%8C%83%E5%BC%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.1.</span> <span class="toc-text">Lookup 与 Discovery：两种服务发现范式的本质区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#lookup%EF%BC%9A%E5%9F%BA%E4%BA%8E%E5%90%8D%E7%A7%B0%E7%9A%84%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">Lookup：基于名称的静态查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#discovery%EF%BC%9A%E5%9F%BA%E4%BA%8E%E8%83%BD%E5%8A%9B%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%91%E7%8E%B0"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">Discovery：基于能力的动态发现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E8%80%85%E7%9A%84%E6%A0%B8%E5%BF%83%E5%AF%B9%E6%AF%94"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">两者的核心对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9A%84%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.5.1.4.</span> <span class="toc-text">在微服务中的实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86-decentralized-data-management"><span class="toc-number">1.6.</span> <span class="toc-text">去中心化数据管理（Decentralized Data Management）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD%E8%87%AA%E5%8A%A8%E5%8C%96-infrastructure-automation"><span class="toc-number">1.7.</span> <span class="toc-text">基础设施自动化（Infrastructure Automation）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E9%94%99%E6%80%A7%E8%AE%BE%E8%AE%A1-design-for-failure"><span class="toc-number">1.8.</span> <span class="toc-text">容错性设计（Design for Failure）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%94%E8%BF%9B%E5%BC%8F%E8%AE%BE%E8%AE%A1-evolutionary-design"><span class="toc-number">1.9.</span> <span class="toc-text">演进式设计（Evolutionary Design）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">反思与批判</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>