<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>重新学习 Solidity | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="以下内容还是从 Solidity 文档里摘出来的。 智能合约入门&#x2F;介绍 第一个基本的例子 12345678910111213pragma solidity ^0.4.0;contract SimpleStorage &#123;    uint storedData;    function set(uint x) public &#123;        storedData &#x3D; x;    &amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="重新学习 Solidity">
<meta property="og:url" content="https://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="以下内容还是从 Solidity 文档里摘出来的。 智能合约入门&#x2F;介绍 第一个基本的例子 12345678910111213pragma solidity ^0.4.0;contract SimpleStorage &#123;    uint storedData;    function set(uint x) public &#123;        storedData &#x3D; x;    &amp;">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-100.jpg">
<meta property="article:published_time" content="2018-03-08T08:25:00.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:31.906Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="Ethereum">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-100.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "重新学习 Solidity",
  "url": "https://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/",
  "image": "https://magicliang.github.io/img/wall-paper-100.jpg",
  "datePublished": "2018-03-08T08:25:00.000Z",
  "dateModified": "2025-10-22T08:01:31.906Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '重新学习 Solidity',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-100.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">重新学习 Solidity</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">重新学习 Solidity</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2018-03-08T08:25:00.000Z" title="Created 2018-03-08 16:25:00">2018-03-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:31.906Z" title="Updated 2025-10-22 16:01:31">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">20.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>87mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>以下内容还是从 Solidity 文档里摘出来的。</p>
<h2 id="智能合约入门-介绍">智能合约入门/介绍</h2>
<h3 id="第一个基本的例子">第一个基本的例子</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascripts">pragma solidity ^0.4.0;<br><br>contract SimpleStorage &#123;<br>    uint storedData;<br><br>    function set(uint x) public &#123;<br>        storedData = x;<br>    &#125;<br><br>    function get() public constant returns (uint) &#123;<br>        return storedData;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个 contract 可以被认为是一个类型。<br>
默认的 unint 就是256位的。<br>
storedData 可以被认为是 state variable，状态变量。在 Solidity 的概念里面，这个东西可以被认为是数据库里面的一个槽，可以被函数查询和修改。注意看它不是 public 的，所以没有合成方法。</p>
<p>访问状态变量不需要用 this前缀（在什么 scope 下都不需要吗？）。</p>
<p>这个例子没有限制任何其他人调用修改状态变量的方法。</p>
<h3 id="子货币的例子">子货币的例子</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract <span class="hljs-title class_">Coin</span> &#123;<br>    <span class="hljs-comment">// The keyword &quot;public&quot; makes those variables</span><br>    <span class="hljs-comment">// readable from outside.</span><br>    address public minter;<br>    <span class="hljs-title function_">mapping</span> (<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> uint) public balances;<br><br>    <span class="hljs-comment">// Events allow light clients to react on</span><br>    <span class="hljs-comment">// changes efficiently.</span><br>    event <span class="hljs-title class_">Sent</span>(address <span class="hljs-keyword">from</span>, address to, uint amount);<br><br>    <span class="hljs-comment">// This is the constructor whose code is</span><br>    <span class="hljs-comment">// run only when the contract is created.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Coin</span>(<span class="hljs-params"></span>) public &#123;<br>        minter = msg.<span class="hljs-property">sender</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">mint</span>(<span class="hljs-params">address receiver, uint amount</span>) public &#123;<br>        <span class="hljs-keyword">if</span> (msg.<span class="hljs-property">sender</span> != minter) <span class="hljs-keyword">return</span>;<br>        balances[receiver] += amount;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">send</span>(<span class="hljs-params">address receiver, uint amount</span>) public &#123;<br>        <span class="hljs-keyword">if</span> (balances[msg.<span class="hljs-property">sender</span>] &lt; amount) <span class="hljs-keyword">return</span>;<br>        balances[msg.<span class="hljs-property">sender</span>] -= amount;<br>        balances[receiver] += amount;<br>        <span class="hljs-title class_">Sent</span>(msg.<span class="hljs-property">sender</span>, receiver, amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>address 是160位的类型（问：为什么不是2的整数次幂？如何）。可以用来存储合约地址或者属于外部人的钥匙对（所谓的 msg.sender？）。public 关键字会让编译器自动帮忙生成一个访问器函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">minter</span>(<span class="hljs-params"></span>) <span class="hljs-title function_">returns</span> (address) &#123; <span class="hljs-keyword">return</span> minter; &#125;<br></code></pre></td></tr></table></figure>
<p>而<code>mapping (address =&gt; uint) public balances</code>创造了一个公共状态变量，用 hash 表的形式来把地址映射到整数，其实就是把户头映射到金钱余额。这一个公共变量被<strong>虚拟地初始化</strong>了，所以所有合法的key<strong>都存在</strong>，而它们映射value都是零值（对整数而言，当然应该是0）。因为这个无限大的 map 的存在，所以不可能遍历所有的 key，也不能遍历所有的 value，只能依赖于外部数组来记住有意义的 key。而编译器帮忙生成的函数，则看起来是这个样子的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">balances</span>(<span class="hljs-params">address _account</span>) public view <span class="hljs-title function_">returns</span> (uint) &#123;<br>    <span class="hljs-keyword">return</span> balances[_account];<br>&#125;<br></code></pre></td></tr></table></figure>
<p>也就是说，调用的时候，用类 balances(0x1234567)的方式来获取账户余额？</p>
<p>Event 的定义和我们习惯的就很相似了。但原文中举了一个观察的例子，不知道是在 Web3 api 里面使用，还是在智能合约里面使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Coin</span>.<span class="hljs-title class_">Sent</span>().<span class="hljs-title function_">watch</span>(&#123;&#125;, <span class="hljs-string">&#x27;&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">error, result</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!error) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Coin transfer: &quot;</span> + result.<span class="hljs-property">args</span>.<span class="hljs-property">amount</span> +<br>            <span class="hljs-string">&quot; coins were sent from &quot;</span> + result.<span class="hljs-property">args</span>.<span class="hljs-property">from</span> +<br>            <span class="hljs-string">&quot; to &quot;</span> + result.<span class="hljs-property">args</span>.<span class="hljs-property">to</span> + <span class="hljs-string">&quot;.&quot;</span>);<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Balances now:\n&quot;</span> +<br>            <span class="hljs-string">&quot;Sender: &quot;</span> + <span class="hljs-title class_">Coin</span>.<span class="hljs-property">balances</span>.<span class="hljs-title function_">call</span>(result.<span class="hljs-property">args</span>.<span class="hljs-property">from</span>) +<br>            <span class="hljs-string">&quot;Receiver: &quot;</span> + <span class="hljs-title class_">Coin</span>.<span class="hljs-property">balances</span>.<span class="hljs-title function_">call</span>(result.<span class="hljs-property">args</span>.<span class="hljs-property">to</span>));<br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>当然这个例子也提供了对 balances 函数的调用示例。</p>
<p>Coin 函数就是在创建合约的时候只执行一次不能再被执行的。这个构造器其实显式地把创建合约的 msg（而不只是 sender）以及 tx 和 block 这样的默认变量都保存下来了。对于所有函数而言，msg.sender 永远指向当前这个函数的调用地址。</p>
<p>mint 因为设置了卫语句，所以在不是创建者的调用面前会提前返回。而 send 则可以被任何人调用。</p>
<p>这些转账事件当然不可能被链自带的货币系统反映出来。但因为这个合约自己带了事件，所以可以开发针对它的区块链浏览器。</p>
<h3 id="区块链基础">区块链基础</h3>
<h4 id="事务">事务</h4>
<p>区块链是全局共享的事务型数据库，以太坊甚至可以被认为是一个序列化隔离级别的数据库。所有加入网络的人都可以从这个数据库里读取条目。如果你想改变数据库里的什么👻东西，你创造的交易必须被所有人接受。事务，也就意味着操作是原子化的，事务里的所有操作要么都被完成，要么都没执行。此外，没有人能够篡改已经被应用数据库里的事务。</p>
<p>只有签过名的事务，才能做相应的修改–用密码学和权限隔离来保证安全性。</p>
<h4 id="区块">区块</h4>
<p>一个需要克服的主要障碍是，按照比特币的说法，是所谓的“双花攻击”。也就是如果网络中存在相互矛盾的两笔事务怎么办？</p>
<p>抽象的回答是，你不用担心这个。一个事务的排序总会为你挑选出来，（被选中的）事务会被打包进一个所谓的“区块”里，然后他们会被执行和分发到所有参与节点里面。如果两个合约相互矛盾，那么被排在第二位的合约会被拒绝而不成为区块的一部分。</p>
<p>这些区块行程一个线性序列，区块链这个词就源于此。</p>
<p>作为“顺序挑选机制”（即所谓的“挖矿”）的一部分，区块可能会被回滚，但这种情况只会发生在链的末梢。越多的区块被加到顶部，原来的区块就越不容易被回滚。</p>
<h3 id="以太坊虚拟机">以太坊虚拟机</h3>
<h4 id="概览">概览</h4>
<p>以太坊虚拟机（EVM）是智能合约的运行时。它不只是一个沙盒，而且被完全隔离了，也就是说EVM 不能访问网络、文件系统和其他进程（Fabric 的智能合约理论上没有这个限制）。智能合约甚至受限访问其他智能合约。</p>
<h4 id="账户">账户</h4>
<p>以太坊中有两类账户共享同样的地址空间：由公私钥对（即人类）控制的外部账户以及与合约一同存储的代码控制的合约账户。</p>
<p>外部账户的地址是又公钥控制的，而合约的地址则是在合约创建时决定的（由创建者的地址和从哪个地址里发出的事务数（即 nonce）衍生。）。</p>
<p>不考虑账户是不是存储有代码，两种类型被 EVM 平等对待。</p>
<p>每一个账户有持久化的的键值存储叫 storage，映射256位的字到256位的字。</p>
<p>除此之外，每个账户都有一个以太币（以 wei 为单位）余额，可以通过发送含有以太币的事务进行修改。</p>
<h4 id="事务">事务</h4>
<p>事务是从一个账户发送往另一个账户（另一个账户可以是同一个账户或者特殊的零账户）的消息。它可以包含二进制数据（它的载荷）和以太币。</p>
<p>如果目标账户包含代码，那么代码可以被执行，而载荷则可以被当做输入数据（按，等同于 message call）。</p>
<p>如果目标账户是一个零账户（账户地址是0），事务会产生一个新合约（这也是编程式产生新合约的方法）。创造合约的时候，我们在事务里发送的载荷实际上并不是合约本身，而是能够产生合约的代码。</p>
<p>注意，这个零账户指的是一个 transaction 里面的 to 的零值：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lasso">transaction = &#123;<br>  nonce: <span class="hljs-string">&#x27;0x0&#x27;</span>, <br>  gasLimit: <span class="hljs-string">&#x27;0x6acfc0&#x27;</span>, <span class="hljs-comment">// 7000000</span><br>  gasPrice: <span class="hljs-string">&#x27;0x4a817c800&#x27;</span>, <span class="hljs-comment">// 20000000000</span><br>  <span class="hljs-keyword">to</span>: <span class="hljs-string">&#x27;0x0&#x27;</span>,<br>  value: <span class="hljs-string">&#x27;0x0&#x27;</span>,<br>  <span class="hljs-built_in">data</span>: <span class="hljs-string">&#x27;0xfffff&#x27;</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>具体思辨内容见<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48219716/what-is-address0-in-solidity">此</a>。</p>
<h4 id="gas">Gas</h4>
<p>一创建完成，每个事务总要收取一定量的 gas，用意是为了限制执行事务所需的工作量，并为执行事务付费。当 EVM 执行事务的时候，gas 根据特定规则被逐渐消耗。</p>
<p>gas 加个是由事务创建者设立的，发出（事务的）账户必须付出<code>gas_price * gas</code>的预付款。如果执行之后还有 gas 剩余，它会被原路退回。</p>
<p>如果 gas 在任何时刻被用尽，一个 out-of-gas 异常会被触发，因此会反转当前调用帧对状态的所有修改。</p>
<h4 id="storage-memory-和-stack">Storage， Memory 和 Stack</h4>
<p>每个账户都有一个<strong>持久化的内存区域</strong>，被称作<code>storage</code>。Storage 是一个键值存储，它把256位的字映射到256位的字。不可能在一个合约内部枚举 storage，而读storage也是相对昂贵的， 修改 storage 更是昂贵。一个合约不能读和写它自己的 storage 中自己拥有的部分之外的东西。</p>
<p>第二个内存区域叫做<code>memory</code>，它让合约为每一个消息调用获得了一个全新清理过的实例。memory 是线性的，可以在字节级别被寻址，但读被限制到256位宽，写得可以写8位到256位宽。memory 被字（256位）展开，当访问（不管是读或者写）一个之前没有接触过的内存字（即，一个字内的任何偏移）。在展开的时候，gas 的花费也必须要之丰富。memory 增长的越大，越昂贵（因为它是平方级扩容的）。</p>
<p>EVM 不是个寄存器机器而是个栈机器，所以所有的计算都在一个叫 stack 的区域上执行。栈有一个1024个元素的最大尺寸，并且包含256位的字。只允许通过这种方式从栈顶访问元素：可以拷贝最顶上的16个元素中的一个或者把最顶上的十六个元素中的一个与其下的元素翻转。按：这也就是 stack 里的局部变量表只允许有16个变量的原因。看起来所有的 EVM 语言，包括但不限于 Solidity，都受这个限制影响。其他操作则只能从栈上取最顶上的两个（或一或更多，取决于具体操作）元素并将结果推上栈。当然可能把栈上的元素移动到 storage 和 memory，但不可能在不移除栈顶元素的前提下，访问栈上更深的任意元素。</p>
<h4 id="指令集">指令集</h4>
<p>EVM 的指令集被保持极小规模，以防错误的实现引发共识问题。所有的指令都操作在基本数据类型，256位的字上。常见的算数、位、逻辑和比较操作符是现成的。条件和非条件跳转是可行的。除此之外，合约能够访问当前区块的相关属性比如数字和时间戳。</p>
<h4 id="消息调用">消息调用</h4>
<p>合约可以调用其他合约，或者通过消息调用的方式发送以太币到非合约账户。消息调用类似事务，所以它有源、目标、数据载荷、以太币、gas 和返回值。事实上，所有的事务都包含一个<strong>顶级消息调用</strong>（按：可以理解为元消息调用），它可以创造更多的消息调用。</p>
<p>一个合约决定有多少它的剩余 gas 需要被伴随内部消息调用发送，有多少它想要保留。如果一个 out-of-gas 异常在内部调用发生了（或者任何其他异常），这件事会以一个被放在栈上的错误值作为信号。在这种情况下，只有伴随着这个调用的 gas 被用尽了（按：其它的 gas 没有被用尽）。在 Solidity 中，在这种情况下，调用方合约引发一个手动异常（按：下面传上来的是错误码，在这里才 raise 异常），所以异常状况就在调用栈上被冒泡上去了。</p>
<p>正如已经提到的，被调用的合约（它可以是调用者本身）会收到一个全新的被清理过的内存实例，并且可以访问调用载荷-它会在一个单独的被称作<code>alldata</code> 的区域里被提供。当它执行完成以后，它可以返回数据，数据会被存贮在调用者的预分配内存里的某一个部分。按：类似传统调用栈的返回值寄存器。调用被限制在一个1024的深度上，这意味着对更复杂的操作，循环应该优于递归。</p>
<h4 id="delegatecall-委托调用-callcode-调用代码-和-libraries-库">Delegatecall（委托调用）/Callcode（调用代码） 和 Libraries(库)</h4>
<p>存在消息调用的一个特殊变种，名为 delegatecall，它和一个消息调用完全一样，除了目标地址的代码是在调用方合约的上下文里执行（按：意即，不是在被调用合约上下文里执行），并且 msg.sender 和 msg.value 没有改变它们的值（按：和调用方合约里的值一样）。</p>
<p>这意味着一个合约可以在运行时动态地从其他地址提取代码。存储、当前地址和余额，依旧指向调用方合约，只有代码是从被调用方合约里拿来的。这意味着在 Solidity 中实现库这一特征是可能的：可复用的库代码可以应用到一个合约的存储里，意即，可以（通过复用库）实现复杂的数据结构。</p>
<h4 id="日志">日志</h4>
<p>可以在专门索引过的数据结构里存储数据，这把所有的方法都映射到了区块级别（按：即在区块级别来思考怎么解决相关问题）。被称作log（日志）的特征被 Solidity 用来实现 events（事件）。合约不能在日志被创建后访问它们（即 log 被创建后就不能在内部从任何一个地方被读取了）。但它们可以从链外被读取。由于有一部分 log 数据被存储在布隆过滤器里，所以可以通过有效率和加密安全的方法来搜索其中数据，所以网络对等节点（轻客户端）不需要下载完整的区块就可以发行这些日志。</p>
<h4 id="创建">创建</h4>
<p>合约甚至可以使用特殊的opcode（操作码）创建其他合约（它们并不只是简单地调用零合约地址，这已经是第二种已知的创建合约的方法了）。<strong>创建调用</strong>和普通消息调用的唯一差别是载荷数据被执行了，而结果被当做代码存储。调用者/创建者在栈上接收到新合约的地址。</p>
<h4 id="自毁">自毁</h4>
<p>代码被从区块链上移出的唯一可能性是当一个合约执行<code>selfdestruct</code>操作的时候。地址中存储的剩余以太币会被发送给一个设定好的目标（账户），接着状态（数据库的存储）中的存储和状态将被移除。</p>
<p><strong>即使一个合约的代码中不包含一个到<code>selfdestruct</code>的调用，它仍然可以通过<code>delegatecall</code>和<code>callcode</code>来执行那个操作。</strong></p>
<p><strong>对于老以太坊节点而言，这个珊瑚并不一定是物理删除，也可以是软删除</strong></p>
<p><strong>当前外部账户（即个人的 account）是不能从 state 中移除掉的。按：即合约账户可以被移除</strong></p>
<h2 id="solidity举例">Solidity举例</h2>
<h3 id="选举">选举</h3>
<p>接下来的合约就非常复杂了，它显示了 Solidity 的一大堆优点。它实现了一个投票合约。当然，电子投票的主要问题是如何分配投票权给正确的人群和如何阻止操纵选举。我们不会在这里解决所有的问题，但最起码我们会显式被代理的选举如何完成，并且计票是自动和同时完全透明的。</p>
<p>奥妙就是每一个ballot（投票）一个合约，为每个选项提供一个短名字。然后合约的创建者作为主席会把投票权单独授予每个地址。</p>
<p>地址后面的人可以选择要么自己投票，要么把他们的投票权delegate（委托）一个他们信任的人。</p>
<p>在选举结束的时候，<code>winningProposal()</code>会返回最大投票数的建议。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br><span class="hljs-comment">/// @title Voting with delegation.</span><br>contract <span class="hljs-title class_">Ballot</span> &#123;<br>    <span class="hljs-comment">// This declares a new complex type which will</span><br>    <span class="hljs-comment">// be used for variables later.</span><br>    <span class="hljs-comment">// It will represent a single voter.</span><br>    struct <span class="hljs-title class_">Voter</span> &#123;<br>        uint weight; <span class="hljs-comment">// weight is accumulated by delegation</span><br>        bool voted;  <span class="hljs-comment">// if true, that person already voted</span><br>        address delegate; <span class="hljs-comment">// person delegated to</span><br>        uint vote;   <span class="hljs-comment">// index of the voted proposal</span><br>    &#125;<br><br>    <span class="hljs-comment">// This is a type for a single proposal.</span><br>    struct <span class="hljs-title class_">Proposal</span> &#123;<br>        bytes32 name;   <span class="hljs-comment">// short name (up to 32 bytes)</span><br>        uint voteCount; <span class="hljs-comment">// number of accumulated votes</span><br>    &#125;<br><br>    address public chairperson;<br><br>    <span class="hljs-comment">// This declares a state variable that</span><br>    <span class="hljs-comment">// stores a `Voter` struct for each possible address.</span><br>    <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> <span class="hljs-title class_">Voter</span>) public voters;<br><br>    <span class="hljs-comment">// A dynamically-sized array of `Proposal` structs.</span><br>    <span class="hljs-title class_">Proposal</span>[] public proposals;<br><br>    <span class="hljs-comment">/// Create a new ballot to choose one of `proposalNames`.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Ballot</span>(<span class="hljs-params">bytes32[] proposalNames</span>) public &#123;<br>        chairperson = msg.<span class="hljs-property">sender</span>;<br>        <span class="hljs-comment">// 主席有投票权</span><br>        voters[chairperson].<span class="hljs-property">weight</span> = <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// For each of the provided proposal names,</span><br>        <span class="hljs-comment">// create a new proposal object and add it</span><br>        <span class="hljs-comment">// to the end of the array.</span><br>        <span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; proposalNames.<span class="hljs-property">length</span>; i++) &#123;<br>            <span class="hljs-comment">// `Proposal(&#123;...&#125;)` creates a temporary</span><br>            <span class="hljs-comment">// Proposal object and `proposals.push(...)`</span><br>            <span class="hljs-comment">// appends it to the end of `proposals`.</span><br>            proposals.<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Proposal</span>(&#123;<br>                <span class="hljs-attr">name</span>: proposalNames[i],<br>                <span class="hljs-attr">voteCount</span>: <span class="hljs-number">0</span><br>            &#125;));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Give `voter` the right to vote on this ballot.</span><br>    <span class="hljs-comment">// May only be called by `chairperson`.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">giveRightToVote</span>(<span class="hljs-params">address voter</span>) public &#123;<br>        <span class="hljs-comment">// If the argument of `require` evaluates to `false`,</span><br>        <span class="hljs-comment">// it terminates and reverts all changes to</span><br>        <span class="hljs-comment">// the state and to Ether balances. It is often</span><br>        <span class="hljs-comment">// a good idea to use this if functions are</span><br>        <span class="hljs-comment">// called incorrectly. But watch out, this</span><br>        <span class="hljs-comment">// will currently also consume all provided gas</span><br>        <span class="hljs-comment">// (this is planned to change in the future).</span><br>        <span class="hljs-comment">// require 类似断言，会反转所有的区块链 state，但还是会消耗 gas（这点未来会被修改），这比 return 好吗？</span><br>        <span class="hljs-built_in">require</span>((msg.<span class="hljs-property">sender</span> == chairperson) &amp;&amp; !voters[voter].<span class="hljs-property">voted</span> &amp;&amp; (voters[voter].<span class="hljs-property">weight</span> == <span class="hljs-number">0</span>));<br>        <span class="hljs-comment">// 某个投票者地址获得了投票权</span><br>        voters[voter].<span class="hljs-property">weight</span> = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/// Delegate your vote to the voter `to`.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">delegate</span>(<span class="hljs-params">address to</span>) public &#123;<br>        <span class="hljs-comment">// assigns reference</span><br>        <span class="hljs-comment">// 第一个出现的显式 storage，这证明读成员变量赋给局部变量总是要求 storage 的</span><br>        <span class="hljs-title class_">Voter</span> storage sender = voters[msg.<span class="hljs-property">sender</span>];<br>        <span class="hljs-built_in">require</span>(!sender.<span class="hljs-property">voted</span>);<br><br>        <span class="hljs-comment">// Self-delegation is not allowed.</span><br>        <span class="hljs-built_in">require</span>(to != msg.<span class="hljs-property">sender</span>);<br><br>        <span class="hljs-comment">// Forward the delegation as long as</span><br>        <span class="hljs-comment">// `to` also delegated.</span><br>        <span class="hljs-comment">// In general, such loops are very dangerous,</span><br>        <span class="hljs-comment">// because if they run too long, they might</span><br>        <span class="hljs-comment">// need more gas than is available in a block.</span><br>        <span class="hljs-comment">// In this case, the delegation will not be executed,</span><br>        <span class="hljs-comment">// but in other situations, such loops might</span><br>        <span class="hljs-comment">// cause a contract to get &quot;stuck&quot; completely.</span><br>        <span class="hljs-comment">// 这里使用了一个可以比较零地址的例子，证明不可以直接 != 0来比较</span><br>        <span class="hljs-comment">// 在现实中这样的循环可能很耗 gas</span><br>        <span class="hljs-keyword">while</span> (voters[to].<span class="hljs-property">delegate</span> != <span class="hljs-title function_">address</span>(<span class="hljs-number">0</span>)) &#123;<br>            to = voters[to].<span class="hljs-property">delegate</span>;<br><br>            <span class="hljs-comment">// We found a loop in the delegation, not allowed.</span><br>            <span class="hljs-comment">// 内置 required 断言</span><br>            <span class="hljs-built_in">require</span>(to != msg.<span class="hljs-property">sender</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Since `sender` is a reference, this</span><br>        <span class="hljs-comment">// modifies `voters[msg.sender].voted`</span><br>        <span class="hljs-comment">// 把被委托者的旧值作废掉</span><br>        sender.<span class="hljs-property">voted</span> = <span class="hljs-literal">true</span>;<br>        sender.<span class="hljs-property">delegate</span> = to;<br>        <span class="hljs-title class_">Voter</span> storage delegate = voters[to];<br>        <span class="hljs-keyword">if</span> (delegate.<span class="hljs-property">voted</span>) &#123;<br>            <span class="hljs-comment">// If the delegate already voted,</span><br>            <span class="hljs-comment">// directly add to the number of votes</span><br>            proposals[delegate.<span class="hljs-property">vote</span>].<span class="hljs-property">voteCount</span> += sender.<span class="hljs-property">weight</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// If the delegate did not vote yet,</span><br>            <span class="hljs-comment">// add to her weight.</span><br>            delegate.<span class="hljs-property">weight</span> += sender.<span class="hljs-property">weight</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 每一个合约都是</span><br>    <span class="hljs-comment">/// Give your vote (including votes delegated to you)</span><br>    <span class="hljs-comment">/// to proposal `proposals[proposal].name`.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">vote</span>(<span class="hljs-params">uint proposal</span>) public &#123;<br>        <span class="hljs-title class_">Voter</span> storage sender = voters[msg.<span class="hljs-property">sender</span>];<br>        <span class="hljs-built_in">require</span>(!sender.<span class="hljs-property">voted</span>);<br>        sender.<span class="hljs-property">voted</span> = <span class="hljs-literal">true</span>;<br>        sender.<span class="hljs-property">vote</span> = proposal;<br><br>        <span class="hljs-comment">// If `proposal` is out of the range of the array,</span><br>        <span class="hljs-comment">// this will throw automatically and revert all</span><br>        <span class="hljs-comment">// changes.</span><br>        proposals[proposal].<span class="hljs-property">voteCount</span> += sender.<span class="hljs-property">weight</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/// @dev Computes the winning proposal taking all</span><br>    <span class="hljs-comment">/// previous votes into account.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">winningProposal</span>(<span class="hljs-params"></span>) public view<br>            <span class="hljs-title function_">returns</span> (uint winningProposal)<br>    &#123;<br>        <span class="hljs-comment">// solidity 的 dummy 数值对象就是这样写的了</span><br>        uint winningVoteCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 注意，这个 proposals 是数组，winner 其实只是这个数组的一个索引</span><br>        <span class="hljs-keyword">for</span> (uint p = <span class="hljs-number">0</span>; p &lt; proposals.<span class="hljs-property">length</span>; p++) &#123;<br>            <span class="hljs-keyword">if</span> (proposals[p].<span class="hljs-property">voteCount</span> &gt; winningVoteCount) &#123;<br>                winningVoteCount = proposals[p].<span class="hljs-property">voteCount</span>;<br>                winningProposal = p;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Calls winningProposal() function to get the index</span><br>    <span class="hljs-comment">// of the winner contained in the proposals array and then</span><br>    <span class="hljs-comment">// returns the name of the winner</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">winnerName</span>(<span class="hljs-params"></span>) public view<br>            <span class="hljs-title function_">returns</span> (bytes32 winnerName)<br>    &#123;<br>        winnerName = proposals[<span class="hljs-title function_">winningProposal</span>()].<span class="hljs-property">name</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个合约可以提升的地方，就是怎样提升事务的效率？</p>
<h3 id="盲拍卖">盲拍卖</h3>
<h4 id="简单拍卖">简单拍卖</h4>
<p>接下来出现的简单明拍卖合约的大意是每个人都可以在投标期内把投标投出去。投标已经包含了发送金钱/以太币，以把投标者和投标绑定起来。如果最高投标上升了，前一个最高投标者会拿回她的钱。在投标周期的最后，合约要让受益人手动调用来获得它的钱，合约不能激活它自己。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br>contract <span class="hljs-title class_">SimpleAuction</span> &#123;<br>    <span class="hljs-comment">// 卖东西的人</span><br>    <span class="hljs-comment">// Parameters of the auction. Times are either</span><br>    <span class="hljs-comment">// absolute unix timestamps (seconds since 1970-01-01)</span><br>    <span class="hljs-comment">// or time periods in seconds.</span><br>    address public beneficiary;<br>    <span class="hljs-comment">// 用整数来表示时间</span><br>    uint public auctionEnd;<br><br>    <span class="hljs-comment">// 当前最高投标者的地址</span><br>    <span class="hljs-comment">// Current state of the auction.</span><br>    address public highestBidder;<br>    <span class="hljs-comment">// 最高的投标</span><br>    uint public highestBid;<br><br>    <span class="hljs-comment">// 受许可的之前投标的退款，在这里 withdrawal 等于 refund 了</span><br>    <span class="hljs-comment">// Allowed withdrawals of previous bids</span><br>    <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> uint) pendingReturns;<br><br>    <span class="hljs-comment">// Set to true at the end, disallows any change</span><br>    bool ended;<br><br>    <span class="hljs-comment">// Events that will be fired on changes.</span><br>    event <span class="hljs-title class_">HighestBidIncreased</span>(address bidder, uint amount);<br>    event <span class="hljs-title class_">AuctionEnded</span>(address winner, uint amount);<br>    <br>    <span class="hljs-comment">// 三斜杠的是提示符评论，可以提示用户是否确认一个事务</span><br>    <span class="hljs-comment">// The following is a so-called natspec comment,</span><br>    <span class="hljs-comment">// recognizable by the three slashes.</span><br>    <span class="hljs-comment">// It will be shown when the user is asked to</span><br>    <span class="hljs-comment">// confirm a transaction.</span><br><br>    <span class="hljs-comment">/// Create a simple auction with `_biddingTime`</span><br>    <span class="hljs-comment">/// seconds bidding time on behalf of the</span><br>    <span class="hljs-comment">/// beneficiary address `_beneficiary`.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">SimpleAuction</span>(<span class="hljs-params"></span><br><span class="hljs-params">        uint _biddingTime,</span><br><span class="hljs-params">        address _beneficiary</span><br><span class="hljs-params">    </span>) public &#123;<br>        beneficiary = _beneficiary;<br>        <span class="hljs-comment">// 看来 now 也是秒数的意思。换言之，没有毫秒数。</span><br>        auctionEnd = now + _biddingTime;<br>    &#125;<br><br>    <span class="hljs-comment">/// Bid on the auction with the value sent</span><br>    <span class="hljs-comment">/// together with this transaction.</span><br>    <span class="hljs-comment">/// The value will only be refunded if the</span><br>    <span class="hljs-comment">/// auction is not won.</span><br>    <span class="hljs-comment">// payable 就是拿来修饰 function 的，所以它是 payble 的。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bid</span>(<span class="hljs-params"></span>) public payable &#123;<br>        <span class="hljs-comment">// No arguments are necessary, all</span><br>        <span class="hljs-comment">// information is already part of</span><br>        <span class="hljs-comment">// the transaction. The keyword payable</span><br>        <span class="hljs-comment">// is required for the function to</span><br>        <span class="hljs-comment">// be able to receive Ether.</span><br><br>        <span class="hljs-comment">// Revert the call if the bidding</span><br>        <span class="hljs-comment">// period is over.</span><br>        <span class="hljs-built_in">require</span>(now &lt;= auctionEnd);<br><br>        <span class="hljs-comment">// If the bid is not higher, send the</span><br>        <span class="hljs-comment">// money back.</span><br>        <span class="hljs-comment">// 这个 payable 的合约也可以被断言所中断</span><br>        <span class="hljs-built_in">require</span>(msg.<span class="hljs-property">value</span> &gt; highestBid);<br>        <br>        <span class="hljs-comment">// 最高投标者的地址的另一种比对方法</span><br>        <span class="hljs-keyword">if</span> (highestBidder != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Sending back the money by simply using</span><br>            <span class="hljs-comment">// highestBidder.send(highestBid) is a security risk</span><br>            <span class="hljs-comment">// because it could execute an untrusted contract.</span><br>            <span class="hljs-comment">// It is always safer to let the recipients</span><br>            <span class="hljs-comment">// withdraw their money themselves.</span><br>            pendingReturns[highestBidder] += highestBid;<br>        &#125;<br>        highestBidder = msg.<span class="hljs-property">sender</span>;<br>        highestBid = msg.<span class="hljs-property">value</span>;<br>        <span class="hljs-title class_">HighestBidIncreased</span>(msg.<span class="hljs-property">sender</span>, msg.<span class="hljs-property">value</span>);<br>        <br>        <span class="hljs-comment">// 这个方法没有任何直接摸合约 account 的地方，但这个payable 方法的内容里处处充满了 msg.value</span><br>    &#125;<br><br>    <span class="hljs-comment">/// Withdraw a bid that was overbid.</span><br>    <span class="hljs-comment">//  这个退款函数是谁来调用 ?</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">withdraw</span>(<span class="hljs-params"></span>) public <span class="hljs-title function_">returns</span> (bool) &#123;<br>        uint amount = pendingReturns[msg.<span class="hljs-property">sender</span>];<br>        <span class="hljs-keyword">if</span> (amount &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// It is important to set this to zero because the recipient</span><br>            <span class="hljs-comment">// can call this function again as part of the receiving call</span><br>            <span class="hljs-comment">// before `send` returns.</span><br>            pendingReturns[msg.<span class="hljs-property">sender</span>] = <span class="hljs-number">0</span>;<br><br>            <span class="hljs-keyword">if</span> (!msg.<span class="hljs-property">sender</span>.<span class="hljs-title function_">send</span>(amount)) &#123;<br>                <span class="hljs-comment">// No need to call throw here, just reset the amount owing</span><br>                pendingReturns[msg.<span class="hljs-property">sender</span>] = amount;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/// End the auction and send the highest bid</span><br>    <span class="hljs-comment">/// to the beneficiary.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">auctionEnd</span>(<span class="hljs-params"></span>) public &#123;<br>        <span class="hljs-comment">// It is a good guideline to structure functions that interact</span><br>        <span class="hljs-comment">// with other contracts (i.e. they call functions or send Ether)</span><br>        <span class="hljs-comment">// into three phases:</span><br>        <span class="hljs-comment">// 1. checking conditions</span><br>        <span class="hljs-comment">// 2. performing actions (potentially changing conditions)</span><br>        <span class="hljs-comment">// 3. interacting with other contracts</span><br>        <span class="hljs-comment">// If these phases are mixed up, the other contract could call</span><br>        <span class="hljs-comment">// back into the current contract and modify the state or cause</span><br>        <span class="hljs-comment">// effects (ether payout) to be performed multiple times.</span><br>        <span class="hljs-comment">// If functions called internally include interaction with external</span><br>        <span class="hljs-comment">// contracts, they also have to be considered interaction with</span><br>        <span class="hljs-comment">// external contracts.</span><br><br>        <span class="hljs-comment">// 1. Conditions</span><br>        <span class="hljs-built_in">require</span>(now &gt;= auctionEnd); <span class="hljs-comment">// auction did not yet end</span><br>        <span class="hljs-built_in">require</span>(!ended); <span class="hljs-comment">// this function has already been called</span><br><br>        <span class="hljs-comment">// 2. Effects</span><br>        ended = <span class="hljs-literal">true</span>;<br>        <span class="hljs-title class_">AuctionEnded</span>(highestBidder, highestBid);<br><br>        <span class="hljs-comment">// 3. Interaction</span><br>        beneficiary.<span class="hljs-title function_">transfer</span>(highestBid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="盲拍卖">盲拍卖</h4>
<p>盲拍卖的优点是没有向着拍卖终点的时间压力。</p>
<p>简化一个盲拍卖模型。用户先用头标志的 hash 投标。投标结束后大家揭示出自己的投标值，同时校验 hash 是否相同以及数值是否最高。</p>
<p>为了防止有些人拍完不给钱，这个合约还进一步要求大家把价值和投标一起发送，前者自然是明文的，而后者是加密的。为了不暴露隐私，合约接受一切附带的价值高于当前最高投标价的新投标转账。这也就意味着，在价值揭示环节，有些投标是无效的不成立的。投标者甚至可以用一些错误的高投标或者低投标来迷惑整个竞争。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br>contract <span class="hljs-title class_">BlindAuction</span> &#123;<br>    struct <span class="hljs-title class_">Bid</span> &#123;<br>        bytes32 blindedBid;<br>        <span class="hljs-comment">// 锁死存款</span><br>        uint deposit;<br>    &#125;<br><br>    address public beneficiary;<br>    uint public biddingEnd;<br>    uint public revealEnd;<br>    bool public ended;<br><br>    <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> <span class="hljs-title class_">Bid</span>[]) public bids;<br><br>    address public highestBidder;<br>    uint public highestBid;<br><br>    <span class="hljs-comment">// Allowed withdrawals of previous bids</span><br>    <span class="hljs-title function_">mapping</span>(<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> uint) pendingReturns;<br><br>    event <span class="hljs-title class_">AuctionEnded</span>(address winner, uint highestBid);<br><br>    <span class="hljs-comment">/// Modifiers are a convenient way to validate inputs to</span><br>    <span class="hljs-comment">/// functions. `onlyBefore` is applied to `bid` below:</span><br>    <span class="hljs-comment">/// The new function body is the modifier&#x27;s body where</span><br>    <span class="hljs-comment">/// `_` is replaced by the old function body.</span><br>    <span class="hljs-comment">// modifier 有点像装饰器，结合了 require，_指的就是被修饰方法的 body</span><br>    modifier <span class="hljs-title function_">onlyBefore</span>(<span class="hljs-params">uint _time</span>) &#123; <span class="hljs-built_in">require</span>(now &lt; _time); _; &#125;<br>    modifier <span class="hljs-title function_">onlyAfter</span>(<span class="hljs-params">uint _time</span>) &#123; <span class="hljs-built_in">require</span>(now &gt; _time); _; &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">BlindAuction</span>(<span class="hljs-params"></span><br><span class="hljs-params">        uint _biddingTime,</span><br><span class="hljs-params">        uint _revealTime,</span><br><span class="hljs-params">        address _beneficiary</span><br><span class="hljs-params">    </span>) public &#123;<br>        beneficiary = _beneficiary;<br>        <span class="hljs-comment">// 在这里直接拿起点时间戳来生成接下来的时间节点就行了</span><br>        biddingEnd = now + _biddingTime;<br>        revealEnd = biddingEnd + _revealTime;<br>    &#125;<br><br>    <span class="hljs-comment">// keccak 函数是 SHA-3函数的别名，被以太坊更名过的函数。SHA-256实际上是 SHA-2 的一个子类型，keccak 算法是下一代的 SHA-3算法，是最强的散列算法。http://www.atool.org/hash.php</span><br>    <span class="hljs-comment">// keccak 是个松散参数函数，所有的输入都是散列的种子，会被函数直接拼接起来，类似分段签名相加的思路。</span><br>    <span class="hljs-comment">/// Place a blinded bid with `_blindedBid` = keccak256(value,</span><br>    <span class="hljs-comment">/// fake, secret).</span><br>    <span class="hljs-comment">/// The sent ether is only refunded if the bid is correctly</span><br>    <span class="hljs-comment">/// revealed in the revealing phase. The bid is valid if the</span><br>    <span class="hljs-comment">/// ether sent together with the bid is at least &quot;value&quot; and</span><br>    <span class="hljs-comment">/// &quot;fake&quot; is not true. Setting &quot;fake&quot; to true and sending</span><br>    <span class="hljs-comment">/// not the exact amount are ways to hide the real bid but</span><br>    <span class="hljs-comment">/// still make the required deposit. The same address can</span><br>    <span class="hljs-comment">/// place multiple bids.</span><br>    <span class="hljs-comment">// 一个地址可以做多个投标。只有被正确亮出的投标值才会被返还（其他的投标值就不返还了吗？）。只有附带的投标值大于等于value（这是什么意思？）而且 fake 不是 true。设置 fake 为 true 而且发送不准确的数额是隐藏真实投标但满足要求的锁定存款的方法。</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">bid</span>(<span class="hljs-params">bytes32 _blindedBid</span>)<br>        public<br>        payable<br>        <span class="hljs-title function_">onlyBefore</span>(<span class="hljs-params">biddingEnd</span>)<br>    &#123;<br>        bids[msg.<span class="hljs-property">sender</span>].<span class="hljs-title function_">push</span>(<span class="hljs-title class_">Bid</span>(&#123;<br>            <span class="hljs-attr">blindedBid</span>: _blindedBid,<br>            <span class="hljs-attr">deposit</span>: msg.<span class="hljs-property">value</span><br>        &#125;));<br>    &#125;<br>    <br>    <span class="hljs-comment">// 亮标。用户可以得到所有被正确掩盖的错标，和除了最高标以外的所有标。</span><br>    <span class="hljs-comment">/// Reveal your blinded bids. You will get a refund for all</span><br>    <span class="hljs-comment">/// correctly blinded invalid bids and for all bids except for</span><br>    <span class="hljs-comment">/// the totally highest.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">reveal</span>(<span class="hljs-params"></span><br><span class="hljs-params">        uint[] _values,</span><br><span class="hljs-params">        bool[] _fake,</span><br><span class="hljs-params">        bytes32[] _secret</span><br><span class="hljs-params">    </span>)<br>        public<br>        <span class="hljs-title function_">onlyAfter</span>(biddingEnd)<br>        <span class="hljs-title function_">onlyBefore</span>(<span class="hljs-params">revealEnd</span>)<br>    &#123;<br>        uint length = bids[msg.<span class="hljs-property">sender</span>].<span class="hljs-property">length</span>;<br>        <span class="hljs-built_in">require</span>(_values.<span class="hljs-property">length</span> == length);<br>        <span class="hljs-built_in">require</span>(_fake.<span class="hljs-property">length</span> == length);<br>        <span class="hljs-built_in">require</span>(_secret.<span class="hljs-property">length</span> == length);<br><br>        uint refund;<br>        <span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">var</span> bid = bids[msg.<span class="hljs-property">sender</span>][i];<br>            <span class="hljs-title function_">var</span> (value, fake, secret) =<br>                    (_values[i], _fake[i], _secret[i]);<br>            <span class="hljs-keyword">if</span> (bid.<span class="hljs-property">blindedBid</span> != <span class="hljs-title function_">keccak256</span>(value, fake, secret)) &#123;<br>                <span class="hljs-comment">// Bid was not actually revealed.</span><br>                <span class="hljs-comment">// Do not refund deposit.</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            refund += bid.<span class="hljs-property">deposit</span>;<br>            <span class="hljs-comment">// deposit 是实际存入的锁定价值，value 是用来做散列种子的声称价值</span><br>            <span class="hljs-keyword">if</span> (!fake &amp;&amp; bid.<span class="hljs-property">deposit</span> &gt;= value) &#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-title function_">placeBid</span>(msg.<span class="hljs-property">sender</span>, value))<br>                    refund -= value;<br>            &#125;<br>            <span class="hljs-comment">// 因为以太坊可以被认为是序列化的事务隔离级别的，所以在这里置零可以抗并发问题</span><br>            <span class="hljs-comment">// Make it impossible for the sender to re-claim</span><br>            <span class="hljs-comment">// the same deposit.</span><br>            bid.<span class="hljs-property">blindedBid</span> = <span class="hljs-title function_">bytes32</span>(<span class="hljs-number">0</span>);<br>        &#125;<br>        msg.<span class="hljs-property">sender</span>.<span class="hljs-title function_">transfer</span>(refund);<br>    &#125;<br><br>    <span class="hljs-comment">// internal 的第一个用法，internal 函数类似 private，只能在合约内部使用了。</span><br>    <span class="hljs-comment">// This is an &quot;internal&quot; function which means that it</span><br>    <span class="hljs-comment">// can only be called from the contract itself (or from</span><br>    <span class="hljs-comment">// derived contracts).</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">placeBid</span>(<span class="hljs-params">address bidder, uint value</span>) internal<br>            <span class="hljs-title function_">returns</span> (bool success)<br>    &#123;<br>        <span class="hljs-comment">// 不中标。所以在这里 place 就是放标的意思？</span><br>        <span class="hljs-keyword">if</span> (value &lt;= highestBid) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (highestBidder != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 先把之前的最高标放进退款名单里面</span><br>            <span class="hljs-comment">// Refund the previously highest bidder.</span><br>            pendingReturns[highestBidder] += highestBid;<br>        &#125;<br>        <span class="hljs-comment">// 替换最高标</span><br>        highestBid = value;<br>        highestBidder = bidder;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/// Withdraw a bid that was overbid.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">withdraw</span>(<span class="hljs-params"></span>) public &#123;<br>        uint amount = pendingReturns[msg.<span class="hljs-property">sender</span>];<br>        <span class="hljs-keyword">if</span> (amount &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// It is important to set this to zero because the recipient</span><br>            <span class="hljs-comment">// can call this function again as part of the receiving call</span><br>            <span class="hljs-comment">// before `transfer` returns (see the remark above about</span><br>            <span class="hljs-comment">// conditions -&gt; effects -&gt; interaction).</span><br>            pendingReturns[msg.<span class="hljs-property">sender</span>] = <span class="hljs-number">0</span>;<br><br>            msg.<span class="hljs-property">sender</span>.<span class="hljs-title function_">transfer</span>(amount);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 在拍卖结束的时候把投标款转走。</span><br>    <span class="hljs-comment">/// End the auction and send the highest bid</span><br>    <span class="hljs-comment">/// to the beneficiary.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">auctionEnd</span>(<span class="hljs-params"></span>)<br>        public<br>        <span class="hljs-title function_">onlyAfter</span>(<span class="hljs-params">revealEnd</span>)<br>    &#123;<br>        <span class="hljs-built_in">require</span>(!ended);<br>        <span class="hljs-title class_">AuctionEnded</span>(highestBidder, highestBid);<br>        ended = <span class="hljs-literal">true</span>;<br>        beneficiary.<span class="hljs-title function_">transfer</span>(highestBid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>到目前为止，每个合约只有一个 payable 方法。</p>
<h3 id="安全的远程购买">安全的远程购买</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs javascript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br>contract <span class="hljs-title class_">Purchase</span> &#123;<br>    uint public value;<br>    address public seller;<br>    address public buyer;<br>    enum <span class="hljs-title class_">State</span> &#123; <span class="hljs-title class_">Created</span>, <span class="hljs-title class_">Locked</span>, <span class="hljs-title class_">Inactive</span> &#125;<br>    <span class="hljs-title class_">State</span> public state;<br><br>    <span class="hljs-comment">// 确认价值是偶数（为什么？）。由卖方初始化合约。这是第一个构造函数也是 payable 的合约。初始化合约的 value，大致等于一个买卖的押金。</span><br>    <span class="hljs-comment">// Ensure that `msg.value` is an even number.</span><br>    <span class="hljs-comment">// Division will truncate if it is an odd number.</span><br>    <span class="hljs-comment">// Check via multiplication that it wasn&#x27;t an odd number.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">Purchase</span>(<span class="hljs-params"></span>) public payable &#123;<br>        seller = msg.<span class="hljs-property">sender</span>;<br>        value = msg.<span class="hljs-property">value</span> / <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">require</span>((<span class="hljs-number">2</span> * value) == msg.<span class="hljs-property">value</span>);<br>    &#125;<br><br>    modifier <span class="hljs-title function_">condition</span>(<span class="hljs-params">bool _condition</span>) &#123;<br>        <span class="hljs-built_in">require</span>(_condition);<br>        _;<br>    &#125;<br><br>    modifier <span class="hljs-title function_">onlyBuyer</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">require</span>(msg.<span class="hljs-property">sender</span> == buyer);<br>        _;<br>    &#125;<br><br>    modifier <span class="hljs-title function_">onlySeller</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">require</span>(msg.<span class="hljs-property">sender</span> == seller);<br>        _;<br>    &#125;<br><br>    modifier <span class="hljs-title function_">inState</span>(<span class="hljs-params">State _state</span>) &#123;<br>        <span class="hljs-built_in">require</span>(state == _state);<br>        _;<br>    &#125;<br><br>    event <span class="hljs-title class_">Aborted</span>();<br>    event <span class="hljs-title class_">PurchaseConfirmed</span>();<br>    event <span class="hljs-title class_">ItemReceived</span>();<br><br>    <span class="hljs-comment">/// Abort the purchase and reclaim the ether.</span><br>    <span class="hljs-comment">/// Can only be called by the seller before</span><br>    <span class="hljs-comment">/// the contract is locked.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">abort</span>(<span class="hljs-params"></span>)<br>        public<br>        onlySeller<br>        <span class="hljs-title function_">inState</span>(<span class="hljs-params">State.Created</span>)<br>    &#123;<br>        <span class="hljs-title class_">Aborted</span>();<br>        state = <span class="hljs-title class_">State</span>.<span class="hljs-property">Inactive</span>;<br>        <span class="hljs-comment">// 这个 balance 就是合约自带的所有 balance 了，而不是我们自定义的 value 一类的成员变量。</span><br>        seller.<span class="hljs-title function_">transfer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">balance</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/// Confirm the purchase as buyer.</span><br>    <span class="hljs-comment">/// Transaction has to include `2 * value` ether.</span><br>    <span class="hljs-comment">/// The ether will be locked until confirmReceived</span><br>    <span class="hljs-comment">/// is called.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">confirmPurchase</span>(<span class="hljs-params"></span>)<br>        public<br>        <span class="hljs-title function_">inState</span>(<span class="hljs-title class_">State</span>.<span class="hljs-property">Created</span>)<br>        <span class="hljs-title function_">condition</span>(msg.<span class="hljs-property">value</span> == (<span class="hljs-number">2</span> * value))<br>        payable<br>    &#123;   <br>        <span class="hljs-comment">// 发出购买锁定事件</span><br>        <span class="hljs-title class_">PurchaseConfirmed</span>();<br>        buyer = msg.<span class="hljs-property">sender</span>;<br>        state = <span class="hljs-title class_">State</span>.<span class="hljs-property">Locked</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/// Confirm that you (the buyer) received the item.</span><br>    <span class="hljs-comment">/// This will release the locked ether.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">confirmReceived</span>(<span class="hljs-params"></span>)<br>        public<br>        onlyBuyer<br>        <span class="hljs-title function_">inState</span>(<span class="hljs-params">State.Locked</span>)<br>    &#123;<br>        <span class="hljs-comment">// 发出事件</span><br>        <span class="hljs-title class_">ItemReceived</span>();<br>        <span class="hljs-comment">// It is important to change the state first because</span><br>        <span class="hljs-comment">// otherwise, the contracts called using `send` below</span><br>        <span class="hljs-comment">// can call in again here.</span><br>        state = <span class="hljs-title class_">State</span>.<span class="hljs-property">Inactive</span>;<br><br>        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> This actually allows both the buyer and the seller to</span><br>        <span class="hljs-comment">// block the refund - the withdraw pattern should be used.</span><br>        <span class="hljs-comment">// 把押金转给买家，把差额交给卖家。为什么要这样设计？为了避免空口无凭的卖家浪费合约价值？</span><br>        buyer.<span class="hljs-title function_">transfer</span>(value);<br>        seller.<span class="hljs-title function_">transfer</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">balance</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这足以证明一个合约有好几个 payable 方法，允许多角色博弈了。<br>
这个合约没有任何的 internal 函数。</p>
<h2 id="深入solidity">深入Solidity</h2>
<h3 id="solidity-源文件的轮廓">Solidity 源文件的轮廓</h3>
<p>源文件可以包含任意多的合约定义。</p>
<h4 id="版本-pragma">版本 pragma</h4>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// 这个尖角号意味着不能用高于0.5.0的编译器编译。这个数字说明了合约的最小编译器编译器是0.4.0。换言之，要用高级编译器，要 bump up 这个数字。</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br></code></pre></td></tr></table></figure>
<h3 id="引入其他源文件">引入其他源文件</h3>
<h4 id="语法和语义">语法和语义</h4>
<p>Solidity 用类似 JavaScript 的引入语法，但不支持“default export”。在全局层次，你可以用以下形式的引入语句：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">import <span class="hljs-string">&quot;filename&quot;</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>这个语句把该文件名下所有的<strong>全局</strong>符号引入到当前的<strong>全局</strong>作用域中。</p>
<figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> symbolName <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;filename&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>这个语句制造了一个新的全局符号，类似名字空间，所有该文件名下的符号，都是这个新的全局符号的成员。它和<code>import &quot;filename&quot; as symbolName;</code>等价。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> &#123;symbol1 <span class="hljs-keyword">as</span> <span class="hljs-keyword">alias</span>, symbol2&#125; <span class="hljs-keyword">from</span> &quot;filename&quot;;<br></code></pre></td></tr></table></figure>
<p>部分引用和别名机制。</p>
<h4 id="路径">路径</h4>
<p>.和…的机制同 Unix 系统。</p>
<p>要引用同一个文件夹下的文件，用这样的语法<code>mport &quot;./x&quot; as x;</code>。如果你使用了<code>import &quot;x&quot; as x;</code>，一个全局的“include directory”里的同名文件夹会被引用。</p>
<h4 id="重映射问题">重映射问题</h4>
<p>太无聊，直接看文档吧。</p>
<h4 id="注释问题">注释问题</h4>
<p>注意看下面的文档，展示了如何写注释，也展示了如何写多返回值。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs zephir">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">/** <span class="hljs-doctag">@title</span> Shape calculator. */</span><br>contract shapeCalculator &#123;<br>    <span class="hljs-comment">/** <span class="hljs-doctag">@dev</span> Calculates a rectangle&#x27;s surface and perimeter.</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@param</span> w Width of the rectangle.</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@param</span> h Height of the rectangle.</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@return</span> s The calculated surface.</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@return</span> p The calculated perimeter.</span><br><span class="hljs-comment">      */</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rectangle</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> w, <span class="hljs-keyword">uint</span> h)</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> s, <span class="hljs-keyword">uint</span> p)</span> </span>&#123;<br>        s = w * h;<br>        p = <span class="hljs-number">2</span> * (w + h);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="合约的结构">合约的结构</h3>
<p>合约和面向对象程序设计语言里面的 class 很相似。每个合约可以包含<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-state-variables">状态变量</a>、<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-functions">函数</a>、<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-function-modifiers">函数修饰符</a>、<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-events">事件</a>、<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-struct-types">结构类型</a>和<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-enum-types">枚举类型</a>的声明。</p>
<h4 id="状态变量">状态变量</h4>
<p>状态变量会被持久化在合约存储（状态）里：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract SimpleStorage &#123;<br>    <span class="hljs-built_in">uint</span> storedData; <span class="hljs-comment">// State variable</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="函数">函数</h4>
<p>函数是代码的可执行单元。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span>.<span class="hljs-number">0</span>;<br><br>contract SimpleAuction &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">bid</span>() public payable &#123; // <span class="hljs-keyword">Function</span><br>        <span class="hljs-title">//</span> ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/control-structures.html#function-calls">函数调用</a>可以在内部发生，也可以在外部发生，而且面对不同的其他合约可以拥有不同的<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/contracts.html#visibility-and-getters">可见性</a>。</p>
<h4 id="函数修饰符">函数修饰符</h4>
<p>函数修饰符可以以声明的方式修饰函数的语义（见<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/contracts.html#modifiers">Function Modifiers</a>部分）。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br>contract Purchase &#123;<br>    address <span class="hljs-keyword">public</span> seller;<br>    <br>    <span class="hljs-comment">// 总是配合 require 函数使用。还可以看看 revert 什么的函数。</span><br>    <span class="hljs-function">modifier <span class="hljs-title">onlySeller</span>()</span> &#123; <span class="hljs-comment">// Modifier</span><br>        require(msg.sender == seller);<br>        _;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">abort</span>() <span class="hljs-keyword">public</span> onlySeller</span> &#123; <span class="hljs-comment">// Modifier usage</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="事件">事件</h4>
<p>事件就是拿来和 EVM 日志设施打交道的方便接口。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract SimpleAuction &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">event</span> <span class="hljs-title">HighestBidIncreased</span>(<span class="hljs-params">address bidder, <span class="hljs-built_in">uint</span> amount</span>)</span>; <span class="hljs-comment">// Event</span><br><br>    <span class="hljs-function">function <span class="hljs-title">bid</span>() <span class="hljs-keyword">public</span> payable</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        HighestBidIncreased(msg.sender, msg.<span class="hljs-keyword">value</span>); <span class="hljs-comment">// Triggering event</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="struct-类型">Struct 类型</h4>
<p>类似 C 语言，是基本类型的封装组合。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract Ballot &#123;<br>    <span class="hljs-keyword">struct</span> Voter &#123; <span class="hljs-comment">// Struct</span><br>        <span class="hljs-built_in">uint</span> weight;<br>        <span class="hljs-built_in">bool</span> voted;<br>        address <span class="hljs-built_in">delegate</span>;<br>        <span class="hljs-built_in">uint</span> vote;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="枚举类型">枚举类型</h4>
<p>依然类似 Java。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract Purchase &#123;<br>    <span class="hljs-keyword">enum</span> State &#123; Created, Locked, Inactive &#125; <span class="hljs-comment">// Enum</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="类型">类型</h3>
<p>Solidity 是静态类型语言，这意味着不管是状态变量还是局部变量，每个变量的类型必须在运行时被指定好（至少是已知的，见<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/types.html#type-deduction">Type Deduction</a>）。Solidity 提供几个至关重要的类型，可以被组合成复合类型。</p>
<h4 id="值类型">值类型</h4>
<p>以下的类型总是被称作值类型，因为这些类型的变量总是会被传值。他们作为函数参数或者赋值使用的时候，总是会被拷贝。</p>
<h5 id="布尔类型">布尔类型</h5>
<p>bool：可能值为常量 true 或者 false。</p>
<p>逻辑操作符和常见的编程语言操作符类似，也支持<strong>短路操作</strong>。</p>
<h5 id="整型">整型</h5>
<p><code>int</code>/<code>uint</code>：各种尺寸的有符号和无符号整型数。关键字<code>uint8</code>和 <code>unint256</code>以8位为步长，以及<code>int8</code>和<code>int256</code>。相对地，<code>unint</code>和<code>int</code>是<code>uint256</code>和<code>int256</code>的别名（按：即默认数据宽度就是最宽）。</p>
<p>除法总是会造成截断，除非两个操作符都是字面量（？）或者字面量表达式。</p>
<p><code>x &lt;&lt; y</code>等于<code>x * 2**y</code>，而<code>x &gt;&gt; y</code>等于<code>x / 2**y</code>。用负数作 y 可能会出运行时异常-这是因为不同编程语言的移位有向0和向负无穷移位的区别。</p>
<h5 id="定点数">定点数</h5>
<p>定点数在 Solidity 里还没被完全支持。它们可以被声明，但不能被拿来赋值或者取值。</p>
<p><code>fixed</code>/<code>ufixed</code>表达的是不同尺寸的有符号和无符号定点数。关键字<code>ufixedMxN</code>和<code>fixedMxN</code>里，<code>M</code> 代表这个类型可以使用的位数，而<code>N</code>代表的是有多少个小数位可被使用。<code>M</code>必须可被8整除，从8增长到256。<code>N</code>必须在0到80之间。相应地，<code>ufixed</code>和<code>fixed</code>是<code>ufixed128x19</code> 和 <code>fixed128x19</code>的别名。</p>
<p>浮点数（IEEE 754）的小数点位置是可变的，而定点数是不可变的。</p>
<h5 id="地址类型">地址类型</h5>
<p>地址拥有20字节的数据，它也有成员，而且在0.5.0以前是所有合约的基类。在0.5.0之后，合约类型不再从地址类型里衍生出来，但可以被显式地转化为地址。</p>
<p>地址的成员：</p>
<ul>
<li>balance<code>和</code>transfer</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">address x = <span class="hljs-number">0x123</span>;<br>address myAddress = <span class="hljs-variable language_">this</span>;<br><span class="hljs-keyword">if</span> (x.<span class="hljs-property">balance</span> &lt; <span class="hljs-number">10</span> &amp;&amp; myAddress.<span class="hljs-property">balance</span> &gt;= <span class="hljs-number">10</span>) x.<span class="hljs-title function_">transfer</span>(<span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>
<p><strong>特别地，向合约地址调用 transfer 的时候，每个合约地址的 fallback 函数会被调用。</strong></p>
<ul>
<li>
<p>send 是 transfer 低级对应物。如果执行失败，transfer 抛出异常而 send 返回 false。</p>
</li>
<li>
<p>call, callcode and delegatecall</p>
</li>
</ul>
<p>call 可以使用任意数量任意类型的参数和接口交互。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">address nameReg = <span class="hljs-number">0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2</span>;<br>nameReg.<span class="hljs-title function_">call</span>(<span class="hljs-string">&quot;register&quot;</span>, <span class="hljs-string">&quot;MyName&quot;</span>);<br>nameReg.<span class="hljs-title function_">call</span>(<span class="hljs-title function_">bytes4</span>(<span class="hljs-title function_">keccak256</span>(<span class="hljs-string">&quot;fun(uint256)&quot;</span>)), a);<br></code></pre></td></tr></table></figure>
<p>修改提供的 gas 数量的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">namReg.<span class="hljs-property">call</span>.<span class="hljs-title function_">gas</span>(<span class="hljs-number">1000000</span>)(<span class="hljs-string">&quot;register&quot;</span>, <span class="hljs-string">&quot;MyName&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>类似地，也可以在调用函数的时候转钱：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nameReg</span>.call.value(<span class="hljs-number">1</span> ether)(<span class="hljs-string">&quot;register&quot;</span>, <span class="hljs-string">&quot;MyName&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>无关顺序的修饰符使用：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nameReg</span>.call.gas(<span class="hljs-number">1000000</span>).value(<span class="hljs-number">1</span> ether)(<span class="hljs-string">&quot;register&quot;</span>, <span class="hljs-string">&quot;MyName&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>delegatecall可以被用来调用某个特定合约上的地址，这个方法的用意就是用来调用其他合约上的库函数。它的早期版本（家园以前）callcode 同理，而且callcode 不能访问<code>msg.sender</code>和<code>msg.value</code>。<strong>callcode 将在未来的版本被移除。</strong></p>
<p>尽量应该使用 transfer 而不要使用低级 API，因为它们破坏了 Solidity 的类型安全。</p>
<p><code>.gas()</code>选项对于三个方法都可用，但<code>.value()</code>选项不被<code>delegatecall</code>所支持。</p>
<p>因为所有的合约都集成了地址的成员，所以在合约里可以这样查余额<code>this.balance</code>。</p>
<h5 id="定长字节数组">定长字节数组</h5>
<p><code>bytes1</code>，<code>bytes2</code>，<code>bytes3</code>，…，<code>bytes32</code>。 <code>byte</code> 是 <code>bytes1</code>的别名。</p>
<p>这个类型也支持常见的比较、位操作符，它还支持更重要的索引操作符：如果 x 是个<code>bytesI</code>类型，<code>x[k]</code>(<code>0 &lt;= k &lt; I</code>)返回第 k<br>
个字节。</p>
<h5 id="动态长度字节数组">动态长度字节数组</h5>
<p><code>bytes</code>：动态长度字节数组，见<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/types.html#arrays">Arrays</a>。不是一个值类型（为什么要放这里？）。</p>
<p><code>string</code>：动态utf-8编码字符串，见<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/types.html#arrays">Arrays</a>。不是一个值类型（为什么要放这里？）。</p>
<p>如果有任意长度数据的需求，应该优先使用<code>bytes</code>和<code>string</code>，否则尽量使用定长的数据数据类型，<code>bytes1</code>和<code>bytes32</code>比较便宜。</p>
<h5 id="地址字面量">地址字面量</h5>
<p>能够通过地址测试的十六进制字面量（加上0x长度为42的字符串）如<code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code>是 地址类型。</p>
<h5 id="有理数和整数字面量">有理数和整数字面量</h5>
<p>常见整数字面量：<code>69</code>。<br>
十进位小数字面量：<code>1.3</code>。<br>
科学计数法：<code>2e10</code>，<code>-2e10</code>，<code>2e-10</code>，<code>2.5e1.</code>。</p>
<p>早期版本的有理数除法会导致截断，当前版本不会，<code>5/2</code>现在等于2.5了。</p>
<h5 id="字符串字面量">字符串字面量</h5>
<p>单引号和双引号都可以包裹字符串字面量，如<code>&quot;foo&quot;</code>和<code>'bar'</code>。他们没有 C 中的尾随0。<code>&quot;foo&quot;</code>代表三个字节而不是四个。他们可以被隐式地转换为各种字节数组（见上文），定长不定长的都可能，当然也可以转化为<code>string</code>。</p>
<p>字符串字面量支持转义符，如<code>\n</code>，<code>\xNN</code>和<code>\uNNNN</code>。<code>\xNN</code>取一个十六进制的值，并插入一个正确的字节。<code>\uNNNN</code>取一个 Unicode 码点，并且插入一个UTF-8序数。</p>
<h5 id="十六进制字面量">十六进制字面量</h5>
<p>用<code>hex</code>开头，用单双引号括起来：<code>hex&quot;001122FF&quot;</code>。</p>
<h5 id="枚举">枚举</h5>
<p>这里的枚举也是可以显式地与整型数互相转换的。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>contract test &#123;<br>    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;<br>    ActionChoices choice;<br>    ActionChoices <span class="hljs-keyword">constant</span> defaultChoice = ActionChoices.GoStraight;<br><br>    <span class="hljs-keyword">function</span> setGoStraight() <span class="hljs-built_in">public</span> &#123;<br>        choice = ActionChoices.GoStraight;<br>    &#125;<br><br>    // Since enum <span class="hljs-keyword">types</span> are <span class="hljs-keyword">not</span> part <span class="hljs-keyword">of</span> the ABI, the signature <span class="hljs-keyword">of</span> &quot;getChoice&quot;<br>    // will automatically be changed <span class="hljs-keyword">to</span> &quot;getChoice() returns (uint8)&quot;<br>    // <span class="hljs-keyword">for</span> <span class="hljs-keyword">all</span> matters <span class="hljs-keyword">external</span> <span class="hljs-keyword">to</span> Solidity. The <span class="hljs-type">integer</span> <span class="hljs-keyword">type</span> used <span class="hljs-keyword">is</span> just<br>    // <span class="hljs-keyword">large</span> enough <span class="hljs-keyword">to</span> hold <span class="hljs-keyword">all</span> enum <span class="hljs-keyword">values</span>, i.e. <span class="hljs-keyword">if</span> you have more <span class="hljs-keyword">values</span>,<br>    // `uint16` will be used <span class="hljs-keyword">and</span> so <span class="hljs-keyword">on</span>.<br>    <span class="hljs-keyword">function</span> getChoice() <span class="hljs-built_in">public</span> <span class="hljs-keyword">view</span> <span class="hljs-keyword">returns</span> (ActionChoices) &#123;<br>        <span class="hljs-keyword">return</span> choice;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> getDefaultChoice() <span class="hljs-built_in">public</span> pure <span class="hljs-keyword">returns</span> (uint) &#123;<br>        <span class="hljs-keyword">return</span> uint(defaultChoice);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="函数类型">函数类型</h5>
<p>同函数式编程里面的一等类型函数差不多。</p>
<p>函数类型被分为两种：内部和外部函数。</p>
<p>内部函数只能在当前合约内被调用（更具体地说，在当前的代码单元内，也就包含了内部函数库和继承下来的函数），因为他们不能在当前合约的上下文之外被执行。调用一个内部函数的实现方式就是让控制流跳到一个条目标签上。</p>
<p>外部函数包括一个地址和一个函数签名，他们可以被传递进/传递出外部函数调用。</p>
<p>函数类型的标记法是：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">function</span> (&lt;parameter <span class="hljs-keyword">types</span>&gt;) &#123;<span class="hljs-type">internal</span>|<span class="hljs-keyword">external</span>&#125; [pure|<span class="hljs-keyword">constant</span>|<span class="hljs-keyword">view</span>|payable] [<span class="hljs-keyword">returns</span> (&lt;<span class="hljs-keyword">return</span> <span class="hljs-keyword">types</span>&gt;)]<br></code></pre></td></tr></table></figure>
<p>不允许出现空的 return 语句。</p>
<p>默认函数都是 internal 的，所以 internal 实际上可以被省略（类似 C 语言呢）。</p>
<p><code>delete</code>一个函数后，再调用它会出现运行时异常。</p>
<p>如果一个外部函数变量被 Solidity 之外的上下文调用（跨语言互操作 interoperability问题），他们将被当做<code>function</code>类型，它在一个<code>bytes24</code>类型里放了一个编码的地址，后面还跟着函数识别符。</p>
<p>public（或外部）函数同样包含一个叫<code>selector</code>的成员，它返回一个 <a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/abi-spec.html#abi-function-selector">ABI function selector</a></p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span>.<span class="hljs-number">16</span>;<br><br>contract Selector &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title">f</span>() public view returns (bytes4) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">this.f.selector</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>内部函数的例子：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs zephir">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>library ArrayUtils &#123;<br>  <span class="hljs-comment">// 同在一个上下文里的内部函数调用。</span><br>  <span class="hljs-comment">// internal functions can be used in internal library functions because</span><br>  <span class="hljs-comment">// they will be part of the same code context</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">map</span><span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory <span class="hljs-keyword">self</span>, <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> pure returns <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> f)</span></span><br><span class="hljs-function">    <span class="hljs-title">internal</span></span><br><span class="hljs-function">    <span class="hljs-title">pure</span></span><br><span class="hljs-function">    <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory r)</span></span><br><span class="hljs-function">  </span>&#123;<br>    r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uint</span>[](<span class="hljs-keyword">self</span>.length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">self</span>.length; i++) &#123;<br>      r[i] = f(<span class="hljs-keyword">self</span>[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reduce</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">uint</span>[] memory <span class="hljs-keyword">self</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-keyword">function</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>, <span class="hljs-keyword">uint</span>)</span> pure returns <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> f</span></span><br><span class="hljs-params"><span class="hljs-function">  )</span></span><br><span class="hljs-function">    <span class="hljs-title">internal</span></span><br><span class="hljs-function">    <span class="hljs-title">pure</span></span><br><span class="hljs-function">    <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> r)</span></span><br><span class="hljs-function">  </span>&#123;<br>    r = <span class="hljs-keyword">self</span>[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">1</span>; i &lt; <span class="hljs-keyword">self</span>.length; i++) &#123;<br>      r = f(r, <span class="hljs-keyword">self</span>[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">range</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> length)</span> <span class="hljs-title">internal</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>[] memory r)</span> </span>&#123;<br>    r = <span class="hljs-keyword">new</span> <span class="hljs-keyword">uint</span>[](length);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; r.length; i++) &#123;<br>      r[i] = i;<br>    &#125;<br>  &#125;<br>&#125;<br><br>contract Pyramid &#123;<br>  using ArrayUtils <span class="hljs-keyword">for</span> *;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">pyramid</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> l)</span> <span class="hljs-title">public</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ArrayUtils.range(l).map(square).reduce(sum);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">square</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> x)</span> <span class="hljs-title">internal</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x * x;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> x, <span class="hljs-keyword">uint</span> y)</span> <span class="hljs-title">internal</span> <span class="hljs-title">pure</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个把外部函数类型传递进 struct 的实例，这其实也是个预言机使用的好例子了：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.20</span>; // should actually be <span class="hljs-number">0.4</span><span class="hljs-number">.21</span><br><br>contract Oracle &#123;<br>  struct Request &#123;<br>    bytes data;<br>    <span class="hljs-keyword">function</span>(bytes memory) <span class="hljs-keyword">external</span> callback;<br>  &#125;<br>  Request[] requests;<br>  event NewRequest(uint);<br>  <span class="hljs-keyword">function</span> query(bytes data, <span class="hljs-keyword">function</span>(bytes memory) <span class="hljs-keyword">external</span> callback) <span class="hljs-built_in">public</span> &#123;<br>    requests.push(Request(data, callback));<br>    emit NewRequest(requests.length - <span class="hljs-number">1</span>);<br>  &#125;<br>  <span class="hljs-keyword">function</span> reply(uint requestID, bytes response) <span class="hljs-built_in">public</span> &#123;<br>    // Here goes the <span class="hljs-keyword">check</span> that the reply comes <span class="hljs-keyword">from</span> a <span class="hljs-keyword">trusted</span> source<br>    requests[requestID].callback(response);<br>  &#125;<br>&#125;<br><br>contract OracleUser &#123;<br>  Oracle <span class="hljs-keyword">constant</span> oracle = Oracle(<span class="hljs-number">0x1234567</span>); // known contract<br>  <span class="hljs-keyword">function</span> buySomething() &#123;<br>    oracle.query(&quot;USD&quot;, this.oracleResponse);<br>  &#125;<br>  <span class="hljs-keyword">function</span> oracleResponse(bytes response) <span class="hljs-built_in">public</span> &#123;<br>    require(msg.sender == address(oracle));<br>    // Use the data<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>现在还不支持 Lambda 函数和内联函数。</p>
<h4 id="引用类型">引用类型</h4>
<p>复合类型，也就是类型不衬进256位的类型，总要被比我们已经看到的值类型更仔细地对待。因为拷贝它们是非常昂贵的，所以我们要仔细考虑它们应该被存储在<code>memory里</code>（不会被持久化）还是被存储在<code>storage</code>（状态变量就放在这里）里。</p>
<h5 id="数据位置">数据位置</h5>
<p>每个复合类型，数组和结构体，都有一个额外的注解，即“数据位置”，关于它是被存储在memory里还是在storage里。依据上下文的不同，总有一个缺省值，但它可以被往类型上添加<code>storage</code>和<code>memory</code>覆盖掉。默认的函数参数是<code>memory</code>的，默认的局部变量是<code>storage</code>的（即这两者是可变的），状态变量的位置被强制设为<code>storage</code>。</p>
<p>还有第三种数据位置，<code>calldata</code>，它是不可修改的，不持久化的，函数实参存储在里面。外部函数的函数参数（而不是返回参数）被强制为<code>calldata</code>，行为表现与<code>memory</code>很相似。</p>
<p>数据位置是重要的，因为他们改变了赋值行为:<code>memory</code>和<code>storage</code>之间的赋值、状态变量之间的赋值总是会产生独立拷贝。向局部<code>storage</code> 变量赋值，尽管只是赋予一个引用，这个引用总是指向一个状态变量，即使后者会改变。<code>memory</code>和<code>memory</code>之间的赋值不会产生拷贝。</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs gml">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    uint[] <span class="hljs-variable language_">x</span>; <span class="hljs-comment">// the data location of x is storage</span><br><br>    <span class="hljs-comment">// the data location of memoryArray is memory</span><br>    <span class="hljs-keyword">function</span> f(uint[] memoryArray) public &#123;<br>        <span class="hljs-variable language_">x</span> = memoryArray; <span class="hljs-comment">// works, copies the whole array to storage</span><br>        <span class="hljs-keyword">var</span> <span class="hljs-variable language_">y</span> = <span class="hljs-variable language_">x</span>; <span class="hljs-comment">// works, assigns a pointer, data location of y is storage</span><br>        <span class="hljs-variable language_">y</span>[<span class="hljs-number">7</span>]; <span class="hljs-comment">// fine, returns the 8th element</span><br>        <span class="hljs-comment">// 局部 storage 变量修改了状态 storage 变量。</span><br>        <span class="hljs-variable language_">y</span>.length = <span class="hljs-number">2</span>; <span class="hljs-comment">// fine, modifies x through y</span><br>        <span class="hljs-comment">// 清除数组的方法</span><br>        <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">x</span>; <span class="hljs-comment">// fine, clears the array, also modifies y</span><br>        <span class="hljs-comment">// 可以把实参赋给状态变量，把局部变量指向状态变量，却不能跳过第一步。状态变量都是“静态分配”的。</span><br>        <span class="hljs-comment">// The following does not work; it would need to create a new temporary /</span><br>        <span class="hljs-comment">// unnamed array in storage, but storage is &quot;statically&quot; allocated:</span><br>        <span class="hljs-comment">// y = memoryArray;</span><br>        <span class="hljs-comment">// This does not work either, since it would &quot;reset&quot; the pointer, but there</span><br>        <span class="hljs-comment">// is no sensible location it could point to.</span><br>        <span class="hljs-comment">// delete y;</span><br>        g(<span class="hljs-variable language_">x</span>); <span class="hljs-comment">// calls g, handing over a reference to x</span><br>        h(<span class="hljs-variable language_">x</span>); <span class="hljs-comment">// calls h and creates an independent, temporary copy in memory</span><br>    &#125;<br><br>    <span class="hljs-keyword">function</span> g(uint[] storage storageArray) internal &#123;&#125;<br>    <span class="hljs-keyword">function</span> h(uint[] memoryArray) public &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在实验之中，构造函数生成的总是<code>memory</code>类型的变量，拷贝到 storage 变量就可以让它被持久化了。</p>
<p>总结一下：</p>
<p>强制数据位置：<br>
外部函数的参数必须是<code>calldata</code><br>
状态变量必须是<code>storage</code><br>
缺省数据位置：<br>
函数参数默认是<code>memory</code><br>
所有局部变量默认是<code>storage</code></p>
<h5 id="数组">数组</h5>
<p>数组可以有编译时的固定长度，也可以是动态的。<code>storage</code>数组的元素类型可以是任意的（即可以是数组的数组、mapping 的数组和结构体的数组）。<code>memory</code>数组则不能有<code>mapping</code>元素，如果它是个公共可见函数（外部函数？），它的元素必须是个 ABI 类型。</p>
<p>定长数组写作，<code>T[k]</code>，变长数组写作<code>T[]</code>（也就是说大部分的智能合约的函数参数都是<code>memory</code>动态数组）。</p>
<p>5个<code>unint</code>动态数组的写法与其他语言正好反过来，<code>uint[][15]</code>。访问第三个动态数组的第二个元素，又反而和其它语言一样，<code>x[2][16]</code>。</p>
<h5 id="创建内存数组">创建内存数组</h5>
<p><strong>可以用 new 来创建内存数组</strong>。<code>memory</code>数组不可以通过<code>.length</code> 来修改数组尺寸，但<code>storage</code>数组可以。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> len) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> &#123;<br>        <span class="hljs-built_in">uint</span>[] memory a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">uint</span>[](<span class="hljs-number">7</span>);<br>        bytes memory b = <span class="hljs-keyword">new</span> bytes(len);<br>        <span class="hljs-comment">// Here we have a.length == 7 and b.length == len</span><br>        a[<span class="hljs-number">6</span>] = <span class="hljs-number">8</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="数组字面量-内联数组">数组字面量/内联数组</h5>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f() <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> &#123;<br>        g([<span class="hljs-built_in">uint</span>(<span class="hljs-number">1</span>), <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);<br>    &#125;<br>    <span class="hljs-comment">// 这也是个定长数组的例子</span><br>    <span class="hljs-built_in">function</span> g(<span class="hljs-built_in">uint</span>[<span class="hljs-number">3</span>] _data) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="成员">成员</h5>
<p>length：只有 storage 的动态数组才能动态修改自己的尺寸。<br>
push：在数组尾部添加元素，返回新的长度。</p>
<p>数组的一个综合例子：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>contract ArrayContract &#123;<br>    <span class="hljs-built_in">uint</span>[<span class="hljs-number">2</span>**<span class="hljs-number">20</span>] m_aLotOfIntegers;<br>    <span class="hljs-comment">// Note that the following is not a pair of dynamic arrays but a</span><br>    <span class="hljs-comment">// dynamic array of pairs (i.e. of fixed size arrays of length two).</span><br>    <span class="hljs-built_in">bool</span>[<span class="hljs-number">2</span>][] m_pairsOfFlags;<br>    <span class="hljs-comment">// newPairs is stored in memory - the default for function arguments</span><br><br>    <span class="hljs-built_in">function</span> setAllFlagPairs(<span class="hljs-built_in">bool</span>[<span class="hljs-number">2</span>][] newPairs) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// assignment to a storage array replaces the complete array</span><br>        m_pairsOfFlags = newPairs;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> setFlagPair(<span class="hljs-built_in">uint</span> index, <span class="hljs-built_in">bool</span> flagA, <span class="hljs-built_in">bool</span> flagB) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// access to a non-existing index will throw an exception</span><br>        m_pairsOfFlags[index][<span class="hljs-number">0</span>] = flagA;<br>        m_pairsOfFlags[index][<span class="hljs-number">17</span>] = flagB;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> changeFlagArraySize(<span class="hljs-built_in">uint</span> newSize) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// if the new size is smaller, removed array elements will be cleared</span><br>        m_pairsOfFlags.length = newSize;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> clear() <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// these clear the arrays completely</span><br>        <span class="hljs-keyword">delete</span> m_pairsOfFlags;<br>        <span class="hljs-keyword">delete</span> m_aLotOfIntegers;<br>        <span class="hljs-comment">// identical effect here</span><br>        m_pairsOfFlags.length = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    bytes m_byteData;<br><br>    <span class="hljs-built_in">function</span> byteArrays(bytes data) <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-comment">// byte arrays (&quot;bytes&quot;) are different as they are stored without padding,</span><br>        <span class="hljs-comment">// but can be treated identical to &quot;uint8[]&quot;</span><br>        m_byteData = data;<br>        m_byteData.length += <span class="hljs-number">7</span>;<br>        m_byteData[<span class="hljs-number">3</span>] = <span class="hljs-keyword">byte</span>(<span class="hljs-number">8</span>);<br>        <span class="hljs-keyword">delete</span> m_byteData[<span class="hljs-number">2</span>];<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> addFlag(<span class="hljs-built_in">bool</span>[<span class="hljs-number">2</span>] flag) <span class="hljs-keyword">public</span> returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-keyword">return</span> m_pairsOfFlags.push(flag);<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> createMemoryArray(<span class="hljs-built_in">uint</span> size) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (bytes) &#123;<br>        <span class="hljs-comment">// Dynamic memory arrays are created using `new`:</span><br>        <span class="hljs-built_in">uint</span>[<span class="hljs-number">2</span>][] memory arrayOfPairs = <span class="hljs-keyword">new</span> <span class="hljs-built_in">uint</span>[<span class="hljs-number">2</span>][](size);<br>        <span class="hljs-comment">// Create a dynamic byte array:</span><br>        bytes memory b = <span class="hljs-keyword">new</span> bytes(<span class="hljs-number">200</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">uint</span> i = <span class="hljs-number">0</span>; i &lt; b.length; i++)<br>            b[i] = <span class="hljs-keyword">byte</span>(i);<br>        <span class="hljs-keyword">return</span> b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="结构体类型">结构体类型</h5>
<p>结构体提供了定义新类型的能力。<br>
众筹合约的例子：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br>contract CrowdFunding &#123;<br>    // Defines a <span class="hljs-built_in">new</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">with</span> two fields.<br>    struct Funder &#123;<br>        address addr;<br>        uint amount;<br>    &#125;<br><br>    struct Campaign &#123;<br>        address beneficiary;<br>        uint fundingGoal;<br>        uint numFunders;<br>        uint amount;<br>        <span class="hljs-keyword">mapping</span> (uint =&gt; Funder) funders;<br>    &#125;<br><br>    uint numCampaigns;<br>    <span class="hljs-keyword">mapping</span> (uint =&gt; Campaign) campaigns;<br><br>    <span class="hljs-keyword">function</span> newCampaign(address beneficiary, uint goal) <span class="hljs-built_in">public</span> <span class="hljs-keyword">returns</span> (uint campaignID) &#123;<br>        campaignID = numCampaigns++; // campaignID <span class="hljs-keyword">is</span> <span class="hljs-keyword">return</span> variable<br>        // Creates <span class="hljs-built_in">new</span> struct <span class="hljs-keyword">and</span> saves <span class="hljs-keyword">in</span> <span class="hljs-keyword">storage</span>. We leave <span class="hljs-keyword">out</span> the <span class="hljs-keyword">mapping</span> <span class="hljs-keyword">type</span>.<br>        // 这里构造函数生成的数据类型是 memory，而 campaigns[campaignID]的数据位置是 <span class="hljs-keyword">storage</span>，只有这种方式可以隐式自动转化这两种 data <span class="hljs-keyword">location</span>。<br>        campaigns[campaignID] = Campaign(beneficiary, goal, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> contribute(uint campaignID) <span class="hljs-built_in">public</span> payable &#123;<br>        Campaign <span class="hljs-keyword">storage</span> c = campaigns[campaignID];<br>        // Creates a <span class="hljs-built_in">new</span> <span class="hljs-keyword">temporary</span> memory struct, initialised <span class="hljs-keyword">with</span> the given <span class="hljs-keyword">values</span><br>        // <span class="hljs-keyword">and</span> copies it <span class="hljs-keyword">over</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">storage</span>.<br>        // Note that you can <span class="hljs-keyword">also</span> use Funder(msg.sender, msg.<span class="hljs-keyword">value</span>) <span class="hljs-keyword">to</span> initialise.<br>        c.funders[c.numFunders++] = Funder(&#123;addr: msg.sender, amount: msg.<span class="hljs-keyword">value</span>&#125;);<br>        c.amount += msg.<span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> checkGoalReached(uint campaignID) <span class="hljs-built_in">public</span> <span class="hljs-keyword">returns</span> (<span class="hljs-type">bool</span> reached) &#123;<br>        Campaign <span class="hljs-keyword">storage</span> c = campaigns[campaignID];<br>        <span class="hljs-keyword">if</span> (c.amount &lt; c.fundingGoal)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        uint amount = c.amount;<br>        c.amount = <span class="hljs-number">0</span>;<br>        c.beneficiary.transfer(amount);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>struct 本身可以存储数组和映射，也可以被这两者存储。它不能存储它自身类型的变量，struct 的尺寸必须是有限的。</p>
<h4 id="映射">映射</h4>
<p><code>mapping(_KeyType =&gt; _ValueType)</code>里的key类型不能是映射，动态长度数组、合约、枚举和结构体。value 可以是任何类型。</p>
<p>映射可以被认为是个被虚拟初始化的 hash 表，所有可能的键都存在而且值被初始化为0值。实际上 key 数据并不存在映射里面，只有它的<code>keccak256</code>散列值被存在里面，用来查值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract MappingExample &#123;<br>    mapping(address =&gt; <span class="hljs-built_in">uint</span>) <span class="hljs-keyword">public</span> balances;<br><br>    <span class="hljs-function">function <span class="hljs-title">update</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> newBalance</span>) <span class="hljs-keyword">public</span></span> &#123;<br>        balances[msg.sender] = newBalance;<br>    &#125;<br>&#125;<br><br>contract MappingUser &#123;<br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        MappingExample m = <span class="hljs-keyword">new</span> MappingExample();<br>        m.update(<span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">return</span> m.balances(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>mapping 本身是不可迭代的，但可以看<a target="_blank" rel="noopener" href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">iterable mapping</a>，看看怎么在它之上建立一个可迭代的结构。</p>
<h4 id="牵涉到左值的操作符">牵涉到左值的操作符</h4>
<h5 id="delete">delete</h5>
<p><code>delete</code>一个变量，差不多可以说是把一个零值赋给它。除了不能 delete 一个映射以外，所有类型的变量都可以被 delete。delete 动态数组会得到一个长度为0的新动态数组，delete 一个静态数组会得到一个长度等于原长度，所有元素都等于该元素类型零值的数组，delete 一个结构体变量，所有的成员除了映射都会变成0值。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract DeleteExample &#123;<br>    uint data;<br>    uint[] dataArray;<br><br>    <span class="hljs-keyword">function</span> f() <span class="hljs-built_in">public</span> &#123;<br>        // 注意！这里 x 拷贝了 data，而不是把一个指针指向了 data。<br>        uint x = data;<br>        <span class="hljs-keyword">delete</span> x; // sets x <span class="hljs-keyword">to</span> <span class="hljs-number">0</span>, does <span class="hljs-keyword">not</span> affect data<br>        <span class="hljs-keyword">delete</span> data; // sets data <span class="hljs-keyword">to</span> <span class="hljs-number">0</span>, does <span class="hljs-keyword">not</span> affect x which still holds a <span class="hljs-keyword">copy</span><br>        uint[] <span class="hljs-keyword">storage</span> y = dataArray;<br>        <span class="hljs-keyword">delete</span> dataArray; // this sets dataArray.length <span class="hljs-keyword">to</span> zero, but <span class="hljs-keyword">as</span> uint[] <span class="hljs-keyword">is</span> a complex <span class="hljs-keyword">object</span>, <span class="hljs-keyword">also</span><br>        // y <span class="hljs-keyword">is</span> affected which <span class="hljs-keyword">is</span> an <span class="hljs-keyword">alias</span> <span class="hljs-keyword">to</span> the <span class="hljs-keyword">storage</span> <span class="hljs-keyword">object</span><br>        // <span class="hljs-keyword">On</span> the other hand: &quot;delete y&quot; <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">valid</span>, <span class="hljs-keyword">as</span> assignments <span class="hljs-keyword">to</span> <span class="hljs-keyword">local</span> variables<br>        // referencing <span class="hljs-keyword">storage</span> objects can <span class="hljs-keyword">only</span> be made <span class="hljs-keyword">from</span> existing <span class="hljs-keyword">storage</span> objects.<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="基本数据类型之间的转换">基本数据类型之间的转换</h4>
<p>所有的数据类型都可以转变为<code>uint160</code>，也就可以转变为地址。</p>
<p>显式转换的例子：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">uint x <span class="hljs-operator">=</span> uint(y)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<h4 id="类型推导">类型推导</h4>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">uint24 x <span class="hljs-operator">=</span> <span class="hljs-number">0</span>x123<span class="hljs-comment">;</span><br>var y <span class="hljs-operator">=</span> x<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>var 不能用在函数形参和返回值上。<br>
var 只在第一次赋值时被推导出来，所以以下循环无法终止：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">for (var i <span class="hljs-operator">=</span> <span class="hljs-number">0</span><span class="hljs-comment">; i &lt; 2000; i++) &#123; ... &#125;</span><br></code></pre></td></tr></table></figure>
<p>因为第一次赋值，使得 i 被推导为<code>uint8</code>类型了。</p>
<h3 id="单位和全局可用变量">单位和全局可用变量</h3>
<h4 id="以太币的单位">以太币的单位</h4>
<p>四级单位<code>wei</code>，<code>finney</code>，<code>szabo</code> 或者 <code>ether</code>。<code>2 ether == 2000 finney</code>。</p>
<h4 id="时间单位">时间单位</h4>
<p><code>seconds</code>，<code>minutes</code>，<code>hours</code>，<code>day</code>，<code>weeks</code>和<code>years</code>。<br>
小心闰秒（ leap seconds）问题。</p>
<p>巧妙使用单位来对比当前时间的例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">function <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> start, <span class="hljs-built_in">uint</span> daysAfter</span>) <span class="hljs-keyword">public</span></span> &#123;<br>    <span class="hljs-keyword">if</span> (now &gt;= start + daysAfter * <span class="hljs-number">1</span> days) &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="特殊的变量和函数">特殊的变量和函数</h4>
<p>在全局空间里早已存在一些特殊的变量和函数，用以提供区块链的信息：</p>
<h5 id="区块和事务属性">区块和事务属性</h5>
<ul>
<li>block.blockhash(uint blockNumber) returns (bytes32)：一个给定区块的散列值 - 只对当前最近的256个区块奏效。</li>
<li>block.coinbase (address)：当前区块挖掘者的地址。</li>
<li>block.difficulty (uint)：当前区块的难度。</li>
<li>block.gaslimit (uint)：当前区块的 gaslimit。</li>
<li>block.number (uint)：当前区块号</li>
<li>block.timestamp (uint)：当前区块的时间戳，从 unix epoch 开始的秒数形式。</li>
<li>msg.data (bytes)：完整的调用数据。</li>
<li>msg.gas (uint)：剩余 gas。</li>
<li>msg.sender (address)：当前调用的消息发送者。</li>
<li>msg.sig (bytes4)：calldata 的最初四个字节（函数标识符）。</li>
<li>msg.value (uint)：消息附带的价值数。</li>
<li>now (uint)：时间戳的别名。</li>
<li>tx.gasprice (uint)：事务的 gasprice。</li>
<li>tx.origin (address)：事务的发送者 (完整调用链)。</li>
</ul>
<p>msg 的所有成员，可能在每个外部调用中都发生变化。</p>
<h5 id="错误处理">错误处理</h5>
<p><code>assert(bool condition)</code>：如果条件不为真抛出异常。<br>
<code>require(bool condition)</code>：抛出异常如果条件不为真，用来做输入检查（通常配合 modifier 使用）。<br>
<code>revert()</code>：退出执行，并且反转状态变化。</p>
<h5 id="数学和密码学函数">数学和密码学函数</h5>
<ul>
<li>addmod(uint x, uint y, uint k) returns (uint):<br>
compute (x + y) % k where the addition is performed with arbitrary precision and does not wrap around at 2**256. Assert that k != 0 starting from version 0.5.0.</li>
<li>mulmod(uint x, uint y, uint k) returns (uint):<br>
compute (x * y) % k where the multiplication is performed with arbitrary precision and does not wrap around at 2**256. Assert that k != 0 starting from version 0.5.0.</li>
<li>keccak256(…) returns (bytes32):<br>
compute the Ethereum-SHA-3 (Keccak-256) hash of the (tightly packed) arguments</li>
<li>sha256(…) returns (bytes32):<br>
compute the SHA-256 hash of the (tightly packed) arguments</li>
<li>sha3(…) returns (bytes32):<br>
alias to keccak256</li>
<li>ripemd160(…) returns (bytes20):<br>
compute RIPEMD-160 hash of the (tightly packed) arguments</li>
<li>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):<br>
recover the address associated with the public key from elliptic curve signature or return zero on error (example usage)</li>
</ul>
<p>因为“紧密打包”，以下内容是相等的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">keccak256</span><span class="hljs-params">(<span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">keccak256</span><span class="hljs-params">(<span class="hljs-string">&quot;abc&quot;</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">keccak256</span><span class="hljs-params">(<span class="hljs-number">0</span>x616263)</span></span><br><span class="hljs-function"><span class="hljs-title">keccak256</span><span class="hljs-params">(<span class="hljs-number">6382179</span>)</span></span><br><span class="hljs-function"><span class="hljs-title">keccak256</span><span class="hljs-params">(<span class="hljs-number">97</span>, <span class="hljs-number">98</span>, <span class="hljs-number">99</span>)</span></span><br></code></pre></td></tr></table></figure>
<h3 id="表达式和控制结构">表达式和控制结构</h3>
<h4 id="输入参数和输出参数">输入参数和输出参数</h4>
<h5 id="输入参数">输入参数</h5>
<p>声明输入参数和声明变量一样。</p>
<h5 id="输出参数">输出参数</h5>
<p>输出参数的定义，很像 Golang：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>contract Simple &#123;<br>    <span class="hljs-built_in">function</span> arithmetics(<span class="hljs-built_in">uint</span> _a, <span class="hljs-built_in">uint</span> _b)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-keyword">pure</span><br>        returns (<span class="hljs-built_in">uint</span> o_sum, <span class="hljs-built_in">uint</span> o_product)<br>    &#123;<br>        o_sum = _a + _b;<br>        o_product = _a * _b;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="控制结构">控制结构</h4>
<p>除了 switch 和 goto，JavaScript 中所有的控制结构 Solidity 都支持。</p>
<h5 id="多返回值">多返回值</h5>
<p>我们已经看到声明的地方有多返回值了，可以像 Golang 一样写多返回值-<code>return (v0, v1, ..., vn)</code>。</p>
<h4 id="function-calls">Function Calls</h4>
<h5 id="内部调用">内部调用</h5>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span>.<span class="hljs-number">16</span>;<br><br>contract C &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(uint a) public pure returns (uint ret) &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">f()</span>; &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">f</span>() internal pure returns (uint ret) &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">g(7)</span> + f(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>内部调用会被 EVM 翻译成字节码，直接 jump 过去。因为这时候还是在内存内调用，内存内状态没有被清理掉，所以是很高效。</p>
<h5 id="外部函数调用">外部函数调用</h5>
<p>像<code>c.g(2);</code>这类调用，本身是在一个 contract 实例上的调用，本身必然要求 message call 的，就不能 jump 了。</p>
<p>调用其他合约的 payable 方法的例子。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span>.<span class="hljs-number">0</span>;<br><br>contract InfoFeed &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">info</span>() public payable returns (uint ret) &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">42</span>; &#125;<br>&#125;<br><br>contract Consumer &#123;<br>    InfoFeed feed;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">setFeed</span>(address addr) public &#123; feed = InfoFeed(addr); &#125;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">callFeed</span>() public &#123; feed.info.value(10).gas(800)(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只有被 payable 修饰的方法，才可以被 value option 方法调用。<code>InfoFeed(addr)</code>并不是调用一个构造方法（看来构造方法只有在合约初始化的时候才会被调用），而是向这个地址声称能一个代理对象？</p>
<p>与任何其他合约交互都有潜在危险，特别是在该合约的源码事先未知的情况下。当前的合约把控制权拱手交给被调用合约，它就可以做任何事。为了让自己的成not vulnerable to exploit，应该让自己的外部函数调用有防御性，尽量让外部函数调用发生在<strong>状态改变之后</strong>。</p>
<h5 id="命名调用和匿名函数参数">命名调用和匿名函数参数</h5>
<p>一个简单的字面量调用的例子：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-function">function <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> key, <span class="hljs-built_in">uint</span> <span class="hljs-keyword">value</span></span>) <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">g</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-comment">// named arguments</span><br>        f(&#123;<span class="hljs-keyword">value</span>: <span class="hljs-number">2</span>, key: <span class="hljs-number">3</span>&#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="省略函数参数名">省略函数参数名</h5>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>contract C &#123;<br>    <span class="hljs-comment">// 这里有个被省略了的 uint 参数，不能访问到。</span><br>    <span class="hljs-comment">// omitted name for parameter</span><br>    <span class="hljs-built_in">function</span> func(<span class="hljs-built_in">uint</span> k, <span class="hljs-built_in">uint</span>) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns(<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-keyword">return</span> k;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="用new创建新合约">用<code>new</code>创建新合约</h4>
<p>可以用<code>new</code>来创建合约。要被创建的合约的完整代码，要事先被知道，所以，也就不可能有递归的创建依赖了：</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract D &#123;<br>    <span class="hljs-built_in">uint</span> x;<br>    <span class="hljs-built_in">function</span> D(<span class="hljs-built_in">uint</span> a) <span class="hljs-keyword">public</span> payable &#123;<br>        x = a;<br>    &#125;<br>&#125;<br><br>contract C &#123;<br>    <span class="hljs-comment">// 创建 C 的时候一并创建 D</span><br>    D d = <span class="hljs-keyword">new</span> D(<span class="hljs-number">4</span>); <span class="hljs-comment">// will be executed as part of C&#x27;s constructor</span><br><br>    <span class="hljs-built_in">function</span> createD(<span class="hljs-built_in">uint</span> arg) <span class="hljs-keyword">public</span> &#123;<br>        D newD = <span class="hljs-keyword">new</span> D(arg);<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> createAndEndowD(<span class="hljs-built_in">uint</span> arg, <span class="hljs-built_in">uint</span> amount) <span class="hljs-keyword">public</span> payable &#123;<br>        <span class="hljs-comment">// Send ether along with the creation</span><br>        D newD = (<span class="hljs-keyword">new</span> D).value(amount)(arg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="表达式求值的顺序">表达式求值的顺序</h4>
<p>除了布尔表达式以外，所有表达式的求值顺序都可能是未定的。在表达式树中，只有一个节点的子节点的孩子节点一定会在它之前执行（后缀遍历），其他的全部都没有保证。</p>
<h4 id="赋值">赋值</h4>
<h5 id="解构赋值和多返回值">解构赋值和多返回值</h5>
<p>Solidity 内部支持元组类型，即一个元素可能是不同类型，但长度在编译时就已经确定为常数的数组列表。元组才是多返回值的本质（其实在其他语言里还允许对象结构的解构返回）。</p>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs gml">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>contract C &#123;<br>    uint[] data;<br><br>    <span class="hljs-keyword">function</span> f() public pure returns (uint, <span class="hljs-built_in">bool</span>, uint) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-number">7</span>, <span class="hljs-symbol">true</span>, <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> g() public &#123;<br>        <span class="hljs-comment">// Declares and assigns the variables. Specifying the type explicitly is not possible.</span><br>        <span class="hljs-keyword">var</span> (<span class="hljs-variable language_">x</span>, b, <span class="hljs-variable language_">y</span>) = f();<br>        <span class="hljs-comment">// Assigns to a pre-existing variable.</span><br>        (<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>) = (<span class="hljs-number">2</span>, <span class="hljs-number">7</span>);<br>        <span class="hljs-comment">// Common trick to swap values -- does not work for non-value storage types.</span><br>        (<span class="hljs-variable language_">x</span>, <span class="hljs-variable language_">y</span>) = (<span class="hljs-variable language_">y</span>, <span class="hljs-variable language_">x</span>);<br>        <span class="hljs-comment">// Components can be left out (also for variable declarations).</span><br>        <span class="hljs-comment">// If the tuple ends in an empty component,</span><br>        <span class="hljs-comment">// the rest of the values are discarded.</span><br>        (data.length,) = f(); <span class="hljs-comment">// Sets the length to 7</span><br>        <span class="hljs-comment">// The same can be done on the left side.</span><br>        <span class="hljs-comment">// If the tuple begins in an empty component, the beginning values are discarded.</span><br>        (,data[<span class="hljs-number">3</span>]) = f(); <span class="hljs-comment">// Sets data[3] to 2</span><br>        <span class="hljs-comment">// Components can only be left out at the left-hand-side of assignments, with</span><br>        <span class="hljs-comment">// one exception:</span><br>        (<span class="hljs-variable language_">x</span>,) = (<span class="hljs-number">1</span>,);<br>        <span class="hljs-comment">// (1,) is the only way to specify a 1-component tuple, because (1) is</span><br>        <span class="hljs-comment">// equivalent to 1.</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="数组和结构体的复杂点">数组和结构体的复杂点</h5>
<p>数组和结构体等非值类型赋值语义稍显复杂。</p>
<p>赋值给一个状态变量总是会产生一个独立拷贝。</p>
<p>从状态变量赋数组和结构体给局部变量是传引用，再赋值还是传引用。</p>
<h4 id="作用域和声明">作用域和声明</h4>
<p>一个变量（包括在函数内）被声明的时候就会拥有字节零值。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> foo() <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-comment">// baz is implicitly initialized as 0</span><br>        <span class="hljs-built_in">uint</span> bar = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>            bar += baz;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">uint</span> baz = <span class="hljs-number">10</span>;<span class="hljs-comment">// never executes</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> bar;<span class="hljs-comment">// returns 5</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>函数内的变量里还是没有块级作用域的。</p>
<h5 id="从-0-5-0-开始就有作用域了">从 0.5.0 开始就有作用域了</h5>
<p>块作用域有块生命周期。<br>
for 相关变量只有 for 块的生命周期。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><span class="hljs-keyword">pragma</span> experimental <span class="hljs-string">&quot;v0.5.0&quot;</span>;<br>contract C &#123;<br>    <span class="hljs-built_in">function</span> minimalScoping() <span class="hljs-keyword">pure</span> <span class="hljs-keyword">public</span> &#123;<br>        &#123;<br>            <span class="hljs-built_in">uint</span> same2 = <span class="hljs-number">0</span>;<br>        &#125;<br><br>        &#123;<br>            <span class="hljs-built_in">uint</span> same2 = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><span class="hljs-keyword">pragma</span> experimental <span class="hljs-string">&quot;v0.5.0&quot;</span>;<br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f() <span class="hljs-keyword">pure</span> <span class="hljs-keyword">public</span> returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-built_in">uint</span> x = <span class="hljs-number">1</span>;<br>        &#123;<br>            x = <span class="hljs-number">2</span>; <span class="hljs-comment">// this will assign to the outer variable</span><br>            <span class="hljs-built_in">uint</span> x;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x; <span class="hljs-comment">// x has value 2</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="错误处理：断言-需求-反转和异常">错误处理：断言、需求、反转和异常</h4>
<p>所有异常都会反转当前的调用及其子调用的状态变化。</p>
<p>在未来<code>throw</code>会被淘汰掉，应该使用<code>revert</code>。</p>
<p>有些调用方法是靠返回值来确认异常的，注意检查返回值。</p>
<p>目前不支持 catch 语句。</p>
<h3 id="合约">合约</h3>
<p>Solidity 里的合约，类似面向对象语言里面的类。他们包含持久化状态和修改状态的函数。</p>
<p>跨合约调用不能引用老上下文的状态变量，但依然要小心外部函数调用问题。</p>
<h4 id="创建合约">创建合约</h4>
<p>可以用外部事务或者在合约内部创建合约。</p>
<p>可以用<a target="_blank" rel="noopener" href="https://github.com/ethereum/web3.js">web3.js</a>的 API 创建合约，具体参见<a target="_blank" rel="noopener" href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract">web3.eth.Contract</a>。</p>
<p>只允许一个构造函数，不允许构造函数重载。也可以没有构造函数。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>contract OwnedToken &#123;<br>    // TokenCreator <span class="hljs-keyword">is</span> a contract <span class="hljs-keyword">type</span> that <span class="hljs-keyword">is</span> defined below.<br>    // It <span class="hljs-keyword">is</span> fine <span class="hljs-keyword">to</span> reference it <span class="hljs-keyword">as</span> long <span class="hljs-keyword">as</span> it <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> used<br>    // <span class="hljs-keyword">to</span> <span class="hljs-keyword">create</span> a <span class="hljs-built_in">new</span> contract.<br>    TokenCreator creator;<br>    address <span class="hljs-keyword">owner</span>;<br>    bytes32 <span class="hljs-type">name</span>;<br><br>    // This <span class="hljs-keyword">is</span> the constructor which registers the<br>    // creator <span class="hljs-keyword">and</span> the assigned <span class="hljs-type">name</span>.<br>    <span class="hljs-keyword">function</span> OwnedToken(bytes32 _name) <span class="hljs-built_in">public</span> &#123;<br>        // <span class="hljs-type">internal</span> 变量不需要 this 访问，反正这时候合约还不存在呢<br>        // State variables are accessed via their <span class="hljs-type">name</span><br>        // <span class="hljs-keyword">and</span> <span class="hljs-keyword">not</span> via e.g. this.<span class="hljs-keyword">owner</span>. This <span class="hljs-keyword">also</span> applies<br>        // <span class="hljs-keyword">to</span> <span class="hljs-keyword">functions</span> <span class="hljs-keyword">and</span> especially <span class="hljs-keyword">in</span> the constructors,<br>        // you can <span class="hljs-keyword">only</span> <span class="hljs-keyword">call</span> them <span class="hljs-keyword">like</span> that (&quot;internally&quot;),<br>        // because the contract itself does <span class="hljs-keyword">not</span> exist yet.<br>        owner = msg.sender;<br>        // We <span class="hljs-keyword">do</span> an explicit <span class="hljs-keyword">type</span> <span class="hljs-keyword">conversion</span> <span class="hljs-keyword">from</span> `address`<br>        // <span class="hljs-keyword">to</span> `TokenCreator` <span class="hljs-keyword">and</span> assume that the <span class="hljs-keyword">type</span> <span class="hljs-keyword">of</span><br>        // the calling contract <span class="hljs-keyword">is</span> TokenCreator, there <span class="hljs-keyword">is</span><br>        // <span class="hljs-keyword">no</span> <span class="hljs-type">real</span> way <span class="hljs-keyword">to</span> <span class="hljs-keyword">check</span> that.<br>        creator = TokenCreator(msg.sender);<br>        <span class="hljs-type">name</span> = _name;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> changeName(bytes32 newName) <span class="hljs-built_in">public</span> &#123;<br>        // <span class="hljs-keyword">Only</span> the creator can <span class="hljs-keyword">alter</span> the <span class="hljs-type">name</span> <span class="hljs-comment">--</span><br>        // the comparison <span class="hljs-keyword">is</span> possible since contracts<br>        // are implicitly convertible <span class="hljs-keyword">to</span> addresses.<br>        <span class="hljs-keyword">if</span> (msg.sender == address(creator))<br>            <span class="hljs-type">name</span> = newName;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> transfer(address newOwner) <span class="hljs-built_in">public</span> &#123;<br>        // <span class="hljs-keyword">Only</span> the <span class="hljs-keyword">current</span> <span class="hljs-keyword">owner</span> can transfer the token.<br>        <span class="hljs-keyword">if</span> (msg.sender != <span class="hljs-keyword">owner</span>) <span class="hljs-keyword">return</span>;<br>        // We <span class="hljs-keyword">also</span> want <span class="hljs-keyword">to</span> ask the creator <span class="hljs-keyword">if</span> the transfer<br>        // <span class="hljs-keyword">is</span> fine. Note that this calls a <span class="hljs-keyword">function</span> <span class="hljs-keyword">of</span> the<br>        // contract defined below. <span class="hljs-keyword">If</span> the <span class="hljs-keyword">call</span> fails (e.g.<br>        // due <span class="hljs-keyword">to</span> <span class="hljs-keyword">out</span>-<span class="hljs-keyword">of</span>-gas), the execution here stops<br>        // immediately.<br>        <span class="hljs-keyword">if</span> (creator.isTokenTransferOK(<span class="hljs-keyword">owner</span>, newOwner))<br>            owner = newOwner;<br>    &#125;<br>&#125;<br><br>contract TokenCreator &#123;<br>    <span class="hljs-keyword">function</span> createToken(bytes32 <span class="hljs-type">name</span>)<br>       <span class="hljs-built_in">public</span><br>       <span class="hljs-keyword">returns</span> (OwnedToken tokenAddress)<br>    &#123;<br>        // <span class="hljs-keyword">Create</span> a <span class="hljs-built_in">new</span> Token contract <span class="hljs-keyword">and</span> <span class="hljs-keyword">return</span> its address.<br>        // <span class="hljs-keyword">From</span> the JavaScript side, the <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">is</span> simply<br>        // `address`, <span class="hljs-keyword">as</span> this <span class="hljs-keyword">is</span> the closest <span class="hljs-keyword">type</span> available <span class="hljs-keyword">in</span><br>        // the ABI.<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span> OwnedToken(<span class="hljs-type">name</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> changeName(OwnedToken tokenAddress, bytes32 <span class="hljs-type">name</span>)  <span class="hljs-built_in">public</span> &#123;<br>        // Again, the <span class="hljs-keyword">external</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">of</span> `tokenAddress` <span class="hljs-keyword">is</span><br>        // simply `address`.<br>        tokenAddress.changeName(<span class="hljs-type">name</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> isTokenTransferOK(address currentOwner, address newOwner)<br>        <span class="hljs-built_in">public</span><br>        <span class="hljs-keyword">view</span><br>        <span class="hljs-keyword">returns</span> (<span class="hljs-type">bool</span> ok)<br>    &#123;<br>        // 这段可以说是胡诌的<br>        // <span class="hljs-keyword">Check</span> <span class="hljs-keyword">some</span> arbitrary condition.<br>        address tokenAddress = msg.sender;<br>        <span class="hljs-keyword">return</span> (keccak256(newOwner) &amp; <span class="hljs-number">0xff</span>) == (bytes20(tokenAddress) &amp; <span class="hljs-number">0xff</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="可见性和-getter">可见性和 Getter</h4>
<p>内部调用只产生 JUMP，而外部调用产生 EVM call。</p>
<p>有四种可见性：<code>external</code>，<code>public</code>，<code>internal</code>或者 <code>private</code>。这四个可见性，恰好是两组反义词。</p>
<p>状态变量默认可见性是<code>internal</code>而不可能是<code>external</code>。</p>
<p><strong>函数默认可见性是 public！</strong></p>
<p>external：外部函数是合约接口的一部分。意味着他们应该被从外部调用，必然产生 EVM call。一个<code>external</code>的<code>f</code>是不能<code>f()</code>的，只能<code>this.f()</code>。</p>
<p>public：公共函数也是合约接口的一部分。可以外部调用也可以内部调用。最简单而完美的接口设计。公共变量会自动产生一个 getter 函数。</p>
<p>internal：内部函数和变量只能合约内部访问，不用 this。类似 private。</p>
<p>private：内部函数和变量不能被继承，只能内部访问。</p>
<p>注意，合约的所有内容在区块链上都是公开可见的，这些修饰符只能阻止不当修改。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// This will not compile</span><br>pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">private</span> data;<br><br>    <span class="hljs-function">function <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a</span>) <span class="hljs-keyword">private</span> <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> b</span>)</span> &#123; <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-function">function <span class="hljs-title">setData</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a</span>) <span class="hljs-keyword">public</span></span> &#123; data = a; &#125;<br>    <span class="hljs-function">function <span class="hljs-title">getData</span>() <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123; <span class="hljs-keyword">return</span> data; &#125;<br>    <span class="hljs-function">function <span class="hljs-title">compute</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b</span>) <span class="hljs-keyword">internal</span> <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123; <span class="hljs-keyword">return</span> a+b; &#125;<br>&#125;<br><br>contract D &#123;<br>    <span class="hljs-function">function <span class="hljs-title">readData</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        C c = <span class="hljs-keyword">new</span> C();<br>        <span class="hljs-built_in">uint</span> local = c.f(<span class="hljs-number">7</span>); <span class="hljs-comment">// error: member `f` is not visible</span><br>        c.setData(<span class="hljs-number">3</span>);<br>        local = c.getData();<br>        local = c.compute(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// error: member `compute` is not visible</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 通过继承，实现了代码复用</span><br>contract E <span class="hljs-keyword">is</span> C &#123;<br>    <span class="hljs-function">function <span class="hljs-title">g</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        C c = <span class="hljs-keyword">new</span> C();<br>        <span class="hljs-built_in">uint</span> val = compute(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>); <span class="hljs-comment">// access to internal member (from derived to parent contract)</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="getter">Getter</h5>
<p>getter 是自动生成的，一个调用的例子。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> data = <span class="hljs-number">42</span>;<br>&#125;<br><br>contract Caller &#123;<br>    C c = <span class="hljs-keyword">new</span> C();<br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-comment">// 换言之，用函数来访问公共变量，不要用点操作符。</span><br>        <span class="hljs-built_in">uint</span> local = c.data();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>内外访问与内部访问：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract C &#123;<br>    uint <span class="hljs-keyword">public</span> <span class="hljs-keyword">data</span>;<br>    function x() <span class="hljs-keyword">public</span> &#123;<br>        <span class="hljs-keyword">data</span> = <span class="hljs-number">3</span>; <span class="hljs-comment">// internal access</span><br>        uint <span class="hljs-keyword">val</span> = <span class="hljs-keyword">this</span>.<span class="hljs-keyword">data</span>(); <span class="hljs-comment">// external access</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个更复杂的例子：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs zephir">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract Complex &#123;<br>    struct Data &#123;<br>        <span class="hljs-keyword">uint</span> a;<br>        bytes3 b;<br>        mapping (<span class="hljs-keyword">uint</span> =&gt; <span class="hljs-keyword">uint</span>) map;<br>    &#125;<br>    mapping (<span class="hljs-keyword">uint</span> =&gt; mapping(<span class="hljs-keyword">bool</span> =&gt; Data[])) <span class="hljs-keyword">public</span> data;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>生成的函数的形式很费解：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs zephir"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">data</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> arg1, <span class="hljs-keyword">bool</span> arg2, <span class="hljs-keyword">uint</span> arg3)</span> <span class="hljs-title">public</span> <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span> a, bytes3 b)</span> </span>&#123;<br>    a = data[arg1][arg2][arg3].a;<br>    b = data[arg1][arg2][arg3].b;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="函数修饰符">函数修饰符</h4>
<p>函数修饰符是用来改变函数行为的，比如检验条件。函数修饰符可以被集成也可以被覆盖。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br>contract owned &#123;<br>    <span class="hljs-function">function <span class="hljs-title">owned</span>() <span class="hljs-keyword">public</span></span> &#123; owner = msg.sender; &#125;<br>    address owner;<br><br>    <span class="hljs-comment">// This contract only defines a modifier but does not use</span><br>    <span class="hljs-comment">// it: it will be used in derived contracts.</span><br>    <span class="hljs-comment">// The function body is inserted where the special symbol</span><br>    <span class="hljs-comment">// `_;` in the definition of a modifier appears.</span><br>    <span class="hljs-comment">// This means that if the owner calls this function, the</span><br>    <span class="hljs-comment">// function is executed and otherwise, an exception is</span><br>    <span class="hljs-comment">// thrown.</span><br>    modifier onlyOwner &#123;<br>        require(msg.sender == owner);<br>        _;<br>    &#125;<br>&#125;<br><br>contract mortal <span class="hljs-keyword">is</span> owned &#123;<br>    <span class="hljs-comment">// This contract inherits the `onlyOwner` modifier from</span><br>    <span class="hljs-comment">// `owned` and applies it to the `close` function, which</span><br>    <span class="hljs-comment">// causes that calls to `close` only have an effect if</span><br>    <span class="hljs-comment">// they are made by the stored owner.</span><br>    <span class="hljs-function">function <span class="hljs-title">close</span>() <span class="hljs-keyword">public</span> onlyOwner</span> &#123;<br>        selfdestruct(owner);<br>    &#125;<br>&#125;<br><br>contract priced &#123;<br>    <span class="hljs-comment">// Modifiers can receive arguments:</span><br>    <span class="hljs-function">modifier <span class="hljs-title">costs</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> price</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.<span class="hljs-keyword">value</span> &gt;= price) &#123;<br>            _;<br>        &#125;<br>    &#125;<br>&#125;<br><br>contract Register <span class="hljs-keyword">is</span> priced, owned &#123;<br>    mapping (address =&gt; <span class="hljs-built_in">bool</span>) registeredAddresses;<br>    <span class="hljs-built_in">uint</span> price;<br><br>    <span class="hljs-function">function <span class="hljs-title">Register</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> initialPrice</span>) <span class="hljs-keyword">public</span></span> &#123; price = initialPrice; &#125;<br>    <br>    <span class="hljs-comment">// 如果没有这个关键字，合约会自动拒绝被发送过来的以太币</span><br>    <span class="hljs-comment">// It is important to also provide the</span><br>    <span class="hljs-comment">// `payable` keyword here, otherwise the function will</span><br>    <span class="hljs-comment">// automatically reject all Ether sent to it.</span><br>    <span class="hljs-function">function <span class="hljs-title">register</span>() <span class="hljs-keyword">public</span> payable <span class="hljs-title">costs</span>(<span class="hljs-params">price</span>)</span> &#123;<br>        registeredAddresses[msg.sender] = <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">changePrice</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> _price</span>) <span class="hljs-keyword">public</span> onlyOwner</span> &#123;<br>        price = _price;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 巧妙地加锁，类似 synchronized。</span><br>contract Mutex &#123;<br>    <span class="hljs-built_in">bool</span> locked;<br>    <span class="hljs-function">modifier <span class="hljs-title">noReentrancy</span>()</span> &#123;<br>        require(!locked);<br>        locked = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 让步修饰符，类似 Ruby 中的 yield。</span><br>        _;<br>        locked = <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> This function is protected by a mutex, which means that</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> reentrant calls from within `msg.sender.call` cannot call `f` again.</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> The `return 7` statement assigns 7 to the return value but still</span><br>    <span class="hljs-comment"><span class="hljs-doctag">///</span> executes the statement `locked = false` in the modifier.</span><br>    <span class="hljs-function">function <span class="hljs-title">f</span>() <span class="hljs-keyword">public</span> noReentrancy <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">uint</span></span>)</span> &#123;<br>        require(msg.sender.call());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">7</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="状态常量">状态常量</h4>
<p>状态变量可以被声明为<code>constant</code>。它们必须被编译时已知常量值的表达式赋值，表达式不能接触 storage (e.g. <code>now</code>，<code>this.balance</code> 或者 <code>block.number</code>)，不能由执行数据决定（<code>msg.value</code>或者<code>gasleft()</code>），或者外部合约调用。允许使用内部计算函数<code>keccak256</code> ，<code>sha256</code>，<code>ripemd160</code>，<code>ecrecover</code>，<code>addmod</code>和<code>mulmod</code>。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">pragma</span> solidity<span class="hljs-regexp"> ^0.4.0</span>;<br><br><span class="hljs-attribute">contract</span> C &#123;<br>    <span class="hljs-attribute">uint</span> constant x = <span class="hljs-number">32</span>**<span class="hljs-number">22</span> + <span class="hljs-number">8</span>;<br>    <span class="hljs-attribute">string</span> constant text = <span class="hljs-string">&quot;abc&quot;</span>;<br>    <span class="hljs-attribute">bytes32</span> constant myHash = keccak256(<span class="hljs-string">&quot;abc&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="函数">函数</h4>
<h5 id="view">view</h5>
<p>不修改状态的函数可以被声明为<code>view</code>。</p>
<p>以下情况不能用<code>view</code>：</p>
<ol>
<li>写状态变量</li>
<li>发射事件</li>
<li>创建其他合约</li>
<li>使用自毁</li>
<li>用调用发送以太币（也就是说 call 也不安全）</li>
<li>调用其他非<code>view</code>或者<code>pure</code>方法。</li>
<li>使用低级调用方法。</li>
<li>使用某些特定内联汇编操作码。</li>
</ol>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>contract C &#123;<br>    <span class="hljs-built_in">function</span> f(<span class="hljs-built_in">uint</span> a, <span class="hljs-built_in">uint</span> b) <span class="hljs-keyword">public</span> view returns (<span class="hljs-built_in">uint</span>) &#123;<br>        <span class="hljs-keyword">return</span> a * (b + <span class="hljs-number">42</span>) + now;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>getter 都是<code>view</code>。</p>
<p>view 是尽量做到最大限度的编程安全，有时候又不能保证。所以是个未完成品。</p>
<h5 id="pure-函数">pure 函数</h5>
<p>不读和写 state 的函数叫 pure 函数。view 是不写，pure 更彻底。pure 可能产生副作用，不是函数式编程里的纯函数。</p>
<p>pure 函数首先必须满足 view 函数的要求，然后不能有以下行为：</p>
<ol>
<li>读状态变量</li>
<li>访问任何 balance。</li>
<li>访问 block，tx 和 msg 的任何成员。</li>
<li>调用非<code>pure</code>的其他函数。</li>
<li>使用某些特定内联汇编操作码。</li>
</ol>
<p>pure 也是未完成品，编译器不能保证函数的不读不写。</p>
<h5 id="降级函数">降级函数</h5>
<p>一个合约只能由一个无名函数。这个函数不能有参数列表，也不能有返回值。合约在被调用，但没有合适的函数匹配得上，或者没有任何调用数据的时候，这个函数就被派上用场了。</p>
<p>这个函数在合约接收到纯以太币（没有数据）的时候，这个函数也会被执行。为了接收以太币，这个函数必须被声明为 payable。没有这个函数，普通转账事务无法往这个合约里转账。</p>
<p>这个函数最少需要 2300个 gas（恰好是普通转账的十分之一）。</p>
<p>即使这个函数没有任何参数，它也可以用<code>msg.data</code>来获取调用载荷。换言之，调用这种函数，应该发送一些没有其他函数可以匹配得上的实参。</p>
<p>早版本的 Solidity 里面降级函数都调用失败的话，是不退币的，现在的版本退币了。</p>
<p>即使没有降级函数，自毁和挖矿的目标依然可以设置为这个合约账户。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract Test &#123;<br>    <span class="hljs-comment">// This function is called for all messages sent to</span><br>    <span class="hljs-comment">// this contract (there is no other function).</span><br>    <span class="hljs-comment">// Sending Ether to this contract will cause an exception,</span><br>    <span class="hljs-comment">// because the fallback function does not have the `payable`</span><br>    <span class="hljs-comment">// modifier.</span><br>    <span class="hljs-built_in">function</span>() <span class="hljs-keyword">public</span> &#123; x = <span class="hljs-number">1</span>; &#125;<br>    <span class="hljs-built_in">uint</span> x;<br>&#125;<br><br><br><span class="hljs-comment">// This contract keeps all Ether sent to it with no way</span><br><span class="hljs-comment">// to get it back.</span><br>contract Sink &#123;<br>    <span class="hljs-built_in">function</span>() <span class="hljs-keyword">public</span> payable &#123; &#125;<br>&#125;<br><br>contract Caller &#123;<br>    <span class="hljs-built_in">function</span> callTest(Test test) <span class="hljs-keyword">public</span> &#123;<br>        test.call(<span class="hljs-number">0</span>xabcdef01); <span class="hljs-comment">// hash does not exist</span><br>        <span class="hljs-comment">// results in test.x becoming == 1.</span><br><br>        <span class="hljs-comment">// The following will not compile, but even</span><br>        <span class="hljs-comment">// if someone sends ether to that contract,</span><br>        <span class="hljs-comment">// the transaction will fail and reject the</span><br>        <span class="hljs-comment">// Ether.</span><br>        <span class="hljs-comment">//test.send(2 ether);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="函数重载">函数重载</h5>
<p>大部分情况下同其他重载一样。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-comment">// This will not compile</span><br><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>contract A &#123;<br>    <span class="hljs-built_in">function</span> f(B _in) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (B <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = _in;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span> f(address _in) <span class="hljs-keyword">public</span> <span class="hljs-keyword">pure</span> returns (address <span class="hljs-keyword">out</span>) &#123;<br>        <span class="hljs-keyword">out</span> = _in;<br>    &#125;<br>&#125;<br><br>contract B &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个函数之所以编译错误，是因为编译后的 ABI 类型都是 address，等于没有重载。</p>
<h4 id="事件">事件</h4>
<p>事件允许方便地使用 EVM 的日志基础设施。</p>
<p>日志可以被在合约内部被继承。日志与事务、合约关联，与区块同在。</p>
<p>日志的 SPV 证明是可以做到的。</p>
<p>最多三个参数可以被标记为<code>indexed</code>来索引。其实索引的查找，可能是通过散列存储和查找的方式来实现的。本质上就是把这个参数存成 topic 类型的数据，可以被类似流处理的机制监听起来。</p>
<p>事件的正统 watch 用法：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scss">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-selector-class">.0</span>;<br><br>contract ClientReceipt &#123;<br>    event <span class="hljs-built_in">Deposit</span>(<br>        address indexed _from,<br>        bytes32 indexed _id,<br>        uint _value<br>    );<br><br>    function <span class="hljs-built_in">deposit</span>(bytes32 _id) public payable &#123;<br>        <span class="hljs-comment">// Events are emitted using `emit`, followed by</span><br>        <span class="hljs-comment">// the name of the event and the arguments</span><br>        <span class="hljs-comment">// (if any) in parentheses. Any such invocation</span><br>        <span class="hljs-comment">// (even deeply nested) can be detected from</span><br>        <span class="hljs-comment">// the JavaScript API by filtering for `Deposit`.</span><br>        emit <span class="hljs-built_in">Deposit</span>(msg.sender, _id, msg.value);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> abi = <span class="hljs-comment">/* abi as generated by the compiler */</span>;<br><span class="hljs-keyword">var</span> ClientReceipt = web3.eth.contract(abi);<br><span class="hljs-keyword">var</span> clientReceipt = ClientReceipt.at(<span class="hljs-string">&quot;0x1234...ab67&quot;</span> <span class="hljs-comment">/* address */</span>);<br><br><span class="hljs-keyword">var</span> event = clientReceipt.Deposit();<br><br><span class="hljs-comment">// watch for changes</span><br>event.watch(<span class="hljs-keyword">function</span>(<span class="hljs-params">error, result</span>)&#123;<br>    <span class="hljs-comment">// result will contain various information</span><br>    <span class="hljs-comment">// including the argumets given to the `Deposit`</span><br>    <span class="hljs-comment">// call.</span><br>    <span class="hljs-keyword">if</span> (!error)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;);<br><br><span class="hljs-comment">// Or pass a callback to start watching immediately</span><br><span class="hljs-keyword">var</span> event = clientReceipt.Deposit(<span class="hljs-keyword">function</span>(<span class="hljs-params">error, result</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!error)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);<br>&#125;);<br></code></pre></td></tr></table></figure>
<h5 id="低级日志设施">低级日志设施</h5>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span>.<span class="hljs-number">10</span>;<br><br>contract C &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">f</span>() public payable &#123;<br>        bytes32 _id = 0x420042;<br>        log3(<br>            bytes32(msg.value),<br>            bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20),<br>            bytes32(msg.sender),<br>            _id<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>logn 一共取 n+1个参数。第一个参数放在 data 区，其他参数放在 topic 区。</p>
<h5 id="其他理解事件的资源">其他理解事件的资源</h5>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events">Javascript documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/debris/smart-exchange/blob/master/lib/contracts/SmartExchange.sol">Example usage of events</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/debris/smart-exchange/blob/master/lib/exchange_transactions.js">How to access them in js</a></li>
</ul>
<h4 id="继承">继承</h4>
<p>Solidity 支持某种程度上的多继承，它需要拷贝包括多态在内的代码。当一个合约多继承的时候，在链上只创建一份合约，其他</p>
<p>所有的函数调用都是虚调用。</p>
<p>继承系统非常像 Python 的元类继承。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>contract owned &#123;<br>    <span class="hljs-function">function <span class="hljs-title">owned</span>()</span> &#123; owner = msg.sender; &#125;<br>    address owner;<br>&#125;<br><br><span class="hljs-comment">// 只有 private 不会被继承下来</span><br><span class="hljs-comment">// Use `is` to derive from another contract. Derived</span><br><span class="hljs-comment">// contracts can access all non-private members including</span><br><span class="hljs-comment">// internal functions and state variables. These cannot be</span><br><span class="hljs-comment">// accessed externally via `this`, though.</span><br>contract mortal <span class="hljs-keyword">is</span> owned &#123;<br>    <span class="hljs-function">function <span class="hljs-title">kill</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 没有函数体的函数。其合约是抽象的。完全没有函数体的合约只能当接口用。</span><br><span class="hljs-comment">// These abstract contracts are only provided to make the</span><br><span class="hljs-comment">// interface known to the compiler. Note the function</span><br><span class="hljs-comment">// without body. If a contract does not implement all</span><br><span class="hljs-comment">// functions it can only be used as an interface.</span><br>contract Config &#123;<br>    <span class="hljs-function">function <span class="hljs-title">lookup</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> id</span>) <span class="hljs-keyword">public</span> <span class="hljs-title">returns</span> (<span class="hljs-params">address adr</span>)</span>;<br>&#125;<br><br>contract NameReg &#123;<br>    <span class="hljs-function">function <span class="hljs-title">register</span>(<span class="hljs-params">bytes32 name</span>) <span class="hljs-keyword">public</span></span>;<br>    <span class="hljs-function">function <span class="hljs-title">unregister</span>() <span class="hljs-keyword">public</span></span>;<br> &#125;<br><br><span class="hljs-comment">// 多继承类似 C++ 的虚继承，不会有多份重复成员。</span><br><span class="hljs-comment">// Multiple inheritance is possible. Note that `owned` is</span><br><span class="hljs-comment">// also a base class of `mortal`, yet there is only a single</span><br><span class="hljs-comment">// instance of `owned` (as for virtual inheritance in C++).</span><br>contract named <span class="hljs-keyword">is</span> owned, mortal &#123;<br>    <span class="hljs-function">function <span class="hljs-title">named</span>(<span class="hljs-params">bytes32 name</span>)</span> &#123;<br>        Config config = Config(<span class="hljs-number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);<br>        NameReg(config.lookup(<span class="hljs-number">1</span>)).register(name);<br>    &#125;<br><br>    <span class="hljs-comment">// Functions can be overridden by another function with the same name and</span><br>    <span class="hljs-comment">// the same number/types of inputs.  If the overriding function has different</span><br>    <span class="hljs-comment">// types of output parameters, that causes an error.</span><br>    <span class="hljs-comment">// Both local and message-based function calls take these overrides</span><br>    <span class="hljs-comment">// into account.</span><br>    <span class="hljs-function">function <span class="hljs-title">kill</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == owner) &#123;<br>            Config config = Config(<span class="hljs-number">0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970</span>);<br>            NameReg(config.lookup(<span class="hljs-number">1</span>)).unregister();<br>            <span class="hljs-comment">// It is still possible to call a specific</span><br>            <span class="hljs-comment">// overridden function.</span><br>            mortal.kill();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这样调用显式构造函数就讨厌了</span><br><span class="hljs-comment">// If a constructor takes an argument, it needs to be</span><br><span class="hljs-comment">// provided in the header (or modifier-invocation-style at</span><br><span class="hljs-comment">// the constructor of the derived contract (see below)).</span><br>contract PriceFeed <span class="hljs-keyword">is</span> owned, mortal, named(<span class="hljs-string">&quot;GoldFeed&quot;</span>) &#123;<br>   <span class="hljs-function">function <span class="hljs-title">updateInfo</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> newInfo</span>) <span class="hljs-keyword">public</span></span> &#123;<br>      <span class="hljs-keyword">if</span> (msg.sender == owner) info = newInfo;<br>   &#125;<br><br>   <span class="hljs-function">function <span class="hljs-title">get</span>() <span class="hljs-keyword">public</span> view <span class="hljs-title">returns</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> r</span>)</span> &#123; <span class="hljs-keyword">return</span> info; &#125;<br><br>   <span class="hljs-built_in">uint</span> info;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>一个菱形继承的讨厌问题：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract <span class="hljs-keyword">owned</span> &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">owned</span>() <span class="hljs-built_in">public</span> &#123; owner = msg.sender; &#125;<br>    address <span class="hljs-keyword">owner</span>;<br>&#125;<br><br>contract mortal <span class="hljs-keyword">is</span> <span class="hljs-keyword">owned</span> &#123;<br>    <span class="hljs-keyword">function</span> kill() <span class="hljs-built_in">public</span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender == <span class="hljs-keyword">owner</span>) selfdestruct(<span class="hljs-keyword">owner</span>);<br>    &#125;<br>&#125;<br><br>contract Base1 <span class="hljs-keyword">is</span> mortal &#123;<br>    <span class="hljs-keyword">function</span> kill() <span class="hljs-built_in">public</span> &#123; <span class="hljs-comment">/* do cleanup 1 */</span> super.kill(); &#125;<br>&#125;<br><br><br>contract Base2 <span class="hljs-keyword">is</span> mortal &#123;<br>    <span class="hljs-keyword">function</span> kill() <span class="hljs-built_in">public</span> &#123; <span class="hljs-comment">/* do cleanup 2 */</span> super.kill(); &#125;<br>&#125;<br><br>contract Final <span class="hljs-keyword">is</span> Base1, Base2 &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>继承顺序大概是Final，Base2，Base1，mortal，owned。</p>
<p>调用顺序很复杂，需要用的时候还是看教程原文吧。</p>
<h5 id="构造器">构造器</h5>
<p>构造器可以是<code>public</code>也可以是<code>internal</code>。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br>contract A &#123;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> a;<br>    <br>    <span class="hljs-comment">// A 因为这个构造器变成了抽象类</span><br>    <span class="hljs-function">function <span class="hljs-title">A</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> _a</span>) <span class="hljs-keyword">internal</span></span> &#123;<br>        a = _a;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 显式实例化</span><br><span class="hljs-function">contract B <span class="hljs-keyword">is</span> <span class="hljs-title">A</span>(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span> &#123;<br>    <span class="hljs-function">function <span class="hljs-title">B</span>() <span class="hljs-keyword">public</span></span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="基类构造器参数">基类构造器参数</h5>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br>contract Base &#123;<br>    <span class="hljs-built_in">uint</span> x;<br>    <span class="hljs-function">function <span class="hljs-title">Base</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> _x</span>) <span class="hljs-keyword">public</span></span> &#123; x = _x; &#125;<br>&#125;<br><br><span class="hljs-comment">// 用两种方法调用基类构造器</span><br><span class="hljs-function">contract Derived <span class="hljs-keyword">is</span> <span class="hljs-title">Base</span>(<span class="hljs-params"><span class="hljs-number">7</span></span>)</span> &#123;<br>    <span class="hljs-comment">// 第二种方法赢了</span><br>    <span class="hljs-function">function <span class="hljs-title">Derived</span>(<span class="hljs-params"><span class="hljs-built_in">uint</span> _y</span>) <span class="hljs-title">Base</span>(<span class="hljs-params">_y * _y</span>) <span class="hljs-keyword">public</span></span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="多重继承与线性化">多重继承与线性化</h5>
<p>Solidity 学习 Python 的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C3_linearization">C3线性化</a>来解决<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">菱形问题</a>。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs maxima">// This will <span class="hljs-keyword">not</span> <span class="hljs-built_in">compile</span><br><br>pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-built_in">contract</span> X &#123;&#125;<br><span class="hljs-built_in">contract</span> A <span class="hljs-built_in">is</span> X &#123;&#125;<br><span class="hljs-built_in">contract</span> C <span class="hljs-built_in">is</span> A, X &#123;&#125;<br></code></pre></td></tr></table></figure>
<h5 id="抽象合约">抽象合约</h5>
<p>两种情况下会产生抽象合约：</p>
<ul>
<li>有函数没有函数体</li>
<li>构造函数是<code>internal</code>的。</li>
</ul>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span>.<span class="hljs-number">0</span>;<br><br>contract Feline &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">utterance</span>() public returns (bytes32);<br>&#125;<br><br>contract Cat <span class="hljs-keyword">is</span> Feline &#123;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title">utterance</span>() public returns (bytes32) &#123; <span class="hljs-keyword">return</span> <span class="hljs-type">&quot;miaow&quot;</span>; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对比</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 无函数体函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(address)</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(address)</span>;<br><span class="hljs-comment">// 函数变量</span><br><span class="hljs-keyword">function</span><span class="hljs-params">(address)</span> <span class="hljs-title function_">external</span> <span class="hljs-title function_">returns</span> <span class="hljs-params">(address)</span> <span class="hljs-title function_">foo</span>;<br></code></pre></td></tr></table></figure>
<h4 id="接口">接口</h4>
<p>接口就是完全没有任何函数体的合约。和 cpp 里抽象类到接口的顺序是一致的。</p>
<p>而且还有以下很熟悉的限制：</p>
<ul>
<li>不能继承其他合约和接口</li>
<li>不能定义构造器</li>
<li>不能定义变量</li>
<li>不能定义结构体</li>
<li>不能定义枚举</li>
</ul>
<p>接口就是 ABI 的等价形式，两者之间应该可以无损互转。</p>
<p>接口有自己的关键字。</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br><span class="hljs-keyword">interface</span> Token &#123;<br>    <span class="hljs-built_in">function</span> transfer(address recipient, <span class="hljs-built_in">uint</span> amount) <span class="hljs-keyword">public</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用接口和继承其他合约一样，也就是都是 is 关键字，没有其他用法。</p>
<h4 id="库">库</h4>
<p>库类似于合约。他们的目的是只在特定的地址上部署一次，然后通过<code>DELEGATECALL</code>调用。这意味着，库函数会在当前合约的上下文里被调用，反而不像外部调用(直接调用其他合约地址的实例方法一样)，产生 EVM call。函数里的 this 都会绑定到当前合约，类似 bind。</p>
<p>当然，代理调用是底层实现的，在使用上是看不出来的。库的<code>internal</code>函数，对于调用它的合约也是可见的，这些代码就好像是一个被 mixin 进合约里的基类合约一样。调用内部函数用的是<code>JUMP</code>而不是<code>DELEGATECALL</code>。</p>
<p>在这里，库是一个 util 式的用法。换言之，库里必须都是是<code>view</code>或者<code>pure</code>函数。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs zephir">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>library Set &#123;<br>  <span class="hljs-comment">// We define a new struct datatype that will be used to</span><br>  <span class="hljs-comment">// hold its data in the calling contract.</span><br>  struct Data &#123; mapping(<span class="hljs-keyword">uint</span> =&gt; <span class="hljs-keyword">bool</span>) flags; &#125;<br><br>  <span class="hljs-comment">// Note that the first parameter is of type &quot;storage</span><br>  <span class="hljs-comment">// reference&quot; and thus only its storage address and not</span><br>  <span class="hljs-comment">// its contents is passed as part of the call.  This is a</span><br>  <span class="hljs-comment">// special feature of library functions.  It is idiomatic</span><br>  <span class="hljs-comment">// to call the first parameter `self`, if the function can</span><br>  <span class="hljs-comment">// be seen as a method of that object.</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">insert</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">      <span class="hljs-title">public</span></span><br><span class="hljs-function">      <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function">  </span>&#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>.flags[value])<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// already there</span><br>      <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">true</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">remove</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">      <span class="hljs-title">public</span></span><br><span class="hljs-function">      <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function">  </span>&#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">self</span>.flags[value])<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <span class="hljs-comment">// not there</span><br>      <span class="hljs-keyword">self</span>.flags[value] = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">contains</span><span class="hljs-params">(Data storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">      <span class="hljs-title">public</span></span><br><span class="hljs-function">      <span class="hljs-title">view</span></span><br><span class="hljs-function">      <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function">  </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.flags[value];<br>  &#125;<br>&#125;<br><br>contract C &#123;<br>    Set.Data knownValues;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">register</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> value)</span> <span class="hljs-title">public</span> </span>&#123;<br>        <span class="hljs-comment">// The library functions can be called without a</span><br>        <span class="hljs-comment">// specific instance of the library, since the</span><br>        <span class="hljs-comment">// &quot;instance&quot; will be the current contract.</span><br>        <span class="hljs-keyword">require</span>(Set.insert(knownValues, value));<br>    &#125;<br>    <span class="hljs-comment">// In this contract, we can also directly access knownValues.flags, if we want.</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>库也有限制：</p>
<ul>
<li>不能有状态变量</li>
<li>不能继承其他也不能被继承</li>
<li>不能接收以太币</li>
</ul>
<h4 id="using-for">Using For</h4>
<p><code>using A for B;</code> 表明，把一个库的函数添加到一个指定类型上。这导致了这些库函数多了一个（隐式的）消息接受者对象作为第一个参数，这类似 Python 里的 self。</p>
<p><code>using A for *;</code>表明 A 的库函数被附着给任意类型。这可能也是为什么库不能有自己的 state 的原因吧。</p>
<p>没有用到 self 的一个例子：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>library <span class="hljs-type">BigInt</span> &#123;<br><br>    // 这个结构体本来是没有成员函数的。<br>    struct <span class="hljs-type">bigint</span> &#123;<br>        uint[] limbs;<br>    &#125;<br><br>    // 全部都是 pure 函数<br>    <span class="hljs-keyword">function</span> fromUint(uint x) <span class="hljs-type">internal</span> pure <span class="hljs-keyword">returns</span> (<span class="hljs-type">bigint</span> r) &#123;<br>        r.limbs = <span class="hljs-built_in">new</span> uint[](<span class="hljs-number">1</span>);<br>        r.limbs[<span class="hljs-number">0</span>] = x;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-keyword">add</span>(<span class="hljs-type">bigint</span> _a, <span class="hljs-type">bigint</span> _b) <span class="hljs-type">internal</span> pure <span class="hljs-keyword">returns</span> (<span class="hljs-type">bigint</span> r) &#123;<br>        r.limbs = <span class="hljs-built_in">new</span> uint[](max(_a.limbs.length, _b.limbs.length));<br>        uint carry = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (uint i = <span class="hljs-number">0</span>; i &lt; r.limbs.length; ++i) &#123;<br>            uint a = limb(_a, i);<br>            uint b = limb(_b, i);<br>            r.limbs[i] = a + b + carry;<br>            <span class="hljs-keyword">if</span> (a + b &lt; a || (a + b == uint(<span class="hljs-number">-1</span>) &amp;&amp; carry &gt; <span class="hljs-number">0</span>))<br>                carry = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span><br>                carry = <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (carry &gt; <span class="hljs-number">0</span>) &#123;<br>            // too bad, we have <span class="hljs-keyword">to</span> <span class="hljs-keyword">add</span> a limb<br>            uint[] memory newLimbs = <span class="hljs-built_in">new</span> uint[](r.limbs.length + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; r.limbs.length; ++i)<br>                newLimbs[i] = r.limbs[i];<br>            newLimbs[i] = carry;<br>            r.limbs = newLimbs;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> limb(<span class="hljs-type">bigint</span> _a, uint _limb) <span class="hljs-type">internal</span> pure <span class="hljs-keyword">returns</span> (uint) &#123;<br>        <span class="hljs-keyword">return</span> _limb &lt; _a.limbs.length ? _a.limbs[_limb] : <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> max(uint a, uint b) private pure <span class="hljs-keyword">returns</span> (uint) &#123;<br>        <span class="hljs-keyword">return</span> a &gt; b ? a : b;<br>    &#125;<br>&#125;<br><br>contract C &#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-type">BigInt</span> <span class="hljs-keyword">for</span> <span class="hljs-type">BigInt</span>.bigint;<br><br>    <span class="hljs-keyword">function</span> f() <span class="hljs-built_in">public</span> pure &#123;<br>        // 这里的三个变量类型都是 <span class="hljs-type">BigInt</span>.bigint，但增加了库函数<br>        var x = <span class="hljs-type">BigInt</span>.fromUint(<span class="hljs-number">7</span>);<br>        var y = <span class="hljs-type">BigInt</span>.fromUint(uint(<span class="hljs-number">-1</span>));<br>        var z = x.<span class="hljs-keyword">add</span>(y);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>self 可以不是必须的，也可以有，另一个例子：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>// This <span class="hljs-keyword">is</span> the same code <span class="hljs-keyword">as</span> <span class="hljs-keyword">before</span>, just <span class="hljs-keyword">without</span> comments<br>library <span class="hljs-keyword">Set</span> &#123;<br>  struct Data &#123; <span class="hljs-keyword">mapping</span>(uint =&gt; <span class="hljs-type">bool</span>) flags; &#125;<br><br>  <span class="hljs-keyword">function</span> <span class="hljs-keyword">insert</span>(Data <span class="hljs-keyword">storage</span> self, uint <span class="hljs-keyword">value</span>)<br>      <span class="hljs-built_in">public</span><br>      <span class="hljs-keyword">returns</span> (<span class="hljs-type">bool</span>)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (self.flags[<span class="hljs-keyword">value</span>])<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; // already there<br>      self.flags[<span class="hljs-keyword">value</span>] = <span class="hljs-keyword">true</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> remove(Data <span class="hljs-keyword">storage</span> self, uint <span class="hljs-keyword">value</span>)<br>      <span class="hljs-built_in">public</span><br>      <span class="hljs-keyword">returns</span> (<span class="hljs-type">bool</span>)<br>  &#123;<br>      <span class="hljs-keyword">if</span> (!self.flags[<span class="hljs-keyword">value</span>])<br>          <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; // <span class="hljs-keyword">not</span> there<br>      self.flags[<span class="hljs-keyword">value</span>] = <span class="hljs-keyword">false</span>;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>  &#125;<br><br>  <span class="hljs-keyword">function</span> contains(Data <span class="hljs-keyword">storage</span> self, uint <span class="hljs-keyword">value</span>)<br>      <span class="hljs-built_in">public</span><br>      <span class="hljs-keyword">view</span><br>      <span class="hljs-keyword">returns</span> (<span class="hljs-type">bool</span>)<br>  &#123;<br>      <span class="hljs-keyword">return</span> self.flags[<span class="hljs-keyword">value</span>];<br>  &#125;<br>&#125;<br><br>contract C &#123;<br>    <span class="hljs-keyword">using</span> <span class="hljs-keyword">Set</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">Set</span>.Data; // this <span class="hljs-keyword">is</span> the crucial change<br>    // 用名字空间来访问内部类型<br>    <span class="hljs-keyword">Set</span>.Data knownValues;<br><br>    <span class="hljs-keyword">function</span> register(uint <span class="hljs-keyword">value</span>) <span class="hljs-built_in">public</span> &#123;<br>        // Here, <span class="hljs-keyword">all</span> variables <span class="hljs-keyword">of</span> <span class="hljs-keyword">type</span> <span class="hljs-keyword">Set</span>.Data have<br>        // corresponding member <span class="hljs-keyword">functions</span>.<br>        // The <span class="hljs-keyword">following</span> <span class="hljs-keyword">function</span> <span class="hljs-keyword">call</span> <span class="hljs-keyword">is</span> identical <span class="hljs-keyword">to</span><br>        // `<span class="hljs-keyword">Set</span>.<span class="hljs-keyword">insert</span>(knownValues, <span class="hljs-keyword">value</span>)`<br>        // 从第二个参数传起<br>        require(knownValues.<span class="hljs-keyword">insert</span>(<span class="hljs-keyword">value</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对基础类型的猴子补丁：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs zephir">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.16</span>;<br><br>library Search &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">indexOf</span><span class="hljs-params">(<span class="hljs-keyword">uint</span>[] storage <span class="hljs-keyword">self</span>, <span class="hljs-keyword">uint</span> value)</span></span><br><span class="hljs-function">        <span class="hljs-title">public</span></span><br><span class="hljs-function">        <span class="hljs-title">view</span></span><br><span class="hljs-function">        <span class="hljs-title">returns</span> <span class="hljs-params">(<span class="hljs-keyword">uint</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">uint</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">self</span>.length; i++)<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">self</span>[i] == value) <span class="hljs-keyword">return</span> i;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">uint</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>&#125;<br><br>contract C &#123;<br>    using Search <span class="hljs-keyword">for</span> <span class="hljs-keyword">uint</span>[];<br>    <span class="hljs-keyword">uint</span>[] data;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">append</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> value)</span> <span class="hljs-title">public</span> </span>&#123;<br>        data.push(value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-keyword">uint</span> _old, <span class="hljs-keyword">uint</span> _new)</span> <span class="hljs-title">public</span> </span>&#123;<br>        <span class="hljs-comment">// This performs the library function call</span><br>        <span class="hljs-keyword">uint</span> index = data.indexOf(_old);<br>        <span class="hljs-keyword">if</span> (index == <span class="hljs-keyword">uint</span>(<span class="hljs-number">-1</span>))<br>            data.push(_new);<br>        <span class="hljs-keyword">else</span><br>            data[index] = _new;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="solidity-汇编">Solidity 汇编</h3>
<p>Solidity 支持手写汇编模式。</p>
<h3 id="杂项">杂项</h3>
<h4 id="有用的小技巧">有用的小技巧</h4>
<ul>
<li>使用<code>delete</code>删除所有的数组元素。</li>
<li>调用内部 send 的方法是<code>address(contractVariable).send(amount)</code>。</li>
<li>用字面量的方法初始化结构体（而不是合约）：<code>x = MyStruct(&#123;a: 1, b: 2&#125;);</code>。</li>
</ul>
<h2 id="安全问题">安全问题</h2>
<h3 id="可重入">可重入</h3>
<p>所有的 send 本质上都可以包含代码执行（因为降级函数的存在），所有以下两个合约都是有漏洞的：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br>contract Fund &#123;<br>    <span class="hljs-comment">/// Mapping of ether shares of the contract.</span><br>    mapping(<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> uint) shares;<br>    <span class="hljs-comment">/// Withdraw your share.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">withdraw</span>(<span class="hljs-params"></span>) <span class="hljs-title function_">public</span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender.send(shares[msg.sender]))<br>            shares[msg.sender] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.0</span>;<br><br><span class="hljs-comment">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br>contract Fund &#123;<br>    <span class="hljs-comment">/// Mapping of ether shares of the contract.</span><br>    mapping(<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> uint) shares;<br>    <span class="hljs-comment">/// Withdraw your share.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">withdraw</span>(<span class="hljs-params"></span>) <span class="hljs-title function_">public</span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.sender.call.value(shares[msg.sender])())<br>            shares[msg.sender] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>被调用方如果在自己的降级函数里面再调用这个合约的提取函数，那么它可以无限提取钱，直到 out-of-gas 异常发生为止。</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br>contract Fund &#123;<br>    <span class="hljs-comment">/// Mapping of ether shares of the contract.</span><br>    mapping(<span class="hljs-function"><span class="hljs-params">address</span> =&gt;</span> uint) shares;<br>    <span class="hljs-comment">/// Withdraw your share.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">withdraw</span>(<span class="hljs-params"></span>) <span class="hljs-title function_">public</span> &#123;<br>        <span class="hljs-keyword">var</span> share = shares[msg.sender];<br>        shares[msg.sender] = <span class="hljs-number">0</span>;<br>        msg.sender.transfer(share);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只有这个先扣款的钱包才能防别人反向递归调用自己。</p>
<h3 id="转以太币相关问题">转以太币相关问题</h3>
<p>一个地址和账户没有办法抗拒别人向它转账，除非转账失败。不用消息调用也可以移动以太币的方法有两个：挖矿和自毁。</p>
<p><code>addr.call.value(x)()</code>等价于<code>addr.transfer(x)</code>，但它把剩余的 gas 全都提供给接受者，让它执行更贵的操作了。</p>
<p>一定要记得检查<code>send</code>的返回值。</p>
<h3 id="tx-origin">tx.origin</h3>
<p>一个类似 CSRF 的相关问题：</p>
<p>一个检查 tx.origin 的钱包</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span>.<span class="hljs-number">11</span>;<br><br>// THIS CONTRACT CONTAINS A BUG - <span class="hljs-keyword">DO</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">USE</span><br>contract TxUserWallet &#123;<br>    address owner;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title">TxUserWallet</span>() public &#123;<br>        owner = msg.sender;<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title">transferTo</span>(address dest, uint amount) public &#123;<br>        require(tx.origin == owner);<br>        dest.transfer(amount);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>一个攻击者的钱包</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs d"><span class="hljs-keyword">pragma</span> solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br><span class="hljs-keyword">interface</span> TxUserWallet &#123;<br>    <span class="hljs-built_in">function</span> transferTo(address dest, <span class="hljs-built_in">uint</span> amount) <span class="hljs-keyword">public</span>;<br>&#125;<br><br>contract TxAttackWallet &#123;<br>    address owner;<br><br>    <span class="hljs-built_in">function</span> TxAttackWallet() <span class="hljs-keyword">public</span> &#123;<br>        owner = msg.sender;<br>    &#125;<br><br>    <span class="hljs-built_in">function</span>() <span class="hljs-keyword">public</span> &#123;<br>        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只要被攻击者往攻击者钱包转账，攻击者钱包就会发一个新的事务，并借用 tx.origin 来盗取被攻击者的全部余额。每个地址的全部余额都是公开可查的。</p>
<h2 id="通用模式">通用模式</h2>
<h3 id="从合约中取钱">从合约中取钱</h3>
<p>比谁更有钱的合约：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br>contract WithdrawalContract &#123;<br>    address <span class="hljs-keyword">public</span> richest;<br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> mostSent;<br><br>    mapping (address =&gt; <span class="hljs-built_in">uint</span>) pendingWithdrawals;<br><br>    <span class="hljs-function">function <span class="hljs-title">WithdrawalContract</span>() <span class="hljs-keyword">public</span> payable</span> &#123;<br>        richest = msg.sender;<br>        mostSent = msg.<span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">becomeRichest</span>() <span class="hljs-keyword">public</span> payable <span class="hljs-title">returns</span> (<span class="hljs-params"><span class="hljs-built_in">bool</span></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (msg.<span class="hljs-keyword">value</span> &gt; mostSent) &#123;<br>            pendingWithdrawals[richest] += msg.<span class="hljs-keyword">value</span>;<br>            richest = msg.sender;<br>            mostSent = msg.<span class="hljs-keyword">value</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">withdraw</span>() <span class="hljs-keyword">public</span></span> &#123;<br>        <span class="hljs-built_in">uint</span> amount = pendingWithdrawals[msg.sender];<br>        <span class="hljs-comment">// Remember to zero the pending refund before</span><br>        <span class="hljs-comment">// sending to prevent re-entrancy attacks</span><br>        pendingWithdrawals[msg.sender] = <span class="hljs-number">0</span>;<br>        msg.sender.transfer(amount);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="用-modifier-来设定可访问性的问题">用 modifier 来设定可访问性的问题</h3>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs typescript">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br>contract <span class="hljs-title class_">AccessRestriction</span> &#123;<br>    <span class="hljs-comment">// These will be assigned at the construction</span><br>    <span class="hljs-comment">// phase, where `msg.sender` is the account</span><br>    <span class="hljs-comment">// creating this contract.</span><br>    address <span class="hljs-keyword">public</span> owner = msg.<span class="hljs-property">sender</span>;<br>    uint <span class="hljs-keyword">public</span> creationTime = now;<br><br>    <span class="hljs-comment">// Modifiers can be used to change</span><br>    <span class="hljs-comment">// the body of a function.</span><br>    <span class="hljs-comment">// If this modifier is used, it will</span><br>    <span class="hljs-comment">// prepend a check that only passes</span><br>    <span class="hljs-comment">// if the function is called from</span><br>    <span class="hljs-comment">// a certain address.</span><br>    modifier <span class="hljs-title function_">onlyBy</span>(<span class="hljs-params">address _account</span>)<br>    &#123;<br>        <span class="hljs-built_in">require</span>(msg.<span class="hljs-property">sender</span> == _account);<br>        <span class="hljs-comment">// Do not forget the &quot;_;&quot;! It will</span><br>        <span class="hljs-comment">// be replaced by the actual function</span><br>        <span class="hljs-comment">// body when the modifier is used.</span><br>        _;<br>    &#125;<br><br>    <span class="hljs-comment">/// Make `_newOwner` the new owner of this</span><br>    <span class="hljs-comment">/// contract.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">changeOwner</span>(<span class="hljs-params">address _newOwner</span>)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-title function_">onlyBy</span>(<span class="hljs-params">owner</span>)<br>    &#123;<br>        owner = _newOwner;<br>    &#125;<br><br>    modifier <span class="hljs-title function_">onlyAfter</span>(<span class="hljs-params">uint _time</span>) &#123;<br>        <span class="hljs-built_in">require</span>(now &gt;= _time);<br>        _;<br>    &#125;<br><br>    <span class="hljs-comment">/// Erase ownership information.</span><br>    <span class="hljs-comment">/// May only be called 6 weeks after</span><br>    <span class="hljs-comment">/// the contract has been created.</span><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">disown</span>(<span class="hljs-params"></span>)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-title function_">onlyBy</span>(owner)<br>        <span class="hljs-title function_">onlyAfter</span>(<span class="hljs-params">creationTime + <span class="hljs-number">6</span> weeks</span>)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> owner;<br>    &#125;<br><br>    <span class="hljs-comment">// This modifier requires a certain</span><br>    <span class="hljs-comment">// fee being associated with a function call.</span><br>    <span class="hljs-comment">// If the caller sent too much, he or she is</span><br>    <span class="hljs-comment">// refunded, but only after the function body.</span><br>    <span class="hljs-comment">// This was dangerous before Solidity version 0.4.0,</span><br>    <span class="hljs-comment">// where it was possible to skip the part after `_;`.</span><br>    modifier <span class="hljs-title function_">costs</span>(<span class="hljs-params">uint _amount</span>) &#123;<br>        <span class="hljs-built_in">require</span>(msg.<span class="hljs-property">value</span> &gt;= _amount);<br>        _;<br>        <span class="hljs-keyword">if</span> (msg.<span class="hljs-property">value</span> &gt; _amount)<br>            msg.<span class="hljs-property">sender</span>.<span class="hljs-title function_">send</span>(msg.<span class="hljs-property">value</span> - _amount);<br>    &#125;<br><br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">forceOwnerChange</span>(<span class="hljs-params">address _newOwner</span>)<br>        <span class="hljs-keyword">public</span><br>        <span class="hljs-title function_">costs</span>(<span class="hljs-params"><span class="hljs-number">200</span> ether</span>)<br>    &#123;<br>        owner = _newOwner;<br>        <span class="hljs-comment">// just some example condition</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-title function_">uint</span>(owner) &amp; <span class="hljs-number">0</span> == <span class="hljs-number">1</span>)<br>            <span class="hljs-comment">// This did not refund for Solidity</span><br>            <span class="hljs-comment">// before version 0.4.0.</span><br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// refund overpaid fees</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="状态机">状态机</h3>
<p>这个例子有两个有意思的地方：</p>
<ul>
<li>modifier 可以叠加</li>
<li>可以由时间自动驱动状态机执行</li>
</ul>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs csharp">pragma solidity ^<span class="hljs-number">0.4</span><span class="hljs-number">.11</span>;<br><br>contract StateMachine &#123;<br>    <span class="hljs-built_in">enum</span> Stages &#123;<br>        AcceptingBlindedBids,<br>        RevealBids,<br>        AnotherStage,<br>        AreWeDoneYet,<br>        Finished<br>    &#125;<br><br>    <span class="hljs-comment">// This is the current stage.</span><br>    Stages <span class="hljs-keyword">public</span> stage = Stages.AcceptingBlindedBids;<br><br>    <span class="hljs-built_in">uint</span> <span class="hljs-keyword">public</span> creationTime = now;<br><br>    <span class="hljs-function">modifier <span class="hljs-title">atStage</span>(<span class="hljs-params">Stages _stage</span>)</span> &#123;<br>        require(stage == _stage);<br>        _;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">nextStage</span>() <span class="hljs-keyword">internal</span></span> &#123;<br>        stage = Stages(<span class="hljs-built_in">uint</span>(stage) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 必须放在最开始</span><br>    <span class="hljs-comment">// Perform timed transitions. Be sure to mention</span><br>    <span class="hljs-comment">// this modifier first, otherwise the guards</span><br>    <span class="hljs-comment">// will not take the new stage into account.</span><br>    <span class="hljs-function">modifier <span class="hljs-title">timedTransitions</span>()</span> &#123;<br>        <span class="hljs-keyword">if</span> (stage == Stages.AcceptingBlindedBids &amp;&amp;<br>                    now &gt;= creationTime + <span class="hljs-number">10</span> days)<br>            nextStage();<br>        <span class="hljs-keyword">if</span> (stage == Stages.RevealBids &amp;&amp;<br>                now &gt;= creationTime + <span class="hljs-number">12</span> days)<br>            nextStage();<br>        <span class="hljs-comment">// The other stages transition by transaction</span><br>        _;<br>    &#125;<br><br>    <span class="hljs-comment">// Order of the modifiers matters here!</span><br>    <span class="hljs-function">function <span class="hljs-title">bid</span>()</span><br><span class="hljs-function">        <span class="hljs-keyword">public</span></span><br><span class="hljs-function">        payable</span><br><span class="hljs-function">        timedTransitions</span><br><span class="hljs-function">        <span class="hljs-title">atStage</span>(<span class="hljs-params">Stages.AcceptingBlindedBids</span>)</span><br>    &#123;<br>        <span class="hljs-comment">// We will not implement that here</span><br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">reveal</span>()</span><br><span class="hljs-function">        <span class="hljs-keyword">public</span></span><br><span class="hljs-function">        timedTransitions</span><br><span class="hljs-function">        <span class="hljs-title">atStage</span>(<span class="hljs-params">Stages.RevealBids</span>)</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-comment">// This modifier goes to the next stage</span><br>    <span class="hljs-comment">// after the function is done.</span><br>    <span class="hljs-function">modifier <span class="hljs-title">transitionNext</span>()</span><br>    &#123;<br>        _;<br>        nextStage();<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">g</span>()</span><br><span class="hljs-function">        <span class="hljs-keyword">public</span></span><br><span class="hljs-function">        timedTransitions</span><br><span class="hljs-function">        <span class="hljs-title">atStage</span>(<span class="hljs-params">Stages.AnotherStage</span>)</span><br><span class="hljs-function">        transitionNext</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">h</span>()</span><br><span class="hljs-function">        <span class="hljs-keyword">public</span></span><br><span class="hljs-function">        timedTransitions</span><br><span class="hljs-function">        <span class="hljs-title">atStage</span>(<span class="hljs-params">Stages.AreWeDoneYet</span>)</span><br><span class="hljs-function">        transitionNext</span><br>    &#123;<br>    &#125;<br><br>    <span class="hljs-function">function <span class="hljs-title">i</span>()</span><br><span class="hljs-function">        <span class="hljs-keyword">public</span></span><br><span class="hljs-function">        timedTransitions</span><br><span class="hljs-function">        <span class="hljs-title">atStage</span>(<span class="hljs-params">Stages.Finished</span>)</span><br>    &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/">https://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><a class="post-meta__tags" href="/tags/Ethereum/">Ethereum</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-100.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/31/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9B%B8%E5%85%B3%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99/" title="以太坊相关研究资料"><img class="cover" src="/img/wall-paper-118.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-31</div><div class="info-item-2">以太坊相关研究资料</div></div><div class="info-2"><div class="info-item-1"> 《以太坊的 gas 费率一览表》 《以太坊学习笔记：私有链搭建操作指南》 《以太坊中的账户、交易、Gas和区块Gas Limit》 StackOverflow 上的问答：以太坊主链到底需要多大空间？ StackOverflow 上的问答：怎样提供无限次数的智能合约操作？ 《区块链技术-智能合约-以太坊 （译文）》 《以太坊官方文档》 《以太坊私有链搭建指南》 《以太坊关于搭建私有网络的 wiki》 《预充值以太坊资金的方法》。注意看 carchrae 的回复，这里面也提供了拷贝私钥复用私钥的方法，可以考虑在多节点的情况下使用。 《一本与参数有关的介绍怎样搭建私链的 gitbook》。 StackOverflow 上的问答：以太坊的网络难度是否可以静态锁死？注意看它还有个相关的子问题。如果网络算力的稳定的话，应该不会出现难度增长才对。 值得大读特读的 geth 的文档。特别是挖矿、账户管理的部分。 geth 的命令行选项。注意，有些选项在当前版本中已经消失了，如（gpomin、gpomax）。 StackOverflow 上的问答：如何降低测试网络中的难度。感觉没多大用。 搜索以...</div></div></div></a><a class="pagination-related" href="/2018/01/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E7%A1%AC%E5%88%86%E5%8F%89/" title="以太坊的硬分叉"><img class="cover" src="/img/wall-paper-105.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-01-24</div><div class="info-item-2">以太坊的硬分叉</div></div><div class="info-2"><div class="info-item-1">  有四次计划内的软件升级，每次都是硬分叉：Frontier，Homestead，Metropolis，Serenity。   有一次意料之外的分叉（DAO 事件），制造出 ETH 和以太经典两种货币。   每次分叉都会造成矿工的迁移。旧链会因为流失算力而丧失安全性。   大都会分叉本来打算引爆难度炸弹，迫使矿工们从 PoW 共识算法移动到 PoA 共识算法，让以太坊进入冰河时代。但这个难度炸弹的引爆被延后了。   大都会同样引入了一个 PoS 的早期实施，Casper共存 算法允许每一百个区块里会有一个 PoS 区块。关于 PoS 算法，Vitalik 的解释是：  想象现在有 100 个人围着圆桌，其中有一个人拿着很多张纸，每张纸记录着很多笔历史交易信息。第一个人拿起笔签完后递给第二个人，第二个人也做出了相同的选择，如果大多数人做出了相同的选择，即都签署了同一张纸那么每一个参与者会获得1美元，当你做出和绝大多数人不同的选择时，那么你的房子就会着火！    如果真的不能阻止矿工停留在 PoW 上继续挖矿，那将会创建三种以太坊币：ETC、ETH-PoW、ETH-PoS，这对以太坊...</div></div></div></a><a class="pagination-related" href="/2018/02/03/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%8E%E9%9A%8F%E6%9C%BA%E6%95%B0%E9%97%AE%E9%A2%98/" title="以太坊与随机数问题"><img class="cover" src="/img/wall-paper-170.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-02-03</div><div class="info-item-2">以太坊与随机数问题</div></div><div class="info-2"><div class="info-item-1">值得注意的几篇文章： 这个 reddit 上的帖子里提到了 RANDAO 其实是不够安全的，但下面 RANDAO 的作者又出来说这个东西被它改进过了。 这个话题下面还有人引了 Vitalik 的一篇博客。 randao的实现。基本上就是用一个dao 的方式（Decentralized autonomous organization）来运行一个匿名先知组织。这个设计思路和 Vitalik 谈到的用先知而不是全上链的版本来运行智能合约的对比基本一致。 vdice 自己的博客里也提到了用未来的块hash来生成随机数是不安全的，他们直接使用了oraclize。改天要分析下它们所谓的“200行的安全的codebase”。 </div></div></div></a><a class="pagination-related" href="/2018/01/31/%E5%AD%A6%E4%B9%A0%E5%8C%BA%E5%9D%97%E9%93%BE%E7%9A%84%E5%9F%BA%E7%A1%80%E8%B5%84%E6%96%99/" title="学习区块链的基础资料"><img class="cover" src="/img/wall-paper-163.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-01-31</div><div class="info-item-2">学习区块链的基础资料</div></div><div class="info-2"><div class="info-item-1">《猥琐发育成区块链开发者》 普林斯顿的《Bitcoin and Cryptocurrency Technologies》课程 《精通比特币（第二版）》 </div></div></div></a><a class="pagination-related" href="/2018/02/03/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%80%82%E5%90%88%E6%8B%BF%E6%9D%A5%E5%81%9A%E8%81%94%E7%9B%9F%E9%93%BE%EF%BC%9F/" title="以太坊为什么不适合拿来做联盟链？"><img class="cover" src="/img/wall-paper-169.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-02-03</div><div class="info-item-2">以太坊为什么不适合拿来做联盟链？</div></div><div class="info-2"><div class="info-item-1">联盟链必然要求多个账户系统存在，联盟中的每个节点都必须独立保存自己的私钥，则在当前的 gas 系统限制下，每个账户必须有自己的ether存款。 是不是允许多头出块？如果允许多头出块，则各个账户可以预先prefund或者在网络启动的时候充钱，不必考虑货币流通性问题。但多头出块的缺点是，不可抵挡分叉。而且，实际上极有可能还是存在货币流通性问题。 不允许多头出块，则必须由我们自己的中心账户来出块，我们自己来出块的话，其他账户发起合约请求需要的货币需要定期从我们的中心账户提取出来。 如果可以用强一致性的协议来预先持久化所有的写消息，也许可以靠监控把错误恢复过来，当然这也对业务产生了强依赖，业务的写操作必须是可以通过类似反幂等的方式恢复过来的。这就是把Raft分布式强一致性协议当做一个分布式的WAL来用了。ES 不适合拿来当这个 WAL，因为它不是强实时写的。 </div></div></div></a><a class="pagination-related" href="/2018/03/08/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB%E9%97%AE%E9%A2%98/" title="重放攻击问题"><img class="cover" src="/img/wall-paper-81.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-03-08</div><div class="info-item-2">重放攻击问题</div></div><div class="info-2"><div class="info-item-1">比特币靠不同的地址前缀可以规避重放攻击问题。 以太坊可以靠 EIP155 钱包来规避重放攻击问题。 何为重放攻击问题？ 一个区块链有若干个测试网络。如果一套公私钥可以在不同的网络上通用，则可以恶意地把在测试网络中出现的 transaction 播放到主网上。如果在测试网络上有人从账户 A 转了一笔钱到账户 B，而账户 B 是一个傻瓜测试账户，私钥是由类似123456之类的种子生成的话。那么只要账户 A 在主网中的余额大于这笔钱，心怀恶意者就能把主网中 A 的钱财转走，从主网中的账户 B 里把钱取出来。即使心怀恶意者没有 B 的取款方法，也能让账户 A 蒙受资金损失。 所以不要跨网使用相同的公私钥对。 </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%85%A5%E9%97%A8-%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.</span> <span class="toc-text">智能合约入门&#x2F;介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">第一个基本的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E8%B4%A7%E5%B8%81%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.2.</span> <span class="toc-text">子货币的例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.</span> <span class="toc-text">区块链基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">区块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.4.</span> <span class="toc-text">以太坊虚拟机</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E8%A7%88"><span class="toc-number">1.4.1.</span> <span class="toc-text">概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A6%E6%88%B7"><span class="toc-number">1.4.2.</span> <span class="toc-text">账户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">1.4.3.</span> <span class="toc-text">事务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gas"><span class="toc-number">1.4.4.</span> <span class="toc-text">Gas</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#storage-memory-%E5%92%8C-stack"><span class="toc-number">1.4.5.</span> <span class="toc-text">Storage， Memory 和 Stack</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="toc-number">1.4.6.</span> <span class="toc-text">指令集</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E8%B0%83%E7%94%A8"><span class="toc-number">1.4.7.</span> <span class="toc-text">消息调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delegatecall-%E5%A7%94%E6%89%98%E8%B0%83%E7%94%A8-callcode-%E8%B0%83%E7%94%A8%E4%BB%A3%E7%A0%81-%E5%92%8C-libraries-%E5%BA%93"><span class="toc-number">1.4.8.</span> <span class="toc-text">Delegatecall（委托调用）&#x2F;Callcode（调用代码） 和 Libraries(库)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">1.4.9.</span> <span class="toc-text">日志</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">1.4.10.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%AF%81"><span class="toc-number">1.4.11.</span> <span class="toc-text">自毁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#solidity%E4%B8%BE%E4%BE%8B"><span class="toc-number">2.</span> <span class="toc-text">Solidity举例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E4%B8%BE"><span class="toc-number">2.1.</span> <span class="toc-text">选举</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B2%E6%8B%8D%E5%8D%96"><span class="toc-number">2.2.</span> <span class="toc-text">盲拍卖</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%8B%8D%E5%8D%96"><span class="toc-number">2.2.1.</span> <span class="toc-text">简单拍卖</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B2%E6%8B%8D%E5%8D%96"><span class="toc-number">2.2.2.</span> <span class="toc-text">盲拍卖</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%B4%AD%E4%B9%B0"><span class="toc-number">2.3.</span> <span class="toc-text">安全的远程购买</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5solidity"><span class="toc-number">3.</span> <span class="toc-text">深入Solidity</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#solidity-%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%BD%AE%E5%BB%93"><span class="toc-number">3.1.</span> <span class="toc-text">Solidity 源文件的轮廓</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC-pragma"><span class="toc-number">3.1.1.</span> <span class="toc-text">版本 pragma</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E6%BA%90%E6%96%87%E4%BB%B6"><span class="toc-number">3.2.</span> <span class="toc-text">引入其他源文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%92%8C%E8%AF%AD%E4%B9%89"><span class="toc-number">3.2.1.</span> <span class="toc-text">语法和语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%AF%E5%BE%84"><span class="toc-number">3.2.2.</span> <span class="toc-text">路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.3.</span> <span class="toc-text">重映射问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A%E9%97%AE%E9%A2%98"><span class="toc-number">3.2.4.</span> <span class="toc-text">注释问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.</span> <span class="toc-text">合约的结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F"><span class="toc-number">3.3.1.</span> <span class="toc-text">状态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.2.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.3.3.</span> <span class="toc-text">函数修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.3.4.</span> <span class="toc-text">事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#struct-%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.5.</span> <span class="toc-text">Struct 类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.3.6.</span> <span class="toc-text">枚举类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.</span> <span class="toc-text">类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.1.</span> <span class="toc-text">值类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">布尔类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">整型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">定点数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">地址类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E9%95%BF%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.1.5.</span> <span class="toc-text">定长字节数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E9%95%BF%E5%BA%A6%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.1.6.</span> <span class="toc-text">动态长度字节数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.4.1.7.</span> <span class="toc-text">地址字面量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E7%90%86%E6%95%B0%E5%92%8C%E6%95%B4%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.4.1.8.</span> <span class="toc-text">有理数和整数字面量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.4.1.9.</span> <span class="toc-text">字符串字面量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="toc-number">3.4.1.10.</span> <span class="toc-text">十六进制字面量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">3.4.1.11.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.1.12.</span> <span class="toc-text">函数类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.2.</span> <span class="toc-text">引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">数据位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E5%AD%98%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">创建内存数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AD%97%E9%9D%A2%E9%87%8F-%E5%86%85%E8%81%94%E6%95%B0%E7%BB%84"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">数组字面量&#x2F;内联数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%88%90%E5%91%98"><span class="toc-number">3.4.2.5.</span> <span class="toc-text">成员</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.4.2.6.</span> <span class="toc-text">结构体类型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%A0%E5%B0%84"><span class="toc-number">3.4.3.</span> <span class="toc-text">映射</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B5%E6%B6%89%E5%88%B0%E5%B7%A6%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">3.4.4.</span> <span class="toc-text">牵涉到左值的操作符</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#delete"><span class="toc-number">3.4.4.1.</span> <span class="toc-text">delete</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.4.5.</span> <span class="toc-text">基本数据类型之间的转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="toc-number">3.4.6.</span> <span class="toc-text">类型推导</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E4%BD%8D%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%AF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="toc-number">3.5.</span> <span class="toc-text">单位和全局可用变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%B8%81%E7%9A%84%E5%8D%95%E4%BD%8D"><span class="toc-number">3.5.1.</span> <span class="toc-text">以太币的单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D"><span class="toc-number">3.5.2.</span> <span class="toc-text">时间单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.3.</span> <span class="toc-text">特殊的变量和函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%BA%E5%9D%97%E5%92%8C%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7"><span class="toc-number">3.5.3.1.</span> <span class="toc-text">区块和事务属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">3.5.3.2.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-number">3.5.3.3.</span> <span class="toc-text">数学和密码学函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.</span> <span class="toc-text">表达式和控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E5%92%8C%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0"><span class="toc-number">3.6.1.</span> <span class="toc-text">输入参数和输出参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0"><span class="toc-number">3.6.1.1.</span> <span class="toc-text">输入参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0"><span class="toc-number">3.6.1.2.</span> <span class="toc-text">输出参数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="toc-number">3.6.2.</span> <span class="toc-text">控制结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.6.2.1.</span> <span class="toc-text">多返回值</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#function-calls"><span class="toc-number">3.6.3.</span> <span class="toc-text">Function Calls</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8"><span class="toc-number">3.6.3.1.</span> <span class="toc-text">内部调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="toc-number">3.6.3.2.</span> <span class="toc-text">外部函数调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%B0%83%E7%94%A8%E5%92%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="toc-number">3.6.3.3.</span> <span class="toc-text">命名调用和匿名函数参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9C%81%E7%95%A5%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%90%8D"><span class="toc-number">3.6.3.4.</span> <span class="toc-text">省略函数参数名</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8new%E5%88%9B%E5%BB%BA%E6%96%B0%E5%90%88%E7%BA%A6"><span class="toc-number">3.6.4.</span> <span class="toc-text">用new创建新合约</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="toc-number">3.6.5.</span> <span class="toc-text">表达式求值的顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="toc-number">3.6.6.</span> <span class="toc-text">赋值</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">3.6.6.1.</span> <span class="toc-text">解构赋值和多返回值</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A4%8D%E6%9D%82%E7%82%B9"><span class="toc-number">3.6.6.2.</span> <span class="toc-text">数组和结构体的复杂点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="toc-number">3.6.7.</span> <span class="toc-text">作用域和声明</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%8E-0-5-0-%E5%BC%80%E5%A7%8B%E5%B0%B1%E6%9C%89%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BA%86"><span class="toc-number">3.6.7.1.</span> <span class="toc-text">从 0.5.0 开始就有作用域了</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E6%96%AD%E8%A8%80-%E9%9C%80%E6%B1%82-%E5%8F%8D%E8%BD%AC%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="toc-number">3.6.8.</span> <span class="toc-text">错误处理：断言、需求、反转和异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E7%BA%A6"><span class="toc-number">3.7.</span> <span class="toc-text">合约</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%90%88%E7%BA%A6"><span class="toc-number">3.7.1.</span> <span class="toc-text">创建合约</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C-getter"><span class="toc-number">3.7.2.</span> <span class="toc-text">可见性和 Getter</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#getter"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">Getter</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">3.7.3.</span> <span class="toc-text">函数修饰符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%B8%B8%E9%87%8F"><span class="toc-number">3.7.4.</span> <span class="toc-text">状态常量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.5.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#view"><span class="toc-number">3.7.5.1.</span> <span class="toc-text">view</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#pure-%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.5.2.</span> <span class="toc-text">pure 函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%8D%E7%BA%A7%E5%87%BD%E6%95%B0"><span class="toc-number">3.7.5.3.</span> <span class="toc-text">降级函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="toc-number">3.7.5.4.</span> <span class="toc-text">函数重载</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.7.6.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%8E%E7%BA%A7%E6%97%A5%E5%BF%97%E8%AE%BE%E6%96%BD"><span class="toc-number">3.7.6.1.</span> <span class="toc-text">低级日志设施</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">3.7.6.2.</span> <span class="toc-text">其他理解事件的资源</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">3.7.7.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">3.7.7.1.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0"><span class="toc-number">3.7.7.2.</span> <span class="toc-text">基类构造器参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%8C%96"><span class="toc-number">3.7.7.3.</span> <span class="toc-text">多重继承与线性化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6"><span class="toc-number">3.7.7.4.</span> <span class="toc-text">抽象合约</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.7.8.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%93"><span class="toc-number">3.7.9.</span> <span class="toc-text">库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#using-for"><span class="toc-number">3.7.10.</span> <span class="toc-text">Using For</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#solidity-%E6%B1%87%E7%BC%96"><span class="toc-number">3.8.</span> <span class="toc-text">Solidity 汇编</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">3.9.</span> <span class="toc-text">杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E7%94%A8%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">3.9.1.</span> <span class="toc-text">有用的小技巧</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">4.</span> <span class="toc-text">安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">4.1.</span> <span class="toc-text">可重入</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E4%BB%A5%E5%A4%AA%E5%B8%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.</span> <span class="toc-text">转以太币相关问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tx-origin"><span class="toc-number">4.3.</span> <span class="toc-text">tx.origin</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.</span> <span class="toc-text">通用模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E5%90%88%E7%BA%A6%E4%B8%AD%E5%8F%96%E9%92%B1"><span class="toc-number">5.1.</span> <span class="toc-text">从合约中取钱</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-modifier-%E6%9D%A5%E8%AE%BE%E5%AE%9A%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.</span> <span class="toc-text">用 modifier 来设定可访问性的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">5.3.</span> <span class="toc-text">状态机</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>