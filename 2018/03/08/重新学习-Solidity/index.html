<!DOCTYPE html>

<html lang="zh-Hans">
    <head>
    <meta charset="utf-8">
    <!--
        hexo-theme-suka © SukkaW
        GitHub: https://github.com/SukkaW/hexo-theme-suka
    -->

    <!-- ### Resource Hint ### -->

    <!-- ## DNS Prefetch ## -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

<!-- busuanzi -->

    <link rel="dns-prefetch" href="//busuanzi.ibruce.info">


<!-- comment -->







<!-- analytics -->







    <!-- ## Preload ## -->
    
    <!-- Busuanzi -->
    
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" as="script">







    <!-- ### Meta & Title & Info ### -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <meta name="renderer" content="webkit">

    <!-- Title -->
    <title>重新学习 Solidity | 守株阁</title>

    <!-- Favicons -->
    <link rel="icon" type="image&#x2F;ico" href="/img/suka-favicon.ico">

    <!-- ### Import File ### -->
    <link rel="stylesheet" href="/lib/spectre/spectre.min.css"><style>
    body {
        background-color: #f8f9fa;
    }

    a, a:visited {
        color: #0070ff;
    }

    a:active, a:focus, a:hover {
        color: #0070ff;
        opacity: .75;
    }

    #post-content a,
    #post-content a:hover,
    #post-content a:focus,
    #post-content a:visited {
        color: #005eb9;
        opacity: 1;
    }

    

    .post-entry .card-body a {
        color: #0070ff;
    }

    .avatar {
        background: #444;
    }

    .navbar-link,
    .navbar-link:visited,
    .timeline .timeline-item .timeline-icon.icon-lg {
        color: #0070ff;
    }

    .navbar-link:hover {
        color: #0070ff;
        opacity: .8;
    }

    #search-input .btn,
    #disqus_click_btn,
    #disqus-switch-to-direct,
    #disqus-loadmore-button {
        background: #727e96;
        border-color: #727e96;
        color: #fff;
    }

    #post-toc a.post-toc-link,
    #post-toc a.post-toc-link:visited,
    .share-menu.menu .menu-item>a {
        color: #727e96;
    }

    .share-menu.menu .menu-item>a:hover,
    .share-menu.menu .menu-item>a:focus,
    .share-menu.menu .menu-item>a:visited {
        color: #50596c;
        background: #f8f9fa;
        opacity: .85;
    }
</style><link rel="stylesheet" href="/css/style.min.css">








    <!-- Prettify Theme -->
    
    <link rel="preload" href="/css/highlight/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/css/highlight/github.min.css"></noscript>





<script>
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
!function(t){"use strict";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n<a.length;n++){var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",function(){e.poly(),t.clearInterval(a)}):t.attachEvent&&t.attachEvent("onload",function(){e.poly(),t.clearInterval(a)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}("undefined"!=typeof global?global:this);
</script>

    <!-- ### Site Verification ### -->
    


    <link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="守株阁"><meta name="msapplication-starturl" content="http://magicliang.github.io"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="守株阁"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- ### The Open Graph & Twitter Card Protocol ### -->
    <meta property="og:title" content="重新学习 Solidity | 守株阁"><meta property="og:site_name" content="守株阁"><meta property="og:type" content="article"><meta property="og:url" content="http://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/"><meta property="og:locale" content="zh-Hans"><meta name="description" content="以下内容还是从 Solidity 文档里摘出来的。 智能合约入门&#x2F;介绍第一个基本的例子12345678910111213pragma solidity ^0.4.0;contract SimpleStorage &amp;#123;    uint storedData;    function set(uint x) public &amp;#123;        storedData &#x3D; x;    &amp;#1 - magicliang - 守株阁"><meta name="keywords" content="区块链, Ethereum"><meta property="article:published_time" content="2018-03-08T08:25:00.000Z"><meta property="article:modified_time" content="2019-09-09T13:35:42.000Z"><meta property="og:updated_time" content="2019-09-09T13:35:42.000Z"><meta property="article:author" content="magicliang"><meta property="article:tag" content="区块链, Ethereum"><meta name="twitter:card" content="summary">

    

    <!-- ### Canonical link ### -->
    <link rel="canonical" href="http://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/">

    <meta name="generator" content="Hexo 6.0.0">

    <!-- ### Analytics ### -->
    







    <!-- ### Structured Data ### -->
    



<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "http://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/",
    "@type": "BlogPosting",
    "logo": "http://magicliang.github.io/img/suka-favicon.ico",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/"
    },
    "headline": "重新学习 Solidity | 守株阁",
    
    "image": {
        "@type": "ImageObject",
        "url": "http://magicliang.github.io/img/suka-favicon.ico"
    },
    
    "datePublished": "2018-03-08T08:25:00.000Z",
    "dateModified": "2019-09-09T13:35:42.000Z",
    "author": {
        "@type": "Person",
        "name": "magicliang",
        "image": {
            "@type": "ImageObject",
            "url": "http://magicliang.github.io/img/default_avatar.png"
        },
        "description": "Hi, nice to meet you."
    },
    "publisher": {
        "@type": "Organization",
        "name": "守株阁",
        "logo": {
            "@type": "ImageObject",
            "url": "http://magicliang.github.io/img/suka-favicon.ico"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "http://magicliang.github.io/search?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "区块链, Ethereum",
    "description": "以下内容还是从 Solidity 文档里摘出来的。 智能合约入门/介绍第一个基本的例子12345678910111213pragma solidity ^0.4.0;contract SimpleStorage &amp;amp;#123;    uint storedData;    function set(uint x) public &amp;amp;#123;        storedData = x;    &amp;amp;#1 - magicliang - 守株阁"
}
</script>



    <!-- ### Custom Head ### -->
    
</head>

    <body>
            

            <!-- ### Main content ### -->
            <!-- ## Header ##-->
<header>
    <h1 class="header-title text-center"><a href="/">守株阁</a></h1>

    <p class="text-center header-slogan">
        
            
                Hi, nice to meet you.
            
        
    </p>

    <nav class="navbar-section text-center">
    
        <a href="/" class="navbar-link">Home</a>
    
    
        <a href="/archives/" class="navbar-link">Archives</a>
    
    
        <a href="/search" class="navbar-link">Search</a>
    
    
    
        <div class="dropdown dropdown-right">
    <a class="navbar-link dropdown-toggle" tabindex="0">Share</a>
    <ul class="menu share-menu">

        <!-- Share Weibo -->
        
        <li class="menu-item">
            <a href="http://service.weibo.com/share/share.php?appkey=&title=守株阁&url=http://magicliang.github.io&pic=http://magicliang.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">Share to Weibo</a>
        </li>
        

        <!-- Share Twitter -->
        
        <li class="menu-item">
            <a href="https://twitter.com/intent/tweet?text=守株阁&url=http://magicliang.github.io&via=magicliang" target="_blank" rel="external noopener noreferrer nofollow">Share to Twitter</a>
        </li>
        

        <!-- Share Facebook -->
        
        <li class="menu-item">
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow">Share to Facebook</a>
        </li>
        

        <!-- Share Google+ -->
        
        <li class="menu-item">
            <a href="https://plus.google.com/share?url=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow">Share to Google+</a>
        </li>
        

        <!-- Share LinkedIn -->
        
        <li class="menu-item">
            <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://magicliang.github.io&title=重新学习 Solidity" target="_blank" rel="external noopener noreferrer nofollow">Share to LinkedIn</a>
        </li>
        

        <!-- Share QQ -->
        
        <li class="menu-item">
            <a href="http://connect.qq.com/widget/shareqq/index.html?site=守株阁&title=重新学习 Solidity&summary=关于技术以及人生&pics=http://magicliang.github.io/img/suka-favicon.ico&url=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow"> Share to QQ</a>
        </li>
        

        <!-- Share Telegram -->
        
        <li class="menu-item">
            <a href="https://t.me/share/url?url=http://magicliang.github.io&text=重新学习 Solidity" target="_blank" rel="external noopener noreferrer nofollow">Share to Telegram</a>
        </li>
        

        <!-- QRCode -->
        
        <li class="menu-item">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAAAAAAYplnuAAACxElEQVR42u2c0VLDMAwE8/8/Da/QsXQr1zAw3ryUaRNnnUHodBJ9Pv7h8QgttNBCXwj9NMfXz79dXJzTvf+61uq14xBa6An08pf+ZdHq/Oq8FXT1EAiH0EJPoVdBU8Glc1GiWGwmcQgt9AlosokKpktS5KEILfRPBeIqOXRBVF2TxJXQQp+EJgJmKvo7gdRt8m2VJ/T10Kmw/a3Xo9W40NdCE7E++ZkKqhXUMddU6KuhO8GebphMRVoYVw8hGpBCCx0EUxI3SfAQE4ca+NhUF1roQjClwjQlhs60IUmLXC+00DvQxAjvmj2VsUMT1aiwFVrookasFqXBmozHtJFuvbJyEVroUNjSpDEZBKAB2xXDrVkjtNChsKWN+yccqUBFiYR2t4QWGiQXWggQYUXFVGqaCi30BJqKpNTkPJFk2uEvoYV+A5oIo0lw0YHycXdLaKGbhn4noHY/I0mLmKBCCz2FJs2gJHxo8CajHU/WCC10GLwiATUdMpn+w8LRvx5CXwlNBDndUCok0jBAKh6EFnoy70GTRlfATgzFZE6ihr7QQg+GVGiBSxtA3QMYG5BCCw1NdWK8xASwOaSFNi+00MN5j24B0tgsh7VDU4gaNkILPYGeDK2QgVaasJIIE1roKXQaYu2CdXeAard5JLTQFJqIJLrJiVFZJRM8TCi00HBAlg5UdcOEqXHUwk1NdaGFbr6UpDPMk1lOzUhyv2hACi30RiCm4BwNt8KhrNbAF1poCJ0WT2YKueHkPmUwCy00hE6mDWnuUCFPDE/UKBJaaOjl0YFtIpZ2mp6twSO00BA6ifPpQBY1ManhI7TQO9DEbElCacececAhtNAnoRPwZIBq0kRFDpPQQr8BTQtTajBSM/KtQBT6amgqdKZJJK2ZAn6rCBD6emhiBKak05nkRISNm59CCw2+3+OvH0ILLbTQF0F/AtRq6hiLeZbnAAAAAElFTkSuQmCC" alr="QRCode">
        </li>
        

    </ul>
</div>
    
    
</nav>
</header>

            
    <!-- ## Post ## -->
    <div class="post-container">
    <div id="post-card" class="card">
        
        <div class="card-item-container">
            <div class="card-inner-cell">
                <!-- # Post Header Info # -->
                <div class="card-header">
                    
    <h1 class="card-title h3 mb-2">重新学习 Solidity</h1>




<div class="post-header-info">
    <p class="post-header-info-left text-gray">
        <img class="author-thumb lazyload" data-src="/img/default_avatar.png" src="/img/suka-lazyload.gif" alt="magicliang's Avatar">
        <span>2018-03-08</span>
        
        
            <!-- Busuanzi Post Views -->
<span id="busuanzi_container_page_pv" hidden>
    <span class="suka-devide-dot"></span>
    <span></span>
    <span id="busuanzi_value_page_pv"></span>
    <span>Views</span>
</span>
        
        
    </p>
    <div class="post-header-info-right">
        
            <div class="dropdown dropdown-right">
<a class="dropdown-toggle" tabindex="0">Share the post</a>
<ul class="menu share-menu">
    <!-- Share Weibo -->
    
    <li class="menu-item">
        <a href="http://service.weibo.com/share/share.php?appkey=&title=重新学习 Solidity&url=http://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/&pic=http://magicliang.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">Share to Weibo</a>
    </li>
    

    <!-- Share Twitter -->
    
    <li class="menu-item">
        <a href="https://twitter.com/intent/tweet?text=重新学习 Solidity&url=http://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/&via=magicliang" target="_blank" rel="external noopener noreferrer nofollow">Share to Twitter</a>
    </li>
    

    <!-- Share Facebook -->
    
    <li class="menu-item">
        <a href="https://www.facebook.com/sharer/sharer.php?u=http://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/" target="_blank" rel="external noopener noreferrer nofollow">Share to Facebook</a>
    </li>
    

    <!-- Share Google+ -->
    
    <li class="menu-item">
        <a href="https://plus.google.com/share?url=http://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/" target="_blank" rel="external noopener noreferrer nofollow">Share to Google+</a>
    </li>
    

    <!-- Share LinkedIn -->
    
    <li class="menu-item">
        <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/&title=守株阁" target="_blank" rel="external noopener noreferrer nofollow">Share to LinkedIn</a>
    </li>
    

    <!-- Share QQ -->
    
    <li class="menu-item">
        <a href="http://connect.qq.com/widget/shareqq/index.html?site=守株阁&title=守株阁&summary=关于技术以及人生&pics=http://magicliang.github.io/img/suka-favicon.ico&url=http://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/" target="_blank" rel="external noopener noreferrer nofollow"> Share to QQ</a>
    </li>
    

    <!-- Share Telegram -->
    
    <li class="menu-item">
        <a href="https://t.me/share/url?url=http://magicliang.github.io/2018/03/08/%E9%87%8D%E6%96%B0%E5%AD%A6%E4%B9%A0-Solidity/&text=守株阁" target="_blank" rel="external noopener noreferrer nofollow">Share to Telegram</a>
    </li>
    

    <!-- QRCode -->
    
    <li class="menu-item">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAAAAAAYplnuAAACxElEQVR42u2c0VLDMAwE8/8/Da/QsXQr1zAw3ryUaRNnnUHodBJ9Pv7h8QgttNBCXwj9NMfXz79dXJzTvf+61uq14xBa6An08pf+ZdHq/Oq8FXT1EAiH0EJPoVdBU8Glc1GiWGwmcQgt9AlosokKpktS5KEILfRPBeIqOXRBVF2TxJXQQp+EJgJmKvo7gdRt8m2VJ/T10Kmw/a3Xo9W40NdCE7E++ZkKqhXUMddU6KuhO8GebphMRVoYVw8hGpBCCx0EUxI3SfAQE4ca+NhUF1roQjClwjQlhs60IUmLXC+00DvQxAjvmj2VsUMT1aiwFVrookasFqXBmozHtJFuvbJyEVroUNjSpDEZBKAB2xXDrVkjtNChsKWN+yccqUBFiYR2t4QWGiQXWggQYUXFVGqaCi30BJqKpNTkPJFk2uEvoYV+A5oIo0lw0YHycXdLaKGbhn4noHY/I0mLmKBCCz2FJs2gJHxo8CajHU/WCC10GLwiATUdMpn+w8LRvx5CXwlNBDndUCok0jBAKh6EFnoy70GTRlfATgzFZE6ihr7QQg+GVGiBSxtA3QMYG5BCCw1NdWK8xASwOaSFNi+00MN5j24B0tgsh7VDU4gaNkILPYGeDK2QgVaasJIIE1roKXQaYu2CdXeAard5JLTQFJqIJLrJiVFZJRM8TCi00HBAlg5UdcOEqXHUwk1NdaGFbr6UpDPMk1lOzUhyv2hACi30RiCm4BwNt8KhrNbAF1poCJ0WT2YKueHkPmUwCy00hE6mDWnuUCFPDE/UKBJaaOjl0YFtIpZ2mp6twSO00BA6ifPpQBY1ManhI7TQO9DEbElCacececAhtNAnoRPwZIBq0kRFDpPQQr8BTQtTajBSM/KtQBT6amgqdKZJJK2ZAn6rCBD6emhiBKak05nkRISNm59CCw2+3+OvH0ILLbTQF0F/AtRq6hiLeZbnAAAAAElFTkSuQmCC" alt="QRCode">
    </li>
    

</ul>
</div>
        
    </div>
</div>
                </div>
                <div class="card-body">
                    
                        
                        
                            <div id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6%E5%85%A5%E9%97%A8-%E4%BB%8B%E7%BB%8D"><span class="post-toc-number">1.</span> <span class="post-toc-text">智能合约入门&#x2F;介绍</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">第一个基本的例子</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AD%90%E8%B4%A7%E5%B8%81%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">子货币的例子</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E5%9F%BA%E7%A1%80"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">区块链基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="post-toc-number">1.3.1.</span> <span class="post-toc-text">事务</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8C%BA%E5%9D%97"><span class="post-toc-number">1.3.2.</span> <span class="post-toc-text">区块</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%9D%8A%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">以太坊虚拟机</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%A6%82%E8%A7%88"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">概览</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B4%A6%E6%88%B7"><span class="post-toc-number">1.4.2.</span> <span class="post-toc-text">账户</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%8B%E5%8A%A1-1"><span class="post-toc-number">1.4.3.</span> <span class="post-toc-text">事务</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Gas"><span class="post-toc-number">1.4.4.</span> <span class="post-toc-text">Gas</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Storage%EF%BC%8C-Memory-%E5%92%8C-Stack"><span class="post-toc-number">1.4.5.</span> <span class="post-toc-text">Storage， Memory 和 Stack</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8C%87%E4%BB%A4%E9%9B%86"><span class="post-toc-number">1.4.6.</span> <span class="post-toc-text">指令集</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B6%88%E6%81%AF%E8%B0%83%E7%94%A8"><span class="post-toc-number">1.4.7.</span> <span class="post-toc-text">消息调用</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Delegatecall%EF%BC%88%E5%A7%94%E6%89%98%E8%B0%83%E7%94%A8%EF%BC%89-Callcode%EF%BC%88%E8%B0%83%E7%94%A8%E4%BB%A3%E7%A0%81%EF%BC%89-%E5%92%8C-Libraries-%E5%BA%93"><span class="post-toc-number">1.4.8.</span> <span class="post-toc-text">Delegatecall（委托调用）&#x2F;Callcode（调用代码） 和 Libraries(库)</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%97%A5%E5%BF%97"><span class="post-toc-number">1.4.9.</span> <span class="post-toc-text">日志</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="post-toc-number">1.4.10.</span> <span class="post-toc-text">创建</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%87%AA%E6%AF%81"><span class="post-toc-number">1.4.11.</span> <span class="post-toc-text">自毁</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Solidity%E4%B8%BE%E4%BE%8B"><span class="post-toc-number">2.</span> <span class="post-toc-text">Solidity举例</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E9%80%89%E4%B8%BE"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">选举</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%9B%B2%E6%8B%8D%E5%8D%96"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">盲拍卖</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%AE%80%E5%8D%95%E6%8B%8D%E5%8D%96"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">简单拍卖</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%9B%B2%E6%8B%8D%E5%8D%96-1"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">盲拍卖</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%AE%89%E5%85%A8%E7%9A%84%E8%BF%9C%E7%A8%8B%E8%B4%AD%E4%B9%B0"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">安全的远程购买</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%B7%B1%E5%85%A5Solidity"><span class="post-toc-number">3.</span> <span class="post-toc-text">深入Solidity</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Solidity-%E6%BA%90%E6%96%87%E4%BB%B6%E7%9A%84%E8%BD%AE%E5%BB%93"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">Solidity 源文件的轮廓</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%88%E6%9C%AC-pragma"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">版本 pragma</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%BC%95%E5%85%A5%E5%85%B6%E4%BB%96%E6%BA%90%E6%96%87%E4%BB%B6"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">引入其他源文件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%AF%AD%E6%B3%95%E5%92%8C%E8%AF%AD%E4%B9%89"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">语法和语义</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B7%AF%E5%BE%84"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">路径</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%87%8D%E6%98%A0%E5%B0%84%E9%97%AE%E9%A2%98"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">重映射问题</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%B3%A8%E9%87%8A%E9%97%AE%E9%A2%98"><span class="post-toc-number">3.2.4.</span> <span class="post-toc-text">注释问题</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%90%88%E7%BA%A6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">合约的结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%8A%B6%E6%80%81%E5%8F%98%E9%87%8F"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">状态变量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0"><span class="post-toc-number">3.3.2.</span> <span class="post-toc-text">函数</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="post-toc-number">3.3.3.</span> <span class="post-toc-text">函数修饰符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%8B%E4%BB%B6"><span class="post-toc-number">3.3.4.</span> <span class="post-toc-text">事件</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Struct-%E7%B1%BB%E5%9E%8B"><span class="post-toc-number">3.3.5.</span> <span class="post-toc-text">Struct 类型</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B"><span class="post-toc-number">3.3.6.</span> <span class="post-toc-text">枚举类型</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%B1%BB%E5%9E%8B"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="post-toc-number">3.4.1.</span> <span class="post-toc-text">值类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%B8%83%E5%B0%94%E7%B1%BB%E5%9E%8B"><span class="post-toc-number">3.4.1.1.</span> <span class="post-toc-text">布尔类型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%95%B4%E5%9E%8B"><span class="post-toc-number">3.4.1.2.</span> <span class="post-toc-text">整型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0"><span class="post-toc-number">3.4.1.3.</span> <span class="post-toc-text">定点数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%9C%B0%E5%9D%80%E7%B1%BB%E5%9E%8B"><span class="post-toc-number">3.4.1.4.</span> <span class="post-toc-text">地址类型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AE%9A%E9%95%BF%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="post-toc-number">3.4.1.5.</span> <span class="post-toc-text">定长字节数组</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8A%A8%E6%80%81%E9%95%BF%E5%BA%A6%E5%AD%97%E8%8A%82%E6%95%B0%E7%BB%84"><span class="post-toc-number">3.4.1.6.</span> <span class="post-toc-text">动态长度字节数组</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%9C%B0%E5%9D%80%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="post-toc-number">3.4.1.7.</span> <span class="post-toc-text">地址字面量</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9C%89%E7%90%86%E6%95%B0%E5%92%8C%E6%95%B4%E6%95%B0%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="post-toc-number">3.4.1.8.</span> <span class="post-toc-text">有理数和整数字面量</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="post-toc-number">3.4.1.9.</span> <span class="post-toc-text">字符串字面量</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6%E5%AD%97%E9%9D%A2%E9%87%8F"><span class="post-toc-number">3.4.1.10.</span> <span class="post-toc-text">十六进制字面量</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="post-toc-number">3.4.1.11.</span> <span class="post-toc-text">枚举</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B"><span class="post-toc-number">3.4.1.12.</span> <span class="post-toc-text">函数类型</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="post-toc-number">3.4.2.</span> <span class="post-toc-text">引用类型</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%95%B0%E6%8D%AE%E4%BD%8D%E7%BD%AE"><span class="post-toc-number">3.4.2.1.</span> <span class="post-toc-text">数据位置</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84"><span class="post-toc-number">3.4.2.2.</span> <span class="post-toc-text">数组</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA%E5%86%85%E5%AD%98%E6%95%B0%E7%BB%84"><span class="post-toc-number">3.4.2.3.</span> <span class="post-toc-text">创建内存数组</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84%E5%AD%97%E9%9D%A2%E9%87%8F-%E5%86%85%E8%81%94%E6%95%B0%E7%BB%84"><span class="post-toc-number">3.4.2.4.</span> <span class="post-toc-text">数组字面量&#x2F;内联数组</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%88%90%E5%91%98"><span class="post-toc-number">3.4.2.5.</span> <span class="post-toc-text">成员</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%B1%BB%E5%9E%8B"><span class="post-toc-number">3.4.2.6.</span> <span class="post-toc-text">结构体类型</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%98%A0%E5%B0%84"><span class="post-toc-number">3.4.3.</span> <span class="post-toc-text">映射</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%B5%E6%B6%89%E5%88%B0%E5%B7%A6%E5%80%BC%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="post-toc-number">3.4.4.</span> <span class="post-toc-text">牵涉到左值的操作符</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#delete"><span class="post-toc-number">3.4.4.1.</span> <span class="post-toc-text">delete</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="post-toc-number">3.4.5.</span> <span class="post-toc-text">基本数据类型之间的转换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E5%AF%BC"><span class="post-toc-number">3.4.6.</span> <span class="post-toc-text">类型推导</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8D%95%E4%BD%8D%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%AF%E7%94%A8%E5%8F%98%E9%87%8F"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">单位和全局可用变量</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BB%A5%E5%A4%AA%E5%B8%81%E7%9A%84%E5%8D%95%E4%BD%8D"><span class="post-toc-number">3.5.1.</span> <span class="post-toc-text">以太币的单位</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%97%B6%E9%97%B4%E5%8D%95%E4%BD%8D"><span class="post-toc-number">3.5.2.</span> <span class="post-toc-text">时间单位</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0"><span class="post-toc-number">3.5.3.</span> <span class="post-toc-text">特殊的变量和函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%8C%BA%E5%9D%97%E5%92%8C%E4%BA%8B%E5%8A%A1%E5%B1%9E%E6%80%A7"><span class="post-toc-number">3.5.3.1.</span> <span class="post-toc-text">区块和事务属性</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="post-toc-number">3.5.3.2.</span> <span class="post-toc-text">错误处理</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%95%B0%E5%AD%A6%E5%92%8C%E5%AF%86%E7%A0%81%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="post-toc-number">3.5.3.3.</span> <span class="post-toc-text">数学和密码学函数</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">表达式和控制结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0%E5%92%8C%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0"><span class="post-toc-number">3.6.1.</span> <span class="post-toc-text">输入参数和输出参数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%BE%93%E5%85%A5%E5%8F%82%E6%95%B0"><span class="post-toc-number">3.6.1.1.</span> <span class="post-toc-text">输入参数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%BE%93%E5%87%BA%E5%8F%82%E6%95%B0"><span class="post-toc-number">3.6.1.2.</span> <span class="post-toc-text">输出参数</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84"><span class="post-toc-number">3.6.2.</span> <span class="post-toc-text">控制结构</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="post-toc-number">3.6.2.1.</span> <span class="post-toc-text">多返回值</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Function-Calls"><span class="post-toc-number">3.6.3.</span> <span class="post-toc-text">Function Calls</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%86%85%E9%83%A8%E8%B0%83%E7%94%A8"><span class="post-toc-number">3.6.3.1.</span> <span class="post-toc-text">内部调用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%A4%96%E9%83%A8%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8"><span class="post-toc-number">3.6.3.2.</span> <span class="post-toc-text">外部函数调用</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%91%BD%E5%90%8D%E8%B0%83%E7%94%A8%E5%92%8C%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0"><span class="post-toc-number">3.6.3.3.</span> <span class="post-toc-text">命名调用和匿名函数参数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E7%9C%81%E7%95%A5%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E5%90%8D"><span class="post-toc-number">3.6.3.4.</span> <span class="post-toc-text">省略函数参数名</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%94%A8new%E5%88%9B%E5%BB%BA%E6%96%B0%E5%90%88%E7%BA%A6"><span class="post-toc-number">3.6.4.</span> <span class="post-toc-text">用new创建新合约</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E7%9A%84%E9%A1%BA%E5%BA%8F"><span class="post-toc-number">3.6.5.</span> <span class="post-toc-text">表达式求值的顺序</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E8%B5%8B%E5%80%BC"><span class="post-toc-number">3.6.6.</span> <span class="post-toc-text">赋值</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E5%92%8C%E5%A4%9A%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="post-toc-number">3.6.6.1.</span> <span class="post-toc-text">解构赋值和多返回值</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E5%A4%8D%E6%9D%82%E7%82%B9"><span class="post-toc-number">3.6.6.2.</span> <span class="post-toc-text">数组和结构体的复杂点</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E5%A3%B0%E6%98%8E"><span class="post-toc-number">3.6.7.</span> <span class="post-toc-text">作用域和声明</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%BB%8E-0-5-0-%E5%BC%80%E5%A7%8B%E5%B0%B1%E6%9C%89%E4%BD%9C%E7%94%A8%E5%9F%9F%E4%BA%86"><span class="post-toc-number">3.6.7.1.</span> <span class="post-toc-text">从 0.5.0 开始就有作用域了</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%9A%E6%96%AD%E8%A8%80%E3%80%81%E9%9C%80%E6%B1%82%E3%80%81%E5%8F%8D%E8%BD%AC%E5%92%8C%E5%BC%82%E5%B8%B8"><span class="post-toc-number">3.6.8.</span> <span class="post-toc-text">错误处理：断言、需求、反转和异常</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%90%88%E7%BA%A6"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">合约</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%88%9B%E5%BB%BA%E5%90%88%E7%BA%A6"><span class="post-toc-number">3.7.1.</span> <span class="post-toc-text">创建合约</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7%E5%92%8C-Getter"><span class="post-toc-number">3.7.2.</span> <span class="post-toc-text">可见性和 Getter</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Getter"><span class="post-toc-number">3.7.2.1.</span> <span class="post-toc-text">Getter</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0%E4%BF%AE%E9%A5%B0%E7%AC%A6-1"><span class="post-toc-number">3.7.3.</span> <span class="post-toc-text">函数修饰符</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%8A%B6%E6%80%81%E5%B8%B8%E9%87%8F"><span class="post-toc-number">3.7.4.</span> <span class="post-toc-text">状态常量</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0-1"><span class="post-toc-number">3.7.5.</span> <span class="post-toc-text">函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#view"><span class="post-toc-number">3.7.5.1.</span> <span class="post-toc-text">view</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#pure-%E5%87%BD%E6%95%B0"><span class="post-toc-number">3.7.5.2.</span> <span class="post-toc-text">pure 函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E9%99%8D%E7%BA%A7%E5%87%BD%E6%95%B0"><span class="post-toc-number">3.7.5.3.</span> <span class="post-toc-text">降级函数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%87%BD%E6%95%B0%E9%87%8D%E8%BD%BD"><span class="post-toc-number">3.7.5.4.</span> <span class="post-toc-text">函数重载</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E4%BA%8B%E4%BB%B6-1"><span class="post-toc-number">3.7.6.</span> <span class="post-toc-text">事件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E4%BD%8E%E7%BA%A7%E6%97%A5%E5%BF%97%E8%AE%BE%E6%96%BD"><span class="post-toc-number">3.7.6.1.</span> <span class="post-toc-text">低级日志设施</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%85%B6%E4%BB%96%E7%90%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%B5%84%E6%BA%90"><span class="post-toc-number">3.7.6.2.</span> <span class="post-toc-text">其他理解事件的资源</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="post-toc-number">3.7.7.</span> <span class="post-toc-text">继承</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="post-toc-number">3.7.7.1.</span> <span class="post-toc-text">构造器</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%9F%BA%E7%B1%BB%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0"><span class="post-toc-number">3.7.7.2.</span> <span class="post-toc-text">基类构造器参数</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF%E4%B8%8E%E7%BA%BF%E6%80%A7%E5%8C%96"><span class="post-toc-number">3.7.7.3.</span> <span class="post-toc-text">多重继承与线性化</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%90%88%E7%BA%A6"><span class="post-toc-number">3.7.7.4.</span> <span class="post-toc-text">抽象合约</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="post-toc-number">3.7.8.</span> <span class="post-toc-text">接口</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%BA%93"><span class="post-toc-number">3.7.9.</span> <span class="post-toc-text">库</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Using-For"><span class="post-toc-number">3.7.10.</span> <span class="post-toc-text">Using For</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Solidity-%E6%B1%87%E7%BC%96"><span class="post-toc-number">3.8.</span> <span class="post-toc-text">Solidity 汇编</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="post-toc-number">3.9.</span> <span class="post-toc-text">杂项</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E6%9C%89%E7%94%A8%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="post-toc-number">3.9.1.</span> <span class="post-toc-text">有用的小技巧</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="post-toc-number">4.</span> <span class="post-toc-text">安全问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">可重入</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E8%BD%AC%E4%BB%A5%E5%A4%AA%E5%B8%81%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">转以太币相关问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#tx-origin"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">tx.origin</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E9%80%9A%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="post-toc-number">5.</span> <span class="post-toc-text">通用模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E4%BB%8E%E5%90%88%E7%BA%A6%E4%B8%AD%E5%8F%96%E9%92%B1"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">从合约中取钱</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%94%A8-modifier-%E6%9D%A5%E8%AE%BE%E5%AE%9A%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E7%9A%84%E9%97%AE%E9%A2%98"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">用 modifier 来设定可访问性的问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">状态机</span></a></li></ol></li></ol></div>
                        
                    
                    <article id="post-content">
                        <p>以下内容还是从 Solidity 文档里摘出来的。</p>
<h2 id="智能合约入门-介绍"><a href="#智能合约入门-介绍" class="headerlink" title="智能合约入门/介绍"></a>智能合约入门/介绍</h2><h3 id="第一个基本的例子"><a href="#第一个基本的例子" class="headerlink" title="第一个基本的例子"></a>第一个基本的例子</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    function set(uint x) public &#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public constant returns (uint) &#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个 contract 可以被认为是一个类型。<br>默认的 unint 就是256位的。<br>storedData 可以被认为是 state variable，状态变量。在 Solidity 的概念里面，这个东西可以被认为是数据库里面的一个槽，可以被函数查询和修改。注意看它不是 public 的，所以没有合成方法。</p>
<p>访问状态变量不需要用 this前缀（在什么 scope 下都不需要吗？）。</p>
<p>这个例子没有限制任何其他人调用修改状态变量的方法。</p>
<h3 id="子货币的例子"><a href="#子货币的例子" class="headerlink" title="子货币的例子"></a>子货币的例子</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.0</span>;</span><br><span class="line"></span><br><span class="line">contract Coin &#123;</span><br><span class="line">    <span class="comment">// The keyword &quot;public&quot; makes those variables</span></span><br><span class="line">    <span class="comment">// readable from outside.</span></span><br><span class="line">    address public minter;</span><br><span class="line">    mapping (<span class="function"><span class="params">address</span> =&gt;</span> uint) public balances;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Events allow light clients to react on</span></span><br><span class="line">    <span class="comment">// changes efficiently.</span></span><br><span class="line">    event Sent(address <span class="keyword">from</span>, address to, uint amount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is the constructor whose code is</span></span><br><span class="line">    <span class="comment">// run only when the contract is created.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Coin</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        minter = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">mint</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msg.sender != minter) <span class="keyword">return</span>;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">send</span>(<span class="params">address receiver, uint amount</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (balances[msg.sender] &lt; amount) <span class="keyword">return</span>;</span><br><span class="line">        balances[msg.sender] -= amount;</span><br><span class="line">        balances[receiver] += amount;</span><br><span class="line">        Sent(msg.sender, receiver, amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>address 是160位的类型（问：为什么不是2的整数次幂？如何）。可以用来存储合约地址或者属于外部人的钥匙对（所谓的 msg.sender？）。public 关键字会让编译器自动帮忙生成一个访问器函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minter</span>(<span class="params"></span>) <span class="title">returns</span> (<span class="params">address</span>) </span>&#123; <span class="keyword">return</span> minter; &#125;</span><br></pre></td></tr></table></figure>
<p>而<code>mapping (address =&gt; uint) public balances</code>创造了一个公共状态变量，用 hash 表的形式来把地址映射到整数，其实就是把户头映射到金钱余额。这一个公共变量被<strong>虚拟地初始化</strong>了，所以所有合法的key<strong>都存在</strong>，而它们映射value都是零值（对整数而言，当然应该是0）。因为这个无限大的 map 的存在，所以不可能遍历所有的 key，也不能遍历所有的 value，只能依赖于外部数组来记住有意义的 key。而编译器帮忙生成的函数，则看起来是这个样子的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">balances</span>(<span class="params">address _account</span>) <span class="title">public</span> <span class="title">view</span> <span class="title">returns</span> (<span class="params">uint</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> balances[_account];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也就是说，调用的时候，用类 balances(0x1234567)的方式来获取账户余额？</p>
<p>Event 的定义和我们习惯的就很相似了。但原文中举了一个观察的例子，不知道是在 Web3 api 里面使用，还是在智能合约里面使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Coin.Sent().watch(&#123;&#125;, <span class="string">&#x27;&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">error, result</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Coin transfer: &quot;</span> + result.args.amount +</span><br><span class="line">            <span class="string">&quot; coins were sent from &quot;</span> + result.args.from +</span><br><span class="line">            <span class="string">&quot; to &quot;</span> + result.args.to + <span class="string">&quot;.&quot;</span>);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;Balances now:\n&quot;</span> +</span><br><span class="line">            <span class="string">&quot;Sender: &quot;</span> + Coin.balances.call(result.args.from) +</span><br><span class="line">            <span class="string">&quot;Receiver: &quot;</span> + Coin.balances.call(result.args.to));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>当然这个例子也提供了对 balances 函数的调用示例。</p>
<p>Coin 函数就是在创建合约的时候只执行一次不能再被执行的。这个构造器其实显式地把创建合约的 msg（而不只是 sender）以及 tx 和 block 这样的默认变量都保存下来了。对于所有函数而言，msg.sender 永远指向当前这个函数的调用地址。</p>
<p>mint 因为设置了卫语句，所以在不是创建者的调用面前会提前返回。而 send 则可以被任何人调用。</p>
<p>这些转账事件当然不可能被链自带的货币系统反映出来。但因为这个合约自己带了事件，所以可以开发针对它的区块链浏览器。</p>
<h3 id="区块链基础"><a href="#区块链基础" class="headerlink" title="区块链基础"></a>区块链基础</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>区块链是全局共享的事务型数据库，以太坊甚至可以被认为是一个序列化隔离级别的数据库。所有加入网络的人都可以从这个数据库里读取条目。如果你想改变数据库里的什么👻东西，你创造的交易必须被所有人接受。事务，也就意味着操作是原子化的，事务里的所有操作要么都被完成，要么都没执行。此外，没有人能够篡改已经被应用数据库里的事务。</p>
<p>只有签过名的事务，才能做相应的修改–用密码学和权限隔离来保证安全性。</p>
<h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><p>一个需要克服的主要障碍是，按照比特币的说法，是所谓的“双花攻击”。也就是如果网络中存在相互矛盾的两笔事务怎么办？</p>
<p>抽象的回答是，你不用担心这个。一个事务的排序总会为你挑选出来，（被选中的）事务会被打包进一个所谓的“区块”里，然后他们会被执行和分发到所有参与节点里面。如果两个合约相互矛盾，那么被排在第二位的合约会被拒绝而不成为区块的一部分。</p>
<p>这些区块行程一个线性序列，区块链这个词就源于此。</p>
<p>作为“顺序挑选机制”（即所谓的“挖矿”）的一部分，区块可能会被回滚，但这种情况只会发生在链的末梢。越多的区块被加到顶部，原来的区块就越不容易被回滚。</p>
<h3 id="以太坊虚拟机"><a href="#以太坊虚拟机" class="headerlink" title="以太坊虚拟机"></a>以太坊虚拟机</h3><h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><p>以太坊虚拟机（EVM）是智能合约的运行时。它不只是一个沙盒，而且被完全隔离了，也就是说EVM 不能访问网络、文件系统和其他进程（Fabric 的智能合约理论上没有这个限制）。智能合约甚至受限访问其他智能合约。</p>
<h4 id="账户"><a href="#账户" class="headerlink" title="账户"></a>账户</h4><p>以太坊中有两类账户共享同样的地址空间：由公私钥对（即人类）控制的外部账户以及与合约一同存储的代码控制的合约账户。</p>
<p>外部账户的地址是又公钥控制的，而合约的地址则是在合约创建时决定的（由创建者的地址和从哪个地址里发出的事务数（即 nonce）衍生。）。</p>
<p>不考虑账户是不是存储有代码，两种类型被 EVM 平等对待。</p>
<p>每一个账户有持久化的的键值存储叫 storage，映射256位的字到256位的字。</p>
<p>除此之外，每个账户都有一个以太币（以 wei 为单位）余额，可以通过发送含有以太币的事务进行修改。</p>
<h4 id="事务-1"><a href="#事务-1" class="headerlink" title="事务"></a>事务</h4><p>事务是从一个账户发送往另一个账户（另一个账户可以是同一个账户或者特殊的零账户）的消息。它可以包含二进制数据（它的载荷）和以太币。</p>
<p>如果目标账户包含代码，那么代码可以被执行，而载荷则可以被当做输入数据（按，等同于 message call）。</p>
<p>如果目标账户是一个零账户（账户地址是0），事务会产生一个新合约（这也是编程式产生新合约的方法）。创造合约的时候，我们在事务里发送的载荷实际上并不是合约本身，而是能够产生合约的代码。</p>
<p>注意，这个零账户指的是一个 transaction 里面的 to 的零值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">transaction = &#123;</span><br><span class="line">  nonce: &#x27;0x0&#x27;, </span><br><span class="line">  gasLimit: &#x27;0x6acfc0&#x27;, // 7000000</span><br><span class="line">  gasPrice: &#x27;0x4a817c800&#x27;, // 20000000000</span><br><span class="line">  to: &#x27;0x0&#x27;,</span><br><span class="line">  value: &#x27;0x0&#x27;,</span><br><span class="line">  data: &#x27;0xfffff&#x27;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>具体思辨内容见<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/48219716/what-is-address0-in-solidity">此</a>。</p>
<h4 id="Gas"><a href="#Gas" class="headerlink" title="Gas"></a>Gas</h4><p>一创建完成，每个事务总要收取一定量的 gas，用意是为了限制执行事务所需的工作量，并为执行事务付费。当 EVM 执行事务的时候，gas 根据特定规则被逐渐消耗。</p>
<p>gas 加个是由事务创建者设立的，发出（事务的）账户必须付出<code>gas_price * gas</code>的预付款。如果执行之后还有 gas 剩余，它会被原路退回。</p>
<p>如果 gas 在任何时刻被用尽，一个 out-of-gas 异常会被触发，因此会反转当前调用帧对状态的所有修改。</p>
<h4 id="Storage，-Memory-和-Stack"><a href="#Storage，-Memory-和-Stack" class="headerlink" title="Storage， Memory 和 Stack"></a>Storage， Memory 和 Stack</h4><p>每个账户都有一个<strong>持久化的内存区域</strong>，被称作<code>storage</code>。Storage 是一个键值存储，它把256位的字映射到256位的字。不可能在一个合约内部枚举 storage，而读storage也是相对昂贵的， 修改 storage 更是昂贵。一个合约不能读和写它自己的 storage 中自己拥有的部分之外的东西。</p>
<p>第二个内存区域叫做<code>memory</code>，它让合约为每一个消息调用获得了一个全新清理过的实例。memory 是线性的，可以在字节级别被寻址，但读被限制到256位宽，写得可以写8位到256位宽。memory 被字（256位）展开，当访问（不管是读或者写）一个之前没有接触过的内存字（即，一个字内的任何偏移）。在展开的时候，gas 的花费也必须要之丰富。memory 增长的越大，越昂贵（因为它是平方级扩容的）。</p>
<p>EVM 不是个寄存器机器而是个栈机器，所以所有的计算都在一个叫 stack 的区域上执行。栈有一个1024个元素的最大尺寸，并且包含256位的字。只允许通过这种方式从栈顶访问元素：可以拷贝最顶上的16个元素中的一个或者把最顶上的十六个元素中的一个与其下的元素翻转。按：这也就是 stack 里的局部变量表只允许有16个变量的原因。看起来所有的 EVM 语言，包括但不限于 Solidity，都受这个限制影响。其他操作则只能从栈上取最顶上的两个（或一或更多，取决于具体操作）元素并将结果推上栈。当然可能把栈上的元素移动到 storage 和 memory，但不可能在不移除栈顶元素的前提下，访问栈上更深的任意元素。</p>
<h4 id="指令集"><a href="#指令集" class="headerlink" title="指令集"></a>指令集</h4><p>EVM 的指令集被保持极小规模，以防错误的实现引发共识问题。所有的指令都操作在基本数据类型，256位的字上。常见的算数、位、逻辑和比较操作符是现成的。条件和非条件跳转是可行的。除此之外，合约能够访问当前区块的相关属性比如数字和时间戳。</p>
<h4 id="消息调用"><a href="#消息调用" class="headerlink" title="消息调用"></a>消息调用</h4><p>合约可以调用其他合约，或者通过消息调用的方式发送以太币到非合约账户。消息调用类似事务，所以它有源、目标、数据载荷、以太币、gas 和返回值。事实上，所有的事务都包含一个<strong>顶级消息调用</strong>（按：可以理解为元消息调用），它可以创造更多的消息调用。</p>
<p>一个合约决定有多少它的剩余 gas 需要被伴随内部消息调用发送，有多少它想要保留。如果一个 out-of-gas 异常在内部调用发生了（或者任何其他异常），这件事会以一个被放在栈上的错误值作为信号。在这种情况下，只有伴随着这个调用的 gas 被用尽了（按：其它的 gas 没有被用尽）。在 Solidity 中，在这种情况下，调用方合约引发一个手动异常（按：下面传上来的是错误码，在这里才 raise 异常），所以异常状况就在调用栈上被冒泡上去了。</p>
<p>正如已经提到的，被调用的合约（它可以是调用者本身）会收到一个全新的被清理过的内存实例，并且可以访问调用载荷-它会在一个单独的被称作<code>alldata</code> 的区域里被提供。当它执行完成以后，它可以返回数据，数据会被存贮在调用者的预分配内存里的某一个部分。按：类似传统调用栈的返回值寄存器。调用被限制在一个1024的深度上，这意味着对更复杂的操作，循环应该优于递归。</p>
<h4 id="Delegatecall（委托调用）-Callcode（调用代码）-和-Libraries-库"><a href="#Delegatecall（委托调用）-Callcode（调用代码）-和-Libraries-库" class="headerlink" title="Delegatecall（委托调用）/Callcode（调用代码） 和 Libraries(库)"></a>Delegatecall（委托调用）/Callcode（调用代码） 和 Libraries(库)</h4><p>存在消息调用的一个特殊变种，名为 delegatecall，它和一个消息调用完全一样，除了目标地址的代码是在调用方合约的上下文里执行（按：意即，不是在被调用合约上下文里执行），并且 msg.sender 和 msg.value 没有改变它们的值（按：和调用方合约里的值一样）。</p>
<p>这意味着一个合约可以在运行时动态地从其他地址提取代码。存储、当前地址和余额，依旧指向调用方合约，只有代码是从被调用方合约里拿来的。这意味着在 Solidity 中实现库这一特征是可能的：可复用的库代码可以应用到一个合约的存储里，意即，可以（通过复用库）实现复杂的数据结构。</p>
<h4 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h4><p>可以在专门索引过的数据结构里存储数据，这把所有的方法都映射到了区块级别（按：即在区块级别来思考怎么解决相关问题）。被称作log（日志）的特征被 Solidity 用来实现 events（事件）。合约不能在日志被创建后访问它们（即 log 被创建后就不能在内部从任何一个地方被读取了）。但它们可以从链外被读取。由于有一部分 log 数据被存储在布隆过滤器里，所以可以通过有效率和加密安全的方法来搜索其中数据，所以网络对等节点（轻客户端）不需要下载完整的区块就可以发行这些日志。</p>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p>合约甚至可以使用特殊的opcode（操作码）创建其他合约（它们并不只是简单地调用零合约地址，这已经是第二种已知的创建合约的方法了）。<strong>创建调用</strong>和普通消息调用的唯一差别是载荷数据被执行了，而结果被当做代码存储。调用者/创建者在栈上接收到新合约的地址。</p>
<h4 id="自毁"><a href="#自毁" class="headerlink" title="自毁"></a>自毁</h4><p>代码被从区块链上移出的唯一可能性是当一个合约执行<code>selfdestruct</code>操作的时候。地址中存储的剩余以太币会被发送给一个设定好的目标（账户），接着状态（数据库的存储）中的存储和状态将被移除。</p>
<p><strong>即使一个合约的代码中不包含一个到<code>selfdestruct</code>的调用，它仍然可以通过<code>delegatecall</code>和<code>callcode</code>来执行那个操作。</strong></p>
<p><strong>对于老以太坊节点而言，这个珊瑚并不一定是物理删除，也可以是软删除</strong></p>
<p><strong>当前外部账户（即个人的 account）是不能从 state 中移除掉的。按：即合约账户可以被移除</strong></p>
<h2 id="Solidity举例"><a href="#Solidity举例" class="headerlink" title="Solidity举例"></a>Solidity举例</h2><h3 id="选举"><a href="#选举" class="headerlink" title="选举"></a>选举</h3><p>接下来的合约就非常复杂了，它显示了 Solidity 的一大堆优点。它实现了一个投票合约。当然，电子投票的主要问题是如何分配投票权给正确的人群和如何阻止操纵选举。我们不会在这里解决所有的问题，但最起码我们会显式被代理的选举如何完成，并且计票是自动和同时完全透明的。</p>
<p>奥妙就是每一个ballot（投票）一个合约，为每个选项提供一个短名字。然后合约的创建者作为主席会把投票权单独授予每个地址。</p>
<p>地址后面的人可以选择要么自己投票，要么把他们的投票权delegate（委托）一个他们信任的人。</p>
<p>在选举结束的时候，<code>winningProposal()</code>会返回最大投票数的建议。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// @title Voting with delegation.</span></span><br><span class="line">contract Ballot &#123;</span><br><span class="line">    <span class="comment">// This declares a new complex type which will</span></span><br><span class="line">    <span class="comment">// be used for variables later.</span></span><br><span class="line">    <span class="comment">// It will represent a single voter.</span></span><br><span class="line">    struct Voter &#123;</span><br><span class="line">        uint weight; <span class="comment">// weight is accumulated by delegation</span></span><br><span class="line">        bool voted;  <span class="comment">// if true, that person already voted</span></span><br><span class="line">        address delegate; <span class="comment">// person delegated to</span></span><br><span class="line">        uint vote;   <span class="comment">// index of the voted proposal</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This is a type for a single proposal.</span></span><br><span class="line">    struct Proposal &#123;</span><br><span class="line">        bytes32 name;   <span class="comment">// short name (up to 32 bytes)</span></span><br><span class="line">        uint voteCount; <span class="comment">// number of accumulated votes</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address public chairperson;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This declares a state variable that</span></span><br><span class="line">    <span class="comment">// stores a `Voter` struct for each possible address.</span></span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> Voter) public voters;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A dynamically-sized array of `Proposal` structs.</span></span><br><span class="line">    Proposal[] public proposals;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Create a new ballot to choose one of `proposalNames`.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Ballot</span>(<span class="params">bytes32[] proposalNames</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        chairperson = msg.sender;</span><br><span class="line">        <span class="comment">// 主席有投票权</span></span><br><span class="line">        voters[chairperson].weight = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// For each of the provided proposal names,</span></span><br><span class="line">        <span class="comment">// create a new proposal object and add it</span></span><br><span class="line">        <span class="comment">// to the end of the array.</span></span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; proposalNames.length; i++) &#123;</span><br><span class="line">            <span class="comment">// `Proposal(&#123;...&#125;)` creates a temporary</span></span><br><span class="line">            <span class="comment">// Proposal object and `proposals.push(...)`</span></span><br><span class="line">            <span class="comment">// appends it to the end of `proposals`.</span></span><br><span class="line">            proposals.push(Proposal(&#123;</span><br><span class="line">                <span class="attr">name</span>: proposalNames[i],</span><br><span class="line">                <span class="attr">voteCount</span>: <span class="number">0</span></span><br><span class="line">            &#125;));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Give `voter` the right to vote on this ballot.</span></span><br><span class="line">    <span class="comment">// May only be called by `chairperson`.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">giveRightToVote</span>(<span class="params">address voter</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If the argument of `require` evaluates to `false`,</span></span><br><span class="line">        <span class="comment">// it terminates and reverts all changes to</span></span><br><span class="line">        <span class="comment">// the state and to Ether balances. It is often</span></span><br><span class="line">        <span class="comment">// a good idea to use this if functions are</span></span><br><span class="line">        <span class="comment">// called incorrectly. But watch out, this</span></span><br><span class="line">        <span class="comment">// will currently also consume all provided gas</span></span><br><span class="line">        <span class="comment">// (this is planned to change in the future).</span></span><br><span class="line">        <span class="comment">// require 类似断言，会反转所有的区块链 state，但还是会消耗 gas（这点未来会被修改），这比 return 好吗？</span></span><br><span class="line">        <span class="built_in">require</span>((msg.sender == chairperson) &amp;&amp; !voters[voter].voted &amp;&amp; (voters[voter].weight == <span class="number">0</span>));</span><br><span class="line">        <span class="comment">// 某个投票者地址获得了投票权</span></span><br><span class="line">        voters[voter].weight = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Delegate your vote to the voter `to`.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">delegate</span>(<span class="params">address to</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assigns reference</span></span><br><span class="line">        <span class="comment">// 第一个出现的显式 storage，这证明读成员变量赋给局部变量总是要求 storage 的</span></span><br><span class="line">        Voter storage sender = voters[msg.sender];</span><br><span class="line">        <span class="built_in">require</span>(!sender.voted);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Self-delegation is not allowed.</span></span><br><span class="line">        <span class="built_in">require</span>(to != msg.sender);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Forward the delegation as long as</span></span><br><span class="line">        <span class="comment">// `to` also delegated.</span></span><br><span class="line">        <span class="comment">// In general, such loops are very dangerous,</span></span><br><span class="line">        <span class="comment">// because if they run too long, they might</span></span><br><span class="line">        <span class="comment">// need more gas than is available in a block.</span></span><br><span class="line">        <span class="comment">// In this case, the delegation will not be executed,</span></span><br><span class="line">        <span class="comment">// but in other situations, such loops might</span></span><br><span class="line">        <span class="comment">// cause a contract to get &quot;stuck&quot; completely.</span></span><br><span class="line">        <span class="comment">// 这里使用了一个可以比较零地址的例子，证明不可以直接 != 0来比较</span></span><br><span class="line">        <span class="comment">// 在现实中这样的循环可能很耗 gas</span></span><br><span class="line">        <span class="keyword">while</span> (voters[to].delegate != address(<span class="number">0</span>)) &#123;</span><br><span class="line">            to = voters[to].delegate;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// We found a loop in the delegation, not allowed.</span></span><br><span class="line">            <span class="comment">// 内置 required 断言</span></span><br><span class="line">            <span class="built_in">require</span>(to != msg.sender);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Since `sender` is a reference, this</span></span><br><span class="line">        <span class="comment">// modifies `voters[msg.sender].voted`</span></span><br><span class="line">        <span class="comment">// 把被委托者的旧值作废掉</span></span><br><span class="line">        sender.voted = <span class="literal">true</span>;</span><br><span class="line">        sender.delegate = to;</span><br><span class="line">        Voter storage delegate = voters[to];</span><br><span class="line">        <span class="keyword">if</span> (delegate.voted) &#123;</span><br><span class="line">            <span class="comment">// If the delegate already voted,</span></span><br><span class="line">            <span class="comment">// directly add to the number of votes</span></span><br><span class="line">            proposals[delegate.vote].voteCount += sender.weight;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If the delegate did not vote yet,</span></span><br><span class="line">            <span class="comment">// add to her weight.</span></span><br><span class="line">            delegate.weight += sender.weight;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每一个合约都是</span></span><br><span class="line">    <span class="comment">/// Give your vote (including votes delegated to you)</span></span><br><span class="line">    <span class="comment">/// to proposal `proposals[proposal].name`.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">vote</span>(<span class="params">uint proposal</span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        Voter storage sender = voters[msg.sender];</span><br><span class="line">        <span class="built_in">require</span>(!sender.voted);</span><br><span class="line">        sender.voted = <span class="literal">true</span>;</span><br><span class="line">        sender.vote = proposal;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If `proposal` is out of the range of the array,</span></span><br><span class="line">        <span class="comment">// this will throw automatically and revert all</span></span><br><span class="line">        <span class="comment">// changes.</span></span><br><span class="line">        proposals[proposal].voteCount += sender.weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// @dev Computes the winning proposal taking all</span></span><br><span class="line">    <span class="comment">/// previous votes into account.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">winningProposal</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span></span></span><br><span class="line"><span class="function">            <span class="title">returns</span> (<span class="params">uint winningProposal</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// solidity 的 dummy 数值对象就是这样写的了</span></span><br><span class="line">        uint winningVoteCount = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 注意，这个 proposals 是数组，winner 其实只是这个数组的一个索引</span></span><br><span class="line">        <span class="keyword">for</span> (uint p = <span class="number">0</span>; p &lt; proposals.length; p++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (proposals[p].voteCount &gt; winningVoteCount) &#123;</span><br><span class="line">                winningVoteCount = proposals[p].voteCount;</span><br><span class="line">                winningProposal = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calls winningProposal() function to get the index</span></span><br><span class="line">    <span class="comment">// of the winner contained in the proposals array and then</span></span><br><span class="line">    <span class="comment">// returns the name of the winner</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">winnerName</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">view</span></span></span><br><span class="line"><span class="function">            <span class="title">returns</span> (<span class="params">bytes32 winnerName</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        winnerName = proposals[winningProposal()].name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个合约可以提升的地方，就是怎样提升事务的效率？</p>
<h3 id="盲拍卖"><a href="#盲拍卖" class="headerlink" title="盲拍卖"></a>盲拍卖</h3><h4 id="简单拍卖"><a href="#简单拍卖" class="headerlink" title="简单拍卖"></a>简单拍卖</h4><p>接下来出现的简单明拍卖合约的大意是每个人都可以在投标期内把投标投出去。投标已经包含了发送金钱/以太币，以把投标者和投标绑定起来。如果最高投标上升了，前一个最高投标者会拿回她的钱。在投标周期的最后，合约要让受益人手动调用来获得它的钱，合约不能激活它自己。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    <span class="comment">// 卖东西的人</span></span><br><span class="line">    <span class="comment">// Parameters of the auction. Times are either</span></span><br><span class="line">    <span class="comment">// absolute unix timestamps (seconds since 1970-01-01)</span></span><br><span class="line">    <span class="comment">// or time periods in seconds.</span></span><br><span class="line">    address public beneficiary;</span><br><span class="line">    <span class="comment">// 用整数来表示时间</span></span><br><span class="line">    uint public auctionEnd;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前最高投标者的地址</span></span><br><span class="line">    <span class="comment">// Current state of the auction.</span></span><br><span class="line">    address public highestBidder;</span><br><span class="line">    <span class="comment">// 最高的投标</span></span><br><span class="line">    uint public highestBid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 受许可的之前投标的退款，在这里 withdrawal 等于 refund 了</span></span><br><span class="line">    <span class="comment">// Allowed withdrawals of previous bids</span></span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) pendingReturns;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set to true at the end, disallows any change</span></span><br><span class="line">    bool ended;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Events that will be fired on changes.</span></span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount);</span><br><span class="line">    event AuctionEnded(address winner, uint amount);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 三斜杠的是提示符评论，可以提示用户是否确认一个事务</span></span><br><span class="line">    <span class="comment">// The following is a so-called natspec comment,</span></span><br><span class="line">    <span class="comment">// recognizable by the three slashes.</span></span><br><span class="line">    <span class="comment">// It will be shown when the user is asked to</span></span><br><span class="line">    <span class="comment">// confirm a transaction.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Create a simple auction with `_biddingTime`</span></span><br><span class="line">    <span class="comment">/// seconds bidding time on behalf of the</span></span><br><span class="line">    <span class="comment">/// beneficiary address `_beneficiary`.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">SimpleAuction</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        uint _biddingTime,</span></span></span><br><span class="line"><span class="params"><span class="function">        address _beneficiary</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        beneficiary = _beneficiary;</span><br><span class="line">        <span class="comment">// 看来 now 也是秒数的意思。换言之，没有毫秒数。</span></span><br><span class="line">        auctionEnd = now + _biddingTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Bid on the auction with the value sent</span></span><br><span class="line">    <span class="comment">/// together with this transaction.</span></span><br><span class="line">    <span class="comment">/// The value will only be refunded if the</span></span><br><span class="line">    <span class="comment">/// auction is not won.</span></span><br><span class="line">    <span class="comment">// payable 就是拿来修饰 function 的，所以它是 payble 的。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bid</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        <span class="comment">// No arguments are necessary, all</span></span><br><span class="line">        <span class="comment">// information is already part of</span></span><br><span class="line">        <span class="comment">// the transaction. The keyword payable</span></span><br><span class="line">        <span class="comment">// is required for the function to</span></span><br><span class="line">        <span class="comment">// be able to receive Ether.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// Revert the call if the bidding</span></span><br><span class="line">        <span class="comment">// period is over.</span></span><br><span class="line">        <span class="built_in">require</span>(now &lt;= auctionEnd);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the bid is not higher, send the</span></span><br><span class="line">        <span class="comment">// money back.</span></span><br><span class="line">        <span class="comment">// 这个 payable 的合约也可以被断言所中断</span></span><br><span class="line">        <span class="built_in">require</span>(msg.value &gt; highestBid);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 最高投标者的地址的另一种比对方法</span></span><br><span class="line">        <span class="keyword">if</span> (highestBidder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Sending back the money by simply using</span></span><br><span class="line">            <span class="comment">// highestBidder.send(highestBid) is a security risk</span></span><br><span class="line">            <span class="comment">// because it could execute an untrusted contract.</span></span><br><span class="line">            <span class="comment">// It is always safer to let the recipients</span></span><br><span class="line">            <span class="comment">// withdraw their money themselves.</span></span><br><span class="line">            pendingReturns[highestBidder] += highestBid;</span><br><span class="line">        &#125;</span><br><span class="line">        highestBidder = msg.sender;</span><br><span class="line">        highestBid = msg.value;</span><br><span class="line">        HighestBidIncreased(msg.sender, msg.value);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这个方法没有任何直接摸合约 account 的地方，但这个payable 方法的内容里处处充满了 msg.value</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Withdraw a bid that was overbid.</span></span><br><span class="line">    <span class="comment">//  这个退款函数是谁来调用 ?</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">returns</span> (<span class="params">bool</span>) </span>&#123;</span><br><span class="line">        uint amount = pendingReturns[msg.sender];</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// It is important to set this to zero because the recipient</span></span><br><span class="line">            <span class="comment">// can call this function again as part of the receiving call</span></span><br><span class="line">            <span class="comment">// before `send` returns.</span></span><br><span class="line">            pendingReturns[msg.sender] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!msg.sender.send(amount)) &#123;</span><br><span class="line">                <span class="comment">// No need to call throw here, just reset the amount owing</span></span><br><span class="line">                pendingReturns[msg.sender] = amount;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// End the auction and send the highest bid</span></span><br><span class="line">    <span class="comment">/// to the beneficiary.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">auctionEnd</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        <span class="comment">// It is a good guideline to structure functions that interact</span></span><br><span class="line">        <span class="comment">// with other contracts (i.e. they call functions or send Ether)</span></span><br><span class="line">        <span class="comment">// into three phases:</span></span><br><span class="line">        <span class="comment">// 1. checking conditions</span></span><br><span class="line">        <span class="comment">// 2. performing actions (potentially changing conditions)</span></span><br><span class="line">        <span class="comment">// 3. interacting with other contracts</span></span><br><span class="line">        <span class="comment">// If these phases are mixed up, the other contract could call</span></span><br><span class="line">        <span class="comment">// back into the current contract and modify the state or cause</span></span><br><span class="line">        <span class="comment">// effects (ether payout) to be performed multiple times.</span></span><br><span class="line">        <span class="comment">// If functions called internally include interaction with external</span></span><br><span class="line">        <span class="comment">// contracts, they also have to be considered interaction with</span></span><br><span class="line">        <span class="comment">// external contracts.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. Conditions</span></span><br><span class="line">        <span class="built_in">require</span>(now &gt;= auctionEnd); <span class="comment">// auction did not yet end</span></span><br><span class="line">        <span class="built_in">require</span>(!ended); <span class="comment">// this function has already been called</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. Effects</span></span><br><span class="line">        ended = <span class="literal">true</span>;</span><br><span class="line">        AuctionEnded(highestBidder, highestBid);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. Interaction</span></span><br><span class="line">        beneficiary.transfer(highestBid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="盲拍卖-1"><a href="#盲拍卖-1" class="headerlink" title="盲拍卖"></a>盲拍卖</h4><p>盲拍卖的优点是没有向着拍卖终点的时间压力。</p>
<p>简化一个盲拍卖模型。用户先用头标志的 hash 投标。投标结束后大家揭示出自己的投标值，同时校验 hash 是否相同以及数值是否最高。</p>
<p>为了防止有些人拍完不给钱，这个合约还进一步要求大家把价值和投标一起发送，前者自然是明文的，而后者是加密的。为了不暴露隐私，合约接受一切附带的价值高于当前最高投标价的新投标转账。这也就意味着，在价值揭示环节，有些投标是无效的不成立的。投标者甚至可以用一些错误的高投标或者低投标来迷惑整个竞争。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line"></span><br><span class="line">contract BlindAuction &#123;</span><br><span class="line">    struct Bid &#123;</span><br><span class="line">        bytes32 blindedBid;</span><br><span class="line">        <span class="comment">// 锁死存款</span></span><br><span class="line">        uint deposit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    address public beneficiary;</span><br><span class="line">    uint public biddingEnd;</span><br><span class="line">    uint public revealEnd;</span><br><span class="line">    bool public ended;</span><br><span class="line"></span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> Bid[]) public bids;</span><br><span class="line"></span><br><span class="line">    address public highestBidder;</span><br><span class="line">    uint public highestBid;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allowed withdrawals of previous bids</span></span><br><span class="line">    mapping(<span class="function"><span class="params">address</span> =&gt;</span> uint) pendingReturns;</span><br><span class="line"></span><br><span class="line">    event AuctionEnded(address winner, uint highestBid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Modifiers are a convenient way to validate inputs to</span></span><br><span class="line">    <span class="comment">/// functions. `onlyBefore` is applied to `bid` below:</span></span><br><span class="line">    <span class="comment">/// The new function body is the modifier&#x27;s body where</span></span><br><span class="line">    <span class="comment">/// `_` is replaced by the old function body.</span></span><br><span class="line">    <span class="comment">// modifier 有点像装饰器，结合了 require，_指的就是被修饰方法的 body</span></span><br><span class="line">    modifier <span class="function"><span class="title">onlyBefore</span>(<span class="params">uint _time</span>)</span> &#123; <span class="built_in">require</span>(now &lt; _time); _; &#125;</span><br><span class="line">    modifier <span class="function"><span class="title">onlyAfter</span>(<span class="params">uint _time</span>)</span> &#123; <span class="built_in">require</span>(now &gt; _time); _; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">BlindAuction</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        uint _biddingTime,</span></span></span><br><span class="line"><span class="params"><span class="function">        uint _revealTime,</span></span></span><br><span class="line"><span class="params"><span class="function">        address _beneficiary</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        beneficiary = _beneficiary;</span><br><span class="line">        <span class="comment">// 在这里直接拿起点时间戳来生成接下来的时间节点就行了</span></span><br><span class="line">        biddingEnd = now + _biddingTime;</span><br><span class="line">        revealEnd = biddingEnd + _revealTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// keccak 函数是 SHA-3函数的别名，被以太坊更名过的函数。SHA-256实际上是 SHA-2 的一个子类型，keccak 算法是下一代的 SHA-3算法，是最强的散列算法。http://www.atool.org/hash.php</span></span><br><span class="line">    <span class="comment">// keccak 是个松散参数函数，所有的输入都是散列的种子，会被函数直接拼接起来，类似分段签名相加的思路。</span></span><br><span class="line">    <span class="comment">/// Place a blinded bid with `_blindedBid` = keccak256(value,</span></span><br><span class="line">    <span class="comment">/// fake, secret).</span></span><br><span class="line">    <span class="comment">/// The sent ether is only refunded if the bid is correctly</span></span><br><span class="line">    <span class="comment">/// revealed in the revealing phase. The bid is valid if the</span></span><br><span class="line">    <span class="comment">/// ether sent together with the bid is at least &quot;value&quot; and</span></span><br><span class="line">    <span class="comment">/// &quot;fake&quot; is not true. Setting &quot;fake&quot; to true and sending</span></span><br><span class="line">    <span class="comment">/// not the exact amount are ways to hide the real bid but</span></span><br><span class="line">    <span class="comment">/// still make the required deposit. The same address can</span></span><br><span class="line">    <span class="comment">/// place multiple bids.</span></span><br><span class="line">    <span class="comment">// 一个地址可以做多个投标。只有被正确亮出的投标值才会被返还（其他的投标值就不返还了吗？）。只有附带的投标值大于等于value（这是什么意思？）而且 fake 不是 true。设置 fake 为 true 而且发送不准确的数额是隐藏真实投标但满足要求的锁定存款的方法。</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">bid</span>(<span class="params">bytes32 _blindedBid</span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">payable</span></span></span><br><span class="line"><span class="function">        <span class="title">onlyBefore</span>(<span class="params">biddingEnd</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        bids[msg.sender].push(Bid(&#123;</span><br><span class="line">            <span class="attr">blindedBid</span>: _blindedBid,</span><br><span class="line">            <span class="attr">deposit</span>: msg.value</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 亮标。用户可以得到所有被正确掩盖的错标，和除了最高标以外的所有标。</span></span><br><span class="line">    <span class="comment">/// Reveal your blinded bids. You will get a refund for all</span></span><br><span class="line">    <span class="comment">/// correctly blinded invalid bids and for all bids except for</span></span><br><span class="line">    <span class="comment">/// the totally highest.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">reveal</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">        uint[] _values,</span></span></span><br><span class="line"><span class="params"><span class="function">        bool[] _fake,</span></span></span><br><span class="line"><span class="params"><span class="function">        bytes32[] _secret</span></span></span><br><span class="line"><span class="params"><span class="function">    </span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">onlyAfter</span>(<span class="params">biddingEnd</span>)</span></span><br><span class="line"><span class="function">        <span class="title">onlyBefore</span>(<span class="params">revealEnd</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        uint length = bids[msg.sender].length;</span><br><span class="line">        <span class="built_in">require</span>(_values.length == length);</span><br><span class="line">        <span class="built_in">require</span>(_fake.length == length);</span><br><span class="line">        <span class="built_in">require</span>(_secret.length == length);</span><br><span class="line"></span><br><span class="line">        uint refund;</span><br><span class="line">        <span class="keyword">for</span> (uint i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">var</span> bid = bids[msg.sender][i];</span><br><span class="line">            <span class="keyword">var</span> (value, fake, secret) =</span><br><span class="line">                    (_values[i], _fake[i], _secret[i]);</span><br><span class="line">            <span class="keyword">if</span> (bid.blindedBid != keccak256(value, fake, secret)) &#123;</span><br><span class="line">                <span class="comment">// Bid was not actually revealed.</span></span><br><span class="line">                <span class="comment">// Do not refund deposit.</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            refund += bid.deposit;</span><br><span class="line">            <span class="comment">// deposit 是实际存入的锁定价值，value 是用来做散列种子的声称价值</span></span><br><span class="line">            <span class="keyword">if</span> (!fake &amp;&amp; bid.deposit &gt;= value) &#123;</span><br><span class="line">                <span class="keyword">if</span> (placeBid(msg.sender, value))</span><br><span class="line">                    refund -= value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 因为以太坊可以被认为是序列化的事务隔离级别的，所以在这里置零可以抗并发问题</span></span><br><span class="line">            <span class="comment">// Make it impossible for the sender to re-claim</span></span><br><span class="line">            <span class="comment">// the same deposit.</span></span><br><span class="line">            bid.blindedBid = bytes32(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.sender.transfer(refund);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// internal 的第一个用法，internal 函数类似 private，只能在合约内部使用了。</span></span><br><span class="line">    <span class="comment">// This is an &quot;internal&quot; function which means that it</span></span><br><span class="line">    <span class="comment">// can only be called from the contract itself (or from</span></span><br><span class="line">    <span class="comment">// derived contracts).</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">placeBid</span>(<span class="params">address bidder, uint value</span>) <span class="title">internal</span></span></span><br><span class="line"><span class="function">            <span class="title">returns</span> (<span class="params">bool success</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 不中标。所以在这里 place 就是放标的意思？</span></span><br><span class="line">        <span class="keyword">if</span> (value &lt;= highestBid) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (highestBidder != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 先把之前的最高标放进退款名单里面</span></span><br><span class="line">            <span class="comment">// Refund the previously highest bidder.</span></span><br><span class="line">            pendingReturns[highestBidder] += highestBid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 替换最高标</span></span><br><span class="line">        highestBid = value;</span><br><span class="line">        highestBidder = bidder;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Withdraw a bid that was overbid.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">withdraw</span>(<span class="params"></span>) <span class="title">public</span> </span>&#123;</span><br><span class="line">        uint amount = pendingReturns[msg.sender];</span><br><span class="line">        <span class="keyword">if</span> (amount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// It is important to set this to zero because the recipient</span></span><br><span class="line">            <span class="comment">// can call this function again as part of the receiving call</span></span><br><span class="line">            <span class="comment">// before `transfer` returns (see the remark above about</span></span><br><span class="line">            <span class="comment">// conditions -&gt; effects -&gt; interaction).</span></span><br><span class="line">            pendingReturns[msg.sender] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            msg.sender.transfer(amount);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 在拍卖结束的时候把投标款转走。</span></span><br><span class="line">    <span class="comment">/// End the auction and send the highest bid</span></span><br><span class="line">    <span class="comment">/// to the beneficiary.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">auctionEnd</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">onlyAfter</span>(<span class="params">revealEnd</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">require</span>(!ended);</span><br><span class="line">        AuctionEnded(highestBidder, highestBid);</span><br><span class="line">        ended = <span class="literal">true</span>;</span><br><span class="line">        beneficiary.transfer(highestBid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前为止，每个合约只有一个 payable 方法。</p>
<h3 id="安全的远程购买"><a href="#安全的远程购买" class="headerlink" title="安全的远程购买"></a>安全的远程购买</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^<span class="number">0.4</span><span class="number">.11</span>;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    uint public value;</span><br><span class="line">    address public seller;</span><br><span class="line">    address public buyer;</span><br><span class="line">    enum State &#123; Created, Locked, Inactive &#125;</span><br><span class="line">    State public state;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认价值是偶数（为什么？）。由卖方初始化合约。这是第一个构造函数也是 payable 的合约。初始化合约的 value，大致等于一个买卖的押金。</span></span><br><span class="line">    <span class="comment">// Ensure that `msg.value` is an even number.</span></span><br><span class="line">    <span class="comment">// Division will truncate if it is an odd number.</span></span><br><span class="line">    <span class="comment">// Check via multiplication that it wasn&#x27;t an odd number.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Purchase</span>(<span class="params"></span>) <span class="title">public</span> <span class="title">payable</span> </span>&#123;</span><br><span class="line">        seller = msg.sender;</span><br><span class="line">        value = msg.value / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">require</span>((<span class="number">2</span> * value) == msg.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier <span class="function"><span class="title">condition</span>(<span class="params">bool _condition</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(_condition);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier <span class="function"><span class="title">onlyBuyer</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == buyer);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier <span class="function"><span class="title">onlySeller</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(msg.sender == seller);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier <span class="function"><span class="title">inState</span>(<span class="params">State _state</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">require</span>(state == _state);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    event Aborted();</span><br><span class="line">    event PurchaseConfirmed();</span><br><span class="line">    event ItemReceived();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Abort the purchase and reclaim the ether.</span></span><br><span class="line">    <span class="comment">/// Can only be called by the seller before</span></span><br><span class="line">    <span class="comment">/// the contract is locked.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">abort</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">onlySeller</span></span></span><br><span class="line"><span class="function">        <span class="title">inState</span>(<span class="params">State.Created</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Aborted();</span><br><span class="line">        state = State.Inactive;</span><br><span class="line">        <span class="comment">// 这个 balance 就是合约自带的所有 balance 了，而不是我们自定义的 value 一类的成员变量。</span></span><br><span class="line">        seller.transfer(<span class="built_in">this</span>.balance);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// Confirm the purchase as buyer.</span></span><br><span class="line">    <span class="comment">/// Transaction has to include `2 * value` ether.</span></span><br><span class="line">    <span class="comment">/// The ether will be locked until confirmReceived</span></span><br><span class="line">    <span class="comment">/// is called.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">confirmPurchase</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">inState</span>(<span class="params">State.Created</span>)</span></span><br><span class="line"><span class="function">        <span class="title">condition</span>(<span class="params">msg.value == (<span class="number">2</span> * value)</span>)</span></span><br><span class="line"><span class="function">        <span class="title">payable</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="comment">// 发出购买锁定事件</span></span><br><span class="line">        PurchaseConfirmed();</span><br><span class="line">        buyer = msg.sender;</span><br><span class="line">        state = State.Locked;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// Confirm that you (the buyer) received the item.</span></span><br><span class="line">    <span class="comment">/// This will release the locked ether.</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">confirmReceived</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">        <span class="title">public</span></span></span><br><span class="line"><span class="function">        <span class="title">onlyBuyer</span></span></span><br><span class="line"><span class="function">        <span class="title">inState</span>(<span class="params">State.Locked</span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 发出事件</span></span><br><span class="line">        ItemReceived();</span><br><span class="line">        <span class="comment">// It is important to change the state first because</span></span><br><span class="line">        <span class="comment">// otherwise, the contracts called using `send` below</span></span><br><span class="line">        <span class="comment">// can call in again here.</span></span><br><span class="line">        state = State.Inactive;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> This actually allows both the buyer and the seller to</span></span><br><span class="line">        <span class="comment">// block the refund - the withdraw pattern should be used.</span></span><br><span class="line">        <span class="comment">// 把押金转给买家，把差额交给卖家。为什么要这样设计？为了避免空口无凭的卖家浪费合约价值？</span></span><br><span class="line">        buyer.transfer(value);</span><br><span class="line">        seller.transfer(<span class="built_in">this</span>.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这足以证明一个合约有好几个 payable 方法，允许多角色博弈了。<br>这个合约没有任何的 internal 函数。</p>
<h2 id="深入Solidity"><a href="#深入Solidity" class="headerlink" title="深入Solidity"></a>深入Solidity</h2><h3 id="Solidity-源文件的轮廓"><a href="#Solidity-源文件的轮廓" class="headerlink" title="Solidity 源文件的轮廓"></a>Solidity 源文件的轮廓</h3><p>源文件可以包含任意多的合约定义。</p>
<h4 id="版本-pragma"><a href="#版本-pragma" class="headerlink" title="版本 pragma"></a>版本 pragma</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 这个尖角号意味着不能用高于0.5.0的编译器编译。这个数字说明了合约的最小编译器编译器是0.4.0。换言之，要用高级编译器，要 bump up 这个数字。</span><br><span class="line">pragma solidity ^0.4.0;</span><br></pre></td></tr></table></figure>

<h3 id="引入其他源文件"><a href="#引入其他源文件" class="headerlink" title="引入其他源文件"></a>引入其他源文件</h3><h4 id="语法和语义"><a href="#语法和语义" class="headerlink" title="语法和语义"></a>语法和语义</h4><p>Solidity 用类似 JavaScript 的引入语法，但不支持“default export”。在全局层次，你可以用以下形式的引入语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;filename&quot;;</span><br></pre></td></tr></table></figure>
<p>这个语句把该文件名下所有的<strong>全局</strong>符号引入到当前的<strong>全局</strong>作用域中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import * as symbolName from &quot;filename&quot;;</span><br></pre></td></tr></table></figure>
<p>这个语句制造了一个新的全局符号，类似名字空间，所有该文件名下的符号，都是这个新的全局符号的成员。它和<code>import &quot;filename&quot; as symbolName;</code>等价。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &#123;symbol1 as alias, symbol2&#125; from &quot;filename&quot;;</span><br></pre></td></tr></table></figure>
<p>部分引用和别名机制。</p>
<h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>.和..的机制同 Unix 系统。</p>
<p>要引用同一个文件夹下的文件，用这样的语法<code>mport &quot;./x&quot; as x;</code>。如果你使用了<code>import &quot;x&quot; as x;</code>，一个全局的“include directory”里的同名文件夹会被引用。</p>
<h4 id="重映射问题"><a href="#重映射问题" class="headerlink" title="重映射问题"></a>重映射问题</h4><p>太无聊，直接看文档吧。</p>
<h4 id="注释问题"><a href="#注释问题" class="headerlink" title="注释问题"></a>注释问题</h4><p>注意看下面的文档，展示了如何写注释，也展示了如何写多返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">/** @title Shape calculator. */</span><br><span class="line">contract shapeCalculator &#123;</span><br><span class="line">    /** @dev Calculates a rectangle&#x27;s surface and perimeter.</span><br><span class="line">      * @param w Width of the rectangle.</span><br><span class="line">      * @param h Height of the rectangle.</span><br><span class="line">      * @return s The calculated surface.</span><br><span class="line">      * @return p The calculated perimeter.</span><br><span class="line">      */</span><br><span class="line">    function rectangle(uint w, uint h) returns (uint s, uint p) &#123;</span><br><span class="line">        s = w * h;</span><br><span class="line">        p = 2 * (w + h);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合约的结构"><a href="#合约的结构" class="headerlink" title="合约的结构"></a>合约的结构</h3><p>合约和面向对象程序设计语言里面的 class 很相似。每个合约可以包含<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-state-variables">状态变量</a>、<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-functions">函数</a>、<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-function-modifiers">函数修饰符</a>、<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-events">事件</a>、<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-struct-types">结构类型</a>和<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/structure-of-a-contract.html#structure-enum-types">枚举类型</a>的声明。</p>
<h4 id="状态变量"><a href="#状态变量" class="headerlink" title="状态变量"></a>状态变量</h4><p>状态变量会被持久化在合约存储（状态）里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData; // State variable</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p>函数是代码的可执行单元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    function bid() public payable &#123; // Function</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/control-structures.html#function-calls">函数调用</a>可以在内部发生，也可以在外部发生，而且面对不同的其他合约可以拥有不同的<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/contracts.html#visibility-and-getters">可见性</a>。</p>
<h4 id="函数修饰符"><a href="#函数修饰符" class="headerlink" title="函数修饰符"></a>函数修饰符</h4><p>函数修饰符可以以声明的方式修饰函数的语义（见<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/contracts.html#modifiers">Function Modifiers</a>部分）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    address public seller;</span><br><span class="line">    </span><br><span class="line">    // 总是配合 require 函数使用。还可以看看 revert 什么的函数。</span><br><span class="line">    modifier onlySeller() &#123; // Modifier</span><br><span class="line">        require(msg.sender == seller);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function abort() public onlySeller &#123; // Modifier usage</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>事件就是拿来和 EVM 日志设施打交道的方便接口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract SimpleAuction &#123;</span><br><span class="line">    event HighestBidIncreased(address bidder, uint amount); // Event</span><br><span class="line"></span><br><span class="line">    function bid() public payable &#123;</span><br><span class="line">        // ...</span><br><span class="line">        HighestBidIncreased(msg.sender, msg.value); // Triggering event</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Struct-类型"><a href="#Struct-类型" class="headerlink" title="Struct 类型"></a>Struct 类型</h4><p>类似 C 语言，是基本类型的封装组合。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Ballot &#123;</span><br><span class="line">    struct Voter &#123; // Struct</span><br><span class="line">        uint weight;</span><br><span class="line">        bool voted;</span><br><span class="line">        address delegate;</span><br><span class="line">        uint vote;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h4><p>依然类似 Java。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Purchase &#123;</span><br><span class="line">    enum State &#123; Created, Locked, Inactive &#125; // Enum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h3><p>Solidity 是静态类型语言，这意味着不管是状态变量还是局部变量，每个变量的类型必须在运行时被指定好（至少是已知的，见<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/types.html#type-deduction">Type Deduction</a>）。Solidity 提供几个至关重要的类型，可以被组合成复合类型。</p>
<h4 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h4><p>以下的类型总是被称作值类型，因为这些类型的变量总是会被传值。他们作为函数参数或者赋值使用的时候，总是会被拷贝。</p>
<h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><p>bool：可能值为常量 true 或者 false。</p>
<p>逻辑操作符和常见的编程语言操作符类似，也支持<strong>短路操作</strong>。</p>
<h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><p><code>int</code>/<code>uint</code>：各种尺寸的有符号和无符号整型数。关键字<code>uint8</code>和 <code>unint256</code>以8位为步长，以及<code>int8</code>和<code>int256</code>。相对地，<code>unint</code>和<code>int</code>是<code>uint256</code>和<code>int256</code>的别名（按：即默认数据宽度就是最宽）。</p>
<p>除法总是会造成截断，除非两个操作符都是字面量（？）或者字面量表达式。</p>
<p><code>x &lt;&lt; y</code>等于<code>x * 2**y</code>，而<code>x &gt;&gt; y</code>等于<code>x / 2**y</code>。用负数作 y 可能会出运行时异常-这是因为不同编程语言的移位有向0和向负无穷移位的区别。</p>
<h5 id="定点数"><a href="#定点数" class="headerlink" title="定点数"></a>定点数</h5><p>定点数在 Solidity 里还没被完全支持。它们可以被声明，但不能被拿来赋值或者取值。</p>
<p><code>fixed</code>/<code>ufixed</code>表达的是不同尺寸的有符号和无符号定点数。关键字<code>ufixedMxN</code>和<code>fixedMxN</code>里，<code>M</code> 代表这个类型可以使用的位数，而<code>N</code>代表的是有多少个小数位可被使用。<code>M</code>必须可被8整除，从8增长到256。<code>N</code>必须在0到80之间。相应地，<code>ufixed</code>和<code>fixed</code>是<code>ufixed128x19</code> 和 <code>fixed128x19</code>的别名。</p>
<p>浮点数（IEEE 754）的小数点位置是可变的，而定点数是不可变的。</p>
<h5 id="地址类型"><a href="#地址类型" class="headerlink" title="地址类型"></a>地址类型</h5><p>地址拥有20字节的数据，它也有成员，而且在0.5.0以前是所有合约的基类。在0.5.0之后，合约类型不再从地址类型里衍生出来，但可以被显式地转化为地址。</p>
<p>地址的成员：</p>
<ul>
<li>balance<code>和</code>transfer</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address x = <span class="number">0x123</span>;</span><br><span class="line">address myAddress = <span class="built_in">this</span>;</span><br><span class="line"><span class="keyword">if</span> (x.balance &lt; <span class="number">10</span> &amp;&amp; myAddress.balance &gt;= <span class="number">10</span>) x.transfer(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<p><strong>特别地，向合约地址调用 transfer 的时候，每个合约地址的 fallback 函数会被调用。</strong></p>
<ul>
<li><p>send 是 transfer 低级对应物。如果执行失败，transfer 抛出异常而 send 返回 false。</p>
</li>
<li><p>call, callcode and delegatecall</p>
</li>
</ul>
<p>call 可以使用任意数量任意类型的参数和接口交互。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">address nameReg = <span class="number">0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2</span>;</span><br><span class="line">nameReg.call(<span class="string">&quot;register&quot;</span>, <span class="string">&quot;MyName&quot;</span>);</span><br><span class="line">nameReg.call(bytes4(keccak256(<span class="string">&quot;fun(uint256)&quot;</span>)), a);</span><br></pre></td></tr></table></figure>
<p>修改提供的 gas 数量的函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">namReg.call.gas(<span class="number">1000000</span>)(<span class="string">&quot;register&quot;</span>, <span class="string">&quot;MyName&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>类似地，也可以在调用函数的时候转钱：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure>
<p>无关顺序的修饰符使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nameReg.call.gas(1000000).value(1 ether)(&quot;register&quot;, &quot;MyName&quot;);</span><br></pre></td></tr></table></figure>

<p>delegatecall可以被用来调用某个特定合约上的地址，这个方法的用意就是用来调用其他合约上的库函数。它的早期版本（家园以前）callcode 同理，而且callcode 不能访问<code>msg.sender</code>和<code>msg.value</code>。<strong>callcode 将在未来的版本被移除。</strong></p>
<p>尽量应该使用 transfer 而不要使用低级 API，因为它们破坏了 Solidity 的类型安全。</p>
<p><code>.gas()</code>选项对于三个方法都可用，但<code>.value()</code>选项不被<code>delegatecall</code>所支持。</p>
<p>因为所有的合约都集成了地址的成员，所以在合约里可以这样查余额<code>this.balance</code>。</p>
<h5 id="定长字节数组"><a href="#定长字节数组" class="headerlink" title="定长字节数组"></a>定长字节数组</h5><p><code>bytes1</code>，<code>bytes2</code>，<code>bytes3</code>，…，<code>bytes32</code>。 <code>byte</code> 是 <code>bytes1</code>的别名。</p>
<p>这个类型也支持常见的比较、位操作符，它还支持更重要的索引操作符：如果 x 是个<code>bytesI</code>类型，<code>x[k]</code>(<code>0 &lt;= k &lt; I</code>)返回第 k<br>个字节。</p>
<h5 id="动态长度字节数组"><a href="#动态长度字节数组" class="headerlink" title="动态长度字节数组"></a>动态长度字节数组</h5><p><code>bytes</code>：动态长度字节数组，见<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/types.html#arrays">Arrays</a>。不是一个值类型（为什么要放这里？）。</p>
<p><code>string</code>：动态utf-8编码字符串，见<a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/types.html#arrays">Arrays</a>。不是一个值类型（为什么要放这里？）。</p>
<p>如果有任意长度数据的需求，应该优先使用<code>bytes</code>和<code>string</code>，否则尽量使用定长的数据数据类型，<code>bytes1</code>和<code>bytes32</code>比较便宜。</p>
<h5 id="地址字面量"><a href="#地址字面量" class="headerlink" title="地址字面量"></a>地址字面量</h5><p>能够通过地址测试的十六进制字面量（加上0x长度为42的字符串）如<code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code>是 地址类型。</p>
<h5 id="有理数和整数字面量"><a href="#有理数和整数字面量" class="headerlink" title="有理数和整数字面量"></a>有理数和整数字面量</h5><p>常见整数字面量：<code>69</code>。<br>十进位小数字面量：<code>1.3</code>。<br>科学计数法：<code>2e10</code>，<code>-2e10</code>，<code>2e-10</code>，<code>2.5e1.</code>。</p>
<p>早期版本的有理数除法会导致截断，当前版本不会，<code>5/2</code>现在等于2.5了。</p>
<h5 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h5><p>单引号和双引号都可以包裹字符串字面量，如<code>&quot;foo&quot;</code>和<code>&#39;bar&#39;</code>。他们没有 C 中的尾随0。<code>&quot;foo&quot;</code>代表三个字节而不是四个。他们可以被隐式地转换为各种字节数组（见上文），定长不定长的都可能，当然也可以转化为<code>string</code>。</p>
<p>字符串字面量支持转义符，如<code>\n</code>，<code>\xNN</code>和<code>\uNNNN</code>。<code>\xNN</code>取一个十六进制的值，并插入一个正确的字节。<code>\uNNNN</code>取一个 Unicode 码点，并且插入一个UTF-8序数。</p>
<h5 id="十六进制字面量"><a href="#十六进制字面量" class="headerlink" title="十六进制字面量"></a>十六进制字面量</h5><p>用<code>hex</code>开头，用单双引号括起来：<code>hex&quot;001122FF&quot;</code>。</p>
<h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p>这里的枚举也是可以显式地与整型数互相转换的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract test &#123;</span><br><span class="line">    enum ActionChoices &#123; GoLeft, GoRight, GoStraight, SitStill &#125;</span><br><span class="line">    ActionChoices choice;</span><br><span class="line">    ActionChoices constant defaultChoice = ActionChoices.GoStraight;</span><br><span class="line"></span><br><span class="line">    function setGoStraight() public &#123;</span><br><span class="line">        choice = ActionChoices.GoStraight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Since enum types are not part of the ABI, the signature of &quot;getChoice&quot;</span><br><span class="line">    // will automatically be changed to &quot;getChoice() returns (uint8)&quot;</span><br><span class="line">    // for all matters external to Solidity. The integer type used is just</span><br><span class="line">    // large enough to hold all enum values, i.e. if you have more values,</span><br><span class="line">    // `uint16` will be used and so on.</span><br><span class="line">    function getChoice() public view returns (ActionChoices) &#123;</span><br><span class="line">        return choice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function getDefaultChoice() public pure returns (uint) &#123;</span><br><span class="line">        return uint(defaultChoice);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h5><p>同函数式编程里面的一等类型函数差不多。</p>
<p>函数类型被分为两种：内部和外部函数。</p>
<p>内部函数只能在当前合约内被调用（更具体地说，在当前的代码单元内，也就包含了内部函数库和继承下来的函数），因为他们不能在当前合约的上下文之外被执行。调用一个内部函数的实现方式就是让控制流跳到一个条目标签上。</p>
<p>外部函数包括一个地址和一个函数签名，他们可以被传递进/传递出外部函数调用。</p>
<p>函数类型的标记法是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function (&lt;parameter types&gt;) &#123;internal|external&#125; [pure|constant|view|payable] [returns (&lt;return types&gt;)]</span><br></pre></td></tr></table></figure>

<p>不允许出现空的 return 语句。</p>
<p>默认函数都是 internal 的，所以 internal 实际上可以被省略（类似 C 语言呢）。</p>
<p><code>delete</code>一个函数后，再调用它会出现运行时异常。</p>
<p>如果一个外部函数变量被 Solidity 之外的上下文调用（跨语言互操作 interoperability问题），他们将被当做<code>function</code>类型，它在一个<code>bytes24</code>类型里放了一个编码的地址，后面还跟着函数识别符。</p>
<p>public（或外部）函数同样包含一个叫<code>selector</code>的成员，它返回一个 <a target="_blank" rel="noopener" href="http://solidity.readthedocs.io/en/develop/abi-spec.html#abi-function-selector">ABI function selector</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Selector &#123;</span><br><span class="line">  function f() public view returns (bytes4) &#123;</span><br><span class="line">    return this.f.selector;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部函数的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library ArrayUtils &#123;</span><br><span class="line">  // 同在一个上下文里的内部函数调用。</span><br><span class="line">  // internal functions can be used in internal library functions because</span><br><span class="line">  // they will be part of the same code context</span><br><span class="line">  function map(uint[] memory self, function (uint) pure returns (uint) f)</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (uint[] memory r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = new uint[](self.length);</span><br><span class="line">    for (uint i = 0; i &lt; self.length; i++) &#123;</span><br><span class="line">      r[i] = f(self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function reduce(</span><br><span class="line">    uint[] memory self,</span><br><span class="line">    function (uint, uint) pure returns (uint) f</span><br><span class="line">  )</span><br><span class="line">    internal</span><br><span class="line">    pure</span><br><span class="line">    returns (uint r)</span><br><span class="line">  &#123;</span><br><span class="line">    r = self[0];</span><br><span class="line">    for (uint i = 1; i &lt; self.length; i++) &#123;</span><br><span class="line">      r = f(r, self[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function range(uint length) internal pure returns (uint[] memory r) &#123;</span><br><span class="line">    r = new uint[](length);</span><br><span class="line">    for (uint i = 0; i &lt; r.length; i++) &#123;</span><br><span class="line">      r[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Pyramid &#123;</span><br><span class="line">  using ArrayUtils for *;</span><br><span class="line">  function pyramid(uint l) public pure returns (uint) &#123;</span><br><span class="line">    return ArrayUtils.range(l).map(square).reduce(sum);</span><br><span class="line">  &#125;</span><br><span class="line">  function square(uint x) internal pure returns (uint) &#123;</span><br><span class="line">    return x * x;</span><br><span class="line">  &#125;</span><br><span class="line">  function sum(uint x, uint y) internal pure returns (uint) &#123;</span><br><span class="line">    return x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个把外部函数类型传递进 struct 的实例，这其实也是个预言机使用的好例子了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.20; // should actually be 0.4.21</span><br><span class="line"></span><br><span class="line">contract Oracle &#123;</span><br><span class="line">  struct Request &#123;</span><br><span class="line">    bytes data;</span><br><span class="line">    function(bytes memory) external callback;</span><br><span class="line">  &#125;</span><br><span class="line">  Request[] requests;</span><br><span class="line">  event NewRequest(uint);</span><br><span class="line">  function query(bytes data, function(bytes memory) external callback) public &#123;</span><br><span class="line">    requests.push(Request(data, callback));</span><br><span class="line">    emit NewRequest(requests.length - 1);</span><br><span class="line">  &#125;</span><br><span class="line">  function reply(uint requestID, bytes response) public &#123;</span><br><span class="line">    // Here goes the check that the reply comes from a trusted source</span><br><span class="line">    requests[requestID].callback(response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract OracleUser &#123;</span><br><span class="line">  Oracle constant oracle = Oracle(0x1234567); // known contract</span><br><span class="line">  function buySomething() &#123;</span><br><span class="line">    oracle.query(&quot;USD&quot;, this.oracleResponse);</span><br><span class="line">  &#125;</span><br><span class="line">  function oracleResponse(bytes response) public &#123;</span><br><span class="line">    require(msg.sender == address(oracle));</span><br><span class="line">    // Use the data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在还不支持 Lambda 函数和内联函数。</p>
<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4><p>复合类型，也就是类型不衬进256位的类型，总要被比我们已经看到的值类型更仔细地对待。因为拷贝它们是非常昂贵的，所以我们要仔细考虑它们应该被存储在<code>memory里</code>（不会被持久化）还是被存储在<code>storage</code>（状态变量就放在这里）里。</p>
<h5 id="数据位置"><a href="#数据位置" class="headerlink" title="数据位置"></a>数据位置</h5><p>每个复合类型，数组和结构体，都有一个额外的注解，即“数据位置”，关于它是被存储在memory里还是在storage里。依据上下文的不同，总有一个缺省值，但它可以被往类型上添加<code>storage</code>和<code>memory</code>覆盖掉。默认的函数参数是<code>memory</code>的，默认的局部变量是<code>storage</code>的（即这两者是可变的），状态变量的位置被强制设为<code>storage</code>。</p>
<p>还有第三种数据位置，<code>calldata</code>，它是不可修改的，不持久化的，函数实参存储在里面。外部函数的函数参数（而不是返回参数）被强制为<code>calldata</code>，行为表现与<code>memory</code>很相似。</p>
<p>数据位置是重要的，因为他们改变了赋值行为:<code>memory</code>和<code>storage</code>之间的赋值、状态变量之间的赋值总是会产生独立拷贝。向局部<code>storage</code> 变量赋值，尽管只是赋予一个引用，这个引用总是指向一个状态变量，即使后者会改变。<code>memory</code>和<code>memory</code>之间的赋值不会产生拷贝。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] x; // the data location of x is storage</span><br><span class="line"></span><br><span class="line">    // the data location of memoryArray is memory</span><br><span class="line">    function f(uint[] memoryArray) public &#123;</span><br><span class="line">        x = memoryArray; // works, copies the whole array to storage</span><br><span class="line">        var y = x; // works, assigns a pointer, data location of y is storage</span><br><span class="line">        y[7]; // fine, returns the 8th element</span><br><span class="line">        // 局部 storage 变量修改了状态 storage 变量。</span><br><span class="line">        y.length = 2; // fine, modifies x through y</span><br><span class="line">        // 清除数组的方法</span><br><span class="line">        delete x; // fine, clears the array, also modifies y</span><br><span class="line">        // 可以把实参赋给状态变量，把局部变量指向状态变量，却不能跳过第一步。状态变量都是“静态分配”的。</span><br><span class="line">        // The following does not work; it would need to create a new temporary /</span><br><span class="line">        // unnamed array in storage, but storage is &quot;statically&quot; allocated:</span><br><span class="line">        // y = memoryArray;</span><br><span class="line">        // This does not work either, since it would &quot;reset&quot; the pointer, but there</span><br><span class="line">        // is no sensible location it could point to.</span><br><span class="line">        // delete y;</span><br><span class="line">        g(x); // calls g, handing over a reference to x</span><br><span class="line">        h(x); // calls h and creates an independent, temporary copy in memory</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g(uint[] storage storageArray) internal &#123;&#125;</span><br><span class="line">    function h(uint[] memoryArray) public &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实验之中，构造函数生成的总是<code>memory</code>类型的变量，拷贝到 storage 变量就可以让它被持久化了。</p>
<p>总结一下：</p>
<p>强制数据位置：<br>外部函数的参数必须是<code>calldata</code><br>状态变量必须是<code>storage</code><br>缺省数据位置：<br>函数参数默认是<code>memory</code><br>所有局部变量默认是<code>storage</code></p>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>数组可以有编译时的固定长度，也可以是动态的。<code>storage</code>数组的元素类型可以是任意的（即可以是数组的数组、mapping 的数组和结构体的数组）。<code>memory</code>数组则不能有<code>mapping</code>元素，如果它是个公共可见函数（外部函数？），它的元素必须是个 ABI 类型。</p>
<p>定长数组写作，<code>T[k]</code>，变长数组写作<code>T[]</code>（也就是说大部分的智能合约的函数参数都是<code>memory</code>动态数组）。</p>
<p>5个<code>unint</code>动态数组的写法与其他语言正好反过来，<code>uint[][15]</code>。访问第三个动态数组的第二个元素，又反而和其它语言一样，<code>x[2][16]</code>。</p>
<h5 id="创建内存数组"><a href="#创建内存数组" class="headerlink" title="创建内存数组"></a>创建内存数组</h5><p><strong>可以用 new 来创建内存数组</strong>。<code>memory</code>数组不可以通过<code>.length</code> 来修改数组尺寸，但<code>storage</code>数组可以。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint len) public pure &#123;</span><br><span class="line">        uint[] memory a = new uint[](7);</span><br><span class="line">        bytes memory b = new bytes(len);</span><br><span class="line">        // Here we have a.length == 7 and b.length == len</span><br><span class="line">        a[6] = 8;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="数组字面量-内联数组"><a href="#数组字面量-内联数组" class="headerlink" title="数组字面量/内联数组"></a>数组字面量/内联数组</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        g([uint(1), 2, 3]);</span><br><span class="line">    &#125;</span><br><span class="line">    // 这也是个定长数组的例子</span><br><span class="line">    function g(uint[3] _data) public pure &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h5><p>length：只有 storage 的动态数组才能动态修改自己的尺寸。<br>push：在数组尾部添加元素，返回新的长度。</p>
<p>数组的一个综合例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract ArrayContract &#123;</span><br><span class="line">    uint[2**20] m_aLotOfIntegers;</span><br><span class="line">    // Note that the following is not a pair of dynamic arrays but a</span><br><span class="line">    // dynamic array of pairs (i.e. of fixed size arrays of length two).</span><br><span class="line">    bool[2][] m_pairsOfFlags;</span><br><span class="line">    // newPairs is stored in memory - the default for function arguments</span><br><span class="line"></span><br><span class="line">    function setAllFlagPairs(bool[2][] newPairs) public &#123;</span><br><span class="line">        // assignment to a storage array replaces the complete array</span><br><span class="line">        m_pairsOfFlags = newPairs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function setFlagPair(uint index, bool flagA, bool flagB) public &#123;</span><br><span class="line">        // access to a non-existing index will throw an exception</span><br><span class="line">        m_pairsOfFlags[index][0] = flagA;</span><br><span class="line">        m_pairsOfFlags[index][17] = flagB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeFlagArraySize(uint newSize) public &#123;</span><br><span class="line">        // if the new size is smaller, removed array elements will be cleared</span><br><span class="line">        m_pairsOfFlags.length = newSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function clear() public &#123;</span><br><span class="line">        // these clear the arrays completely</span><br><span class="line">        delete m_pairsOfFlags;</span><br><span class="line">        delete m_aLotOfIntegers;</span><br><span class="line">        // identical effect here</span><br><span class="line">        m_pairsOfFlags.length = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bytes m_byteData;</span><br><span class="line"></span><br><span class="line">    function byteArrays(bytes data) public &#123;</span><br><span class="line">        // byte arrays (&quot;bytes&quot;) are different as they are stored without padding,</span><br><span class="line">        // but can be treated identical to &quot;uint8[]&quot;</span><br><span class="line">        m_byteData = data;</span><br><span class="line">        m_byteData.length += 7;</span><br><span class="line">        m_byteData[3] = byte(8);</span><br><span class="line">        delete m_byteData[2];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function addFlag(bool[2] flag) public returns (uint) &#123;</span><br><span class="line">        return m_pairsOfFlags.push(flag);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createMemoryArray(uint size) public pure returns (bytes) &#123;</span><br><span class="line">        // Dynamic memory arrays are created using `new`:</span><br><span class="line">        uint[2][] memory arrayOfPairs = new uint[2][](size);</span><br><span class="line">        // Create a dynamic byte array:</span><br><span class="line">        bytes memory b = new bytes(200);</span><br><span class="line">        for (uint i = 0; i &lt; b.length; i++)</span><br><span class="line">            b[i] = byte(i);</span><br><span class="line">        return b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="结构体类型"><a href="#结构体类型" class="headerlink" title="结构体类型"></a>结构体类型</h5><p>结构体提供了定义新类型的能力。<br>众筹合约的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract CrowdFunding &#123;</span><br><span class="line">    // Defines a new type with two fields.</span><br><span class="line">    struct Funder &#123;</span><br><span class="line">        address addr;</span><br><span class="line">        uint amount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    struct Campaign &#123;</span><br><span class="line">        address beneficiary;</span><br><span class="line">        uint fundingGoal;</span><br><span class="line">        uint numFunders;</span><br><span class="line">        uint amount;</span><br><span class="line">        mapping (uint =&gt; Funder) funders;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    uint numCampaigns;</span><br><span class="line">    mapping (uint =&gt; Campaign) campaigns;</span><br><span class="line"></span><br><span class="line">    function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) &#123;</span><br><span class="line">        campaignID = numCampaigns++; // campaignID is return variable</span><br><span class="line">        // Creates new struct and saves in storage. We leave out the mapping type.</span><br><span class="line">        // 这里构造函数生成的数据类型是 memory，而 campaigns[campaignID]的数据位置是 storage，只有这种方式可以隐式自动转化这两种 data location。</span><br><span class="line">        campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function contribute(uint campaignID) public payable &#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        // Creates a new temporary memory struct, initialised with the given values</span><br><span class="line">        // and copies it over to storage.</span><br><span class="line">        // Note that you can also use Funder(msg.sender, msg.value) to initialise.</span><br><span class="line">        c.funders[c.numFunders++] = Funder(&#123;addr: msg.sender, amount: msg.value&#125;);</span><br><span class="line">        c.amount += msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function checkGoalReached(uint campaignID) public returns (bool reached) &#123;</span><br><span class="line">        Campaign storage c = campaigns[campaignID];</span><br><span class="line">        if (c.amount &lt; c.fundingGoal)</span><br><span class="line">            return false;</span><br><span class="line">        uint amount = c.amount;</span><br><span class="line">        c.amount = 0;</span><br><span class="line">        c.beneficiary.transfer(amount);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>struct 本身可以存储数组和映射，也可以被这两者存储。它不能存储它自身类型的变量，struct 的尺寸必须是有限的。</p>
<h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4><p><code>mapping(_KeyType =&gt; _ValueType)</code>里的key类型不能是映射，动态长度数组、合约、枚举和结构体。value 可以是任何类型。</p>
<p>映射可以被认为是个被虚拟初始化的 hash 表，所有可能的键都存在而且值被初始化为0值。实际上 key 数据并不存在映射里面，只有它的<code>keccak256</code>散列值被存在里面，用来查值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract MappingExample &#123;</span><br><span class="line">    mapping(address =&gt; uint) public balances;</span><br><span class="line"></span><br><span class="line">    function update(uint newBalance) public &#123;</span><br><span class="line">        balances[msg.sender] = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract MappingUser &#123;</span><br><span class="line">    function f() public returns (uint) &#123;</span><br><span class="line">        MappingExample m = new MappingExample();</span><br><span class="line">        m.update(100);</span><br><span class="line">        return m.balances(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mapping 本身是不可迭代的，但可以看<a target="_blank" rel="noopener" href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol">iterable mapping</a>，看看怎么在它之上建立一个可迭代的结构。</p>
<h4 id="牵涉到左值的操作符"><a href="#牵涉到左值的操作符" class="headerlink" title="牵涉到左值的操作符"></a>牵涉到左值的操作符</h4><h5 id="delete"><a href="#delete" class="headerlink" title="delete"></a>delete</h5><p><code>delete</code>一个变量，差不多可以说是把一个零值赋给它。除了不能 delete 一个映射以外，所有类型的变量都可以被 delete。delete 动态数组会得到一个长度为0的新动态数组，delete 一个静态数组会得到一个长度等于原长度，所有元素都等于该元素类型零值的数组，delete 一个结构体变量，所有的成员除了映射都会变成0值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract DeleteExample &#123;</span><br><span class="line">    uint data;</span><br><span class="line">    uint[] dataArray;</span><br><span class="line"></span><br><span class="line">    function f() public &#123;</span><br><span class="line">        // 注意！这里 x 拷贝了 data，而不是把一个指针指向了 data。</span><br><span class="line">        uint x = data;</span><br><span class="line">        delete x; // sets x to 0, does not affect data</span><br><span class="line">        delete data; // sets data to 0, does not affect x which still holds a copy</span><br><span class="line">        uint[] storage y = dataArray;</span><br><span class="line">        delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also</span><br><span class="line">        // y is affected which is an alias to the storage object</span><br><span class="line">        // On the other hand: &quot;delete y&quot; is not valid, as assignments to local variables</span><br><span class="line">        // referencing storage objects can only be made from existing storage objects.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基本数据类型之间的转换"><a href="#基本数据类型之间的转换" class="headerlink" title="基本数据类型之间的转换"></a>基本数据类型之间的转换</h4><p>所有的数据类型都可以转变为<code>uint160</code>，也就可以转变为地址。</p>
<p>显式转换的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uint x = uint(y);</span><br></pre></td></tr></table></figure>

<h4 id="类型推导"><a href="#类型推导" class="headerlink" title="类型推导"></a>类型推导</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uint24 x = 0x123;</span><br><span class="line">var y = x;</span><br></pre></td></tr></table></figure>

<p>var 不能用在函数形参和返回值上。<br>var 只在第一次赋值时被推导出来，所以以下循环无法终止：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (var i = 0; i &lt; 2000; i++) &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>因为第一次赋值，使得 i 被推导为<code>uint8</code>类型了。</p>
<h3 id="单位和全局可用变量"><a href="#单位和全局可用变量" class="headerlink" title="单位和全局可用变量"></a>单位和全局可用变量</h3><h4 id="以太币的单位"><a href="#以太币的单位" class="headerlink" title="以太币的单位"></a>以太币的单位</h4><p>四级单位<code>wei</code>，<code>finney</code>，<code>szabo</code> 或者 <code>ether</code>。<code>2 ether == 2000 finney</code>。</p>
<h4 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h4><p><code>seconds</code>，<code>minutes</code>，<code>hours</code>，<code>day</code>，<code>weeks</code>和<code>years</code>。<br>小心闰秒（ leap seconds）问题。</p>
<p>巧妙使用单位来对比当前时间的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(uint start, uint daysAfter) public &#123;</span><br><span class="line">    if (now &gt;= start + daysAfter * 1 days) &#123;</span><br><span class="line">      // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="特殊的变量和函数"><a href="#特殊的变量和函数" class="headerlink" title="特殊的变量和函数"></a>特殊的变量和函数</h4><p>在全局空间里早已存在一些特殊的变量和函数，用以提供区块链的信息：</p>
<h5 id="区块和事务属性"><a href="#区块和事务属性" class="headerlink" title="区块和事务属性"></a>区块和事务属性</h5><ul>
<li>block.blockhash(uint blockNumber) returns (bytes32)：一个给定区块的散列值 - 只对当前最近的256个区块奏效。</li>
<li>block.coinbase (address)：当前区块挖掘者的地址。</li>
<li>block.difficulty (uint)：当前区块的难度。</li>
<li>block.gaslimit (uint)：当前区块的 gaslimit。</li>
<li>block.number (uint)：当前区块号</li>
<li>block.timestamp (uint)：当前区块的时间戳，从 unix epoch 开始的秒数形式。</li>
<li>msg.data (bytes)：完整的调用数据。</li>
<li>msg.gas (uint)：剩余 gas。</li>
<li>msg.sender (address)：当前调用的消息发送者。</li>
<li>msg.sig (bytes4)：calldata 的最初四个字节（函数标识符）。</li>
<li>msg.value (uint)：消息附带的价值数。</li>
<li>now (uint)：时间戳的别名。</li>
<li>tx.gasprice (uint)：事务的 gasprice。</li>
<li>tx.origin (address)：事务的发送者 (完整调用链)。</li>
</ul>
<p>msg 的所有成员，可能在每个外部调用中都发生变化。</p>
<h5 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h5><p><code>assert(bool condition)</code>：如果条件不为真抛出异常。<br><code>require(bool condition)</code>：抛出异常如果条件不为真，用来做输入检查（通常配合 modifier 使用）。<br><code>revert()</code>：退出执行，并且反转状态变化。</p>
<h5 id="数学和密码学函数"><a href="#数学和密码学函数" class="headerlink" title="数学和密码学函数"></a>数学和密码学函数</h5><ul>
<li>addmod(uint x, uint y, uint k) returns (uint):<br>compute (x + y) % k where the addition is performed with arbitrary precision and does not wrap around at 2**256. Assert that k != 0 starting from version 0.5.0.</li>
<li>mulmod(uint x, uint y, uint k) returns (uint):<br>compute (x * y) % k where the multiplication is performed with arbitrary precision and does not wrap around at 2**256. Assert that k != 0 starting from version 0.5.0.</li>
<li>keccak256(…) returns (bytes32):<br>compute the Ethereum-SHA-3 (Keccak-256) hash of the (tightly packed) arguments</li>
<li>sha256(…) returns (bytes32):<br>compute the SHA-256 hash of the (tightly packed) arguments</li>
<li>sha3(…) returns (bytes32):<br>alias to keccak256</li>
<li>ripemd160(…) returns (bytes20):<br>compute RIPEMD-160 hash of the (tightly packed) arguments</li>
<li>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address):<br>recover the address associated with the public key from elliptic curve signature or return zero on error (example usage)</li>
</ul>
<p>因为“紧密打包”，以下内容是相等的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">keccak256(&quot;ab&quot;, &quot;c&quot;)</span><br><span class="line">keccak256(&quot;abc&quot;)</span><br><span class="line">keccak256(0x616263)</span><br><span class="line">keccak256(6382179)</span><br><span class="line">keccak256(97, 98, 99)</span><br></pre></td></tr></table></figure>

<h3 id="表达式和控制结构"><a href="#表达式和控制结构" class="headerlink" title="表达式和控制结构"></a>表达式和控制结构</h3><h4 id="输入参数和输出参数"><a href="#输入参数和输出参数" class="headerlink" title="输入参数和输出参数"></a>输入参数和输出参数</h4><h5 id="输入参数"><a href="#输入参数" class="headerlink" title="输入参数"></a>输入参数</h5><p>声明输入参数和声明变量一样。</p>
<h5 id="输出参数"><a href="#输出参数" class="headerlink" title="输出参数"></a>输出参数</h5><p>输出参数的定义，很像 Golang：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract Simple &#123;</span><br><span class="line">    function arithmetics(uint _a, uint _b)</span><br><span class="line">        public</span><br><span class="line">        pure</span><br><span class="line">        returns (uint o_sum, uint o_product)</span><br><span class="line">    &#123;</span><br><span class="line">        o_sum = _a + _b;</span><br><span class="line">        o_product = _a * _b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h4><p>除了 switch 和 goto，JavaScript 中所有的控制结构 Solidity 都支持。</p>
<h5 id="多返回值"><a href="#多返回值" class="headerlink" title="多返回值"></a>多返回值</h5><p>我们已经看到声明的地方有多返回值了，可以像 Golang 一样写多返回值-<code>return (v0, v1, ..., vn)</code>。</p>
<h4 id="Function-Calls"><a href="#Function-Calls" class="headerlink" title="Function Calls"></a>Function Calls</h4><h5 id="内部调用"><a href="#内部调用" class="headerlink" title="内部调用"></a>内部调用</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function g(uint a) public pure returns (uint ret) &#123; return f(); &#125;</span><br><span class="line">    function f() internal pure returns (uint ret) &#123; return g(7) + f(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部调用会被 EVM 翻译成字节码，直接 jump 过去。因为这时候还是在内存内调用，内存内状态没有被清理掉，所以是很高效。</p>
<h5 id="外部函数调用"><a href="#外部函数调用" class="headerlink" title="外部函数调用"></a>外部函数调用</h5><p>像<code>c.g(2);</code>这类调用，本身是在一个 contract 实例上的调用，本身必然要求 message call 的，就不能 jump 了。</p>
<p>调用其他合约的 payable 方法的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract InfoFeed &#123;</span><br><span class="line">    function info() public payable returns (uint ret) &#123; return 42; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Consumer &#123;</span><br><span class="line">    InfoFeed feed;</span><br><span class="line">    function setFeed(address addr) public &#123; feed = InfoFeed(addr); &#125;</span><br><span class="line">    function callFeed() public &#123; feed.info.value(10).gas(800)(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有被 payable 修饰的方法，才可以被 value option 方法调用。<code>InfoFeed(addr)</code>并不是调用一个构造方法（看来构造方法只有在合约初始化的时候才会被调用），而是向这个地址声称能一个代理对象？</p>
<p>与任何其他合约交互都有潜在危险，特别是在该合约的源码事先未知的情况下。当前的合约把控制权拱手交给被调用合约，它就可以做任何事。为了让自己的成not vulnerable to exploit，应该让自己的外部函数调用有防御性，尽量让外部函数调用发生在<strong>状态改变之后</strong>。</p>
<h5 id="命名调用和匿名函数参数"><a href="#命名调用和匿名函数参数" class="headerlink" title="命名调用和匿名函数参数"></a>命名调用和匿名函数参数</h5><p>一个简单的字面量调用的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint key, uint value) public &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public &#123;</span><br><span class="line">        // named arguments</span><br><span class="line">        f(&#123;value: 2, key: 3&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="省略函数参数名"><a href="#省略函数参数名" class="headerlink" title="省略函数参数名"></a>省略函数参数名</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // 这里有个被省略了的 uint 参数，不能访问到。</span><br><span class="line">    // omitted name for parameter</span><br><span class="line">    function func(uint k, uint) public pure returns(uint) &#123;</span><br><span class="line">        return k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="用new创建新合约"><a href="#用new创建新合约" class="headerlink" title="用new创建新合约"></a>用<code>new</code>创建新合约</h4><p>可以用<code>new</code>来创建合约。要被创建的合约的完整代码，要事先被知道，所以，也就不可能有递归的创建依赖了：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function D(uint a) public payable &#123;</span><br><span class="line">        x = a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    // 创建 C 的时候一并创建 D</span><br><span class="line">    D d = new D(4); // will be executed as part of C&#x27;s constructor</span><br><span class="line"></span><br><span class="line">    function createD(uint arg) public &#123;</span><br><span class="line">        D newD = new D(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function createAndEndowD(uint arg, uint amount) public payable &#123;</span><br><span class="line">        // Send ether along with the creation</span><br><span class="line">        D newD = (new D).value(amount)(arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="表达式求值的顺序"><a href="#表达式求值的顺序" class="headerlink" title="表达式求值的顺序"></a>表达式求值的顺序</h4><p>除了布尔表达式以外，所有表达式的求值顺序都可能是未定的。在表达式树中，只有一个节点的子节点的孩子节点一定会在它之前执行（后缀遍历），其他的全部都没有保证。</p>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><h5 id="解构赋值和多返回值"><a href="#解构赋值和多返回值" class="headerlink" title="解构赋值和多返回值"></a>解构赋值和多返回值</h5><p>Solidity 内部支持元组类型，即一个元素可能是不同类型，但长度在编译时就已经确定为常数的数组列表。元组才是多返回值的本质（其实在其他语言里还允许对象结构的解构返回）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function f() public pure returns (uint, bool, uint) &#123;</span><br><span class="line">        return (7, true, 2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g() public &#123;</span><br><span class="line">        // Declares and assigns the variables. Specifying the type explicitly is not possible.</span><br><span class="line">        var (x, b, y) = f();</span><br><span class="line">        // Assigns to a pre-existing variable.</span><br><span class="line">        (x, y) = (2, 7);</span><br><span class="line">        // Common trick to swap values -- does not work for non-value storage types.</span><br><span class="line">        (x, y) = (y, x);</span><br><span class="line">        // Components can be left out (also for variable declarations).</span><br><span class="line">        // If the tuple ends in an empty component,</span><br><span class="line">        // the rest of the values are discarded.</span><br><span class="line">        (data.length,) = f(); // Sets the length to 7</span><br><span class="line">        // The same can be done on the left side.</span><br><span class="line">        // If the tuple begins in an empty component, the beginning values are discarded.</span><br><span class="line">        (,data[3]) = f(); // Sets data[3] to 2</span><br><span class="line">        // Components can only be left out at the left-hand-side of assignments, with</span><br><span class="line">        // one exception:</span><br><span class="line">        (x,) = (1,);</span><br><span class="line">        // (1,) is the only way to specify a 1-component tuple, because (1) is</span><br><span class="line">        // equivalent to 1.</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="数组和结构体的复杂点"><a href="#数组和结构体的复杂点" class="headerlink" title="数组和结构体的复杂点"></a>数组和结构体的复杂点</h5><p>数组和结构体等非值类型赋值语义稍显复杂。</p>
<p>赋值给一个状态变量总是会产生一个独立拷贝。</p>
<p>从状态变量赋数组和结构体给局部变量是传引用，再赋值还是传引用。</p>
<h4 id="作用域和声明"><a href="#作用域和声明" class="headerlink" title="作用域和声明"></a>作用域和声明</h4><p>一个变量（包括在函数内）被声明的时候就会拥有字节零值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function foo() public pure returns (uint) &#123;</span><br><span class="line">        // baz is implicitly initialized as 0</span><br><span class="line">        uint bar = 5;</span><br><span class="line">        if (true) &#123;</span><br><span class="line">            bar += baz;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            uint baz = 10;// never executes</span><br><span class="line">        &#125;</span><br><span class="line">        return bar;// returns 5</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数内的变量里还是没有块级作用域的。</p>
<h5 id="从-0-5-0-开始就有作用域了"><a href="#从-0-5-0-开始就有作用域了" class="headerlink" title="从 0.5.0 开始就有作用域了"></a>从 0.5.0 开始就有作用域了</h5><p>块作用域有块生命周期。<br>for 相关变量只有 for 块的生命周期。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">pragma experimental &quot;v0.5.0&quot;;</span><br><span class="line">contract C &#123;</span><br><span class="line">    function minimalScoping() pure public &#123;</span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#123;</span><br><span class="line">            uint same2 = 0;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line">pragma experimental &quot;v0.5.0&quot;;</span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() pure public returns (uint) &#123;</span><br><span class="line">        uint x = 1;</span><br><span class="line">        &#123;</span><br><span class="line">            x = 2; // this will assign to the outer variable</span><br><span class="line">            uint x;</span><br><span class="line">        &#125;</span><br><span class="line">        return x; // x has value 2</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="错误处理：断言、需求、反转和异常"><a href="#错误处理：断言、需求、反转和异常" class="headerlink" title="错误处理：断言、需求、反转和异常"></a>错误处理：断言、需求、反转和异常</h4><p>所有异常都会反转当前的调用及其子调用的状态变化。</p>
<p>在未来<code>throw</code>会被淘汰掉，应该使用<code>revert</code>。</p>
<p>有些调用方法是靠返回值来确认异常的，注意检查返回值。</p>
<p>目前不支持 catch 语句。</p>
<h3 id="合约"><a href="#合约" class="headerlink" title="合约"></a>合约</h3><p>Solidity 里的合约，类似面向对象语言里面的类。他们包含持久化状态和修改状态的函数。</p>
<p>跨合约调用不能引用老上下文的状态变量，但依然要小心外部函数调用问题。</p>
<h4 id="创建合约"><a href="#创建合约" class="headerlink" title="创建合约"></a>创建合约</h4><p>可以用外部事务或者在合约内部创建合约。</p>
<p>可以用<a target="_blank" rel="noopener" href="https://github.com/ethereum/web3.js">web3.js</a>的 API 创建合约，具体参见<a target="_blank" rel="noopener" href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract">web3.eth.Contract</a>。</p>
<p>只允许一个构造函数，不允许构造函数重载。也可以没有构造函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract OwnedToken &#123;</span><br><span class="line">    // TokenCreator is a contract type that is defined below.</span><br><span class="line">    // It is fine to reference it as long as it is not used</span><br><span class="line">    // to create a new contract.</span><br><span class="line">    TokenCreator creator;</span><br><span class="line">    address owner;</span><br><span class="line">    bytes32 name;</span><br><span class="line"></span><br><span class="line">    // This is the constructor which registers the</span><br><span class="line">    // creator and the assigned name.</span><br><span class="line">    function OwnedToken(bytes32 _name) public &#123;</span><br><span class="line">        // internal 变量不需要 this 访问，反正这时候合约还不存在呢</span><br><span class="line">        // State variables are accessed via their name</span><br><span class="line">        // and not via e.g. this.owner. This also applies</span><br><span class="line">        // to functions and especially in the constructors,</span><br><span class="line">        // you can only call them like that (&quot;internally&quot;),</span><br><span class="line">        // because the contract itself does not exist yet.</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">        // We do an explicit type conversion from `address`</span><br><span class="line">        // to `TokenCreator` and assume that the type of</span><br><span class="line">        // the calling contract is TokenCreator, there is</span><br><span class="line">        // no real way to check that.</span><br><span class="line">        creator = TokenCreator(msg.sender);</span><br><span class="line">        name = _name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeName(bytes32 newName) public &#123;</span><br><span class="line">        // Only the creator can alter the name --</span><br><span class="line">        // the comparison is possible since contracts</span><br><span class="line">        // are implicitly convertible to addresses.</span><br><span class="line">        if (msg.sender == address(creator))</span><br><span class="line">            name = newName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transfer(address newOwner) public &#123;</span><br><span class="line">        // Only the current owner can transfer the token.</span><br><span class="line">        if (msg.sender != owner) return;</span><br><span class="line">        // We also want to ask the creator if the transfer</span><br><span class="line">        // is fine. Note that this calls a function of the</span><br><span class="line">        // contract defined below. If the call fails (e.g.</span><br><span class="line">        // due to out-of-gas), the execution here stops</span><br><span class="line">        // immediately.</span><br><span class="line">        if (creator.isTokenTransferOK(owner, newOwner))</span><br><span class="line">            owner = newOwner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TokenCreator &#123;</span><br><span class="line">    function createToken(bytes32 name)</span><br><span class="line">       public</span><br><span class="line">       returns (OwnedToken tokenAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        // Create a new Token contract and return its address.</span><br><span class="line">        // From the JavaScript side, the return type is simply</span><br><span class="line">        // `address`, as this is the closest type available in</span><br><span class="line">        // the ABI.</span><br><span class="line">        return new OwnedToken(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changeName(OwnedToken tokenAddress, bytes32 name)  public &#123;</span><br><span class="line">        // Again, the external type of `tokenAddress` is</span><br><span class="line">        // simply `address`.</span><br><span class="line">        tokenAddress.changeName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function isTokenTransferOK(address currentOwner, address newOwner)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (bool ok)</span><br><span class="line">    &#123;</span><br><span class="line">        // 这段可以说是胡诌的</span><br><span class="line">        // Check some arbitrary condition.</span><br><span class="line">        address tokenAddress = msg.sender;</span><br><span class="line">        return (keccak256(newOwner) &amp; 0xff) == (bytes20(tokenAddress) &amp; 0xff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="可见性和-Getter"><a href="#可见性和-Getter" class="headerlink" title="可见性和 Getter"></a>可见性和 Getter</h4><p>内部调用只产生 JUMP，而外部调用产生 EVM call。</p>
<p>有四种可见性：<code>external</code>，<code>public</code>，<code>internal</code>或者 <code>private</code>。这四个可见性，恰好是两组反义词。</p>
<p>状态变量默认可见性是<code>internal</code>而不可能是<code>external</code>。</p>
<p><strong>函数默认可见性是 public！</strong></p>
<p>external：外部函数是合约接口的一部分。意味着他们应该被从外部调用，必然产生 EVM call。一个<code>external</code>的<code>f</code>是不能<code>f()</code>的，只能<code>this.f()</code>。</p>
<p>public：公共函数也是合约接口的一部分。可以外部调用也可以内部调用。最简单而完美的接口设计。公共变量会自动产生一个 getter 函数。</p>
<p>internal：内部函数和变量只能合约内部访问，不用 this。类似 private。</p>
<p>private：内部函数和变量不能被继承，只能内部访问。</p>
<p>注意，合约的所有内容在区块链上都是公开可见的，这些修饰符只能阻止不当修改。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// This will not compile</span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint private data;</span><br><span class="line"></span><br><span class="line">    function f(uint a) private returns(uint b) &#123; return a + 1; &#125;</span><br><span class="line">    function setData(uint a) public &#123; data = a; &#125;</span><br><span class="line">    function getData() public returns(uint) &#123; return data; &#125;</span><br><span class="line">    function compute(uint a, uint b) internal returns (uint) &#123; return a+b; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract D &#123;</span><br><span class="line">    function readData() public &#123;</span><br><span class="line">        C c = new C();</span><br><span class="line">        uint local = c.f(7); // error: member `f` is not visible</span><br><span class="line">        c.setData(3);</span><br><span class="line">        local = c.getData();</span><br><span class="line">        local = c.compute(3, 5); // error: member `compute` is not visible</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 通过继承，实现了代码复用</span><br><span class="line">contract E is C &#123;</span><br><span class="line">    function g() public &#123;</span><br><span class="line">        C c = new C();</span><br><span class="line">        uint val = compute(3, 5); // access to internal member (from derived to parent contract)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Getter"><a href="#Getter" class="headerlink" title="Getter"></a>Getter</h5><p>getter 是自动生成的，一个调用的例子。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data = 42;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    C c = new C();</span><br><span class="line">    function f() public &#123;</span><br><span class="line">        // 换言之，用函数来访问公共变量，不要用点操作符。</span><br><span class="line">        uint local = c.data();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内外访问与内部访问：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint public data;</span><br><span class="line">    function x() public &#123;</span><br><span class="line">        data = 3; // internal access</span><br><span class="line">        uint val = this.data(); // external access</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个更复杂的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Complex &#123;</span><br><span class="line">    struct Data &#123;</span><br><span class="line">        uint a;</span><br><span class="line">        bytes3 b;</span><br><span class="line">        mapping (uint =&gt; uint) map;</span><br><span class="line">    &#125;</span><br><span class="line">    mapping (uint =&gt; mapping(bool =&gt; Data[])) public data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>生成的函数的形式很费解：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) &#123;</span><br><span class="line">    a = data[arg1][arg2][arg3].a;</span><br><span class="line">    b = data[arg1][arg2][arg3].b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数修饰符-1"><a href="#函数修饰符-1" class="headerlink" title="函数修饰符"></a>函数修饰符</h4><p>函数修饰符是用来改变函数行为的，比如检验条件。函数修饰符可以被集成也可以被覆盖。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    // This contract only defines a modifier but does not use</span><br><span class="line">    // it: it will be used in derived contracts.</span><br><span class="line">    // The function body is inserted where the special symbol</span><br><span class="line">    // `_;` in the definition of a modifier appears.</span><br><span class="line">    // This means that if the owner calls this function, the</span><br><span class="line">    // function is executed and otherwise, an exception is</span><br><span class="line">    // thrown.</span><br><span class="line">    modifier onlyOwner &#123;</span><br><span class="line">        require(msg.sender == owner);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    // This contract inherits the `onlyOwner` modifier from</span><br><span class="line">    // `owned` and applies it to the `close` function, which</span><br><span class="line">    // causes that calls to `close` only have an effect if</span><br><span class="line">    // they are made by the stored owner.</span><br><span class="line">    function close() public onlyOwner &#123;</span><br><span class="line">        selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract priced &#123;</span><br><span class="line">    // Modifiers can receive arguments:</span><br><span class="line">    modifier costs(uint price) &#123;</span><br><span class="line">        if (msg.value &gt;= price) &#123;</span><br><span class="line">            _;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Register is priced, owned &#123;</span><br><span class="line">    mapping (address =&gt; bool) registeredAddresses;</span><br><span class="line">    uint price;</span><br><span class="line"></span><br><span class="line">    function Register(uint initialPrice) public &#123; price = initialPrice; &#125;</span><br><span class="line">    </span><br><span class="line">    // 如果没有这个关键字，合约会自动拒绝被发送过来的以太币</span><br><span class="line">    // It is important to also provide the</span><br><span class="line">    // `payable` keyword here, otherwise the function will</span><br><span class="line">    // automatically reject all Ether sent to it.</span><br><span class="line">    function register() public payable costs(price) &#123;</span><br><span class="line">        registeredAddresses[msg.sender] = true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function changePrice(uint _price) public onlyOwner &#123;</span><br><span class="line">        price = _price;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 巧妙地加锁，类似 synchronized。</span><br><span class="line">contract Mutex &#123;</span><br><span class="line">    bool locked;</span><br><span class="line">    modifier noReentrancy() &#123;</span><br><span class="line">        require(!locked);</span><br><span class="line">        locked = true;</span><br><span class="line">        // 让步修饰符，类似 Ruby 中的 yield。</span><br><span class="line">        _;</span><br><span class="line">        locked = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// This function is protected by a mutex, which means that</span><br><span class="line">    /// reentrant calls from within `msg.sender.call` cannot call `f` again.</span><br><span class="line">    /// The `return 7` statement assigns 7 to the return value but still</span><br><span class="line">    /// executes the statement `locked = false` in the modifier.</span><br><span class="line">    function f() public noReentrancy returns (uint) &#123;</span><br><span class="line">        require(msg.sender.call());</span><br><span class="line">        return 7;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="状态常量"><a href="#状态常量" class="headerlink" title="状态常量"></a>状态常量</h4><p>状态变量可以被声明为<code>constant</code>。它们必须被编译时已知常量值的表达式赋值，表达式不能接触 storage (e.g. <code>now</code>，<code>this.balance</code> 或者 <code>block.number</code>)，不能由执行数据决定（<code>msg.value</code>或者<code>gasleft()</code>），或者外部合约调用。允许使用内部计算函数<code>keccak256</code> ，<code>sha256</code>，<code>ripemd160</code>，<code>ecrecover</code>，<code>addmod</code>和<code>mulmod</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    uint constant x = 32**22 + 8;</span><br><span class="line">    string constant text = &quot;abc&quot;;</span><br><span class="line">    bytes32 constant myHash = keccak256(&quot;abc&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h4><h5 id="view"><a href="#view" class="headerlink" title="view"></a>view</h5><p>不修改状态的函数可以被声明为<code>view</code>。</p>
<p>以下情况不能用<code>view</code>：</p>
<ol>
<li>写状态变量</li>
<li>发射事件</li>
<li>创建其他合约</li>
<li>使用自毁</li>
<li>用调用发送以太币（也就是说 call 也不安全）</li>
<li>调用其他非<code>view</code>或者<code>pure</code>方法。</li>
<li>使用低级调用方法。</li>
<li>使用某些特定内联汇编操作码。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f(uint a, uint b) public view returns (uint) &#123;</span><br><span class="line">        return a * (b + 42) + now;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getter 都是<code>view</code>。</p>
<p>view 是尽量做到最大限度的编程安全，有时候又不能保证。所以是个未完成品。</p>
<h5 id="pure-函数"><a href="#pure-函数" class="headerlink" title="pure 函数"></a>pure 函数</h5><p>不读和写 state 的函数叫 pure 函数。view 是不写，pure 更彻底。pure 可能产生副作用，不是函数式编程里的纯函数。</p>
<p>pure 函数首先必须满足 view 函数的要求，然后不能有以下行为：</p>
<ol>
<li>读状态变量</li>
<li>访问任何 balance。</li>
<li>访问 block，tx 和 msg 的任何成员。</li>
<li>调用非<code>pure</code>的其他函数。</li>
<li>使用某些特定内联汇编操作码。</li>
</ol>
<p>pure 也是未完成品，编译器不能保证函数的不读不写。</p>
<h5 id="降级函数"><a href="#降级函数" class="headerlink" title="降级函数"></a>降级函数</h5><p>一个合约只能由一个无名函数。这个函数不能有参数列表，也不能有返回值。合约在被调用，但没有合适的函数匹配得上，或者没有任何调用数据的时候，这个函数就被派上用场了。</p>
<p>这个函数在合约接收到纯以太币（没有数据）的时候，这个函数也会被执行。为了接收以太币，这个函数必须被声明为 payable。没有这个函数，普通转账事务无法往这个合约里转账。</p>
<p>这个函数最少需要 2300个 gas（恰好是普通转账的十分之一）。</p>
<p>即使这个函数没有任何参数，它也可以用<code>msg.data</code>来获取调用载荷。换言之，调用这种函数，应该发送一些没有其他函数可以匹配得上的实参。</p>
<p>早版本的 Solidity 里面降级函数都调用失败的话，是不退币的，现在的版本退币了。</p>
<p>即使没有降级函数，自毁和挖矿的目标依然可以设置为这个合约账户。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Test &#123;</span><br><span class="line">    // This function is called for all messages sent to</span><br><span class="line">    // this contract (there is no other function).</span><br><span class="line">    // Sending Ether to this contract will cause an exception,</span><br><span class="line">    // because the fallback function does not have the `payable`</span><br><span class="line">    // modifier.</span><br><span class="line">    function() public &#123; x = 1; &#125;</span><br><span class="line">    uint x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// This contract keeps all Ether sent to it with no way</span><br><span class="line">// to get it back.</span><br><span class="line">contract Sink &#123;</span><br><span class="line">    function() public payable &#123; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Caller &#123;</span><br><span class="line">    function callTest(Test test) public &#123;</span><br><span class="line">        test.call(0xabcdef01); // hash does not exist</span><br><span class="line">        // results in test.x becoming == 1.</span><br><span class="line"></span><br><span class="line">        // The following will not compile, but even</span><br><span class="line">        // if someone sends ether to that contract,</span><br><span class="line">        // the transaction will fail and reject the</span><br><span class="line">        // Ether.</span><br><span class="line">        //test.send(2 ether);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h5><p>大部分情况下同其他重载一样。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// This will not compile</span><br><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    function f(B _in) public pure returns (B out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function f(address _in) public pure returns (address out) &#123;</span><br><span class="line">        out = _in;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract B &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数之所以编译错误，是因为编译后的 ABI 类型都是 address，等于没有重载。</p>
<h4 id="事件-1"><a href="#事件-1" class="headerlink" title="事件"></a>事件</h4><p>事件允许方便地使用 EVM 的日志基础设施。</p>
<p>日志可以被在合约内部被继承。日志与事务、合约关联，与区块同在。</p>
<p>日志的 SPV 证明是可以做到的。</p>
<p>最多三个参数可以被标记为<code>indexed</code>来索引。其实索引的查找，可能是通过散列存储和查找的方式来实现的。本质上就是把这个参数存成 topic 类型的数据，可以被类似流处理的机制监听起来。</p>
<p>事件的正统 watch 用法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract ClientReceipt &#123;</span><br><span class="line">    event Deposit(</span><br><span class="line">        address indexed _from,</span><br><span class="line">        bytes32 indexed _id,</span><br><span class="line">        uint _value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    function deposit(bytes32 _id) public payable &#123;</span><br><span class="line">        // Events are emitted using `emit`, followed by</span><br><span class="line">        // the name of the event and the arguments</span><br><span class="line">        // (if any) in parentheses. Any such invocation</span><br><span class="line">        // (even deeply nested) can be detected from</span><br><span class="line">        // the JavaScript API by filtering for `Deposit`.</span><br><span class="line">        emit Deposit(msg.sender, _id, msg.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var abi = /* abi as generated by the compiler */;</span><br><span class="line">var ClientReceipt = web3.eth.contract(abi);</span><br><span class="line">var clientReceipt = ClientReceipt.at(&quot;0x1234...ab67&quot; /* address */);</span><br><span class="line"></span><br><span class="line">var event = clientReceipt.Deposit();</span><br><span class="line"></span><br><span class="line">// watch for changes</span><br><span class="line">event.watch(function(error, result)&#123;</span><br><span class="line">    // result will contain various information</span><br><span class="line">    // including the argumets given to the `Deposit`</span><br><span class="line">    // call.</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Or pass a callback to start watching immediately</span><br><span class="line">var event = clientReceipt.Deposit(function(error, result) &#123;</span><br><span class="line">    if (!error)</span><br><span class="line">        console.log(result);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h5 id="低级日志设施"><a href="#低级日志设施" class="headerlink" title="低级日志设施"></a>低级日志设施</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.10;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    function f() public payable &#123;</span><br><span class="line">        bytes32 _id = 0x420042;</span><br><span class="line">        log3(</span><br><span class="line">            bytes32(msg.value),</span><br><span class="line">            bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20),</span><br><span class="line">            bytes32(msg.sender),</span><br><span class="line">            _id</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>logn 一共取 n+1个参数。第一个参数放在 data 区，其他参数放在 topic 区。</p>
<h5 id="其他理解事件的资源"><a href="#其他理解事件的资源" class="headerlink" title="其他理解事件的资源"></a>其他理解事件的资源</h5><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events">Javascript documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/debris/smart-exchange/blob/master/lib/contracts/SmartExchange.sol">Example usage of events</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/debris/smart-exchange/blob/master/lib/exchange_transactions.js">How to access them in js</a></li>
</ul>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>Solidity 支持某种程度上的多继承，它需要拷贝包括多态在内的代码。当一个合约多继承的时候，在链上只创建一份合约，其他</p>
<p>所有的函数调用都是虚调用。</p>
<p>继承系统非常像 Python 的元类继承。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 只有 private 不会被继承下来</span><br><span class="line">// Use `is` to derive from another contract. Derived</span><br><span class="line">// contracts can access all non-private members including</span><br><span class="line">// internal functions and state variables. These cannot be</span><br><span class="line">// accessed externally via `this`, though.</span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 没有函数体的函数。其合约是抽象的。完全没有函数体的合约只能当接口用。</span><br><span class="line">// These abstract contracts are only provided to make the</span><br><span class="line">// interface known to the compiler. Note the function</span><br><span class="line">// without body. If a contract does not implement all</span><br><span class="line">// functions it can only be used as an interface.</span><br><span class="line">contract Config &#123;</span><br><span class="line">    function lookup(uint id) public returns (address adr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract NameReg &#123;</span><br><span class="line">    function register(bytes32 name) public;</span><br><span class="line">    function unregister() public;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">// 多继承类似 C++ 的虚继承，不会有多份重复成员。</span><br><span class="line">// Multiple inheritance is possible. Note that `owned` is</span><br><span class="line">// also a base class of `mortal`, yet there is only a single</span><br><span class="line">// instance of `owned` (as for virtual inheritance in C++).</span><br><span class="line">contract named is owned, mortal &#123;</span><br><span class="line">    function named(bytes32 name) &#123;</span><br><span class="line">        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">        NameReg(config.lookup(1)).register(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Functions can be overridden by another function with the same name and</span><br><span class="line">    // the same number/types of inputs.  If the overriding function has different</span><br><span class="line">    // types of output parameters, that causes an error.</span><br><span class="line">    // Both local and message-based function calls take these overrides</span><br><span class="line">    // into account.</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) &#123;</span><br><span class="line">            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);</span><br><span class="line">            NameReg(config.lookup(1)).unregister();</span><br><span class="line">            // It is still possible to call a specific</span><br><span class="line">            // overridden function.</span><br><span class="line">            mortal.kill();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 这样调用显式构造函数就讨厌了</span><br><span class="line">// If a constructor takes an argument, it needs to be</span><br><span class="line">// provided in the header (or modifier-invocation-style at</span><br><span class="line">// the constructor of the derived contract (see below)).</span><br><span class="line">contract PriceFeed is owned, mortal, named(&quot;GoldFeed&quot;) &#123;</span><br><span class="line">   function updateInfo(uint newInfo) public &#123;</span><br><span class="line">      if (msg.sender == owner) info = newInfo;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   function get() public view returns(uint r) &#123; return info; &#125;</span><br><span class="line"></span><br><span class="line">   uint info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个菱形继承的讨厌问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract owned &#123;</span><br><span class="line">    function owned() public &#123; owner = msg.sender; &#125;</span><br><span class="line">    address owner;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract mortal is owned &#123;</span><br><span class="line">    function kill() public &#123;</span><br><span class="line">        if (msg.sender == owner) selfdestruct(owner);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Base1 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 1 */ super.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">contract Base2 is mortal &#123;</span><br><span class="line">    function kill() public &#123; /* do cleanup 2 */ super.kill(); &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Final is Base1, Base2 &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继承顺序大概是Final，Base2，Base1，mortal，owned。</p>
<p>调用顺序很复杂，需要用的时候还是看教程原文吧。</p>
<h5 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h5><p>构造器可以是<code>public</code>也可以是<code>internal</code>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract A &#123;</span><br><span class="line">    uint public a;</span><br><span class="line">    </span><br><span class="line">    // A 因为这个构造器变成了抽象类</span><br><span class="line">    function A(uint _a) internal &#123;</span><br><span class="line">        a = _a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 显式实例化</span><br><span class="line">contract B is A(1) &#123;</span><br><span class="line">    function B() public &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="基类构造器参数"><a href="#基类构造器参数" class="headerlink" title="基类构造器参数"></a>基类构造器参数</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Base &#123;</span><br><span class="line">    uint x;</span><br><span class="line">    function Base(uint _x) public &#123; x = _x; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 用两种方法调用基类构造器</span><br><span class="line">contract Derived is Base(7) &#123;</span><br><span class="line">    // 第二种方法赢了</span><br><span class="line">    function Derived(uint _y) Base(_y * _y) public &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="多重继承与线性化"><a href="#多重继承与线性化" class="headerlink" title="多重继承与线性化"></a>多重继承与线性化</h5><p>Solidity 学习 Python 的<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/C3_linearization">C3线性化</a>来解决<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">菱形问题</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// This will not compile</span><br><span class="line"></span><br><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract X &#123;&#125;</span><br><span class="line">contract A is X &#123;&#125;</span><br><span class="line">contract C is A, X &#123;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="抽象合约"><a href="#抽象合约" class="headerlink" title="抽象合约"></a>抽象合约</h5><p>两种情况下会产生抽象合约：</p>
<ul>
<li>有函数没有函数体</li>
<li>构造函数是<code>internal</code>的。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">contract Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract Cat is Feline &#123;</span><br><span class="line">    function utterance() public returns (bytes32) &#123; return &quot;miaow&quot;; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对比</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 无函数体函数</span><br><span class="line">function foo(address) external returns (address);</span><br><span class="line">// 函数变量</span><br><span class="line">function(address) external returns (address) foo;</span><br></pre></td></tr></table></figure>

<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>接口就是完全没有任何函数体的合约。和 cpp 里抽象类到接口的顺序是一致的。</p>
<p>而且还有以下很熟悉的限制：</p>
<ul>
<li>不能继承其他合约和接口</li>
<li>不能定义构造器</li>
<li>不能定义变量</li>
<li>不能定义结构体</li>
<li>不能定义枚举</li>
</ul>
<p>接口就是 ABI 的等价形式，两者之间应该可以无损互转。</p>
<p>接口有自己的关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">interface Token &#123;</span><br><span class="line">    function transfer(address recipient, uint amount) public;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用接口和继承其他合约一样，也就是都是 is 关键字，没有其他用法。</p>
<h4 id="库"><a href="#库" class="headerlink" title="库"></a>库</h4><p>库类似于合约。他们的目的是只在特定的地址上部署一次，然后通过<code>DELEGATECALL</code>调用。这意味着，库函数会在当前合约的上下文里被调用，反而不像外部调用(直接调用其他合约地址的实例方法一样)，产生 EVM call。函数里的 this 都会绑定到当前合约，类似 bind。</p>
<p>当然，代理调用是底层实现的，在使用上是看不出来的。库的<code>internal</code>函数，对于调用它的合约也是可见的，这些代码就好像是一个被 mixin 进合约里的基类合约一样。调用内部函数用的是<code>JUMP</code>而不是<code>DELEGATECALL</code>。</p>
<p>在这里，库是一个 util 式的用法。换言之，库里必须都是是<code>view</code>或者<code>pure</code>函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Set &#123;</span><br><span class="line">  // We define a new struct datatype that will be used to</span><br><span class="line">  // hold its data in the calling contract.</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  // Note that the first parameter is of type &quot;storage</span><br><span class="line">  // reference&quot; and thus only its storage address and not</span><br><span class="line">  // its contents is passed as part of the call.  This is a</span><br><span class="line">  // special feature of library functions.  It is idiomatic</span><br><span class="line">  // to call the first parameter `self`, if the function can</span><br><span class="line">  // be seen as a method of that object.</span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">          return false; // already there</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // not there</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // The library functions can be called without a</span><br><span class="line">        // specific instance of the library, since the</span><br><span class="line">        // &quot;instance&quot; will be the current contract.</span><br><span class="line">        require(Set.insert(knownValues, value));</span><br><span class="line">    &#125;</span><br><span class="line">    // In this contract, we can also directly access knownValues.flags, if we want.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>库也有限制：</p>
<ul>
<li>不能有状态变量</li>
<li>不能继承其他也不能被继承</li>
<li>不能接收以太币</li>
</ul>
<h4 id="Using-For"><a href="#Using-For" class="headerlink" title="Using For"></a>Using For</h4><p><code>using A for B;</code> 表明，把一个库的函数添加到一个指定类型上。这导致了这些库函数多了一个（隐式的）消息接受者对象作为第一个参数，这类似 Python 里的 self。</p>
<p><code>using A for *;</code>表明 A 的库函数被附着给任意类型。这可能也是为什么库不能有自己的 state 的原因吧。</p>
<p>没有用到 self 的一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library BigInt &#123;</span><br><span class="line"></span><br><span class="line">    // 这个结构体本来是没有成员函数的。</span><br><span class="line">    struct bigint &#123;</span><br><span class="line">        uint[] limbs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 全部都是 pure 函数</span><br><span class="line">    function fromUint(uint x) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](1);</span><br><span class="line">        r.limbs[0] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add(bigint _a, bigint _b) internal pure returns (bigint r) &#123;</span><br><span class="line">        r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));</span><br><span class="line">        uint carry = 0;</span><br><span class="line">        for (uint i = 0; i &lt; r.limbs.length; ++i) &#123;</span><br><span class="line">            uint a = limb(_a, i);</span><br><span class="line">            uint b = limb(_b, i);</span><br><span class="line">            r.limbs[i] = a + b + carry;</span><br><span class="line">            if (a + b &lt; a || (a + b == uint(-1) &amp;&amp; carry &gt; 0))</span><br><span class="line">                carry = 1;</span><br><span class="line">            else</span><br><span class="line">                carry = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        if (carry &gt; 0) &#123;</span><br><span class="line">            // too bad, we have to add a limb</span><br><span class="line">            uint[] memory newLimbs = new uint[](r.limbs.length + 1);</span><br><span class="line">            for (i = 0; i &lt; r.limbs.length; ++i)</span><br><span class="line">                newLimbs[i] = r.limbs[i];</span><br><span class="line">            newLimbs[i] = carry;</span><br><span class="line">            r.limbs = newLimbs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function limb(bigint _a, uint _limb) internal pure returns (uint) &#123;</span><br><span class="line">        return _limb &lt; _a.limbs.length ? _a.limbs[_limb] : 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function max(uint a, uint b) private pure returns (uint) &#123;</span><br><span class="line">        return a &gt; b ? a : b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using BigInt for BigInt.bigint;</span><br><span class="line"></span><br><span class="line">    function f() public pure &#123;</span><br><span class="line">        // 这里的三个变量类型都是 BigInt.bigint，但增加了库函数</span><br><span class="line">        var x = BigInt.fromUint(7);</span><br><span class="line">        var y = BigInt.fromUint(uint(-1));</span><br><span class="line">        var z = x.add(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>self 可以不是必须的，也可以有，另一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">// This is the same code as before, just without comments</span><br><span class="line">library Set &#123;</span><br><span class="line">  struct Data &#123; mapping(uint =&gt; bool) flags; &#125;</span><br><span class="line"></span><br><span class="line">  function insert(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (self.flags[value])</span><br><span class="line">        return false; // already there</span><br><span class="line">      self.flags[value] = true;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function remove(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      if (!self.flags[value])</span><br><span class="line">          return false; // not there</span><br><span class="line">      self.flags[value] = false;</span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function contains(Data storage self, uint value)</span><br><span class="line">      public</span><br><span class="line">      view</span><br><span class="line">      returns (bool)</span><br><span class="line">  &#123;</span><br><span class="line">      return self.flags[value];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Set for Set.Data; // this is the crucial change</span><br><span class="line">    // 用名字空间来访问内部类型</span><br><span class="line">    Set.Data knownValues;</span><br><span class="line"></span><br><span class="line">    function register(uint value) public &#123;</span><br><span class="line">        // Here, all variables of type Set.Data have</span><br><span class="line">        // corresponding member functions.</span><br><span class="line">        // The following function call is identical to</span><br><span class="line">        // `Set.insert(knownValues, value)`</span><br><span class="line">        // 从第二个参数传起</span><br><span class="line">        require(knownValues.insert(value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对基础类型的猴子补丁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.16;</span><br><span class="line"></span><br><span class="line">library Search &#123;</span><br><span class="line">    function indexOf(uint[] storage self, uint value)</span><br><span class="line">        public</span><br><span class="line">        view</span><br><span class="line">        returns (uint)</span><br><span class="line">    &#123;</span><br><span class="line">        for (uint i = 0; i &lt; self.length; i++)</span><br><span class="line">            if (self[i] == value) return i;</span><br><span class="line">        return uint(-1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract C &#123;</span><br><span class="line">    using Search for uint[];</span><br><span class="line">    uint[] data;</span><br><span class="line"></span><br><span class="line">    function append(uint value) public &#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function replace(uint _old, uint _new) public &#123;</span><br><span class="line">        // This performs the library function call</span><br><span class="line">        uint index = data.indexOf(_old);</span><br><span class="line">        if (index == uint(-1))</span><br><span class="line">            data.push(_new);</span><br><span class="line">        else</span><br><span class="line">            data[index] = _new;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Solidity-汇编"><a href="#Solidity-汇编" class="headerlink" title="Solidity 汇编"></a>Solidity 汇编</h3><p>Solidity 支持手写汇编模式。</p>
<h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><h4 id="有用的小技巧"><a href="#有用的小技巧" class="headerlink" title="有用的小技巧"></a>有用的小技巧</h4><ul>
<li>使用<code>delete</code>删除所有的数组元素。</li>
<li>调用内部 send 的方法是<code>address(contractVariable).send(amount)</code>。</li>
<li>用字面量的方法初始化结构体（而不是合约）：<code>x = MyStruct(&#123;a: 1, b: 2&#125;);</code>。</li>
</ul>
<h2 id="安全问题"><a href="#安全问题" class="headerlink" title="安全问题"></a>安全问题</h2><h3 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h3><p>所有的 send 本质上都可以包含代码执行（因为降级函数的存在），所有以下两个合约都是有漏洞的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        if (msg.sender.send(shares[msg.sender]))</span><br><span class="line">            shares[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.0;</span><br><span class="line"></span><br><span class="line">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        if (msg.sender.call.value(shares[msg.sender])())</span><br><span class="line">            shares[msg.sender] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>被调用方如果在自己的降级函数里面再调用这个合约的提取函数，那么它可以无限提取钱，直到 out-of-gas 异常发生为止。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract Fund &#123;</span><br><span class="line">    /// Mapping of ether shares of the contract.</span><br><span class="line">    mapping(address =&gt; uint) shares;</span><br><span class="line">    /// Withdraw your share.</span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        var share = shares[msg.sender];</span><br><span class="line">        shares[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(share);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有这个先扣款的钱包才能防别人反向递归调用自己。</p>
<h3 id="转以太币相关问题"><a href="#转以太币相关问题" class="headerlink" title="转以太币相关问题"></a>转以太币相关问题</h3><p>一个地址和账户没有办法抗拒别人向它转账，除非转账失败。不用消息调用也可以移动以太币的方法有两个：挖矿和自毁。</p>
<p><code>addr.call.value(x)()</code>等价于<code>addr.transfer(x)</code>，但它把剩余的 gas 全都提供给接受者，让它执行更贵的操作了。</p>
<p>一定要记得检查<code>send</code>的返回值。</p>
<h3 id="tx-origin"><a href="#tx-origin" class="headerlink" title="tx.origin"></a>tx.origin</h3><p>一个类似 CSRF 的相关问题：</p>
<p>一个检查 tx.origin 的钱包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">// THIS CONTRACT CONTAINS A BUG - DO NOT USE</span><br><span class="line">contract TxUserWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxUserWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function transferTo(address dest, uint amount) public &#123;</span><br><span class="line">        require(tx.origin == owner);</span><br><span class="line">        dest.transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>一个攻击者的钱包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">interface TxUserWallet &#123;</span><br><span class="line">    function transferTo(address dest, uint amount) public;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">contract TxAttackWallet &#123;</span><br><span class="line">    address owner;</span><br><span class="line"></span><br><span class="line">    function TxAttackWallet() public &#123;</span><br><span class="line">        owner = msg.sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function() public &#123;</span><br><span class="line">        TxUserWallet(msg.sender).transferTo(owner, msg.sender.balance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要被攻击者往攻击者钱包转账，攻击者钱包就会发一个新的事务，并借用 tx.origin 来盗取被攻击者的全部余额。每个地址的全部余额都是公开可查的。</p>
<h2 id="通用模式"><a href="#通用模式" class="headerlink" title="通用模式"></a>通用模式</h2><h3 id="从合约中取钱"><a href="#从合约中取钱" class="headerlink" title="从合约中取钱"></a>从合约中取钱</h3><p>比谁更有钱的合约：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract WithdrawalContract &#123;</span><br><span class="line">    address public richest;</span><br><span class="line">    uint public mostSent;</span><br><span class="line"></span><br><span class="line">    mapping (address =&gt; uint) pendingWithdrawals;</span><br><span class="line"></span><br><span class="line">    function WithdrawalContract() public payable &#123;</span><br><span class="line">        richest = msg.sender;</span><br><span class="line">        mostSent = msg.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function becomeRichest() public payable returns (bool) &#123;</span><br><span class="line">        if (msg.value &gt; mostSent) &#123;</span><br><span class="line">            pendingWithdrawals[richest] += msg.value;</span><br><span class="line">            richest = msg.sender;</span><br><span class="line">            mostSent = msg.value;</span><br><span class="line">            return true;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function withdraw() public &#123;</span><br><span class="line">        uint amount = pendingWithdrawals[msg.sender];</span><br><span class="line">        // Remember to zero the pending refund before</span><br><span class="line">        // sending to prevent re-entrancy attacks</span><br><span class="line">        pendingWithdrawals[msg.sender] = 0;</span><br><span class="line">        msg.sender.transfer(amount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用-modifier-来设定可访问性的问题"><a href="#用-modifier-来设定可访问性的问题" class="headerlink" title="用 modifier 来设定可访问性的问题"></a>用 modifier 来设定可访问性的问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract AccessRestriction &#123;</span><br><span class="line">    // These will be assigned at the construction</span><br><span class="line">    // phase, where `msg.sender` is the account</span><br><span class="line">    // creating this contract.</span><br><span class="line">    address public owner = msg.sender;</span><br><span class="line">    uint public creationTime = now;</span><br><span class="line"></span><br><span class="line">    // Modifiers can be used to change</span><br><span class="line">    // the body of a function.</span><br><span class="line">    // If this modifier is used, it will</span><br><span class="line">    // prepend a check that only passes</span><br><span class="line">    // if the function is called from</span><br><span class="line">    // a certain address.</span><br><span class="line">    modifier onlyBy(address _account)</span><br><span class="line">    &#123;</span><br><span class="line">        require(msg.sender == _account);</span><br><span class="line">        // Do not forget the &quot;_;&quot;! It will</span><br><span class="line">        // be replaced by the actual function</span><br><span class="line">        // body when the modifier is used.</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// Make `_newOwner` the new owner of this</span><br><span class="line">    /// contract.</span><br><span class="line">    function changeOwner(address _newOwner)</span><br><span class="line">        public</span><br><span class="line">        onlyBy(owner)</span><br><span class="line">    &#123;</span><br><span class="line">        owner = _newOwner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    modifier onlyAfter(uint _time) &#123;</span><br><span class="line">        require(now &gt;= _time);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /// Erase ownership information.</span><br><span class="line">    /// May only be called 6 weeks after</span><br><span class="line">    /// the contract has been created.</span><br><span class="line">    function disown()</span><br><span class="line">        public</span><br><span class="line">        onlyBy(owner)</span><br><span class="line">        onlyAfter(creationTime + 6 weeks)</span><br><span class="line">    &#123;</span><br><span class="line">        delete owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // This modifier requires a certain</span><br><span class="line">    // fee being associated with a function call.</span><br><span class="line">    // If the caller sent too much, he or she is</span><br><span class="line">    // refunded, but only after the function body.</span><br><span class="line">    // This was dangerous before Solidity version 0.4.0,</span><br><span class="line">    // where it was possible to skip the part after `_;`.</span><br><span class="line">    modifier costs(uint _amount) &#123;</span><br><span class="line">        require(msg.value &gt;= _amount);</span><br><span class="line">        _;</span><br><span class="line">        if (msg.value &gt; _amount)</span><br><span class="line">            msg.sender.send(msg.value - _amount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function forceOwnerChange(address _newOwner)</span><br><span class="line">        public</span><br><span class="line">        costs(200 ether)</span><br><span class="line">    &#123;</span><br><span class="line">        owner = _newOwner;</span><br><span class="line">        // just some example condition</span><br><span class="line">        if (uint(owner) &amp; 0 == 1)</span><br><span class="line">            // This did not refund for Solidity</span><br><span class="line">            // before version 0.4.0.</span><br><span class="line">            return;</span><br><span class="line">        // refund overpaid fees</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h3><p>这个例子有两个有意思的地方：</p>
<ul>
<li>modifier 可以叠加</li>
<li>可以由时间自动驱动状态机执行</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.11;</span><br><span class="line"></span><br><span class="line">contract StateMachine &#123;</span><br><span class="line">    enum Stages &#123;</span><br><span class="line">        AcceptingBlindedBids,</span><br><span class="line">        RevealBids,</span><br><span class="line">        AnotherStage,</span><br><span class="line">        AreWeDoneYet,</span><br><span class="line">        Finished</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // This is the current stage.</span><br><span class="line">    Stages public stage = Stages.AcceptingBlindedBids;</span><br><span class="line"></span><br><span class="line">    uint public creationTime = now;</span><br><span class="line"></span><br><span class="line">    modifier atStage(Stages _stage) &#123;</span><br><span class="line">        require(stage == _stage);</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function nextStage() internal &#123;</span><br><span class="line">        stage = Stages(uint(stage) + 1);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 必须放在最开始</span><br><span class="line">    // Perform timed transitions. Be sure to mention</span><br><span class="line">    // this modifier first, otherwise the guards</span><br><span class="line">    // will not take the new stage into account.</span><br><span class="line">    modifier timedTransitions() &#123;</span><br><span class="line">        if (stage == Stages.AcceptingBlindedBids &amp;&amp;</span><br><span class="line">                    now &gt;= creationTime + 10 days)</span><br><span class="line">            nextStage();</span><br><span class="line">        if (stage == Stages.RevealBids &amp;&amp;</span><br><span class="line">                now &gt;= creationTime + 12 days)</span><br><span class="line">            nextStage();</span><br><span class="line">        // The other stages transition by transaction</span><br><span class="line">        _;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Order of the modifiers matters here!</span><br><span class="line">    function bid()</span><br><span class="line">        public</span><br><span class="line">        payable</span><br><span class="line">        timedTransitions</span><br><span class="line">        atStage(Stages.AcceptingBlindedBids)</span><br><span class="line">    &#123;</span><br><span class="line">        // We will not implement that here</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function reveal()</span><br><span class="line">        public</span><br><span class="line">        timedTransitions</span><br><span class="line">        atStage(Stages.RevealBids)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // This modifier goes to the next stage</span><br><span class="line">    // after the function is done.</span><br><span class="line">    modifier transitionNext()</span><br><span class="line">    &#123;</span><br><span class="line">        _;</span><br><span class="line">        nextStage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function g()</span><br><span class="line">        public</span><br><span class="line">        timedTransitions</span><br><span class="line">        atStage(Stages.AnotherStage)</span><br><span class="line">        transitionNext</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function h()</span><br><span class="line">        public</span><br><span class="line">        timedTransitions</span><br><span class="line">        atStage(Stages.AreWeDoneYet)</span><br><span class="line">        transitionNext</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function i()</span><br><span class="line">        public</span><br><span class="line">        timedTransitions</span><br><span class="line">        atStage(Stages.Finished)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



                    </article>
                    


    <blockquote id="date-expire-notification" class="post-expired-notify">This article was last updated on <span id="date-expire-num"></span> days ago, and the information described in the article may have changed.</blockquote>
    <script>
    (function() {
        var dateUpdate = Date.parse("2019-09-09");
        var nowDate = new Date();
        var a = nowDate.getTime();
        var b = a - dateUpdate;
        var daysUpdateExpire = Math.floor(b/(24*3600*1000));
        if (daysUpdateExpire >= 120) {
            document.getElementById('date-expire-num').innerHTML = daysUpdateExpire;
        } else {
            document.getElementById('date-expire-notification').style.display = 'none';
        }
    })();
    </script>


<p class="post-footer-info mb-0 pt-0">Published at&nbsp;<time datetime="2018-03-08T08:25:00.000Z" itemprop="datePublished">2018-03-08</time>

    , Updated at&nbsp;<time datetime="2019-09-09T13:35:42.000Z" itemprop="dateModified">2019-09-09</time>

</p>
<p class="post-footer-info mb-0 pt-2">



<span class="post-tags-list mt-2">

<a class="post-tags-list-item" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/" rel="tag">#&nbsp;区块链</a>

<a class="post-tags-list-item" href="/tags/Ethereum/" rel="tag">#&nbsp;Ethereum</a>

</span>


</p>

                </div>
                <div class="post-nav px-2 bg-gray">
<ul class="pagination">
    <!-- Prev Nav -->
    
        <li class="page-item page-prev">
            <a href="/2018/03/08/UTXO-%E4%B8%8E-account-balance-%E6%A8%A1%E5%9E%8B/" rel="prev">
                <div class="page-item-title"><i class="icon icon-back" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">UTXO 与 account balance 模型</div>
            </a>
        </li>
    

    <!-- Next Nav -->
    
        <li class="page-item page-next">
            <a href="/2018/03/07/%E8%AF%AD%E4%B9%89%E7%89%88%E6%9C%AC%E5%8C%96%E9%97%AE%E9%A2%98/" rel="next">
                <div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">语义版本化问题</div>
            </a>
        </li>
    
</ul>
</div>

                
                    <!-- # Comment # -->
                    
                
            </div>
        </div>
    </div>
</div>

            <!-- ### Footer ### -->
            <footer class="text-center">
    <!-- footer copyright -->
    
        <p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span>
            <a class="footer-copyright-a" href="http://magicliang.github.io">守株阁</a>
        </p>

    <!-- footer custom text -->
    <p class="footer-text mb-0">
    
    </p>
    <!-- footer develop info -->
    <p class="footer-develop mb-0">
        
    <!-- Busuanzi User Views -->
    <span id="busuanzi_container_site_uv" hidden>
        <span></span>
        <span id="busuanzi_value_site_uv"></span>
        <span>Viewers</span>
        
            <span>|</span>
        
    </span>




        
        Powered by&nbsp;<!--
         --><a href="https://hexo.io" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Hexo</a><span class="footer-develop-divider"></span>Theme&nbsp;-&nbsp;<!--
         --><a href="https://github.com/SukkaW/hexo-theme-suka" target="_blank" class="footer-develop-a" rel="external noopener">Suka</a>
    </p>
</footer>


        <!-- ### Import File ### -->
        <!-- ### Footer JS Import ### -->

<script>

    
window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 50
};
document.getElementById('copyright-year').textContent = new Date().getFullYear();
console.log('\n %c Suka Theme (hexo-theme-suka) | © SukkaW | Verision 1.3.3 %c https://github.com/SukkaW/hexo-theme-suka \n', 'color: #fff; background: #444; padding:5px 0;', 'background: #bbb; padding:5px 0;');

</script>

<script src="/lib/vanilla-lazyload/lazyload.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" async></script>


<!-- Offset -->




<!-- Comment -->


<!-- ### Custom Footer ### -->

    </body>

</html>