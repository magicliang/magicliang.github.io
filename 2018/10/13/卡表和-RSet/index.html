<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>卡表和 RSet | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="卡表和 RSet 问题定义：为什么需要跨区域引用记录 JVM 垃圾收集器的核心工作之一是确定 live set——哪些对象仍然存活、不可回收。确定 live set 的标准做法是从 GC Roots（栈帧中的局部变量、静态字段等）出发，沿引用链遍历所有可达对象。 问题在于：当堆被划分为多个区域（代、Region）并且只回收其中一部分时，如何高效地找到从&quot;不回收区域&quot;指向&amp;quo">
<meta property="og:type" content="article">
<meta property="og:title" content="卡表和 RSet">
<meta property="og:url" content="https://magicliang.github.io/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="卡表和 RSet 问题定义：为什么需要跨区域引用记录 JVM 垃圾收集器的核心工作之一是确定 live set——哪些对象仍然存活、不可回收。确定 live set 的标准做法是从 GC Roots（栈帧中的局部变量、静态字段等）出发，沿引用链遍历所有可达对象。 问题在于：当堆被划分为多个区域（代、Region）并且只回收其中一部分时，如何高效地找到从&quot;不回收区域&quot;指向&amp;quo">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-3.jpg">
<meta property="article:published_time" content="2018-10-13T08:01:59.000Z">
<meta property="article:modified_time" content="2026-02-08T03:43:34.408Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-3.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "卡表和 RSet",
  "url": "https://magicliang.github.io/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/",
  "image": "https://magicliang.github.io/img/wall-paper-3.jpg",
  "datePublished": "2018-10-13T08:01:59.000Z",
  "dateModified": "2026-02-08T03:43:34.408Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '卡表和 RSet',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-3.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">卡表和 RSet</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">卡表和 RSet</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2018-10-13T08:01:59.000Z" title="Created 2018-10-13 16:01:59">2018-10-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-08T03:43:34.408Z" title="Updated 2026-02-08 11:43:34">2026-02-08</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>13mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>卡表和 RSet</h1>
<h2 id="问题定义：为什么需要跨区域引用记录">问题定义：为什么需要跨区域引用记录</h2>
<p>JVM 垃圾收集器的核心工作之一是确定 live set——哪些对象仍然存活、不可回收。确定 live set 的标准做法是从 GC Roots（栈帧中的局部变量、静态字段等）出发，沿引用链遍历所有可达对象。</p>
<p>问题在于：<strong>当堆被划分为多个区域（代、Region）并且只回收其中一部分时，如何高效地找到从&quot;不回收区域&quot;指向&quot;回收区域&quot;的引用？</strong></p>
<p>以 Young GC 为例：只回收新生代，但老年代中可能持有指向新生代对象的引用。如果不处理这些跨代引用，就会错误地回收仍被老年代引用的新生代对象。最朴素的做法是扫描整个老年代来找出这些引用——但老年代通常远大于新生代，这样做的代价过高，违背了分代收集&quot;只回收一部分堆&quot;的初衷。</p>
<p>卡表（Card Table）和 RSet（Remembered Set）正是为解决这个问题而设计的辅助数据结构。二者的关系并非互相替代，而是<strong>层次不同、协作互补</strong>：卡表是底层的脏标记机制，RSet 是建立在卡表之上的更高层索引结构。</p>
<h2 id="核心概念速览">核心概念速览</h2>
<p>在深入细节之前，先建立全局认知：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>卡表（Card Table）</th>
<th>RSet（Remembered Set）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>本质</strong></td>
<td>一个覆盖整个堆的 byte 数组，每个元素对应一块固定大小的内存区域（card）</td>
<td>每个 Region 持有的哈希表，记录&quot;谁引用了我&quot;</td>
</tr>
<tr>
<td><strong>记录方向</strong></td>
<td>points-out：标记&quot;这块区域里有对外引用&quot;</td>
<td>points-into：记录&quot;哪些外部 card 引用了本 Region&quot;</td>
</tr>
<tr>
<td><strong>粒度</strong></td>
<td>card 级别（HotSpot 中每个 card 覆盖 512 字节）</td>
<td>card 级别（RSet 的 Value 是 card index 的集合）</td>
</tr>
<tr>
<td><strong>数量</strong></td>
<td>全局一个（覆盖整个堆）</td>
<td>每个 Region 一个</td>
</tr>
<tr>
<td><strong>使用的收集器</strong></td>
<td>Serial、Parallel、CMS、G1、Shenandoah 均使用</td>
<td>G1 特有（ZGC/Shenandoah 采用了不同的方案）</td>
</tr>
<tr>
<td><strong>维护机制</strong></td>
<td>写屏障（write barrier）</td>
<td>写屏障 + Concurrent Refinement Threads</td>
</tr>
</tbody>
</table>
<h3 id="🔑-模式提炼：脏标记-写屏障">🔑 模式提炼：脏标记 + 写屏障</h3>
<p>卡表和 RSet 背后的通用模式是**“脏标记 + 写屏障”**——在数据变更时通过拦截写操作（写屏障）维护一个辅助标记结构（脏标记），使后续查询可以跳过未变更的区域。</p>
<p>这个模式的参数化公式：<code>ON_WRITE(target) → MARK_DIRTY(auxiliary_structure, locate(target))</code></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>辅助结构</th>
<th>写拦截点</th>
<th>查询收益</th>
</tr>
</thead>
<tbody>
<tr>
<td>卡表</td>
<td>byte 数组</td>
<td>引用赋值</td>
<td>Young GC 跳过 clean card</td>
</tr>
<tr>
<td>操作系统脏页</td>
<td>页表 dirty bit</td>
<td>页写入</td>
<td>换页时跳过 clean page</td>
</tr>
<tr>
<td>数据库 WAL</td>
<td>redo log</td>
<td>行修改</td>
<td>恢复时只重放脏页</td>
</tr>
<tr>
<td>CPU cache</td>
<td>cache line dirty bit</td>
<td>cache 写入</td>
<td>write-back 时跳过 clean line</td>
</tr>
</tbody>
</table>
<p>核心洞察：当听到&quot;只处理变更过的部分&quot;这类需求时，应该想到脏标记模式。其本质是<strong>用写操作时的少量额外开销，换取读/扫描操作时的大幅度缩减</strong>。</p>
<h2 id="卡表-card-table">卡表（Card Table）</h2>
<p><img src="%E5%8D%A1%E8%A1%A8.png" alt="卡表"></p>
<h3 id="数据结构">数据结构</h3>
<p>卡表在 HotSpot 中实现为一个 <code>byte</code> 数组，覆盖整个 Java 堆。堆被逻辑划分为固定大小的 card，每个 card 覆盖 512 字节的连续内存区域，对应卡表数组中的一个字节。</p>
<p>地址到卡表索引的映射关系：<code>card_index = (address - heap_base) &gt;&gt; 9</code>（右移 9 位即除以 512）。</p>
<p>当某个 card 对应的字节被标记为非零值（dirty）时，表示该 card 覆盖的内存区域中<strong>可能</strong>持有指向其他区域的引用。注意&quot;可能&quot;二字——卡表是一种保守的近似，存在 false positive（标记为 dirty 但实际上没有跨区域引用），但不存在 false negative（有跨区域引用但未标记）。</p>
<h3 id="写屏障维护">写屏障维护</h3>
<p>每当程序执行引用赋值操作（如 <code>obj.field = anotherObj</code>），JVM 通过写屏障（write barrier）将 <code>obj</code> 所在的 card 标记为 dirty。写屏障的伪代码：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">CARD_TABLE[address &gt;&gt; <span class="hljs-number">9</span>] <span class="hljs-operator">=</span> DIRTY<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>
<p>这段逻辑被注入到以下所有位置：</p>
<ul>
<li>解释器执行的字节码</li>
<li>JIT 编译器（C1/C2）生成的机器码</li>
<li>JNI 原生代码的引用更新路径</li>
</ul>
<p>写屏障的开销是每次引用赋值额外执行一条 store 指令——代价极低，但保证了卡表始终处于最新状态。</p>
<h3 id="在-young-gc-中的作用">在 Young GC 中的作用</h3>
<p>Young GC 只回收新生代，但需要找到所有从老年代指向新生代的引用。有了卡表，收集器的工作流程变为：</p>
<ol>
<li>从 GC Roots 出发，遍历新生代中的可达对象。</li>
<li>扫描卡表，找到所有 dirty card，<strong>只检查这些 card 覆盖的老年代区域</strong>，从中找出指向新生代的引用，将其也作为根。</li>
<li>跳过所有 clean card 对应的老年代区域。</li>
</ol>
<p>这样就避免了扫描整个老年代。在典型的应用中，老年代中只有少量 card 是 dirty 的（因为老年代对象的引用关系相对稳定），所以扫描量大幅减少。</p>
<h3 id="jvm-参数">JVM 参数</h3>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">-XX:<span class="hljs-attribute">ParGCCardsPerStrideChunk</span>=4096<br></code></pre></td></tr></table></figure>
<p>在多线程并行收集时，每个 GC 线程批量扫描多个 card，一批 card 称为一个 stride。默认一个 stride 含 256 个 card（即 512 × 256 = 128 KB）。<code>ParGCCardsPerStrideChunk</code> 控制每个 stride 的 card 数量。stride 太大会导致单次扫描时间过长，stride 太小会导致线程在 stride 之间切换的同步开销增加。</p>
<h3 id="卡表的局限">卡表的局限</h3>
<p>卡表解决了&quot;从老年代找到指向新生代的引用&quot;这一问题，但它有两个固有局限：</p>
<ol>
<li><strong>方向单一</strong>：卡表是 points-out 的——它标记&quot;这个 card 里有对外引用&quot;，但不记录&quot;引用指向谁&quot;。收集器仍需扫描 dirty card 内的所有对象来找到具体的跨代引用。</li>
<li><strong>只适用于连续分代</strong>：在传统的连续分代布局（新生代 + 老年代各占一块连续空间）中，卡表工作良好。但当堆被划分为大量不连续的 Region 时，仅靠卡表无法高效地回答&quot;哪些 Region 引用了这个 Region&quot;。</li>
</ol>
<p>这两个局限正是 G1 引入 RSet 的动机。</p>
<h2 id="rset-remembered-set">RSet（Remembered Set）</h2>
<p><img src="RSet.png" alt="RSet"></p>
<h3 id="g1-的堆布局变革">G1 的堆布局变革</h3>
<p>G1 将整个堆划分为大量等大的 Region（默认 1-32 MB），每个 Region 可以动态充当 Eden、Survivor、Old 或 Humongous 角色。这种布局带来了灵活性——G1 可以选择回收价值最高的 Region 子集（Collection Set, CSet），而非必须回收整个新生代或老年代。</p>
<p>但灵活性也带来了新问题：<strong>跨 Region 引用无处不在</strong>。不仅有 old→young 的跨代引用，还有 old→old、young→old 等各种方向的跨 Region 引用。仅靠全局卡表的 points-out 标记，无法高效地回答&quot;哪些外部 Region 引用了 CSet 中的某个 Region&quot;。</p>
<h3 id="数据结构">数据结构</h3>
<p>RSet 是每个 Region 持有的一个哈希表（概念上），记录&quot;谁引用了我&quot;：</p>
<ul>
<li><strong>Key</strong>：引用来源 Region 的起始地址</li>
<li><strong>Value</strong>：该来源 Region 中引用了本 Region 的 card index 集合</li>
</ul>
<p>因此，<strong>G1 的 RSet 建立在 Card Table 之上</strong>——RSet 并不替代卡表，而是在卡表的基础上增加了一层反向索引。卡表提供 card 级别的脏标记，RSet 利用 card index 记录引用的来源位置。</p>
<h3 id="points-out-与-points-into-的区别">points-out 与 points-into 的区别</h3>
<p>这是理解卡表与 RSet 关系的关键：</p>
<ul>
<li><strong>points-out（卡表）</strong>：站在引用发出方的视角——“我这个 card 里有对象引用了外部区域”。回答的问题是&quot;哪些 card 需要被扫描&quot;。</li>
<li><strong>points-into（RSet）</strong>：站在引用接收方的视角——“外部的哪些 card 引用了我这个 Region”。回答的问题是&quot;谁引用了我&quot;。</li>
</ul>
<p>points-into 的优势在于：当回收某个 Region 时，直接查看该 Region 的 RSet 就能知道所有外部引用的来源，无需扫描整个堆的卡表。</p>
<h3 id="rset-在不同-gc-阶段的作用">RSet 在不同 GC 阶段的作用</h3>
<p><strong>Young GC</strong>：只回收 young Region。每个 young Region 的 RSet 记录了所有 old→young 的引用来源。收集器将这些 RSet 中记录的 card 作为额外的根，与 GC Roots 一起作为遍历起点。这样就避免了扫描整个 old generation。</p>
<p><strong>Mixed GC</strong>：同时回收 young Region 和部分 old Region。对于被选入 CSet 的 old Region，其 RSet 记录了 old→old 的引用来源。young→old 的引用则通过扫描所有 young Region 获得（young Region 数量有限，扫描代价可接受）。</p>
<h3 id="rset-的维护">RSet 的维护</h3>
<p>RSet 的维护比卡表复杂，分为两个阶段：</p>
<ol>
<li>
<p><strong>写屏障（post-write barrier）</strong>：每次引用赋值时，写屏障将变更信息记录到一个线程本地的 dirty card queue（DCQ）中，而非直接更新 RSet。这样做是为了避免在 mutator 线程的热路径上执行复杂的哈希表操作。</p>
</li>
<li>
<p><strong>Concurrent Refinement Threads</strong>：后台的 refinement 线程异步消费 DCQ 中的条目，将其转化为 RSet 中的记录。这些线程与应用线程并发运行，将 RSet 维护的开销从 mutator 的关键路径上移除。</p>
</li>
</ol>
<h3 id="rset-的内存开销与优化">RSet 的内存开销与优化</h3>
<p>RSet 的空间开销不可忽视——在极端情况下，RSet 可能占用堆内存的 10%-20%。G1 通过三级粒度优化来控制 RSet 的大小：</p>
<ul>
<li><strong>Sparse</strong>：当引用来源较少时，使用哈希表直接记录 card index</li>
<li><strong>Fine</strong>：当引用来源增多时，使用位图（bitmap）记录 card index，每个来源 Region 一个位图</li>
<li><strong>Coarse</strong>：当引用来源过多时，退化为一个 Region 级别的位图，只记录&quot;哪些 Region 引用了我&quot;，丢失 card 级别的精度</li>
</ul>
<p>这种三级结构是一种<strong>渐进退化</strong>的设计——在精度和空间之间动态权衡。</p>
<h3 id="🔑-模式提炼：反向索引加速定向查询">🔑 模式提炼：反向索引加速定向查询</h3>
<p>RSet 的 points-into 设计本质上是一种反向索引——正向关系是&quot;A 引用 B&quot;，反向索引记录的是&quot;B 被 A 引用&quot;。</p>
<p>参数化公式：<code>REVERSE_INDEX[target] = { source₁, source₂, ... }</code></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>正向关系</th>
<th>反向索引</th>
<th>查询收益</th>
</tr>
</thead>
<tbody>
<tr>
<td>G1 RSet</td>
<td>对象 A 引用对象 B</td>
<td>Region B 的 RSet 记录 A 所在的 card</td>
<td>回收 B 时直接知道谁引用了 B</td>
</tr>
<tr>
<td>数据库外键索引</td>
<td>订单表引用用户表</td>
<td>用户表上的外键索引</td>
<td>删除用户时快速找到关联订单</td>
</tr>
<tr>
<td>搜索引擎倒排索引</td>
<td>文档包含关键词</td>
<td>关键词→文档列表</td>
<td>搜索关键词时直接定位文档</td>
</tr>
</tbody>
</table>
<p>核心洞察：当需要频繁回答&quot;谁引用/依赖了 X&quot;这类反向查询时，应该考虑建立反向索引。代价是写入时需要同时维护正向和反向两个方向的数据结构。</p>
<h2 id="卡表与-rset-的关系：不是替代-而是分层协作">卡表与 RSet 的关系：不是替代，而是分层协作</h2>
<p>理解二者关系的关键在于认识到它们处于不同的抽象层次：</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs gams">┌─────────────────────────────────────────┐<br>│           GC 收集器逻辑层                │<br>│  <span class="hljs-string">&quot;回收 Region X 时，谁引用了 X？&quot;</span>        │<br>│         ↓ 查询 RSet                      │<br>├─────────────────────────────────────────┤<br>│           RSet 索引层                    │<br>│  Region X 的 RSet:                       │<br>│    Region A → &#123; <span class="hljs-keyword">card</span> <span class="hljs-number">3</span>, <span class="hljs-keyword">card</span> <span class="hljs-number">7</span> &#125;         │<br>│    Region B → &#123; <span class="hljs-keyword">card</span> <span class="hljs-number">1</span> &#125;                 │<br>│         ↓ 基于 <span class="hljs-keyword">card</span> index 定位           │<br>├─────────────────────────────────────────┤<br>│           <span class="hljs-keyword">Card</span> <span class="hljs-keyword">Table</span> 标记层              │<br>│  全局 byte 数组，card index → dirty/clean│<br>│         ↓ 写屏障维护                     │<br>├─────────────────────────────────────────┤<br>│           堆内存层                       │<br>│  对象引用赋值触发写屏障                   │<br>└─────────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>卡表是基础设施</strong>：无论使用哪种收集器，卡表都存在。它提供了将堆内存划分为 card 并标记脏状态的基本能力。</li>
<li><strong>RSet 是上层索引</strong>：RSet 建立在卡表之上，利用 card index 作为记录粒度，提供了 points-into 的反向查询能力。</li>
<li><strong>在 G1 中二者共存</strong>：卡表负责脏标记和 card 级别的定位，RSet 负责反向索引和快速查询。</li>
</ul>
<p>在非 G1 的收集器（Serial、Parallel、CMS）中，只有卡表，没有 RSet。这些收集器的堆布局是连续的两代，只需要处理 old→young 一个方向的跨代引用，卡表足以胜任。</p>
<h2 id="历代演进：跨区域引用问题的解决思路">历代演进：跨区域引用问题的解决思路</h2>
<h3 id="第一阶段：serial-parallel-收集器-全局卡表">第一阶段：Serial / Parallel 收集器——全局卡表</h3>
<p>最早的分代收集器面对的问题是：Young GC 时如何避免扫描整个老年代。</p>
<p>解决方案是全局卡表 + 写屏障。老年代中每个 512 字节的 card 对应卡表中的一个字节，引用赋值时通过写屏障标记 dirty。Young GC 时只扫描 dirty card。</p>
<p>这个方案简单高效，适用于连续分代布局。</p>
<h3 id="第二阶段：cms-收集器-卡表-并发标记">第二阶段：CMS 收集器——卡表 + 并发标记</h3>
<p>CMS 引入了并发标记，但跨代引用的处理仍然依赖卡表。CMS 的特殊之处在于：并发标记阶段 mutator 仍在运行，可能修改引用关系，因此需要通过写屏障将变更记录到 mod-union table（本质上是卡表的变体）中，在 remark 阶段重新处理这些变更。</p>
<h3 id="第三阶段：g1-收集器-卡表-rset">第三阶段：G1 收集器——卡表 + RSet</h3>
<p>G1 将堆划分为 Region，跨区域引用从单一方向（old→young）扩展为多方向（old→young、old→old）。仅靠卡表的 points-out 标记无法高效支持&quot;回收任意 Region 子集&quot;的需求。</p>
<p>G1 的解决方案是在卡表之上增加 RSet 反向索引。每个 Region 的 RSet 记录了所有指向该 Region 的外部 card，使得回收任意 Region 时都能快速找到外部引用。代价是 RSet 的内存开销和 Concurrent Refinement Threads 的 CPU 开销。</p>
<h3 id="第四阶段：zgc-shenandoah-不同的路径">第四阶段：ZGC / Shenandoah——不同的路径</h3>
<p>ZGC 和 Shenandoah 选择了与 G1 不同的路径。ZGC 不使用传统的 RSet，而是通过染色指针（colored pointer）和读屏障（load barrier）来处理跨区域引用问题。Shenandoah 早期版本使用了类似 G1 的 RSet，但后续版本也在探索更轻量的方案。</p>
<p>这反映了 GC 设计中的一个根本权衡：<strong>是在写操作时付出代价（写屏障维护卡表/RSet），还是在读操作时付出代价（读屏障处理引用）</strong>。</p>
<table>
<thead>
<tr>
<th>收集器</th>
<th>跨区域引用方案</th>
<th>屏障类型</th>
<th>核心权衡</th>
</tr>
</thead>
<tbody>
<tr>
<td>Serial / Parallel</td>
<td>全局卡表</td>
<td>写屏障</td>
<td>简单，适用于连续分代</td>
</tr>
<tr>
<td>CMS</td>
<td>卡表 + mod-union table</td>
<td>写屏障</td>
<td>支持并发标记</td>
</tr>
<tr>
<td>G1</td>
<td>卡表 + RSet</td>
<td>写屏障 + post-write barrier</td>
<td>支持任意 Region 子集回收，内存开销较大</td>
</tr>
<tr>
<td>ZGC</td>
<td>染色指针</td>
<td>读屏障（load barrier）</td>
<td>无 RSet 内存开销，读路径有额外代价</td>
</tr>
</tbody>
</table>
<h2 id="结论">结论</h2>
<p>卡表和 RSet 的关系可以用一句话概括：<strong>卡表是&quot;哪里脏了&quot;的标记，RSet 是&quot;谁弄脏了我&quot;的索引；卡表是地基，RSet 是建筑</strong>。</p>
<ul>
<li>卡表解决的是&quot;Young GC 时如何避免扫描整个老年代&quot;的问题，通过 points-out 的脏标记 + 写屏障实现。</li>
<li>RSet 解决的是&quot;回收任意 Region 子集时如何快速找到所有外部引用&quot;的问题，通过 points-into 的反向索引实现，底层依赖卡表的 card 粒度。</li>
<li>二者不是互相替代的关系，而是分层协作：在 G1 中，卡表和 RSet 共同工作；在非 G1 收集器中，只有卡表。</li>
</ul>
<p>从演进角度看，跨区域引用问题的解决思路经历了从&quot;全局脏标记&quot;到&quot;分区反向索引&quot;再到&quot;染色指针&quot;的演进，反映了 GC 设计在写开销与读开销之间的持续权衡。</p>
<h2 id="模式速查表">模式速查表</h2>
<table>
<thead>
<tr>
<th>需求关键词</th>
<th>对应模式</th>
<th>方案</th>
<th>口诀</th>
</tr>
</thead>
<tbody>
<tr>
<td>只处理变更部分</td>
<td>脏标记 + 写屏障</td>
<td>写时标脏，读时跳过 clean</td>
<td>写时多做一点，读时少扫一片</td>
</tr>
<tr>
<td>谁引用/依赖了 X</td>
<td>反向索引</td>
<td>维护 target→sources 映射</td>
<td>正向写入，反向查询</td>
</tr>
<tr>
<td>精度与空间权衡</td>
<td>渐进退化</td>
<td>多级粒度，按需降级</td>
<td>少时精确，多时粗放</td>
</tr>
</tbody>
</table>
<h2 id="参考资料">参考资料</h2>
<ul>
<li>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000004682407">《jvm的card table数据结构》</a></p>
</li>
<li>
<p><a target="_blank" rel="noopener" href="https://tech.meituan.com/g1.html">《Java Hotspot G1 GC的一些关键技术》</a></p>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/">https://magicliang.github.io/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-3.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-25.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-36.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a><a class="pagination-related" href="/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" title="重述双亲委派模型"><img class="cover" src="/img/wall-paper-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-05</div><div class="info-item-2">重述双亲委派模型</div></div><div class="info-2"><div class="info-item-1">何时加载类 根据 Java 语言规范（JLS §12.4），类或接口在首次主动使用时才会被初始化。主动使用包括以下情况：  遇到 new、getstatic、putstatic、invokestatic 等字节码指令时。这些指令分别对应创建对象实例、读取或设置静态字段、调用静态方法。 对类进行反射调用时，如 Class.forName() 或 Method.invoke()。 初始化某个类的子类时，父类会先被初始化（但父类接口不会）。 虚拟机启动时会先加载设置的主类，即包含 main() 方法的类。 使用 java.lang.invoke 包的动态语言支持特性时，如 MethodHandle 调用。  需要注意的是，被动引用（如通过数组引用、常量引用、访问子类的静态字段等）不会触发类初始化。 从 Java 到 cpp 源码分析 双亲委派模型的工作流程 双亲委派模型的核心逻辑在 java.lang.ClassLoader.loadClass(String name, boolean resolve) 方法中： 123456789101112131415161718192021222...</div></div></div></a><a class="pagination-related" href="/2020/03/08/JMX-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9/" title="JMX 深度历险"><img class="cover" src="/img/wall-paper-144.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-08</div><div class="info-item-2">JMX 深度历险</div></div><div class="info-2"><div class="info-item-1">JMX 常见指标 JVM 指标 系统指标    System 相关指标 描述     system.load.average 系统load，如果是docker，此指标收集的物理机的load   cpu.system.load.percent 系统所有进程占用cpu的百分比   cpu.jvm.load.percent jvm占用cpu的百分比   system.process.used.phyical.memory 系统使用的物理内存   system.process.used.swap.size 系统使用的swap内存    JVM 内存指标    JVM相关指标 描述     jvm.gc.count GC的次数   jvm.gc.time GC的时间，单位毫秒   jvm.younggc.count 年轻代GC的次数 ，包括的GC算法（Copy，ParNew，PS Scavenge，G1 Young Generation）   jvm.younggc.time 年轻代GC的时间，单位毫秒   jvm.fullgc.count 年老代GC的次数，包括的GC算法   jvm.f...</div></div></div></a><a class="pagination-related" href="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" title="现代垃圾收集器"><img class="cover" src="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-27</div><div class="info-item-2">现代垃圾收集器</div></div><div class="info-2"><div class="info-item-1">所有的垃圾收集器，都基于弱分代假设。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优。 有几个常用原则：  减少临时对象，尽量复用内存。 使用对象池。 主动提前释放对象。 主动 gc。 好的代码比 tuning 更重要。 选 gc 算法比 tuning 参数重要，tuning 参数是最后一步。  其他情况，可以通过 tuning garbage collector 来解决。 操作系统的影响  SWAP 可能会显著增加 GC 时间，因为被换出的堆还要被换入。  美团的实践 参考：  《从实际案例聊聊Java应用的GC优化》 《Java中9种常见的CMS GC问题分析与解决》   Minor GC Major GC Full GC  垃圾收集器分类    可以看到一个现象：在大部分时候，g1 比 CMS 快，但极端的百分位里，CMS 比 g1 快。 出处见这里。 常用工具 命令行终端   标准终端类：jps、jinfo、jstat、jstack、jmap 功能整合类：jcm...</div></div></div></a><a class="pagination-related" href="/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/" title="如何实现正确的微基准测试"><img class="cover" src="/img/wall-paper-135.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-19</div><div class="info-item-2">如何实现正确的微基准测试</div></div><div class="info-2"><div class="info-item-1">原问题 FROM：《How do I write a correct micro-benchmark in Java?》 Tips about writing micro benchmarks from the creators of Java HotSpot: Rule 0: Read a reputable paper on JVMs and micro-benchmarking. A good one is Brian Goetz, 2005. Do not expect too much from micro-benchmarks; they measure only a limited range of JVM performance characteristics. Rule 1: Always include a warmup phase which runs your test kernel all the way through, enough to trigger all initializations and compilations before timi...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">卡表和 RSet</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%AE%9A%E4%B9%89%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%B7%A8%E5%8C%BA%E5%9F%9F%E5%BC%95%E7%94%A8%E8%AE%B0%E5%BD%95"><span class="toc-number">1.1.</span> <span class="toc-text">问题定义：为什么需要跨区域引用记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E9%80%9F%E8%A7%88"><span class="toc-number">1.2.</span> <span class="toc-text">核心概念速览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%91-%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E8%84%8F%E6%A0%87%E8%AE%B0-%E5%86%99%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">🔑 模式提炼：脏标记 + 写屏障</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%A1%E8%A1%A8-card-table"><span class="toc-number">1.3.</span> <span class="toc-text">卡表（Card Table）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%B1%8F%E9%9A%9C%E7%BB%B4%E6%8A%A4"><span class="toc-number">1.3.2.</span> <span class="toc-text">写屏障维护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8-young-gc-%E4%B8%AD%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">在 Young GC 中的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm-%E5%8F%82%E6%95%B0"><span class="toc-number">1.3.4.</span> <span class="toc-text">JVM 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E8%A1%A8%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-number">1.3.5.</span> <span class="toc-text">卡表的局限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rset-remembered-set"><span class="toc-number">1.4.</span> <span class="toc-text">RSet（Remembered Set）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#g1-%E7%9A%84%E5%A0%86%E5%B8%83%E5%B1%80%E5%8F%98%E9%9D%A9"><span class="toc-number">1.4.1.</span> <span class="toc-text">G1 的堆布局变革</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#points-out-%E4%B8%8E-points-into-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.4.3.</span> <span class="toc-text">points-out 与 points-into 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rset-%E5%9C%A8%E4%B8%8D%E5%90%8C-gc-%E9%98%B6%E6%AE%B5%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.4.4.</span> <span class="toc-text">RSet 在不同 GC 阶段的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rset-%E7%9A%84%E7%BB%B4%E6%8A%A4"><span class="toc-number">1.4.5.</span> <span class="toc-text">RSet 的维护</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rset-%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%80%E9%94%80%E4%B8%8E%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.6.</span> <span class="toc-text">RSet 的内存开销与优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%91-%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E5%8F%8D%E5%90%91%E7%B4%A2%E5%BC%95%E5%8A%A0%E9%80%9F%E5%AE%9A%E5%90%91%E6%9F%A5%E8%AF%A2"><span class="toc-number">1.4.7.</span> <span class="toc-text">🔑 模式提炼：反向索引加速定向查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%A1%E8%A1%A8%E4%B8%8E-rset-%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A%E4%B8%8D%E6%98%AF%E6%9B%BF%E4%BB%A3-%E8%80%8C%E6%98%AF%E5%88%86%E5%B1%82%E5%8D%8F%E4%BD%9C"><span class="toc-number">1.5.</span> <span class="toc-text">卡表与 RSet 的关系：不是替代，而是分层协作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%86%E4%BB%A3%E6%BC%94%E8%BF%9B%EF%BC%9A%E8%B7%A8%E5%8C%BA%E5%9F%9F%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%80%9D%E8%B7%AF"><span class="toc-number">1.6.</span> <span class="toc-text">历代演进：跨区域引用问题的解决思路</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9Aserial-parallel-%E6%94%B6%E9%9B%86%E5%99%A8-%E5%85%A8%E5%B1%80%E5%8D%A1%E8%A1%A8"><span class="toc-number">1.6.1.</span> <span class="toc-text">第一阶段：Serial &#x2F; Parallel 收集器——全局卡表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9Acms-%E6%94%B6%E9%9B%86%E5%99%A8-%E5%8D%A1%E8%A1%A8-%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0"><span class="toc-number">1.6.2.</span> <span class="toc-text">第二阶段：CMS 收集器——卡表 + 并发标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9Ag1-%E6%94%B6%E9%9B%86%E5%99%A8-%E5%8D%A1%E8%A1%A8-rset"><span class="toc-number">1.6.3.</span> <span class="toc-text">第三阶段：G1 收集器——卡表 + RSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%98%B6%E6%AE%B5%EF%BC%9Azgc-shenandoah-%E4%B8%8D%E5%90%8C%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.4.</span> <span class="toc-text">第四阶段：ZGC &#x2F; Shenandoah——不同的路径</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">1.7.</span> <span class="toc-text">结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="toc-number">1.8.</span> <span class="toc-text">模式速查表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.9.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>