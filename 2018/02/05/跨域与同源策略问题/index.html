<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>跨域与同源策略问题 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="什么是同源策略 同源策略(SOP same origin policy)指的是，两个网页的协议、域名和端口都相同。 但 Windows RT IE 是例外的，对它而言，端口号并不是同源策略的组成部分之一。 同源策略的变化 同源策略最初的要求是，同源的网页才能打开同源网页下的 cookie。cookie 实际上是一种对浏览器用户总是可见，但对 javascript 代码不总可见的内容。 同源策略大多">
<meta property="og:type" content="article">
<meta property="og:title" content="跨域与同源策略问题">
<meta property="og:url" content="https://magicliang.github.io/2018/02/05/%E8%B7%A8%E5%9F%9F%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="什么是同源策略 同源策略(SOP same origin policy)指的是，两个网页的协议、域名和端口都相同。 但 Windows RT IE 是例外的，对它而言，端口号并不是同源策略的组成部分之一。 同源策略的变化 同源策略最初的要求是，同源的网页才能打开同源网页下的 cookie。cookie 实际上是一种对浏览器用户总是可见，但对 javascript 代码不总可见的内容。 同源策略大多">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-8.jpg">
<meta property="article:published_time" content="2018-02-05T07:23:08.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:31.905Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JavaScript">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-8.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "跨域与同源策略问题",
  "url": "https://magicliang.github.io/2018/02/05/%E8%B7%A8%E5%9F%9F%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98/",
  "image": "https://magicliang.github.io/img/wall-paper-8.jpg",
  "datePublished": "2018-02-05T07:23:08.000Z",
  "dateModified": "2025-10-22T08:01:31.905Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2018/02/05/%E8%B7%A8%E5%9F%9F%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '跨域与同源策略问题',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-8.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">跨域与同源策略问题</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">跨域与同源策略问题</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2018-02-05T07:23:08.000Z" title="Created 2018-02-05 15:23:08">2018-02-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:31.905Z" title="Updated 2025-10-22 16:01:31">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">13.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>46mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>什么是同源策略</h1>
<p>同源策略(SOP same origin policy)指的是，两个网页的协议、域名和端口都相同。 但 Windows RT IE 是例外的，对它而言，端口号并不是同源策略的组成部分之一。</p>
<h1>同源策略的变化</h1>
<p>同源策略最初的要求是，同源的网页才能打开同源网页下的 cookie。cookie 实际上是一种对浏览器用户总是可见，但对 javascript 代码不总可见的内容。</p>
<h2 id="同源策略大多数关于读-而且同源总能用沙箱解释">同源策略大多数关于读，而且同源总能用沙箱解释</h2>
<p>但现代的同源策略起了轻微的变化：</p>
<p>为了网络安全，浏览器为每一个“源”（Origin）都创建了一个独立的、互不干扰的沙箱环境。您可以把每个沙箱想象成一个独立的“安全屋”，里面存放着属于这个源的所有资源：它的 DOM 结构、数据存储（localStorage 等）以及运行的脚本。</p>
<p>同源策略就是这个沙箱模型的核心规则：<strong>一个沙箱里的脚本，不能随意访问另一个沙箱里的任何资源</strong>。</p>
<h2 id="限制存储和当前页面的资源">限制存储和当前页面的资源</h2>
<h3 id="dom-访问限制">DOM 访问限制</h3>
<p>当一个页面（如<code>a.com</code>）通过<code>&lt;iframe&gt;</code>嵌入另一个不同源的页面（如 <code>b.com</code>）时，浏览器实际上是创建了两个独立的沙箱。</p>
<ul>
<li><code>a.com</code>的 DOM 存在于它自己的沙箱中。</li>
<li><code>&lt;iframe&gt;</code>中<code>b.com</code>的 DOM 则存在于另一个完全独立的沙箱中。</li>
</ul>
<p>沙箱坚固的“墙壁”阻止了<code>a.com</code>的脚本伸入<code>b.com</code>的沙箱去操作其 DOM，反之亦然。这就防止了恶意页面通过内嵌来窃取另一个页面上的敏感信息。</p>
<ul>
<li>例外情况：过去，如果两个沙箱的源主域相同（如<code>a.example.com</code>和 <code>b.example.com</code>），可以通过将双方的<code>document.domain</code>都设置为父域 <code>example.com</code>，在沙箱之间“开一扇小门”。</li>
</ul>
<h3 id="数据存储限制">数据存储限制</h3>
<p>客户端数据同样被严格地存放在各自的沙箱里。</p>
<ul>
<li><code>localStorage</code>和<code>IndexedDB</code> 这两者是沙箱的“标准住户”，被严格限制在创建它们的源所对应的沙箱内部，外部无法访问。</li>
<li><code>Cookie</code> <code>Cookie</code>的规则比较特殊，它不完全受沙箱的约束，有自己的一套“通行证”规则。
<ul>
<li><code>Cookies</code>使用不同的源定义方式。一个页面可以为本域和任何父域设置 <code>Cookie</code>，只要是父域不是公共后缀（public suffix）即可。设置cookie时，你可以使用 <code>Domain</code>，<code>Path</code>，<code>Secure</code>，和<code>Http-Only</code>标记来限定其访问性。</li>
<li>公共后缀 (Public Suffix)：指那些不代表独立实体的顶级域名，浏览器不允许为这些域名设置站点范围的 Cookie。例如：
<ul>
<li><code>.com</code>、<code>.org</code>、<code>.net</code></li>
<li><code>.co.uk</code>(英国)</li>
<li><code>.gov.au</code>(澳大利亚政府)</li>
<li><code>.com.cn</code>(中国)</li>
</ul>
</li>
<li>父域设置示例：通过在<code>sub.example.com</code>页面设置<code>Domain=.example.com</code>，可以让<code>www.example.com</code>也能访问到这个<code>Cookie</code>。</li>
</ul>
</li>
</ul>
<h2 id="沙箱如何限制网络读写">沙箱如何限制网络读写</h2>
<p>沙箱不仅隔离本地资源，也管理着对外的网络通信。</p>
<h3 id="跨源写操作-cross-origin-writes">跨源写操作 (Cross-origin Writes)</h3>
<ul>
<li>
<p>通常被允许，但有条件：沙箱对“写”操作的限制比“读”要宽松。它允许那些在 AJAX 技术出现前就已经存在的、会改变服务器状态的传统跨域请求，例如：</p>
<ul>
<li><code>&lt;a&gt;</code>标签的链接跳转</li>
<li>页面重定向</li>
<li>简单的<code>&lt;form&gt;</code>表单提交</li>
</ul>
</li>
<li>
<p>预检请求 (Preflight Request)：然而，这种允许并非无条件的。对于一些现代的、可能带有副作用的 HTTP 请求（例如使用 PUT、DELETE 方法，或者发送<code>Content-Type</code>为<code>application/json</code>的 POST 请求），浏览器会采取更谨慎的策略。它会首先发送一个轻量的“预检”请求（使用 OPTIONS 方法）到目标服务器，像是在正式写入数据前，先问一下服务器：“我能用这种方式和你通信吗？”。只有在服务器通过预检响应明确表示许可后，真正的请求才会被沙箱放行。</p>
</li>
</ul>
<h3 id="跨源读操作-cross-origin-reads">跨源读操作 (Cross-origin Reads)</h3>
<ul>
<li>通常不被允许：这是沙箱最核心的防护机制之一，因为“读”操作可能导致敏感数据泄露。</li>
<li>工作原理：当沙箱内的脚本（如<code>XMLHttpRequest</code>或<code>fetch</code>）试图读取一个来自不同源的响应时，请求本身可以被发送出去，服务器也会返回数据。但当响应数据回到浏览器时，沙箱的“守卫”会检查响应的来源。如果发现它来自一个不同的源，守卫就会将数据拦截下来，阻止沙箱内的脚本读取它，这也就是常说的“能发 request，不能收 response”。</li>
</ul>
<h3 id="跨源资源嵌入-cross-origin-embedding">跨源资源嵌入 (Cross-origin Embedding)</h3>
<ul>
<li>通常被允许：沙箱允许页面通过标签嵌入来自不同源的资源。这恐怕也是现阶段很多 CSRF 攻击的根源，因为<code>&lt;img&gt;</code>的 src 可以是一个会产生副作用的 GET 请求 URL，这个请求会悄无声息地发生。</li>
<li>允许嵌入的标签示例
<ul>
<li><code>&lt;script src=&quot;...&quot;&gt;&lt;/script&gt;</code></li>
<li><code>&lt;link href=&quot;...&quot;&gt;&lt;/link&gt;</code></li>
<li><code>&lt;img src=&quot;...&quot;&gt;</code></li>
<li><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></li>
<li><code>&lt;video&gt;</code>和<code>&lt;audio&gt;</code></li>
</ul>
</li>
</ul>
<h2 id="不受同源限制的例外">不受同源限制的例外</h2>
<h3 id="websocket">WebSocket</h3>
<p>WebSocket是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>从浏览器的角度看，它确实允许 JavaScript 代码向任何来源（any origin）发起 WebSocket 连接请求，这一点和图片、CSS、JS 脚本等资源的加载行为类似。但是，这并不意味着连接是无条件的。安全性检查的责任转移到了服务器端。</p>
<h4 id="核心问题：为什么-websocket-不需要-sop-保护？">核心问题：为什么 WebSocket “不需要” SOP 保护？</h4>
<p>WebSocket 并没有被豁免，而是采用了与 HTTP 请求（AJAX/Fetch）不同的安全模型。</p>
<h5 id="http-请求-ajax-fetch-的安全模型：请求后验证">HTTP 请求 (AJAX/Fetch) 的安全模型：请求后验证</h5>
<ul>
<li>模型：浏览器先发送请求，然后在收到服务器的响应后，检查响应头里有没有 <code>Access-Control-Allow-Origin</code> (CORS) 头部。</li>
<li>谁负责：浏览器是安全检查的主要执行者。它看到脚本想读取跨域响应，就会主动进行拦截，除非服务器明确通过 CORS 头部表示“许可”。</li>
<li>比喻：你派人（请求）去隔壁公司拿一份文件（数据）。你的人到达后，隔壁公司把文件给了他。但在他回来把文件交给你（脚本）之前，你公司大楼的保安（浏览器）会检查他有没有对方公司开的“文件交接许可单”（CORS 头部）。没有许可单，保安就把文件没收了，你拿不到。</li>
</ul>
<h5 id="websocket-的安全模型：连接前验证">WebSocket 的安全模型：连接前验证</h5>
<ul>
<li>模型：WebSocket 连接不是一个简单的 HTTP 请求，它始于一个“HTTP - 升级（Upgrade）”请求。在这个初始的握手请求中，浏览器会自动添加一个 Origin 头部，告诉服务器这个连接请求来自哪个源（例如 Origin: <a target="_blank" rel="noopener" href="https://evil.com">https://evil.com</a>）。</li>
<li>谁负责：服务器是安全检查的主要执行者。服务器收到握手请求后，必须检查这个 Origin 头部。如果这个来源是它所允许的，它就同意升级请求，建立连接。如果是不允许的来源，服务器就应该直接拒绝这个握手请求，连接从一开始就无法建立。</li>
<li>比喻：你想和隔壁公司建立一条专线电话（WebSocket 连接）。你让你的电话总机（浏览器）去呼叫对方。总机会告诉对方：“我是 A 公司的总机（Origin 头部），想和你们建立专线通话。” 隔壁公司的总机（服务器）会看这个来电显示，如果 A 公司在他们的白名单上，就接通电话，专线建立。如果不在，就直接挂断，通话根本不会开始。</li>
</ul>
<h4 id="总结">总结</h4>
<p>所以，WebSocket 并不是没有安全策略，而是它的安全策略从“浏览器在事后检查 CORS 头部”转移到了“服务器在连接建立前检查 Origin 头部”。</p>
<p>AJAX/Fetch 的保护是浏览器端的，防止脚本读取未经授权的跨域数据。<br>
WebSocket 的保护是服务器端的，防止未经授权的页面与自己建立持久的双向通信。<br>
一旦 WebSocket 连接成功建立，后续在这条“管道”里传输的数据就不再受同源策略的逐条审查了，因为在建立连接的那一刻，双方已经确认了彼此的身份并同意了通信。</p>
<h2 id="preflight-问题">preflight 问题</h2>
<h3 id="为什么">为什么</h3>
<p>想象一下，你要给一位重要客户（服务器）打一通非常规的、可能会占用他很长时间的电话（比如一个 PUT 或 DELETE 请求，这可能会修改或删除数据）。</p>
<p>如果你直接打过去就开始说正事，可能会打断客户正在进行的重要会议，造成不好的后果。</p>
<p>一个更礼貌和安全的方式是：</p>
<ol>
<li>预先发条短信（Preflight Request）：“王总您好，我准备和您电话沟通一下关于删除项目A数据的操作，您现在方便吗？这个电话可能会涉及数据修改。”</li>
<li>客户回复短信（Preflight Response）：
<ul>
<li>同意：“可以，你打过来吧。我允许你谈论这个话题。”</li>
<li>拒绝：“我现在不方便，或者我们公司规定不允许电话里谈论删除数据的事。”</li>
</ul>
</li>
<li>发起正式通话（Actual Request）：只有在收到同意的短信后，你才会拨打那通正式的电话。如果被拒绝，你就不会再打这个电话了。</li>
</ol>
<p>这里的**“预先发短信确认”**这个动作，就是 Preflight（预检）。</p>
<h3 id="非简单跨域请求">非简单跨域请求</h3>
<p>Preflight（预检请求） 是浏览器在发送**“非简单跨域请求”之前，自动发起的一个HTTP OPTIONS 请求**。这个请求的目的就是去问服务器，即将要发送的这个真实请求是否安全、是否被服务器所允许。</p>
<p>它就像是浏览器和服务器之间的一次**“安全握手”或“投石问路”**。</p>
<h3 id="触发条件：为什么会发生-preflight？">触发条件：为什么会发生 Preflight？</h3>
<ul>
<li>请求方法不是 GET, HEAD, POST 之一。比如使用了 PUT, DELETE, PATCH 等方法。</li>
<li>POST 请求的<code>Content-Type</code>不是<code>application/x-www-form-urlencoded</code>，<code>multipart/form-data</code>或 <code>text/plain</code>。比如，现在最常见的前后端交互方式是发送<code>application/json</code>格式的数据，这就会触发  Preflight。</li>
<li>请求中包含了自定义的 Header。比如，前端为了身份验证，在请求头里加了一个<code>Authorization</code>: <code>Bearer &lt;token&gt;</code>，这也会触发 Preflight。</li>
</ul>
<p>核心原因：这些“非简单请求”都具备一个特点——它们是在 AJAX 出现后才被广泛用于网页的技术，可能会对服务器数据进行修改（比如 PUT 和 DELETE），或者携带了传统 HTML 表单无法发送的复杂信息（比如 JSON 数据和自定义 Header）。浏览器为了保护服务器，必须先问一声：“服务器老兄，你认识这些新玩法吗？你允许我这么做吗？”</p>
<h3 id="工作流程">工作流程</h3>
<ul>
<li>
<p>浏览器（发起 Preflight）：自动发送一个 OPTIONS 请求到目标 URL。这个请求包含几个关键的 Header：</p>
<ul>
<li><code>Access-Control-Request-Method</code>: 告诉服务器，我接下来想用什么方法（比如 PUT）。</li>
<li><code>Access-Control-Request-Headers</code>: 告诉服务器，我接下来想带哪些自定义请求头（比如 Authorization）。</li>
<li><code>Origin</code>: 告诉服务器，这个请求来自哪个源（比如<code>https://my-app.com</code>）。</li>
</ul>
</li>
<li>
<p>服务器（响应 Preflight）：服务器收到这个 OPTIONS 请求后，检查这些信息，并根据自己的跨域策略（CORS 配置）来决定是否同意。</p>
<ul>
<li>如果同意，服务器会返回一个 200 或 204 的成功响应，并且响应头里必须包含以下信息来“授权”：
<ul>
<li><code>Access-Control-Allow-Origin</code>: “我允许<code>https://my-app.com</code>这个源访问我。”</li>
<li><code>Access-Control-Allow-Methods</code>: “我允许的请求方法包括 GET, POST, PUT 等。”</li>
<li><code>Access-Control-Allow-Headers</code>: “我允许你携带<code>Content-Type</code>和<code>Authorization</code> 这些请求头。”</li>
<li><code>Access-Control-Max-Age</code> (可选): “在接下来的N秒内，同样的请求不用再发 Preflight 了，我直接给你授权。”（用于性能优化）</li>
</ul>
</li>
<li>如果不同意，服务器就不会返回上述这些 Header。</li>
</ul>
</li>
<li>
<p>浏览器（决策）：浏览器收到 Preflight 的响应后：</p>
<ul>
<li>如果响应中的授权信息与即将发送的真实请求匹配，浏览器就会发送真实的 PUT 请求。</li>
<li>如果不匹配或者服务器压根没返回这些授权 Header，浏览器就会拦截真实的 PUT 请求，并在控制台抛出我们熟悉的 CORS 错误。</li>
</ul>
</li>
</ul>
<p>这里面有很容易被混淆的流程是，请求的时候是<code>Access-Control-Request-Method</code>，响应的是时候是<code>Access-Control-Allow-Methods</code>。</p>
<h3 id="问题排查：为什么我的请求失败了？">问题排查：为什么我的请求失败了？</h3>
<p>这是开发者最常遇到 Preflight 的场景。当一个跨域请求失败时，我们打开浏览器控制台的“网络(Network)”面板，会看到：</p>
<ol>
<li>一个 OPTIONS 请求的状态是 200 OK，但后面的真实请求（如 PUT）是红色的 (failed)。</li>
<li>或者 OPTIONS 请求本身就是红色的 (failed)。</li>
</ol>
<p>这通常意味着服务器端的 CORS 配置出了问题。我们在排查时，就是在检查服务器为什么没有正确地响应 Preflight 请求。比如：</p>
<ul>
<li>是不是<code>Access-Control-Allow-Origin</code>没包含我们的前端地址？</li>
<li>是不是<code>Access-Control-Allow-Methods</code>忘了加 PUT？</li>
<li>是不是<code>Access-Control-Allow-Headers</code>忘了加我们自定义的那个 Header？</li>
</ul>
<h3 id="简单请求">简单请求</h3>
<p>所有的 PUT 都会触发 preflight，但是只有一部分 post 会触发 preflight。</p>
<ul>
<li>只有 GET, HEAD, POST 这三种方法有机会成为“简单请求”。</li>
<li>当一个 POST 请求同时满足以下所有条件时，它被视为“简单请求”：
<ul>
<li><code>Content-Type</code>是以下三者之一:
<ul>
<li><code>application/x-www-form-urlencoded</code>(HTML 表单提交的默认类型)</li>
<li><code>multipart/form-data</code>(HTML 表单用于上传文件时的类型)</li>
<li><code>text/plain</code></li>
</ul>
</li>
<li>没有自定义的请求头 (比如<code>Authorization</code>, <code>X-Custom-Header</code>等)。</li>
</ul>
</li>
</ul>
<p>为什么这些是“简单”的？ 因为这些是传统 HTML <code>&lt;form&gt;</code>标签就能发出的请求。在 AJAX 和现代 Web API 出现之前，浏览器就已经支持这种形式的跨域表单提交了。因此，为了向后兼容并维持互联网长久以来的运作方式，规范将这类请求视为“简单”和“安全”的，服务器理应有能力处理它们，所以不需要预检。</p>
<p>当一个 POST 请求不满足上述“简单”条件时，它就变成了“非简单请求”，需要预检。最常见的情况是：</p>
<ul>
<li><code>Content-Type</code>是<code>application/json</code>: 这是现代前后端分离应用中最常见的 API 数据格式。由于它不是传统 HTML 表单能发出的类型，所以被认为是非简单的。</li>
<li>请求中包含了自定义 Header: 只要你加了任何一个不在“简单请求”允许列表里的 Header（比如为了身份验证加了<code>Authorization</code>头），整个请求就变成了非简单的。</li>
</ul>
<p>所以，<strong>常见的 POST RESTful 调用通常都需要考虑跨域问题</strong>。</p>
<h3 id="总结">总结</h3>
<p>Preflight 是一种由浏览器自动触发的、用于保护服务器安全的前置检查机制。</p>
<p>当我们谈论它时，我们实际上是在谈论现代 Web 应用中跨域通信的安全模型：它如何区分“简单”和“复杂”的交互，如何通过一次额外的 OPTIONS “握手”来确保服务器知情并同意那些可能改变其状态的请求，以及在出现问题时，如何根据这个机制去排查服务器端的配置错误。</p>
<h2 id="options-问题">options 问题</h2>
<p>在现代 Web 开发的跨域（CORS）场景下，OPTIONS 方法的核心和最主要的角色就是专门用来执行 **Preflight（预检）**请求。</p>
<p>然而，从更广泛的 HTTP 协议定义来看，OPTIONS 并非 仅仅 为 Preflight 而生。它有一个更通用的、原始的用途。</p>
<p>我们来区分一下这两个角色：</p>
<h3 id="主要角色：cors-预检请求-preflight">主要角色：CORS 预检请求 (Preflight)</h3>
<p>这是我们今天几乎所有开发者遇到 OPTIONS 的场景。</p>
<ul>
<li>目的：在发送“非简单”跨域请求（如 PUT 或带 application/json 的 POST）之前，由浏览器自动发起，用来询问服务器是否允许即将到来的真实请求。</li>
<li>谁发起：浏览器自动发起，开发者通常不需要手写 OPTIONS 请求。</li>
<li>服务器响应：服务器需要返回一系列<code>Access-Control-*</code>相关的响应头（如 <code>Access-Control-Allow-Methods</code>, <code>Access-Control-Allow-Headers</code>）来“授权”。</li>
<li>本质：这是一次安全握手，是浏览器强制执行的 CORS 安全策略的一部分。</li>
</ul>
<h3 id="原始角色：查询服务器能力">原始角色：查询服务器能力</h3>
<p>这是 HTTP/1.1 规范中 OPTIONS 方法的通用定义，这个用途比 CORS 的概念要早。</p>
<ul>
<li>目的：客户端（不一定是浏览器）可以主动发送一个 OPTIONS 请求给服务器的某个 URL，用来查询该 URL 支持哪些 HTTP 请求方法。</li>
<li>谁发起：任何 HTTP 客户端都可以手动发起。</li>
<li>服务器响应：服务器应该在响应头中返回一个 Allow 字段，列出所有支持的方法。例如：Allow: GET, POST, PUT, HEAD。</li>
<li>本质：这是一个发现机制或探测机制。就像你走到一个自动售货机前，按下一个“查询”按钮，机器会点亮所有有货的商品按钮，告诉你“这些是你现在可以按的”。<br>
举个例子：<br>
一个 API 客户端想知道它是否可以更新某个用户信息，它可以先发送一个 OPTIONS 请求：</li>
</ul>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/api/users/123</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>example.com<br></code></pre></td></tr></table></figure>
<p>如果服务器允许对该用户进行读取、更新和删除，它可能会这样响应：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">204</span> No Content<br><span class="hljs-attribute">Allow</span><span class="hljs-punctuation">: </span>GET, PUT, DELETE, HEAD<br></code></pre></td></tr></table></figure>
<p>客户端收到这个响应后，就知道：“哦，我可以用 PUT 方法去更新这个用户的信息。”</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>CORS Preflight (主要用途)</th>
<th>查询服务器能力 (原始用途)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>目的</strong></td>
<td>跨域安全检查，为真实请求“铺路”</td>
<td>发现指定 URL 支持哪些 HTTP 方法</td>
</tr>
<tr>
<td><strong>触发方</strong></td>
<td>浏览器在特定条件下自动触发</td>
<td>客户端 (浏览器、代码、工具) 手动发起</td>
</tr>
<tr>
<td><strong>关键响应头</strong></td>
<td><code>Access-Control-Allow-Methods</code><br><code>Access-Control-Allow-Headers</code></td>
<td><code>Allow</code></td>
</tr>
<tr>
<td><strong>常见程度</strong></td>
<td>非常常见，是前后端分离开发的日常</td>
<td>相对少见，多用于 RESTful API 测试工具</td>
</tr>
</tbody>
</table>
<p>在实际工作中，我们几乎可以认为 OPTIONS 就是专门为 Preflight 服务的。 尽管它有一个更通用的原始定义，但那个定义在日常开发中用得很少，而 CORS Preflight 则是 OPTIONS 方法如今最重要、最无可替代的舞台。</p>
<h2 id="云设施下的配置">云设施下的配置</h2>
<blockquote>
<p>在现代应用中，似乎我们都是配置反向代理的策略（特别是在 aws 的 cdn 或者 alb 里），来决定什么时候返回<br>
Access-Control-Allow-Methods、Access-Control-Allow-Headers，而不是由代码逻辑决定返回什么头，头里返回什么东西，这正常吗？</p>
</blockquote>
<p>将 CORS 策略（包括<code>Access-Control-Allow-Methods</code>，<code>Access-Control-Allow-Headers</code>，<code>Access-Control-Allow-Origin</code>等）从应用代码中剥离，统一在**基础设施层面（如反向代理、API 网关、CDN、ALB）**进行配置，是主流且推荐的做法。</p>
<h3 id="为什么这是一种好方法？">为什么这是一种好方法？</h3>
<h4 id="关注点分离-separation-of-concerns">关注点分离 (Separation of Concerns)</h4>
<ul>
<li>应用代码：应该专注于核心的业务逻辑。一个处理订单的 API，其代码最应该关心的是如何创建、验证和存储订单数据。</li>
<li>基础设施：应该负责处理横切关注点 (Cross-Cutting Concerns)，如安全性、路由、限流、日志记录和 CORS。</li>
<li>结论：CORS 本质上是一个安全和浏览器通信的策略，它与“如何处理订单”这个业务逻辑无关。将它放在基础设施层，可以让应用开发者更专注于业务，让架构更清晰。</li>
</ul>
<h4 id="集中化管理与一致性">集中化管理与一致性</h4>
<ul>
<li>在一个微服务架构中，你可能有几十甚至上百个服务。如果每个服务都在自己的代码里配置 CORS，很容易出现不一致、遗漏或错误。</li>
<li>在 API Gateway 或 ALB 这种统一入口点配置 CORS，可以确保所有下游服务都遵循同一套安全策略。更新策略时，也只需要修改一个地方，大大降低了维护成本和风险。</li>
</ul>
<h4 id="性能优化">性能优化</h4>
<ul>
<li>大量的 Preflight OPTIONS 请求是“非简单”跨域请求的常态。</li>
<li>如果由反向代理或 CDN 来处理这些 OPTIONS 请求，它们可以直接响应，而无需将请求转发到后端的应用服务器。</li>
<li>这极大地减轻了应用服务器的负担，因为它不再需要花费 CPU 和内存去处理这些“探测性”的请求，可以把资源留给真正处理业务的 GET, POST, PUT 等请求。</li>
</ul>
<h4 id="安全性">安全性</h4>
<ul>
<li>在基础设施层面统一强制执行 CORS 策略，可以防止某个服务的开发者因疏忽而在代码中配置了过于宽松的策略（比如 <code>Access-Control-Allow-Origin: *</code>），从而引入安全漏洞。策略由安全或运维团队在网关层统一把控，更加稳妥。</li>
</ul>
<h4 id="简化开发">简化开发</h4>
<ul>
<li>应用开发者不再需要关心 CORS 的复杂细节。他们不需要在每个项目中都安装和配置 CORS 相关的库或中间件，从而简化了开发和部署流程。</li>
</ul>
<h3 id="什么时候在代码中处理-cors-仍然有意义？">什么时候在代码中处理 CORS 仍然有意义？</h3>
<p>尽管在基础设施层处理是最佳实践，但在某些特定场景下，代码层面的处理仍然是合理甚至必要的：</p>
<h4 id="动态和精细化的-cors-策略：">动态和精细化的 CORS 策略：</h4>
<ul>
<li>场景：假设你希望<code>Access-Control-Allow-Origin</code>的值是动态的。例如，你允许多个租户使用你的 API，并且只允许来自该租户自己注册的域名的请求。</li>
<li>原因：这种逻辑（“去数据库里查一下当前 API Key 对应的租户域名是什么”）是业务逻辑的一部分，很难在静态的代理配置中实现。这时，就需要在应用代码中动态生成 CORS 响应头。</li>
</ul>
<h4 id="简单的单体应用：">简单的单体应用：</h4>
<ul>
<li>场景：你只有一个简单的、独立的后端服务，前面没有复杂的 API Gateway 或 ALB。</li>
<li>原因：在这种情况下，为了实现 CORS 而引入一套复杂的反向代理是不必要的开销。直接在代码中使用一个中间件（如 Node.js 的 cors 包）来处理，是最简单直接的方案。</li>
</ul>
<h4 id="本地开发环境：">本地开发环境：</h4>
<ul>
<li>场景：在本地开发时，为了方便前端调试，通常会在后端代码里启用一个非常宽松的 CORS 策略。</li>
<li>原因：这比在本地也搭建一套完整的反向代理要方便得多。</li>
</ul>
<table>
<thead>
<tr>
<th>配置位置</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>基础设施层（推荐）</strong></td>
<td>• 关注点分离<br>• 集中管理<br>• 性能高<br>• 更安全<br>• 简化开发</td>
<td>• 无法处理非常动态的、依赖业务逻辑的策略</td>
<td>• 生产环境<br>• 微服务架构<br>• 大多数现代应用</td>
</tr>
<tr>
<td><strong>应用代码层</strong></td>
<td>• 灵活，可实现动态策略<br>• 设置简单</td>
<td>• 逻辑耦合<br>• 配置分散<br>• 性能开销<br>• 可能不一致</td>
<td>• 需要动态策略的场景<br>• 简单的单体应用<br>• 本地开发</td>
</tr>
</tbody>
</table>
<h1>如何绕开同源策略限制</h1>
<h2 id="修改源">修改源</h2>
<p>这个方法但只能升源，不能跨源，但能改变 cookie 从属的域。</p>
<p>页面可以修改自己的源，但只能用它的脚本将<code>document.domain</code>的值设置成其当前域或当前域的超级域。如果将其设置为当前域的超级域，则较短的域将用于后续原始检查。</p>
<p>MDN 里举了一个例子，假设文档中的一个脚本在<code>http://store.company.com/dir/other.html</code> 执行以下语句：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&quot;company.com&quot;</span>;<br></code></pre></td></tr></table></figure>
<p>页面将会成功地通过对<code>http://company.com/dir/page.html</code>的同源检测。而同理，<code>company.com</code> 不能设置<code>document.domain</code>为<code>othercompany.com</code>。</p>
<p>但改域还是要注意端口号问题：</p>
<ol>
<li>你不能给<code>document.domain</code>赋值时带上端口号。执行<code>document.domain = &quot;company.com:8080&quot;</code>; 会直接抛出安全错误。</li>
<li>根据 HTML 规范，当<code>document.domain</code>被成功赋值后，该源的端口号在用于同源检测时，会被重置为 null。</li>
<li>假设页面 A 来自<code>company.com:8080</code>，页面 B 来自 <code>company.com:8000</code>。它们不同源（因为端口不同）。但如果两个页面都执行了<code>document.domain = &quot;company.com&quot;</code>;，那么在进行同源比较时，它们的源都变成了 (<code>https</code>, <code>company.com</code>, <code>null</code>)。因为协议、域名、端口（现在都是 null）都相同了，所以它们现在被认为是同源的。</li>
</ol>
<p>还有一个需要对父页面重新赋值的注意事项：</p>
<blockquote>
<p>使用document.domain允许子域安全访问其父域时，您需要设置document.domain在父域和子域中具有相同的值。这是必要的，即使这样做只是将父域设置回其原始值。否则可能会导致权限错误。</p>
</blockquote>
<p>document.domain 的真正作用：是放宽脚本之间对 DOM 的访问权限。最典型的场景是，一个页面 (<code>parent.html</code> from <code>company.com</code>) 中有一个<code>iframe</code>，这个<code>iframe</code>加载了另一个页面 (<code>child.html</code> from <code>store.company.com</code>)。在默认的同源策略下，<code>parent.html</code>的脚本无法访问 <code>child.html</code>的 window 对象，反之亦然。当两个页面都设置了<code>document.domain = &quot;company.com&quot;</code>; 后，它们就可以互相访问对方的 DOM 了。它的目的在于脚本交互，而非 Cookie 共享。</p>
<h2 id="iframe">iframe</h2>
<blockquote>
<p>如果两个网页不同源，就无法拿到对方的DOM。典型的例子是iframe窗口和window.open方法打开的窗口，它们与父窗口无法通信。</p>
</blockquote>
<blockquote>
<p>HTML5为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。</p>
</blockquote>
<blockquote>
<p>这个API为window对象新增了一个window.postMessage方法，允许跨窗口通信，不论这两个窗口是否同源。</p>
</blockquote>
<blockquote>
<p>举例来说，父窗口http://aaa.com向子窗口http://bbb.com发消息，调用postMessage方法就可以了。</p>
</blockquote>
<p>postMessage 是除了修改 document.domain 以外的另一种方法。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>document.domain</th>
<th>window.postMessage</th>
<th>结论</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心用途</strong></td>
<td>专门为了直接访问 DOM。</td>
<td>专门为了安全地传递消息。</td>
<td>postMessage 用途更通用</td>
</tr>
<tr>
<td><strong>限制</strong></td>
<td>极其严格：只能在主域相同的子域之间使用 (e.g., <a target="_blank" rel="noopener" href="http://a.company.com">a.company.com</a> 和 <a target="_blank" rel="noopener" href="http://b.company.com">b.company.com</a>)。</td>
<td>无限制：可以在任何两个窗口之间使用，无论它们是否同源 (<a target="_blank" rel="noopener" href="http://a.com">a.com</a> 和 <a target="_blank" rel="noopener" href="http://b.com">b.com</a> 完全可以)。</td>
<td>postMessage 适用性 完胜</td>
</tr>
<tr>
<td><strong>安全模型</strong></td>
<td>不安全，权限过大。一旦设置成功，就相当于完全打开了 DOM 访问的大门，对方窗口可以对你的页面做任何 DOM 操作，控制粒度为 0。</td>
<td>安全，权限可控。你只传递你需要的数据，而不是整个 DOM 的控制权。接收方必须验证消息来源 (event.origin)，确保只接受信任窗口的消息。</td>
<td>postMessage 安全性 完胜</td>
</tr>
<tr>
<td><strong>通信方式</strong></td>
<td>同步的、直接的 DOM 操作。</td>
<td>异步的、事件驱动的 (message 事件监听)。</td>
<td>postMessage 更符合现代编程范式</td>
</tr>
<tr>
<td><strong>数据类型</strong></td>
<td>只能通过操作 DOM 来&quot;传递&quot;信息，非常笨拙。</td>
<td>可以传递字符串、JSON 对象等任何可序列化的数据，非常灵活。</td>
<td>postMessage 更灵活 强大</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>遗留系统，或者有特殊需求必须在子域间直接操作 DOM 的古老场景。</td>
<td>所有需要跨窗口通信的现代 Web 应用，如：内嵌的 iframe 服务、第三方组件、Web Widget 等。</td>
<td>postMessage 是现代 标准</td>
</tr>
</tbody>
</table>
<h2 id="经典的-不经授权的-js-片段读取内存里的信息-的问题">经典的“不经授权的 js 片段读取内存里的信息”的问题</h2>
<ul>
<li>
<p>第一层防御：浏览器自身的安全沙箱（同源策略）<code>localStorage</code>和<code>IndexedDB</code>是沙箱的“标准住户”，被严格限制在创建它们的源所对应的沙箱内部。例如，<code>b.com</code>的脚本绝对无法读取<code>a.com</code>的 <code>localStorage</code>。</p>
</li>
<li>
<p>第二层防御：防止恶意脚本注入（防范 XSS） 同理，如果攻击者通过 XSS 攻击将脚本注入了 <code>a.com</code>，那么这个脚本就位于沙箱之内，可以自由读取<code>a.com</code>的<code>localStorage</code>和<code>IndexedDB</code> 中的所有数据。这再次凸显了 XSS 防御是保护沙箱内部数据不被窃取的第二层生命线。</p>
</li>
<li>
<p>第三层防御：代码层面的封装（闭包） 作为纵深防御的最后一环，开发者可以在代码层面增加保护。例如，一个极其敏感的令牌（Token），如果直接存储在<code>localStorage</code>中，一旦发生 XSS，令牌就会被轻易盗走。但如果开发者利用 JavaScript 的闭包（Closure），将这个令牌保存在一个模块的私有变量中，并且只暴露一个使用该令牌的特定函数。那么，即使 XSS 脚本被注入，它也无法直接访问到这个被闭包“隐藏”起来的令牌，只能调用暴露出来的函数，极大地增加了攻击难度。这是代码架构层面的最后一道防线。</p>
</li>
</ul>
<h2 id="ajax-的方法">AJAX 的方法</h2>
<h3 id="简单-header-和非简单-header">简单 header 和非简单 header</h3>
<p>默认情况下，只有七种 simple response headers （简单响应首部）可以暴露给外部：</p>
<ul>
<li>Cache-Control</li>
<li>Content-Language</li>
<li>Content-Length</li>
<li>Content-Type</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Pragma</li>
</ul>
<p>non-simple-headers 可以用如下方式返回：</p>
<blockquote>
<p>Access-Control-Expose-Headers: Content-Length, X-Kuma-Revision</p>
</blockquote>
<p>在处理跨域 AJAX 请求时，浏览器不仅会遵循同源策略限制对响应体（Response Body）的读取，同样也会限制对响应头（Response Headers）的访问。这是一种纵深防御策略，旨在防止敏感信息通过响应头泄露。</p>
<h4 id="第一道关卡：简单响应头-simple-response-headers">第一道关卡：简单响应头（Simple Response Headers）</h4>
<p>默认情况下，浏览器这名“安全管家”只会将一小部分它认为“安全”的、不包含敏感信息的响应头放行，让你的 JavaScript 代码可以访问到。这个白名单就是您提到的七种简单响应头：</p>
<ul>
<li>Cache-Control</li>
<li>Content-Language</li>
<li>Content-Length</li>
<li>Content-Type</li>
<li>Expires</li>
<li>Last-Modified</li>
<li>Pragma</li>
</ul>
<p>场景举例： 假设你的网站<code>my-app.com</code>通过<code>fetch</code>请求了<code>api.example.com</code> 的一个接口。当响应返回后，你的 JavaScript 代码尝试执行 <code>response.headers.get('Content-Type')</code>，这是可以成功获取到值的，因为<code>Content-Type</code> 在这个安全白名单里。</p>
<h4 id="第二道关卡：暴露非简单响应头-non-simple-headers">第二道关卡：暴露非简单响应头（Non-Simple Headers）</h4>
<p>现在，假设<code>api.example.com</code>的响应中包含了一些自定义的、非常有用的头部信息，比如：</p>
<ul>
<li><code>X-Request-ID</code>: 用于追踪和调试的请求唯一 ID。</li>
<li><code>X-RateLimit-Remaining</code>: 告知客户端当前速率限制下还剩多少次请求。</li>
</ul>
<p>如果你的代码尝试直接<code>response.headers.get('X-Request-ID')</code>，将会得到 <code>null</code>。因为这个头部不在安全白名单内，浏览器默认将其拦截，不会暴露给脚本。</p>
<h4 id="如何解决？-服务器的-通行证">如何解决？—— 服务器的“通行证”</h4>
<p>要解决这个问题，需要服务器在响应中明确地给浏览器签发一张“通行证”，告诉浏览器：“嘿，这些额外的响应头是安全的，请把它们暴露给发起请求的脚本吧！”</p>
<p>这张通行证就是<code>Access-Control-Expose-Headers</code>响应头。</p>
<p>服务器响应示例：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>https://my-app.com<br><span class="hljs-attribute">Access-Control-Expose-Headers</span><span class="hljs-punctuation">: </span>X-Request-ID, X-RateLimit-Remaining<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>application/json<br><span class="hljs-attribute">X-Request-ID</span><span class="hljs-punctuation">: </span>abc-123-xyz-789<br><span class="hljs-attribute">X-RateLimit-Remaining</span><span class="hljs-punctuation">: </span>49<br></code></pre></td></tr></table></figure>
<p>当浏览器收到这个响应后，它会检查<code>Access-Control-Expose-Headers</code>，看到<code>X-Request-ID</code>和 <code>X-RateLimit-Remaining</code>被列入了许可名单。此时，你的 JavaScript 代码再执行 <code>response.headers.get('X-Request-ID')</code>就能成功拿到 abc-123-xyz-789 这个值了。</p>
<h4 id="总结">总结</h4>
<p>这个机制是 CORS 标准中一个精妙的安全设计。它遵循了最小权限原则：默认情况下，浏览器只暴露最必要、最无害的信息；任何额外的权限（无论是读取响应体还是读取特定的响应头），都必须由提供资源的服务器通过明确的<code>Access-Control-*</code>头部来授予。这确保了数据的控制权始终掌握在资源所有者手中。</p>
<h3 id="jsonp">JSONP</h3>
<h4 id="起因">起因</h4>
<p>一切的起点源于浏览器的同源策略（Same-Origin Policy）。该策略是浏览器的核心安全基石，它严格限制一个源（Origin）的文档或脚本如何与另一个源的资源进行交互。在 AJAX 请求中，这意味着 XMLHttpRequest 和后来的 fetch 默认无法请求不同源的服务器数据。</p>
<p>然而，开发者们发现了一个“例外”：HTML 的<code>&lt;script&gt;</code>标签。它的 src 属性可以加载并执行来自任何源的 JavaScript 文件，而不受同源策略的限制。</p>
<p>JSONP 的核心思想，正是利用了这个特性。<strong>它将一个本应是“数据请求”的过程，伪装成了一个“脚本加载”的过程</strong>，从而巧妙地绕过了同源策略的限制。</p>
<h4 id="实现">实现</h4>
<p><code>&lt;script&gt;</code>标签的存在，生动地说明了同源策略不限制普通的<code>http get</code> 请求获取嵌入式资源。本质上就是让代码的上文写好，生成一个<code>script</code>标签请求，让服务器把下文写好。</p>
<h5 id="客户端：定义函数-上文-并发起请求">客户端：定义函数（上文）并发起请求</h5>
<p>客户端首先需要定义一个全局的“回调函数”，这个函数用来接收和处理从服务器获取的数据。然后，它会动态地创建一个<code>&lt;script&gt;</code>标签，将其<code>src</code>指向服务器的 API 地址，并通过 URL 参数（通常是 <code>callback</code>）告诉服务器回调函数的名字。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 1. 在全局作用域定义好回调函数（“上文”）</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleResponse</span>(<span class="hljs-params">data</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;服务器返回的数据是: &#x27;</span> + data.<span class="hljs-property">message</span>);<br>&#125;;<br><br><span class="hljs-comment">// 2. 动态创建一个 script 标签</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">addScriptTag</span>(<span class="hljs-params">src</span>) &#123;<br>  <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>  script.<span class="hljs-title function_">setAttribute</span>(<span class="hljs-string">&quot;type&quot;</span>,<span class="hljs-string">&quot;text/javascript&quot;</span>);<br>  script.<span class="hljs-property">src</span> = src;<br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br>&#125;<br><br><span class="hljs-comment">// 3. 发起请求，并通过 callback 参数告知服务器我们的函数名叫 &#x27;handleResponse&#x27;</span><br><span class="hljs-comment">// 最终生成的标签会是：&lt;script src=&quot;http://api.example.com/data?callback=handleResponse&quot;&gt;&lt;/script&gt;</span><br><span class="hljs-title function_">addScriptTag</span>(<span class="hljs-string">&#x27;http://api.example.com/data?callback=handleResponse&#x27;</span>);<br></code></pre></td></tr></table></figure>
<h5 id="服务器端：生成调用代码-下文">服务器端：生成调用代码（下文）</h5>
<p>服务器接收到请求后，会解析 URL 中的<code>callback</code>参数，得到客户端定义好的函数名（在这个例子里是 <code>handleResponse</code>）。然后，服务器将要返回的数据（通常是 JSON 格式）作为参数，包裹在这个函数调用语句中，最后将这段拼接好的 JavaScript 代码返回给客户端。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 服务器端（例如 Node.js/Express）的逻辑</span><br><span class="hljs-comment">// 假设请求 URL 是 /data?callback=handleResponse</span><br><br><span class="hljs-keyword">const</span> data = &#123; <span class="hljs-string">&quot;message&quot;</span>: <span class="hljs-string">&quot;Hello from another domain!&quot;</span> &#125;;<br><span class="hljs-keyword">const</span> callbackName = req.<span class="hljs-property">query</span>.<span class="hljs-property">callback</span>; <span class="hljs-comment">// 获取到 &#x27;handleResponse&#x27;</span><br><br><span class="hljs-comment">// 将数据包裹在函数调用中，作为字符串返回</span><br><span class="hljs-keyword">const</span> responseScript = <span class="hljs-string">`<span class="hljs-subst">$&#123;callbackName&#125;</span>(<span class="hljs-subst">$&#123;<span class="hljs-built_in">JSON</span>.stringify(data)&#125;</span>)`</span>;<br><br><span class="hljs-comment">// 设置响应类型为 JavaScript</span><br>res.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;application/javascript&#x27;</span>);<br>res.<span class="hljs-title function_">send</span>(responseScript);<br></code></pre></td></tr></table></figure>
<p>服务器最终返回给浏览器的内容是这样一段文本：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">handleResponse</span>(&#123;<span class="hljs-string">&quot;message&quot;</span>:<span class="hljs-string">&quot;Hello from another domain!&quot;</span>&#125;);<br></code></pre></td></tr></table></figure>
<h4 id="核心弱点与现代替代方案">核心弱点与现代替代方案</h4>
<p>尽管 JSONP 设计巧妙，但它的成功是建立在“信任”的基础之上，这也正是它最大的弱点。</p>
<ul>
<li>严重的安全风险：第三方域危险-JSONP 的本质是加载并执行来自第三方域的脚本。如果你信任的服务器被攻击或本身就是恶意的，它返回的脚本中就可能包含任意恶意代码。这些代码将在你的页面上以你的权限运行，可以窃取用户的 Cookie、篡改页面内容，引发 XSS 攻击。</li>
<li>仅支持 GET 请求：由于<code>&lt;script&gt;</code>标签的 src 只能发起 GET 请求，JSONP 天生无法实现 POST、PUT、DELETE 等具有写入或修改性质的操作。</li>
<li>糟糕的错误处理：如果脚本加载失败（如 404 Not Found 或服务器 500 错误），浏览器不会提供像 fetch 的<code>.catch()</code>那样清晰可靠的错误捕获机制，难以进行优雅的错误处理。</li>
</ul>
<h4 id="现代替代方案：cors">现代替代方案：CORS</h4>
<p>由于上述缺陷，JSONP 在现代 Web 开发中已基本被 CORS（跨域资源共享） 所取代。CORS 是一个 W3C 标准，它允许服务器通过设置 Access-Control-Allow-Origin 等 HTTP 响应头，来授权指定的源进行跨域请求。它更安全（返回的是纯数据，而非可执行代码）、更强大（支持所有 HTTP 方法）且拥有完善的错误处理机制，是当今处理跨域问题的首选方案。</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>CORS (跨域资源共享)</th>
<th>JSONP (JSON with Padding)</th>
<th>优劣对比</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>安全模型</strong></td>
<td>安全：浏览器获取的是纯文本数据，绝不会执行。数据是否可用，由服务器通过 HTTP 头明确授权。</td>
<td>极度危险：本质是请求并执行一段来自第三方的 JavaScript 代码。你必须无条件信任该服务器不会发送恶意代码。</td>
<td><strong>CORS 完胜</strong>。这是最根本的区别。CORS 遵循了“数据与代码分离”的原则，而 JSONP 混淆了两者，为 XSS 攻击打开了大门。</td>
</tr>
<tr>
<td><strong>HTTP 方法</strong></td>
<td>支持所有方法：GET，POST，PUT，DELETE，HEAD 等。</td>
<td>仅支持 GET：因为它依赖 <code>&lt;script&gt;</code> 标签的 src 属性。</td>
<td><strong>CORS 胜出</strong>。现代 Web 应用需要丰富的 HTTP 方法进行 RESTful 交互，JSONP 无法满足。</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>健壮：可以被 <code>try...catch</code> 或 <code>.catch()</code> 捕获。浏览器会报告详细的 HTTP 状态码（如 404, 500）和网络错误。</td>
<td>脆弱：无法直接判断请求是否成功。通常只能用 <code>setTimeout</code> 超时机制来“猜测”请求失败，非常不可靠。</td>
<td><strong>CORS 胜出</strong>。提供了开发者期望的、标准化的错误处理流程。</td>
</tr>
<tr>
<td><strong>标准化</strong></td>
<td>W3C 官方标准：是现代浏览器内置的、推荐的跨域解决方案。</td>
<td>非官方的“模式”：一种被广泛使用的“黑客”技巧或约定，但并非标准。</td>
<td><strong>CORS 胜出</strong>。作为官方标准，它有更好的兼容性、可预见性和未来支持。</td>
</tr>
</tbody>
</table>
<h5 id="把控制权放在服务端-cors-模型">把控制权放在服务端（CORS 模型）</h5>
<p>CORS 的工作模式，可以类比为去一个私人俱乐部：</p>
<ol>
<li>你（客户端 <a target="_blank" rel="noopener" href="http://your-app.com">your-app.com</a>）：想进入俱乐部（访问服务器 <a target="_blank" rel="noopener" href="http://api.server.com">api.server.com</a> 的资源）。</li>
<li>保安（浏览器）：拦住你，因为你不属于这个俱乐部（跨域了）。保安不会自己决定放你进去，他需要查看来宾名单。</li>
<li>你对保安说：你去问问俱乐部老板（服务器），我 <a target="_blank" rel="noopener" href="http://your-app.com">your-app.com</a> 在不在他的来宾名单上。</li>
<li>保安（浏览器）：向俱乐部老板（服务器）发送一个请求（这个请求被称为“预检请求” Preflight Request）。</li>
<li>俱乐部老板（服务器）：查看自己的来宾名单（Access-Control-Allow-Origin 配置）。
<ul>
<li>情况A：名单上写着 <a target="_blank" rel="noopener" href="http://your-app.com">your-app.com</a> 可以进入。老板告诉保安：“放他进来。”</li>
<li>情况B：名单上没有你。老板告诉保安：“把他赶走。”</li>
</ul>
</li>
<li>保安（浏览器）：根据老板的指令，决定是让你通过（执行真正的请求），还是拒绝你（在控制台报错）。</li>
</ol>
<p>在这个模型中：</p>
<ul>
<li>所有权决定控制权：资源在服务器上，所以只有服务器有权决定谁能访问它。这符合现实世界的逻辑。</li>
<li>明确授权（Explicit is better than implicit）：服务器必须明确地列出允许访问的源。这避免了意外或模糊的授权，安全性更高。</li>
<li>浏览器是中立的执行者：浏览器不偏袒任何一方，它只是忠实地执行服务器制定的安全策略。这使得安全策略可靠且可预测。</li>
</ul>
<p>结论：将跨域访问的控制权交给服务器，是确保数据所有者能够自主掌控其资源安全的关键。CORS 正是基于这一核心原则设计的，因此它构建了一个远比 JSONP 更安全、更强大的现代 Web 安全体系。</p>
<h4 id="cors-cross-origin-resource-sharing">CORS(Cross-Origin Resource Sharing)</h4>
<p>先把请求分成简单请求(simple request)和非简单请求(not-so-simple request)。</p>
<h4 id="简单请求">简单请求</h4>
<p>对于简单请求，就是在 request 里面表明当前的request 来自哪个 origin。换言之，A 要跨域到 B，A 至少要表明自己。</p>
<p>如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，<strong>被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。</strong></p>
<p>如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-params">Access-Control-Allow-Origin:</span> http:<span class="hljs-symbol">//api.bob.com</span><br><span class="hljs-params">Access-Control-Allow-Credentials:</span> <span class="hljs-literal">true</span><br><span class="hljs-params">Access-Control-Expose-Headers:</span> FooBar<br><span class="hljs-params">Content-Type:</span> text<span class="hljs-symbol">/html</span>; <span class="hljs-attr">charset</span><span class="hljs-operator">=</span>utf-<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure>
<p>其中各个字段的含义：</p>
<ol>
<li>
<p>Access-Control-Allow-Origin：<strong>该字段是必须的</strong>。它的值要么是请求时Origin字段的值，要么是一个，表示接受任意域名的请求（习惯大方的程序员当然会选择后者了）。</p>
</li>
<li>
<p>Access-Control-Allow-Credentials：该字段可选。它的值是一个布尔值，<strong>表示是否允许发送Cookie</strong>。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。</p>
</li>
<li>
<p>Access-Control-Expose-Headers：该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。**如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。**上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。</p>
</li>
</ol>
<h4 id="非简单请求">非简单请求</h4>
<p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。</p>
<p>非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为&quot;预检&quot;请求（preflight）。</p>
<p>浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。</p>
<p>简而言之，在 JQuery 时代，由浏览器而不是由 JQuery 自动发出的 OPTIONS 请求，就是 preflight 请求。</p>
<p>一个例子如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> url = <span class="hljs-string">&#x27;http://api.alice.com/cors&#x27;</span>;<br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&#x27;PUT&#x27;</span>, url, <span class="hljs-literal">true</span>);<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&#x27;X-Custom-Header&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br>xhr.<span class="hljs-title function_">send</span>();<br></code></pre></td></tr></table></figure>
<p>上面代码中，HTTP请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。</p>
<p><strong>浏览器</strong>发现，这是一个非简单请求，就<strong>自动发出一个&quot;预检&quot;请求</strong>，要求服务器确认可以这样请求。下面是这个&quot;预检&quot;请求的HTTP头信息。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">OPTIONS</span> <span class="hljs-string">/cors</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Origin</span><span class="hljs-punctuation">: </span>http://api.bob.com<br><span class="hljs-attribute">Access-Control-Request-Method</span><span class="hljs-punctuation">: </span>PUT<br><span class="hljs-attribute">Access-Control-Request-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>api.alice.com<br><span class="hljs-attribute">Accept-Language</span><span class="hljs-punctuation">: </span>en-US<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>keep-alive<br><span class="hljs-attribute">User-Agent</span><span class="hljs-punctuation">: </span>Mozilla/5.0...<br></code></pre></td></tr></table></figure>
<p>服务器收到了这个请求，返回一个这样的响应：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Mon, 01 Dec 2008 01:15:39 GMT<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache/2.0.61 (Unix)<br><span class="hljs-attribute">Access-Control-Allow-Origin</span><span class="hljs-punctuation">: </span>http://api.bob.com<br><span class="hljs-attribute">Access-Control-Allow-Methods</span><span class="hljs-punctuation">: </span>GET, POST, PUT<br><span class="hljs-attribute">Access-Control-Allow-Headers</span><span class="hljs-punctuation">: </span>X-Custom-Header<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html; charset=utf-8<br><span class="hljs-attribute">Content-Encoding</span><span class="hljs-punctuation">: </span>gzip<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>0<br><span class="hljs-attribute">Keep-Alive</span><span class="hljs-punctuation">: </span>timeout=2, max=100<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>Keep-Alive<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/plain<br></code></pre></td></tr></table></figure>
<p>上面的HTTP回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<p><strong>如果浏览器否定了&quot;预检&quot;请求，会返回一个正常的HTTP回应</strong>，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。</p>
<p>到此我们可以看到，跨域相关的许可信息，都是放在 header 里而不是放在 body 里的。</p>
<p>一旦服务器通过了&quot;预检&quot;请求，以后<strong>每次</strong>浏览器正常的CORS请求，就都跟简单请求一样，<strong>会有一个Origin头信息字段</strong>。服务器的回应，也都<strong>会有一个Access-Control-Allow-Origin头信息字段</strong>。这两个字段，是浏览器和服务器自动添加上去，<strong>保证通话过程始终在对跨域的警惕和授权中度过</strong>。</p>
<h1>附一个小问题：CSRF 攻防问题</h1>
<ol>
<li><code>img src</code>攻击可以攻击所有 get 请求。所以现代的电子邮箱默认都不显示邮件图片，否则不知道哪个图片会攻击某个还能使用 get url 访问的网站。</li>
<li>隐藏表单不受同源策略影响，post 也需要做专门防御。任意的空白网页里都可能存在一个表单，在 onload 函数里就把表单提交了。</li>
</ol>
<p>最完善的做法，应该是做一些有时效性的 token 放在网页里。像 Rails 的方案，就是一个隐藏表单里的 token，还要配合 referer 使用（这个字段能不能被 javascript 修改是个<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/9580575/how-to-manually-set-referer-header-in-javascript">复杂问题</a>）。</p>
<h1>tomcat 关于会话的实现</h1>
<p>对 tomcat 而言，会话存在于 cookie、url重写（“;jsessionid=xxxxxx”）、隐藏表单域、ssl 属性。</p>
<p>使用的一般字段是 JSESSIONID。</p>
<p><img src="tomcat%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="tomcat四层结构"></p>
<p>engine -&gt; host -&gt; context -&gt; manager。</p>
<blockquote>
<p>tomcat session 组件图如下所示，其中 Context 对应一个 webapp 应用，每个 webapp 有多个 HttpSessionListener， 并且每个应用的 session 是独立管理的，而 session 的创建、销毁由 Manager 组件完成，它内部维护了 N 个 Session 实例对象。在前面的文章中，我们分析了 Context 组件，它的默认实现是 StandardContext，它与 Manager 是一对一的关系，Manager 创建、销毁会话时，需要借助 StandardContext 获取 HttpSessionListener 列表并进行事件通知，而 StandardContext 的后台线程会对 Manager 进行过期 Session 的清理工作。</p>
</blockquote>
<p><img src="tomcat-session%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="tomcat-session的结构"></p>
<p>context 与 manager 是一对一的关系，而且 manger 负责通过以下代码创建 session：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取 request 对应的 session</span><br><span class="hljs-keyword">public</span> HttpSession <span class="hljs-title function_">getSession</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 这里就是 通过 managerBase.sessions 获取 Session</span><br>    <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> doGetSession(<span class="hljs-literal">true</span>); <br>    <span class="hljs-keyword">if</span> (session == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> session.getSession();<br>&#125;<br><br><span class="hljs-comment">// create 代表是否创建 StandardSession</span><br><span class="hljs-keyword">protected</span> Session <span class="hljs-title function_">doGetSession</span><span class="hljs-params">(<span class="hljs-type">boolean</span> create)</span> &#123;              <br><br>    <span class="hljs-comment">// There cannot be a session if no context has been assigned yet</span><br>    <span class="hljs-comment">// 1. 检验 StandardContext</span><br>    <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span>);                                           <br>    &#125;<br><br>    <span class="hljs-comment">// Return the current session if it exists and is valid</span><br>     <span class="hljs-comment">// 2. 校验 Session 的有效性</span><br>    <span class="hljs-keyword">if</span> ((session != <span class="hljs-literal">null</span>) &amp;&amp; !session.isValid()) &#123;              <br>        session = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> (session);<br>    &#125;<br><br>    <span class="hljs-comment">// Return the requested session if it exists and is valid</span><br>    <span class="hljs-type">Manager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//拿到StandardContext 中对应的StandardManager，Context与 Manager 是一对一的关系</span><br>        manager = context.getManager();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (manager == <span class="hljs-literal">null</span>)<br>     &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span>);      <span class="hljs-comment">// Sessions are not supported</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (requestedSessionId != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;        <br>            <span class="hljs-comment">// 3. 通过 managerBase.sessions 获取 Session</span><br>            <span class="hljs-comment">// 4. 通过客户端的 sessionId 从 managerBase.sessions 来获取 Session 对象</span><br>            session = manager.findSession(requestedSessionId);   <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            session = <span class="hljs-literal">null</span>;<br>        &#125;<br>         <span class="hljs-comment">// 5. 判断 session 是否有效</span><br>        <span class="hljs-keyword">if</span> ((session != <span class="hljs-literal">null</span>) &amp;&amp; !session.isValid()) &#123;          <br>            session = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 6. session access +1</span><br>            session.access();                                    <br>            <span class="hljs-keyword">return</span> (session);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Create a new session if requested and the response is not committed</span><br>    <span class="hljs-comment">// 7. 根据标识是否创建 StandardSession ( false 直接返回)</span><br>    <span class="hljs-keyword">if</span> (!create) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span>);                                           <br>    &#125;<br>    <span class="hljs-comment">// 当前的 Context 是否支持通过 cookie 的方式来追踪 Session</span><br>    <span class="hljs-keyword">if</span> ((context != <span class="hljs-literal">null</span>) &amp;&amp; (response != <span class="hljs-literal">null</span>) &amp;&amp; context.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.COOKIE) &amp;&amp; response.getResponse().isCommitted()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span><br>          (sm.getString(<span class="hljs-string">&quot;coyoteRequest.sessionCreateCommitted&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// Attempt to reuse session id if one was submitted in a cookie</span><br>    <span class="hljs-comment">// Do not reuse the session id if it is from a URL, to prevent possible</span><br>    <span class="hljs-comment">// phishing attacks</span><br>    <span class="hljs-comment">// Use the SSL session ID if one is present.</span><br>    <span class="hljs-comment">// 8. 到这里其实是没有找到 session, 直接创建 Session 出来</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-string">&quot;/&quot;</span>.equals(context.getSessionCookiePath()) &amp;&amp; isRequestedSessionIdFromCookie()) || requestedSessionSSL ) &#123;<br>        session = manager.createSession(getRequestedSessionId()); <span class="hljs-comment">// 9. 从客户端读取 sessionID, 并且根据这个 sessionId 创建 Session</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        session = manager.createSession(<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Creating a new session cookie based on that session</span><br>    <span class="hljs-keyword">if</span> ((session != <span class="hljs-literal">null</span>) &amp;&amp; (getContext() != <span class="hljs-literal">null</span>)&amp;&amp; getContext().getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.COOKIE)) &#123;<br>        <span class="hljs-comment">// 10. 根据 sessionId 来创建一个 Cookie</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> ApplicationSessionCookieConfig.createSessionCookie(context, session.getIdInternal(), isSecure());<br>        <span class="hljs-comment">// 11. 最后在响应体中写入 cookie</span><br>        response.addSessionCookieInternal(cookie);              <br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (session == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 12. session access 计数器 + 1</span><br>    session.access();                                          <br>    <span class="hljs-keyword">return</span> session;<br>&#125;<br><br><span class="hljs-comment">// 获取 request 对应的 session</span><br><span class="hljs-keyword">public</span> HttpSession <span class="hljs-title function_">getSession</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 这里就是 通过 managerBase.sessions 获取 Session</span><br>    <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> doGetSession(<span class="hljs-literal">true</span>); <br>    <span class="hljs-keyword">if</span> (session == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> session.getSession();<br>&#125;<br><br><span class="hljs-comment">// create 代表是否创建 StandardSession</span><br><span class="hljs-keyword">protected</span> Session <span class="hljs-title function_">doGetSession</span><span class="hljs-params">(<span class="hljs-type">boolean</span> create)</span> &#123;              <br><br>    <span class="hljs-comment">// There cannot be a session if no context has been assigned yet</span><br>    <span class="hljs-comment">// 1. 检验 StandardContext</span><br>    <span class="hljs-keyword">if</span> (context == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span>);                                           <br>    &#125;<br><br>    <span class="hljs-comment">// Return the current session if it exists and is valid</span><br>     <span class="hljs-comment">// 2. 校验 Session 的有效性</span><br>    <span class="hljs-keyword">if</span> ((session != <span class="hljs-literal">null</span>) &amp;&amp; !session.isValid()) &#123;              <br>        session = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> (session);<br>    &#125;<br><br>    <span class="hljs-comment">// Return the requested session if it exists and is valid</span><br>    <span class="hljs-type">Manager</span> <span class="hljs-variable">manager</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (context != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">//拿到StandardContext 中对应的StandardManager，Context与 Manager 是一对一的关系</span><br>        manager = context.getManager();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (manager == <span class="hljs-literal">null</span>)<br>     &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span>);      <span class="hljs-comment">// Sessions are not supported</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (requestedSessionId != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;        <br>            <span class="hljs-comment">// 3. 通过 managerBase.sessions 获取 Session</span><br>            <span class="hljs-comment">// 4. 通过客户端的 sessionId 从 managerBase.sessions 来获取 Session 对象</span><br>            session = manager.findSession(requestedSessionId);   <br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            session = <span class="hljs-literal">null</span>;<br>        &#125;<br>         <span class="hljs-comment">// 5. 判断 session 是否有效</span><br>        <span class="hljs-keyword">if</span> ((session != <span class="hljs-literal">null</span>) &amp;&amp; !session.isValid()) &#123;          <br>            session = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (session != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 6. session access +1</span><br>            session.access();                                    <br>            <span class="hljs-keyword">return</span> (session);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Create a new session if requested and the response is not committed</span><br>    <span class="hljs-comment">// 7. 根据标识是否创建 StandardSession ( false 直接返回)</span><br>    <span class="hljs-keyword">if</span> (!create) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-literal">null</span>);                                           <br>    &#125;<br>    <span class="hljs-comment">// 当前的 Context 是否支持通过 cookie 的方式来追踪 Session</span><br>    <span class="hljs-keyword">if</span> ((context != <span class="hljs-literal">null</span>) &amp;&amp; (response != <span class="hljs-literal">null</span>) &amp;&amp; context.getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.COOKIE) &amp;&amp; response.getResponse().isCommitted()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span><br>          (sm.getString(<span class="hljs-string">&quot;coyoteRequest.sessionCreateCommitted&quot;</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// Attempt to reuse session id if one was submitted in a cookie</span><br>    <span class="hljs-comment">// Do not reuse the session id if it is from a URL, to prevent possible</span><br>    <span class="hljs-comment">// phishing attacks</span><br>    <span class="hljs-comment">// Use the SSL session ID if one is present.</span><br>    <span class="hljs-comment">// 8. 到这里其实是没有找到 session, 直接创建 Session 出来</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-string">&quot;/&quot;</span>.equals(context.getSessionCookiePath()) &amp;&amp; isRequestedSessionIdFromCookie()) || requestedSessionSSL ) &#123;<br>        session = manager.createSession(getRequestedSessionId()); <span class="hljs-comment">// 9. 从客户端读取 sessionID, 并且根据这个 sessionId 创建 Session</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        session = manager.createSession(<span class="hljs-literal">null</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Creating a new session cookie based on that session</span><br>    <span class="hljs-keyword">if</span> ((session != <span class="hljs-literal">null</span>) &amp;&amp; (getContext() != <span class="hljs-literal">null</span>)&amp;&amp; getContext().getServletContext().getEffectiveSessionTrackingModes().contains(SessionTrackingMode.COOKIE)) &#123;<br>        <span class="hljs-comment">// 10. 根据 sessionId 来创建一个 Cookie</span><br>        <span class="hljs-type">Cookie</span> <span class="hljs-variable">cookie</span> <span class="hljs-operator">=</span> ApplicationSessionCookieConfig.createSessionCookie(context, session.getIdInternal(), isSecure());<br>        <span class="hljs-comment">// 11. 最后在响应体中写入 cookie</span><br>        response.addSessionCookieInternal(cookie);              <br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (session == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 12. session access 计数器 + 1</span><br>    session.access();                                          <br>    <span class="hljs-keyword">return</span> session;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ManagerBase</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LifecycleMBeanBase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Manager</span> &#123;<br>    <span class="hljs-comment">// Manager管理着当前Context的所有session，所以会话是被 manager 里存有的一个容器管理的。</span><br>    <span class="hljs-keyword">protected</span> Map&lt;String, Session&gt; sessions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Session <span class="hljs-title function_">findSession</span><span class="hljs-params">(String id)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">if</span> (id == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">//通过JssionId获取session</span><br>        <span class="hljs-keyword">return</span> sessions.get(id);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Session <span class="hljs-title function_">createSession</span><span class="hljs-params">(String sessionId)</span> &#123;<br>        <span class="hljs-comment">// 1. 判断 单节点的 Session 个数是否超过限制</span><br>        <span class="hljs-keyword">if</span> ((maxActiveSessions &gt;= <span class="hljs-number">0</span>) &amp;&amp; (getActiveSessions() &gt;= maxActiveSessions)) &#123;      <br>            rejectedSessions++;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TooManyActiveSessionsException</span>(<br>                    sm.getString(<span class="hljs-string">&quot;managerBase.createSession.ise&quot;</span>),<br>                    maxActiveSessions);<br>        &#125;<br><br>        <span class="hljs-comment">// Recycle or create a Session instance</span><br>        <span class="hljs-comment">// 创建一个 空的 session</span><br>        <span class="hljs-comment">// 2. 创建 Session</span><br>        <span class="hljs-type">Session</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> createEmptySession();                     <br><br>        <span class="hljs-comment">// Initialize the properties of the new session and return it</span><br>        <span class="hljs-comment">// 初始化空 session 的属性</span><br>        session.setNew(<span class="hljs-literal">true</span>);<br>        session.setValid(<span class="hljs-literal">true</span>);<br>        session.setCreationTime(System.currentTimeMillis());<br>        <span class="hljs-comment">// 3. StandardSession 最大的默认 Session 激活时间</span><br>        session.setMaxInactiveInterval(<span class="hljs-built_in">this</span>.maxInactiveInterval); <br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> sessionId;<br>        <span class="hljs-comment">// 若没有从 client 端读取到 jsessionId</span><br>        <span class="hljs-keyword">if</span> (id == <span class="hljs-literal">null</span>) &#123;      <br>            <span class="hljs-comment">// 4. 生成 sessionId (这里通过随机数来生成)    </span><br>            id = generateSessionId();                              <br>        &#125;<br>        <span class="hljs-comment">//这里会将session存入Map&lt;String, Session&gt; sessions = new ConcurrentHashMap&lt;&gt;();</span><br>        session.setId(id);<br>        sessionCounter++;<br><br>        <span class="hljs-type">SessionTiming</span> <span class="hljs-variable">timing</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionTiming</span>(session.getCreationTime(), <span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">synchronized</span> (sessionCreationTiming) &#123;<br>            <span class="hljs-comment">// 5. 每次创建 Session 都会创建一个 SessionTiming, 并且 push 到 链表 sessionCreationTiming 的最后</span><br>            sessionCreationTiming.add(timing); <br>            <span class="hljs-comment">// 6. 并且将 链表 最前面的节点删除        </span><br>            sessionCreationTiming.poll();                         <br>        &#125;      <br>        <span class="hljs-comment">// 那这个 sessionCreationTiming 是什么作用呢, 其实 sessionCreationTiming 是用来统计 Session的新建及失效的频率 (好像Zookeeper 里面也有这个的统计方式)    </span><br>        <span class="hljs-keyword">return</span> (session);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(Session session)</span> &#123;<br>        <span class="hljs-comment">// 将创建的Seesion存入Map&lt;String, Session&gt; sessions = new ConcurrentHashMap&lt;&gt;();</span><br>        sessions.put(session.getIdInternal(), session);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> getActiveSessions();<br>        <span class="hljs-keyword">if</span>( size &gt; maxActive ) &#123;<br>            <span class="hljs-keyword">synchronized</span>(maxActiveUpdateLock) &#123;<br>                <span class="hljs-keyword">if</span>( size &gt; maxActive ) &#123;<br>                    maxActive = size;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id)</span> &#123;<br>    setId(id, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setId</span><span class="hljs-params">(String id, <span class="hljs-type">boolean</span> notify)</span> &#123;<br><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">this</span>.id != <span class="hljs-literal">null</span>) &amp;&amp; (manager != <span class="hljs-literal">null</span>))<br>        manager.remove(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-built_in">this</span>.id = id;<br><br>    <span class="hljs-keyword">if</span> (manager != <span class="hljs-literal">null</span>)<br>        manager.add(<span class="hljs-built_in">this</span>);<br><br>    <span class="hljs-keyword">if</span> (notify) &#123;<br>        tellNew();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>tomcat8.5 提供了 4 种实现，默认使用 StandardManager，tomcat 还提供了集群会话的解决方案，但是在实际项目中很少运用。</p>
<ul>
<li>StandardManager：Manager 默认实现，在内存中管理 session，宕机将导致 session 丢失；但是当调用 Lifecycle 的 start/stop 接口时，将采用 jdk 序列化保存 Session 信息，因此当 tomcat 发现某个应用的文件有变更进行 reload 操作时，这种情况下不会丢失 Session 信息</li>
<li>DeltaManager：增量 Session 管理器，用于Tomcat集群的会话管理器，某个节点变更 Session 信息都会同步到集群中的所有节点，这样可以保证 Session 信息的实时性，但是这样会带来较大的网络开销</li>
<li>BackupManager：用于 Tomcat 集群的会话管理器，与DeltaManager不同的是，某个节点变更 Session 信息的改变只会同步给集群中的另一个 backup 节点</li>
<li>PersistentManager：当会话长时间空闲时，将会把 Session 信息写入磁盘，从而限制内存中的活动会话数量；此外，它还支持容错，会定期将内存中的 Session 信息备份到磁盘。</li>
</ul>
<p><img src="StandardManager%E7%B1%BB%E5%9B%BE.png" alt="StandardManager类图"></p>
<p>本文的主要参考文献：</p>
<ol>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html">《浏览器同源政策及其规避方法》</a></li>
<li><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/04/cors.html">《跨域资源共享 CORS 详解》</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">《浏览器的同源策略》</a></li>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests">《Cross-Origin Resource Sharing (CORS)》</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/java-chen-hao/p/11316172.html">Tomcat源码分析 （十）----- 彻底理解 Session机制</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2018/02/05/%E8%B7%A8%E5%9F%9F%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98/">https://magicliang.github.io/2018/02/05/%E8%B7%A8%E5%9F%9F%E4%B8%8E%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E9%97%AE%E9%A2%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-8.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/11/14/KOA-%E5%88%9D%E6%8E%A2/" title=" KOA 初探"><img class="cover" src="/img/wall-paper-164.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-14</div><div class="info-item-2"> KOA 初探</div></div><div class="info-2"><div class="info-item-1">  KOA 是 express 的进化版。都是被作者玩腻了扔掉的东西。   它简化了各个中间件层面的工作，提供了高级的“糖”，把各个中间件转化为了函数。 123456789101112131415161718192021222324252627282930313233const Koa = require(&#x27;koa&#x27;);const app = new Koa();// x-response-timeapp.use(async (ctx, next) =&gt; &#123;    const start = Date.now();    // 到这里就停住了运行，让下一个中间件函数运行。    await next();    // 从下一个中间件函数那里返回    const ms = Date.now() - start;    ctx.set(&#x27;X-Response-Time&#x27;, `$&#123;ms&#125;ms`);&#125;);// loggerapp.use(async (ctx, next) =&gt; &#123;  ...</div></div></div></a><a class="pagination-related" href="/2017/12/12/JSX/" title="JSX"><img class="cover" src="/img/wall-paper-23.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-12-12</div><div class="info-item-2">JSX</div></div><div class="info-2"><div class="info-item-1">简介   JSX 是点缀着 XML 元素的 JavaScript。它是由 React 这个库最初构思出来的，但又不是专门为了某个库或者框架设计的。它是一种 DSL。   JSX 是 html in JavaScript 的一种很好体现。这里的 XML，实际上还是 html 元素。粗略看下来，和当初 backbone 写 rendertemplate 的函数差不多。要引入 JSX 的语法，在很多场景下都要引入 Babel 这个 transpiler，也就是要搞到工具链满天飞。照抄官网的例子的话，可以看到： 12345678910111213141516171819&lt;!DOCTYPE html&gt;  &lt;html&gt;  &lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot; /&gt;    &lt;title&gt;Hello React!&lt;/title&gt;    &lt;script src=&quot;vendor-js/react.js&quot;&gt;&lt;/script&gt;    &lt;s...</div></div></div></a><a class="pagination-related" href="/2018/01/30/Vue-%E5%80%BC%E5%BE%97%E6%B3%A8%E6%84%8F%E7%9A%84%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/" title="Vue 值得注意的小知识点"><img class="cover" src="/img/wall-paper-138.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-01-30</div><div class="info-item-2">Vue 值得注意的小知识点</div></div><div class="info-2"><div class="info-item-1">  this.$el.querySelector(’#map’) 只能查找第一个 dom 以内的 dom 节点，不包括当前的 dom。   在 webpack:// 这个域下可以看到可调式的 vue 文件。   </div></div></div></a><a class="pagination-related" href="/2018/02/03/Echart-%E8%AF%8D%E6%B1%87%E8%A1%A8/" title="Echart 词汇表"><img class="cover" src="/img/wall-paper-36.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-02-03</div><div class="info-item-2">Echart 词汇表</div></div><div class="info-2"><div class="info-item-1">emphasis n 强调 roam 漫游 scatterplot 散点图 effectscatter 特效散点 </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">什么是同源策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">同源策略的变化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E5%A4%A7%E5%A4%9A%E6%95%B0%E5%85%B3%E4%BA%8E%E8%AF%BB-%E8%80%8C%E4%B8%94%E5%90%8C%E6%BA%90%E6%80%BB%E8%83%BD%E7%94%A8%E6%B2%99%E7%AE%B1%E8%A7%A3%E9%87%8A"><span class="toc-number">2.1.</span> <span class="toc-text">同源策略大多数关于读，而且同源总能用沙箱解释</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E5%AD%98%E5%82%A8%E5%92%8C%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-number">2.2.</span> <span class="toc-text">限制存储和当前页面的资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dom-%E8%AE%BF%E9%97%AE%E9%99%90%E5%88%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">DOM 访问限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E9%99%90%E5%88%B6"><span class="toc-number">2.2.2.</span> <span class="toc-text">数据存储限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%99%E7%AE%B1%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6%E7%BD%91%E7%BB%9C%E8%AF%BB%E5%86%99"><span class="toc-number">2.3.</span> <span class="toc-text">沙箱如何限制网络读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E6%BA%90%E5%86%99%E6%93%8D%E4%BD%9C-cross-origin-writes"><span class="toc-number">2.3.1.</span> <span class="toc-text">跨源写操作 (Cross-origin Writes)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E6%BA%90%E8%AF%BB%E6%93%8D%E4%BD%9C-cross-origin-reads"><span class="toc-number">2.3.2.</span> <span class="toc-text">跨源读操作 (Cross-origin Reads)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%A8%E6%BA%90%E8%B5%84%E6%BA%90%E5%B5%8C%E5%85%A5-cross-origin-embedding"><span class="toc-number">2.3.3.</span> <span class="toc-text">跨源资源嵌入 (Cross-origin Embedding)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%8F%97%E5%90%8C%E6%BA%90%E9%99%90%E5%88%B6%E7%9A%84%E4%BE%8B%E5%A4%96"><span class="toc-number">2.4.</span> <span class="toc-text">不受同源限制的例外</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#websocket"><span class="toc-number">2.4.1.</span> <span class="toc-text">WebSocket</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88-websocket-%E4%B8%8D%E9%9C%80%E8%A6%81-sop-%E4%BF%9D%E6%8A%A4%EF%BC%9F"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">核心问题：为什么 WebSocket “不需要” SOP 保护？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#http-%E8%AF%B7%E6%B1%82-ajax-fetch-%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%EF%BC%9A%E8%AF%B7%E6%B1%82%E5%90%8E%E9%AA%8C%E8%AF%81"><span class="toc-number">2.4.1.1.1.</span> <span class="toc-text">HTTP 请求 (AJAX&#x2F;Fetch) 的安全模型：请求后验证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#websocket-%E7%9A%84%E5%AE%89%E5%85%A8%E6%A8%A1%E5%9E%8B%EF%BC%9A%E8%BF%9E%E6%8E%A5%E5%89%8D%E9%AA%8C%E8%AF%81"><span class="toc-number">2.4.1.1.2.</span> <span class="toc-text">WebSocket 的安全模型：连接前验证</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.4.1.2.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#preflight-%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">preflight 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88"><span class="toc-number">2.5.1.</span> <span class="toc-text">为什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E7%AE%80%E5%8D%95%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82"><span class="toc-number">2.5.2.</span> <span class="toc-text">非简单跨域请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%8F%91%E7%94%9F-preflight%EF%BC%9F"><span class="toc-number">2.5.3.</span> <span class="toc-text">触发条件：为什么会发生 Preflight？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.5.4.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E7%9A%84%E8%AF%B7%E6%B1%82%E5%A4%B1%E8%B4%A5%E4%BA%86%EF%BC%9F"><span class="toc-number">2.5.5.</span> <span class="toc-text">问题排查：为什么我的请求失败了？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">2.5.6.</span> <span class="toc-text">简单请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">2.5.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#options-%E9%97%AE%E9%A2%98"><span class="toc-number">2.6.</span> <span class="toc-text">options 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E8%A7%92%E8%89%B2%EF%BC%9Acors-%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82-preflight"><span class="toc-number">2.6.1.</span> <span class="toc-text">主要角色：CORS 预检请求 (Preflight)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B%E8%A7%92%E8%89%B2%EF%BC%9A%E6%9F%A5%E8%AF%A2%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%83%BD%E5%8A%9B"><span class="toc-number">2.6.2.</span> <span class="toc-text">原始角色：查询服务器能力</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%91%E8%AE%BE%E6%96%BD%E4%B8%8B%E7%9A%84%E9%85%8D%E7%BD%AE"><span class="toc-number">2.7.</span> <span class="toc-text">云设施下的配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E6%98%AF%E4%B8%80%E7%A7%8D%E5%A5%BD%E6%96%B9%E6%B3%95%EF%BC%9F"><span class="toc-number">2.7.1.</span> <span class="toc-text">为什么这是一种好方法？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB-separation-of-concerns"><span class="toc-number">2.7.1.1.</span> <span class="toc-text">关注点分离 (Separation of Concerns)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%8C%96%E7%AE%A1%E7%90%86%E4%B8%8E%E4%B8%80%E8%87%B4%E6%80%A7"><span class="toc-number">2.7.1.2.</span> <span class="toc-text">集中化管理与一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">2.7.1.3.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">2.7.1.4.</span> <span class="toc-text">安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8C%96%E5%BC%80%E5%8F%91"><span class="toc-number">2.7.1.5.</span> <span class="toc-text">简化开发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%9C%A8%E4%BB%A3%E7%A0%81%E4%B8%AD%E5%A4%84%E7%90%86-cors-%E4%BB%8D%E7%84%B6%E6%9C%89%E6%84%8F%E4%B9%89%EF%BC%9F"><span class="toc-number">2.7.2.</span> <span class="toc-text">什么时候在代码中处理 CORS 仍然有意义？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%92%8C%E7%B2%BE%E7%BB%86%E5%8C%96%E7%9A%84-cors-%E7%AD%96%E7%95%A5%EF%BC%9A"><span class="toc-number">2.7.2.1.</span> <span class="toc-text">动态和精细化的 CORS 策略：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E5%8D%95%E4%BD%93%E5%BA%94%E7%94%A8%EF%BC%9A"><span class="toc-number">2.7.2.2.</span> <span class="toc-text">简单的单体应用：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AC%E5%9C%B0%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%EF%BC%9A"><span class="toc-number">2.7.2.3.</span> <span class="toc-text">本地开发环境：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">如何绕开同源策略限制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%AE%E6%94%B9%E6%BA%90"><span class="toc-number">3.1.</span> <span class="toc-text">修改源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iframe"><span class="toc-number">3.2.</span> <span class="toc-text">iframe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E7%9A%84-%E4%B8%8D%E7%BB%8F%E6%8E%88%E6%9D%83%E7%9A%84-js-%E7%89%87%E6%AE%B5%E8%AF%BB%E5%8F%96%E5%86%85%E5%AD%98%E9%87%8C%E7%9A%84%E4%BF%A1%E6%81%AF-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.</span> <span class="toc-text">经典的“不经授权的 js 片段读取内存里的信息”的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ajax-%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">3.4.</span> <span class="toc-text">AJAX 的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95-header-%E5%92%8C%E9%9D%9E%E7%AE%80%E5%8D%95-header"><span class="toc-number">3.4.1.</span> <span class="toc-text">简单 header 和非简单 header</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%81%93%E5%85%B3%E5%8D%A1%EF%BC%9A%E7%AE%80%E5%8D%95%E5%93%8D%E5%BA%94%E5%A4%B4-simple-response-headers"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">第一道关卡：简单响应头（Simple Response Headers）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%81%93%E5%85%B3%E5%8D%A1%EF%BC%9A%E6%9A%B4%E9%9C%B2%E9%9D%9E%E7%AE%80%E5%8D%95%E5%93%8D%E5%BA%94%E5%A4%B4-non-simple-headers"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">第二道关卡：暴露非简单响应头（Non-Simple Headers）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-%E9%80%9A%E8%A1%8C%E8%AF%81"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">如何解决？—— 服务器的“通行证”</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jsonp"><span class="toc-number">3.4.2.</span> <span class="toc-text">JSONP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%B7%E5%9B%A0"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">起因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%9A%E5%AE%9A%E4%B9%89%E5%87%BD%E6%95%B0-%E4%B8%8A%E6%96%87-%E5%B9%B6%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82"><span class="toc-number">3.4.2.2.1.</span> <span class="toc-text">客户端：定义函数（上文）并发起请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%EF%BC%9A%E7%94%9F%E6%88%90%E8%B0%83%E7%94%A8%E4%BB%A3%E7%A0%81-%E4%B8%8B%E6%96%87"><span class="toc-number">3.4.2.2.2.</span> <span class="toc-text">服务器端：生成调用代码（下文）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%BC%B1%E7%82%B9%E4%B8%8E%E7%8E%B0%E4%BB%A3%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">核心弱点与现代替代方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9Acors"><span class="toc-number">3.4.2.4.</span> <span class="toc-text">现代替代方案：CORS</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%8A%E6%8E%A7%E5%88%B6%E6%9D%83%E6%94%BE%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%AB%AF-cors-%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.4.2.4.1.</span> <span class="toc-text">把控制权放在服务端（CORS 模型）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cors-cross-origin-resource-sharing"><span class="toc-number">3.4.2.5.</span> <span class="toc-text">CORS(Cross-Origin Resource Sharing)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">3.4.2.6.</span> <span class="toc-text">简单请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82"><span class="toc-number">3.4.2.7.</span> <span class="toc-text">非简单请求</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">附一个小问题：CSRF 攻防问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">tomcat 关于会话的实现</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>