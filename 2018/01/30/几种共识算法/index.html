<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>几种共识算法 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="达成共识的英文原文是 come to consensus。达成共识以后，也未必代表数据是完全一致的（Raft 算法中 leader 发出 append log 的 commit 命令即算达成共识？但如果中途数据丢失，则还是会有子节点数据不一致）。 在分布式环境下，多个系统协同工作的效率，受制于系统交叉点的性能。在需要达成分布式共识的场景下，分布式共识算法在保证系统安全性的同时，限制了全系统横向扩展">
<meta property="og:type" content="article">
<meta property="og:title" content="几种共识算法">
<meta property="og:url" content="https://magicliang.github.io/2018/01/30/%E5%87%A0%E7%A7%8D%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="达成共识的英文原文是 come to consensus。达成共识以后，也未必代表数据是完全一致的（Raft 算法中 leader 发出 append log 的 commit 命令即算达成共识？但如果中途数据丢失，则还是会有子节点数据不一致）。 在分布式环境下，多个系统协同工作的效率，受制于系统交叉点的性能。在需要达成分布式共识的场景下，分布式共识算法在保证系统安全性的同时，限制了全系统横向扩展">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-168.jpg">
<meta property="article:published_time" content="2018-01-30T05:59:56.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:31.905Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="区块链">
<meta property="article:tag" content="consensus">
<meta property="article:tag" content="系统架构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-168.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "几种共识算法",
  "url": "https://magicliang.github.io/2018/01/30/%E5%87%A0%E7%A7%8D%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/",
  "image": "https://magicliang.github.io/img/wall-paper-168.jpg",
  "datePublished": "2018-01-30T05:59:56.000Z",
  "dateModified": "2025-10-22T08:01:31.905Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2018/01/30/%E5%87%A0%E7%A7%8D%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '几种共识算法',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-168.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">几种共识算法</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">几种共识算法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2018-01-30T05:59:56.000Z" title="Created 2018-01-30 13:59:56">2018-01-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:31.905Z" title="Updated 2025-10-22 16:01:31">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">6.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>22mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>达成共识的英文原文是 come to consensus。达成共识以后，也未必代表数据是完全一致的（Raft 算法中 leader 发出 append log 的 commit 命令即算达成共识？但如果中途数据丢失，则还是会有子节点数据不一致）。</p>
<p>在分布式环境下，多个系统协同工作的效率，受制于系统交叉点的性能。在需要达成分布式共识的场景下，分布式共识算法在保证系统安全性的同时，限制了全系统横向扩展的性能提升。</p>
<p>根据环境的不同，可以应用不同的共识算法。</p>
<p>在完全互信的环境下-私有链、私有的分布式数据库，节点之间可以使用 Paxos 或者 Raft 这种 leader 相对固定的算法。</p>
<p>在有限互信的环境下-联盟链，可以使用 PBFT。PBFT 算法是依据确定性的投票（可能是漫长的投票，也可能进入死循环）达到确定性一致的算法。</p>
<p>在没有互信的情况下-公有链，可以使用 POW/POS/DPOS/POA。这类算法是基于概率得到正确的最终一致性，性能比 PBFT 要稍微好点。</p>
<p>最好的共识算法应该模块化，例如 Corda 中的 notary，Hyperledger fabric 中的 solo/kafka。</p>
<h2 id="flp-impossibility-flp-不可能定理">FLP Impossibility（FLP 不可能定理）</h2>
<p>FLP 是三个作者的名字。</p>
<blockquote>
<p>FLP Impossibility（FLP不可能性）是分布式领域中一个非常著名的结果，该结果在专业领域被称为“定理”，其地位之高可见一斑。该定理的论文是由Fischer, Lynch and Patterson三位作者于1985年发表,之后该论文毫无疑问得获得了Dijkstra奖。</p>
</blockquote>
<blockquote>
<p>顺便要提一句的是，Lynch是一位非常著名的分布式领域的女性科学家，研究遍布分布式的方方面面，对分布式领域有着极其卓越的贡献，其著有&quot;Distributed Algorithms&quot;一书，书中有非常严谨而简洁的逻辑讨论了许许多多的分布式算法。</p>
</blockquote>
<blockquote>
<p>FLP给出了一个令人吃惊的结论：在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！</p>
</blockquote>
<blockquote>
<p>因为同步通信中的一致性被证明是可以达到的，因此在之前一直有人尝试各种算法解决以异步环境的一致性问题，有个FLP的结果，这样的尝试终于有了答案。</p>
</blockquote>
<blockquote>
<p>FLP证明最难理解的是没有一个直观的sample，所有提到FLP的资料中也基本都回避了sample的要求。究其原因，sample难以设计，除非你先设计几种一致性算法，并用FLP说明这些算法都是错误的。</p>
</blockquote>
<p>只要记住这样一个结论即可：<strong>在异步通信场景，即使只有一个进程失败，也没有任何算法能保证非失败进程达到一致性！</strong></p>
<p>换言之，Paxos 为代表的协议，都只能保证极大概率不出错达到一致性，不能保证真正的一致性。</p>
<h2 id="可信环境下的共识算法">可信环境下的共识算法</h2>
<p>可信环境下，节点只会故障（fault），不存在恶意节点（corrupt），可能存在丢失消息或者不响应，不会出现恶意的错误信息。</p>
<h3 id="paxos-算法">Paxos 算法</h3>
<p>Paxos 算法假定有一个全局能够自动生成递增消息编号的服务。</p>
<p>Paxos 算法把角色分为 proposer、acceptor 和 learner。这三种角色都可以有多个节点以避免单点故障，Paxos 算法的目的就是如果多个 proposer 在异步网络环境下有多个提案，怎样让 proposer/acceptor 最终选出一个，然后让 learner 知晓。</p>
<p>Acceptor 可以应对两种请求：</p>
<ul>
<li>prepare 请求，承诺一个 proposer 不再accept编号低于某个值的提案，并返回目前批准最大编号提案的值。</li>
<li>accept 请求，如果没有 prepare 过编号大于 N 的提案，而 N 又是可以被批准的（也就是恰好足以成为最大的编号的），则可以 accept 这条提案，这个proposer 应该就可以结束 prepare 和 accept 了，由其他 proposer 继续这个两阶段的旅程，直到这个过程终止。</li>
</ul>
<p>proposer 就是不断地先向 majority 发出 prepare 请求，然后如果得到了一个 chosen 值，就不断地持续地向 majority广播 chosen 值，直到它被majority accept。acceptor 就在 proposer 逐渐变得一致的过程中，达到一个有 majority 的批准值。</p>
<p>如果两个 proposer1 完成了消息1 prepare，acceptor 又 prepare 了一个更高的 proposer2 的消息2，而会直接拒绝掉 proposer 1 的 accept 消息1，于是proposer 1 提出消息3（这个 retry 机制很有意思，因为 proposer 被拒绝以后并不是直接去询问当前高序号的值，而是用一个更高序号的值去 prepare 来询问 ），让 proposer 的消息2 accept 又失败，于是就产生了活锁。Paxos 无法终止，因为恰好每个 prepare 和 accept 的间隙都被对方给否定掉了。虽然 lamport 证明了在数学上算法应该可以收敛，但受环境所限，并不一定在现实中就必然会收敛。</p>
<h3 id="raft-算法">Raft 算法</h3>
<p><a target="_blank" rel="noopener" href="https://www.infoq.cn/article/raft-paper">论文中文版</a></p>
<p>Raft 简化 Paxos 的地方在于，它不再是一个多轮多 proposer 达到一致的算法，而是先用 leader election 来制造单一的 trust source，然后由统一的 trust source 发号施令，确定分布式场景下数据的顺序和对错的算法。这个 leader 也避免了活锁的存在。Raft 只是更好理解，属于Paxos 的一个特例场景变种，但并不更容易实现。</p>
<p>Raft 是先做 election，再做 log replication 的。</p>
<p>Raft 有三种角色，follower、candidate、leader。如果 follower 没有收听到 leader 的心跳，那么它就可以假设 leader 不在了（即使它只是因为处在一个 network partition 里，接收不到 leader 的 heartbeat），转变为 candidate，自行发动选举，能不能选举完成，要看自己所在的分区是不是多数分区。系统总是从一群 term 为0 的 follower 开始的，所以系统初始化的时候就会直接开始一场选举。</p>
<p>选举有两个超时。</p>
<p>一个叫<strong>election timeout</strong>，就是 follower 忍受 leader 不发心跳给自己，变成 candidate 的时长。不同的 follower 的忍受时长不一样，在150ms 到300ms 之间徘徊， 这就导致了有的 follower 变成 candidate 的时间早，有的变成 candidate 的时间短。follower 变成 candidate 第一件事就是选自己，然后把 vote request 发给其他节点，其他节点即使现在还是 follower/candidate 状态，收到 vote request，如果没有投过票，也会立即进入下一个 term 的投票，直接把票投给第一个给自己发 vote request 的节点，自己依然保持 follower/candidate 状态。任意一个 candidate 收到定制拓扑结构里面的多数投票就会自封为 leader。因为其他节点已经投给了别人，所以他们只能乖乖做 follower，接收他们选的 leader 发送过来的信息。</p>
<p>另一个 timeout 叫<strong>heartbeat timeout</strong>。leader 发送的信息叫做 Append Entries（类似 Kafka 的 appending log），这些信息本身要跟随心跳信息被发送，follower 本身也要发送 response 给 leader。</p>
<p>如果节点出现了一个 term 的选举平局，则这一轮已无法再投票。需要等到下一轮超时，再投一次，产生自封的 leader。感觉上这里就会产生两个问题，首先，自封的 leader 完全可以自称，这就不能解决 bft 问题，其次，这个选举的平局几乎可以无限地进行下去。</p>
<p>一旦一个客户端往 leader 发信息，则 leader 会先在自己的 log 上预 append，然后把 log 通过消息发送给 follower，follower 也都预 append 以后发送 acknowledgement 给 leader。leader 收到多数 acknowledgement 以后就在本地完成提交，然后先把 response 发给客户端，然后告知 follower 把预提交的信息完全提交上去（真 commit）。这也是一个两阶段提交的步骤，但和传统的两阶段提交的算法不一样的是，它的 coordinator 不是固定的，它收集 acknowledgement 并不是收集全部的，而是收集 majority，这就不能保证强一致性。它的最后发送真 commit 本身，也是像传统的两阶段提交算法一样，是不看最后的 acknowledgement 的。难道这些 log 本身是编好序号的？</p>
<p>如果真的出现了网络分区，则小分区的 leader 即使不知道新的 leader 已经产生了，还能以蒙在鼓里的形式继续跟小分区里的 follower 继续通信，也无法真的更新自己的 log 和 follower 的 log，因为它收集不到足够多的 acknowledgement。</p>
<p>假设系统已经有了 leader，则 leader 有自己的任期（term），高任期的 leader 会自动打败低任期的 leader。leader 一定要定时地发送自己的心跳数据给 follower，以告知它们自己这一任 leader 还活着，不然系统中会产生新的 leader。</p>
<h2 id="在有限互信的环境下的共识算法">在有限互信的环境下的共识算法</h2>
<p>Bazantine General Problem 问题，是1982年 Leslie Lamport 提出的一个解释一致性问题的虚构模型。</p>
<p>对于拜占庭问题来说，假如节点总数为 N，叛变将军数为 F，则当 N &gt;= 3F + 1时，问题才有解，即 Byzantine Fault Tolerant (BFT) 算法。</p>
<p>据说有一种最直观的理解是，假设 N 为3，而 F 为1。A、B、C三个人里面有C会说谎，A、B 都向其他人广播1，而 C 广播 0，则 A 会受到一个1 和 0，B 也会收到一个 1 和 0，A 和 B 都无法判定谁是叛徒。可是 A 在收到1和发出1的时候，难道不能认定自己的1是多数派么？</p>
<p>PBFT 全称是 Practical Byzantine Fault Tolerant，由 Castro 和 Liskov 在1998年提出，是第一个得到广泛应用的 BFT 算法，只要系统中有2/3的节点是正常工作的，则可以保证一致性。</p>
<p>超级账本相关项目大量采用 <a target="_blank" rel="noopener" href="https://www.hyperledger.org/wp-content/uploads/2017/08/Hyperledger_Arch_WG_Paper_1_Consensus.pdf">BFT 相关算法</a>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/diegomasini/hyperledger-fabric/blob/master/docs/FAQ/consensus_FAQ.md">Fabric 采用的是可插拔共识算法架构，目前包括三种具体算法</a>：</p>
<ol>
<li>No-op (consensus ignored)（无操作共识机制？）</li>
<li>SBFT（Zyzzyva 的实现，还未到来）</li>
<li>SIEVE (an enhanced version of classic PBFT)（还未到来）。</li>
</ol>
<p>传统的 BFT 算法的时间复杂度是 O（N*N），<a href="EOS%E5%A3%B0%E7%A7%B0%E7%9A%84%E6%AF%8F%E7%A7%92%E7%99%BE%E4%B8%87%E7%BA%A7%E7%9A%84%E4%BA%A4%E6%98%93%E9%80%9F%E5%BA%A6%E9%9D%A0%E8%B0%B1%E4%B9%88%EF%BC%9F%20-%20maxdeath%E7%9A%84%E5%9B%9E%E7%AD%94%20-%20%E7%9F%A5%E4%B9%8E%20https://www.zhihu.com/question/265927960/answer/302336312">平方复杂度的算法导致它极难横向扩展。因为 n 个节点，每个节点都要广播给所有其他节点知晓自己的信息，必然导致 n*n 次通信</a>。</p>
<h2 id="在没有互信的情况下的共识算法">在没有互信的情况下的共识算法</h2>
<p>这些不同的算法，可以说都是在公有链上的挖矿算法。挖矿有几层含义：</p>
<ul>
<li>替别人产生了价值（公允的记账）。</li>
<li>为自己挣得了奖励。</li>
<li>能够在挖矿过程中梳理交易，防止双花攻击。</li>
</ul>
<p>这些算法本质上都是博弈算法。总是要让参与出块决策的参与者们拿出一些高于某个门槛的抵押物，在算法中靠抵押物和少数服从多数的认同达到共识和服从。</p>
<h3 id="pow-proof-of-work">PoW（Proof of Work）</h3>
<p>PoW 的抵押物是电。每个矿工拿出算力出来寻找随机数，找到随机数的矿工用自说明的区块向其他矿工展示自己消耗的算力，其他矿工通过重复演算确认区块的合法性。</p>
<p>PoW 是中本聪最初设计出来，让每一个比特币钱包的拥有者能够参与整个系统的决策机制-也就是说，他没有料想到职业矿工、加强型矿机甚至矿池的出现。即使是发生了节点故障，或者有人作恶，只要有超过百分之五十一的节点能够健康工作，这个网络就是健康的。</p>
<p>PoW 到现在为止暴露出的弊端是：</p>
<ul>
<li>中本聪设计 PoW 的构想里面，节点和算力是均匀分布的，网络最终会发展成最大限度的去中心化民主制度。但现实之中，大型矿池的出现，使得几个利益集团可以操控整个网络的发展。</li>
<li>太耗电了。</li>
<li>事实上导致了全网真正确认的速度变得非常慢。因为算力竞赛的胜者，要等待全网中大部分非信任节点把被挖出来的区块加入他们的主 链条（canonical chain）中，还要防止分叉出现。即使横向扩展网络中机器的规模，也无法解决这个问题。</li>
</ul>
<h3 id="pos-proof-of-stake">PoS（Proof of Stake）</h3>
<p>PoS 是个权益证明算法。</p>
<p>它是要求公有链上的 validator 把他们的经济权益抵押在链上的共识算法。</p>
<p>在 PoS 的算法下，一系列的 validator 提议区块，并给区块投票。投票的权重由他们抵押在这次投票里的权益决定。</p>
<p>任何持有以太坊基本货币的人都可以成为 validator。他们只要发起一个特殊的事务把他们的以太币<strong>锁</strong>起来，然后就可以开始共识算法了。</p>
<p>从算法的角度来看，主要有两类 PoS 算法：</p>
<ul>
<li>基于链的</li>
<li>BFT 风格的</li>
</ul>
<p>基于链的PoS 里，算法在每个时间槽伪随机地选择一个 validator。由这个 validator 来指定下一个区块是怎么样的（通常基于已知的最长链的最后一个区块）。那么投票在哪里呢？所以这种算法是不够安全的。</p>
<p>BFT 风格的 PoS 里，validator 被真正随机地被选出来提议区块，但哪个区块被加到主链上，是由多轮投票决定的。这个算法才是现在以太坊的 PoS 基础。</p>
<h4 id="pos-相对于-pow-的优点是什么？">PoS 相对于 Pow 的优点是什么？</h4>
<ol>
<li>省电。</li>
<li>不需要增发新的货币-实际上现在很多 ICO 里都留有货币增发的口子，就是为了不断激励矿工。</li>
<li>可以从博弈论机制设计的角度来防止中心化的卡泰尔出现。</li>
</ol>
<h4 id="pos-是如何融入传统的拜占庭容错研究-成果-的？">PoS 是如何融入传统的拜占庭容错研究（成果）的？</h4>
<p>其实 PoW 是依赖于同步网络模型的。网络延迟越高，容错性越低。如果网络延迟等于出块时间，整个系统的容错性降为0。</p>
<blockquote>
<p>Proof of work has been rigorously analyzed by Andrew Miller and others and fits into the picture as an algorithm reliant on a synchronous network model. We can model the network as being made up of a near-infinite number of nodes, with each node representing a very small unit of computing power and having a very small probability of being able to create a block in a given period. In this model, the protocol has 50% fault tolerance assuming zero network latency, ~46% (Ethereum) and ~49.5% (Bitcoin) fault tolerance under actually observed conditions, but goes down to 33% if network latency is equal to the block time, and reduces to zero as network latency approaches infinity.</p>
</blockquote>
<p>PoS 算法更加贴近拜占庭共识模型。</p>
<p>PoW 算法是 AP 的算法。BFT 风格的共识算法更加贴近一致性（依然保证可用性）。</p>
<h4 id="什么是利益无关问题-以及如何解决它">什么是利益无关问题，以及如何解决它</h4>
<p>在 PoW 模型下，一个利益相关者不可能给每个区块都下注，因为分散下注需要分散电力，这在经济上并不划算。但如果 PoS 模型不做一些准备措施，那么在分布式环境下下注也可以以以类似双花攻击（甚至是多花攻击）的方式存在，这样的行为如果不受到惩罚，实际上是给产生共识制造障碍。</p>
<p>第一种解法，Slasher。不允许一个 validator 试图同时创建两条链。但这要求 validator 在分叉发生前就选好，而且两条分叉链上的 validator 都必须一样。</p>
<p>第二种方法就很简明了。猜对链条的人得到 +R 的奖励，猜错的人受到 -F（可以等于 R） 的惩罚。</p>
<h4 id="所以这和拜占庭容错理论有什么关系？">所以这和拜占庭容错理论有什么关系？</h4>
<p>传统的拜占庭理论可以证明，“如果一个系统有安全鼓掌，那么最少三分之一的节点是有过失的”。而 BFT 风格的 PoS 算法则试图证明，“如果一个系统有安全鼓掌，那么最少三分之一的节点是有过失的，而且你知道哪些节点有过失，即使你在故障发生时不在线”。（译者按：这简直就是记名投票）。</p>
<p>PoS 技术说明的<a target="_blank" rel="noopener" href="https://github.com/ethereum/wiki/wiki/Proof-of-Stake-FAQ">英文</a>和<a target="_blank" rel="noopener" href="http://www.8btc.com/proof-stake-learned-love-weak-subjectivity">中文版本</a>。</p>
<h4 id="看了那么多-pos-到底是怎么工作的呢？">看了那么多 PoS 到底是怎么工作的呢？</h4>
<p><img src="https://ws1.sinaimg.cn/large/66dd581fly1fnxm6v36sdj215y1b4q5b.jpg" alt=""></p>
<p>PoS 里的 validator 不再被称作 miner，而被称作 forger。</p>
<p>在所有货币都预售了的系统里面，PoS 是没有区块奖励的（挖矿有点名不副实了），只赚手续费。</p>
<p>所有人如果想成为 validator，可以加入一个 validator 池，然后总会被选上：</p>
<blockquote>
<p>“You automatically get inducted after some time,” explained Vitalik Buterin himself on a post shared on Reddit.</p>
</blockquote>
<p>Casper 是带有惩罚机制的 PoS 算法。系统会挑出它认为做了坏事的 validator，扣除它的准备金赌注，并取消掉它成为 validator 的资格（这有什么意义？）。具体步骤：</p>
<blockquote>
<p>The validators stake a portion of their Ethers as stake.<br>
After that, they will start validating the blocks. Meaning, when they discover a block which they think can be added to the chain, they will validate it by placing a bet on it.<br>
If the block gets appended, then the validators will get a reward proportionate to their bets.<br>
However, if a validator acts in a malicious manner and tries to do a “nothing at stake”, they will immediately be reprimanded, and all of their stake is going to get slashed.</p>
</blockquote>
<p>恶意攻击被称作Malicious manner 或者 Byzantine manner。</p>
<p>在出现惩罚措施以前，nothing at stake 问题使得攻击 PoS 网络变得很简单，惩罚措施试图使得全网的共识更加像 PoW。在 PoS 中，51%攻击的必要条件是，一个人必须有全网51%的货币。</p>
<p>Casper 的两种版本 Casper FFG 和 Casper CBC，详情见<a target="_blank" rel="noopener" href="https://blockgeeks.com/guides/ethereum-casper/">本文</a>。</p>
<p>Casper 和 Pow 一样，都会造成富者愈富-Pow 本身已经让很多矿池成为 cartel<br>
了。</p>
<h3 id="poa-proof-of-authority">PoA（Proof of Authority）</h3>
<p>PoA 算法指的是网络里有些预先批准节点（sealers），新的签名者 加入网络必须经过老的 sealer 批准。这样其实就制造了一个严格控制的网络环境。为了防止坏节点破坏网络，一个签名者只能签署一定数量的连续区块（(floor(SIGNER_COUNT / 2) + 1)）<strong>中的最多一个区块</strong>。换言之，心怀恶意的攻击无法防御，只能被这种设计有限控制。</p>
<p>以太坊的 PoA 算法被称作 Clique 协议，协议的描述在<a target="_blank" rel="noopener" href="https://github.com/ethereum/EIPs/issues/225">这里</a>，它还产生了一个<a target="_blank" rel="noopener" href="https://rinkeby.io/">Rinkeby test network</a>。这个测试网络每15秒出一个块，和主网的<code>ethash</code>想要达到的目标一致。</p>
<p>是不是 PoS 永远不能升级到 PoA 了？PoA 是不是就是为了联盟链设计的？</p>
<p>另外一篇<a target="_blank" rel="noopener" href="http://blog.enuma.io/update/2017/08/29/proof-of-authority-ethereum-networks.html">描述了 Clique 用法的文</a>。</p>
<p>接下来我们来好好描述 Clique 的具体细节：</p>
<h4 id="授权-即签署-区块">授权（即签署）区块</h4>
<p>要为网络签署一个区块，一个签名者要给一个包含一切数据（偏偏不包含签名本身）的哈希值签名。这这意味着这个哈希值包含了块头部的一切字段（包括<code>nonce</code>和<code>mixDigest</code>），以及除了65字节后缀以外的 <code>extraData</code>。这些字段按照黄皮书里定义的顺序被散列（译者按：类似比特币的试算算法）。</p>
<p>这个哈希值用标准的<code>secp256k1</code>曲线（椭圆曲线）算法签名，得到的65字节签名就作为65字节的拖尾后缀被嵌入<code>extraData</code>。</p>
<p>为了保证心怀恶意的签名者（丢失了私钥）不能对网络造成伤害。每个签名者被允许签署<code>SIGNER_LIMIT</code>个连续区块中的最多一个。区块顺序不是固定的，但循序签名区块比不循序签名区块权重更大。</p>
<h4 id="授权策略">授权策略</h4>
<p>只要签名者遵守上述规范，他们可以授权和散播他们认为合适的区块。下面的建议策略会减少网络通信和小分叉，所以它是建议特征：</p>
<ul>
<li>如果一个签名者被允许签署一个区块（他在授权名单上而且最近没有签过名）。</li>
<li>计算下一个区块的最佳签署时间（父区块 + <code>BLOCK_PERIOD</code>）。</li>
<li>如果签名者是循序的，等到那个确定时间，直接签署和广播区块。</li>
<li>如果签名者是不循序的，按照<code>rand(SIGNER_COUNT * 500ms)</code>延迟签名。</li>
</ul>
<p>这个小策略可以保证循序签名者（它的区块权重更高）相比起不循序签名者有轻微的签署和传播优势。也因此这个设计也允许通过提升签名者的数量得到轻微的（性能）扩展。</p>
<p>从以上策略可以看出，实际上 PoA 里依然有可能产生分叉，除非使用严格的单账户 PoA。</p>
<h4 id="为什么要标准化-poa">为什么要标准化 PoA</h4>
<p>PoW 在无价值网络上是不安全的，PoS 还远未实现。PoA 作为一个过分简单的解，就被实现出来挽救测试网络了。</p>
<p>PoA 可以被认为是 PoW 的简化版-而不是 PoS 的进化版（<strong>以前我想错了</strong>），它直接授权了一群主，让他们尽量按顺序出块，当然这种设计（scheme）下依然有分叉的可能。</p>
<p>Clique 算法的相关文献在<a target="_blank" rel="noopener" href="https://github.com/ethereum/EIPs/issues/225">这里</a>。</p>
<h3 id="dpos-delegated-proof-of-stake">DPoS（Delegated Proof of Stake）</h3>
<p>旧的共识算法无法解决交易性能问题。</p>
<p>DPoS 使用见证人（witness）的机制来解决中心化和性能问题的矛盾。</p>
<p>传统的区块链共识算法有一个很大的弊病，就是需要在大规模范围内被验证非出块节点验证过。DPoS 争取把收集事务、生成区块、验证区块这一系列事件局部化到小范围的少量可被信任节点里，<strong>特别是不需要再等待若干个区块累加确认时间</strong>。</p>
<p>DPoS 是受控中心化的，每个客户端最终可以通过公平选举，决定哪些节点成为代表绝大多数用户的代理人。</p>
<p>DPoS 背后的理性逻辑（Rationale）是：</p>
<ul>
<li>使权益所有者能够通过投票决定记账人</li>
<li>最大化权益所有者的红利</li>
<li>最小化保证网络安全的消耗</li>
<li>最大化网络的性能（可能诚实节点之间通过架设专有网络进行通信）</li>
<li>最小化运行网络的成本（可能诚实节点之间通过架设专有网络进行通信）</li>
</ul>
<p>每个权益所有者通过投票决定区块的签名验证者，任何一个拥有超过1%投票的人都可以参与到董事会。所有的代表构成一个“董事会”，轮流签署区块。如果一个董事错过了签署区块的机会，客户会自动把投票给予其他人。最终，这些错过签署机会的董事会被取消资格，其他人就可以加入董事会。董事会成员会收到少量代币作为奖励，用来激励在线时间和参与竞选。每一个董事必须要将单个区块平均奖励的100倍作为保证金，从而确保其至少99%的在线时间。</p>
<p>EOS 的候选代表出自各大研究所、大学、交易所等地方，是 well-known 节点。</p>
<p>不从普通用户中选择见证者的原因：</p>
<ul>
<li>普通用户大部分时间不在线</li>
<li>攻击者可以使用其权益控制网络，而不经过其他人的认可</li>
<li>由于没有挖矿，在去中心化网络中生成随机数变得不可能。</li>
</ul>
<p>现实工作中，普通用户是通过钱包中的投票选项来选择见证者的。在全网出现不诚实区块的时候，正常的钱包可能在交易以前强制举行一轮新投票。但具体的投票过程，没有具体文献披露出来。</p>
<p>假设手续费等于验证成本，则全网只能有一个验证节点，蜕变为中心化节点。假设手续费100倍于验证成本，则全网可以拥有100个去中心化节点。这个平均成本核算说明了现在比特币挖矿并不 rational，需要依靠矿金激励的支持。</p>
<p>见证人干了什么：</p>
<ul>
<li>生成区块和广播区块的权威（类似 authority）。</li>
<li>负责用自己的私钥对收集来的 P2P 网络中的合法交易进行验证、打包和签名。</li>
<li>在比特股实现中，见证人的排列顺序是随机的，因为网络拓扑结构不固定，而且网络连通性没有保障。而 EOS 的实现则是定制拓扑的 round robin 结构，因为它是确定 well-known 节点的，每个出块者都可以跟下一个出块者直连以防块扩散速度不足。而且这种定制的 round robin 顺序可能还会被洗牌算法所改变。</li>
</ul>
<p>经典的出块过程：</p>
<p><img src="https://ws1.sinaimg.cn/large/66dd581fly1fp6p0oc9y0j20kk02tjrj.jpg" alt=""></p>
<p>在比特股/Steemit的时代，3秒出一个块，EOS 的时代，可能1秒就出一个块。 出块时间深受假定的网络延迟模型影响。</p>
<p>EOS 的出块过程里面，如果一个见证者的出块失败了，该 slot 的指定区块会被 skipped 掉，而不是由其他出块者补上。</p>
<p>理论上每个 transaction 都包含对一个最近区块的交易 hash 值（这也就意味着 transaction  必须有时效性了，其他区块链的区块里是没有这个限制的）。这也就意味着，每个签署人签署一个新区块，都会增强对历史交易的认定。这被称为 TaPoS（Transaction as Proof of Stake）。它可以：</p>
<ul>
<li>防止跨分叉的事务重放。</li>
<li>通知网络某个用户和它们的权益在某个特定分叉上。</li>
</ul>
<p>按照 BM 在视频里的说法，在 DPoS + TaPoS 双重防御下，也需要三分之二的区块生产者都在老的区块上产生新的区块，最终确定性(finality)才能被保证，这至少需要45（3*15）秒。这个数字为什么和 BFT 要求的比例一模一样？按照 BM 在视频里的说法，只需要三分之一的节点是非拜占庭恶意节点，网络就不会被拜占庭恶意攻击攻破。</p>
<p>DPoS 对于攻击的抑制</p>
<ul>
<li>不管是因为掉线，还是因为有意拒绝，如果见证人没有签署它应该签署的区块，它将被解职，并是去未来的稳定预期收入。因此不诚实的委托代表只有在明确有其他利益诉求时才会选择放弃区块生成。</li>
<li>见证人无法签署无效的交易，因为交易需要所有见证人都确认。</li>
</ul>
<p>在现实世界里，通常需要11个或者21个当选见证者，候选见证者可能需要100个。</p>
<p>以上内容参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1de1a1673bcd">《区块链核心技术：委任权益证明算法DPoS》</a>和<a target="_blank" rel="noopener" href="https://www.leiphone.com/news/201706/JfsBmaf6Y0ZtV11R.html">《缺失的白皮书：DPOS共识算法工作原理及鲁棒性根源分析<br>
》</a>。我们都知道区块链应该能够防止双重支付攻击，但这篇文章<a target="_blank" rel="noopener" href="http://www.8btc.com/dpos_bitfarm">《http://www.8btc.com/dpos_bitfarm》</a>也提到要防止拒绝服务攻击。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2018/01/30/%E5%87%A0%E7%A7%8D%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/">https://magicliang.github.io/2018/01/30/%E5%87%A0%E7%A7%8D%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><a class="post-meta__tags" href="/tags/consensus/">consensus</a><a class="post-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-168.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/27/Hyperledger-Fabric-%E7%BD%91%E7%BB%9C%E7%9A%84%E5%90%AF%E5%8A%A8%E6%AD%A5%E9%AA%A4/" title="Hyperledger Fabric 网络的启动步骤"><img class="cover" src="/img/wall-paper-55.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-27</div><div class="info-item-2">Hyperledger Fabric 网络的启动步骤</div></div><div class="info-2"><div class="info-item-1">  本文是截至日前（2017.10.27）时对官方教程和自我实验的重新梳理。   Hyperledger Fabric 可以说是 Hyperledger 的拳头项目。虽然同为  Apache 的顶级项目，但大部分其他项目都以 Fabric 为基础。它是顶级项目中的顶级项目，可以认为是0级项目。   docker 要有高于 17.06.2-ce 的版本。docker-compose 要有 1.14.0 及以上的版本。当然当前的高版本的 docker 已经自带了高版本的 docker-compose，这通常不用担心。   安装1.9+ 的 Golang。应该预期这样的结果：    echo $GOPATH   /Users/xxx/go   如果这个结果出不来，考虑当前 Shell 的环境变量没有正确设置：   export GOPATH=$HOME/go   export PATH=$PATH:$GOPATH/bin   要用一个很特别的 nodejs 版本。6.9以上，却不能用8.x。npm 也有特别的版本要求：   npm install npm@3.10.10 -g   要用...</div></div></div></a><a class="pagination-related" href="/2017/10/27/%E6%80%9D%E8%80%83%E5%8C%BA%E5%9D%97%E9%93%BE/" title="思考区块链"><img class="cover" src="/img/wall-paper-122.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-27</div><div class="info-item-2">思考区块链</div></div><div class="info-2"><div class="info-item-1"> 区块链是比特币的基础设施。由区块组成链，是为区块链。各个区块链的持有者之间，总是在玩不确定选主的游戏，所以这和所有传统的分布式数据库不同，是一个去中心的数据存储模式。 比特币的区块链是1.0的玩法，以太坊是2.0的玩法。有些人认为 Hyperledger 是3.0的玩法，还有待怀疑。 区块链上的资产，可以是自带的（比特币网络里的比特币，以太坊网络里的以太币），也可以是智能合约定义和约束的。 智能合约是个看起来很美好，实际上只能执行在沙盒里面的东西。曾经在某个IBM程序员的分享里看到过，Hyperledger 的智能合约本质上也是 GO 程序，所以理论上可以做一切事情。但目前没有看到除了调用各种 Shim API 以外的任何用处。比如，如果我们想要用智能合约发出另外一个调用请求，让真实的系统发生转账，如何做到？ 很多人都有热思考，人类再也回不到没有比特币的时代了。也有冷思考，区块链的时代还未到来。就目前而言，现在的计算性能真的不足以支撑真实的行业流量，只能养养鸡，运运肉。 也有观点认为，公有链是真命题，而私有链是伪命题。就目前的观察看来，不管是 Hyperledger 还是 Co...</div></div></div></a><a class="pagination-related" href="/2017/10/31/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9B%B8%E5%85%B3%E7%A0%94%E7%A9%B6%E8%B5%84%E6%96%99/" title="以太坊相关研究资料"><img class="cover" src="/img/wall-paper-32.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-31</div><div class="info-item-2">以太坊相关研究资料</div></div><div class="info-2"><div class="info-item-1"> 《以太坊的 gas 费率一览表》 《以太坊学习笔记：私有链搭建操作指南》 《以太坊中的账户、交易、Gas和区块Gas Limit》 StackOverflow 上的问答：以太坊主链到底需要多大空间？ StackOverflow 上的问答：怎样提供无限次数的智能合约操作？ 《区块链技术-智能合约-以太坊 （译文）》 《以太坊官方文档》 《以太坊私有链搭建指南》 《以太坊关于搭建私有网络的 wiki》 《预充值以太坊资金的方法》。注意看 carchrae 的回复，这里面也提供了拷贝私钥复用私钥的方法，可以考虑在多节点的情况下使用。 《一本与参数有关的介绍怎样搭建私链的 gitbook》。 StackOverflow 上的问答：以太坊的网络难度是否可以静态锁死？注意看它还有个相关的子问题。如果网络算力的稳定的话，应该不会出现难度增长才对。 值得大读特读的 geth 的文档。特别是挖矿、账户管理的部分。 geth 的命令行选项。注意，有些选项在当前版本中已经消失了，如（gpomin、gpomax）。 StackOverflow 上的问答：如何降低测试网络中的难度。感觉没多大用。 搜索以...</div></div></div></a><a class="pagination-related" href="/2017/11/02/Cello-%E5%9C%A8-mac-%E4%B8%8A%E9%9C%80%E8%A6%81%E7%89%B9%E5%88%AB%E6%B3%A8%E6%84%8F%E7%9A%84%E5%87%A0%E4%B8%AA%E9%97%AE%E9%A2%98/" title="Cello 在 mac 上需要特别注意的几个问题"><img class="cover" src="/img/wall-paper-15.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-02</div><div class="info-item-2">Cello 在 mac 上需要特别注意的几个问题</div></div><div class="info-2"><div class="info-item-1"> /opt/cello 和 /opt/cello2 以及下面的 mongo 和 fabric-1.0 都尽量把 owner 和 group 改成当前用户名和当前用户名组名。然后把这两个子文件夹用 docker file sharing 打开。 docker 会对 cello 下的 file sharing 有很麻烦的冲突影响。解决方法是建立一个 cello2 文件夹，然后在 cello 项目下用以下脚本把 fabric-1.0 的文件夹迁移过去：  1234#!/usr/bin/env bashARTIFACTS_DIR=/opt/cello2sudo cp -r ./src/agent/docker/_compose_files/fabric-1.0 $&#123;ARTIFACTS_DIR&#125;sudo chown -R $&#123;USER&#125;:$&#123;USERGROUP&#125; $&#123;ARTIFACTS_DIR&#125; 然后修改 vi .//src/agent/docker/docker_swarm.py，把  COMPOSE_PRO...</div></div></div></a><a class="pagination-related" href="/2018/01/17/Merkle-Tree/" title="Merkle Tree"><img class="cover" src="/img/wall-paper-179.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-01-17</div><div class="info-item-2">Merkle Tree</div></div><div class="info-2"><div class="info-item-1">本文还是对《区块链：原理、设计与应用》的一个基础技术的总结和摘录。  默克尔树的特点   默克尔树是多层散列表（Hash List），目的是做多层摘要，把对多个 item 的校验，转化为对一个 item 的校验。   默克尔树可以是二叉树，也可以是多叉树。   叶子节点是 item 的 value 和 value 的散列值。中间每一层的值，都是它们子女散列值的和的散列值-多叉树的结果就是多个散列值加法的结果的再散列，孤儿的计算结果就是在孤儿散列值上进行再散列。 默克尔树的用途 快速比较大量数据   两组数据的排序后构建默克尔树，只要比较两个树的root 就可以确定两组数据是否一样。 快速 diff   如果默克尔树是二叉树，则只要从 root 开始做二分的 diff，就能快速定位到不一致的叶子节点。这在 p2p 传输文件数据的场景里非常有用。实际上 rsync 的 diff 算法就是一个一层的 Hash List ， 零（部分知识）知识证明   所谓的零知识证明，就是不告诉 verifier 验证一个论断真伪的全部信息。只提供部分信息，就可以让 verifier 相信某个事情是真...</div></div></div></a><a class="pagination-related" href="/2018/01/24/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%9A%84%E7%A1%AC%E5%88%86%E5%8F%89/" title="以太坊的硬分叉"><img class="cover" src="/img/wall-paper-91.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-01-24</div><div class="info-item-2">以太坊的硬分叉</div></div><div class="info-2"><div class="info-item-1">  有四次计划内的软件升级，每次都是硬分叉：Frontier，Homestead，Metropolis，Serenity。   有一次意料之外的分叉（DAO 事件），制造出 ETH 和以太经典两种货币。   每次分叉都会造成矿工的迁移。旧链会因为流失算力而丧失安全性。   大都会分叉本来打算引爆难度炸弹，迫使矿工们从 PoW 共识算法移动到 PoA 共识算法，让以太坊进入冰河时代。但这个难度炸弹的引爆被延后了。   大都会同样引入了一个 PoS 的早期实施，Casper共存 算法允许每一百个区块里会有一个 PoS 区块。关于 PoS 算法，Vitalik 的解释是：  想象现在有 100 个人围着圆桌，其中有一个人拿着很多张纸，每张纸记录着很多笔历史交易信息。第一个人拿起笔签完后递给第二个人，第二个人也做出了相同的选择，如果大多数人做出了相同的选择，即都签署了同一张纸那么每一个参与者会获得1美元，当你做出和绝大多数人不同的选择时，那么你的房子就会着火！    如果真的不能阻止矿工停留在 PoW 上继续挖矿，那将会创建三种以太坊币：ETC、ETH-PoW、ETH-PoS，这对以太坊...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#flp-impossibility-flp-%E4%B8%8D%E5%8F%AF%E8%83%BD%E5%AE%9A%E7%90%86"><span class="toc-number">1.</span> <span class="toc-text">FLP Impossibility（FLP 不可能定理）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E4%BF%A1%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">可信环境下的共识算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#paxos-%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">Paxos 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#raft-%E7%AE%97%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">Raft 算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%9C%89%E9%99%90%E4%BA%92%E4%BF%A1%E7%9A%84%E7%8E%AF%E5%A2%83%E4%B8%8B%E7%9A%84%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">在有限互信的环境下的共识算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8%E6%B2%A1%E6%9C%89%E4%BA%92%E4%BF%A1%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E7%9A%84%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95"><span class="toc-number">4.</span> <span class="toc-text">在没有互信的情况下的共识算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pow-proof-of-work"><span class="toc-number">4.1.</span> <span class="toc-text">PoW（Proof of Work）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pos-proof-of-stake"><span class="toc-number">4.2.</span> <span class="toc-text">PoS（Proof of Stake）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#pos-%E7%9B%B8%E5%AF%B9%E4%BA%8E-pow-%E7%9A%84%E4%BC%98%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.2.1.</span> <span class="toc-text">PoS 相对于 Pow 的优点是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#pos-%E6%98%AF%E5%A6%82%E4%BD%95%E8%9E%8D%E5%85%A5%E4%BC%A0%E7%BB%9F%E7%9A%84%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%A0%94%E7%A9%B6-%E6%88%90%E6%9E%9C-%E7%9A%84%EF%BC%9F"><span class="toc-number">4.2.2.</span> <span class="toc-text">PoS 是如何融入传统的拜占庭容错研究（成果）的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%A9%E7%9B%8A%E6%97%A0%E5%85%B3%E9%97%AE%E9%A2%98-%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%AE%83"><span class="toc-number">4.2.3.</span> <span class="toc-text">什么是利益无关问题，以及如何解决它</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%E8%BF%99%E5%92%8C%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%AE%B9%E9%94%99%E7%90%86%E8%AE%BA%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">4.2.4.</span> <span class="toc-text">所以这和拜占庭容错理论有什么关系？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9C%8B%E4%BA%86%E9%82%A3%E4%B9%88%E5%A4%9A-pos-%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%B7%A5%E4%BD%9C%E7%9A%84%E5%91%A2%EF%BC%9F"><span class="toc-number">4.2.5.</span> <span class="toc-text">看了那么多 PoS 到底是怎么工作的呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#poa-proof-of-authority"><span class="toc-number">4.3.</span> <span class="toc-text">PoA（Proof of Authority）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%88%E6%9D%83-%E5%8D%B3%E7%AD%BE%E7%BD%B2-%E5%8C%BA%E5%9D%97"><span class="toc-number">4.3.1.</span> <span class="toc-text">授权（即签署）区块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E7%AD%96%E7%95%A5"><span class="toc-number">4.3.2.</span> <span class="toc-text">授权策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%A0%87%E5%87%86%E5%8C%96-poa"><span class="toc-number">4.3.3.</span> <span class="toc-text">为什么要标准化 PoA</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dpos-delegated-proof-of-stake"><span class="toc-number">4.4.</span> <span class="toc-text">DPoS（Delegated Proof of Stake）</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>