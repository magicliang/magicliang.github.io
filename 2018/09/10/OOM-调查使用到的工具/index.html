<!DOCTYPE html>

<html lang="zh-Hans">
    <head>
    <meta charset="utf-8">
    <!--
        hexo-theme-suka © SukkaW
        GitHub: https://github.com/SukkaW/hexo-theme-suka
    -->

    <!-- ### Resource Hint ### -->

    <!-- ## DNS Prefetch ## -->
    <meta http-equiv="x-dns-prefetch-control" content="on">

<!-- busuanzi -->

    <link rel="dns-prefetch" href="//busuanzi.ibruce.info">


<!-- comment -->







<!-- analytics -->







    <!-- ## Preload ## -->
    
    <!-- Busuanzi -->
    
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" as="script">







    <!-- ### Meta & Title & Info ### -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, maximum-scale=5, viewport-fit=cover">
    <meta name="renderer" content="webkit">

    <!-- Title -->
    <title>OOM 调查使用到的工具 | 守株阁</title>

    <!-- Favicons -->
    <link rel="icon" type="image&#x2F;ico" href="/img/suka-favicon.ico">

    <!-- ### Import File ### -->
    <link rel="stylesheet" href="/lib/spectre/spectre.min.css"><style>
    body {
        background-color: #f8f9fa;
    }

    a, a:visited {
        color: #0070ff;
    }

    a:active, a:focus, a:hover {
        color: #0070ff;
        opacity: .75;
    }

    #post-content a,
    #post-content a:hover,
    #post-content a:focus,
    #post-content a:visited {
        color: #005eb9;
        opacity: 1;
    }

    

    .post-entry .card-body a {
        color: #0070ff;
    }

    .avatar {
        background: #444;
    }

    .navbar-link,
    .navbar-link:visited,
    .timeline .timeline-item .timeline-icon.icon-lg {
        color: #0070ff;
    }

    .navbar-link:hover {
        color: #0070ff;
        opacity: .8;
    }

    #search-input .btn,
    #disqus_click_btn,
    #disqus-switch-to-direct,
    #disqus-loadmore-button {
        background: #727e96;
        border-color: #727e96;
        color: #fff;
    }

    #post-toc a.post-toc-link,
    #post-toc a.post-toc-link:visited,
    .share-menu.menu .menu-item>a {
        color: #727e96;
    }

    .share-menu.menu .menu-item>a:hover,
    .share-menu.menu .menu-item>a:focus,
    .share-menu.menu .menu-item>a:visited {
        color: #50596c;
        background: #f8f9fa;
        opacity: .85;
    }
</style><link rel="stylesheet" href="/css/style.min.css">








    <!-- Prettify Theme -->
    
    <link rel="preload" href="/css/highlight/github.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><noscript><link rel="stylesheet" href="/css/highlight/github.min.css"></noscript>





<script>
/*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
!function(t){"use strict";t.loadCSS||(t.loadCSS=function(){});var e=loadCSS.relpreload={};if(e.support=function(){var e;try{e=t.document.createElement("link").relList.supports("preload")}catch(t){e=!1}return function(){return e}}(),e.bindMediaToggle=function(t){var e=t.media||"all";function a(){t.addEventListener?t.removeEventListener("load",a):t.attachEvent&&t.detachEvent("onload",a),t.setAttribute("onload",null),t.media=e}t.addEventListener?t.addEventListener("load",a):t.attachEvent&&t.attachEvent("onload",a),setTimeout(function(){t.rel="stylesheet",t.media="only x"}),setTimeout(a,3e3)},e.poly=function(){if(!e.support())for(var a=t.document.getElementsByTagName("link"),n=0;n<a.length;n++){var o=a[n];"preload"!==o.rel||"style"!==o.getAttribute("as")||o.getAttribute("data-loadcss")||(o.setAttribute("data-loadcss",!0),e.bindMediaToggle(o))}},!e.support()){e.poly();var a=t.setInterval(e.poly,500);t.addEventListener?t.addEventListener("load",function(){e.poly(),t.clearInterval(a)}):t.attachEvent&&t.attachEvent("onload",function(){e.poly(),t.clearInterval(a)})}"undefined"!=typeof exports?exports.loadCSS=loadCSS:t.loadCSS=loadCSS}("undefined"!=typeof global?global:this);
</script>

    <!-- ### Site Verification ### -->
    


    <link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="mobile-web-app-capable" content="yes"><meta name="application-name" content="守株阁"><meta name="msapplication-starturl" content="http://magicliang.github.io"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="守株阁"><meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <!-- ### The Open Graph & Twitter Card Protocol ### -->
    <meta property="og:title" content="OOM 调查使用到的工具 | 守株阁"><meta property="og:site_name" content="守株阁"><meta property="og:type" content="article"><meta property="og:url" content="http://magicliang.github.io/2018/09/10/OOM-%E8%B0%83%E6%9F%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/"><meta property="og:locale" content="zh-Hans"><meta name="description" content="top 与 htop。这两个东西比 free 好用。比较神奇的是，为什么线上还有装了 htop这样的非标准 top。字节跳动自己开源了一个 atop，可以细致地监控线程信息，也可以快速采集系统信息，是一个不错的监控工具。 pmap。这个东西是莫枢自己也用来 dump 详细的内存轮廓的地址，但可能需要使用他提到的一个 Serviceability Agent API 来读才读得懂。这个工具的输出可以 - magicliang - 守株阁"><meta name="keywords" content="JVM, 操作系统"><meta property="og:image" content="http://magicliang.github.io/2018/09/10/OOM-%E8%B0%83%E6%9F%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/async-profiler-idea.png"><meta property="article:published_time" content="2018-09-10T03:33:04.000Z"><meta property="article:modified_time" content="2021-12-21T08:53:20.000Z"><meta property="og:updated_time" content="2021-12-21T08:53:20.000Z"><meta property="article:author" content="magicliang"><meta property="article:tag" content="JVM, 操作系统"><meta name="twitter:card" content="summary">

    

    <!-- ### Canonical link ### -->
    <link rel="canonical" href="http://magicliang.github.io/2018/09/10/OOM-%E8%B0%83%E6%9F%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/">

    <meta name="generator" content="Hexo 6.0.0">

    <!-- ### Analytics ### -->
    







    <!-- ### Structured Data ### -->
    



<script type="application/ld+json">
{
    "@context": "http://schema.org",
    "url": "http://magicliang.github.io/2018/09/10/OOM-%E8%B0%83%E6%9F%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/",
    "@type": "BlogPosting",
    "logo": "http://magicliang.github.io/img/suka-favicon.ico",
    "mainEntityOfPage": {
        "@type": "WebPage",
        "@id": "http://magicliang.github.io/2018/09/10/OOM-%E8%B0%83%E6%9F%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/"
    },
    "headline": "OOM 调查使用到的工具 | 守株阁",
    
    "image": {
        "@type": "ImageObject",
        "url": "http://magicliang.github.io/img/suka-favicon.ico"
    },
    
    "datePublished": "2018-09-10T03:33:04.000Z",
    "dateModified": "2021-12-21T08:53:20.000Z",
    "author": {
        "@type": "Person",
        "name": "magicliang",
        "image": {
            "@type": "ImageObject",
            "url": "http://magicliang.github.io/img/default_avatar.png"
        },
        "description": "Hi, nice to meet you."
    },
    "publisher": {
        "@type": "Organization",
        "name": "守株阁",
        "logo": {
            "@type": "ImageObject",
            "url": "http://magicliang.github.io/img/suka-favicon.ico"
        }
    },
    
    "potentialAction": {
        "@type": "SearchAction",
        "target": "http://magicliang.github.io/search?s={search_term_string}",
        "query-input": "required name=search_term_string"
    },
    
    "keywords": "JVM, 操作系统",
    "description": "top 与 htop。这两个东西比 free 好用。比较神奇的是，为什么线上还有装了 htop这样的非标准 top。字节跳动自己开源了一个 atop，可以细致地监控线程信息，也可以快速采集系统信息，是一个不错的监控工具。 pmap。这个东西是莫枢自己也用来 dump 详细的内存轮廓的地址，但可能需要使用他提到的一个 Serviceability Agent API 来读才读得懂。这个工具的输出可以 - magicliang - 守株阁"
}
</script>



    <!-- ### Custom Head ### -->
    
</head>

    <body>
            

            <!-- ### Main content ### -->
            <!-- ## Header ##-->
<header>
    <h1 class="header-title text-center"><a href="/">守株阁</a></h1>

    <p class="text-center header-slogan">
        
            
                Hi, nice to meet you.
            
        
    </p>

    <nav class="navbar-section text-center">
    
        <a href="/" class="navbar-link">Home</a>
    
    
        <a href="/archives/" class="navbar-link">Archives</a>
    
    
        <a href="/search" class="navbar-link">Search</a>
    
    
    
        <div class="dropdown dropdown-right">
    <a class="navbar-link dropdown-toggle" tabindex="0">Share</a>
    <ul class="menu share-menu">

        <!-- Share Weibo -->
        
        <li class="menu-item">
            <a href="http://service.weibo.com/share/share.php?appkey=&title=守株阁&url=http://magicliang.github.io&pic=http://magicliang.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">Share to Weibo</a>
        </li>
        

        <!-- Share Twitter -->
        
        <li class="menu-item">
            <a href="https://twitter.com/intent/tweet?text=守株阁&url=http://magicliang.github.io&via=magicliang" target="_blank" rel="external noopener noreferrer nofollow">Share to Twitter</a>
        </li>
        

        <!-- Share Facebook -->
        
        <li class="menu-item">
            <a href="https://www.facebook.com/sharer/sharer.php?u=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow">Share to Facebook</a>
        </li>
        

        <!-- Share Google+ -->
        
        <li class="menu-item">
            <a href="https://plus.google.com/share?url=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow">Share to Google+</a>
        </li>
        

        <!-- Share LinkedIn -->
        
        <li class="menu-item">
            <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://magicliang.github.io&title=OOM 调查使用到的工具" target="_blank" rel="external noopener noreferrer nofollow">Share to LinkedIn</a>
        </li>
        

        <!-- Share QQ -->
        
        <li class="menu-item">
            <a href="http://connect.qq.com/widget/shareqq/index.html?site=守株阁&title=OOM 调查使用到的工具&summary=关于技术以及人生&pics=http://magicliang.github.io/img/suka-favicon.ico&url=http://magicliang.github.io" target="_blank" rel="external noopener noreferrer nofollow"> Share to QQ</a>
        </li>
        

        <!-- Share Telegram -->
        
        <li class="menu-item">
            <a href="https://t.me/share/url?url=http://magicliang.github.io&text=OOM 调查使用到的工具" target="_blank" rel="external noopener noreferrer nofollow">Share to Telegram</a>
        </li>
        

        <!-- QRCode -->
        
        <li class="menu-item">
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMQAAADECAAAAADlzdG3AAADK0lEQVR42u3b0U4rMQxF0f7/T8MTEqoan+0Qh4L2vCC47SRrpExsx/fx8Q+uhwgRIkSIGEc8iuv7Z+INn75DPvv1+VdjoXmJEDGEWA20muTzoK8m9WoyaRzy4ESIuIVYLbbuAlw9gGpR0/uLEPEuiNWGVi3wapKrhV59VoSId0NUmxbBpAmnF4sIEbcRq4lVCz0t9uoFUd3zeBQrQkQTUSXkv/nzWLVDhIgGolvoWm1Oq8COTCoFhj+uiosQ0Tyf6AZuqWhG7pUmi+4hQsQgIiXw3eQlBYidBGv5uwgRA4gqcU//Rh8AKRis8BVahIgpRNpY6EZIDhU7Y1QHNyJE3ECQzShNLhXaqkSrSrjK4pkIEQMIOsGdQK67uPEYIkQMIDqF5G4j184hfRWALgNAESIOIjpBXMLQTXDnQFKEiNsIGpyRRL5qZCTFAxJwihBxC0EX8QqSimmk0JY2UxEiJhGdoIsWmUnRgLwcYhIlQsQAIhUIyA3pAUp6UGRcESJuI2LzYPH39P3OS4I8LBEiphCkcNxptNopsJEiRNmgIkLEYQQJ3HYSJPoQaCM87igQIWITQRrWyQBV4YxupKnQFjM7ESIOIdJVFZZJANjZFGnDvAgRkwiS8KfCQucAnjT8kg1ThIhJRBXIkQYS+iBo8bj6rggRk4hUACYbWSq0dcYgRQYRIiYR6UCQLOJdNGmQKRMuESIGEdUCIg1VadPcTYzKF4cIEQMIUiBLRWW0MT3YfxzsBJYiREwiyMEjGYg0YnUbwVCDiggRhxDVgusepHQPD9MDigefIkQMIeiBemdS3cYu2riyjGJFiDiESEkOCQpp8bhzsELGEyFiCoGbaUGTL9m8qkN6EkiKEDGJII3nnUIAKSKfaJgXIWIKQQvG1aJMCRMpGHeLzCJETCHazYOhqEWDv3SI0m54FyHiIGKnySptiOSQPS3cGDCKEDGIoIPQRisS5JHvthreRYi4hKg2uZS8kOSHNMvgLhsRIi4jaACYgsZqIyX3ECFiGtEpBJOkKRXNugcxP4piRYhoItLGtRvUdYpk6e+oQUWEiAOIv3yJECFChIix6xPF+P6sUdE9YwAAAABJRU5ErkJggg==" alr="QRCode">
        </li>
        

    </ul>
</div>
    
    
</nav>
</header>

            
    <!-- ## Post ## -->
    <div class="post-container">
    <div id="post-card" class="card">
        
        <div class="card-item-container">
            <div class="card-inner-cell">
                <!-- # Post Header Info # -->
                <div class="card-header">
                    
    <h1 class="card-title h3 mb-2">OOM 调查使用到的工具</h1>




<div class="post-header-info">
    <p class="post-header-info-left text-gray">
        <img class="author-thumb lazyload" data-src="/img/default_avatar.png" src="/img/suka-lazyload.gif" alt="magicliang's Avatar">
        <span>2018-09-10</span>
        
        
            <!-- Busuanzi Post Views -->
<span id="busuanzi_container_page_pv" hidden>
    <span class="suka-devide-dot"></span>
    <span></span>
    <span id="busuanzi_value_page_pv"></span>
    <span>Views</span>
</span>
        
        
    </p>
    <div class="post-header-info-right">
        
            <div class="dropdown dropdown-right">
<a class="dropdown-toggle" tabindex="0">Share the post</a>
<ul class="menu share-menu">
    <!-- Share Weibo -->
    
    <li class="menu-item">
        <a href="http://service.weibo.com/share/share.php?appkey=&title=OOM 调查使用到的工具&url=http://magicliang.github.io/2018/09/10/OOM-%E8%B0%83%E6%9F%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/&pic=http://magicliang.github.io/img/suka-favicon.ico&searchPic=false&style=simple" target="_blank" rel="external noopener noreferrer nofollow">Share to Weibo</a>
    </li>
    

    <!-- Share Twitter -->
    
    <li class="menu-item">
        <a href="https://twitter.com/intent/tweet?text=OOM 调查使用到的工具&url=http://magicliang.github.io/2018/09/10/OOM-%E8%B0%83%E6%9F%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/&via=magicliang" target="_blank" rel="external noopener noreferrer nofollow">Share to Twitter</a>
    </li>
    

    <!-- Share Facebook -->
    
    <li class="menu-item">
        <a href="https://www.facebook.com/sharer/sharer.php?u=http://magicliang.github.io/2018/09/10/OOM-%E8%B0%83%E6%9F%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/" target="_blank" rel="external noopener noreferrer nofollow">Share to Facebook</a>
    </li>
    

    <!-- Share Google+ -->
    
    <li class="menu-item">
        <a href="https://plus.google.com/share?url=http://magicliang.github.io/2018/09/10/OOM-%E8%B0%83%E6%9F%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/" target="_blank" rel="external noopener noreferrer nofollow">Share to Google+</a>
    </li>
    

    <!-- Share LinkedIn -->
    
    <li class="menu-item">
        <a href="https://www.linkedin.com/shareArticle?mini=true&url=http://magicliang.github.io/2018/09/10/OOM-%E8%B0%83%E6%9F%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/&title=守株阁" target="_blank" rel="external noopener noreferrer nofollow">Share to LinkedIn</a>
    </li>
    

    <!-- Share QQ -->
    
    <li class="menu-item">
        <a href="http://connect.qq.com/widget/shareqq/index.html?site=守株阁&title=守株阁&summary=关于技术以及人生&pics=http://magicliang.github.io/img/suka-favicon.ico&url=http://magicliang.github.io/2018/09/10/OOM-%E8%B0%83%E6%9F%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/" target="_blank" rel="external noopener noreferrer nofollow"> Share to QQ</a>
    </li>
    

    <!-- Share Telegram -->
    
    <li class="menu-item">
        <a href="https://t.me/share/url?url=http://magicliang.github.io/2018/09/10/OOM-%E8%B0%83%E6%9F%A5%E4%BD%BF%E7%94%A8%E5%88%B0%E7%9A%84%E5%B7%A5%E5%85%B7/&text=守株阁" target="_blank" rel="external noopener noreferrer nofollow">Share to Telegram</a>
    </li>
    

    <!-- QRCode -->
    
    <li class="menu-item">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMQAAADECAAAAADlzdG3AAADK0lEQVR42u3b0U4rMQxF0f7/T8MTEqoan+0Qh4L2vCC47SRrpExsx/fx8Q+uhwgRIkSIGEc8iuv7Z+INn75DPvv1+VdjoXmJEDGEWA20muTzoK8m9WoyaRzy4ESIuIVYLbbuAlw9gGpR0/uLEPEuiNWGVi3wapKrhV59VoSId0NUmxbBpAmnF4sIEbcRq4lVCz0t9uoFUd3zeBQrQkQTUSXkv/nzWLVDhIgGolvoWm1Oq8COTCoFhj+uiosQ0Tyf6AZuqWhG7pUmi+4hQsQgIiXw3eQlBYidBGv5uwgRA4gqcU//Rh8AKRis8BVahIgpRNpY6EZIDhU7Y1QHNyJE3ECQzShNLhXaqkSrSrjK4pkIEQMIOsGdQK67uPEYIkQMIDqF5G4j184hfRWALgNAESIOIjpBXMLQTXDnQFKEiNsIGpyRRL5qZCTFAxJwihBxC0EX8QqSimmk0JY2UxEiJhGdoIsWmUnRgLwcYhIlQsQAIhUIyA3pAUp6UGRcESJuI2LzYPH39P3OS4I8LBEiphCkcNxptNopsJEiRNmgIkLEYQQJ3HYSJPoQaCM87igQIWITQRrWyQBV4YxupKnQFjM7ESIOIdJVFZZJANjZFGnDvAgRkwiS8KfCQucAnjT8kg1ThIhJRBXIkQYS+iBo8bj6rggRk4hUACYbWSq0dcYgRQYRIiYR6UCQLOJdNGmQKRMuESIGEdUCIg1VadPcTYzKF4cIEQMIUiBLRWW0MT3YfxzsBJYiREwiyMEjGYg0YnUbwVCDiggRhxDVgusepHQPD9MDigefIkQMIeiBemdS3cYu2riyjGJFiDiESEkOCQpp8bhzsELGEyFiCoGbaUGTL9m8qkN6EkiKEDGJII3nnUIAKSKfaJgXIWIKQQvG1aJMCRMpGHeLzCJETCHazYOhqEWDv3SI0m54FyHiIGKnySptiOSQPS3cGDCKEDGIoIPQRisS5JHvthreRYi4hKg2uZS8kOSHNMvgLhsRIi4jaACYgsZqIyX3ECFiGtEpBJOkKRXNugcxP4piRYhoItLGtRvUdYpk6e+oQUWEiAOIv3yJECFChIix6xPF+P6sUdE9YwAAAABJRU5ErkJggg==" alt="QRCode">
    </li>
    

</ul>
</div>
        
    </div>
</div>
                </div>
                <div class="card-body">
                    
                        
                        
                            <div id="post-toc"><ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#%E5%9F%BA%E7%A1%80%E5%8E%9F%E7%90%86%E6%B1%87%E6%80%BB%EF%BC%9A"><span class="post-toc-number">1.</span> <span class="post-toc-text">基础原理汇总：</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#jcmd-%E5%AE%9E%E6%88%98%E4%BE%8B%E5%AD%90"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">jcmd 实战例子</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#top-%E6%8E%92%E5%BA%8F"><span class="post-toc-number">2.</span> <span class="post-toc-text">top 排序</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#jstack-sop"><span class="post-toc-number">3.</span> <span class="post-toc-text">jstack sop</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Profiler-%E9%97%AE%E9%A2%98"><span class="post-toc-number">4.</span> <span class="post-toc-text">Profiler 问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%81%AB%E7%84%B0%E5%9B%BE"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">火焰图</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E7%83%AD%E7%82%B9%E5%88%86%E6%9E%90%E6%A0%91"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">热点分析树</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E6%A0%91"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">调用堆栈树</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Idea-%E7%9A%84-Method-Merged-Callees-%E5%92%8C-Method-BackTraces"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">Idea 的 Method Merged Callees 和 Method BackTraces</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Java-Agent"><span class="post-toc-number">4.5.</span> <span class="post-toc-text">Java Agent</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Java-%E7%9A%84-Java-Agent-%E8%A7%84%E8%8C%83"><span class="post-toc-number">4.5.1.</span> <span class="post-toc-text">Java 的 Java Agent 规范</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A-Profiler-%E7%9A%84%E6%9E%B6%E6%9E%84%E6%80%9D%E8%B7%AF"><span class="post-toc-number">4.6.</span> <span class="post-toc-text">一个普通 Profiler 的架构思路</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Sampling-vs-Instrumentation"><span class="post-toc-number">4.6.1.</span> <span class="post-toc-text">Sampling vs Instrumentation</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#%E5%9F%BA%E4%BA%8EJava-Agent-JMX%E5%AE%9E%E7%8E%B0"><span class="post-toc-number">4.6.1.1.</span> <span class="post-toc-text">基于Java Agent + JMX实现</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#SafePoint-Bias%E9%97%AE%E9%A2%98"><span class="post-toc-number">4.6.2.</span> <span class="post-toc-text">SafePoint Bias问题</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%9F%BA%E4%BA%8EJVMTI-AsyncGetCallTrace%E5%AE%9E%E7%8E%B0"><span class="post-toc-number">4.6.3.</span> <span class="post-toc-text">基于JVMTI + AsyncGetCallTrace实现</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-Dynamic-Attach%EF%BC%9F"><span class="post-toc-number">4.6.4.</span> <span class="post-toc-text">如何实现 Dynamic Attach？</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E7%81%AB%E7%84%B0%E5%9B%BE%EF%BC%9F"><span class="post-toc-number">4.7.</span> <span class="post-toc-text">如何实现自己的火焰图？</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#%E6%80%BB%E7%BB%93"><span class="post-toc-number">4.8.</span> <span class="post-toc-text">总结</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#Remote-debugger"><span class="post-toc-number">5.</span> <span class="post-toc-text">Remote debugger</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#gperftools"><span class="post-toc-number">6.</span> <span class="post-toc-text">gperftools</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#java-7-%E7%9A%84%E9%BB%98%E8%AE%A4-flag"><span class="post-toc-number">7.</span> <span class="post-toc-text">java 7 的默认 flag</span></a></li></ol></div>
                        
                    
                    <article id="post-content">
                        <ol>
<li>top 与 htop。这两个东西比 free 好用。比较神奇的是，为什么线上还有装了 htop这样的非标准 top。<a target="_blank" rel="noopener" href="https://blog.csdn.net/ByteDanceTech/article/details/122007542?spm=1001.2014.3001.5501">字节跳动自己开源了一个 atop</a>，可以细致地监控线程信息，也可以快速采集系统信息，是一个不错的监控工具。</li>
<li>pmap。这个东西是莫枢自己也用来 dump 详细的内存轮廓的地址，但可能需要使用他提到的一个 Serviceability Agent API 来读才读得懂。这个工具的输出可以看到各段内存的起止，但不经帮助，很难读出各个子线程的栈来。<br>这个命令在非 root/sudo 权限下看到的是 jvm 启动参数，在 root/sudo 权限下看到的是内存轮廓，这时候就需要 Serviceability Agent API 了。</li>
<li>smem。这个东西对内存的 RSS/PSS/USS 分析得很好。但并不能帮助我们直接获知我们最期待的栈内存轮廓，比如当前 JVM 的 stack 到底是怎么分布的，占了多少内存？而且更重要是，线上机器没有这个工具。</li>
<li>直接 cat /proc/pid/smaps 其实其他的进程内存查看工具的信息可能都能在这里看得到，但是需要耐心。而且，这个东西在线上也是看不了的，看来也是需要 root。</li>
<li>ps_mem.py 这是一个对 private ram usage 分析得不错的脚本。但是需要 root。</li>
<li>jstack。 这是目前 thread dump 最详尽的命令行工具了。但线上有时候用不了（为什么用不了呢）。jstack 可以用来分析 core dump（jmap 也可以）。</li>
<li>其他 jmx 客户端。 JConsole/JVisualVM/JMC。全部都连不上线上。JVisualVM 的 mbean 功能没有 JConsole 强大，要搞好 mbean，要在界面上对“函数名”浮层按钮进行点击调用。或者在 JMC 上打开 mbeanserver 的控制台，在诊断命令面板里面点击 GC.class_stats 等高危命令。</li>
<li>飞行记录器。这个东西甲骨文收费非常贵，但好处是可以录下来再在本地回放。目前看来，所有的 JVM 运行时状态分析，只有这个是最完备的了。它还有一个命令行工具 jcmd，可以动态地使用飞行记录器的功能和各种 jmx client 特有的动能。</li>
<li>其他，这里有本<a target="_blank" rel="noopener" href="https://juejin.im/post/5c9ced366fb9a070e344c614">书</a>，讲了很多 system tuning 的原理和工具，但对 JVM 的调试好像没有什么特别的好处。</li>
<li>看 jstat -gc PID 也可以看到内存轮廓。其中 MU 是永久代信息。同理，JMX 客户端也可以看到这个值。jstat 相关的 options 可以查看内部的 gc 统计结果，比直接读 gc log 直观。因为 JVM 会直接写一个内部的类似日志的东西，把所有的 gc 记下来，即使没有打开 printGCLog。</li>
<li>directbuffer 和 metaspace 的回收严重依赖 fullgc，ygc 是远远不够的。</li>
<li>查看元空间的尺寸： <code>/usr/local/java8/bin/java  -XX:+PrintFlagsFinal -version | grep Metaspace</code> 直接看 gc log 也可以看到 metaspace 的大小。</li>
<li>查看所有的 native memory：<code>jcmd 16200  VM.native_memory scale=MB</code>，这需要使用 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/tooldescr007.html">Java 8 自带的 nmt 功能</a>。注意，jmc 可以直接看到 direct buffer，比 native memory tracker 优秀，但看不到 thread 内存。nmt 正好反过来，能看到线程消耗的内存，看不到 direct buffer。</li>
<li><code>jps -lvm</code> 查看实际的 jvm 汇总传入参数。 <code>ps -aux</code> <code>ps -elf</code>查看进程实际的传入参数。<code>java -XX:+PrintFlagsFinal</code> java 命令默认的参数。</li>
<li>heap dump 可能包括 full gc 的时间，也包括写磁盘的时间，大堆的 hang/panic 几乎不可避免。</li>
<li>要仔细思考互为因果的问题里各个因素的相互关系和在时间线上出现的顺序：有 GC 耗时增大、线程 Block 增多、慢查询增多、CPU 负载高四个表象，到底哪个是诱因？如何判断 GC 有没有问题？使用 CMS 有哪些常见问题？如何判断根因是什么？如何解决或避免这些问题？</li>
<li>真正难的是建立评价 Metric 的方法：当前的系统 performance 应该使用什么样的 metric 来衡量。</li>
</ol>
<h1 id="基础原理汇总："><a href="#基础原理汇总：" class="headerlink" title="基础原理汇总："></a>基础原理汇总：</h1><ol>
<li><a target="_blank" rel="noopener" href="https://juejin.im/post/5c9ced366fb9a070e344c614">聊聊jvm的-XX:MaxDirectMemorySize</a></li>
<li><a target="_blank" rel="noopener" href="https://dzone.com/articles/permgen-and-metaspace">https://dzone.com/articles/permgen-and-metaspace</a></li>
<li><a target="_blank" rel="noopener" href="https://www.baeldung.com/native-memory-tracking-in-jvm">Native Memory Tracking in JVM</a></li>
<li><a target="_blank" rel="noopener" href="http://lovestblog.cn/blog/2015/05/12/direct-buffer/">JVM源码分析之堆外内存完全解读</a></li>
<li><a target="_blank" rel="noopener" href="https://shipilev.net/jvm/anatomy-quarks/12-native-memory-tracking/">JVM Anatomy Quark #12: Native Memory Tracking</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1406522">聊聊HotSpot VM的Native Memory Tracking</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/12/troubleshoot/diagnostic-tools.html#GUID-5EF7BB07-C903-4EBD-A9C2-EC0E44048D37">NMT 工具输出表</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/u010686469/article/details/77319599">Java程序在Linux上运行虚拟内存耗用很大</a></li>
<li><a target="_blank" rel="noopener" href="https://gist.github.com/prasanthj/48e7063cac88eb396bc9961fb3149b58">native-mem-tracking.md</a></li>
<li><a target="_blank" rel="noopener" href="http://hellojava.info/?p=323">说说在Java启动参数上我犯的错</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/FHY0MelBfmgdRpT4zWF9dQ">江南白衣 | 关键系统的JVM参数推荐(2018仲夏版)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/64685291">线程栈的原理</a></li>
<li><a target="_blank" rel="noopener" href="http://hg.openjdk.java.net/jdk7/jdk7/hotspot/file/tip/src/share/vm/runtime/thread.cpp">thread 源码</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/apache/rocketmq/blob/cdb494c4dcef45c506d79bfdbe727e319cdce681/distribution/bin/runserver.cmd">rocketmq 的 jvm 配置</a></li>
<li>gdb：注意 backtrace 的使用。</li>
<li>vmerr：注意看 jvm 退出的时候线程栈状态，cpp 栈帧从哪里调用又从哪里抛出，调用从哪里来的。</li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/aitangyong/article/details/39403031">《System.gc()和-XX:+DisableExplicitGC启动参数，以及DirectByteBuffer的内存释放》</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/32912702/impact-of-setting-xxdisableexplicitgc-when-nio-direct-buffers-are-used">《Impact of setting -XX:+DisableExplicitGC when NIO direct buffers are used》</a></li>
</ol>
<h2 id="jcmd-实战例子"><a href="#jcmd-实战例子" class="headerlink" title="jcmd 实战例子"></a>jcmd 实战例子</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jcmd 140466 VM.native_memory baseline</span><br><span class="line"></span><br><span class="line">jcmd 140466 VM.native_memory detail.diff</span><br><span class="line"></span><br><span class="line">jcmd 140466 VM.native_memory summary</span><br><span class="line"></span><br><span class="line">jcmd 230163 VM.native_memory summary</span><br></pre></td></tr></table></figure>

<p>上面的输出里面的 committed 的意思是已经向操作系统做了 mmaped  PROT_READ | PROT_WRITE ，就是正在使用的内存（最初的 committed 等于 xms）；reserved 只是向系统用 mmaped none 申请了的内存，等到 paging error 才真的申请（最初的 reserved 等于 xmx）。</p>
<h1 id="top-排序"><a href="#top-排序" class="headerlink" title="top 排序"></a>top 排序</h1><p>press shift+m after running the top command<br>or you can interactively choose which column to sort on<br>press Shift+f to enter the interactive menu<br>press the up or down arrow until the %MEM choice is highlighted<br>press s to select %MEM choice<br>press enter to save your selection<br>press q to exit the interactive menu<br>Or specify the sort order on the command line</p>
<h1 id="jstack-sop"><a href="#jstack-sop" class="headerlink" title="jstack sop"></a>jstack sop</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 看到 pid 下的 pid</span></span><br><span class="line">top -Hp 23344</span><br><span class="line">top -H</span><br><span class="line"><span class="comment"># jstack 输出的tid是线程内存地址，nid是os的pid 的 16 进制形式，需要和 top 里的 pid 进行转换。</span></span><br><span class="line"><span class="built_in">printf</span> <span class="string">&quot;%x&quot;</span> 18969</span><br><span class="line"><span class="comment"># 参数是 pid</span></span><br><span class="line">jstack 31928</span><br></pre></td></tr></table></figure>

<p>如果存在死锁，输出的开头和末尾都会打出死锁相关的信息，不需要再单独找分析工具。</p>
<h1 id="Profiler-问题"><a href="#Profiler-问题" class="headerlink" title="Profiler 问题"></a>Profiler 问题</h1><p>本文参考：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/10/10/jvm-cpu-profiler.html">《JVM CPU Profiler技术原理及源码深度解析》</a></p>
<p>常见的 profiler 有：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://www.ej-technologies.com/products/jprofiler/overview.html">JProfiler</a>。这是一个“The Award-Winning All-in-One Java Profiler”，可惜它是商用的。</li>
<li>Uber 开源的 JVM profiler，可以搜集 CPU、Memory、IO 相关的信息。</li>
<li>intellij 集成的<a target="_blank" rel="noopener" href="https://blog.jetbrains.com/idea/2018/09/intellij-idea-2018-3-eap-git-submodules-jvm-profiler-macos-and-linux-and-more/">穷人版 Profiler</a>。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/jvm-profiling-tools">统一的 profiler 列表</a>。</li>
</ol>
<p>当代的开源 lowoverhead CPU Profiler 已经超越了 hprof 和 JFR 里的 profiler。</p>
<h2 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h2><p>作为一个二维图片，火焰图的 X 轴代表采样总量，而 Y 轴代表栈深度。每个框就代表了一个栈里的函数，其宽度代表了所占用的 CPU 总时间。因此，比较宽的框就表示该函数运行时间较慢或被调用次数较多，从而占用的 CPU 时间多。通过火焰图，RD 可以轻松观察到各个方法调用占用 CPU 的情况。</p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2017/09/flame-graph.html">找平顶</a>，或者说宽平面。平时人们总是容易注意“宽”，但很少注意“顶”。</p>
<h2 id="热点分析树"><a href="#热点分析树" class="headerlink" title="热点分析树"></a>热点分析树</h2><p>热点分析树会统计出CPU上调用最频繁的方法，我们把这些方法称为热点，同时树形结构可查看抵达此热点的不同栈路径。和调用堆栈树不同，热点分析树是从自底向上描述调用栈，并做了更深入的继承关系分析，在性能诊断时具有更好的实践指导意义。</p>
<p>日志通常被调用得比较多，但日志并不能被真正称为一个性能热点。就好像字符串虽然在 heapdump 里面出现得比较多，但字符串未必就是性能热点一样。热点分析树能够用聚合的视角让我们看到被调用得最多的底层方法。通常出现得比较多的热点方法有日志调用、协议编解码、加解密、各种客户端 flushBuffer。</p>
<h2 id="调用堆栈树"><a href="#调用堆栈树" class="headerlink" title="调用堆栈树"></a>调用堆栈树</h2><p>该功能统计了Java进程在一段时间内各个方法占用CPU的情况，通过一颗自顶向下的树式（java method1 → java method2 → … native method…）来呈现耗时信息，树中包含所有在JVM中已记录的访问队列。</p>
<p>通常出现得比较多的底层堆栈有：</p>
<ol>
<li>java.lang.Thread.run</li>
<li>java.util.concurrent.ThreadPoolExecutor$Worker.run</li>
<li>各种 io 事件 handler</li>
<li>各种 runnable、future.get</li>
</ol>
<h2 id="Idea-的-Method-Merged-Callees-和-Method-BackTraces"><a href="#Idea-的-Method-Merged-Callees-和-Method-BackTraces" class="headerlink" title="Idea 的 Method Merged Callees 和 Method BackTraces"></a>Idea 的 Method Merged Callees 和 Method BackTraces</h2><p><img src="async-profiler-idea.png" alt="async-profiler-idea.png"></p>
<h2 id="Java-Agent"><a href="#Java-Agent" class="headerlink" title="Java Agent"></a>Java Agent</h2><p>作为 Java instrumentation 体系的经典工具，它的存在意味着我们可以把一个伴生库 attach 到 JVM 主进程里，通过 JVMTI 机制和 JVM 进行通信，这种通信是 Debugger（JDWP）、Profiler、Monitor、Thread Analyser等工具的统一基础，在主流Java虚拟机中都有实现。</p>
<p>我们可以通过 CPP 编写 Java Agent，也可以通过 Java 来编写 Java Agent。通过 Java 编写的 Java Agent 是一种更友好的方式。</p>
<p>我们应当仔细想清楚 Java Agent 和 Advice 的侵入性和编码难易程度上的差别。因为侵入性特别低，所以业内的流行开源产品都是基于 Java Agent 来实现的。</p>
<h3 id="Java-的-Java-Agent-规范"><a href="#Java-的-Java-Agent-规范" class="headerlink" title="Java 的 Java Agent 规范"></a>Java 的 Java Agent 规范</h3><ol>
<li>声明一个 在jar包的MANIFEST.MF中将Premain-Class指定为一个入口类。</li>
<li>实现一个这样的方法：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">premain</span><span class="params">(String args, Instrumentation ins)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// implement</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样打包出来的jar就是一个Java Agent，可以通过-javaagent参数将jar传递给Java进程伴随启动，JVM同样会在启动阶段的合适时机执行该方法。</p>
<blockquote>
<p>在该方法内部，参数Instrumentation接口提供了Retransform<br>Classes的能力，我们利用该接口就可以对宿主进程的Class进行修改，实现方法耗时统计、故障注入、Trace等功能。Instrumentation接口提供的能力较为单一，仅与Class字节码操作相关，但由于我们现在已经处于宿主进程环境内，就可以利用JMX直接获取宿主进程的内存、线程、锁等信息。无论是Instrument API还是JMX，它们内部仍是统一基于JVMTI来实现。</p>
</blockquote>
<h2 id="一个普通-Profiler-的架构思路"><a href="#一个普通-Profiler-的架构思路" class="headerlink" title="一个普通 Profiler 的架构思路"></a>一个普通 Profiler 的架构思路</h2><p>使用过JProfiler的同学应该都知道，JProfiler的CPU Profiling功能提供了两种方式选项: Sampling和Instrumentation，它们也是实现CPU Profiler的两种手段。</p>
<h3 id="Sampling-vs-Instrumentation"><a href="#Sampling-vs-Instrumentation" class="headerlink" title="Sampling vs Instrumentation"></a>Sampling vs Instrumentation</h3><p>这个问题的另一种问法是：你的设计是基于 AOP 拦截，还是基于定时采样 dump？</p>
<p>Sampling方式顾名思义，基于对StackTrace的“采样”进行实现，核心原理如下：</p>
<blockquote>
<ol>
<li>引入Profiler依赖，或直接利用Agent技术注入目标JVM进程并启动Profiler。</li>
<li>启动一个采样定时器，以固定的采样频率每隔一段时间（毫秒级）对所有线程的调用栈进行Dump。</li>
<li>汇总并统计每次调用栈的Dump结果，在一定时间内采到足够的样本后，导出统计结果，内容是每个方法被采样到的次数及方法的调用关系。 Instrumentation则是利用Instrument<br>API，对所有必要的Class进行字节码增强，在进入每个方法前进行埋点，方法执行结束后统计本次方法执行耗时，最终进行汇总。二者都能得到想要的结果，那么它们有什么区别呢？或者说，孰优孰劣？</li>
</ol>
</blockquote>
<p>Instrumentation 其实就是一种 AOP，AOP 是一种更广义的编程思想。</p>
<p>Instrumentation 侵入性强，对真实执行环境的影响大，但采集数据详实精确（虽然里面也有很大的时间加成）。</p>
<p>Sampling 的缺点是：到底什么样的采样率能够保证数据真实？我们不知道。JVM 只能进入安全点才能采样，更限制了 Sampling 的活动空间。所以有了一篇这样著名的文章<a target="_blank" rel="noopener" href="https://psy-lob-saw.blogspot.com/2016/02/why-most-sampling-java-profilers-are.html">《Why (Most) Sampling Java Profilers Are Fucking Terrible》</a>。</p>
<blockquote>
<p>具体到“孰优孰劣”的问题层面，这两种实现技术并没有非常明显的高下之判，只有在分场景讨论下才有意义。Sampling由于低开销的特性，更适合用在CPU密集型的应用中，以及不可接受大量性能开销的线上服务中。而Instrumentation则更适合用在I/O密集的应用中、对性能开销不敏感以及确实需要精确统计的场景中。社区的Profiler更多的是基于Sampling来实现，本文也是基于Sampling来进行讲解。</p>
</blockquote>
<p>注意，Sampling 也有它的用武之地，特别是对线上服务的 Sampling 而言，更是不知不觉地使用了很多的 Sampling 功能。</p>
<h4 id="基于Java-Agent-JMX实现"><a href="#基于Java-Agent-JMX实现" class="headerlink" title="基于Java Agent + JMX实现"></a>基于Java Agent + JMX实现</h4><blockquote>
<p>一个最简单的Sampling CPU Profiler可以用Java Agent + JMX方式来实现。以Java<br>Agent为入口，进入目标JVM进程后开启一个ScheduledExecutorService，定时利用JMX的threadMXBean.dumpAllThreads()来导出所有线程的StackTrace，最终汇总并导出即可。</p>
<p>Uber的JVM-Profiler实现原理也是如此，关键部分代码如下：</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com/uber/profiling/profilers/StacktraceCollectorProfiler.java</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * StacktraceCollectorProfiler等同于文中所述CpuProfiler，仅命名偏好不同而已</span></span><br><span class="line"><span class="comment"> * jvm-profiler的CpuProfiler指代的是CpuLoad指标的Profiler</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">​</span><br><span class="line"><span class="comment">// 实现了Profiler接口，外部由统一的ScheduledExecutorService对所有Profiler定时执行</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">profile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<span class="keyword">false</span>, <span class="keyword">false</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadInfo threadInfo : threadInfos) &#123;</span><br><span class="line">        String threadName = threadInfo.getThreadName();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        StackTraceElement[] stackTraceElements = threadInfo.getStackTrace();</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = stackTraceElements.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            StackTraceElement stackTraceElement = stackTraceElements[i];</span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Uber提供的定时器默认Interval是100ms，对于CPU Profiler来说，这略显粗糙。但由于dumpAllThreads()的执行开销不容小觑，Interval不宜设置的过小，所以该方法的CPU<br>Profiling结果会存在不小的误差。</strong></p>
<p>JVM-Profiler的优点在于支持多种指标的Profiling（StackTrace、CPUBusy、Memory、I/O、Method），且支持将Profiling结果通过Kafka上报回中心Server进行分析，也即支持集群诊断。</p>
</blockquote>
<p>所以对于 Monitoring 服务而言，大停顿的操作都要小心、小心再小心。</p>
<blockquote>
<p>使用Java实现Profiler相对较简单，但也存在一些问题，譬如说Java<br>Agent代码与业务代码共享AppClassLoader，被JVM直接加载的agent.jar如果引入了第三方依赖，可能会对业务Class造成污染。截止发稿时，JVM-Profiler都存在这个问题，它引入了Kafka-Client、http-Client、Jackson等组件，如果与业务代码中的组件版本发生冲突，可能会引发未知错误。Greys/Arthas/JVM-Sandbox的解决方式是分离入口与核心代码，使用定制的ClassLoader加载核心代码，避免影响业务代码。</p>
</blockquote>
<p>所以自定义的 Java Agent 本身并不足够好用，必须要认真思考依赖隔离的问题。</p>
<h3 id="SafePoint-Bias问题"><a href="#SafePoint-Bias问题" class="headerlink" title="SafePoint Bias问题"></a>SafePoint Bias问题</h3><blockquote>
<p>基于Sampling的CPU Profiler通过采集程序在不同时间点的调用栈样本来近似地推算出热点方法，因此，从理论上来讲Sampling<br>CPU Profiler必须遵循以下两个原则：</p>
<ol>
<li>样本必须足够多。</li>
<li>程序中所有正在运行的代码点都必须以相同的概率被Profiler采样。 如果只能在安全点采样，就违背了第二条原则。因为我们只能采集到位于安全点时刻的调用栈快照，意味着某些代码可能永远没有机会被采样，即使它真实耗费了大量的CPU执行时间，这种现象被称为“SafePoint<br>Bias”。</li>
</ol>
</blockquote>
<p>一定会有高开销的方法会不能在 SafePoint 里读到。</p>
<blockquote>
<p>上文我们提到，基于JMX与基于JVMTI的Profiler实现都存在SafePoint<br>Bias，但一个值得了解的细节是：单独来说，JVMTI的GetStackTrace()函数并不需要在Caller的安全点执行，但当调用GetStackTrace()获取其他线程的调用栈时，必须等待，直到目标线程进入安全点；而且，GetStackTrace()仅能通过单独的线程同步定时调用，不能在UNIX信号处理器的Handler中被异步调用。综合来说，GetStackTrace()存在与JMX一样的SafePoint<br>Bias。更多安全点相关的知识可以参考《Safepoints: Meaning, Side Effects and Overheads》。</p>
</blockquote>
<h3 id="基于JVMTI-AsyncGetCallTrace实现"><a href="#基于JVMTI-AsyncGetCallTrace实现" class="headerlink" title="基于JVMTI + AsyncGetCallTrace实现"></a>基于JVMTI + AsyncGetCallTrace实现</h3><blockquote>
<p>如上节所述，假如我们拥有一个函数可以获取当前线程的调用栈且不受安全点干扰，另外它还支持在UNIX信号处理器中被异步调用，那么我们只需注册一个UNIX信号处理器，在Handler中调用该函数获取当前线程的调用栈即可。由于UNIX信号会被发送给进程的随机一线程进行处理，因此最终信号会均匀分布在所有线程上，也就均匀获取了所有线程的调用栈样本。</p>
<p>按如上步骤即可实现基于AsyncGetCallTrace的CPU Profiler，这是社区中目前性能开销最低、相对效率最高的CPU<br>Profiler实现方式，在Linux环境下结合perf_events还能做到同时采样Java栈与Native栈，也就能同时分析Native代码中存在的性能热点。该方式的典型开源实现有Async-Profiler和Honest-Profiler，Async-Profiler实现质量较高，感兴趣的话建议大家阅读参考文章。有趣的是，IntelliJ<br>IDEA内置的Java<br>Profiler，其实就是Async-Profiler的包装。更多关于AsyncGetCallTrace的内容，大家可以参考《The<br>Pros and Cons of AsyncGetCallTrace Profilers》。</p>
</blockquote>
<p>我们常说的“低开销 profiler”，其实指的是<a target="_blank" rel="noopener" href="https://github.com/jvm-profiling-tools/async-profiler">Async-Profiler</a>。</p>
<h3 id="如何实现-Dynamic-Attach？"><a href="#如何实现-Dynamic-Attach？" class="headerlink" title="如何实现 Dynamic Attach？"></a>如何实现 Dynamic Attach？</h3><blockquote>
<p>JDK在1.6以后提供了Attach<br>API，允许向运行中的JVM进程添加Agent，这项手段被广泛使用在各种Profiler和字节码增强工具中。<br>总的来说，Dynamic<br>Attach是HotSpot提供的一种特殊能力，它允许一个进程向另一个运行中的JVM进程发送一些命令并执行，命令并不限于加载Agent，还包括Dump内存、Dump线程等等。</p>
</blockquote>
<p>arthas 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// com/taobao/arthas/core/Arthas.java</span></span><br><span class="line">​</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachine;</span><br><span class="line"><span class="keyword">import</span> com.sun.tools.attach.VirtualMachineDescriptor;</span><br><span class="line">​</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">​</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachAgent</span><span class="params">(Configure configure)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    VirtualMachineDescriptor virtualMachineDescriptor = <span class="keyword">null</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 拿到所有JVM进程，找出目标进程</span></span><br><span class="line">    <span class="keyword">for</span> (VirtualMachineDescriptor descriptor : VirtualMachine.list()) &#123;</span><br><span class="line">        String pid = descriptor.id();</span><br><span class="line">        <span class="keyword">if</span> (pid.equals(Integer.toString(configure.getJavaPid()))) &#123;</span><br><span class="line">            virtualMachineDescriptor = descriptor;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    VirtualMachine virtualMachine = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 针对某个JVM进程调用VirtualMachine.attach()方法，拿到VirtualMachine实例</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == virtualMachineDescriptor) &#123;</span><br><span class="line">            virtualMachine = VirtualMachine.attach(<span class="string">&quot;&quot;</span> + configure.getJavaPid());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            virtualMachine = VirtualMachine.attach(virtualMachineDescriptor);</span><br><span class="line">        &#125;</span><br><span class="line">​</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">​</span><br><span class="line">        <span class="comment">// 调用VirtualMachine#loadAgent()，将arthasAgentPath指定的jar attach到目标JVM进程中</span></span><br><span class="line">        <span class="comment">// 第二个参数为attach参数，即agentmain的首个String参数args</span></span><br><span class="line">        virtualMachine.loadAgent(arthasAgentPath, configure.getArthasCore() + <span class="string">&quot;;&quot;</span> + configure.toString());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != virtualMachine) &#123;</span><br><span class="line">            <span class="comment">// 调用VirtualMachine#detach()释放</span></span><br><span class="line">            virtualMachine.detach();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>async profiler 的 jattach 的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jattach <span class="number">1234</span> load /absolute/path/to/agent/libagent.so <span class="keyword">true</span></span><br></pre></td></tr></table></figure>

<h2 id="如何实现自己的火焰图？"><a href="#如何实现自己的火焰图？" class="headerlink" title="如何实现自己的火焰图？"></a>如何实现自己的火焰图？</h2><blockquote>
<p>现在我们拥有了采样调用栈的能力，但是调用栈样本集是以二维数组的数据结构形式存在于内存中的，如何将其转换为可视化的火焰图呢？</p>
<p>火焰图通常是一个svg文件，部分优秀项目可以根据文本文件自动生成火焰图文件，仅对文本文件的格式有一定要求。FlameGraph项目的核心只是一个Perl脚本，可以根据我们提供的调用栈文本生成相应的火焰图svg文件。调用栈的文本格式相当简单，如下所示：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base_func;func1;func2;func3 10</span><br><span class="line">base_func;funca;funcb 15</span><br></pre></td></tr></table></figure>

<blockquote>
<p>将我们采样到的调用栈样本集进行整合后，需输出如上所示的文本格式。每一行代表一“类“调用栈，空格左边是调用栈的方法名排列，以分号分割，左栈底右栈顶，空格右边是该样本出现的次数。</p>
<p>将样本文件交给flamegraph.pl脚本执行，就能输出相应的火焰图了：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flamegraph.pl stacktraces.txt &gt; stacktraces.svg</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Java Agent 很美好，但保证它的 dynamic attach 被良好实现、易用， 是基于它构建的工具能被广泛使用要思考的关键问题。</li>
<li>Intercept 很美好，但不适合做定量分析，因为它对性能影响可能非常大。</li>
<li>很多 JMX api 会 block until SafePoint（比如 GetStackTrace），所以 SafePoint Bias 是客观存在、必须注意的问题。</li>
<li>Sampling 才是对业务友好的采集器，精确度是一个必须迂回解决的问题。</li>
</ol>
<h1 id="Remote-debugger"><a href="#Remote-debugger" class="headerlink" title="Remote debugger"></a>Remote debugger</h1><p>为什么有时候 remote debugger connection refuse？因为上一个 debugging 还在继续，再 debug 上去会被拒绝。</p>
<h1 id="gperftools"><a href="#gperftools" class="headerlink" title="gperftools"></a>gperftools</h1><p>待续</p>
<h1 id="java-7-的默认-flag"><a href="#java-7-的默认-flag" class="headerlink" title="java 7 的默认 flag"></a>java 7 的默认 flag</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[Global flags]</span><br><span class="line">    uintx AdaptivePermSizeWeight                    = 20</span><br><span class="line"># 太多了，以后还是自己搜吧</span><br></pre></td></tr></table></figure>



                    </article>
                    


    <blockquote id="date-expire-notification" class="post-expired-notify">This article was last updated on <span id="date-expire-num"></span> days ago, and the information described in the article may have changed.</blockquote>
    <script>
    (function() {
        var dateUpdate = Date.parse("2021-12-21");
        var nowDate = new Date();
        var a = nowDate.getTime();
        var b = a - dateUpdate;
        var daysUpdateExpire = Math.floor(b/(24*3600*1000));
        if (daysUpdateExpire >= 120) {
            document.getElementById('date-expire-num').innerHTML = daysUpdateExpire;
        } else {
            document.getElementById('date-expire-notification').style.display = 'none';
        }
    })();
    </script>


<p class="post-footer-info mb-0 pt-0">Published at&nbsp;<time datetime="2018-09-10T03:33:04.000Z" itemprop="datePublished">2018-09-10</time>

    , Updated at&nbsp;<time datetime="2021-12-21T08:53:20.000Z" itemprop="dateModified">2021-12-21</time>

</p>
<p class="post-footer-info mb-0 pt-2">



<span class="post-tags-list mt-2">

<a class="post-tags-list-item" href="/tags/JVM/" rel="tag">#&nbsp;JVM</a>

<a class="post-tags-list-item" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">#&nbsp;操作系统</a>

</span>


</p>

                </div>
                <div class="post-nav px-2 bg-gray">
<ul class="pagination">
    <!-- Prev Nav -->
    
        <li class="page-item page-prev">
            <a href="/2018/09/21/Docker-%E4%B8%8E%E5%AD%98%E5%82%A8/" rel="prev">
                <div class="page-item-title"><i class="icon icon-back" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">Docker 与存储</div>
            </a>
        </li>
    

    <!-- Next Nav -->
    
        <li class="page-item page-next">
            <a href="/2018/09/07/Docker-%E4%B8%8E%E7%BD%91%E7%BB%9C/" rel="next">
                <div class="page-item-title"><i class="icon icon-forward" aria-hidden="true"></i></div>
                <div class="page-item-subtitle">Docker 与网络</div>
            </a>
        </li>
    
</ul>
</div>

                
                    <!-- # Comment # -->
                    
                
            </div>
        </div>
    </div>
</div>

            <!-- ### Footer ### -->
            <footer class="text-center">
    <!-- footer copyright -->
    
        <p class="footer-copyright mb-0">Copyright&nbsp;©&nbsp;<span id="copyright-year"></span>
            <a class="footer-copyright-a" href="http://magicliang.github.io">守株阁</a>
        </p>

    <!-- footer custom text -->
    <p class="footer-text mb-0">
    
    </p>
    <!-- footer develop info -->
    <p class="footer-develop mb-0">
        
    <!-- Busuanzi User Views -->
    <span id="busuanzi_container_site_uv" hidden>
        <span></span>
        <span id="busuanzi_value_site_uv"></span>
        <span>Viewers</span>
        
            <span>|</span>
        
    </span>




        
        Powered by&nbsp;<!--
         --><a href="https://hexo.io" target="_blank" class="footer-develop-a" rel="external nofollow noopener noreferrer">Hexo</a><span class="footer-develop-divider"></span>Theme&nbsp;-&nbsp;<!--
         --><a href="https://github.com/SukkaW/hexo-theme-suka" target="_blank" class="footer-develop-a" rel="external noopener">Suka</a>
    </p>
</footer>


        <!-- ### Import File ### -->
        <!-- ### Footer JS Import ### -->

<script>

    
window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 50
};
document.getElementById('copyright-year').textContent = new Date().getFullYear();
console.log('\n %c Suka Theme (hexo-theme-suka) | © SukkaW | Verision 1.3.3 %c https://github.com/SukkaW/hexo-theme-suka \n', 'color: #fff; background: #444; padding:5px 0;', 'background: #bbb; padding:5px 0;');

</script>

<script src="/lib/vanilla-lazyload/lazyload.min.js" async></script>
    <script src="https://cdn.jsdelivr.net/npm/busuanzi@2.3.0/bsz.pure.mini.js" async></script>


<!-- Offset -->




<!-- Comment -->


<!-- ### Custom Footer ### -->

    </body>

</html>