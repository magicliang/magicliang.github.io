<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Fabric 文档拾遗 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="基本名词解释 ledger 账本上一系列由事务驱动的状态迁移的记录。状态迁移是链码调用（调用即事务）的结果。这些记录是不可修改顺序的，因此也上抗篡改的。 每个channel有一个账本，但恐怕不只一个账本。 理论上账本是由产生它的链码的命名空间隔离开来的，不能直接被其他链码访问到。 chain 由包含一系列 transaction 的 block 通过hash-link（由散列值作为前驱指针的一种连">
<meta property="og:type" content="article">
<meta property="og:title" content="Fabric 文档拾遗">
<meta property="og:url" content="https://magicliang.github.io/2018/04/10/Fabric-%E6%96%87%E6%A1%A3%E6%8B%BE%E9%81%97/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="基本名词解释 ledger 账本上一系列由事务驱动的状态迁移的记录。状态迁移是链码调用（调用即事务）的结果。这些记录是不可修改顺序的，因此也上抗篡改的。 每个channel有一个账本，但恐怕不只一个账本。 理论上账本是由产生它的链码的命名空间隔离开来的，不能直接被其他链码访问到。 chain 由包含一系列 transaction 的 block 通过hash-link（由散列值作为前驱指针的一种连">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-128.jpg">
<meta property="article:published_time" content="2018-04-10T09:28:06.000Z">
<meta property="article:modified_time" content="2026-01-24T07:32:06.483Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Hyperledger Fabric">
<meta property="article:tag" content="区块链">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-128.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Fabric 文档拾遗",
  "url": "https://magicliang.github.io/2018/04/10/Fabric-%E6%96%87%E6%A1%A3%E6%8B%BE%E9%81%97/",
  "image": "https://magicliang.github.io/img/wall-paper-128.jpg",
  "datePublished": "2018-04-10T09:28:06.000Z",
  "dateModified": "2026-01-24T07:32:06.483Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2018/04/10/Fabric-%E6%96%87%E6%A1%A3%E6%8B%BE%E9%81%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Fabric 文档拾遗',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-128.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Fabric 文档拾遗</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Fabric 文档拾遗</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2018-04-10T09:28:06.000Z" title="Created 2018-04-10 17:28:06">2018-04-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T07:32:06.483Z" title="Updated 2026-01-24 15:32:06">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">1.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>5mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="基本名词解释">基本名词解释</h2>
<h3 id="ledger">ledger</h3>
<p>账本上一系列由事务驱动的状态迁移的记录。状态迁移是链码调用（调用即事务）的结果。这些记录是不可修改顺序的，因此也上抗篡改的。</p>
<p>每个channel有一个账本，但恐怕不只一个账本。</p>
<p>理论上账本是由产生它的链码的命名空间隔离开来的，不能直接被其他链码访问到。</p>
<h3 id="chain">chain</h3>
<p>由包含一系列 transaction 的 block 通过hash-link（由散列值作为前驱指针的一种连接方式）组成的数据结构。</p>
<h3 id="state-database">state database</h3>
<p>记录各种 key 的 latest value。可以被认为上chain的indexed view，可以随时被从链上重建出来。</p>
<p>所以 Fabric 自己就有双层数据结构。</p>
<h3 id="读写集语义">读写集语义</h3>
<p>读集和写集搞不好是同一个事务里的数据结构（待查）。</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">&lt;TxReadWriteSet&gt;<br>  &lt;NsReadWriteSet <span class="hljs-type">name</span>=&quot;chaincode1&quot;&gt;<br>    &lt;<span class="hljs-keyword">read</span>-<span class="hljs-keyword">set</span>&gt;<br>      &lt;<span class="hljs-keyword">read</span> key=&quot;K1&quot;, version=&quot;1&quot;&gt;<br>      &lt;<span class="hljs-keyword">read</span> key=&quot;K2&quot;, version=&quot;1&quot;&gt;<br>    &lt;/<span class="hljs-keyword">read</span>-<span class="hljs-keyword">set</span>&gt;<br>    &lt;<span class="hljs-keyword">write</span>-<span class="hljs-keyword">set</span>&gt;<br>      &lt;<span class="hljs-keyword">write</span> key=&quot;K1&quot;, <span class="hljs-keyword">value</span>=&quot;V1&quot;<br>      &lt;<span class="hljs-keyword">write</span> key=&quot;K3&quot;, <span class="hljs-keyword">value</span>=&quot;V2&quot;<br>      &lt;<span class="hljs-keyword">write</span> key=&quot;K4&quot;, isDelete=&quot;true&quot;<br>    &lt;/<span class="hljs-keyword">write</span>-<span class="hljs-keyword">set</span>&gt;<br>  &lt;/NsReadWriteSet&gt;<br>&lt;TxReadWriteSet&gt;<br></code></pre></td></tr></table></figure>
<h3 id="锚节点">锚节点</h3>
<p>一个 peer 节点，全 channel 里所有的其他节点都可以跟它交谈。每个组织（Member）都有一个锚节点，Member 里  的所有节点通过它来发现频道中的所有其他节点，<strong>通过锚节点和其他组织交换数据</strong>。</p>
<p>特别像以太坊中的 bootnode。</p>
<h3 id="leader-节点">leader 节点</h3>
<p>这个节点代表组织跟 orderer 通信，拉取最新到达的节点以后，<strong>通过 gossip 协议</strong>向其他节点做同步。</p>
<h3 id="member">Member</h3>
<p>法律上分离的实体，拥有独立的网络根证书。</p>
<h3 id="membership-service-provider">Membership Service Provider</h3>
<p>一个抽象的插件化组件，可以切换实现。主要用意是提供 credentials 甚至 peers 给 client，让它跟网络交流。理论上每个 Member 应该有个 MSP。</p>
<p>MSP 的本质是一系列证书、私钥和验证算法，实际上就是一堆文件夹。</p>
<h3 id="membership-services">Membership Services</h3>
<p>每个 peer 和 orderer 都可能实现 MSP，也就是说 MS 其实是它们的一个服务组件。</p>
<h3 id="bccsp">BCCSP</h3>
<p>Blockchain Crypto Service Provider</p>
<p>和MSP一样，是加密服务的提供者。</p>
<h2 id="bin-文件夹下的内容">bin 文件夹下的内容</h2>
<p>configtxlator<br>
<a target="_blank" rel="noopener" href="http://get-byfn.sh">get-byfn.sh</a><br>
<a target="_blank" rel="noopener" href="http://get-docker-images.sh">get-docker-images.sh</a><br>
orderer<br>
peer</p>
<p>其中 orderer、peer 都会被映射到镜像之内。</p>
<h2 id="初始化的步骤">初始化的步骤</h2>
<ol>
<li>cryptogen 这个工具根据配置文件生成指定拓扑的 x.509证书材料。</li>
<li>用 configtxgen 工具生成 orderer 创世区块，给 orderer 用。</li>
<li>生成频道配置事务-算是元事务的一种吧，给 channel 用。</li>
<li>生成相关组织的锚节点。</li>
</ol>
<h2 id="启动脚本的作用">启动脚本的作用</h2>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">./byfn.sh -m up -l <span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure>
<p>默认的 chaincode 开发语言是 Golang，但也可以切换到 node 上面。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">./byfn.sh -m down<br></code></pre></td></tr></table></figure>
<p>这里的<code>-m</code>是 mode 的意思。</p>
<p>这个命令会消灭掉 docker 网络残余文件，包括密码学文件和链码镜像。</p>
<p>这个大脚本会大量依赖父文件夹的…/bin脚本。</p>
<h2 id="transaction-的流程">transaction 的流程</h2>
<ol>
<li>client 根据 endorsement policy  发送 transaction proposal 到各个 peer。</li>
<li>各个 peer 通过合约容器试算，生成 read-write-set。</li>
<li>client 再根据读写集语义签真正的 transaction，如果不是查询的试算，会把 transaction 发给 orderer。</li>
<li>orderer只负责收集所有的 transaction 打包成区块。</li>
<li>区块发送给 peer，如果 read-write-set 语义还依然满足，则 transaction validate 通过，把区块添加到区块链上。</li>
</ol>
<h2 id="ca-问题">CA 问题</h2>
<p>CA 是可选组件。</p>
<p>但如果 CA server 跑起来，我们可以向它发送 REST 请求给组织的 CA 来完成用户注册和登记。</p>
<p>CA 是 PKI 的实现。PKI 可以抗女巫攻击。</p>
<p>CA 可以像 cryptogen 一样，先生成组织里的节点证书和私钥（组织里一定会有 root-ca），然后生成成员（admin 和普通成员）的证书和私钥。</p>
<h2 id="常见端口号">常见端口号</h2>
<p>这些端口号有先后顺序，适合在同一个 host 编排一系列容器。</p>
<p>orderer：7050<br>
peer：7051<br>
peer event：7053<br>
ca：7054</p>
<h2 id="sdk-问题">SDK 问题</h2>
<p>区块链天然可以用gRPC来通信。</p>
<p>因为各种语言都支持 Protocol Buffers，基于Protocol Buffers over gRPC，我们可以制造各种语言的SDK。</p>
<p>所以理论上我们可以直接通过 gRPC 跟区块链通信。</p>
<h2 id="读写集语义">读写集语义</h2>
<p>实际上读集（read set）和写集（write set）是分开的。<br>
它们共同组成了事务。</p>
<h2 id="configuration-block">configuration block</h2>
<p>有configtx，就有configuration block，这不奇怪。两者都要经过orderer。</p>
<p>可以通过命令行来获取configuration（peer channel fetch）。peer channel fetch 可以用来获取任意序号的区块。</p>
<h2 id="packaging">packaging</h2>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">peer chaincode <span class="hljs-keyword">package</span> -n mycc -p github.com<span class="hljs-regexp">/hyperledger/</span>fabric<span class="hljs-regexp">/examples/</span>chaincode<span class="hljs-regexp">/go/</span>chaincode_example02 -v <span class="hljs-number">0</span> -s -S -i <span class="hljs-string">&quot;AND(&#x27;OrgA.admin&#x27;)&quot;</span> ccpack.out<br></code></pre></td></tr></table></figure>
<p>这一行命令生成了一个 signedCDS。</p>
<p>有<code>-s</code>（signing的意思）应该有<code>-S</code>，否则再也没有机会让 owner 来签署这个 package 了。<code>-S</code>指出了需要本地 MSP 来 sign 这个 package。</p>
<p><code>-i</code>是 intantiate policy，指的是只有 OrgA 的 admin 可以初始化这个 package。</p>
<p>实际上不用 package 和 sign 最好了，反正每个peer默认可以初始化链码也只有本 Member 的 admin（这种 admin 在默认的情况下是大多数需要产生变化的 wrtier）。</p>
<p>可见这个初始化策略是针对 package 而不是针对 channel 的。我们只可以组织一个 package 被初始化，不能阻止别人在一个 channel 上安装任意的 chaincode。</p>
<p>这个初始化策略还会进一步限制 upgrade。只有符合策略的 MSP 才能 upgrade 整个lian ma</p>
<h2 id="停止链码">停止链码</h2>
<p>目前只能通过停止和删除容器，并删除 peer 上 CDS的方式来做到，对其他组织的机器是个考验呢。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">rm</span> -f &lt;container <span class="hljs-built_in">id</span>&gt;<br><span class="hljs-built_in">rm</span> /var/hyperledger/production/chaincodes/&lt;ccname&gt;:&lt;ccversion&gt;<br></code></pre></td></tr></table></figure>
<h2 id="系统链码">系统链码</h2>
<p>逻辑上和普通链码是一样的（应该也是通过各种事务驱动的），但只跑在 peer 进程内。</p>
<p>系统链码的目的是为了减少 peer 和 chaincode 容器之间的 gRPC。</p>
<p>要 upgrade 链码只有 upgrade peer 二进制文件（实际上就是跟着 Fabric 版本走）。</p>
<h2 id="架构流程图">架构流程图</h2>
<p><img src="https://ws1.sinaimg.cn/large/66dd581fly1fq8up9arebj20wu0h5q3o.jpg" alt=""></p>
<p><img src="https://ws1.sinaimg.cn/large/66dd581fly1fq8uplpjkwj20oj0c70t4.jpg" alt=""></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2018/04/10/Fabric-%E6%96%87%E6%A1%A3%E6%8B%BE%E9%81%97/">https://magicliang.github.io/2018/04/10/Fabric-%E6%96%87%E6%A1%A3%E6%8B%BE%E9%81%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/">区块链</a><a class="post-meta__tags" href="/tags/Hyperledger-Fabric/">Hyperledger Fabric</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-128.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2018/03/15/Hyperledger-Fabric-MSP-%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" title="Hyperledger Fabric MSP 相关问题"><img class="cover" src="/img/wall-paper-101.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-03-15</div><div class="info-item-2">Hyperledger Fabric MSP 相关问题</div></div><div class="info-2"><div class="info-item-1">Fabric要求所有的 paticipant 有相关的 identity。identity是由x509证书认证的（大致上也就是各种signcert），每个 identity 有自己的 principal，包含了大量的 property，包括但不仅限于组织名。 PKI 生成 identity，而 MSP 表达治理组织的规则，包括哪些 identity 属于哪些组织，且参与网络中。 PKI PKI 是一种标准，一般由四个元素组成：  Digital Certificates Public and Private Keys Certificate Authorities Certificate Revocation Lists  数字证书 一个持有一个组织的系列属性的数字文件。常见的数字证书是X509标准的，很像一个国家发放的身份证（有名称，省份，国家，还有组织的名字）。  For example, John Doe of Accounting division in FOO Corporation in Detroit, Michigan might have a digital c...</div></div></div></a><a class="pagination-related" href="/2018/03/15/Hyperledger-Fabric-%E7%9A%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E8%AF%BB/" title="Hyperledger Fabric 的配置文件解读"><img class="cover" src="/img/wall-paper-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-03-15</div><div class="info-item-2">Hyperledger Fabric 的配置文件解读</div></div><div class="info-2"><div class="info-item-1">Crypto Generator x.509 相关的文件主要包含两个东西：证书和 signing keys。 cryptogen 使用的配置文件是crypto-config.yaml。 x.509 的根证书是ca-cert。它把 peers 和 orderers 绑定到一个 Org 里面。在这个网络里，每个组织都有签发自己的证书的能力，可以用这个 ca 来签发其他证书给节点和 client。 签发交易用的是私钥（keystore），验证交易用的是公钥（signcerts）。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293# Copyright IBM Corp. All Rights Reserved.## SPDX-License-Identifier: Apache-2.0...</div></div></div></a><a class="pagination-related" href="/2018/04/09/Fabric-%E4%B8%AD%E7%9A%84-peer/" title="Fabric 中的 peer"><img class="cover" src="/img/wall-paper-85.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-04-09</div><div class="info-item-2">Fabric 中的 peer</div></div><div class="info-2"><div class="info-item-1">每个 peer 可以拥有若干个 chaincode，也可以拥有若干个 ledger，但并不是一开始就拥有的，而是逐渐被创建出来的。chaincode 一定会定义一个 asset，也就生成了 ledger。一个peer 可以拥有 ledger 而无 chaincode，可见也并不是必然由 chaincode 生成 ledger。比如同一个组织里面多个 peer，只有一个安装了 chaincode（只有这个 peer 可以当作 endorser），其它的peer一样可以拿到 ledger。 peer 的流程架构图大致上是：  为了预防有 peer 的数据不一致，有可能需要 client application 向多个 peer 进行查询。 channel 可以认为是一系列 peers 的逻辑组合，orderer 可以被认为是跨channel的。同一个 channel 的 peers 共享完全一样的账本。  不同的组织完全可以基于同样的账本copy，产生不同的 application。 Fabric 有 identity，identity 有 principal。 transactio...</div></div></div></a><a class="pagination-related" href="/2018/04/09/Hyperledger-Fabric-%E5%90%84%E4%B8%AA%E5%AE%B9%E5%99%A8%E5%86%85%E7%8E%AF%E5%A2%83/" title="Hyperledger Fabric 各个容器内环境"><img class="cover" src="/img/wall-paper-133.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-04-09</div><div class="info-item-2">Hyperledger Fabric 各个容器内环境</div></div><div class="info-2"><div class="info-item-1">peer 容器 /opt/gopath/src/github.com/hyperledger/fabric/peer 虽然是WORKING_DIR，什么都没有。这个目录是/bin/bash永远的进入路径，不管在哪个目录退出，重新进入还是会进入这个路径。 /etc/hyperledger/fabric 12345678910# 原生的三个配置文件。所以修改peer的行为要通过环境变量来修改，让docker用COMMAND启动peer进程的时候吸收这几个配置文件和环境变量core.yaml# 这两个文件似乎不关peer的事情configtx.yamlorderer.yaml# 这两个文件夹要被外部的数据卷映射修改过来，实际上只能依赖于外部# 这个文件夹本质上还是 core.yaml 默认的 mspConfigPath 的值msptls /var/hyperledger/production 这个文件夹存放unix系统里面的动态程序数据。 123456# 它下面有打包好的CIP（chaincode install package）格式的链码 chaincodes/mycc.1.0。ch...</div></div></div></a><a class="pagination-related" href="/2017/10/27/Hyperledger-Fabric-%E7%BD%91%E7%BB%9C%E7%9A%84%E5%90%AF%E5%8A%A8%E6%AD%A5%E9%AA%A4/" title="Hyperledger Fabric 网络的启动步骤"><img class="cover" src="/img/wall-paper-73.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-27</div><div class="info-item-2">Hyperledger Fabric 网络的启动步骤</div></div><div class="info-2"><div class="info-item-1">  本文是截至日前（2017.10.27）时对官方教程和自我实验的重新梳理。   Hyperledger Fabric 可以说是 Hyperledger 的拳头项目。虽然同为  Apache 的顶级项目，但大部分其他项目都以 Fabric 为基础。它是顶级项目中的顶级项目，可以认为是0级项目。   docker 要有高于 17.06.2-ce 的版本。docker-compose 要有 1.14.0 及以上的版本。当然当前的高版本的 docker 已经自带了高版本的 docker-compose，这通常不用担心。   安装1.9+ 的 Golang。应该预期这样的结果：    echo $GOPATH   /Users/xxx/go   如果这个结果出不来，考虑当前 Shell 的环境变量没有正确设置：   export GOPATH=$HOME/go   export PATH=$PATH:$GOPATH/bin   要用一个很特别的 nodejs 版本。6.9以上，却不能用8.x。npm 也有特别的版本要求：   npm install npm@3.10.10 -g   要用...</div></div></div></a><a class="pagination-related" href="/2017/10/27/%E6%80%9D%E8%80%83%E5%8C%BA%E5%9D%97%E9%93%BE/" title="思考区块链"><img class="cover" src="/img/wall-paper-160.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-27</div><div class="info-item-2">思考区块链</div></div><div class="info-2"><div class="info-item-1"> 区块链是比特币的基础设施。由区块组成链，是为区块链。各个区块链的持有者之间，总是在玩不确定选主的游戏，所以这和所有传统的分布式数据库不同，是一个去中心的数据存储模式。 比特币的区块链是1.0的玩法，以太坊是2.0的玩法。有些人认为 Hyperledger 是3.0的玩法，还有待怀疑。 区块链上的资产，可以是自带的（比特币网络里的比特币，以太坊网络里的以太币），也可以是智能合约定义和约束的。 智能合约是个看起来很美好，实际上只能执行在沙盒里面的东西。曾经在某个IBM程序员的分享里看到过，Hyperledger 的智能合约本质上也是 GO 程序，所以理论上可以做一切事情。但目前没有看到除了调用各种 Shim API 以外的任何用处。比如，如果我们想要用智能合约发出另外一个调用请求，让真实的系统发生转账，如何做到？ 很多人都有热思考，人类再也回不到没有比特币的时代了。也有冷思考，区块链的时代还未到来。就目前而言，现在的计算性能真的不足以支撑真实的行业流量，只能养养鸡，运运肉。 也有观点认为，公有链是真命题，而私有链是伪命题。就目前的观察看来，不管是 Hyperledger 还是 Co...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">1.</span> <span class="toc-text">基本名词解释</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ledger"><span class="toc-number">1.1.</span> <span class="toc-text">ledger</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chain"><span class="toc-number">1.2.</span> <span class="toc-text">chain</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state-database"><span class="toc-number">1.3.</span> <span class="toc-text">state database</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%9B%86%E8%AF%AD%E4%B9%89"><span class="toc-number">1.4.</span> <span class="toc-text">读写集语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%9A%E8%8A%82%E7%82%B9"><span class="toc-number">1.5.</span> <span class="toc-text">锚节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#leader-%E8%8A%82%E7%82%B9"><span class="toc-number">1.6.</span> <span class="toc-text">leader 节点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#member"><span class="toc-number">1.7.</span> <span class="toc-text">Member</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#membership-service-provider"><span class="toc-number">1.8.</span> <span class="toc-text">Membership Service Provider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#membership-services"><span class="toc-number">1.9.</span> <span class="toc-text">Membership Services</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bccsp"><span class="toc-number">1.10.</span> <span class="toc-text">BCCSP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bin-%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">2.</span> <span class="toc-text">bin 文件夹下的内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E6%AD%A5%E9%AA%A4"><span class="toc-number">3.</span> <span class="toc-text">初始化的步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8%E8%84%9A%E6%9C%AC%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">4.</span> <span class="toc-text">启动脚本的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#transaction-%E7%9A%84%E6%B5%81%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">transaction 的流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ca-%E9%97%AE%E9%A2%98"><span class="toc-number">6.</span> <span class="toc-text">CA 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">7.</span> <span class="toc-text">常见端口号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sdk-%E9%97%AE%E9%A2%98"><span class="toc-number">8.</span> <span class="toc-text">SDK 问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%9B%86%E8%AF%AD%E4%B9%89"><span class="toc-number">9.</span> <span class="toc-text">读写集语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#configuration-block"><span class="toc-number">10.</span> <span class="toc-text">configuration block</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#packaging"><span class="toc-number">11.</span> <span class="toc-text">packaging</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%9C%E6%AD%A2%E9%93%BE%E7%A0%81"><span class="toc-number">12.</span> <span class="toc-text">停止链码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E9%93%BE%E7%A0%81"><span class="toc-number">13.</span> <span class="toc-text">系统链码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">14.</span> <span class="toc-text">架构流程图</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>