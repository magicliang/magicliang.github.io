<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>分布式会话技术 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="会话技术 HTTP协议的本质：无状态（Stateless）。   无状态意味着服务器不会记住任何关于客户端的过往请求。你第一次访问和第一万次访问，对于服务器来说，都是一个全新的、陌生的请求。   问题出现：Web应用很快就需要“记住”用户，比如用户是否登录、购物车里有什么商品。如果无法记住，用户每点击一个链接就需要重新登录一次，购物车也会被清空。   Session的诞生：为了解决这个问题，开发者">
<meta property="og:type" content="article">
<meta property="og:title" content="分布式会话技术">
<meta property="og:url" content="https://magicliang.github.io/2025/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="会话技术 HTTP协议的本质：无状态（Stateless）。   无状态意味着服务器不会记住任何关于客户端的过往请求。你第一次访问和第一万次访问，对于服务器来说，都是一个全新的、陌生的请求。   问题出现：Web应用很快就需要“记住”用户，比如用户是否登录、购物车里有什么商品。如果无法记住，用户每点击一个链接就需要重新登录一次，购物车也会被清空。   Session的诞生：为了解决这个问题，开发者">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2025/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/oauth2-arch.png">
<meta property="article:published_time" content="2025-07-03T09:21:32.000Z">
<meta property="article:modified_time" content="2026-01-24T07:32:08.631Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="鉴权">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2025/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/oauth2-arch.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "分布式会话技术",
  "url": "https://magicliang.github.io/2025/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/",
  "image": "https://magicliang.github.io/2025/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/oauth2-arch.png",
  "datePublished": "2025-07-03T09:21:32.000Z",
  "dateModified": "2026-01-24T07:32:08.631Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2025/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '分布式会话技术',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2025/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/oauth2-arch.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">分布式会话技术</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">分布式会话技术</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-03T09:21:32.000Z" title="Created 2025-07-03 17:21:32">2025-07-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T07:32:08.631Z" title="Updated 2026-01-24 15:32:08">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">14.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>53mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>会话技术</h1>
<p>HTTP协议的本质：无状态（Stateless）。</p>
<ul>
<li>
<p>无状态意味着服务器不会记住任何关于客户端的过往请求。你第一次访问和第一万次访问，对于服务器来说，都是一个全新的、陌生的请求。</p>
</li>
<li>
<p>问题出现：Web应用很快就需要“记住”用户，比如用户是否登录、购物车里有什么商品。如果无法记住，用户每点击一个链接就需要重新登录一次，购物车也会被清空。</p>
</li>
<li>
<p>Session的诞生：为了解决这个问题，开发者们引入了“Session”这个逻辑概念。它的目标很简单：在无状态的HTTP之上，人为地创造出一个“有状态的对话（Stateful Conversation）”。</p>
</li>
</ul>
<p>常见的技术有3种：</p>
<ol>
<li>
<p>cookie：我们接下来会看到的技术。安全设计比较完备。<code>Set-Cookie</code>和<code>Cookie</code>是对位的header。</p>
</li>
<li>
<p>url query param：服务器主动把返回的 html 里所有的<code>&lt;a href&gt;</code>都加上 session id。这种方式是特别不安全的，因为分享链接意味着会话状态暴露。</p>
</li>
<li>
<p>隐藏表单。在生成 HTML 页面时，动态地嵌入一个<code>&lt;input&gt;</code>标签，并将其 type 属性设置为 hidden。服务器在处理一个请求时，确定了有一些信息需要“记住”或者传递到下一个请求。这些信息不是给用户看的，而是给程序自己用的。例如：产品ID、用户的唯一标识、一个安全令牌（Token）等。完全不安全（Hidden is NOT Secure）：这是它最致命的缺点。“隐藏”不等于“安全”。任何一个懂点的用户都可以通过在浏览器中“查看网页源代码”或使用开发者工具（F12）轻松看到隐藏域的值。</p>
</li>
</ol>
<p>这三种技术都不能真的实现把信息完全从服务端剥离的目的，数据细节仍然是需要放在专门的存储-MySQL、Redis里，而这些载体主要存储 id-包括jwt。</p>
<h1>关键 header</h1>
<h2 id="每次都应该有的基础header">每次都应该有的基础Header</h2>
<ol>
<li>Content-Type</li>
</ol>
<ul>
<li>作用：告诉浏览器响应体是什么类型的数据。这是最基本的Header之一。</li>
<li>示例：Content-Type: text/html; charset=utf-8 (HTML页面), Content-Type: application/json (JSON数据), Content-Type: image/jpeg (图片)。</li>
<li>重要性：如果缺失，浏览器只能去猜测内容类型，可能导致页面渲染错误或安全问题，会导致很多<strong>文件不能打开，而只能下载</strong>。</li>
</ul>
<ol start="2">
<li>Content-Length 或 Transfer-Encoding</li>
</ol>
<ul>
<li>作用：告诉浏览器响应体的长度。</li>
<li>Content-Length: 一次性告知总长度。</li>
<li>Transfer-Encoding: chunked: 表示响应体是分块传输的，长度未知。</li>
<li>重要性：两者必有其一（对于有响应体的请求），用于浏览器正确接收数据和管理连接。否则response可能会中断。</li>
</ul>
<ol start="3">
<li>Date</li>
</ol>
<ul>
<li>作用：提供响应消息被创建的日期和时间。</li>
<li>重要性：HTTP/1.1规范要求服务器包含此字段。</li>
</ul>
<h2 id="强烈推荐每次都包含的header-尤其是安全和缓存">强烈推荐每次都包含的Header（尤其是安全和缓存）</h2>
<ol>
<li>Cache-Control</li>
</ol>
<ul>
<li>作用：精细地控制浏览器和代理服务器如何缓存此响应。</li>
<li>示例：Cache-Control: no-store (完全不缓存), Cache-Control: public, max-age=3600 (公开缓存1小时)。</li>
<li>重要性：对于提升网站性能和保证数据新鲜度至关重要。</li>
</ul>
<ol start="2">
<li>Strict-Transport-Security (HSTS)</li>
</ol>
<ul>
<li>作用：强制浏览器在未来的一段时间内，只能通过HTTPS访问此站点。</li>
<li>重要性：极大地提升了网站的安全性，防止中间人攻击。</li>
</ul>
<ol start="3">
<li>X-Content-Type-Options</li>
</ol>
<ul>
<li>作用：固定为nosniff，防止浏览器对Content-Type进行“嗅探”猜测，避免某些类型的攻击。</li>
<li>重要性：一个简单有效的安全加固措施。</li>
</ul>
<ol start="4">
<li>Content-Security-Policy (CSP)</li>
</ol>
<ul>
<li>作用：定义一个可信内容源的白名单，帮助抵御XSS（跨站脚本）攻击。</li>
<li>重要性：现代Web安全的核心防御机制之一。</li>
</ul>
<h1>cookie 技术</h1>
<p>cookie 是为了“弥补 http 无状态”而特别设计出来的“可重放的 header”。它的定位 small block of data。起源于 Unix 程序员里的小 packet data，recieved and sends back unchanged，本来是网景用来实现虚拟购物车用的，后来逐渐成为严重的隐私问题。为了防止被盗用，通常它不是具体的数据，而是一个加密过的id，或者一个会话id。</p>
<h2 id="cookie-的属性">cookie 的属性</h2>
<ul>
<li>domain：如果不设置就是默认当前的域（包括子域）：d2ksr8gxr5kl2o（子域名）.cloudfront（主域名）.net（顶级域名）：<a target="_blank" rel="noopener" href="http://sina.com">sina.com</a>（主域名），<a target="_blank" rel="noopener" href="http://sso.sina.com">sso.sina.com</a>（二级域名）。
<ul>
<li><a target="_blank" rel="noopener" href="http://d2ksr8gxr5kl2o.cloudfront.net">d2ksr8gxr5kl2o.cloudfront.net</a> 的 cookie 不能用在任何 <a target="_blank" rel="noopener" href="http://xxx.cloudfront.net">xxx.cloudfront.net</a> 上。</li>
</ul>
</li>
<li>path：如果不设置则为当前路径的父路径，所以最好设置为/。</li>
<li>MaxAge/Expires：旧版本协议用 Expires，新版本用MaxAge。每次check ticket/ check token，得到了 expire time，<strong>都要专门使用 Set-Cookie 来延长 cookie 的寿命</strong>，不要忘记。</li>
<li>HttpOnly：当设置为true时，表示该 Cookie 只能通过 HTTP/HTTPS 协议访问。这种设置可以防止 JavaScript 通过 document.cookie 访问该 Cookie，从而降低 XSS (跨站脚本)攻击的风险。这是 Web 安全的最佳实践之一，特别适用于存储敏感信息(如认证令牌)的Cookie。但这个方案不能替代同源策略 SOP。</li>
<li>Secure： 是否使用 https</li>
<li>SameSite：
<ul>
<li>SameSite=Strict：最严格。只有当请求完全来自于你当前正在浏览的网站时，才会发送Cookie。<a target="_blank" rel="noopener" href="http://xn--example-l45kk29c7qf8x2d.xn--comexample-sf2pypu32bjva080soz2bi3zg5sf4rmt6p.com/other%EF%BC%8C%E4%BC%9A%E5%8F%91%E9%80%81">比如你在example.com里点击一个链接跳转到example.com/other，会发送</a> cookie。<a target="_blank" rel="noopener" href="http://xn--google-hi9i2g177d7qfu88b.xn--comexample-sf2pxdvs096b1waz08scq4b965gx3f184a.com">但如果你在google.com上点击一个链接跳转到example.com</a>，则不会发送。
<ul>
<li>典型场景：在线银行登录 Cookie，防止从搜索引擎或邮件链接直接进入后自动带会话。
<ul>
<li>当用户从 Google 点击链接进入已登录且 SameSite=Strict 的 Twitter 时，浏览器在首次跨站 GET 请求中因 SameSite 限制不会携带登录 Cookie，Twitter 认定未登录而返回访客页；随后用户只要按 F5 刷新，这次同站导航 Cookie 被自动带上，页面立即呈现已登录状态，无需重新输入凭据。</li>
</ul>
</li>
</ul>
</li>
<li>SameSite=Lax (现代浏览器默认值)：一个折中。允许在一些顶层导航（比如从其他网站点击链接跳转过来-方法等于 GET，且必须是一次“顶层文档请求”（top-level document request，常见于从搜索引擎跳过来无需登录），浏览器会把返回的响应作为新的顶层浏览上下文（top-level browsing context） 来渲染）时发送Cookie，但会阻止在跨站的子请求（如加载图片、iframe、AJAX请求）中发送-防止了一部分 CSRF 攻击。
<ul>
<li>典型场景：普通网站希望用户在 Google 搜索后点击链接进入时保持登录，但阻止 CSRF 表单提交。</li>
</ul>
</li>
<li>SameSite=None：最宽松。允许在所有跨站请求中发送Cookie，<strong>但必须同时设置Secure标志（即只能用于HTTPS）</strong>。
<ul>
<li>典型场景：第三方广告、跨域单点登录、CDN 资源需要身份凭证</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="cookie-的重放">cookie 的重放</h2>
<p>总结：服务器对Set-Cookie的使用是指令性和事件驱动的，而不是每次都无脑重放。</p>
<ol>
<li>
<p>Set-Cookie 是一个特殊的、浏览器能看懂的指令。浏览器识别出这个Header后，会自动地、安全地将Cookie内容保存在自己专门的存储区里。浏览器会自动地检查本地存储的Cookie，如果发现有匹配当前域名和路径的Cookie，就会在后续的请求中自动地添加 Cookie 请求头，把数据发回给服务器。</p>
</li>
<li>
<p>服务端通常不需要每次都 Set-Cookie（<strong>完全没有这个规范，而且通常是应该极力避免的错误实践</strong>），但是如果如果需要动态更新 cookie，则需要设计一个前后端不断接力的 cookie 机制。</p>
</li>
<li>
<p>服务端频繁 Set-Cookie 的缺点是：</p>
</li>
</ol>
<ul>
<li>浪费带宽：每个HTTP响应都增加了一些不必要的Header数据。</li>
<li>逻辑混乱：让开发者和调试工具难以判断Set-Cookie的真实意图。</li>
</ul>
<ol start="4">
<li>服务器只在以下四种明确的场景下，才应该发送Set-Cookie头：
<ul>
<li>
<p>创建Cookie：当用户首次登录或触发某个功能时，服务器需要创建一个新的会话或状态标识，此时发送Set-Cookie来在浏览器中“种下”这个Cookie。</p>
</li>
<li>
<p>修改Cookie：当需要更新Cookie的值时。一个最经典的安全实践是会话更新（Session Regeneration）：当用户登录成功后，服务器应该废弃旧的会话ID（登录前的），并生成一个全新的会话ID，通过Set-Cookie下发给浏览器，以防止会话固定（Session Fixation）攻击。</p>
</li>
<li>
<p>续期Cookie：如果你的会话策略是“滑动过期”（Sliding Expiration，即用户有操作就自动延长过期时间），那么在用户每次与服务器交互时，服务器都应该发送一个带有新的过期时间的Set-Cookie头，来为会话“续命”。</p>
</li>
<li>
<p>删除Cookie：删除一个Cookie的标准方法，就是发送一个同名、同路径、同域的Set-Cookie头，并将其过期时间设置为一个过去的时间点（或Max-Age=0）。</p>
</li>
</ul>
</li>
</ol>
<h2 id="与其他-web-storage-indexeddb-localstorage-对比">与其他 Web Storage（IndexedDB、LocalStorage）对比</h2>
<h3 id="cookie的局限性">Cookie的局限性</h3>
<ol>
<li>
<p>容量太小：每个Cookie的大小被限制在4KB左右，一个域名下的Cookie总数也有限制（通常是20-50个）。这对于存储少量身份信息足够，但无法存储更复杂的数据。</p>
</li>
<li>
<p>性能开销：Cookie在每次HTTP请求中都会被完整地携带在请求头里，即使当前请求完全不需要这些数据（比如请求一张图片或一个CSS文件）。如果Cookie很大，会明显增加网络流量，造成不必要的性能浪费。</p>
</li>
<li>
<p>API不友好：原生操作Cookie的API document.cookie 是一个简单的字符串，读写和解析都非常不便。</p>
</li>
<li>
<p>定位不纯粹：Cookie的设计初衷是“服务器与客户端的通信”，而不是纯粹的“客户端本地存储”。</p>
</li>
</ol>
<h4 id="third-party-cookie">third-party cookie</h4>
<ul>
<li>第一步：埋下追踪器
<ul>
<li>你访问了一个新闻网站 <a target="_blank" rel="noopener" href="http://A.com">A.com</a>。</li>
<li>这个网站上有一个来自广告联盟 <a target="_blank" rel="noopener" href="http://Ad-Network.com">Ad-Network.com</a> 的广告位。当你加载A.com时，你的浏览器也向Ad-Network.com发出了请求以下载广告。</li>
<li>此时，<a target="_blank" rel="noopener" href="http://Ad-Network.com">Ad-Network.com</a> 就在你的浏览器里“种下”了一个属于它自己的第三方Cookie。这个Cookie里有一个独一无二的ID，比如 ID=xyz123。</li>
</ul>
</li>
<li>第二步：跨站追踪
<ul>
<li>过了一会儿，你又去访问一个购物网站 <a target="_blank" rel="noopener" href="http://B.com">B.com</a>，它恰好也使用了同一个广告联盟 <a target="_blank" rel="noopener" href="http://Ad-Network.com">Ad-Network.com</a>。</li>
<li>当你加载B.com时，浏览器同样会请求Ad-Network.com的资源。这时，浏览器会自动带上之前存下的那个ID=xyz123的Cookie。</li>
<li><a target="_blank" rel="noopener" href="http://Ad-Network.com">Ad-Network.com</a> 的服务器看到这个ID，立刻就知道：“哦！访问B.com的这个人，就是刚才访问了A.com的那个人！”</li>
</ul>
</li>
<li>第三步：建立你的“数字档案”
<ul>
<li>你继续访问汽车论坛 <a target="_blank" rel="noopener" href="http://C.com">C.com</a>，旅游博客 <a target="_blank" rel="noopener" href="http://D.com">D.com</a>… 只要这些网站上有 <a target="_blank" rel="noopener" href="http://Ad-Network.com">Ad-Network.com</a> 的“探针”（广告、分析脚本等），你的行踪就会被一次又一次地记录下来。</li>
<li>久而久之，<a target="_blank" rel="noopener" href="http://Ad-Network.com">Ad-Network.com</a> 就围绕着 ID=xyz123 这个Cookie，建立起了一个关于你的、极其详尽的**“数字侧写”或“影子档案”**：
<ul>
<li>你的兴趣：你对数码产品、汽车、东南亚旅游感兴趣。</li>
<li>你的意图：你最近可能在考虑买车或计划度假。</li>
<li>你的特征：结合数据分析，它甚至能推断出你的大致年龄、消费水平、政治倾向等。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="hljs mermaid">sequenceDiagram
    actor User as 你
    participant Browser as 浏览器
    participant A as 新闻站 A.com
    participant Ad as Ad-Network.com
    participant B as 购物站 B.com
    participant C as 汽车论坛 C.com
    participant D as 旅游博客 D.com
    participant Profile as 数字档案

    Note over User,Ad: 第一步 - 埋下追踪器
    User-&gt;&gt;A: 打开 A.com
    A-&gt;&gt;Browser: HTML + iframe指向Ad-Network.com/ad
    Browser-&gt;&gt;Ad: 请求广告
    Note right of Ad: Set-Cookie ID=xyz123
    Browser--&gt;&gt;Browser: 存储第三方 Cookie

    Note over User,Ad: 第二步 - 跨站追踪
    User-&gt;&gt;B: 打开 B.com
    B-&gt;&gt;Browser: HTML + img指向Ad-Network.com/pixel
    Browser-&gt;&gt;Ad: 请求像素 自动带Cookie ID=xyz123
    Ad--&gt;&gt;Ad: 记录 A到B 的同一用户

    Note over User,Ad: 第三步 - 继续追踪并汇总档案
    loop 浏览更多站点
        User-&gt;&gt;C: 浏览汽车论坛
        Browser-&gt;&gt;Ad: 请求广告 带Cookie ID=xyz123
        Ad--&gt;&gt;Ad: 记录汽车兴趣

        User-&gt;&gt;D: 浏览旅游博客
        Browser-&gt;&gt;Ad: 请求广告 带Cookie ID=xyz123
        Ad--&gt;&gt;Ad: 记录旅游意图
    end

    Ad-&gt;&gt;Profile: 按 ID=xyz123 汇总
    Note right of Profile: 数字档案/影子档案</code></pre>
<p><strong>一切问题都是同一个广告联盟的广告位+后台日志汇总的结果</strong>！</p>
<h3 id="web-storage-localstorage-sessionstorage-的出现解决了这些问题">Web Storage（LocalStorage, SessionStorage）的出现解决了这些问题</h3>
<ol>
<li>
<p>容量更大：LocalStorage提供了5-10MB的存储空间，远超Cookie的4KB，可以存储大量的JSON数据、配置信息等。</p>
</li>
<li>
<p>性能更优：LocalStorage中存储的数据不会被自动附加到HTTP请求头中。它纯粹是客户端的本地仓库，只在需要时通过JavaScript手动读取。这避免了Cookie带来的性能开销。</p>
</li>
<li>
<p>API更友好：提供了简单的键值对API，如 localStorage.setItem(‘key’, ‘value’), localStorage.getItem(‘key’)，操作非常方便。</p>
</li>
<li>
<p>定位纯粹：它的定位就是纯粹的客户端存储，与服务器通信无关。</p>
</li>
</ol>
<h3 id="indexeddb则更进一步">IndexedDB则更进一步</h3>
<p>如果说LocalStorage是一个简单的“键值对”仓库，那么IndexedDB就是一个功能完善的客户端小型数据库。</p>
<ol>
<li>
<p>解决复杂数据存储：它支持存储大量的结构化数据（JSON对象），并能创建索引来快速查询。这对于需要离线功能、本地数据缓存、PWA（渐进式Web应用）等复杂场景至关重要。</p>
</li>
<li>
<p>支持事务：IndexedDB的操作是事务性的，保证了数据操作的原子性、一致性、隔离性和持久性（ACID特性），非常可靠。</p>
</li>
<li>
<p>异步API：它的API是异步的，不会阻塞浏览器主线程，适合处理大量数据的读写操作。</p>
</li>
</ol>
<h3 id="总结">总结</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>Cookie (小饼干)</th>
<th>localStorage (文件柜)</th>
<th>IndexedDB (图书馆)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心用途</strong></td>
<td>服务器驱动的状态管理。主要用于服务器识别用户、维持会话（如登录状态）</td>
<td>客户端的简单数据存储。主要用于存储用户偏好、UI状态等纯客户端数据</td>
<td>客户端的复杂数据存储。用于构建离线应用、缓存大量结构化数据</td>
</tr>
<tr>
<td><strong>与服务器通信</strong></td>
<td>自动发送。在每次符合条件的HTTP请求中，都会被自动添加到 Cookie 请求头里</td>
<td>从不自动发送。必须由你手动编写JavaScript代码（如 fetch）来读取并发送给服务器</td>
<td>从不自动发送。和 localStorage 一样，必须手动发送</td>
</tr>
<tr>
<td><strong>容量大小</strong></td>
<td>非常小，约 4KB</td>
<td>较大，约 5-10MB</td>
<td>巨大，可达数百MB甚至GB级别（取决于浏览器和用户授权）</td>
</tr>
<tr>
<td><strong>数据类型</strong></td>
<td>只能是字符串</td>
<td>只能是字符串（通常用 JSON.stringify 存对象）</td>
<td>几乎所有类型：字符串、数字、对象、数组、文件(Blob)等</td>
</tr>
<tr>
<td><strong>API易用性</strong></td>
<td>难用。通过 document.cookie 操作，需要手动解析字符串</td>
<td>非常简单。同步的.setItem, getItem 键值对操作</td>
<td>非常复杂。异步的、基于事务和事件的API，像一个真正的数据库</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>可设置过期时间。到期后浏览器自动删除</td>
<td>永久有效。除非用户手动清除或代码主动删除，否则永不过期</td>
<td>永久有效。和 localStorage 一样</td>
</tr>
<tr>
<td><strong>访问范围</strong></td>
<td>只能在主线程中访问</td>
<td>只能在主线程中访问</td>
<td>可以在Web Workers (后台线程)中访问，适合处理复杂计算不阻塞页面</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>Cookie 的本质是“服务器的备忘录”，它写在你的浏览器上，每次你访问服务器时，浏览器都会自动带上这个备忘录。它的缺点是容量小，且每次都带上会浪费流量。</p>
</li>
<li>
<p>localStorage 是纯粹“浏览器的记事本”，你想记什么就记什么，服务器完全不知道。只有当你需要时，你才用代码把记事本里的内容告诉服务器。</p>
</li>
<li>
<p>IndexedDB 是“浏览器的数据库”，当你的应用需要在本地存储大量结构化信息（比如一个邮件客户端要离线存储所有邮件），并且需要高效查询时，就用它。</p>
</li>
</ul>
<h1>jwt</h1>
<h2 id="起因">起因</h2>
<p>现代的 http 的客户端实现和服务器端实现并不是真正的无状态。</p>
<ol>
<li>
<p>针对特定的域，客户端需要 cookie 重放：</p>
<ul>
<li>但是移动端的浏览器没有 cookie 机制。</li>
<li>cookie 重放要处理跨域问题。</li>
</ul>
</li>
<li>
<p>服务器必须使用内存来关联 session id，把 session 的内容放在单一服务器，或者分布式 session 的载体里。这就产生了 session 共享、session 黏着之类的与“无状态”正相反的 http 服务端问题。</p>
</li>
</ol>
<h2 id="核心思想">核心思想</h2>
<p>服务器不再存储Session，而是将用户信息本身加密后生成一个令牌(Token)，返给客户端。客户端在后续请求中携带这个Token，<strong>服务器只需验证Token的合法性即可</strong>，无需查询任何存储。</p>
<h2 id="结构">结构</h2>
<p><code>Header.Payload.Signature</code></p>
<p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code></p>
<ul>
<li>
<p>Header (头部)：描述JWT元数据，通常包含两部分：令牌类型（typ: “JWT”）和所使用的签名算法（alg: “HS256”, &quot;RS256&quot;等）。这部分会进行Base64Url编码。</p>
</li>
<li>
<p>Payload (载荷)：存放实际需要传递的数据，也称为Claims（声明）。包含一些标准字段（如iss签发者, exp过期时间, sub主题），也可以自定义私有字段（如userId, role）。注意：Payload默认只是Base64Url编码，不是加密，所以不应存放敏感信息。</p>
</li>
<li>
<p>Signature (签名)：这是JWT最核心的部分。计算方式是：</p>
<ul>
<li>
<p>将编码后的Header和编码后的Payload用点 . 连接起来。</p>
</li>
<li>
<p>使用Header中指定的算法**，配合一个只有服务器知道的密钥 (Secret)**，对连接后的字符串进行签名。</p>
</li>
</ul>
</li>
</ul>
<p>签名的作用是：保证Token在传输过程中没有被篡改。当服务器收到Token后，会用同样的算法和密钥重新计算签名。如果计算出的签名与Token中的签名一致，说明数据是可信的；如果不一致，则说明Token是伪造的或被修改过。</p>
<p>验证合法性只要使用单向签名算法就能实现。</p>
<p>在实践中，我们在 jwt 的 claim 里最好只放入一些会话id，把大的数据结构存入 db 或者 redis里，把 jwt的 claim 当作存储指针的地方来用。</p>
<h2 id="例子">例子</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> security.jwt;<br><br><br><span class="hljs-keyword">import</span> com.auth0.jwt.JWT;<br><span class="hljs-keyword">import</span> com.auth0.jwt.JWTVerifier;<br><span class="hljs-keyword">import</span> com.auth0.jwt.algorithms.Algorithm;<br><span class="hljs-keyword">import</span> com.auth0.jwt.exceptions.JWTVerificationException;<br><span class="hljs-keyword">import</span> com.auth0.jwt.interfaces.DecodedJWT;<br><span class="hljs-keyword">import</span> java.util.Date;<br><span class="hljs-keyword">import</span> java.util.UUID;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JwtUtil</span> &#123;<br><br>    <span class="hljs-comment">// 定义密钥 (在真实项目中，应从配置文件中读取，且更为复杂)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SECRET_KEY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;your-super-secret-key-that-is-long-and-secure&quot;</span>;<br><br>    <span class="hljs-comment">// 定义签发者</span><br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Issuer和Subject的选择原则：</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Issuer：应该使用能唯一标识你的认证服务的字符串，通常可以是：</span><br><span class="hljs-comment">     *   - 你的应用域名（如auth.yourdomain.com）</span><br><span class="hljs-comment">     *   - 服务名称（如当前代码中的MyAppAuthService）</span><br><span class="hljs-comment">     *   - 在微服务架构中，建议使用服务注册中心的名称</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Subject：应该使用能唯一标识用户的字符串，通常可以是：</span><br><span class="hljs-comment">     *   - 用户ID（如当前代码中的userId）</span><br><span class="hljs-comment">     *   - 用户邮箱/用户名（如果它们是唯一的）</span><br><span class="hljs-comment">     *   - 不建议使用可变的用户信息作为Subject</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ISSUER</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;MyAppAuthService&quot;</span>;<br><br>    <span class="hljs-comment">// 定义过期时间 (例如：1小时)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">EXPIRATION_TIME_MS</span> <span class="hljs-operator">=</span> <span class="hljs-number">3600</span> * <span class="hljs-number">1000</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个JWT.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> userId 用户的唯一标识</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> role 用户的角色</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 生成的JWT字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">createToken</span><span class="hljs-params">(String userId, String role)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1. 选择签名算法</span><br>            <span class="hljs-type">Algorithm</span> <span class="hljs-variable">algorithm</span> <span class="hljs-operator">=</span> Algorithm.HMAC256(SECRET_KEY);<br><br>            <span class="hljs-comment">// 2. 生成JWT</span><br>            <span class="hljs-keyword">return</span> JWT.create()<br>                    .withIssuer(ISSUER) <span class="hljs-comment">// 签发者</span><br>                    .withSubject(userId) <span class="hljs-comment">// 主题，通常是用户ID</span><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * 不要将所有状态放入JWT：JWT应该保持精简，只包含认证和授权必需的信息</span><br><span class="hljs-comment">                     * 推荐做法：</span><br><span class="hljs-comment">                     * public static String createToken(String userId, String role, Map&lt;String, Object&gt;</span><br><span class="hljs-comment">                     * additionalClaims) &#123;    // ...其他代码不变...    JWT.create()        .withIssuer(ISSUER)</span><br><span class="hljs-comment">                     * .withSubject(userId)        .withClaim(&quot;role&quot;, role)        // 添加额外声明        .withClaim</span><br><span class="hljs-comment">                     * (&quot;userData&quot;, additionalClaims)        // ...其他代码...&#125;</span><br><span class="hljs-comment">                     * 替代方案：</span><br><span class="hljs-comment">                     *   - 只在JWT中存储引用ID（如购物车ID），然后在服务端存储完整数据</span><br><span class="hljs-comment">                     *   - 使用短期有效的JWT配合服务端会话存储</span><br><span class="hljs-comment">                     *   - 对于频繁变更的数据（如购物车），建议使用数据库存储</span><br><span class="hljs-comment">                     */</span><br>                    .withClaim(<span class="hljs-string">&quot;role&quot;</span>, role) <span class="hljs-comment">// 自定义声明 (payload)</span><br>                    .withIssuedAt(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>()) <span class="hljs-comment">// 签发时间</span><br>                    .withExpiresAt(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(System.currentTimeMillis() + EXPIRATION_TIME_MS)) <span class="hljs-comment">// 过期时间</span><br>                    .withJWTId(UUID.randomUUID().toString()) <span class="hljs-comment">// JWT的唯一身份标识</span><br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                     * - JWT大小限制：HTTP头部通常有大小限制（如8KB）</span><br><span class="hljs-comment">                     * - 安全性：敏感信息不应放在JWT中，因为JWT可以被解码（只是不能篡改）</span><br><span class="hljs-comment">                     * - 性能：每次请求都会携带JWT，过大的JWT会影响性能</span><br><span class="hljs-comment">                     *</span><br><span class="hljs-comment">                     * - JWT的设计初衷：</span><br><span class="hljs-comment">                     *      - JWT确实是为了实现无状态认证而设计的，但这里的&quot;状态&quot;主要指会话状态（如用户身份、权限等）</span><br><span class="hljs-comment">                     *      - 它解决了传统session需要服务端存储会话数据的问题，使得服务端只需验证JWT签名即可确认用户身份</span><br><span class="hljs-comment">                     *  - 实际应用中的权衡：</span><br><span class="hljs-comment">                     *      - 技术限制：</span><br><span class="hljs-comment">                     *          - HTTP头部大小限制（通常8KB）</span><br><span class="hljs-comment">                     *          - JWT一旦签发就无法修改（除非重新生成）</span><br><span class="hljs-comment">                     *      - 业务需求：</span><br><span class="hljs-comment">                     *          - 购物车、地址等数据频繁变化</span><br><span class="hljs-comment">                     *          - 这些数据通常需要与其他系统共享（如支付系统、物流系统）</span><br><span class="hljs-comment">                     */</span><br>                    .sign(algorithm); <span class="hljs-comment">// 使用算法进行签名</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 处理异常，例如记录日志</span><br>            System.err.println(<span class="hljs-string">&quot;Error creating JWT: &quot;</span> + e.getMessage());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 验证一个JWT并解码.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> token JWT字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 解码后的JWT对象，如果验证失败则返回null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DecodedJWT <span class="hljs-title function_">verifyToken</span><span class="hljs-params">(String token)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 1. 选择与创建时相同的签名算法</span><br>            <span class="hljs-type">Algorithm</span> <span class="hljs-variable">algorithm</span> <span class="hljs-operator">=</span> Algorithm.HMAC256(SECRET_KEY);<br><br>            <span class="hljs-comment">// 2. 构建验证器</span><br>            <span class="hljs-type">JWTVerifier</span> <span class="hljs-variable">verifier</span> <span class="hljs-operator">=</span> JWT.require(algorithm)<br>                    .withIssuer(ISSUER) <span class="hljs-comment">// 验证签发者</span><br>                    .build(); <span class="hljs-comment">// 创建验证器实例</span><br><br>            <span class="hljs-comment">// 3. 执行验证</span><br>            <span class="hljs-keyword">return</span> verifier.verify(token);<br>        &#125; <span class="hljs-keyword">catch</span> (JWTVerificationException e) &#123;<br>            <span class="hljs-comment">// 验证失败 (例如：签名不匹配, token过期等)</span><br>            System.err.println(<span class="hljs-string">&quot;JWT Verification failed: &quot;</span> + e.getMessage());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// --- 模拟登录成功，生成Token ---</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;user123&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">userRole</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;admin&quot;</span>;<br>        System.out.println(<span class="hljs-string">&quot;--- Generating Token ---&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> createToken(userId, userRole);<br>        System.out.println(<span class="hljs-string">&quot;Generated Token: &quot;</span> + token);<br>        System.out.println();<br><br>        <span class="hljs-comment">// --- 模拟后续请求，验证Token ---</span><br>        System.out.println(<span class="hljs-string">&quot;--- Verifying Token ---&quot;</span>);<br>        <span class="hljs-keyword">if</span> (token != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">DecodedJWT</span> <span class="hljs-variable">decodedJWT</span> <span class="hljs-operator">=</span> verifyToken(token);<br><br>            <span class="hljs-keyword">if</span> (decodedJWT != <span class="hljs-literal">null</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Verification Successful!&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">verifiedUserId</span> <span class="hljs-operator">=</span> decodedJWT.getSubject();<br>                <span class="hljs-type">String</span> <span class="hljs-variable">verifiedRole</span> <span class="hljs-operator">=</span> decodedJWT.getClaim(<span class="hljs-string">&quot;role&quot;</span>).asString();<br>                <span class="hljs-type">Date</span> <span class="hljs-variable">expiresAt</span> <span class="hljs-operator">=</span> decodedJWT.getExpiresAt();<br><br>                System.out.println(<span class="hljs-string">&quot;User ID: &quot;</span> + verifiedUserId);<br>                System.out.println(<span class="hljs-string">&quot;User Role: &quot;</span> + verifiedRole);<br>                System.out.println(<span class="hljs-string">&quot;Expires At: &quot;</span> + expiresAt);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Verification Failed!&quot;</span>);<br>            &#125;<br>        &#125;<br><br>        System.out.println(<span class="hljs-string">&quot;\n--- Verifying a Tampered Token ---&quot;</span>);<br>        <span class="hljs-comment">// 模拟一个被篡改的token (在payload部分添加了额外字符)</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">tamperedToken</span> <span class="hljs-operator">=</span><br>                token.substring(<span class="hljs-number">0</span>, token.indexOf(<span class="hljs-string">&#x27;.&#x27;</span>) + <span class="hljs-number">10</span>) + <span class="hljs-string">&quot;tamper&quot;</span> + token.substring(token.indexOf(<span class="hljs-string">&#x27;.&#x27;</span>) + <span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">&quot;Tampered Token: &quot;</span> + tamperedToken);<br>        verifyToken(tamperedToken); <span class="hljs-comment">// 这将会验证失败</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<h2 id="类似的-token">类似的 token</h2>
<p>这类变体令牌的结构通常都是：某个散列算法(客户appid+待签名信息+时间戳明文)，然后把关键信息隐藏，把其他部分拿来拼接出明文。</p>
<p>如果使用 secret 方案，则一开始就由发布方给出关键密钥，差别在于不同的散列算法。JWT 默认也是使用隐藏密钥的方案的。</p>
<p>如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 方法一</span><br><span class="hljs-comment">// GenToken token生成</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *Token)</span></span> GenToken(client <span class="hljs-type">string</span>, secret <span class="hljs-type">string</span>, algorithm Algorithm) <span class="hljs-type">string</span> &#123;<br>    now := <span class="hljs-type">int</span>(time.Now().Unix())<br>    <span class="hljs-keyword">var</span> sign <span class="hljs-type">string</span><br>    <span class="hljs-keyword">switch</span> algorithm &#123;<br>    <span class="hljs-keyword">case</span> SHA1:<br>        s := sha1.Sum([]<span class="hljs-type">byte</span>(client + secret + strconv.Itoa(now))) <span class="hljs-comment">// #nosec</span><br>        sign = fmt.Sprintf(<span class="hljs-string">&quot;%x&quot;</span>, s)<br>    <span class="hljs-keyword">case</span> MD5:<br>        s := md5.Sum([]<span class="hljs-type">byte</span>(client + secret + strconv.Itoa(now))) <span class="hljs-comment">//nolint:gosec</span><br>        sign = fmt.Sprintf(<span class="hljs-string">&quot;%x&quot;</span>, s)<br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-built_in">panic</span>(errors.New(<span class="hljs-string">&quot;Not supported algorithm: &quot;</span> + <span class="hljs-type">string</span>(algorithm)))<br>    &#125;<br>    token := client + <span class="hljs-string">&quot;,&quot;</span> + strconv.Itoa(now) + <span class="hljs-string">&quot;,&quot;</span> + sign<br>    <span class="hljs-keyword">return</span> base64.StdEncoding.EncodeToString([]<span class="hljs-type">byte</span>(token))<br>&#125;<br><br><span class="hljs-comment">// 方法2</span><br><br><span class="hljs-comment">// GenerateGeneralToken 生成全局token</span><br><span class="hljs-comment">// 参数:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  appID: 应用ID</span><br><span class="hljs-comment">//  appSecret: 应用密钥</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 返回值:</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//  生成的token字符串</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GenerateGeneralToken</span><span class="hljs-params">(appID, appSecret <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>    now := <span class="hljs-type">int</span>(time.Now().Unix())<br>    nowStr := strconv.Itoa(now)<br>    sign := Sha1([]<span class="hljs-type">byte</span>(appID + appSecret + nowStr))<br>    token := appID + <span class="hljs-string">&quot;,&quot;</span> + nowStr + <span class="hljs-string">&quot;,&quot;</span> + sign<br>    <span class="hljs-keyword">return</span> base64.StdEncoding.EncodeToString([]<span class="hljs-type">byte</span>(token))<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">encode</span><span class="hljs-params">(String appId, String appSecret, Long timestamp)</span> &#123;<br>       <span class="hljs-keyword">if</span> (appId == <span class="hljs-literal">null</span> || appId.isEmpty()) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;No appId&quot;</span>);<br>       &#125;<br>       <span class="hljs-keyword">if</span> (appSecret == <span class="hljs-literal">null</span> || appSecret.isEmpty()) &#123;<br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unable find the suitable appSecret.&quot;</span>);<br>       &#125;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">sign</span> <span class="hljs-operator">=</span> sign(appId, appSecret, timestamp);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">plain</span> <span class="hljs-operator">=</span> compose(appId, timestamp, sign);<br><br>       <span class="hljs-keyword">return</span> Base64.encodeBase64String(plain.getBytes());<br>   &#125;<br><br>   <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">sign</span><span class="hljs-params">(String appId, String appSecret, <span class="hljs-type">long</span> timestamp)</span> &#123;<br>       <span class="hljs-keyword">return</span> SignAlgorithm.SHA1.apply(String.format(<span class="hljs-string">&quot;%s%s%d&quot;</span>, appId, appSecret, timestamp));<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 组装数据</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> appId 应用 ID</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> timestamp 时间戳</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> sign 签名字符串</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> Token 文本</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">protected</span> String <span class="hljs-title function_">compose</span><span class="hljs-params">(String appId, <span class="hljs-type">long</span> timestamp, String sign)</span> &#123;<br>       String plain;<br><br>       plain = String.format(<span class="hljs-string">&quot;%s,%d,%s&quot;</span>, appId, timestamp, sign);<br>       <span class="hljs-keyword">return</span> plain;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h1>SSO</h1>
<h2 id="精确的sso登录流程-结合联邦认证">精确的SSO登录流程 (结合联邦认证)</h2>
<p>这个流程描述了当用户首次访问系统，且 SSO 认证中心本身也需要借助第三方（如QQ）来完成认证的完整过程。</p>
<h3 id="核心参与者">核心参与者</h3>
<ul>
<li>
<p>用户 (浏览器): 用户的设备。</p>
</li>
<li>
<p>系统 A (应用/Service Provider): 用户想要访问的业务系统，例如 <a target="_blank" rel="noopener" href="http://app.a.com">app.a.com</a>。</p>
</li>
<li>
<p>SSO 服务器 (认证中心/Identity Provider): 统一的身份认证服务，例如 <a target="_blank" rel="noopener" href="http://sso.com">sso.com</a>。</p>
</li>
<li>
<p>QQ (外部认证方/External IdP): 提供身份信息的第三方，例如 <a target="_blank" rel="noopener" href="http://qq.com">qq.com</a>。</p>
</li>
</ul>
<h3 id="流程步骤">流程步骤</h3>
<ol>
<li>
<p>访问应用: 用户在浏览器中访问系统 A (<code>app.a.com</code>) 的受保护页面。系统 A 检查发现浏览器请求中没有自己的登录凭证（<code>app_a_cookie</code>），判定用户未登录。</p>
</li>
<li>
<p>重定向至 SSO: 系统 A 将用户的浏览器重定向到SSO服务器的登录地址，并在 URL 中附带自己的身份和期望的回调地址。</p>
<ul>
<li><code>sso.com/login?service=https://app.a.com/callback</code></li>
</ul>
</li>
<li>
<p>SSO 检查并再次重定向: SSO 服务器检查发现浏览器请求中也没有 SSO 的全局登录凭证（<code>sso_cookie</code>），判定用户在认证中心也未登录。此时，SSO 服务器呈现一个登录页面，上面有多种登录选项（如：用户名密码、使用 QQ 登录）。</p>
</li>
<li>
<p>用户选择 QQ 登录: 用户点击“使用 QQ 登录”按钮。SSO 服务器将浏览器重定向到 QQ 的授权页面，并附带自己的客户端 ID 和预设的回调地址（指向 SSO 自己）。</p>
<ul>
<li><code>qq.com/auth?client_id=sso_client_id&amp;redirect_uri=https://sso.com/auth/qq/callback</code></li>
</ul>
</li>
<li>
<p>QQ 认证与授权: 用户在 QQ 的页面上输入账号密码，并同意授权 SSO 服务器获取其基本信息。</p>
</li>
<li>
<p>QQ 回调 SSO: QQ 认证成功后，将浏览器重定向回第4步中指定的 SSO 回调地址，并在 URL 中附带一个一次性的<code>authorization_code</code>。</p>
<ul>
<li><code>sso.com/auth/qq/callback?code=qq_auth_code_123</code></li>
</ul>
</li>
<li>
<p>SSO后台换取用户信息: SSO服务器的后端收到<code>authorization_code</code>后，向QQ的API服务器发起一个安全的后台HTTP请求，用<code>code</code>换取<code>access_token</code>，再用<code>access_token</code>获取用户的唯一标识（<code>openid</code>）等信息。</p>
</li>
<li>
<p>SSO 建立全局会话: SSO 服务器确认了用户的身份，此时：</p>
<ul>
<li>在 SSO 域 (<code>sso.com</code>) 下为浏览器种下全局登录凭证（<code>sso_cookie</code>）。</li>
<li>这标志着用户已经在单点登录系统中完成了认证。</li>
</ul>
</li>
<li>
<p>SSO 携带 Ticket 重定向回系统 A:SSO 服务器现在将浏览器重定向回系统 A 在第2步中提供的回调地址，并在URL中附带一个一次性票据 (Ticket)。在现实中还会有多余的一步，首先返回一个 uid列表（如果一个qq下有多个 uid的话），让用户选择 uid 以后，<strong>再根据 uid 返回一个独一无二的 ticketA</strong>（只绑定 uid）。</p>
<ul>
<li><code>app.a.com/callback?ticket=ST-xyz-789</code></li>
</ul>
</li>
<li>
<p>系统 A 后台验证 Ticket: 系统 A 的后端收到<code>ticket</code>后，向SSO服务器的验证接口发起一个安全的后台HTTP请求来核销这个<code>ticket</code>。</p>
</li>
<li>
<p>SSO 验证并返回用户信息: SSO 服务器验证<code>ticket</code>有效（且是发给系统A的），然后立即销毁该<code>ticket</code>防止重放攻击。验证成功后，向系统 A 返回该用户的身份信息（如统一的<code>uid</code>、<code>role</code>等）。</p>
</li>
<li>
<p>系统 A 建立本地会话: 系统 A 收到了确认信息，信任了该用户。它会在自己的域 (<code>app.a.com</code>) 下为浏览器种下应用自身的登录凭证（<code>app_a_cookie</code>），并最终将用户带到他最初想访问的页面。</p>
</li>
</ol>
<p>至此，登录流程完成。如果用户再去访问已接入 SSO 的系统 B，流程会大大简化：他会被重定向到 SSO（步骤2），SSO 检测到<code>sso_cookie</code>已存在（步骤8），会直接跳过登录和QQ认证，立即执行步骤9，<strong>发放一个新票据给系统B</strong>，实现无感知的“单点登录”。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    actor User as 用户/浏览器
    participant A as 系统A
    participant SSO as SSO服务器
    participant QQ as QQ认证服务器

    User-&gt;&gt;A: 访问系统A
    A-&gt;&gt;SSO: 重定向到SSO&lt;br/&gt;/login?service=app.a.com/callback
    SSO-&gt;&gt;SSO: 检查sso_cookie (未登录)
    SSO--&gt;&gt;User: 展示登录选项页面
    User-&gt;&gt;SSO: 选择QQ登录
    SSO-&gt;&gt;QQ: 重定向到QQ认证&lt;br/&gt;/authorize?client_id=sso_id&amp;redirect_uri=sso.com/callback
    QQ--&gt;&gt;User: 展示QQ登录页面
    User-&gt;&gt;QQ: QQ登录认证 (用户名密码)
    QQ-&gt;&gt;SSO: 返回授权码 code
    SSO-&gt;&gt;QQ: 后台交换token
    QQ-&gt;&gt;SSO: 返回用户信息
    SSO-&gt;&gt;SSO: 创建全局会话 (设置sso_cookie)
    SSO--&gt;&gt;User: 重定向回系统A，携带ticket
    User-&gt;&gt;A: 携带ticket访问
    A-&gt;&gt;SSO: 验证ticket
    SSO-&gt;&gt;A: 返回用户信息
    A--&gt;&gt;User: 设置本地会话cookie</code></pre>
<h4 id="设计思想">设计思想</h4>
<ol>
<li>
<p>每个系统都是靠本域下的 cookie 来省却登录流程，如果无 cookie，要先确定是不是本系统作为最初授权源。如果不是，去找授权源。</p>
</li>
<li>
<p>授权源完成授权是用户手动操作，如果完成以后，向授权请求方给出一个一次性令牌（ ticket/access_token），再通过 query params 之类的方案回调。</p>
</li>
<li>
<p>授权请求方得到一次性令牌后，再通过自身的鉴权机制拿这个一次性去授权源验证，获取令牌带有的长效信息（如用户的 OpenId）。</p>
</li>
<li>
<p>授权请求方把长效信息和一个本地令牌（会话id/sso_token）关联起来，然后把长效信息存在缓存里，或者每次验证本地令牌时去询问授权源。</p>
</li>
<li>
<p>本地令牌给 api 使用方，使用方每次来访问本系统，如果有 cookie 都直接验证账号和  token 的关联性，直接进入下一步，否则就经浏览器跳转到授权源。</p>
</li>
<li>
<p>授权源的拓扑关系大概是：user -&gt; gateway (本地令牌提供方) -&gt; sso 中心 -&gt; 真授权方：</p>
<ul>
<li>如果一个页面有 gateway 的 cookie，则请求直接放行</li>
<li>如果没有 gateway 的 cookie，有 sso 的 cookie，则 sso 不需要登录，带着 ticket 跳回 gateway</li>
<li>否则执行登录流程</li>
</ul>
</li>
<li>
<p>任何从没有 sso 登录过的新系统登录时，如从 A 到 B，B 会到达 SSO，直接触发 SSO 的 cookie 的免登录通过。</p>
</li>
<li>
<p>跳转都是经过浏览器实现的，多层调用有逐层嵌套和解套回调：</p>
<ul>
<li>
<p>尽量从 <strong>Referer</strong> 头获取回调地址。</p>
</li>
<li>
<p>回调地址里面要尽量<strong>去掉 sso_ticket 这种sso 回调才会添加的附加参数</strong>，避免触发一次性凭证的校验机制。</p>
</li>
</ul>
</li>
</ol>
<h4 id="安全问题">安全问题</h4>
<h5 id="如果-token-或者-ticket-被复制-分享或者窃听拿来用-应该怎么防御水平越权">如果 token 或者 ticket 被复制、分享或者窃听拿来用，应该怎么防御水平越权</h5>
<ol>
<li>
<p>保证这些明文不被挪用的机制有：</p>
<ul>
<li>
<p>验证凭证要使用加密协议，而且 caller 要单独向 callee 鉴权。</p>
</li>
<li>
<p>ticket 和 token 最好<strong>在授权源和账号、回调 uri 绑定</strong>，不单独使用，和某些明 principal id 一起混合使用。</p>
<ul>
<li>如果从多个区域（header、body和 query param）都能获取账号与 sso 校验，而数据库写入只从 body 取值，这就产生了一种可以窃取 request 的其他部分，但是修改 body 到其他值的水平越权问题。解法是：统一从一个地方-body来获取账号值。</li>
</ul>
</li>
</ul>
</li>
</ol>
<ul>
<li>水平越权：使用当前身份的 Principal 查询其他 Principal 的信息。</li>
<li>身份盗用：盗用别人的 Principal</li>
</ul>
<h5 id="水平权限兼容问题">水平权限兼容问题</h5>
<p>如我有1个token可以关联账号1和2，但不允许访问3。那么怎样让1和2可以互相切换，但是禁止切换3，就是这个体系的边界要考虑的问题了。</p>
<h6 id="死循环">死循环</h6>
<p>已存在的 token 解析出一个登录账号，然后重定向到 sso 服务，因为 sso 域下的 cookie 已存在，又会重定向回这个登录账号在当前账号下的页面。即<code>/9/account</code>已经登录了，浏览器输入了一个<code>/10/account</code>，则需要靠重定向到 sso，再重定向回来<code>/9/account</code>。如果给 sso 的重定向uri是<code>/10/account</code>则可能产生无限循环。</p>
<h6 id="解法">解法</h6>
<h6 id="解析出一个不会循环的地址">解析出一个不会循环的地址</h6>
<p>尝试给出一个和 sso_token 匹配的回调地址再登录，比如当前错误地从<code>/9/account</code>跳到<code>/10/account</code>，如果能够解析出9来，就不会产生循环。有些 sso 系统不支持。因为 cookie 可能账户绑定关系是一对多的，没人知道具体原来使用了哪个账户（可能一个 token绑定了7、8、9）。</p>
<h6 id="选择账号列表法">选择账号列表法</h6>
<p>如果已经有了正确的 cookie 跨了错误的账号（no permission on this account问题）：</p>
<ul>
<li>回到 sso 中心的账号选择列表，用新的账号，跳到当前网站的主页。即用户可以使用 1、2，但是误跳到了3，重新回到账号选择界面，让它在 1 和 2 里选择。</li>
</ul>
<h6 id="重登陆法">重登陆法</h6>
<p>本 token 本身已经不合法：</p>
<ul>
<li>
<p>登出：一次性清除全部的 cookie-当前登录系统的 cookie + 所有能通知到的系统的 cookie。</p>
<ul>
<li>一个完整清除 cookie 的 header 是：<code>Set-Cookie: sso_token=; Expires=Thu, 01 Jan 1970 00:00:00 GMT; Max-Age=0; Domain=.example.com; Path=/</code>。如果原 cookie 没有设置 domain，这里也不设置 domain，用的就是当前的 host 全地址（不包括所有二级域名），但是 <strong>path 即使是<code>/</code>也是必须的</strong>。</li>
</ul>
</li>
<li>
<p>带有 status code == 0，加 data.code != 0 + location header 回 sso 服务。</p>
</li>
</ul>
<h3 id="sso登出流程-logout">SSO登出流程 (Logout)</h3>
<p>SSO的核心理念是“一次登录，处处通行”。相应地，登出的核心理念应该是**“一次登出，处处失效”，这被称为单点登出 (Single Logout, SLO)**。</p>
<p>如果只清除了当前应用（系统 A ）的登录状态，而 SSO 认证中心的全局会话依然存在，那么用户刷新页面后，系统 A 会再次将他重定向到 SSO，SSO 发现全局会话还在，会立刻又把他自动登录回系统 A。这就导致了用户无法真正登出的尴尬局面。</p>
<p>因此，正确的登出流程必须由 SSO 认证中心来协调。也因此，中间服务不要缓存 sso_token，因为不一定能感知到这个 sso_token 被他处 invalidate 了。</p>
<p>流程步骤:</p>
<ol>
<li>
<p>用户发起登出: 用户在系统A的界面上点击“登出”按钮。</p>
</li>
<li>
<p>系统 A 清理本地会话: 系统 A 的后端接收到登出请求后，首先执行本地登出操作。这包括：</p>
<ul>
<li>销毁系统 A 自身的会话 (Session)。</li>
<li>清除种在<code>app.a.com</code>域下的本地登录凭证（<code>app_a_cookie</code>）-<strong>这一步需要重新使用 Set-Cookie header 设置一个过期的 cookie</strong>。</li>
</ul>
</li>
<li>
<p>重定向至 SSO 进行全局登出: 清理完本地会话后，系统 A 必须将用户的浏览器重定向到 SSO 服务器的登出地址。通常还会附带一个参数，告诉 SSO 登出后应该跳转回哪里。注意这个参数是靠重放 cookie 而不是携带参数来实现的。</p>
<ul>
<li><code>sso.com/logout?post_logout_redirect_uri=https://app.a.com/login</code></li>
</ul>
</li>
<li>
<p>SSO 执行全局登出: SSO 服务器接收到请求后，执行全局登出操作：</p>
<ul>
<li>销毁 SSO 的中央认证会话。</li>
<li>清除种在<code>sso.com</code>域下的全局登录凭证（<code>sso_cookie</code>）。</li>
</ul>
</li>
<li>
<p>SSO 通知所有相关应用登出 (关键步骤): 这是实现单点登出 (SLO) 的核心。SSO 服务器会查找在此次全局会话期间，该用户都登录了哪些应用（例如系统A、系统B、系统C）。然后，SSO服务器会从后端向所有这些应用的预设登出接口发送登出通知 (Logout Notification)。</p>
<ul>
<li>这个通知通常是一个包含了<code>logout_token</code>的HTTP POST请求，应用收到后需要验证这个<code>token</code>的合法性。</li>
</ul>
</li>
<li>
<p>其他应用清理本地会话: 系统 B、系统 C 等其他应用收到来自 SSO 的登出通知后，执行与步骤2相同的本地登出操作，清理各自的会话和 Cookie。</p>
</li>
<li>
<p>最终跳转: 在 SSO 服务器完成所有登出操作后，它会将用户的浏览器重定向到第3步中指定的<code>post_logout_redirect_uri</code>地址，通常是应用的登录页面。用户此时会看到系统 A 的登录页，表示已成功登出。</p>
</li>
</ol>
<p>至此，用户在整个 SSO 体系中的所有会话均已失效，实现了彻底的“单点登出”。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    actor User as 用户/浏览器
    participant A as 系统A
    participant SSO as SSO服务器
    participant QQ as QQ认证服务器

    User-&gt;&gt;A: 请求登出
    A-&gt;&gt;SSO: 重定向到SSO /logout
    SSO-&gt;&gt;SSO: 清除全局会话
    SSO-&gt;&gt;QQ: 通知QQ登出
    SSO-&gt;&gt;A: 清除本地会话
    A--&gt;&gt;User: 重定向到登录页面</code></pre>
<h1>OAUTH2</h1>
<h2 id="基本角色定义">基本角色定义</h2>
<ol>
<li>授权服务器 - 验证身份并颁发令牌的服务器（我上面代码示例中的 OAuth 服务器）</li>
<li>资源服务器 - 提供 API 资源的服务器</li>
<li>客户端应用 - 访问 API 的应用，可以是：
<ul>
<li>第一方应用 - 您公司自己的应用</li>
<li>第二方应用 - 业务合作伙伴的应用</li>
<li>第三方应用 - 外部开发者的应用</li>
</ul>
</li>
</ol>
<h3 id="token-类型">token 类型</h3>
<ul>
<li>
<p>access_token （默认有效期 24 小时）</p>
</li>
<li>
<p>refresh_token（默认有效期 30 自然日，每次刷新 access_token 的操作可自动刷新 refresh_token 有效期的起始计算时间）。</p>
</li>
</ul>
<h3 id="客户端凭证流程-适用于服务器到服务器通信">客户端凭证流程（适用于服务器到服务器通信）</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant App as 第一方/第二方应用
    participant Auth as 授权服务器
    participant API as 资源服务器(API)

    App-&gt;&gt;Auth: 1. 请求访问令牌&lt;br/&gt;(使用client_id和client_secret)
    Auth-&gt;&gt;App: 2. 返回access_token
    App-&gt;&gt;API: 3. 使用access_token调用API
    API-&gt;&gt;App: 4. 返回API响应</code></pre>
<p>这种流程中：</p>
<ul>
<li>获取令牌方: 第一方或第二方应用直接获取令牌</li>
<li>使用令牌方: 同样的应用使用令牌调用API</li>
<li>无用户参与: 整个过程无需最终用户授权</li>
</ul>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client as 客户端
    participant Auth as 认证服务器

    Client-&gt;&gt;Auth: POST /token&lt;br/&gt;grant_type=client_credentials&lt;br/&gt;client_id=CLIENT_ID&lt;br/&gt;client_secret=CLIENT_SECRET
    Auth-&gt;&gt;Client: 200 OK JSON 响应&lt;br/&gt;&#123;&quot;access_token&quot;: &quot;eyJhbGc...&quot;,&lt;br/&gt;&quot;token_type&quot;: &quot;Bearer&quot;,&lt;br/&gt;&quot;expires_in&quot;: 3600&#125;
    Client-&gt;&gt;Auth: 使用令牌访问API&lt;br/&gt;Authorization: Bearer eyJhbGc...</code></pre>
<h3 id="授权码流程-适用于有用户参与的场景">授权码流程（适用于有用户参与的场景）</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    actor User as 用户
    participant App as 第一方/第二方/第三方应用
    participant Auth as 授权服务器
    participant API as 资源服务器(API)

    User-&gt;&gt;App: 1. 访问应用
    App--&gt;&gt;User: 2. 重定向到授权服务器
    User-&gt;&gt;Auth: 3. 登录并授权
    Auth--&gt;&gt;User: 4. 重定向回应用，携带授权码(code)
    User-&gt;&gt;App: 5. 返回应用，带上授权码
    App-&gt;&gt;Auth: 6. 使用code请求令牌&lt;br/&gt;(附带client_id/secret)
    Auth-&gt;&gt;App: 7. 返回access_token和refresh_token
    App-&gt;&gt;API: 8. 使用access_token调用API
    API-&gt;&gt;App: 9. 返回API响应</code></pre>
<p>这里面有两次重定向：</p>
<p>第一次：重定向到授权服务器。用户是带着一个 param 去访问 authserver 的，在我们常见的场景里线索通跳到 sso 是第一次重定向，参数里带有 <a target="_blank" rel="noopener" href="https://app.example.com/callback">https://app.example.com/callback</a> 就是授权完以后再回到线索通的一个 url。</p>
<ul>
<li>
<p>当用户尝试访问需要授权的功能时，应用生成一个授权请求 URL</p>
</li>
<li>
<p>这个 URL 包含 redirect_uri 参数（应用事先在授权服务器注册的 URL）</p>
</li>
<li>
<p>应用通过 HTTP 302重定向或者前端跳转，将用户浏览器导向授权服务器</p>
</li>
</ul>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pf">GET https://auth-server.com/oauth/authorize?<br>    response_type=code&amp;<br>    client_id=CLIENT_ID&amp;<br>    redirect_uri=https://app.example.com/callback&amp;<br>    scope=<span class="hljs-keyword">profile</span> email&amp;<br>    <span class="hljs-keyword">state</span>=random_state_value<br></code></pre></td></tr></table></figure>
<p>第二次：重定向回应用，携带授权码(code)。</p>
<ul>
<li>
<p>用户在授权服务器完成身份验证并授予权限后</p>
</li>
<li>
<p>授权服务器使用之前请求中的redirect_uri，将用户浏览器重定向回应用</p>
</li>
<li>
<p>重定向 URL 中附加授权码(code)作为查询参数</p>
</li>
</ul>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">HTTP/<span class="hljs-number">1.1</span> <span class="hljs-number">302</span> Found<br>Location: https://app.example.com/callback?<br>          code=AUTHORIZATION_CODE_VALUE&amp;<br>          <span class="hljs-keyword">state</span>=random_state_value<br></code></pre></td></tr></table></figure>
<ul>
<li>授权服务器只会重定向到预先注册的 URI，防止授权码被重定向到恶意网站</li>
<li>防止授权码被重定向到恶意网站</li>
</ul>
<pre><code class="hljs mermaid">sequenceDiagram
    actor User as 用户/浏览器
    participant Client as 客户端应用
    participant Auth as 认证服务器
    participant Resource as 资源服务器

    Client-&gt;&gt;Auth: 重定向用户认证&lt;br/&gt;/authorize?client_id=...&amp;&lt;br/&gt;redirect_uri=...&amp;response_type=code
    Auth--&gt;&gt;User: 展示登录页面
    User-&gt;&gt;Auth: 登录界面交互
    Auth--&gt;&gt;User: 重定向回客户端&lt;br/&gt;/callback?code=...
    User-&gt;&gt;Client: 携带授权码访问
    Client-&gt;&gt;Auth: POST /token&lt;br/&gt;grant_type=authorization_code&lt;br/&gt;&amp;code=...&amp;redirect_uri=...&lt;br/&gt;&amp;client_id=...&amp;client_secret=...
    Auth-&gt;&gt;Client: 返回令牌&lt;br/&gt;access_token, refresh_token等
    Client-&gt;&gt;Resource: 使用令牌访问资源&lt;br/&gt;Authorization: Bearer &#123;token&#125;
    Resource-&gt;&gt;Client: 返回受保护资源数据</code></pre>
<h3 id="刷新令牌流程-refresh-token-flow">刷新令牌流程 (Refresh Token Flow)</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client as 客户端
    participant Auth as 认证服务器

    Client-&gt;&gt;Auth: POST /token&lt;br/&gt;grant_type=refresh_token&lt;br/&gt;refresh_token=REFRESH_TOKEN&lt;br/&gt;client_id=CLIENT_ID&lt;br/&gt;client_secret=CLIENT_SECRET
    Auth-&gt;&gt;Client: 200 OK JSON 响应&lt;br/&gt;&#123;&quot;access_token&quot;: &quot;NEW_TOKEN&quot;,&lt;br/&gt;&quot;token_type&quot;: &quot;Bearer&quot;,&lt;br/&gt;&quot;expires_in&quot;: 3600,&lt;br/&gt;&quot;refresh_token&quot;: &quot;NEW_REFRESH&quot;&#125;</code></pre>
<h1>特殊的请求头</h1>
<h2 id="location">Location</h2>
<p>除了重定向响应之外，状态码为 201 (Created) 的消息也会带有 Location 首部。它指向的是新创建的资源的地址。</p>
<h3 id="3xx-状态码总是自带-location-头部吗？">3xx 状态码总是自带 Location 头部吗？</h3>
<ul>
<li>
<p>根据 HTTP 规范，所有 3xx 重定向响应都应该包含 Location 头部，用于指定重定向的目标地址</p>
</li>
<li>
<p>常见的重定向状态码包括：</p>
<ul>
<li>301 Moved Permanently（永久重定向）</li>
<li>302 Found（临时重定向）</li>
<li>303 See Other（查看其他位置）</li>
<li>307 Temporary Redirect（临时重定向）</li>
<li>308 Permanent Redirect（永久重定向）</li>
</ul>
</li>
<li>
<p>如果服务端不发送 Location 头部会怎样？</p>
<ul>
<li>客户端（浏览器/应用）将无法知道重定向的目标地址</li>
<li>可能导致以下问题：
<ul>
<li>浏览器显示错误页面（如 “重定向循环” 错误）</li>
<li>应用程序无法正确处理重定向逻辑</li>
<li>API 调用失败，无法获取预期资源</li>
</ul>
</li>
<li>从技术上讲，<strong>缺少 Location 头部的 3xx 响应是违反 HTTP 规范的</strong></li>
</ul>
</li>
<li>
<p>是否所有服务端都会返回这个头部？</p>
<ul>
<li>所有遵循 HTTP 规范的服务端实现（如 Nginx、Apache、主流框架）都会在 3xx  响应中自动添加 Location 头部</li>
<li>如果开发者手动创建重定向响应但忘记添加 Location 头部，会导致上述问题</li>
<li>在正常配置下，所有标准服务端实现都会返回 Location 头部</li>
</ul>
</li>
</ul>
<h3 id="ajax-get-302-location-触发跨域问题">ajax get 302 + Location 触发跨域问题</h3>
<p>很多人会有一些误解：只要在 response 里加上 302 + Location 就可以触发页面跳转。</p>
<p>但是如果这个 response 是 ajax get 的 request 的响应，那么 ajax 会跨域请求，如果没有<code>Access-Control-Allow-Origin</code>允许的头，就会触发跨域错误。</p>
<p>AJAX 请求（XMLHttpRequest/Fetch）处理重定向时：</p>
<ul>
<li>浏览器会自动跟踪重定向（向 Location 地址发送新请求）</li>
<li>但整个过程在后台完成，不会触发页面跳转</li>
<li>最终返回的是重定向后页面的内容（而非跳转行为）</li>
</ul>
<p>当 Location 指向的地址与当前页面不同源时：</p>
<ul>
<li>浏览器自动发起跨域 AJAX 请求</li>
<li>若目标服务器未配置 CORS 响应头（如 Access-Control-Allow-Origin）</li>
<li>浏览器拦截响应并报跨域错误</li>
</ul>
<p>解决方案一：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 前端代码示例</span><br><span class="hljs-title function_">fetch</span>(<span class="hljs-string">&#x27;/your-endpoint&#x27;</span>, &#123; <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span> &#125;)<br>  .<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (response.<span class="hljs-property">redirected</span>) &#123;<br>      <span class="hljs-comment">// 手动触发页面跳转</span><br>      <span class="hljs-variable language_">window</span>.<span class="hljs-property">location</span>.<span class="hljs-property">href</span> = response.<span class="hljs-property">url</span>; <br>    &#125;<br>  &#125;)<br>  .<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(error));<br></code></pre></td></tr></table></figure>
<ol>
<li>服务端返回 200 OK + JSON 数据（而非 302）<br>
{ “redirectUrl”: “<a target="_blank" rel="noopener" href="https://new-domain.com/target">https://new-domain.com/target</a>” }</li>
<li>前端根据响应手动执行 window.location.href</li>
</ol>
<p>方案二：服务端配置 CORS<br>
若必须保持 302 重定向</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs conf"># 目标服务器配置（Nginx 示例）<br>server &#123;<br>    location / &#123;<br>        add_header &#x27;Access-Control-Allow-Origin&#x27; &#x27;*&#x27;;<br>        add_header &#x27;Access-Control-Allow-Methods&#x27; &#x27;GET, POST, OPTIONS&#x27;;<br>        add_header &#x27;Access-Control-Allow-Headers&#x27; &#x27;Content-Type&#x27;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="场景行为对比">场景行为对比</h4>
<table>
<thead>
<tr>
<th>场景</th>
<th>页面跳转行为</th>
<th>跨域风险</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>直接访问 URL (非 AJAX)</strong></td>
<td>自动跳转</td>
<td>无</td>
</tr>
<tr>
<td><strong>AJAX 请求</strong></td>
<td>后台静默重定向</td>
<td>需 CORS 配置</td>
</tr>
<tr>
<td><strong>前端控制跳转</strong></td>
<td>主动触发页面刷新</td>
<td>无</td>
</tr>
</tbody>
</table>
<h4 id="302-重定向响应对比">302 重定向响应对比</h4>
<table>
<thead>
<tr>
<th>请求类型</th>
<th>302 + Location 响应结果</th>
<th>原因说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>普通 HTTP GET</strong><br>(地址栏输入/链接点击)</td>
<td>浏览器自动跳转到新地址</td>
<td>属于页面级导航行为，浏览器直接处理重定向</td>
</tr>
<tr>
<td><strong>AJAX GET</strong><br>(XMLHttpRequest/Fetch)</td>
<td>触发跨域错误，不跳转</td>
<td>AJAX 机制在后台静默跟踪重定向，受 CORS 策略限制</td>
</tr>
</tbody>
</table>
<p>页面级导航：</p>
<ol>
<li>地址栏变化：用户可见的浏览器地址栏会立即更新为新的 URL</li>
<li>完整页面刷新：整个页面内容会被完全替换（包括 HTML、CSS、JS 等所有资源）</li>
<li>历史记录更新：浏览器历史记录会增加新条目（可通过后退按钮返回）</li>
<li>加载指示器：浏览器显示加载进度条/旋转图标等视觉反馈</li>
<li>触发条件：</li>
</ol>
<ul>
<li>用户直接输入 URL</li>
<li>点击<code>&lt;a&gt;</code>链接</li>
<li>表单提交（非 AJAX）</li>
<li><code>window.location</code>跳转</li>
<li>收到 3xx 重定向响应</li>
</ul>
<h1>攻击技术</h1>
<h2 id="如何阻止跨域访问">如何阻止跨域访问</h2>
<p><img src="csrf%E6%94%BB%E5%87%BB.jpeg" alt="csrf攻击"></p>
<ul>
<li>
<p>CSRF（跨站请求伪造）攻击的本质是<strong>攻击者利用用户已登录网站A的身份，在用户不知情的情况下，以用户身份向网站A发送恶意请求</strong>。攻击流程如下：</p>
<ol>
<li>用户正常登录网站A，浏览器存储了网站A的认证信息（如Cookie）</li>
<li>用户在未退出网站A的情况下，访问了攻击者控制的恶意网站B</li>
<li><strong>网站B通过HTML元素（如<code>&lt;img&gt;</code>、<code>&lt;form&gt;</code>等）或JavaScript构造指向网站A的恶意请求</strong></li>
<li>用户浏览器自动携带网站A的Cookie向网站A发送请求</li>
<li>网站A服务器收到请求后，验证Cookie发现用户已认证，<strong>误认为是用户的合法操作</strong>而执行相应操作</li>
</ol>
</li>
<li>
<p><strong>CSRF攻击成功的关键前提</strong>：</p>
<ul>
<li>用户已在目标网站认证（持有有效Cookie）</li>
<li>目标网站完全依赖Cookie进行身份验证</li>
<li>浏览器的自动Cookie携带机制</li>
</ul>
</li>
<li>
<p><strong>防御CSRF攻击的核心机制是CSRF Token</strong>：</p>
<ul>
<li>服务器生成加密安全的随机token，嵌入到合法页面的表单、响应头或URL参数（url不推荐，因为可以被分享、泄露，而header或者表单受同源策略保护）中
<ul>
<li>使用 header 来替代 cookie 里的 sessionid 是一个好主意！</li>
</ul>
</li>
<li><strong>防御的关键是攻击者无法获取该token</strong>（B网站无从了解A网站的一切）</li>
<li>客户端在发送敏感请求时必须携带该token进行验证</li>
<li><strong>攻击者无法获取该token的原因</strong>：
<ul>
<li>浏览器的同源策略（SOP）阻止恶意网站跨域读取目标网站的内容（包括token）</li>
<li>现代浏览器的额外安全机制（如CORS策略）</li>
</ul>
</li>
<li>因此，攻击者伪造的请求虽然会自动携带Cookie，但缺少有效的CSRF token，会被服务器拒绝</li>
</ul>
</li>
</ul>
<pre><code class="hljs mermaid">sequenceDiagram
    actor User as 用户
    participant Browser as 浏览器
    participant Server as 服务器

    %% 1️⃣ 用户访问页面，服务器返回页面和 CSRF Token
    User-&gt;&gt;Browser: 访问页面 (GET)
    Browser-&gt;&gt;Server: 请求页面
    Server-&gt;&gt;Browser: 返回页面 + CSRF Token (包含在隐藏字段或 Cookie)

    %% 2️⃣ 用户提交表单，携带 CSRF Token
    User-&gt;&gt;Browser: 填写表单并提交
    Browser-&gt;&gt;Server: 提交表单 + CSRF Token

    %% 3️⃣ 服务器验证 CSRF Token
    Server-&gt;&gt;Server: 验证 CSRF Token 是否有效
    alt CSRF Token 验证通过
        Server--&gt;&gt;Browser: 处理请求（例如提交成功）
    else CSRF Token 无效
        Server--&gt;&gt;Browser: 拒绝请求，返回错误
    end
</code></pre>
<ul>
<li>
<p><strong>其他辅助防御措施</strong>：</p>
<ul>
<li><strong>SameSite Cookie属性</strong>：设置Cookie的SameSite属性为Strict或Lax，限制Cookie在跨站请求中的发送</li>
<li><strong>验证Referer/Origin头</strong>：检查请求来源，但可能被伪造且存在隐私问题</li>
<li><strong>阻止页面被嵌入</strong>：通过X-Frame-Options头或CSP的frame-ancestors指令防止网站被恶意iframe嵌入</li>
<li><strong>GET请求幂等性</strong>：确保GET请求不修改服务器状态，避免通过<code>&lt;img&gt;</code>等标签触发恶意操作</li>
<li>双 cookie 方案：在响应里面给一个 cookie，但是要求请求用别的参数-比如 url 传回来。利用攻击方不能读取cookie只能诱导重放的特性，显式要求主网站给出确切的令牌-即使用 cookie也不用重放的原 cookie。</li>
</ul>
</li>
<li>
<p><strong>需要注意的误区</strong>：</p>
<ul>
<li>CSRF攻击主要针对<strong>修改数据的请求</strong>（POST/PUT等），而非仅仅信息获取</li>
<li>纯API服务若使用 Bearer Token 等认证方式且不依赖Cookie，天然免疫CSRF攻击</li>
</ul>
</li>
</ul>
<h2 id="x-frame-options-详解">X-Frame-Options 详解</h2>
<p>X-Frame-Options 是一个重要的 HTTP 响应头，主要用于防止 <strong>点击劫持（Clickjacking）</strong> 攻击。</p>
<h3 id="什么是点击劫持-clickjacking">什么是点击劫持（Clickjacking）</h3>
<p>点击劫持是一种 UI 伪装攻击，攻击者通过将目标网站嵌入到恶意网站的透明 <code>iframe</code> 中，诱使用户在不知情的情况下点击目标网站的敏感功能。</p>
<h4 id="攻击流程示意">攻击流程示意</h4>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css">┌──────────────────────────────────────────────────┐<br>│  恶意网站 <span class="hljs-selector-tag">B</span> 的内容（可见）                        │<br>│                                                  │<br>│  <span class="hljs-selector-attr">[点击赢取大奖]</span>  ← 用户看到的按钮                │<br>│                                                  │<br>│  ┌───────────────────────────────────────────┐   │<br>│  │ 银行网站 <span class="hljs-selector-tag">A</span> 的转账页面（透明 <span class="hljs-selector-tag">iframe</span> 中）   │   │<br>│  │                                           │   │<br>│  │ <span class="hljs-selector-attr">[确认转账 10000 元]</span> ← 用户实际点击的按钮   │   │<br>│  └───────────────────────────────────────────┘   │<br>└──────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<p>用户以为在点击“赢取大奖”，实际上点击的是银行转账按钮。</p>
<h3 id="x-frame-options-的作用">X-Frame-Options 的作用</h3>
<p>X-Frame-Options 响应头告诉浏览器是否允许当前页面被嵌入到 <code>&lt;frame&gt;</code>、<code>&lt;iframe&gt;</code>、<code>&lt;embed&gt;</code> 或 <code>&lt;object&gt;</code> 中。</p>
<h4 id="取值选项">取值选项</h4>
<table>
<thead>
<tr>
<th>取值</th>
<th>说明</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>DENY</code></td>
<td>最严格</td>
<td>页面不能被<strong>任何</strong>网站嵌入到 frame 中</td>
</tr>
<tr>
<td><code>SAMEORIGIN</code></td>
<td>常用</td>
<td>页面只能被<strong>同源</strong>网站嵌入到 frame 中</td>
</tr>
<tr>
<td><code>ALLOW-FROM uri</code></td>
<td><strong>已废弃</strong></td>
<td>页面只能被指定来源的网站嵌入（现代浏览器大多不再支持）</td>
</tr>
</tbody>
</table>
<h3 id="实际应用示例">实际应用示例</h3>
<h4 id="银行网站-高安全场景">银行网站（高安全场景）</h4>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html">HTTP/1.1 200 OK<br>Content-Type: text/html<br>X-Frame-Options: DENY<br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网上银行<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>转账页面<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 敏感操作 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>
<h4 id="企业内部门户网站">企业内部门户网站</h4>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html<br><span class="hljs-attribute">X-Frame-Options</span><span class="hljs-punctuation">: </span>SAMEORIGIN<br></code></pre></td></tr></table></figure>
<h3 id="浏览器行为">浏览器行为</h3>
<ul>
<li>DENY：浏览器直接拒绝把页面加载到任何 frame 中，显示空白或错误。</li>
<li>SAMEORIGIN：浏览器检查嵌入页面的来源，同源则允许，否则拒绝。</li>
<li>ALLOW-FROM：检查来源是否匹配（现代浏览器可能忽略）。</li>
</ul>
<h3 id="现代替代方案：content-security-policy-csp">现代替代方案：Content Security Policy (CSP)</h3>
<p>X-Frame-Options 正逐步被更强大的 CSP 策略取代：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"># 等同于 DENY<br><span class="hljs-attribute">Content-Security-Policy</span><span class="hljs-punctuation">: </span>frame-ancestors &#x27;none&#x27;;<br><br># 等同于 SAMEORIGIN<br><span class="hljs-attribute">Content-Security-Policy</span><span class="hljs-punctuation">: </span>frame-ancestors &#x27;self&#x27;;<br><br># 指定可信域名<br><span class="hljs-attribute">Content-Security-Policy</span><span class="hljs-punctuation">: </span>frame-ancestors &#x27;self&#x27; https://trusted-site.com;<br></code></pre></td></tr></table></figure>
<h3 id="csp-优势">CSP 优势</h3>
<ul>
<li>更灵活：支持多个来源、协议、端口等细粒度规则。</li>
<li>标准化：W3C 标准，未来趋势。</li>
</ul>
<h3 id="配置建议">配置建议</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐配置</th>
</tr>
</thead>
<tbody>
<tr>
<td>高安全（银行、支付）</td>
<td><code>X-Frame-Options: DENY</code></td>
</tr>
<tr>
<td>一般企业网站</td>
<td><code>X-Frame-Options: SAMEORIGIN</code></td>
</tr>
<tr>
<td>需被特定站点嵌入</td>
<td><code>Content-Security-Policy: frame-ancestors 'self' https://trusted-site.com;</code></td>
</tr>
</tbody>
</table>
<h3 id="注意事项">注意事项</h3>
<ol>
<li><strong>向后兼容</strong>：同时设置 X-Frame-Options 与 CSP，以兼容旧浏览器。</li>
<li><strong>优先级</strong>：若同时设置，现代浏览器优先使用 CSP。</li>
<li><strong>测试验证</strong>：部署后务必测试，确保不会破坏正常的 iframe 使用需求。</li>
</ol>
<h3 id="总结">总结</h3>
<p>X-Frame-Options 是防御点击劫持攻击的重要安全机制，通过控制页面是否可被嵌入到 frame 中来保护用户免受 UI 伪装攻击。尽管正逐步被 CSP 替代，但在兼容老浏览器和提供基础防护方面仍然不可或缺。</p>
<h2 id="xss-和-ssrf">xss 和 ssrf</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>XSS</th>
<th>CSRF</th>
<th>SSRF</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>攻击代码位置</strong></td>
<td>嵌入在 <strong>A 网站页面</strong> 内，浏览器执行-通常攻击者准备一个攻击载荷，比如某个img的元素，让a网站加载触发攻击</td>
<td>存在于 <strong>B 网站</strong>，浏览器充当跳板</td>
<td>作为 <strong>A 网站的参数</strong>，服务器自己执行</td>
</tr>
<tr>
<td><strong>受害者视角</strong></td>
<td>在 A 站浏览时被 A 站内的恶意脚本攻击</td>
<td>在 B 站浏览时被 B 站遥控去攻击 A 站</td>
<td>向 A 站上传/填写 URL，被 A 站服务器拿去攻击内网或第三方</td>
</tr>
<tr>
<td><strong>信任误用点</strong></td>
<td>浏览器信任 A 站返回的内容</td>
<td>服务器信任浏览器自动携带的 Cookie</td>
<td>服务器信任自身的网络访问权限</td>
</tr>
<tr>
<td><strong>是否利用 Cookie</strong></td>
<td>不依赖（脚本已拿到 Cookie）</td>
<td>必须依赖（跨站自动带 Cookie）</td>
<td>不依赖（服务器自带凭证或内网信任）</td>
</tr>
<tr>
<td><strong>防御关键</strong></td>
<td>输入过滤 + 输出编码 + CSP + HttpOnly</td>
<td>CSRF Token + SameSite + 二次验证</td>
<td>白名单域名/IP + 禁止内网 + 统一代理</td>
</tr>
</tbody>
</table>
<h1>Content-Security-Policy（CSP）完全指南</h1>
<p>一句话定位：CSP 是一套在 HTTP 响应头 或 <code>&lt;meta&gt;</code> 标签里声明的白名单策略，告诉浏览器 “什么资源可以加载、从哪里加载、能否执行内联脚本”；默认拒绝、显式允许，从而把 XSS、点击劫持、混合内容等前端风险直接挡在浏览器之外。</p>
<h2 id="1-解决的问题">1. 解决的问题</h2>
<table>
<thead>
<tr>
<th>风险场景</th>
<th>传统痛点</th>
<th>CSP 对策</th>
</tr>
</thead>
<tbody>
<tr>
<td>XSS（反射/存储/DOM）</td>
<td>页面直接输出用户输入，脚本被执行</td>
<td>只允许可信域名脚本，阻断未知来源</td>
</tr>
<tr>
<td>Clickjacking</td>
<td>被透明 iframe 嵌入</td>
<td><code>frame-ancestors</code> 指令显式指定可嵌入源</td>
</tr>
<tr>
<td>混合内容</td>
<td>HTTPS 页面加载 HTTP 资源</td>
<td><code>block-all-mixed-content</code> 强制全站 HTTPS</td>
</tr>
<tr>
<td>供应链投毒</td>
<td>第三方 CDN 被篡改</td>
<td>用 <code>script-src</code> 白名单排除被污染域名</td>
</tr>
<tr>
<td>数据注入</td>
<td><code>data:</code>、<code>blob:</code>、内联事件处理函数</td>
<td>通过 <code>default-src</code>、<code>object-src</code> 禁用</td>
</tr>
</tbody>
</table>
<h2 id="2-部署方式">2. 部署方式</h2>
<h3 id="http-响应头-推荐-功能最全">HTTP 响应头（推荐，功能最全）</h3>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Content-Security-Policy</span>:<br>  default-src &#x27;self&#x27;;<br>  script-src &#x27;self&#x27; https://cdn.jsdelivr.net &#x27;nonce-416d1177&#x27;;<br>  style-src &#x27;self&#x27; &#x27;sha256-AbCdEf==&#x27;;<br>  img-src * data:;<br>  frame-ancestors &#x27;none&#x27;;<br>  upgrade-insecure-requests;<br>  report-uri /csp-violation-report-endpoint;<br></code></pre></td></tr></table></figure>
<h3 id="meta-标签-紧急热修或静态站点"><code>&lt;meta&gt;</code>标签（紧急热修或静态站点）</h3>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Security-Policy&quot;</span></span><br><span class="hljs-tag">      <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;default-src &#x27;self&#x27;; script-src &#x27;self&#x27;;&quot;</span>&gt;</span><br>```      <br>`<span class="hljs-tag">&lt;<span class="hljs-name">meta</span>&gt;</span>`不支持`report-uri`、`frame-ancestors`等指令，生产环境仍建议用响应头。<br><br>## 3. 核心指令速查<br><br>| 指令                          | 作用范围                | 常用值示例                                                 |<br>| --------------------------- | ------------------- | ----------------------------------------------------- |<br>| `default-src`               | 所有资源全局默认            | `&#x27;self&#x27;`                                              |<br>| `script-src`                | JavaScript          | `&#x27;self&#x27;`、`https://cdn.com`、`&#x27;nonce-xxx&#x27;`、`&#x27;sha256-…&#x27;` |<br>| `style-src`                 | CSS                 | `&#x27;self&#x27;`、`&#x27;unsafe-inline&#x27;`（不推荐）                       |<br>| `img-src`                   | 图片                  | `*`、`data:`、`https:`                                  |<br>| `connect-src`               | XHR/fetch/WebSocket | `&#x27;self&#x27;`、`https://api.example.com`                    |<br>| `frame-ancestors`           | 可被谁嵌入               | `&#x27;none&#x27;`、`&#x27;self&#x27;`、`https://trusted.com`               |<br>| `object-src`                | `<span class="hljs-tag">&lt;<span class="hljs-name">object</span>&gt;</span>`/`<span class="hljs-tag">&lt;<span class="hljs-name">embed</span>&gt;</span>`  | `&#x27;none&#x27;`（彻底禁用 Flash/Java）                             |<br>| `base-uri`                  | `<span class="hljs-tag">&lt;<span class="hljs-name">base</span>&gt;</span>` 标签         | `&#x27;self&#x27;`                                              |<br>| `form-action`               | `<span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span>` 提交地址       | `&#x27;self&#x27;`（防钓鱼）                                         |<br>| `upgrade-insecure-requests` | 强制 HTTPS 升级         | 无值                                                    |<br>| `report-uri` / `report-to`  | 违规上报地址              | `/csp-report`                                         |<br><br>## 4. 内联脚本/样式的三种放行方式<br><br>| 方式              | 写法示例                                    | 使用场景           |<br>| --------------- | --------------------------------------- | -------------- |<br>| `nonce`         | `<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nonce</span>=<span class="hljs-string">&quot;416d1177&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>` | 动态模板，一次性随机值    |<br>| `hash`          | `script-src &#x27;sha256-AbCdEf==&#x27;`          | 静态内联块，内容不变     |<br>| `unsafe-inline` | `script-src &#x27;unsafe-inline&#x27;`            | 禁用，等于关闭 XSS 防护 |<br><br>同一指令中若出现`nonce`或`hash`，`&#x27;unsafe-inline&#x27;`会被浏览器忽略。<br><br>## 5. 实战配置模板<br><br>### 高安全站点（银行）<br><br>```http<br>Content-Security-Policy: default-src &#x27;none&#x27;;<br>  script-src &#x27;self&#x27; &#x27;nonce-&#123;&#123;nonce&#125;&#125;&#x27;;<br>  style-src &#x27;self&#x27; &#x27;sha256-&#123;&#123;hash&#125;&#125;&#x27;;<br>  img-src &#x27;self&#x27; data: https:;<br>  font-src &#x27;self&#x27;;<br>  connect-src &#x27;self&#x27;;<br>  frame-ancestors &#x27;none&#x27;;<br>  base-uri &#x27;self&#x27;;<br>  form-action &#x27;self&#x27;;<br>  upgrade-insecure-requests;<br></code></pre></td></tr></table></figure>
<h3 id="通用业务站点">通用业务站点</h3>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-attribute">Content-Security-Policy</span><span class="hljs-punctuation">: </span>default-src &#x27;self&#x27;;<br>  script-src &#x27;self&#x27; https://cdn.jsdelivr.net;<br>  style-src &#x27;self&#x27; &#x27;sha256-AbCdEf==&#x27;;<br>  img-src * data:;<br>  frame-ancestors &#x27;self&#x27;;<br></code></pre></td></tr></table></figure>
<h2 id="6-违规报告与监控">6. 违规报告与监控</h2>
<h3 id="开启上报">开启上报</h3>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs http">report-to csp-endpoint;<br>report-uri /csp-violation-report-endpoint;<br></code></pre></td></tr></table></figure>
<h3 id="服务器接收-json-报告-实时告警">服务器接收 JSON 报告，实时告警</h3>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;csp-report&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;document-uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://example.com/&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;blocked-uri&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;https://evil.com/x.js&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;violated-directive&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;script-src&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<h2 id="7-常见误区">7. 常见误区</h2>
<ul>
<li>[错误] CSP 能防 SQL 注入、SSRF → 只在浏览器生效，与后端漏洞无关。</li>
<li>[错误] 加了 CSP 就不用转义 → CSP 是额外防线，仍需输入输出编码。</li>
<li>[错误] unsafe-inline 方便 → 等于关掉 XSS 防护，生产环境禁用。</li>
</ul>
<h2 id="8-一句话总结">8. 一句话总结</h2>
<p>CSP 把“浏览器执行什么、加载什么”的决定权从页面代码收回到服务器声明；只要白名单足够精细，未知脚本、未知 iframe、未知资源都将在浏览器端被直接拦截，实现“零信任”前端安全。</p>
<h2 id="meta-标签与响应头对比"><code>&lt;meta&gt;</code>标签与响应头对比</h2>
<p><code>&lt;meta&gt;</code>标签确实可以在 HTML 里充当 CSP 的“内联声明”，但它只是功能受限的替代品，并非与 HTTP 响应头等价。</p>
<h3 id="作用范围">作用范围</h3>
<p><code>&lt;meta&gt;</code>版本的 CSP 仅在当前 HTML 文档生效。如果后续通过 JavaScript 动态插入<code>&lt;script src&gt;</code>或<code>&lt;iframe&gt;</code>，仍受该<code>&lt;meta&gt;</code>策略约束。</p>
<h3 id="能力限制">能力限制</h3>
<ul>
<li>不支持<code>report-uri</code>、<code>report-to</code>、<code>frame-ancestors</code>等只能在响应头里生效的指令。</li>
<li>无法覆盖通过 HTTP 头提前加载的资源（如预加载、HSTS 预加载）。</li>
</ul>
<h3 id="生效时机">生效时机</h3>
<p>浏览器解析到<code>&lt;meta&gt;</code>时才开始应用策略；若在此之前已加载了违规资源，则拦不住。</p>
<h3 id="适用场景">适用场景</h3>
<ul>
<li>无法修改服务器头（静态托管、CDN 边缘节点）时的应急部署。</li>
<li>单页应用（SPA）在打包阶段硬编码策略，减少运维依赖。</li>
</ul>
<h3 id="结论">结论</h3>
<p><code>&lt;meta&gt;</code>可临时或局部替代响应头，但生产环境仍推荐用<code>Content-Security-Policy</code> 响应头，功能最完整、生效最早。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2025/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/">https://magicliang.github.io/2025/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%89%B4%E6%9D%83/">鉴权</a></div><div class="post-share"><div class="social-share" data-image="/2025/07/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D%E6%8A%80%E6%9C%AF/oauth2-arch.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">会话技术</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">关键 header</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AF%8F%E6%AC%A1%E9%83%BD%E5%BA%94%E8%AF%A5%E6%9C%89%E7%9A%84%E5%9F%BA%E7%A1%80header"><span class="toc-number">2.1.</span> <span class="toc-text">每次都应该有的基础Header</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%BA%E7%83%88%E6%8E%A8%E8%8D%90%E6%AF%8F%E6%AC%A1%E9%83%BD%E5%8C%85%E5%90%AB%E7%9A%84header-%E5%B0%A4%E5%85%B6%E6%98%AF%E5%AE%89%E5%85%A8%E5%92%8C%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">强烈推荐每次都包含的Header（尤其是安全和缓存）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">cookie 技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie-%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">3.1.</span> <span class="toc-text">cookie 的属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cookie-%E7%9A%84%E9%87%8D%E6%94%BE"><span class="toc-number">3.2.</span> <span class="toc-text">cookie 的重放</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96-web-storage-indexeddb-localstorage-%E5%AF%B9%E6%AF%94"><span class="toc-number">3.3.</span> <span class="toc-text">与其他 Web Storage（IndexedDB、LocalStorage）对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cookie%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">3.3.1.</span> <span class="toc-text">Cookie的局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#third-party-cookie"><span class="toc-number">3.3.1.1.</span> <span class="toc-text">third-party cookie</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#web-storage-localstorage-sessionstorage-%E7%9A%84%E5%87%BA%E7%8E%B0%E8%A7%A3%E5%86%B3%E4%BA%86%E8%BF%99%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">3.3.2.</span> <span class="toc-text">Web Storage（LocalStorage, SessionStorage）的出现解决了这些问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#indexeddb%E5%88%99%E6%9B%B4%E8%BF%9B%E4%B8%80%E6%AD%A5"><span class="toc-number">3.3.3.</span> <span class="toc-text">IndexedDB则更进一步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.4.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">jwt</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%B7%E5%9B%A0"><span class="toc-number">4.1.</span> <span class="toc-text">起因</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">4.2.</span> <span class="toc-text">核心思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.</span> <span class="toc-text">结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">4.4.</span> <span class="toc-text">例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%BC%BC%E7%9A%84-token"><span class="toc-number">4.5.</span> <span class="toc-text">类似的 token</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">SSO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%BE%E7%A1%AE%E7%9A%84sso%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B-%E7%BB%93%E5%90%88%E8%81%94%E9%82%A6%E8%AE%A4%E8%AF%81"><span class="toc-number">5.1.</span> <span class="toc-text">精确的SSO登录流程 (结合联邦认证)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%8F%82%E4%B8%8E%E8%80%85"><span class="toc-number">5.1.1.</span> <span class="toc-text">核心参与者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.1.2.</span> <span class="toc-text">流程步骤</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">5.1.2.1.</span> <span class="toc-text">设计思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.2.2.</span> <span class="toc-text">安全问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C-token-%E6%88%96%E8%80%85-ticket-%E8%A2%AB%E5%A4%8D%E5%88%B6-%E5%88%86%E4%BA%AB%E6%88%96%E8%80%85%E7%AA%83%E5%90%AC%E6%8B%BF%E6%9D%A5%E7%94%A8-%E5%BA%94%E8%AF%A5%E6%80%8E%E4%B9%88%E9%98%B2%E5%BE%A1%E6%B0%B4%E5%B9%B3%E8%B6%8A%E6%9D%83"><span class="toc-number">5.1.2.2.1.</span> <span class="toc-text">如果 token 或者 ticket 被复制、分享或者窃听拿来用，应该怎么防御水平越权</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E6%9D%83%E9%99%90%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.2.2.2.</span> <span class="toc-text">水平权限兼容问题</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.1.2.2.2.1.</span> <span class="toc-text">死循环</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E6%B3%95"><span class="toc-number">5.1.2.2.2.2.</span> <span class="toc-text">解法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90%E5%87%BA%E4%B8%80%E4%B8%AA%E4%B8%8D%E4%BC%9A%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-number">5.1.2.2.2.3.</span> <span class="toc-text">解析出一个不会循环的地址</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E8%B4%A6%E5%8F%B7%E5%88%97%E8%A1%A8%E6%B3%95"><span class="toc-number">5.1.2.2.2.4.</span> <span class="toc-text">选择账号列表法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%87%8D%E7%99%BB%E9%99%86%E6%B3%95"><span class="toc-number">5.1.2.2.2.5.</span> <span class="toc-text">重登陆法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sso%E7%99%BB%E5%87%BA%E6%B5%81%E7%A8%8B-logout"><span class="toc-number">5.1.3.</span> <span class="toc-text">SSO登出流程 (Logout)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">OAUTH2</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E8%A7%92%E8%89%B2%E5%AE%9A%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">基本角色定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#token-%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.1.</span> <span class="toc-text">token 类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%87%AD%E8%AF%81%E6%B5%81%E7%A8%8B-%E9%80%82%E7%94%A8%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%80%9A%E4%BF%A1"><span class="toc-number">6.1.2.</span> <span class="toc-text">客户端凭证流程（适用于服务器到服务器通信）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%88%E6%9D%83%E7%A0%81%E6%B5%81%E7%A8%8B-%E9%80%82%E7%94%A8%E4%BA%8E%E6%9C%89%E7%94%A8%E6%88%B7%E5%8F%82%E4%B8%8E%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">6.1.3.</span> <span class="toc-text">授权码流程（适用于有用户参与的场景）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E4%BB%A4%E7%89%8C%E6%B5%81%E7%A8%8B-refresh-token-flow"><span class="toc-number">6.1.4.</span> <span class="toc-text">刷新令牌流程 (Refresh Token Flow)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">特殊的请求头</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#location"><span class="toc-number">7.1.</span> <span class="toc-text">Location</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3xx-%E7%8A%B6%E6%80%81%E7%A0%81%E6%80%BB%E6%98%AF%E8%87%AA%E5%B8%A6-location-%E5%A4%B4%E9%83%A8%E5%90%97%EF%BC%9F"><span class="toc-number">7.1.1.</span> <span class="toc-text">3xx 状态码总是自带 Location 头部吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ajax-get-302-location-%E8%A7%A6%E5%8F%91%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.2.</span> <span class="toc-text">ajax get 302 + Location 触发跨域问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E8%A1%8C%E4%B8%BA%E5%AF%B9%E6%AF%94"><span class="toc-number">7.1.2.1.</span> <span class="toc-text">场景行为对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#302-%E9%87%8D%E5%AE%9A%E5%90%91%E5%93%8D%E5%BA%94%E5%AF%B9%E6%AF%94"><span class="toc-number">7.1.2.2.</span> <span class="toc-text">302 重定向响应对比</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">攻击技术</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E8%B7%A8%E5%9F%9F%E8%AE%BF%E9%97%AE"><span class="toc-number">8.1.</span> <span class="toc-text">如何阻止跨域访问</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#x-frame-options-%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.2.</span> <span class="toc-text">X-Frame-Options 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81-clickjacking"><span class="toc-number">8.2.1.</span> <span class="toc-text">什么是点击劫持（Clickjacking）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%B5%81%E7%A8%8B%E7%A4%BA%E6%84%8F"><span class="toc-number">8.2.1.1.</span> <span class="toc-text">攻击流程示意</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x-frame-options-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.2.2.</span> <span class="toc-text">X-Frame-Options 的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E5%80%BC%E9%80%89%E9%A1%B9"><span class="toc-number">8.2.2.1.</span> <span class="toc-text">取值选项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">8.2.3.</span> <span class="toc-text">实际应用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%B6%E8%A1%8C%E7%BD%91%E7%AB%99-%E9%AB%98%E5%AE%89%E5%85%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">8.2.3.1.</span> <span class="toc-text">银行网站（高安全场景）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%81%E4%B8%9A%E5%86%85%E9%83%A8%E9%97%A8%E6%88%B7%E7%BD%91%E7%AB%99"><span class="toc-number">8.2.3.2.</span> <span class="toc-text">企业内部门户网站</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E8%A1%8C%E4%B8%BA"><span class="toc-number">8.2.4.</span> <span class="toc-text">浏览器行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9Acontent-security-policy-csp"><span class="toc-number">8.2.5.</span> <span class="toc-text">现代替代方案：Content Security Policy (CSP)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#csp-%E4%BC%98%E5%8A%BF"><span class="toc-number">8.2.6.</span> <span class="toc-text">CSP 优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%BB%BA%E8%AE%AE"><span class="toc-number">8.2.7.</span> <span class="toc-text">配置建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">8.2.8.</span> <span class="toc-text">注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.2.9.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xss-%E5%92%8C-ssrf"><span class="toc-number">8.3.</span> <span class="toc-text">xss 和 ssrf</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">Content-Security-Policy（CSP）完全指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.</span> <span class="toc-text">1. 解决的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F"><span class="toc-number">9.2.</span> <span class="toc-text">2. 部署方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#http-%E5%93%8D%E5%BA%94%E5%A4%B4-%E6%8E%A8%E8%8D%90-%E5%8A%9F%E8%83%BD%E6%9C%80%E5%85%A8"><span class="toc-number">9.2.1.</span> <span class="toc-text">HTTP 响应头（推荐，功能最全）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#meta-%E6%A0%87%E7%AD%BE-%E7%B4%A7%E6%80%A5%E7%83%AD%E4%BF%AE%E6%88%96%E9%9D%99%E6%80%81%E7%AB%99%E7%82%B9"><span class="toc-number">9.2.2.</span> <span class="toc-text">&lt;meta&gt;标签（紧急热修或静态站点）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E4%B8%9A%E5%8A%A1%E7%AB%99%E7%82%B9"><span class="toc-number">9.2.3.</span> <span class="toc-text">通用业务站点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BF%9D%E8%A7%84%E6%8A%A5%E5%91%8A%E4%B8%8E%E7%9B%91%E6%8E%A7"><span class="toc-number">9.3.</span> <span class="toc-text">6. 违规报告与监控</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%80%E5%90%AF%E4%B8%8A%E6%8A%A5"><span class="toc-number">9.3.1.</span> <span class="toc-text">开启上报</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%8E%A5%E6%94%B6-json-%E6%8A%A5%E5%91%8A-%E5%AE%9E%E6%97%B6%E5%91%8A%E8%AD%A6"><span class="toc-number">9.3.2.</span> <span class="toc-text">服务器接收 JSON 报告，实时告警</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E5%B8%B8%E8%A7%81%E8%AF%AF%E5%8C%BA"><span class="toc-number">9.4.</span> <span class="toc-text">7. 常见误区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%80%BB%E7%BB%93"><span class="toc-number">9.5.</span> <span class="toc-text">8. 一句话总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#meta-%E6%A0%87%E7%AD%BE%E4%B8%8E%E5%93%8D%E5%BA%94%E5%A4%B4%E5%AF%B9%E6%AF%94"><span class="toc-number">9.6.</span> <span class="toc-text">&lt;meta&gt;标签与响应头对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">9.6.1.</span> <span class="toc-text">作用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%8A%9B%E9%99%90%E5%88%B6"><span class="toc-number">9.6.2.</span> <span class="toc-text">能力限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%95%88%E6%97%B6%E6%9C%BA"><span class="toc-number">9.6.3.</span> <span class="toc-text">生效时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">9.6.4.</span> <span class="toc-text">适用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">9.6.5.</span> <span class="toc-text">结论</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>