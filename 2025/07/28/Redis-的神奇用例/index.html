<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis 经典用例全解：从数据结构到系统设计 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Redis 不只是缓存。它是一把瑞士军刀——凭借五种基础数据结构和若干扩展模块，Redis 能解决从分布式锁到社交网络、从排行榜到消息队列的几乎所有高频系统设计问题。 本文的目标是：建立一套从业务问题到 Redis 数据结构的映射思维。对于每个用例，我们都会回答三个问题：  业务问题是什么？ 需求的本质是什么操作？ 为什么选 Redis？ 相比 MySQL、MQ 等方案，Redis 的优势和代价是">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 经典用例全解：从数据结构到系统设计">
<meta property="og:url" content="https://magicliang.github.io/2025/07/28/Redis-%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E4%BE%8B/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="Redis 不只是缓存。它是一把瑞士军刀——凭借五种基础数据结构和若干扩展模块，Redis 能解决从分布式锁到社交网络、从排行榜到消息队列的几乎所有高频系统设计问题。 本文的目标是：建立一套从业务问题到 Redis 数据结构的映射思维。对于每个用例，我们都会回答三个问题：  业务问题是什么？ 需求的本质是什么操作？ 为什么选 Redis？ 相比 MySQL、MQ 等方案，Redis 的优势和代价是">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-43.jpg">
<meta property="article:published_time" content="2025-07-28T12:48:32.000Z">
<meta property="article:modified_time" content="2026-02-07T05:15:14.279Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="系统设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-43.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis 经典用例全解：从数据结构到系统设计",
  "url": "https://magicliang.github.io/2025/07/28/Redis-%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E4%BE%8B/",
  "image": "https://magicliang.github.io/img/wall-paper-43.jpg",
  "datePublished": "2025-07-28T12:48:32.000Z",
  "dateModified": "2026-02-07T05:15:14.279Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2025/07/28/Redis-%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E4%BE%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 经典用例全解：从数据结构到系统设计',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-43.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis 经典用例全解：从数据结构到系统设计</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Redis 经典用例全解：从数据结构到系统设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-28T12:48:32.000Z" title="Created 2025-07-28 20:48:32">2025-07-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-07T05:15:14.279Z" title="Updated 2026-02-07 13:15:14">2026-02-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">15.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>60mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>Redis 不只是缓存。它是一把瑞士军刀——凭借五种基础数据结构和若干扩展模块，Redis 能解决从分布式锁到社交网络、从排行榜到消息队列的几乎所有高频系统设计问题。</p>
<p>本文的目标是：<strong>建立一套从业务问题到 Redis 数据结构的映射思维</strong>。对于每个用例，我们都会回答三个问题：</p>
<ol>
<li><strong>业务问题是什么？</strong> 需求的本质是什么操作？</li>
<li><strong>为什么选 Redis？</strong> 相比 MySQL、MQ 等方案，Redis 的优势和代价是什么？</li>
<li><strong>怎么设计？</strong> 用哪种数据结构，Key 怎么命名，核心命令是什么？</li>
</ol>
<pre><code class="hljs mermaid">mindmap
  root((Redis 用例全景))
    基础存储
      缓存策略
        Cache-Aside
        穿透/击穿/雪崩
      分布式会话
        Session 共享
        验证码/短链接
      分布式 ID
        INCR 自增
        日期分段
    并发控制
      分布式锁
        SET NX
        Redlock
        看门狗续期
      计数器与限流
        固定窗口
        滑动窗口
        令牌桶
    有序数据
      排行榜
        实时排名
        多维度榜单
      延时队列
        Score=到期时间
        Lua 原子消费
    关系与集合
      社交关系
        关注/粉丝
        共同好友
        集合运算
      评论系统
        实体+索引分离
        二级评论树
    消息与事件
      消息队列
        List 简单队列
        Pub/Sub 广播
        Stream 可靠队列
    地理与统计
      地理位置
        GEO 附近的人
        GeoHash 编码
      UV 统计
        HyperLogLog
        12KB 统计 2^64
      布隆过滤器
        穿透防护
        概率换空间
    二值状态
      签到系统
        Bitmap
        BITCOUNT/BITOP</code></pre>
<h1>Redis 数据结构速查与设计思维框架</h1>
<h2 id="数据结构总览">数据结构总览</h2>
<p>在开始任何设计之前，先建立对 Redis 数据结构能力的直觉：</p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>本质</th>
<th>核心能力</th>
<th>典型映射场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>String</strong></td>
<td>二进制安全的字节串</td>
<td>GET/SET/INCR/DECR，原子操作，支持 TTL</td>
<td>缓存、计数器、分布式锁、会话</td>
</tr>
<tr>
<td><strong>Hash</strong></td>
<td>字段-值映射表</td>
<td>HSET/HGET/HGETALL，单个 Key 下的结构化存储</td>
<td>对象存储、用户 Profile、购物车</td>
</tr>
<tr>
<td><strong>List</strong></td>
<td>双向链表</td>
<td>LPUSH/RPOP/BRPOP，阻塞弹出</td>
<td>消息队列、最新动态、操作日志</td>
</tr>
<tr>
<td><strong>Set</strong></td>
<td>无序唯一集合</td>
<td>SADD/SISMEMBER/SINTER/SUNION/SDIFF</td>
<td>标签、共同好友、去重、抽奖</td>
</tr>
<tr>
<td><strong>Sorted Set (ZSet)</strong></td>
<td>带分数的有序唯一集合</td>
<td>ZADD/ZRANGE/ZRANK/ZRANGEBYSCORE</td>
<td>排行榜、延时队列、时间线、滑动窗口</td>
</tr>
<tr>
<td><strong>HyperLogLog</strong></td>
<td>概率基数统计</td>
<td>PFADD/PFCOUNT/PFMERGE，误差 ≤ 0.81%</td>
<td>UV 统计、独立访客计数</td>
</tr>
<tr>
<td><strong>Bitmap</strong></td>
<td>位数组</td>
<td>SETBIT/GETBIT/BITCOUNT/BITOP</td>
<td>签到、在线状态、布隆过滤器</td>
</tr>
<tr>
<td><strong>GEO</strong></td>
<td>地理坐标索引（底层是 ZSet）</td>
<td>GEOADD/GEODIST/GEORADIUS</td>
<td>附近的人、门店搜索</td>
</tr>
<tr>
<td><strong>Stream</strong></td>
<td>持久化消息日志</td>
<td>XADD/XREAD/XREADGROUP/XACK</td>
<td>消息队列、事件溯源</td>
</tr>
</tbody>
</table>
<h2 id="设计思维框架：三步映射法">设计思维框架：三步映射法</h2>
<p>面对任何业务问题，可以按以下三步将其转化为 Redis 方案：</p>
<pre><code class="hljs mermaid">flowchart TD
    A[&quot;业务问题&quot;] --&gt; B[&quot;Step 1: 抽象操作语义&quot;]
    B --&gt; C&#123;&quot;需要什么操作？&quot;&#125;
    C --&gt;|&quot;读写单值&quot;| D[&quot;String&quot;]
    C --&gt;|&quot;结构化对象&quot;| E[&quot;Hash&quot;]
    C --&gt;|&quot;有序队列/栈&quot;| F[&quot;List&quot;]
    C --&gt;|&quot;集合运算&quot;| G[&quot;Set&quot;]
    C --&gt;|&quot;排序 + 范围查询&quot;| H[&quot;Sorted Set&quot;]
    C --&gt;|&quot;基数统计&quot;| I[&quot;HyperLogLog&quot;]
    C --&gt;|&quot;位运算&quot;| J[&quot;Bitmap&quot;]
    C --&gt;|&quot;地理距离&quot;| K[&quot;GEO&quot;]
    C --&gt;|&quot;消息流&quot;| L[&quot;Stream&quot;]
    
    D --&gt; M[&quot;Step 2: 设计 Key Schema&quot;]
    E --&gt; M
    F --&gt; M
    G --&gt; M
    H --&gt; M
    I --&gt; M
    J --&gt; M
    K --&gt; M
    L --&gt; M
    
    M --&gt; N[&quot;Step 3: 评估取舍&quot;]
    N --&gt; O&#123;&quot;数据丢失可接受？&quot;&#125;
    O --&gt;|&quot;是&quot;| P[&quot;纯 Redis 方案&quot;]
    O --&gt;|&quot;否&quot;| Q[&quot;Redis + 持久化存储&quot;]</code></pre>
<p><strong>Step 1 — 抽象操作语义</strong>：把业务需求翻译成数据操作。&quot;用户签到&quot;本质是&quot;标记某天某用户为已签到&quot;→ 位操作 → Bitmap。&quot;排行榜&quot;本质是&quot;按分数排序并查询排名&quot;→ 排序 + 排名查询 → Sorted Set。</p>
<p><strong>Step 2 — 设计 Key Schema</strong>：Key 的命名决定了数据的组织方式。通用模式是 <code>{业务域}:{实体类型}:{实体ID}:{子资源}</code>，例如 <code>post:123:comments</code>、<code>user:456:followers</code>。</p>
<p><strong>Step 3 — 评估取舍</strong>：Redis 是内存数据库，天然面临容量和持久性的约束。每个方案都需要回答：数据丢了怎么办？内存不够怎么办？需要事务一致性吗？</p>
<h2 id="七大可迁移模式-先记住模式-再看用例">七大可迁移模式（先记住模式，再看用例）</h2>
<p>在深入 14 个用例之前，先建立<strong>模式意识</strong>。下面这七个模式覆盖了 Redis 解决问题的所有核心套路。每个用例都是某个模式的具体实例——<strong>记住模式，就能自己推导出新场景的方案</strong>。</p>
<table>
<thead>
<tr>
<th>#</th>
<th>模式名称</th>
<th>一句话口诀</th>
<th>覆盖用例</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><strong>KV + TTL 万能临时状态</strong></td>
<td>任何&quot;有生命周期的状态&quot;都能用 String + 过期时间表达</td>
<td>缓存、Session、验证码、短链接</td>
</tr>
<tr>
<td>2</td>
<td><strong>原子占位</strong></td>
<td><code>SET NX</code> = “谁先到谁占坑”，解决一切&quot;只能有一个&quot;的问题</td>
<td>分布式锁、幂等控制、缓存击穿互斥锁</td>
</tr>
<tr>
<td>3</td>
<td><strong>Score 即时间轴</strong></td>
<td>把时间戳塞进 ZSet 的 Score，就得到了一条可查询的时间线</td>
<td>延时队列、排行榜、滑动窗口限流、时间线 Feed</td>
</tr>
<tr>
<td>4</td>
<td><strong>双向关系 + 集合运算</strong></td>
<td>一个关系写两个 Set，交并差运算解决所有&quot;共同/推荐/互相&quot;问题</td>
<td>社交关系、标签系统、权限交集</td>
</tr>
<tr>
<td>5</td>
<td><strong>实体 + 索引分离</strong></td>
<td>Hash 存内容，ZSet/Set 存索引——读写分离的 Redis 版</td>
<td>评论系统、商品列表、搜索结果缓存</td>
</tr>
<tr>
<td>6</td>
<td><strong>概率换空间</strong></td>
<td>用可控的误差换取数量级的内存节省</td>
<td>HyperLogLog UV 统计、布隆过滤器</td>
</tr>
<tr>
<td>7</td>
<td><strong>Lua 原子胶水</strong></td>
<td>多个命令需要&quot;要么全做要么不做&quot;时，用 Lua 脚本粘合</td>
<td>限流、延时队列消费、锁释放、令牌桶</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">flowchart LR
    subgraph &quot;记住这七个模式&quot;
        P1[&quot;① KV+TTL&lt;br/&gt;临时状态&quot;]
        P2[&quot;② 原子占位&lt;br/&gt;SET NX&quot;]
        P3[&quot;③ Score=时间戳&lt;br/&gt;时间轴&quot;]
        P4[&quot;④ 双Set&lt;br/&gt;集合运算&quot;]
        P5[&quot;⑤ Hash+ZSet&lt;br/&gt;实体+索引&quot;]
        P6[&quot;⑥ 概率结构&lt;br/&gt;换空间&quot;]
        P7[&quot;⑦ Lua 脚本&lt;br/&gt;原子胶水&quot;]
    end
    
    P1 --&gt; U1[&quot;缓存/Session/验证码&quot;]
    P2 --&gt; U2[&quot;分布式锁/幂等/击穿&quot;]
    P3 --&gt; U3[&quot;排行榜/延时队列/限流&quot;]
    P4 --&gt; U4[&quot;社交关系/标签/权限&quot;]
    P5 --&gt; U5[&quot;评论/商品列表&quot;]
    P6 --&gt; U6[&quot;UV统计/穿透防护&quot;]
    P7 --&gt; U7[&quot;贯穿所有需要原子性的场景&quot;]</code></pre>
<blockquote>
<p><strong>阅读建议</strong>：后文每个用例结束后，都会有一个 <strong>🔑 模式提炼</strong> 段落，把该用例抽象为可迁移的模式，并列出&quot;换个参数就能解决&quot;的同类场景。读完全文后，回到这张表，你会发现所有用例都是这七个模式的排列组合。</p>
</blockquote>
<hr>
<h1>用例一：缓存策略</h1>
<h2 id="业务问题">业务问题</h2>
<p>数据库查询慢，热点数据被反复读取，如何降低数据库压力并提升响应速度？</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>Redis</th>
<th>本地缓存 (Guava/Caffeine)</th>
<th>CDN</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>延迟</strong></td>
<td>亚毫秒（网络开销）</td>
<td>纳秒级</td>
<td>毫秒级</td>
</tr>
<tr>
<td><strong>一致性</strong></td>
<td>多实例共享，单点更新</td>
<td>每个实例独立，一致性差</td>
<td>适合静态资源</td>
</tr>
<tr>
<td><strong>容量</strong></td>
<td>GB 级</td>
<td>受 JVM 堆限制</td>
<td>无限（但成本高）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>动态热点数据</td>
<td>极热点、变化少的数据</td>
<td>静态资源</td>
</tr>
</tbody>
</table>
<h2 id="设计方案">设计方案</h2>
<h3 id="cache-aside-旁路缓存">Cache-Aside（旁路缓存）</h3>
<p>这是最常用的缓存模式。应用层同时管理缓存和数据库。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client
    participant App
    participant Redis
    participant DB

    Client-&gt;&gt;App: 查询数据
    App-&gt;&gt;Redis: GET cache:user:123
    alt 缓存命中
        Redis--&gt;&gt;App: 返回数据
        App--&gt;&gt;Client: 返回数据
    else 缓存未命中
        Redis--&gt;&gt;App: nil
        App-&gt;&gt;DB: SELECT * FROM users WHERE id=123
        DB--&gt;&gt;App: 用户数据
        App-&gt;&gt;Redis: SET cache:user:123 &#123;data&#125; EX 3600
        App--&gt;&gt;Client: 返回数据
    end</code></pre>
<p><strong>写操作</strong>：先更新数据库，再删除缓存（而非更新缓存）。删除比更新更安全，因为避免了并发写导致的脏数据。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 读</span><br>GET cache:user:123<br><br><span class="hljs-comment"># 写（先更新 DB，再删缓存）</span><br>DEL cache:user:123<br></code></pre></td></tr></table></figure>
<h3 id="缓存三大问题及应对">缓存三大问题及应对</h3>
<pre><code class="hljs mermaid">flowchart LR
    subgraph 缓存穿透
        A1[&quot;查询不存在的数据&quot;] --&gt; A2[&quot;每次都打到 DB&quot;]
        A2 --&gt; A3[&quot;解决：布隆过滤器&lt;br/&gt;或缓存空值&quot;]
    end
    
    subgraph 缓存击穿
        B1[&quot;热点 Key 过期&quot;] --&gt; B2[&quot;大量请求同时打到 DB&quot;]
        B2 --&gt; B3[&quot;解决：互斥锁重建&lt;br/&gt;或永不过期+异步更新&quot;]
    end
    
    subgraph 缓存雪崩
        C1[&quot;大量 Key 同时过期&quot;] --&gt; C2[&quot;DB 瞬间压力暴增&quot;]
        C2 --&gt; C3[&quot;解决：过期时间加随机值&lt;br/&gt;或多级缓存&quot;]
    end</code></pre>
<p><strong>缓存穿透</strong>：恶意或错误请求查询不存在的数据，缓存永远不会命中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 方案1：缓存空值（短 TTL）</span><br>SET cache:user:999999 <span class="hljs-string">&quot;&quot;</span> EX 60<br><br><span class="hljs-comment"># 方案2：布隆过滤器（见后文&quot;布隆过滤器&quot;章节）</span><br>BF.EXISTS user_filter 999999<br></code></pre></td></tr></table></figure>
<p><strong>缓存击穿</strong>：某个热点 Key 恰好过期，瞬间大量请求涌入数据库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 方案：分布式锁保护重建过程</span><br><span class="hljs-comment"># 只有拿到锁的请求去查 DB 并重建缓存，其他请求等待或返回旧值</span><br>SET lock:rebuild:user:123 1 NX EX 10<br></code></pre></td></tr></table></figure>
<p><strong>缓存雪崩</strong>：大量 Key 在同一时刻过期。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 方案：过期时间 = 基础时间 + 随机偏移</span><br><span class="hljs-comment"># 伪代码：SET cache:user:&#123;id&#125; &#123;data&#125; EX (3600 + random(0, 600))</span><br></code></pre></td></tr></table></figure>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：读性能提升 10-100 倍，显著降低 DB 压力</li>
<li><strong>代价</strong>：数据一致性是最终一致（有短暂的不一致窗口）；增加了系统复杂度（缓存更新策略、异常处理）</li>
<li><strong>不适合</strong>：对一致性要求极高的场景（如金融交易余额），或数据量极大且无明显热点的场景</li>
</ul>
<hr>
<h1>用例二：分布式会话（Session）</h1>
<h2 id="业务问题">业务问题</h2>
<p>Web 应用部署多个实例，用户登录后的 Session 如何在多实例间共享？</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>Redis</th>
<th>Sticky Session</th>
<th>DB 存储 Session</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>性能</strong></td>
<td>亚毫秒</td>
<td>无额外开销</td>
<td>毫秒级</td>
</tr>
<tr>
<td><strong>可用性</strong></td>
<td>实例宕机不影响</td>
<td>实例宕机丢 Session</td>
<td>高</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>水平扩展</td>
<td>受限于单实例</td>
<td>受限于 DB</td>
</tr>
<tr>
<td><strong>运维</strong></td>
<td>需维护 Redis</td>
<td>负载均衡配置复杂</td>
<td>DB 压力大</td>
</tr>
</tbody>
</table>
<h2 id="设计方案">设计方案</h2>
<pre><code class="hljs mermaid">flowchart LR
    User[&quot;用户&quot;] --&gt; LB[&quot;负载均衡器&quot;]
    LB --&gt; App1[&quot;App 实例 1&quot;]
    LB --&gt; App2[&quot;App 实例 2&quot;]
    LB --&gt; App3[&quot;App 实例 3&quot;]
    App1 --&gt; Redis[&quot;Redis&lt;br/&gt;session:token123 → user_data&quot;]
    App2 --&gt; Redis
    App3 --&gt; Redis</code></pre>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 用户登录成功后，生成 Session</span><br>SET session:abc123def456 <span class="hljs-string">&#x27;&#123;&quot;user_id&quot;:&quot;123&quot;,&quot;role&quot;:&quot;admin&quot;,&quot;login_time&quot;:1700000000&#125;&#x27;</span> EX 1800<br><br><span class="hljs-comment"># 每次请求验证 Session</span><br>GET session:abc123def456<br><br><span class="hljs-comment"># 续期（用户活跃时）</span><br>EXPIRE session:abc123def456 1800<br><br><span class="hljs-comment"># 用户登出</span><br>DEL session:abc123def456<br></code></pre></td></tr></table></figure>
<p><strong>Key Schema</strong>：<code>session:{session_token}</code>，Token 由服务端生成（UUID 或 JWT 的 jti），通过 Cookie 或 Header 传递给客户端。</p>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：无状态部署，实例可随意扩缩容；Session 天然支持 TTL 自动过期</li>
<li><strong>代价</strong>：每次请求多一次 Redis 网络往返；Redis 宕机影响所有用户登录态</li>
<li><strong>缓解</strong>：Redis Sentinel/Cluster 保证高可用；本地缓存 Session 减少网络调用</li>
</ul>
<h3 id="🔑-模式提炼：kv-ttl-万能临时状态">🔑 模式提炼：KV + TTL 万能临时状态</h3>
<p>回顾用例一（缓存）和用例二（Session），它们的底层结构完全相同：<strong>一个 String Key 存一段数据，配一个过期时间</strong>。区别仅在于 Key 的命名和 TTL 的长短。</p>
<p><strong>模式公式</strong>：<code>SET {业务域}:{标识符} {状态数据} EX {生命周期秒数}</code></p>
<p>这个模式可以直接迁移到以下场景——只需要换参数：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>Key</th>
<th>Value</th>
<th>TTL</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>缓存</strong></td>
<td><code>cache:user:123</code></td>
<td>序列化的用户数据</td>
<td>3600s</td>
<td>降低 DB 压力</td>
</tr>
<tr>
<td><strong>Session</strong></td>
<td><code>session:token</code></td>
<td>用户登录态 JSON</td>
<td>1800s</td>
<td>多实例共享</td>
</tr>
<tr>
<td><strong>短信验证码</strong></td>
<td><code>sms:code:13800138000</code></td>
<td><code>&quot;384729&quot;</code></td>
<td>300s</td>
<td>5 分钟有效</td>
</tr>
<tr>
<td><strong>邮箱验证链接</strong></td>
<td><code>verify:email:uuid</code></td>
<td><code>&quot;user_123&quot;</code></td>
<td>86400s</td>
<td>24 小时有效</td>
</tr>
<tr>
<td><strong>短链接</strong></td>
<td><code>short:abc123</code></td>
<td><code>&quot;https://...&quot;</code></td>
<td>永不过期或 30 天</td>
<td>302 跳转</td>
</tr>
<tr>
<td><strong>接口幂等</strong></td>
<td><code>idempotent:order:req_uuid</code></td>
<td><code>&quot;1&quot;</code></td>
<td>600s</td>
<td>防重复提交</td>
</tr>
<tr>
<td><strong>分布式限流标记</strong></td>
<td><code>blocked:ip:1.2.3.4</code></td>
<td><code>&quot;1&quot;</code></td>
<td>3600s</td>
<td>IP 封禁 1 小时</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：任何&quot;有生命周期的临时状态&quot;，都可以用这个模式一行命令解决。你不需要为每种场景设计不同的方案——它们本质上是同一个东西，只是 Key 的命名空间和 TTL 不同。</p>
<hr>
<h1>用例三：分布式锁</h1>
<h2 id="业务问题">业务问题</h2>
<p>多个服务实例并发操作同一资源（如扣减库存），如何保证互斥？</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>Redis</th>
<th>ZooKeeper</th>
<th>数据库行锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>性能</strong></td>
<td>极高（万级 QPS）</td>
<td>中等</td>
<td>低</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>需要额外机制防死锁</td>
<td>临时节点天然防死锁</td>
<td>高</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>低</td>
<td>高（需 ZK 集群）</td>
<td>低</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>高性能互斥</td>
<td>强一致性场景</td>
<td>已有 DB 的简单场景</td>
</tr>
</tbody>
</table>
<h2 id="设计方案">设计方案</h2>
<h3 id="基础版：setnx-过期时间">基础版：SETNX + 过期时间</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client1
    participant Client2
    participant Redis

    Client1-&gt;&gt;Redis: SET lock:order:123 uuid1 NX EX 30
    Redis--&gt;&gt;Client1: OK（获锁成功）
    
    Client2-&gt;&gt;Redis: SET lock:order:123 uuid2 NX EX 30
    Redis--&gt;&gt;Client2: nil（获锁失败）
    
    Note over Client1: 执行业务逻辑...
    
    Client1-&gt;&gt;Redis: Lua: if GET == uuid1 then DEL
    Redis--&gt;&gt;Client1: 释放成功</code></pre>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 加锁：SET key value NX EX seconds</span><br><span class="hljs-comment"># NX = 不存在才设置（互斥语义）</span><br><span class="hljs-comment"># EX = 过期时间（防死锁）</span><br><span class="hljs-comment"># value = 唯一标识（防误删别人的锁）</span><br>SET lock:order:123 <span class="hljs-string">&quot;uuid-abc-123&quot;</span> NX EX 30<br><br><span class="hljs-comment"># 释放锁：必须用 Lua 脚本保证原子性（先比较再删除）</span><br><span class="hljs-comment"># 如果直接 DEL，可能删掉别人的锁</span><br></code></pre></td></tr></table></figure>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 释放锁的 Lua 脚本</span><br><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;GET&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;DEL&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<h3 id="进阶：redlock-算法">进阶：Redlock 算法</h3>
<p>当 Redis 是单点时，主节点宕机可能导致锁丢失。Redlock 使用 N 个独立的 Redis 实例（通常 5 个），客户端需要在<strong>多数节点</strong>（≥ N/2 + 1）上成功加锁才算获锁。</p>
<pre><code class="hljs mermaid">flowchart TD
    Client[&quot;客户端&quot;] --&gt; R1[&quot;Redis 1: SET lock NX&quot;]
    Client --&gt; R2[&quot;Redis 2: SET lock NX&quot;]
    Client --&gt; R3[&quot;Redis 3: SET lock NX&quot;]
    Client --&gt; R4[&quot;Redis 4: SET lock NX&quot;]
    Client --&gt; R5[&quot;Redis 5: SET lock NX&quot;]
    
    R1 --&gt;|&quot;OK&quot;| Check[&quot;获锁成功 ≥ 3/5？&quot;]
    R2 --&gt;|&quot;OK&quot;| Check
    R3 --&gt;|&quot;OK&quot;| Check
    R4 --&gt;|&quot;nil&quot;| Check
    R5 --&gt;|&quot;OK&quot;| Check
    
    Check --&gt;|&quot;是 (4/5)&quot;| Success[&quot;获锁成功&lt;br/&gt;有效时间 = TTL - 获锁耗时&quot;]
    Check --&gt;|&quot;否&quot;| Fail[&quot;获锁失败&lt;br/&gt;释放所有已获取的锁&quot;]</code></pre>
<h3 id="看门狗机制-锁续期">看门狗机制（锁续期）</h3>
<p>业务执行时间可能超过锁的过期时间。Redisson 等客户端库实现了&quot;看门狗&quot;机制：后台线程定期检查锁是否仍被持有，如果是则自动续期。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client
    participant Watchdog as 看门狗线程
    participant Redis

    Client-&gt;&gt;Redis: SET lock:res uuid1 NX EX 30
    Redis--&gt;&gt;Client: OK
    
    Note over Client: 开始执行业务（可能耗时 &gt; 30s）
    
    loop 每 10 秒检查一次
        Watchdog-&gt;&gt;Redis: if GET lock:res == uuid1 then EXPIRE 30
        Redis--&gt;&gt;Watchdog: OK（续期成功）
    end
    
    Client-&gt;&gt;Redis: Lua: if GET == uuid1 then DEL
    Note over Watchdog: 停止续期</code></pre>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：性能极高，实现简单，适合大多数互斥场景</li>
<li><strong>代价</strong>：Redis 主从切换时可能短暂丢锁；Redlock 有争议（Martin Kleppmann vs Antirez 的经典论战）</li>
<li><strong>建议</strong>：对锁的正确性要求不是&quot;生死攸关&quot;时用 Redis 锁；金融级场景考虑 ZooKeeper 或数据库乐观锁</li>
</ul>
<h3 id="🔑-模式提炼：原子占位-set-nx">🔑 模式提炼：原子占位（SET NX）</h3>
<p>分布式锁的本质不是&quot;锁&quot;，而是**“原子占位”**——在一个共享命名空间中，谁先到谁占坑，后来者被拒绝。<code>SET key value NX</code> 这五个字母，解决了一整类&quot;只能有一个&quot;的问题。</p>
<p><strong>模式公式</strong>：<code>SET {命名空间}:{资源标识} {持有者标识} NX EX {超时秒数}</code></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>Key</th>
<th>Value</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>分布式锁</strong></td>
<td><code>lock:order:123</code></td>
<td><code>uuid</code></td>
<td>同一时刻只有一个实例处理该订单</td>
</tr>
<tr>
<td><strong>幂等控制</strong></td>
<td><code>idempotent:pay:req_abc</code></td>
<td><code>&quot;1&quot;</code></td>
<td>同一个支付请求只处理一次</td>
</tr>
<tr>
<td><strong>缓存击穿互斥</strong></td>
<td><code>lock:rebuild:user:123</code></td>
<td><code>&quot;1&quot;</code></td>
<td>只有一个请求去重建缓存</td>
</tr>
<tr>
<td><strong>定时任务防重</strong></td>
<td><code>cron:daily_report:20250728</code></td>
<td><code>instance_id</code></td>
<td>今天的日报只由一个实例生成</td>
</tr>
<tr>
<td><strong>抢购/秒杀资格</strong></td>
<td><code>seckill:item:789:user:456</code></td>
<td><code>&quot;1&quot;</code></td>
<td>每人限购一次</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当你听到&quot;只能有一个&quot;、“不能重复”、&quot;谁先谁得&quot;这类需求时，脑中应该立刻浮现 <code>SET NX</code>。它们都是同一个模式的不同参数化实例。</p>
<p><strong>进阶认知</strong>：原子占位模式有三个关键细节，无论应用在哪个场景都适用：</p>
<ol>
<li><strong>必须有 TTL</strong>（防死锁/防泄漏）</li>
<li><strong>Value 必须唯一</strong>（防误释放别人的占位）</li>
<li><strong>释放必须原子</strong>（Lua 脚本：先比较再删除）</li>
</ol>
<hr>
<h1>用例四：计数器与限流器</h1>
<h2 id="业务问题">业务问题</h2>
<h3 id="计数器">计数器</h3>
<p>统计文章阅读量、点赞数、库存数量等，要求高并发下的原子递增/递减。</p>
<h3 id="限流器">限流器</h3>
<p>防止 API 被恶意调用或突发流量打垮服务，需要对请求频率进行限制。</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<ul>
<li><strong>原子性</strong>：<code>INCR</code>/<code>DECR</code> 是原子操作，天然线程安全</li>
<li><strong>性能</strong>：单实例 10 万+ QPS，远超数据库</li>
<li><strong>TTL</strong>：天然支持过期，适合滑动窗口等时间相关的计数</li>
</ul>
<h2 id="设计方案">设计方案</h2>
<h3 id="简单计数器">简单计数器</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 文章阅读量 +1</span><br>INCR article:123:views<br><span class="hljs-comment"># 返回: (integer) 42</span><br><br><span class="hljs-comment"># 获取阅读量</span><br>GET article:123:views<br><span class="hljs-comment"># 返回: &quot;42&quot;</span><br><br><span class="hljs-comment"># 点赞（原子递增）</span><br>INCR post:456:likes<br><br><span class="hljs-comment"># 取消点赞（原子递减）</span><br>DECR post:456:likes<br></code></pre></td></tr></table></figure>
<h3 id="固定窗口限流">固定窗口限流</h3>
<p>最简单的限流：在固定时间窗口内限制请求次数。</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph &quot;固定窗口 (1分钟)&quot;
        A[&quot;12:00:00 - 12:00:59&lt;br/&gt;限制 100 次&quot;]
        B[&quot;12:01:00 - 12:01:59&lt;br/&gt;限制 100 次&quot;]
    end
    C[&quot;⚠️ 临界问题：&lt;br/&gt;12:00:50-12:01:10 的 20 秒内&lt;br/&gt;可能通过 200 次请求&quot;]</code></pre>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 固定窗口限流</span><br><span class="hljs-comment"># Key 包含时间窗口标识（分钟级）</span><br>INCR rate:user:123:202307281200<br>EXPIRE rate:user:123:202307281200 60<br><br><span class="hljs-comment"># 检查是否超限</span><br>GET rate:user:123:202307281200<br><span class="hljs-comment"># 如果 &gt; 100，拒绝请求</span><br></code></pre></td></tr></table></figure>
<h3 id="滑动窗口限流-推荐">滑动窗口限流（推荐）</h3>
<p>使用 Sorted Set 实现真正的滑动窗口，解决固定窗口的临界问题。</p>
<pre><code class="hljs mermaid">flowchart TD
    A[&quot;请求到达&quot;] --&gt; B[&quot;ZREMRANGEBYSCORE&lt;br/&gt;移除窗口外的旧请求&quot;]
    B --&gt; C[&quot;ZCARD&lt;br/&gt;统计窗口内请求数&quot;]
    C --&gt; D&#123;&quot;请求数 &lt; 限制？&quot;&#125;
    D --&gt;|&quot;是&quot;| E[&quot;ZADD 记录本次请求&lt;br/&gt;EXPIRE 设置 Key 过期&quot;]
    D --&gt;|&quot;否&quot;| F[&quot;拒绝请求&quot;]</code></pre>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 滑动窗口限流（每分钟最多 100 次）</span><br><span class="hljs-comment"># current_timestamp = 1700000000000（当前时间戳，毫秒）</span><br><br><span class="hljs-comment"># 1. 移除 1 分钟前的旧记录</span><br>ZREMRANGEBYSCORE rate:user:123 0 1699999940000<br><br><span class="hljs-comment"># 2. 统计当前窗口内的请求数</span><br>ZCARD rate:user:123<br><br><span class="hljs-comment"># 3. 如果未超限，记录本次请求（member 需唯一，用时间戳+随机数）</span><br>ZADD rate:user:123 1700000000000 <span class="hljs-string">&quot;1700000000000-384729&quot;</span><br>EXPIRE rate:user:123 60<br></code></pre></td></tr></table></figure>
<p>为了保证原子性，应使用 Lua 脚本将上述步骤合并：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 滑动窗口限流 Lua 脚本</span><br><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">local</span> now = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">local</span> window = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">local</span> limit = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">3</span>])<br><br>redis.call(<span class="hljs-string">&#x27;ZREMRANGEBYSCORE&#x27;</span>, key, <span class="hljs-number">0</span>, now - window)<br><span class="hljs-keyword">local</span> count = redis.call(<span class="hljs-string">&#x27;ZCARD&#x27;</span>, key)<br><br><span class="hljs-keyword">if</span> count &lt; limit <span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;ZADD&#x27;</span>, key, now, now .. <span class="hljs-string">&#x27;-&#x27;</span> .. <span class="hljs-built_in">math</span>.<span class="hljs-built_in">random</span>(<span class="hljs-number">1000000</span>))<br>    redis.call(<span class="hljs-string">&#x27;EXPIRE&#x27;</span>, key, <span class="hljs-built_in">math</span>.<span class="hljs-built_in">ceil</span>(window / <span class="hljs-number">1000</span>))<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>  <span class="hljs-comment">-- 允许</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-comment">-- 拒绝</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<h3 id="令牌桶限流">令牌桶限流</h3>
<p>令牌桶允许一定程度的突发流量，比滑动窗口更灵活。核心思想：令牌以固定速率放入桶中，每个请求消耗一个令牌，桶满则丢弃新令牌。</p>
<pre><code class="hljs mermaid">flowchart LR
    A[&quot;令牌以固定速率&lt;br/&gt;放入桶中&quot;] --&gt; B[&quot;桶 (容量上限)&quot;]
    B --&gt; C[&quot;每个请求&lt;br/&gt;消耗一个令牌&quot;]
    C --&gt; D&#123;&quot;桶中有令牌？&quot;&#125;
    D --&gt;|&quot;有&quot;| E[&quot;放行&quot;]
    D --&gt;|&quot;无&quot;| F[&quot;拒绝/等待&quot;]</code></pre>
<p>使用 Hash 存储令牌桶状态，Lua 脚本保证原子性：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 令牌桶 Lua 脚本</span><br><span class="hljs-keyword">local</span> key = KEYS[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">local</span> rate = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">1</span>])       <span class="hljs-comment">-- 每秒生成的令牌数</span><br><span class="hljs-keyword">local</span> capacity = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">2</span>])   <span class="hljs-comment">-- 桶容量</span><br><span class="hljs-keyword">local</span> now = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">3</span>])        <span class="hljs-comment">-- 当前时间戳（秒）</span><br><span class="hljs-keyword">local</span> requested = <span class="hljs-built_in">tonumber</span>(ARGV[<span class="hljs-number">4</span>])  <span class="hljs-comment">-- 请求的令牌数</span><br><br><span class="hljs-keyword">local</span> last_time = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;HGET&#x27;</span>, key, <span class="hljs-string">&#x27;last_time&#x27;</span>) <span class="hljs-keyword">or</span> now)<br><span class="hljs-keyword">local</span> tokens = <span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;HGET&#x27;</span>, key, <span class="hljs-string">&#x27;tokens&#x27;</span>) <span class="hljs-keyword">or</span> capacity)<br><br><span class="hljs-comment">-- 计算从上次到现在新生成的令牌</span><br><span class="hljs-keyword">local</span> elapsed = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, now - last_time)<br>tokens = <span class="hljs-built_in">math</span>.<span class="hljs-built_in">min</span>(capacity, tokens + elapsed * rate)<br><br><span class="hljs-keyword">if</span> tokens &gt;= requested <span class="hljs-keyword">then</span><br>    tokens = tokens - requested<br>    redis.call(<span class="hljs-string">&#x27;HSET&#x27;</span>, key, <span class="hljs-string">&#x27;last_time&#x27;</span>, now)<br>    redis.call(<span class="hljs-string">&#x27;HSET&#x27;</span>, key, <span class="hljs-string">&#x27;tokens&#x27;</span>, tokens)<br>    redis.call(<span class="hljs-string">&#x27;EXPIRE&#x27;</span>, key, <span class="hljs-built_in">math</span>.<span class="hljs-built_in">ceil</span>(capacity / rate) * <span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>  <span class="hljs-comment">-- 允许</span><br><span class="hljs-keyword">else</span><br>    redis.call(<span class="hljs-string">&#x27;HSET&#x27;</span>, key, <span class="hljs-string">&#x27;last_time&#x27;</span>, now)<br>    redis.call(<span class="hljs-string">&#x27;HSET&#x27;</span>, key, <span class="hljs-string">&#x27;tokens&#x27;</span>, tokens)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>  <span class="hljs-comment">-- 拒绝</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：原子操作天然线程安全；性能远超数据库方案；TTL 自动清理过期数据</li>
<li><strong>代价</strong>：计数器数据在内存中，Redis 宕机可能丢失（可通过持久化缓解）；滑动窗口的 ZSet 在高并发下内存占用较大</li>
<li><strong>不适合</strong>：需要精确持久化的计数（如账户余额），应使用数据库</li>
</ul>
<hr>
<h1>用例五：排行榜</h1>
<h2 id="业务问题">业务问题</h2>
<p>游戏积分排名、热门文章排行、销量排行等，需要实时更新分数并快速查询排名。</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<p>排行榜的核心操作是&quot;按分数排序 + 查询排名&quot;，这恰好是 Sorted Set 的原生能力。用 MySQL 实现需要 <code>ORDER BY score DESC LIMIT N</code>，在数据量大时性能急剧下降。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>Redis ZSet</th>
<th>MySQL</th>
</tr>
</thead>
<tbody>
<tr>
<td>更新分数</td>
<td>O(log N)</td>
<td>O(log N) + 写磁盘</td>
</tr>
<tr>
<td>查询排名</td>
<td>O(log N)</td>
<td>O(N log N) 全表排序</td>
</tr>
<tr>
<td>Top N</td>
<td>O(log N + N)</td>
<td>O(N log N)</td>
</tr>
<tr>
<td>查询周围排名</td>
<td>O(log N)</td>
<td>复杂子查询</td>
</tr>
</tbody>
</table>
<h2 id="设计方案">设计方案</h2>
<pre><code class="hljs mermaid">flowchart TD
    subgraph &quot;Sorted Set: leaderboard:global&quot;
        direction LR
        A[&quot;player_2: 2100&quot;] 
        B[&quot;player_1: 1800&quot;]
        C[&quot;player_3: 1000&quot;]
    end
    
    D[&quot;ZADD 更新分数&quot;] --&gt; A
    E[&quot;ZREVRANK 查排名&quot;] --&gt; A
    F[&quot;ZREVRANGE 0 N Top N&quot;] --&gt; A
    G[&quot;ZINCRBY 加分&quot;] --&gt; A</code></pre>
<h3 id="核心命令速查">核心命令速查</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 更新/添加用户分数（ZADD 自动覆盖已有 member 的 score）</span><br>ZADD leaderboard:global 1500 player_1<br>ZADD leaderboard:global 2100 player_2<br><br><span class="hljs-comment"># 只在新分数更高时更新（Redis 6.2+）</span><br>ZADD leaderboard:global GT 1800 player_1<br><br><span class="hljs-comment"># 增加分数（原子操作，比 ZSCORE + ZADD 更好）</span><br>ZINCRBY leaderboard:global 50 player_3<br><br><span class="hljs-comment"># 查询排名（0-based，0 = 第一名）</span><br>ZREVRANK leaderboard:global player_2<br><span class="hljs-comment"># 返回: (integer) 0</span><br><br><span class="hljs-comment"># 查询分数（O(1) 哈希查找，非常快）</span><br>ZSCORE leaderboard:global player_1<br><span class="hljs-comment"># 返回: &quot;1800&quot;</span><br><br><span class="hljs-comment"># 获取 Top 3（从高到低）</span><br>ZREVRANGE leaderboard:global 0 2 WITHSCORES<br><span class="hljs-comment"># 返回: player_2, 2100, player_1, 1800, player_3, 1000</span><br><br><span class="hljs-comment"># 获取用户周围的排名（前后各 2 名）</span><br><span class="hljs-comment"># 先获取排名</span><br>ZREVRANK leaderboard:global player_1  <span class="hljs-comment"># 假设返回 1</span><br><span class="hljs-comment"># 再获取范围 [max(0, 1-2), 1+2] = [0, 3]</span><br>ZREVRANGE leaderboard:global 0 3 WITHSCORES<br><br><span class="hljs-comment"># 分页：第 2 页，每页 10 条（页码从 0 开始）</span><br>ZREVRANGE leaderboard:global 10 19 WITHSCORES<br></code></pre></td></tr></table></figure>
<h3 id="多维度排行榜-日榜-周榜-月榜">多维度排行榜（日榜/周榜/月榜）</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 日榜（每天一个 Key，设置次日过期）</span><br>ZINCRBY leaderboard:daily:20250728 10 player_1<br>EXPIREAT leaderboard:daily:20250728 1690588800  <span class="hljs-comment"># 次日 0 点的时间戳</span><br><br><span class="hljs-comment"># 周榜（合并 7 天的日榜，ZUNIONSTORE 默认对相同 member 的 score 求和）</span><br>ZUNIONSTORE leaderboard:weekly:2025W30 7 \<br>    leaderboard:daily:20250722 \<br>    leaderboard:daily:20250723 \<br>    leaderboard:daily:20250724 \<br>    leaderboard:daily:20250725 \<br>    leaderboard:daily:20250726 \<br>    leaderboard:daily:20250727 \<br>    leaderboard:daily:20250728<br></code></pre></td></tr></table></figure>
<h3 id="zset-命令分类记忆">ZSet 命令分类记忆</h3>
<table>
<thead>
<tr>
<th>类别</th>
<th>命令</th>
<th>说明</th>
<th>时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>写入</strong></td>
<td><code>ZADD</code></td>
<td>添加/更新成员，支持 NX/XX/GT/LT 选项</td>
<td>O(log N)</td>
</tr>
<tr>
<td><strong>增量</strong></td>
<td><code>ZINCRBY</code></td>
<td>原子加分</td>
<td>O(log N)</td>
</tr>
<tr>
<td><strong>排名</strong></td>
<td><code>ZRANK</code> / <code>ZREVRANK</code></td>
<td>升序/降序排名（0-based）</td>
<td>O(log N)</td>
</tr>
<tr>
<td><strong>分数</strong></td>
<td><code>ZSCORE</code></td>
<td>查询单个成员的分数</td>
<td><strong>O(1)</strong></td>
</tr>
<tr>
<td><strong>范围-按排名</strong></td>
<td><code>ZRANGE</code> / <code>ZREVRANGE</code></td>
<td>按排名范围获取成员</td>
<td>O(log N + M)</td>
</tr>
<tr>
<td><strong>范围-按分数</strong></td>
<td><code>ZRANGEBYSCORE</code> / <code>ZREVRANGEBYSCORE</code></td>
<td>按分数区间获取成员</td>
<td>O(log N + M)</td>
</tr>
<tr>
<td><strong>删除</strong></td>
<td><code>ZREM</code></td>
<td>移除成员</td>
<td>O(log N)</td>
</tr>
<tr>
<td><strong>集合运算</strong></td>
<td><code>ZUNIONSTORE</code> / <code>ZINTERSTORE</code></td>
<td>合并多个 ZSet</td>
<td>O(N)</td>
</tr>
<tr>
<td><strong>计数</strong></td>
<td><code>ZCARD</code> / <code>ZCOUNT</code></td>
<td>总数 / 分数区间内的数量</td>
<td>O(1) / O(log N)</td>
</tr>
</tbody>
</table>
<p><strong>性能提示</strong>：<code>ZSCORE</code> 是 O(1) 的哈希查找，而 <code>ZRANGEBYSCORE</code> 是 O(log N + M) 的范围查询（M 为结果集大小）。查单个成员的分数永远用 <code>ZSCORE</code>。区间查找即使在 Redis 里也应该加上 <code>LIMIT</code>，避免返回过多数据。</p>
<h2 id="range-索引规则">Range 索引规则</h2>
<p>Redis 的 ZRANGE/ZREVRANGE/LRANGE 等命令的索引规则：</p>
<ul>
<li><strong>索引从 0 开始</strong>，第一个元素索引为 0</li>
<li><strong>支持负数索引</strong>：-1 表示最后一个元素，-2 表示倒数第二个</li>
<li><strong>start 和 stop 都是闭区间</strong>（包含两端），这与 Python 切片（左闭右开）不同</li>
<li><strong>常用组合</strong>：<code>0 0</code> = 第一个元素，<code>0 -1</code> = 所有元素，<code>0 9</code> = 前 10 个，<code>-5 -1</code> = 最后 5 个</li>
</ul>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：实时排名，O(log N) 的更新和查询；天然支持分页和范围查询</li>
<li><strong>代价</strong>：全量数据在内存中，百万级用户的排行榜约占几十 MB；不支持复杂的多条件排序</li>
<li><strong>不适合</strong>：需要按多个维度联合排序的场景（如&quot;先按等级排，等级相同按经验排&quot;），需要额外设计 Score 编码（如将两个维度编码到一个 double 中）</li>
</ul>
<hr>
<h1>用例六：延时队列</h1>
<h2 id="业务问题">业务问题</h2>
<p>订单 30 分钟未支付自动取消、邮件定时发送、定时任务调度等——需要在未来某个时间点触发某个操作。</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>Redis ZSet</th>
<th>RabbitMQ 延时插件</th>
<th>数据库轮询</th>
<th>时间轮 (HashedWheelTimer)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>精度</strong></td>
<td>秒级</td>
<td>秒级</td>
<td>取决于轮询间隔</td>
<td>毫秒级</td>
</tr>
<tr>
<td><strong>可靠性</strong></td>
<td>需要额外保证</td>
<td>高（消息确认机制）</td>
<td>高</td>
<td>进程内，宕机丢失</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>低</td>
<td>中（需要 MQ 基础设施）</td>
<td>低</td>
<td>低</td>
</tr>
<tr>
<td><strong>吞吐量</strong></td>
<td>高</td>
<td>高</td>
<td>低</td>
<td>高</td>
</tr>
</tbody>
</table>
<h2 id="设计方案">设计方案</h2>
<p>核心思想：<strong>将消息的到期时间戳作为 ZSet 的 Score</strong>，Worker 定期查询 Score ≤ 当前时间的消息并处理。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Producer as 生产者
    participant Redis as Redis ZSet
    participant Worker as Worker 消费者

    Producer-&gt;&gt;Redis: ZADD delayed_queue:order_timeout&lt;br/&gt;1678886700 &#x27;&#123;&quot;order_id&quot;:&quot;123&quot;,&quot;action&quot;:&quot;cancel&quot;&#125;&#x27;
    
    Note over Redis: Score = 到期时间戳&lt;br/&gt;Member = 消息体 (JSON)

    loop 每秒轮询
        Worker-&gt;&gt;Redis: ZRANGEBYSCORE delayed_queue:order_timeout&lt;br/&gt;0 &#123;current_timestamp&#125; LIMIT 0 10
        alt 有到期消息
            Redis--&gt;&gt;Worker: 返回到期消息列表
            Worker-&gt;&gt;Worker: 执行业务逻辑（取消订单）
            Worker-&gt;&gt;Redis: ZREM delayed_queue:order_timeout &#123;message&#125;
        else 无到期消息
            Redis--&gt;&gt;Worker: 空列表
            Worker-&gt;&gt;Worker: sleep(1)
        end
    end</code></pre>
<h3 id="核心命令">核心命令</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生产者：添加延时消息</span><br><span class="hljs-comment"># Score = 当前时间 + 延迟时间（如 30 分钟 = 1800 秒）</span><br>ZADD delayed_queue:order_timeout 1678886700 <span class="hljs-string">&#x27;&#123;&quot;order_id&quot;:&quot;12345&quot;,&quot;action&quot;:&quot;cancel&quot;&#125;&#x27;</span><br><br><span class="hljs-comment"># 消费者：查询到期消息（Score ≤ 当前时间，升序取最早到期的）</span><br>ZRANGEBYSCORE delayed_queue:order_timeout 0 1678886800 LIMIT 0 10<br><br><span class="hljs-comment"># 消费者：处理完成后移除（ZRANGEBYSCORE 不会自动移除元素！）</span><br>ZREM delayed_queue:order_timeout <span class="hljs-string">&#x27;&#123;&quot;order_id&quot;:&quot;12345&quot;,&quot;action&quot;:&quot;cancel&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure>
<p><strong>关键点</strong>：<code>ZRANGEBYSCORE</code> 只是查询，<strong>不会移除元素</strong>。必须通过 <code>ZREM</code> 显式移除已处理的消息。</p>
<h3 id="原子性保证：lua-脚本">原子性保证：Lua 脚本</h3>
<p>在多 Worker 场景下，&quot;查询&quot;和&quot;移除&quot;必须是原子操作，否则同一条消息可能被多个 Worker 重复处理。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 原子性地获取并移除一条到期消息</span><br><span class="hljs-keyword">local</span> expired = redis.call(<span class="hljs-string">&#x27;ZRANGEBYSCORE&#x27;</span>, KEYS[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, ARGV[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;LIMIT&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> #expired &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;ZREM&#x27;</span>, KEYS[<span class="hljs-number">1</span>], expired[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> expired[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<h3 id="消费者伪代码">消费者伪代码</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">lua_script = redis_client.register_script(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    local expired = redis.call(&#x27;ZRANGEBYSCORE&#x27;, KEYS[1], 0, ARGV[1], &#x27;LIMIT&#x27;, 0, 1)</span><br><span class="hljs-string">    if #expired &gt; 0 then</span><br><span class="hljs-string">        redis.call(&#x27;ZREM&#x27;, KEYS[1], expired[1])</span><br><span class="hljs-string">        return expired[1]</span><br><span class="hljs-string">    else</span><br><span class="hljs-string">        return nil</span><br><span class="hljs-string">    end</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    current_timestamp = get_current_unix_timestamp()<br>    message = lua_script(keys=[<span class="hljs-string">&#x27;delayed_queue:order_timeout&#x27;</span>], args=[current_timestamp])<br>    <span class="hljs-keyword">if</span> message:<br>        task_data = json.loads(message)<br>        process_message(task_data)  <span class="hljs-comment"># 执行业务逻辑（必须幂等）</span><br>    <span class="hljs-keyword">else</span>:<br>        time.sleep(<span class="hljs-number">1</span>)  <span class="hljs-comment"># 避免空轮询</span><br></code></pre></td></tr></table></figure>
<h3 id="设计要点">设计要点</h3>
<ol>
<li><strong>队列 Key 命名</strong>：<code>delayed_queue:{业务类型}</code>，如 <code>delayed_queue:order_timeout</code>、<code>delayed_queue:email_reminders</code></li>
<li><strong>Member 是消息体本身</strong>（JSON 字符串），而不是指向 Hash 的引用</li>
<li><strong>消息处理必须幂等</strong>：即使因故障重复处理，结果也应该一致</li>
<li><strong>批量消费时的分页</strong>：如果一次取多条，取完后以本批最大 Score 作为下一次查询的起始值</li>
</ol>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：实现简单，无需额外中间件；精度可达秒级；支持任意延迟时间</li>
<li><strong>代价</strong>：轮询有固有延迟（通常 1 秒）；消息可靠性不如专业 MQ（无 ACK 机制，需自行实现）；大量延时消息占用内存</li>
<li><strong>建议</strong>：轻量级延时任务用 Redis；对可靠性要求高的场景用 RabbitMQ/RocketMQ 的延时消息功能</li>
</ul>
<h3 id="🔑-模式提炼：score-即时间轴">🔑 模式提炼：Score 即时间轴</h3>
<p>回顾用例四的滑动窗口限流、用例五的排行榜、用例六的延时队列，它们用的都是 ZSet，但 Score 的含义不同：</p>
<table>
<thead>
<tr>
<th>用例</th>
<th>Score 的含义</th>
<th>Member 的含义</th>
<th>核心查询</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>排行榜</strong></td>
<td>分数/积分</td>
<td>玩家 ID</td>
<td><code>ZREVRANGE</code>（按分数从高到低）</td>
</tr>
<tr>
<td><strong>延时队列</strong></td>
<td>到期时间戳</td>
<td>消息体 JSON</td>
<td><code>ZRANGEBYSCORE 0 now</code>（到期的消息）</td>
</tr>
<tr>
<td><strong>滑动窗口限流</strong></td>
<td>请求时间戳</td>
<td>请求唯一标识</td>
<td><code>ZCARD</code>（窗口内请求数）</td>
</tr>
<tr>
<td><strong>时间线 Feed</strong></td>
<td>发布时间戳</td>
<td>帖子 ID</td>
<td><code>ZREVRANGE</code>（最新的帖子）</td>
</tr>
<tr>
<td><strong>优先级队列</strong></td>
<td>优先级数值</td>
<td>任务 ID</td>
<td><code>ZRANGEBYSCORE</code>（最高优先级）</td>
</tr>
</tbody>
</table>
<p><strong>模式公式</strong>：<code>ZADD {队列名} {时间戳或分数} {元素}</code>，然后用 <code>ZRANGEBYSCORE</code> 或 <code>ZREVRANGE</code> 做范围查询。</p>
<p><strong>核心洞察</strong>：ZSet 的本质是一条<strong>可查询的数轴</strong>。Score 可以是任何有序的数值——时间戳、分数、优先级、权重、距离。只要你的业务需要&quot;按某个数值排序并做范围查询&quot;，就应该想到 ZSet。</p>
<p><strong>迁移清单</strong>——把 Score 换成不同含义，就得到不同的系统：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Score</span> <span class="hljs-operator">=</span> 到期时间  → 延时队列、定时任务<br><span class="hljs-attribute">Score</span> <span class="hljs-operator">=</span> 积分     → 排行榜、热度排序<br><span class="hljs-attribute">Score</span> <span class="hljs-operator">=</span> 请求时间  → 滑动窗口限流<br><span class="hljs-attribute">Score</span> <span class="hljs-operator">=</span> 发布时间  → 时间线、最新动态<br><span class="hljs-attribute">Score</span> <span class="hljs-operator">=</span> 优先级   → 优先级队列<br><span class="hljs-attribute">Score</span> <span class="hljs-operator">=</span> 价格     → 价格区间筛选<br><span class="hljs-attribute">Score</span> <span class="hljs-operator">=</span> 距离     → 附近的人（GEO 底层就是这么做的）<br></code></pre></td></tr></table></figure>
<hr>
<h1>用例七：社交关系（关注/粉丝/共同好友）</h1>
<h2 id="业务问题">业务问题</h2>
<p>社交网络中的关注、粉丝、共同好友、推荐好友等功能，核心是<strong>集合的交集、并集、差集运算</strong>。</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<p>关系型数据库处理&quot;共同好友&quot;需要两次 JOIN 或子查询，性能随数据量增长急剧下降。Redis 的 Set 提供了 O(N) 的集合运算，且全在内存中完成。</p>
<h2 id="设计方案">设计方案</h2>
<pre><code class="hljs mermaid">flowchart TD
    subgraph &quot;用户 A 的关系&quot;
        A1[&quot;following:A = &#123;B, C, D&#125;&quot;]
        A2[&quot;followers:A = &#123;B, E&#125;&quot;]
    end
    
    subgraph &quot;用户 B 的关系&quot;
        B1[&quot;following:B = &#123;A, C, E&#125;&quot;]
        B2[&quot;followers:B = &#123;A, D&#125;&quot;]
    end
    
    A1 --- |&quot;SINTER following:A following:B&quot;| Common[&quot;共同关注: &#123;C&#125;&quot;]
    A1 --- |&quot;SDIFF following:B following:A&quot;| Recommend[&quot;推荐关注: &#123;E&#125;&lt;br/&gt;(B 关注了但 A 没关注)&quot;]</code></pre>
<h3 id="数据结构">数据结构</h3>
<p>每个用户维护两个 Set：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 用户的关注列表</span><br><span class="hljs-comment"># Key: following:&#123;user_id&#125;，Member: 被关注用户的 ID</span><br><br><span class="hljs-comment"># 用户的粉丝列表</span><br><span class="hljs-comment"># Key: followers:&#123;user_id&#125;，Member: 粉丝用户的 ID</span><br></code></pre></td></tr></table></figure>
<h3 id="核心操作">核心操作</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># === 关注操作（双向写入） ===</span><br>SADD following:A B      <span class="hljs-comment"># A 的关注列表加入 B</span><br>SADD followers:B A      <span class="hljs-comment"># B 的粉丝列表加入 A</span><br><br><span class="hljs-comment"># === 取消关注 ===</span><br>SREM following:A B<br>SREM followers:B A<br><br><span class="hljs-comment"># === 查询操作 ===</span><br>SMEMBERS following:A          <span class="hljs-comment"># A 的关注列表</span><br>SCARD followers:A             <span class="hljs-comment"># A 的粉丝数</span><br>SISMEMBER following:A B       <span class="hljs-comment"># A 是否关注了 B？返回 1 或 0</span><br><br><span class="hljs-comment"># === 集合运算 ===</span><br>SINTER following:A following:B    <span class="hljs-comment"># A 和 B 的共同关注</span><br>SINTER followers:A followers:B    <span class="hljs-comment"># A 和 B 的共同粉丝</span><br>SDIFF following:B following:A     <span class="hljs-comment"># 推荐关注：B 关注了但 A 没关注的人</span><br>SINTER following:A followers:A    <span class="hljs-comment"># A 的互相关注（好友）</span><br></code></pre></td></tr></table></figure>
<h3 id="互相关注判断优化">互相关注判断优化</h3>
<p>判断两个用户是否互相关注，可以维护一个额外的&quot;好友&quot;Set：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># A 关注 B 时，检查 B 是否已关注 A</span><br>SISMEMBER following:B A<br><span class="hljs-comment"># 如果返回 1，说明互相关注，加入好友列表</span><br>SADD friends:A B<br>SADD friends:B A<br></code></pre></td></tr></table></figure>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：集合运算是 Redis 的原生能力，性能极高；<code>SISMEMBER</code> O(1) 判断关系</li>
<li><strong>代价</strong>：大 V 用户的粉丝列表可能有千万级成员，单个 Set 过大会影响性能和内存；双向写入需要保证一致性</li>
<li><strong>缓解</strong>：大 V 粉丝列表可以只存计数，不存完整列表；使用 Pipeline 或 Lua 脚本保证双向写入的原子性</li>
<li><strong>不适合</strong>：需要复杂查询的关系（如&quot;关注了 A 且同时关注了 B 的用户中，最近 7 天活跃的&quot;），应使用图数据库（如 Neo4j）</li>
</ul>
<h3 id="🔑-模式提炼：双向关系-集合运算">🔑 模式提炼：双向关系 + 集合运算</h3>
<p>社交关系的核心不是&quot;关注&quot;这个动作，而是**“一个关系写两个 Set，然后用集合运算回答所有关系问题”**。这个模式可以迁移到任何存在双向关系的场景。</p>
<p><strong>模式公式</strong>：</p>
<ul>
<li>建立关系：<code>SADD {关系}:{主体} {客体}</code> + <code>SADD {反向关系}:{客体} {主体}</code></li>
<li>查询关系：<code>SINTER</code> / <code>SUNION</code> / <code>SDIFF</code></li>
</ul>
<table>
<thead>
<tr>
<th>场景</th>
<th>Set A</th>
<th>Set B</th>
<th>SINTER</th>
<th>SDIFF</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>社交关注</strong></td>
<td><code>following:A</code></td>
<td><code>following:B</code></td>
<td>共同关注</td>
<td>推荐关注</td>
</tr>
<tr>
<td><strong>标签系统</strong></td>
<td><code>tag:java的文章</code></td>
<td><code>tag:redis的文章</code></td>
<td>同时有两个标签的文章</td>
<td>只有 java 没有 redis 的文章</td>
</tr>
<tr>
<td><strong>权限系统</strong></td>
<td><code>role:admin的权限</code></td>
<td><code>role:editor的权限</code></td>
<td>两个角色共有的权限</td>
<td>admin 独有的权限</td>
</tr>
<tr>
<td><strong>商品属性</strong></td>
<td><code>brand:nike的商品</code></td>
<td><code>color:red的商品</code></td>
<td>红色的 Nike 商品</td>
<td>Nike 非红色商品</td>
</tr>
<tr>
<td><strong>课程选修</strong></td>
<td><code>student:A的课程</code></td>
<td><code>student:B的课程</code></td>
<td>共同选修的课程</td>
<td>A 选了 B 没选的课程</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：当你看到&quot;共同的 XX&quot;、“推荐 XX”、&quot;互相 XX&quot;这类需求时，本质上都是集合的交集、差集运算。<strong>一个关系建两个 Set，三种运算回答所有问题</strong>。</p>
<p><strong>注意边界</strong>：当单个 Set 的成员数超过万级时（如大 V 的粉丝列表），<code>SINTER</code>/<code>SDIFF</code> 的 O(N) 复杂度会成为瓶颈。此时应考虑：只存计数不存完整列表，或将大 Set 拆分到多个 Key。</p>
<hr>
<h1>用例八：二级评论系统</h1>
<h2 id="业务问题">业务问题</h2>
<p>文章/帖子下的评论系统，支持一级评论和对评论的回复（二级评论），需要按时间排序和分页。</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<p>评论系统的读远多于写，且需要按时间排序和分页——这正是 ZSet 的强项。Redis 可以作为评论系统的读缓存层，配合数据库做持久化。</p>
<h2 id="设计方案">设计方案</h2>
<h3 id="三层存储设计">三层存储设计</h3>
<pre><code class="hljs mermaid">flowchart TD
    subgraph &quot;数据模型&quot;
        H1[&quot;Hash: comment:1001&lt;br/&gt;content, user_id, post_id,&lt;br/&gt;parent_id=0, timestamp, status&quot;]
        H2[&quot;Hash: comment:1002&lt;br/&gt;content, user_id, post_id,&lt;br/&gt;parent_id=1001, timestamp, status&quot;]
        
        Z1[&quot;ZSet: post:123:comments&lt;br/&gt;member=1001, score=timestamp&quot;]
        Z2[&quot;ZSet: comment:1001:replies&lt;br/&gt;member=1002, score=timestamp&quot;]
    end
    
    Z1 --&gt;|&quot;ZREVRANGE&quot;| H1
    Z2 --&gt;|&quot;ZREVRANGE&quot;| H2
    H2 --&gt;|&quot;parent_id&quot;| H1</code></pre>
<ol>
<li><strong>评论内容</strong>（Hash）：每条评论一个 Hash，存储完整信息</li>
<li><strong>文章的一级评论列表</strong>（ZSet）：Score 为时间戳，Member 为评论 ID</li>
<li><strong>评论的回复列表</strong>（ZSet）：Score 为时间戳，Member 为回复 ID</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># === 评论内容 Hash ===</span><br><span class="hljs-comment"># Key: comment:&#123;comment_id&#125;</span><br>HSET comment:1001 content <span class="hljs-string">&quot;Great article!&quot;</span> user_id <span class="hljs-string">&quot;user_a&quot;</span> \<br>    post_id <span class="hljs-string">&quot;post_123&quot;</span> parent_id <span class="hljs-string">&quot;0&quot;</span> timestamp 1700000000 status <span class="hljs-string">&quot;active&quot;</span><br><br><span class="hljs-comment"># === 文章的一级评论列表 ZSet ===</span><br><span class="hljs-comment"># Key: post:&#123;post_id&#125;:comments</span><br>ZADD post:post_123:comments 1700000000 1001<br><br><span class="hljs-comment"># === 评论的回复列表 ZSet ===</span><br><span class="hljs-comment"># Key: comment:&#123;parent_id&#125;:replies</span><br>ZADD comment:1001:replies 1700000050 1002<br></code></pre></td></tr></table></figure>
<h3 id="核心操作">核心操作</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># === 发表一级评论 ===</span><br>INCR global:comment_id_counter  <span class="hljs-comment"># 生成唯一 ID，假设得到 1001</span><br>HSET comment:1001 content <span class="hljs-string">&quot;Great article!&quot;</span> user_id <span class="hljs-string">&quot;user_a&quot;</span> \<br>    post_id <span class="hljs-string">&quot;post_123&quot;</span> parent_id <span class="hljs-string">&quot;0&quot;</span> timestamp 1700000000 status <span class="hljs-string">&quot;active&quot;</span><br>ZADD post:post_123:comments 1700000000 1001<br><br><span class="hljs-comment"># === 发表二级评论（回复） ===</span><br>INCR global:comment_id_counter  <span class="hljs-comment"># 假设得到 1002</span><br>HSET comment:1002 content <span class="hljs-string">&quot;Thanks!&quot;</span> user_id <span class="hljs-string">&quot;user_b&quot;</span> \<br>    post_id <span class="hljs-string">&quot;post_123&quot;</span> parent_id <span class="hljs-string">&quot;1001&quot;</span> timestamp 1700000050 status <span class="hljs-string">&quot;active&quot;</span><br><span class="hljs-comment"># 注意：回复只加入父评论的 replies 列表，不加入文章的 comments 列表</span><br>ZADD comment:1001:replies 1700000050 1002<br><br><span class="hljs-comment"># === 读取文章评论（分页 + 回复） ===</span><br><span class="hljs-comment"># Step 1: 获取一级评论 ID（最新 10 条）</span><br>ZREVRANGE post:post_123:comments 0 9<br><br><span class="hljs-comment"># Step 2: 批量获取评论内容（使用 Pipeline 减少网络往返）</span><br>HGETALL comment:1001<br>HGETALL comment:1003<br><br><span class="hljs-comment"># Step 3: 获取每条评论的前 3 条回复</span><br>ZREVRANGE comment:1001:replies 0 2<br>HGETALL comment:1002<br><br><span class="hljs-comment"># === 逻辑删除（推荐） ===</span><br>HSET comment:1001 status <span class="hljs-string">&quot;deleted&quot;</span><br><span class="hljs-comment"># 读取时过滤 status=&quot;deleted&quot; 的评论</span><br><br><span class="hljs-comment"># === 物理删除（复杂，需要清理多处） ===</span><br>ZREM post:post_123:comments 1001    <span class="hljs-comment"># 从文章评论列表移除</span><br>DEL comment:1001:replies             <span class="hljs-comment"># 删除回复列表</span><br>DEL comment:1001                     <span class="hljs-comment"># 删除评论内容</span><br></code></pre></td></tr></table></figure>
<h3 id="读取流程">读取流程</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client
    participant App
    participant Redis

    Client-&gt;&gt;App: GET /post/123/comments?page=1
    App-&gt;&gt;Redis: ZREVRANGE post:123:comments 0 9
    Redis--&gt;&gt;App: [1001, 1003, 1005, ...]
    
    Note over App: 使用 Pipeline 批量获取
    
    App-&gt;&gt;Redis: Pipeline: HGETALL comment:1001,&lt;br/&gt;HGETALL comment:1003, ...
    Redis--&gt;&gt;App: 所有评论内容
    
    App-&gt;&gt;Redis: Pipeline: ZREVRANGE comment:1001:replies 0 2,&lt;br/&gt;ZREVRANGE comment:1003:replies 0 2, ...
    Redis--&gt;&gt;App: 所有回复 ID 列表
    
    App-&gt;&gt;Redis: Pipeline: HGETALL comment:&#123;reply_ids&#125;...
    Redis--&gt;&gt;App: 所有回复内容
    
    App--&gt;&gt;Client: 组装后的评论树</code></pre>
<p><strong>设计要点</strong>：回复只加入父评论的 <code>replies</code> 列表，不加入文章的 <code>comments</code> 列表——这是&quot;主表持有关联表主键控制权，从表通过 parent_id 寻找父节点&quot;的设计模式。使用 <strong>Pipeline</strong> 批量发送命令，将多次网络往返合并为一次。</p>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：读性能极高，天然支持按时间排序和分页</li>
<li><strong>代价</strong>：数据冗余（Hash + ZSet 双写）；不支持复杂查询（如&quot;搜索包含某关键词的评论&quot;）；需要配合数据库做持久化</li>
<li><strong>建议</strong>：Redis 作为读缓存层，数据库作为持久化层；写操作先写 DB 再同步到 Redis</li>
</ul>
<hr>
<h1>用例九：消息队列</h1>
<h2 id="业务问题">业务问题</h2>
<p>服务间异步通信、事件驱动架构、削峰填谷等场景需要消息队列。</p>
<h2 id="redis-提供了三种消息队列方案">Redis 提供了三种消息队列方案</h2>
<pre><code class="hljs mermaid">flowchart TD
    A[&quot;Redis 消息队列方案&quot;] --&gt; B[&quot;List&lt;br/&gt;LPUSH/BRPOP&quot;]
    A --&gt; C[&quot;Pub/Sub&lt;br/&gt;PUBLISH/SUBSCRIBE&quot;]
    A --&gt; D[&quot;Stream&lt;br/&gt;XADD/XREADGROUP&quot;]
    
    B --&gt; B1[&quot;✅ 简单可靠&lt;br/&gt;❌ 不支持多消费者组&lt;br/&gt;❌ 无 ACK 机制&quot;]
    C --&gt; C1[&quot;✅ 广播模式&lt;br/&gt;❌ 消息不持久化&lt;br/&gt;❌ 离线消费者丢消息&quot;]
    D --&gt; D1[&quot;✅ 消费者组&lt;br/&gt;✅ 消息持久化&lt;br/&gt;✅ ACK 机制&lt;br/&gt;✅ 最接近专业 MQ&quot;]</code></pre>
<h3 id="方案一：list-队列">方案一：List 队列</h3>
<p>最简单的消息队列，使用 List 的 LPUSH/BRPOP 实现。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生产者：推入消息</span><br>LPUSH queue:emails <span class="hljs-string">&#x27;&#123;&quot;to&quot;:&quot;user@example.com&quot;,&quot;subject&quot;:&quot;Welcome&quot;&#125;&#x27;</span><br><br><span class="hljs-comment"># 消费者：阻塞弹出（等待最多 30 秒）</span><br>BRPOP queue:emails 30<br><span class="hljs-comment"># 返回: 1) &quot;queue:emails&quot;  2) &#x27;&#123;&quot;to&quot;:&quot;user@example.com&quot;,&quot;subject&quot;:&quot;Welcome&quot;&#125;&#x27;</span><br></code></pre></td></tr></table></figure>
<p><strong>BRPOP vs RPOP</strong>：<code>BRPOP</code> 是阻塞版本，队列为空时会等待而非返回 nil，避免了空轮询消耗 CPU。</p>
<h3 id="方案二：pub-sub-发布订阅">方案二：Pub/Sub 发布订阅</h3>
<p>适合实时广播场景（如聊天室、实时通知），但<strong>消息不持久化</strong>。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 订阅者（先启动）</span><br>SUBSCRIBE channel:notifications<br><br><span class="hljs-comment"># 发布者</span><br>PUBLISH channel:notifications <span class="hljs-string">&#x27;&#123;&quot;type&quot;:&quot;new_order&quot;,&quot;order_id&quot;:&quot;123&quot;&#125;&#x27;</span><br><br><span class="hljs-comment"># 模式订阅（支持通配符）</span><br>PSUBSCRIBE channel:*<br></code></pre></td></tr></table></figure>
<p><strong>致命缺陷</strong>：如果订阅者不在线，消息会永久丢失。Pub/Sub 没有消息积压能力，不适合需要可靠投递的场景。</p>
<h3 id="方案三：stream-redis-5-0-推荐">方案三：Stream（Redis 5.0+，推荐）</h3>
<p>Stream 是最接近专业消息队列的方案，支持消费者组、消息确认、消息回溯。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Producer
    participant Stream as Redis Stream
    participant C1 as Consumer 1
    participant C2 as Consumer 2

    Producer-&gt;&gt;Stream: XADD mystream * key value
    Note over Stream: 消息 ID: 1678886400000-0
    
    C1-&gt;&gt;Stream: XREADGROUP GROUP mygroup consumer1&lt;br/&gt;COUNT 1 BLOCK 5000 STREAMS mystream &gt;
    Stream--&gt;&gt;C1: 消息分配给 Consumer 1
    
    C2-&gt;&gt;Stream: XREADGROUP GROUP mygroup consumer2&lt;br/&gt;COUNT 1 BLOCK 5000 STREAMS mystream &gt;
    Stream--&gt;&gt;C2: 下一条消息分配给 Consumer 2
    
    C1-&gt;&gt;Stream: XACK mystream mygroup 1678886400000-0
    Note over C1: 确认消息已处理</code></pre>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建消费者组（$ 表示从最新消息开始消费，MKSTREAM 自动创建 Stream）</span><br>XGROUP CREATE mystream mygroup $ MKSTREAM<br><br><span class="hljs-comment"># 生产者：添加消息（* 表示自动生成 ID，格式为 时间戳-序号）</span><br>XADD mystream * order_id 123 action <span class="hljs-string">&quot;process&quot;</span><br><span class="hljs-comment"># 返回: &quot;1678886400000-0&quot;</span><br><br><span class="hljs-comment"># 消费者：从消费者组读取（&gt; 表示读取未分配的新消息）</span><br>XREADGROUP GROUP mygroup consumer1 COUNT 1 BLOCK 5000 STREAMS mystream &gt;<br><br><span class="hljs-comment"># 确认消息已处理</span><br>XACK mystream mygroup <span class="hljs-string">&quot;1678886400000-0&quot;</span><br><br><span class="hljs-comment"># 查看未确认的消息（Pending 列表，用于监控和故障恢复）</span><br>XPENDING mystream mygroup<br><br><span class="hljs-comment"># 转移超时未确认的消息给其他消费者（故障转移，60000ms = 1分钟超时）</span><br>XCLAIM mystream mygroup consumer2 60000 <span class="hljs-string">&quot;1678886400000-0&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="三种方案对比">三种方案对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>List</th>
<th>Pub/Sub</th>
<th>Stream</th>
</tr>
</thead>
<tbody>
<tr>
<td>消息持久化</td>
<td>✅</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>消费者组</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>消息确认 (ACK)</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>阻塞读取</td>
<td>✅ (BRPOP)</td>
<td>✅ (SUBSCRIBE)</td>
<td>✅ (BLOCK)</td>
</tr>
<tr>
<td>消息回溯</td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
</tr>
<tr>
<td>广播</td>
<td>❌</td>
<td>✅</td>
<td>✅（多消费者组）</td>
</tr>
<tr>
<td>适用场景</td>
<td>简单任务队列</td>
<td>实时通知/广播</td>
<td>可靠消息队列</td>
</tr>
</tbody>
</table>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：无需额外中间件，Stream 功能已接近 Kafka/RabbitMQ 的基础能力</li>
<li><strong>代价</strong>：消息堆积受内存限制；不支持事务消息、延时消息等高级特性；集群模式下 Stream 不支持跨分片</li>
<li><strong>建议</strong>：轻量级异步任务用 Redis Stream；高可靠、高吞吐场景用 Kafka/RocketMQ</li>
</ul>
<h3 id="🔑-模式提炼：实体-索引分离">🔑 模式提炼：实体 + 索引分离</h3>
<p>回顾用例八（评论系统）和用例九（消息队列），它们都使用了同一个架构模式：<strong>Hash 存实体内容，ZSet/Set/List 存索引</strong>。这是 Redis 中最重要的复合数据建模模式。</p>
<p><strong>模式公式</strong>：</p>
<ul>
<li>实体存储：<code>HSET {实体类型}:{ID} field1 value1 field2 value2 ...</code></li>
<li>索引维护：<code>ZADD {父实体}:{父ID}:{子实体列表} {排序分数} {子实体ID}</code></li>
<li>读取流程：先查索引拿 ID 列表 → 再用 Pipeline 批量查实体内容</li>
</ul>
<pre><code class="hljs mermaid">flowchart LR
    subgraph &quot;通用模式&quot;
        Index[&quot;索引层&lt;br/&gt;ZSet/Set/List&lt;br/&gt;存 ID + 排序信息&quot;] --&gt;|&quot;Pipeline 批量查&quot;| Entity[&quot;实体层&lt;br/&gt;Hash&lt;br/&gt;存完整内容&quot;]
    end</code></pre>
<table>
<thead>
<tr>
<th>场景</th>
<th>实体 (Hash)</th>
<th>索引 (ZSet)</th>
<th>Score</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>评论系统</strong></td>
<td><code>comment:{id}</code> → 评论内容</td>
<td><code>post:{id}:comments</code> → 评论 ID 列表</td>
<td>时间戳</td>
</tr>
<tr>
<td><strong>商品列表</strong></td>
<td><code>product:{id}</code> → 商品详情</td>
<td><code>category:{id}:products</code> → 商品 ID 列表</td>
<td>销量/价格</td>
</tr>
<tr>
<td><strong>用户动态</strong></td>
<td><code>post:{id}</code> → 帖子内容</td>
<td><code>user:{id}:timeline</code> → 帖子 ID 列表</td>
<td>发布时间</td>
</tr>
<tr>
<td><strong>搜索缓存</strong></td>
<td><code>doc:{id}</code> → 文档内容</td>
<td><code>search:{keyword}:results</code> → 文档 ID 列表</td>
<td>相关度</td>
</tr>
<tr>
<td><strong>订单列表</strong></td>
<td><code>order:{id}</code> → 订单详情</td>
<td><code>user:{id}:orders</code> → 订单 ID 列表</td>
<td>下单时间</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：这个模式本质上是<strong>关系型数据库的&quot;主表 + 索引&quot;在 Redis 中的映射</strong>。Hash 相当于数据行，ZSet 相当于索引。区别在于：索引需要你手动维护（写入时双写），但读取性能远超数据库。</p>
<p><strong>关键技巧</strong>：</p>
<ol>
<li><strong>Pipeline 是必须的</strong>——先查索引拿到 N 个 ID，再用 Pipeline 一次性发 N 个 <code>HGETALL</code>，将 N 次网络往返压缩为 1 次</li>
<li><strong>索引和实体的一致性</strong>——写入时必须同时写 Hash 和 ZSet（用 Pipeline 或 Lua 保证）</li>
<li><strong>删除要清理两处</strong>——删实体时别忘了从索引中移除</li>
</ol>
<hr>
<h1>用例十：地理位置服务（附近的人）</h1>
<h2 id="业务问题">业务问题</h2>
<p>“附近的人”、“附近的餐厅”、“3 公里内的门店”——基于经纬度的距离计算和范围查询。</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<p>Redis 的 GEO 命令底层使用 <strong>GeoHash 编码 + Sorted Set</strong>，将二维坐标映射为一维分数，利用 ZSet 的范围查询能力实现地理搜索。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Redis GEO</th>
<th>MySQL 空间索引</th>
<th>ElasticSearch</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>性能</strong></td>
<td>极高（内存计算）</td>
<td>中等（磁盘 I/O）</td>
<td>中等</td>
</tr>
<tr>
<td><strong>功能</strong></td>
<td>距离计算、圆形范围搜索</td>
<td>完整空间查询（多边形等）</td>
<td>全文搜索 + 地理混合</td>
</tr>
<tr>
<td><strong>精度</strong></td>
<td>米级</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单的&quot;附近&quot;查询</td>
<td>复杂空间关系</td>
<td>搜索 + 地理混合查询</td>
</tr>
</tbody>
</table>
<h2 id="设计方案">设计方案</h2>
<pre><code class="hljs mermaid">flowchart LR
    subgraph &quot;GEO 底层原理&quot;
        A[&quot;经纬度 (lng, lat)&quot;] --&gt; B[&quot;GeoHash 编码&quot;]
        B --&gt; C[&quot;52位整数&quot;]
        C --&gt; D[&quot;作为 ZSet 的 Score 存储&quot;]
    end
    
    subgraph &quot;范围查询&quot;
        E[&quot;中心点 + 半径&quot;] --&gt; F[&quot;计算 GeoHash 范围&quot;]
        F --&gt; G[&quot;ZRANGEBYSCORE 范围查询&quot;]
        G --&gt; H[&quot;过滤 + 精确距离计算&quot;]
    end</code></pre>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加地理位置</span><br>GEOADD stores:city:hangzhou 120.1551 30.2741 <span class="hljs-string">&quot;store_001&quot;</span><br>GEOADD stores:city:hangzhou 120.1612 30.2590 <span class="hljs-string">&quot;store_002&quot;</span><br>GEOADD stores:city:hangzhou 120.2100 30.2100 <span class="hljs-string">&quot;store_003&quot;</span><br><br><span class="hljs-comment"># 计算两点距离（支持 m/km/mi/ft 单位）</span><br>GEODIST stores:city:hangzhou store_001 store_002 km<br><span class="hljs-comment"># 返回: &quot;1.8432&quot;</span><br><br><span class="hljs-comment"># 查询某点附近 5km 内的门店（Redis 6.2+ 推荐 GEOSEARCH）</span><br>GEOSEARCH stores:city:hangzhou \<br>    FROMLONLAT 120.1600 30.2700 \<br>    BYRADIUS 5 km \<br>    WITHCOORD WITHDIST COUNT 10 ASC<br><br><span class="hljs-comment"># 查询某个成员附近的其他成员</span><br>GEOSEARCH stores:city:hangzhou \<br>    FROMMEMBER store_001 \<br>    BYRADIUS 3 km \<br>    ASC COUNT 5<br><br><span class="hljs-comment"># 获取成员的经纬度</span><br>GEOPOS stores:city:hangzhou store_001<br><br><span class="hljs-comment"># 旧版命令（Redis &lt; 6.2）</span><br>GEORADIUS stores:city:hangzhou 120.1600 30.2700 5 km \<br>    WITHCOORD WITHDIST COUNT 10 ASC<br></code></pre></td></tr></table></figure>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：开箱即用，无需额外地理索引；性能极高（内存计算）；API 简洁</li>
<li><strong>代价</strong>：只支持圆形范围查询（不支持多边形围栏）；不支持复杂空间关系（如&quot;在某条路线上的&quot;）；数据量大时内存占用高</li>
<li><strong>不适合</strong>：需要多边形围栏、路径规划等复杂地理计算的场景，应使用 PostGIS 或 ElasticSearch</li>
</ul>
<hr>
<h1>用例十一：UV 统计（HyperLogLog）</h1>
<h2 id="业务问题">业务问题</h2>
<p>统计网站的独立访客数（UV）、独立 IP 数等，要求去重计数。如果用 Set 存储每个访客 ID，百万级 UV 需要几十 MB 内存。</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<p>HyperLogLog 是一种概率数据结构，用 <strong>固定 12 KB 内存</strong> 就能统计 2^64 个不同元素的基数，误差率仅 0.81%。</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>内存占用（100 万 UV）</th>
<th>精确度</th>
<th>支持合并</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Set</strong></td>
<td>~40 MB</td>
<td>精确</td>
<td>✅ (SUNION)</td>
</tr>
<tr>
<td><strong>Bitmap</strong></td>
<td>~125 KB（ID 为连续整数时）</td>
<td>精确</td>
<td>✅ (BITOP OR)</td>
</tr>
<tr>
<td><strong>HyperLogLog</strong></td>
<td><strong>12 KB</strong></td>
<td>误差 ≤ 0.81%</td>
<td>✅ (PFMERGE)</td>
</tr>
</tbody>
</table>
<h2 id="设计方案">设计方案</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 记录访客（重复添加不会增加计数）</span><br>PFADD uv:page:homepage:20250728 <span class="hljs-string">&quot;user_123&quot;</span><br>PFADD uv:page:homepage:20250728 <span class="hljs-string">&quot;user_456&quot;</span><br>PFADD uv:page:homepage:20250728 <span class="hljs-string">&quot;user_123&quot;</span>  <span class="hljs-comment"># 重复，不计</span><br><br><span class="hljs-comment"># 查询 UV</span><br>PFCOUNT uv:page:homepage:20250728<br><span class="hljs-comment"># 返回: (integer) 2</span><br><br><span class="hljs-comment"># 合并多天的 UV（去重后的总 UV，而非简单求和）</span><br>PFMERGE uv:page:homepage:week \<br>    uv:page:homepage:20250722 \<br>    uv:page:homepage:20250723 \<br>    uv:page:homepage:20250724 \<br>    uv:page:homepage:20250725 \<br>    uv:page:homepage:20250726 \<br>    uv:page:homepage:20250727 \<br>    uv:page:homepage:20250728<br><br>PFCOUNT uv:page:homepage:week<br><span class="hljs-comment"># 返回周 UV（已去重）</span><br></code></pre></td></tr></table></figure>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：极低内存占用（12 KB/Key，无论元素数量多少）；支持合并统计；O(1) 的添加和查询</li>
<li><strong>代价</strong>：有 0.81% 的误差；不能查询&quot;某个元素是否存在&quot;；不能获取元素列表</li>
<li><strong>适用</strong>：UV、独立 IP 等对精确度要求不高的大规模去重计数</li>
<li><strong>不适用</strong>：需要精确计数或需要知道具体元素的场景</li>
</ul>
<hr>
<h1>用例十二：布隆过滤器</h1>
<h2 id="业务问题">业务问题</h2>
<p>判断一个元素<strong>是否可能存在</strong>于一个大集合中。典型场景：缓存穿透防护、垃圾邮件过滤、推荐系统去重（“用户是否已经看过这篇文章”）。</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<p>Redis 4.0+ 通过 <strong>RedisBloom 模块</strong> 提供了布隆过滤器。也可以用 Bitmap 手动实现。</p>
<pre><code class="hljs mermaid">flowchart TD
    subgraph &quot;布隆过滤器原理&quot;
        A[&quot;元素 X&quot;] --&gt; B[&quot;Hash 函数 1 → 位置 3&quot;]
        A --&gt; C[&quot;Hash 函数 2 → 位置 7&quot;]
        A --&gt; D[&quot;Hash 函数 3 → 位置 11&quot;]
        B --&gt; E[&quot;位数组: 将位置 3 设为 1&quot;]
        C --&gt; F[&quot;位数组: 将位置 7 设为 1&quot;]
        D --&gt; G[&quot;位数组: 将位置 11 设为 1&quot;]
    end
    
    subgraph &quot;查询&quot;
        H[&quot;查询元素 Y&quot;] --&gt; I[&quot;计算 3 个 Hash 值&quot;]
        I --&gt; J&#123;&quot;所有对应位都是 1？&quot;&#125;
        J --&gt;|&quot;是&quot;| K[&quot;可能存在&lt;br/&gt;(有假阳性概率)&quot;]
        J --&gt;|&quot;否&quot;| L[&quot;一定不存在&lt;br/&gt;(100% 准确)&quot;]
    end</code></pre>
<p><strong>核心特性</strong>：</p>
<ul>
<li>说&quot;不存在&quot;→ <strong>一定不存在</strong>（零假阴性）</li>
<li>说&quot;存在&quot;→ <strong>可能存在</strong>（有假阳性概率，可通过参数控制）</li>
</ul>
<h2 id="设计方案">设计方案</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 RedisBloom 模块</span><br><span class="hljs-comment"># 创建布隆过滤器（预期 100 万元素，误判率 0.01%）</span><br>BF.RESERVE user_filter 0.0001 1000000<br><br><span class="hljs-comment"># 添加元素</span><br>BF.ADD user_filter <span class="hljs-string">&quot;user_123&quot;</span><br>BF.ADD user_filter <span class="hljs-string">&quot;user_456&quot;</span><br><br><span class="hljs-comment"># 查询元素是否存在</span><br>BF.EXISTS user_filter <span class="hljs-string">&quot;user_123&quot;</span><br><span class="hljs-comment"># 返回: (integer) 1（可能存在）</span><br><br>BF.EXISTS user_filter <span class="hljs-string">&quot;user_999&quot;</span><br><span class="hljs-comment"># 返回: (integer) 0（一定不存在）</span><br><br><span class="hljs-comment"># 批量操作</span><br>BF.MADD user_filter <span class="hljs-string">&quot;user_789&quot;</span> <span class="hljs-string">&quot;user_012&quot;</span><br>BF.MEXISTS user_filter <span class="hljs-string">&quot;user_789&quot;</span> <span class="hljs-string">&quot;user_999&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="缓存穿透防护实战">缓存穿透防护实战</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client
    participant App
    participant BloomFilter as 布隆过滤器
    participant Cache as Redis Cache
    participant DB

    Client-&gt;&gt;App: 查询 user_id=999999
    App-&gt;&gt;BloomFilter: BF.EXISTS user_filter 999999
    alt 布隆过滤器说&quot;不存在&quot;
        BloomFilter--&gt;&gt;App: 0（一定不存在）
        App--&gt;&gt;Client: 返回空（不查 DB，拦截穿透）
    else 布隆过滤器说&quot;可能存在&quot;
        BloomFilter--&gt;&gt;App: 1
        App-&gt;&gt;Cache: GET cache:user:999999
        alt 缓存命中
            Cache--&gt;&gt;App: 数据
        else 缓存未命中
            App-&gt;&gt;DB: SELECT ...
            DB--&gt;&gt;App: 数据或空
            App-&gt;&gt;Cache: SET cache:user:999999 ...
        end
        App--&gt;&gt;Client: 返回结果
    end</code></pre>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：极低内存占用（比 Set 小一个数量级）；O(k) 的查询（k 为哈希函数数量，通常 3-7）</li>
<li><strong>代价</strong>：有假阳性概率（可通过增大位数组和哈希函数数量降低）；<strong>不支持删除元素</strong>（删除会影响其他元素的判断，因为多个元素可能共享同一个位）</li>
<li><strong>变体</strong>：Cuckoo Filter（<code>CF.*</code> 命令）支持删除操作，但内存占用略高</li>
</ul>
<h3 id="🔑-模式提炼：概率换空间">🔑 模式提炼：概率换空间</h3>
<p>HyperLogLog 和布隆过滤器看似是两个独立的数据结构，但它们背后是同一个设计哲学：<strong>用可控的误差换取数量级的内存节省</strong>。</p>
<p><strong>模式公式</strong>：当精确方案的内存成本不可接受时，问自己——“我能容忍多大的误差？”</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>精确方案 (Set)</th>
<th>HyperLogLog</th>
<th>布隆过滤器</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>回答的问题</strong></td>
<td>“有哪些元素？有多少个？”</td>
<td>“大约有多少个不同元素？”</td>
<td>“这个元素是否可能存在？”</td>
</tr>
<tr>
<td><strong>100 万元素内存</strong></td>
<td>~40 MB</td>
<td><strong>12 KB</strong></td>
<td>~1.2 MB (0.1% 误判率)</td>
</tr>
<tr>
<td><strong>节省倍数</strong></td>
<td>基准</td>
<td><strong>3300 倍</strong></td>
<td><strong>33 倍</strong></td>
</tr>
<tr>
<td><strong>误差</strong></td>
<td>0</td>
<td>≤ 0.81%</td>
<td>可配置（越低越耗内存）</td>
</tr>
<tr>
<td><strong>能否枚举元素</strong></td>
<td>✅</td>
<td>❌</td>
<td>❌</td>
</tr>
<tr>
<td><strong>能否删除元素</strong></td>
<td>✅</td>
<td>❌</td>
<td>❌（Cuckoo Filter 可以）</td>
</tr>
</tbody>
</table>
<p><strong>决策树</strong>——什么时候用概率结构：</p>
<pre><code class="hljs mermaid">flowchart TD
    A[&quot;需要去重/计数&quot;] --&gt; B&#123;&quot;需要知道具体是哪些元素？&quot;&#125;
    B --&gt;|&quot;是&quot;| C[&quot;用 Set（精确）&quot;]
    B --&gt;|&quot;否&quot;| D&#123;&quot;需要知道精确数量？&quot;&#125;
    D --&gt;|&quot;是&quot;| C
    D --&gt;|&quot;否&quot;| E&#123;&quot;只需要判断存在性？&quot;&#125;
    E --&gt;|&quot;是&quot;| F[&quot;布隆过滤器&quot;]
    E --&gt;|&quot;否&quot;| G[&quot;HyperLogLog&quot;]</code></pre>
<p><strong>可迁移场景</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>概率结构</th>
<th>替代的精确方案</th>
<th>节省</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UV 统计</strong></td>
<td>HyperLogLog</td>
<td>Set 存所有用户 ID</td>
<td>3000x</td>
</tr>
<tr>
<td><strong>缓存穿透防护</strong></td>
<td>布隆过滤器</td>
<td>Set 存所有合法 ID</td>
<td>30x</td>
</tr>
<tr>
<td><strong>推荐去重</strong>（“用户看过这篇文章吗”）</td>
<td>布隆过滤器</td>
<td>Set 存用户已读列表</td>
<td>30x</td>
</tr>
<tr>
<td><strong>垃圾邮件过滤</strong></td>
<td>布隆过滤器</td>
<td>Set 存所有垃圾邮件特征</td>
<td>30x</td>
</tr>
<tr>
<td><strong>数据库行存在性预检</strong></td>
<td>布隆过滤器</td>
<td>每次查 DB</td>
<td>减少无效 I/O</td>
</tr>
</tbody>
</table>
<p><strong>核心洞察</strong>：在大规模系统中，&quot;精确&quot;往往是一种奢侈。当数据量达到百万、千万级时，先问自己：<strong>“我真的需要精确答案吗？”</strong> 如果 0.81% 的误差可以接受，你就能用 12 KB 替代 40 MB。</p>
<hr>
<h1>用例十三：分布式 ID 生成</h1>
<h2 id="业务问题">业务问题</h2>
<p>分布式系统中需要全局唯一、趋势递增的 ID，用于数据库主键、订单号等。</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<p>Redis 的 <code>INCR</code> 命令是原子操作，天然保证唯一性和严格递增性。</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>性能</th>
<th>趋势递增</th>
<th>全局唯一</th>
<th>依赖</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>UUID</strong></td>
<td>极高（本地生成）</td>
<td>❌ 无序</td>
<td>✅</td>
<td>无</td>
</tr>
<tr>
<td><strong>数据库自增</strong></td>
<td>低（磁盘 I/O）</td>
<td>✅</td>
<td>✅</td>
<td>DB</td>
</tr>
<tr>
<td><strong>Redis INCR</strong></td>
<td>高（内存操作）</td>
<td>✅</td>
<td>✅</td>
<td>Redis</td>
</tr>
<tr>
<td><strong>Snowflake</strong></td>
<td>极高（本地生成）</td>
<td>✅</td>
<td>✅</td>
<td>时钟同步</td>
</tr>
</tbody>
</table>
<h2 id="设计方案">设计方案</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 简单自增 ID</span><br>INCR global:order_id<br><span class="hljs-comment"># 返回: (integer) 10001</span><br><br><span class="hljs-comment"># 按天分段（便于按日期查询和归档）</span><br>INCR order_id:20250728<br><span class="hljs-comment"># 应用层组合为: 20250728-00001</span><br><br><span class="hljs-comment"># 批量获取（减少网络往返，应用层使用 10001-10100 这 100 个 ID）</span><br>INCRBY global:order_id 100<br><span class="hljs-comment"># 返回: (integer) 10100</span><br></code></pre></td></tr></table></figure>
<h3 id="带业务前缀的-id-生成-lua-脚本">带业务前缀的 ID 生成（Lua 脚本）</h3>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 生成带日期前缀的订单号</span><br><span class="hljs-keyword">local</span> date_key = <span class="hljs-string">&#x27;order_seq:&#x27;</span> .. ARGV[<span class="hljs-number">1</span>]  <span class="hljs-comment">-- ARGV[1] = &quot;20250728&quot;</span><br><span class="hljs-keyword">local</span> seq = redis.call(<span class="hljs-string">&#x27;INCR&#x27;</span>, date_key)<br><span class="hljs-keyword">if</span> seq == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;EXPIRE&#x27;</span>, date_key, <span class="hljs-number">86400</span> * <span class="hljs-number">2</span>)  <span class="hljs-comment">-- 首次创建时设置 2 天后过期</span><br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> seq<br><span class="hljs-comment">-- 应用层组合为: ORD-20250728-000001</span><br></code></pre></td></tr></table></figure>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：简单可靠，性能高（10 万+ QPS）；严格递增</li>
<li><strong>代价</strong>：依赖 Redis 可用性（Redis 宕机则无法生成 ID）；单点瓶颈（可通过批量获取缓解）；ID 连续可能暴露业务量</li>
<li><strong>建议</strong>：中小规模系统用 Redis INCR；大规模系统用 Snowflake 算法（无中心依赖，本地生成）</li>
</ul>
<hr>
<h1>用例十四：签到系统（Bitmap）</h1>
<h2 id="业务问题">业务问题</h2>
<p>用户每日签到、连续签到天数统计、月度签到日历等。</p>
<h2 id="为什么选-redis">为什么选 Redis</h2>
<p>Bitmap 用 1 bit 表示一天的签到状态，一个用户一年的签到数据只需 365 bits ≈ 46 bytes。百万用户一年的签到数据约 46 MB。</p>
<h2 id="设计方案">设计方案</h2>
<pre><code class="hljs mermaid">flowchart LR
    subgraph &quot;Bitmap: sign:user:123:202507&quot;
        direction LR
        B0[&quot;bit0=1&lt;br/&gt;7/1 ✅&quot;] 
        B1[&quot;bit1=1&lt;br/&gt;7/2 ✅&quot;]
        B2[&quot;bit2=0&lt;br/&gt;7/3 ❌&quot;]
        B3[&quot;bit3=1&lt;br/&gt;7/4 ✅&quot;]
        B4[&quot;...&quot;]
        B30[&quot;bit30=1&lt;br/&gt;7/31 ✅&quot;]
    end</code></pre>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 签到（7月28日 = 第 27 位，0-based）</span><br>SETBIT sign:user:123:202507 27 1<br><br><span class="hljs-comment"># 查询某天是否签到</span><br>GETBIT sign:user:123:202507 27<br><span class="hljs-comment"># 返回: (integer) 1</span><br><br><span class="hljs-comment"># 统计本月签到天数</span><br>BITCOUNT sign:user:123:202507<br><span class="hljs-comment"># 返回: (integer) 15</span><br><br><span class="hljs-comment"># 获取本月签到位图（用于计算连续签到天数）</span><br><span class="hljs-comment"># BITFIELD 可以一次性获取多个位的值</span><br>BITFIELD sign:user:123:202507 GET u31 0<br><span class="hljs-comment"># 返回一个整数，应用层通过位运算计算末尾连续 1 的个数</span><br><br><span class="hljs-comment"># === 全站签到统计 ===</span><br><span class="hljs-comment"># 每天一个 Bitmap，每个用户对应一个 bit 位（用户 ID 作为 offset）</span><br>SETBIT daily_sign:20250728 123 1  <span class="hljs-comment"># 用户 123 签到</span><br>SETBIT daily_sign:20250728 456 1  <span class="hljs-comment"># 用户 456 签到</span><br>BITCOUNT daily_sign:20250728      <span class="hljs-comment"># 当天签到总人数</span><br><br><span class="hljs-comment"># 统计连续 3 天都签到的用户（BITOP AND = 位与运算）</span><br>BITOP AND sign_3days daily_sign:20250726 daily_sign:20250727 daily_sign:20250728<br>BITCOUNT sign_3days  <span class="hljs-comment"># 连续 3 天签到的用户数</span><br></code></pre></td></tr></table></figure>
<h2 id="取舍分析">取舍分析</h2>
<ul>
<li><strong>优势</strong>：极低内存占用（1 bit/天/用户）；<code>BITCOUNT</code> 高效统计；<code>BITOP</code> 支持跨天聚合分析</li>
<li><strong>代价</strong>：只能存储 0/1 二值状态；用户 ID 作为 offset 时必须是非负整数（且最好连续，否则稀疏 ID 会浪费空间）</li>
<li><strong>适用</strong>：签到、在线状态、功能开关、A/B 测试分组等二值状态场景</li>
</ul>
<hr>
<h1>全景对比：Redis 用例选型决策</h1>
<h2 id="数据结构-用例映射总览">数据结构 → 用例映射总览</h2>
<pre><code class="hljs mermaid">mindmap
  root((Redis 用例全景))
    String
      缓存
      会话管理
      分布式锁
      计数器
      分布式 ID
    Hash
      对象缓存
      购物车
      评论内容存储
      令牌桶状态
    List
      简单消息队列
      最新动态流
      操作日志
    Set
      社交关系
      标签系统
      抽奖去重
    Sorted Set
      排行榜
      延时队列
      滑动窗口限流
      时间线
      评论排序列表
    HyperLogLog
      UV 统计
      独立 IP 计数
    Bitmap
      签到打卡
      在线状态
      布隆过滤器
    GEO
      附近的人
      门店搜索
    Stream
      可靠消息队列
      事件溯源</code></pre>
<h2 id="redis-vs-替代方案决策矩阵">Redis vs 替代方案决策矩阵</h2>
<table>
<thead>
<tr>
<th>场景</th>
<th>首选 Redis 的条件</th>
<th>考虑替代方案的条件</th>
<th>推荐替代方案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>缓存</strong></td>
<td>动态热点数据，多实例共享</td>
<td>极热点数据，单实例内使用</td>
<td>本地缓存 (Caffeine)</td>
</tr>
<tr>
<td><strong>分布式锁</strong></td>
<td>高性能互斥，容忍极端情况丢锁</td>
<td>强一致性要求，不容忍任何丢锁</td>
<td>ZooKeeper / etcd</td>
</tr>
<tr>
<td><strong>消息队列</strong></td>
<td>轻量级异步，消息量不大</td>
<td>高可靠、高吞吐、需要事务消息</td>
<td>Kafka / RocketMQ</td>
</tr>
<tr>
<td><strong>排行榜</strong></td>
<td>实时排名，单维度排序</td>
<td>复杂多维排序，全文搜索</td>
<td>ElasticSearch</td>
</tr>
<tr>
<td><strong>社交关系</strong></td>
<td>简单关系运算（共同好友等）</td>
<td>复杂图遍历（六度分隔等）</td>
<td>Neo4j / JanusGraph</td>
</tr>
<tr>
<td><strong>地理位置</strong></td>
<td>简单圆形范围查询</td>
<td>多边形围栏、路径规划</td>
<td>PostGIS / ElasticSearch</td>
</tr>
<tr>
<td><strong>计数/统计</strong></td>
<td>实时计数，允许宕机丢失</td>
<td>精确持久化计数（如余额）</td>
<td>关系型数据库</td>
</tr>
<tr>
<td><strong>全文搜索</strong></td>
<td>❌ 不适合</td>
<td>任何搜索场景</td>
<td>ElasticSearch / Solr</td>
</tr>
<tr>
<td><strong>ACID 事务</strong></td>
<td>❌ 不适合</td>
<td>需要跨表事务一致性</td>
<td>关系型数据库</td>
</tr>
</tbody>
</table>
<h2 id="redis-的通用局限性">Redis 的通用局限性</h2>
<p>在选择 Redis 方案时，始终需要考虑以下约束：</p>
<ol>
<li><strong>内存限制</strong>：所有数据在内存中，成本高于磁盘存储。需要评估数据量和增长趋势，设置 <code>maxmemory</code> 和淘汰策略。</li>
<li><strong>持久性风险</strong>：即使开启 RDB/AOF，极端情况下仍可能丢失少量数据（RDB 丢失最后一次快照后的数据，AOF 在 <code>everysec</code> 模式下最多丢 1 秒）。关键数据必须有数据库兜底。</li>
<li><strong>单线程模型</strong>：Redis 6.0 前命令执行是单线程的（6.0 后 I/O 多线程，但命令执行仍是单线程）。单个慢命令（如 <code>KEYS *</code>、大 Key 的 <code>HGETALL</code>、<code>SMEMBERS</code>）会阻塞所有请求。</li>
<li><strong>数据结构限制</strong>：不支持 JOIN、聚合、全文搜索等复杂查询。</li>
<li><strong>一致性模型</strong>：Redis 主从复制是异步的，主节点宕机可能丢失未同步到从节点的数据。</li>
</ol>
<h2 id="key-命名最佳实践">Key 命名最佳实践</h2>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs less">通用模式：&#123;业务域&#125;:&#123;实体类型&#125;:&#123;实体<span class="hljs-selector-tag">ID</span>&#125;:&#123;子资源&#125;<br><br>示例：<br>cache:user:123              → 用户缓存<br>session:abc123def456        → 会话<br>lock:<span class="hljs-attribute">order</span>:<span class="hljs-number">123</span>              → 分布式锁<br><span class="hljs-attribute">rate</span>:<span class="hljs-attribute">user</span>:<span class="hljs-number">123</span>               → 限流计数<br><span class="hljs-attribute">leaderboard</span>:global          → 全局排行榜<br><span class="hljs-attribute">leaderboard</span>:<span class="hljs-attribute">daily</span>:<span class="hljs-number">20250728</span>  → 日排行榜<br><span class="hljs-attribute">delayed_queue</span>:order_timeout → 延时队列<br><span class="hljs-attribute">following</span>:user_a            → 关注列表<br><span class="hljs-attribute">followers</span>:user_a            → 粉丝列表<br><span class="hljs-attribute">friends</span>:user_a              → 好友列表（互相关注）<br><span class="hljs-attribute">post</span>:<span class="hljs-number">123</span>:comments           → 文章一级评论列表<br><span class="hljs-attribute">comment</span>:<span class="hljs-number">1001</span>:replies        → 评论回复列表<br><span class="hljs-attribute">comment</span>:<span class="hljs-number">1001</span>                → 评论内容<br><span class="hljs-attribute">uv</span>:<span class="hljs-attribute">page</span>:<span class="hljs-attribute">homepage</span>:<span class="hljs-number">20250728</span>   → UV 统计<br><span class="hljs-attribute">sign</span>:<span class="hljs-attribute">user</span>:<span class="hljs-number">123</span>:<span class="hljs-number">202507</span>        → 签到记录<br><span class="hljs-attribute">stores</span>:<span class="hljs-attribute">city</span>:hangzhou        → 门店地理位置<br>mystream                    → 消息流<br></code></pre></td></tr></table></figure>
<p><strong>命名规则</strong>：</p>
<ul>
<li>使用冒号 <code>:</code> 分隔层级（Redis 社区惯例）</li>
<li>使用小写字母和下划线</li>
<li>Key 名要有业务含义，避免无意义缩写</li>
<li>控制 Key 长度（过长浪费内存和网络带宽，过短难以理解）</li>
</ul>
<h2 id="通用设计原则">通用设计原则</h2>
<ol>
<li><strong>先抽象操作，再选数据结构</strong>：不要先想&quot;我要用 Redis 的什么命令&quot;，而是先想&quot;我的业务本质上是什么操作&quot;——排序？去重？计数？集合运算？</li>
<li><strong>Redis 是加速层，不是持久层</strong>：除非数据丢失完全可以接受（如缓存、限流计数），否则 Redis 应该配合数据库使用。</li>
<li><strong>避免大 Key</strong>：单个 Key 的 Value 不要超过 10 MB。大 Set/ZSet/Hash 考虑分片（如按用户 ID 取模分到多个 Key）。</li>
<li><strong>善用 Pipeline 和 Lua</strong>：Pipeline 减少网络往返（批量读取），Lua 脚本保证多命令的原子性（如&quot;查询+删除&quot;、“比较+设置”）。</li>
<li><strong>设置 TTL</strong>：所有缓存类 Key 都应该有过期时间，防止内存泄漏。业务数据的 Key 也应该有合理的过期策略。</li>
<li><strong>监控和告警</strong>：关注 <code>used_memory</code>（内存使用率）、<code>keyspace_hits/misses</code>（缓存命中率）、<code>slowlog</code>（慢查询日志）、<code>connected_clients</code>（连接数）。</li>
</ol>
<hr>
<h1>模式速查表：从问题到方案的快速映射</h1>
<p>读完全文，你应该能记住这张表。遇到任何新问题时，先在左列找到匹配的&quot;问题特征&quot;，右列就是你的起点方案。</p>
<h2 id="听到什么关键词-想到什么模式">听到什么关键词 → 想到什么模式</h2>
<table>
<thead>
<tr>
<th>你听到的需求关键词</th>
<th>对应模式</th>
<th>Redis 方案</th>
<th>一句话口诀</th>
</tr>
</thead>
<tbody>
<tr>
<td>“缓存”、“加速”、“热点”</td>
<td>KV + TTL</td>
<td><code>SET key data EX ttl</code></td>
<td>有生命周期的状态 = String + TTL</td>
</tr>
<tr>
<td>“Session”、“验证码”、“临时令牌”</td>
<td>KV + TTL</td>
<td><code>SET key data EX ttl</code></td>
<td>同上，换个 Key 和 TTL</td>
</tr>
<tr>
<td>“锁”、“互斥”、“只能一个”、“幂等”</td>
<td>原子占位</td>
<td><code>SET key uuid NX EX ttl</code></td>
<td>谁先到谁占坑</td>
</tr>
<tr>
<td>“排行榜”、“Top N”、“排名”</td>
<td>Score 即时间轴</td>
<td><code>ZADD</code> + <code>ZREVRANGE</code></td>
<td>Score = 分数，ZSet = 数轴</td>
</tr>
<tr>
<td>“延时”、“定时”、“30分钟后”</td>
<td>Score 即时间轴</td>
<td><code>ZADD</code> + <code>ZRANGEBYSCORE</code></td>
<td>Score = 到期时间戳</td>
</tr>
<tr>
<td>“限流”、“频率控制”、“滑动窗口”</td>
<td>Score 即时间轴 + Lua</td>
<td><code>ZADD</code> + <code>ZCARD</code> + Lua</td>
<td>Score = 请求时间戳</td>
</tr>
<tr>
<td>“共同好友”、“推荐”、“交集”</td>
<td>双向关系 + 集合运算</td>
<td><code>SADD</code> + <code>SINTER</code>/<code>SDIFF</code></td>
<td>一个关系两个 Set</td>
</tr>
<tr>
<td>“评论列表”、“商品列表”、“动态流”</td>
<td>实体 + 索引分离</td>
<td>Hash + ZSet + Pipeline</td>
<td>Hash 存内容，ZSet 存索引</td>
</tr>
<tr>
<td>“UV”、“独立访客”、“去重计数”</td>
<td>概率换空间</td>
<td><code>PFADD</code> + <code>PFCOUNT</code></td>
<td>12 KB 统计 2^64 个元素</td>
</tr>
<tr>
<td>“是否存在”、“穿透防护”、“预检”</td>
<td>概率换空间</td>
<td><code>BF.ADD</code> + <code>BF.EXISTS</code></td>
<td>说不在就一定不在</td>
</tr>
<tr>
<td>“消息队列”、“异步”、“事件”</td>
<td>生产者-消费者</td>
<td>Stream <code>XADD</code>/<code>XREADGROUP</code></td>
<td>轻量级用 Redis，重量级用 Kafka</td>
</tr>
<tr>
<td>“附近的人”、“距离”、“范围搜索”</td>
<td>Score 即时间轴（GEO 变体）</td>
<td><code>GEOADD</code> + <code>GEOSEARCH</code></td>
<td>GEO 底层就是 ZSet</td>
</tr>
<tr>
<td>“签到”、“在线状态”、“开关”</td>
<td>Bitmap 二值状态</td>
<td><code>SETBIT</code> + <code>BITCOUNT</code></td>
<td>1 bit 表示一个布尔值</td>
</tr>
<tr>
<td>“全局 ID”、“自增序号”</td>
<td>原子递增</td>
<td><code>INCR</code> / <code>INCRBY</code></td>
<td>原子操作天然唯一</td>
</tr>
</tbody>
</table>
<h2 id="七大模式的组合使用">七大模式的组合使用</h2>
<p>实际系统中，一个功能往往是多个模式的组合：</p>
<pre><code class="hljs mermaid">flowchart TD
    subgraph &quot;电商秒杀系统&quot;
        A[&quot;模式②原子占位&lt;br/&gt;SET NX 抢购资格&quot;] --&gt; B[&quot;模式⑦Lua原子胶水&lt;br/&gt;扣减库存&quot;]
        B --&gt; C[&quot;模式③Score时间轴&lt;br/&gt;延时队列：未支付自动取消&quot;]
        C --&gt; D[&quot;模式①KV+TTL&lt;br/&gt;订单缓存&quot;]
    end
    
    subgraph &quot;社交 Feed 系统&quot;
        E[&quot;模式④双Set集合运算&lt;br/&gt;关注/粉丝关系&quot;] --&gt; F[&quot;模式⑤实体+索引分离&lt;br/&gt;帖子内容+时间线索引&quot;]
        F --&gt; G[&quot;模式③Score时间轴&lt;br/&gt;按时间排序的 Feed&quot;]
        G --&gt; H[&quot;模式⑥概率换空间&lt;br/&gt;布隆过滤器去重已读&quot;]
    end</code></pre>
<blockquote>
<p><strong>最后的建议</strong>：不要试图记住 14 个用例的所有细节。记住<strong>七个模式</strong>和<strong>这张速查表</strong>就够了。遇到新问题时，先识别它属于哪个模式，再查对应的命令和 Key 设计——这就是从&quot;一个个问题&quot;到&quot;一类类问题&quot;的思维跃迁。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2025/07/28/Redis-%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E4%BE%8B/">https://magicliang.github.io/2025/07/28/Redis-%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E4%BE%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a><a class="post-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-43.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/07/29/%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" title="缓存系统设计——从穿透到雪崩的完整攻略"><img class="cover" src="/img/wall-paper-175.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-29</div><div class="info-item-2">缓存系统设计——从穿透到雪崩的完整攻略</div></div><div class="info-2"><div class="info-item-1">缓存是提升系统性能的第一利器，但也是引发故障的第一杀手。缓存穿透、缓存击穿、缓存雪崩——这三大问题几乎是每个后端工程师都会遇到的挑战。本文将系统性地剖析缓存系统的设计原则、经典问题及其解决方案，从单机缓存到分布式缓存，从理论到生产实践。  Part 1: 缓存的基本原理 为什么需要缓存    存储介质 访问延迟 吞吐量 成本     CPU L1 Cache ~1 ns — 极高   CPU L3 Cache ~10 ns — 高   内存（RAM） ~100 ns ~10 GB/s 中   SSD ~100 μs ~500 MB/s 低   HDD ~10 ms ~100 MB/s 极低   网络（同机房） ~500 μs — —   网络（跨机房） ~50 ms — —    内存访问比 SSD 快 1000 倍，比 HDD 快 100,000 倍。缓存的本质就是用更快的存储介质保存热点数据的副本。 缓存的命中率 命中率 = 命中次数 / (命中次数 + 未命中次数)    命中率 效果 说明     &lt; 50% 差 缓存几乎没有意义   50-80% 一般 有一定效果...</div></div></div></a><a class="pagination-related" href="/2019/10/30/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81-%E5%93%A8%E5%85%B5-Sentinel/" title="Redis 笔记之十-哨兵 Sentinel"><img class="cover" src="/img/wall-paper-84.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-30</div><div class="info-item-2">Redis 笔记之十-哨兵 Sentinel</div></div><div class="info-2"><div class="info-item-1">Redis 有若干套高可用实现方案。2.8 开始提供哨兵功能（不要使用更低版本的哨兵，可能有 bug）。 基本概念  主从复制模式的问题 Redis 天然就带有主从复制的功能，但主从复制有若干缺点：  需要手工干预，缺乏自动 FO 机制-分布式高可用问题。 单机的写能力有限-分布式容量问题。 单机的存储能力有限-分布式容量问题。  一个经典的高可用场景 当一个主从集群的 主节点 失效的时候，经典的恢复步骤如下：  主节点失效。 选出新的从节点，slaveof no one。 先更新应用方的连接。 再让其他从节点换主。 再把恢复好的主节点作为新的从节点复制新的主节点。  3 和 4 的步骤可以互换。这种需要手工介入的运行机制不能被当作高可用的。而 sentinel 的作用是把这些经典步骤从手工实现为自动。 Sentinel 的高可用性 Sentinel 方案是在原生的 Master-Slave 集群之外加上一个 Sentinel 集群。 每个 Sentinel 节点会监控其他 Sentinel 节点和所有 Redis 节点。任何一个不可达的节点，它都会将其做下线标识。 如果标识的是...</div></div></div></a><a class="pagination-related" href="/2019/11/09/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80-%E9%9B%86%E7%BE%A4-Cluster/" title="Redis 笔记之十一-集群 Cluster"><img class="cover" src="/img/wall-paper-176.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-09</div><div class="info-item-2">Redis 笔记之十一-集群 Cluster</div></div><div class="info-2"><div class="info-item-1">背景 在 Redis Cluster 方案诞生以前，在 Redis 集群遇到单机资源和流量瓶颈时，有两种常见分布式解决方案：  客户端方案：需要自己处理分区逻辑、路由、故障转移（有时候 Routing、LB 和 Failover是同一个问题，都需要通过 routing 技术来切换流量的 endpoint）。 代理方案：减轻了客户端的职责和压力，架构上的负担过重。  Redis Cluster 的出现，极大地降低了架构师的负担，解放了生产力。 数据分布 数据分布理论 |分区方式|特点|代表产品|取舍逻辑| |:–:|:–:|:–:| |哈希分区| 离散度好 数据分布业务无关 无法顺序访问| KV型 Redis Cluster Cassandra Dynamo Elastic Search|如果需要平衡地存储大量数据而只有随机访问其中的若干条，则可以使用简单的哈希分区| |顺序分区|离散度易倾斜 数据分布业务相关 可顺序访问| 表型 Bigtable HBase Hypertable|如果需要存储大量数据且需要支持区间查找，则也需要使用简单的顺序分区，如果要解决负载均衡的问题可能需要...</div></div></div></a><a class="pagination-related" href="/2022/01/13/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%EF%BC%9A%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/" title="Redis 笔记之：内存调优"><img class="cover" src="/img/wall-paper-117.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-13</div><div class="info-item-2">Redis 笔记之：内存调优</div></div><div class="info-2"><div class="info-item-1">Redis 的 memory info Redis 的内存使用状况可以使用info memory来获取。 需要重点关注的值是 used_memory_rss（用于存储消耗的物理内存），used_memory（用于存储消耗的内存= 物理内存 + 硬盘），以及他们的比值mem_fragmentation_ratio（used_memory_rss/used_memory）。 used_memory_rss或者used_memory很高时，意味着当前的 Redis 实例正在蚕食系统中的内存/硬盘资源。 当这个mem_fragmentation_ratio大于 1 的时候，意味着用于存储消耗的物理内存超过了 Redis 自己掌控的内存值，也就意味着当前有些未能回收的内存泄漏或者碎片。 当这个mem_fragmentation_ratio小于 1 的时候，这意味着有一部分用于存储的内存，实际上是在使用虚拟内存中的 swap 空间，此时 Redis 的性能会非常差。 Redis 的内存轮廓 memory_used = 进程自身消耗的内存 + 存储对象的内存（大头） + buffer 内存 m...</div></div></div></a><a class="pagination-related" href="/2024/11/04/Redis-%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/" title="Redis 开发与运维"><img class="cover" src="/2024/11/04/Redis-%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-04</div><div class="info-item-2">Redis 开发与运维</div></div><div class="info-2"><div class="info-item-1">Redis 特性 Redis 高性能的原因 Redis 的读写性能达到 10w/s，主要基于以下原因：  数据主要放在内存中。 Redis 使用距离 OS “层次更近”的 C 语言实现。 Redis 使用单线程架构，没有很高的 lock contention。 IO 多路复用技术 Redis 的代码实现得优雅而兼顾性能  Redis 的数据结构 Redis 本身是 Remote Dictionary Server 的简称，其中，老的、常见的数据结构有：  字符串 哈希 列表 set（集合） zset（有序集合）  但后来追加了几种新颖的数据机构，包括：bitmap、hyperloglog，更后来更添加了 GEO 地理信息相关的工具。 基于这些数据结构，我们可以实现一些常见的功能：  键过期，可以用来实现缓存，进而实现分布式锁。 发布订阅功能，进而实现消息系统（TODO）。 Lua 脚本功能，可以实现自定义的 Redis 命令（TODO）。 实现简单的事务功能，能在一定程度上实现事务特性。 提供流水线功能，能够让客户端一次性把一批命令一次性上传到 Redis 里，能够合并 IO 并...</div></div></div></a><a class="pagination-related" href="/2020/07/12/%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95/" title="软件方法"><img class="cover" src="/2020/07/12/%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95/%E8%BD%AF%E4%BB%B6%E6%96%B9%E6%B3%95.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-12</div><div class="info-item-2">软件方法</div></div><div class="info-2"><div class="info-item-1">建模带来竞争优势。 前言  “唱曲的名家，唱到极快处，吐字依然干净利落”。 不能站在别人的肩膀上看得更远，只是摘抄别人的观点，无意义。要有足够的积累，和深度的思考。 涉众（stakeholder）往往会做而不会定义，把不同类型的涉众放在一起访谈时，只会剩下在场军衔最高那个人的意见。 需求变更的时候，要注意涉众利益角度分析。 项目的流程步骤：  寻找老大 揣摩愿景 业务建模 系统用例 需求规约 分析模型 设计开发   只有一个领域（核心域）的知识是系统能在市场上生存的理由。 拿来主义要摒除门户之见，不关注流派和风格，着力于细节和应用。  建模与 uml 利润 = 需求 - 设计 需求：提升销售 设计：降低开发维护成本 几种弊习：  从需求直接映射设计，会得到大量的重复代码。 从设计出发来定义需求，会得到一堆假的“需求”。  从涉众视角对系统功能分包会得到需求包。 子系统是基于内部视角根据系统部件的耦合和内聚情况进行切割。    需求 设计     卖的视角 做的视角   具体 抽象   产品当项目做 项目当产品做   设计源于需求，高于需求     建模工作流  业务建模：描述组织...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Redis 数据结构速查与设计思维框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">数据结构总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%80%9D%E7%BB%B4%E6%A1%86%E6%9E%B6%EF%BC%9A%E4%B8%89%E6%AD%A5%E6%98%A0%E5%B0%84%E6%B3%95"><span class="toc-number">1.2.</span> <span class="toc-text">设计思维框架：三步映射法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E5%A4%A7%E5%8F%AF%E8%BF%81%E7%A7%BB%E6%A8%A1%E5%BC%8F-%E5%85%88%E8%AE%B0%E4%BD%8F%E6%A8%A1%E5%BC%8F-%E5%86%8D%E7%9C%8B%E7%94%A8%E4%BE%8B"><span class="toc-number">1.3.</span> <span class="toc-text">七大可迁移模式（先记住模式，再看用例）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">用例一：缓存策略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">2.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.</span> <span class="toc-text">设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cache-aside-%E6%97%81%E8%B7%AF%E7%BC%93%E5%AD%98"><span class="toc-number">2.3.1.</span> <span class="toc-text">Cache-Aside（旁路缓存）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E5%BA%94%E5%AF%B9"><span class="toc-number">2.3.2.</span> <span class="toc-text">缓存三大问题及应对</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">2.4.</span> <span class="toc-text">取舍分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">用例二：分布式会话（Session）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">3.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">3.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">3.3.</span> <span class="toc-text">设计方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">3.4.</span> <span class="toc-text">取舍分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%91-%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9Akv-ttl-%E4%B8%87%E8%83%BD%E4%B8%B4%E6%97%B6%E7%8A%B6%E6%80%81"><span class="toc-number">3.4.1.</span> <span class="toc-text">🔑 模式提炼：KV + TTL 万能临时状态</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">用例三：分布式锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">4.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">4.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">4.3.</span> <span class="toc-text">设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%89%88%EF%BC%9Asetnx-%E8%BF%87%E6%9C%9F%E6%97%B6%E9%97%B4"><span class="toc-number">4.3.1.</span> <span class="toc-text">基础版：SETNX + 过期时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E9%98%B6%EF%BC%9Aredlock-%E7%AE%97%E6%B3%95"><span class="toc-number">4.3.2.</span> <span class="toc-text">进阶：Redlock 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E9%97%A8%E7%8B%97%E6%9C%BA%E5%88%B6-%E9%94%81%E7%BB%AD%E6%9C%9F"><span class="toc-number">4.3.3.</span> <span class="toc-text">看门狗机制（锁续期）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">4.4.</span> <span class="toc-text">取舍分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%91-%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E5%8E%9F%E5%AD%90%E5%8D%A0%E4%BD%8D-set-nx"><span class="toc-number">4.4.1.</span> <span class="toc-text">🔑 模式提炼：原子占位（SET NX）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">用例四：计数器与限流器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">业务问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">5.1.1.</span> <span class="toc-text">计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E6%B5%81%E5%99%A8"><span class="toc-number">5.1.2.</span> <span class="toc-text">限流器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">5.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">5.3.</span> <span class="toc-text">设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="toc-number">5.3.1.</span> <span class="toc-text">简单计数器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81"><span class="toc-number">5.3.2.</span> <span class="toc-text">固定窗口限流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%99%90%E6%B5%81-%E6%8E%A8%E8%8D%90"><span class="toc-number">5.3.3.</span> <span class="toc-text">滑动窗口限流（推荐）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A4%E7%89%8C%E6%A1%B6%E9%99%90%E6%B5%81"><span class="toc-number">5.3.4.</span> <span class="toc-text">令牌桶限流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">5.4.</span> <span class="toc-text">取舍分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">用例五：排行榜</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">6.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">6.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">6.3.</span> <span class="toc-text">设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4%E9%80%9F%E6%9F%A5"><span class="toc-number">6.3.1.</span> <span class="toc-text">核心命令速查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%B4%E5%BA%A6%E6%8E%92%E8%A1%8C%E6%A6%9C-%E6%97%A5%E6%A6%9C-%E5%91%A8%E6%A6%9C-%E6%9C%88%E6%A6%9C"><span class="toc-number">6.3.2.</span> <span class="toc-text">多维度排行榜（日榜&#x2F;周榜&#x2F;月榜）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zset-%E5%91%BD%E4%BB%A4%E5%88%86%E7%B1%BB%E8%AE%B0%E5%BF%86"><span class="toc-number">6.3.3.</span> <span class="toc-text">ZSet 命令分类记忆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#range-%E7%B4%A2%E5%BC%95%E8%A7%84%E5%88%99"><span class="toc-number">6.4.</span> <span class="toc-text">Range 索引规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">6.5.</span> <span class="toc-text">取舍分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">用例六：延时队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">7.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">7.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">7.3.</span> <span class="toc-text">设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%91%BD%E4%BB%A4"><span class="toc-number">7.3.1.</span> <span class="toc-text">核心命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E4%BF%9D%E8%AF%81%EF%BC%9Alua-%E8%84%9A%E6%9C%AC"><span class="toc-number">7.3.2.</span> <span class="toc-text">原子性保证：Lua 脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E8%80%85%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">7.3.3.</span> <span class="toc-text">消费者伪代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E8%A6%81%E7%82%B9"><span class="toc-number">7.3.4.</span> <span class="toc-text">设计要点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">7.4.</span> <span class="toc-text">取舍分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%91-%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9Ascore-%E5%8D%B3%E6%97%B6%E9%97%B4%E8%BD%B4"><span class="toc-number">7.4.1.</span> <span class="toc-text">🔑 模式提炼：Score 即时间轴</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">用例七：社交关系（关注&#x2F;粉丝&#x2F;共同好友）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">8.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">8.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">8.3.</span> <span class="toc-text">设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">8.3.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C"><span class="toc-number">8.3.2.</span> <span class="toc-text">核心操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E7%9B%B8%E5%85%B3%E6%B3%A8%E5%88%A4%E6%96%AD%E4%BC%98%E5%8C%96"><span class="toc-number">8.3.3.</span> <span class="toc-text">互相关注判断优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">8.4.</span> <span class="toc-text">取舍分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%91-%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E5%8F%8C%E5%90%91%E5%85%B3%E7%B3%BB-%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97"><span class="toc-number">8.4.1.</span> <span class="toc-text">🔑 模式提炼：双向关系 + 集合运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">用例八：二级评论系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">9.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">9.3.</span> <span class="toc-text">设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%B1%82%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">9.3.1.</span> <span class="toc-text">三层存储设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C"><span class="toc-number">9.3.2.</span> <span class="toc-text">核心操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%B5%81%E7%A8%8B"><span class="toc-number">9.3.3.</span> <span class="toc-text">读取流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">9.4.</span> <span class="toc-text">取舍分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">用例九：消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">10.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E6%8F%90%E4%BE%9B%E4%BA%86%E4%B8%89%E7%A7%8D%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%96%B9%E6%A1%88"><span class="toc-number">10.2.</span> <span class="toc-text">Redis 提供了三种消息队列方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9Alist-%E9%98%9F%E5%88%97"><span class="toc-number">10.2.1.</span> <span class="toc-text">方案一：List 队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9Apub-sub-%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85"><span class="toc-number">10.2.2.</span> <span class="toc-text">方案二：Pub&#x2F;Sub 发布订阅</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%89%EF%BC%9Astream-redis-5-0-%E6%8E%A8%E8%8D%90"><span class="toc-number">10.2.3.</span> <span class="toc-text">方案三：Stream（Redis 5.0+，推荐）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="toc-number">10.2.4.</span> <span class="toc-text">三种方案对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">10.3.</span> <span class="toc-text">取舍分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%91-%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E5%AE%9E%E4%BD%93-%E7%B4%A2%E5%BC%95%E5%88%86%E7%A6%BB"><span class="toc-number">10.3.1.</span> <span class="toc-text">🔑 模式提炼：实体 + 索引分离</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">用例十：地理位置服务（附近的人）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">11.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">11.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">11.3.</span> <span class="toc-text">设计方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">11.4.</span> <span class="toc-text">取舍分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">用例十一：UV 统计（HyperLogLog）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">12.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">12.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">12.3.</span> <span class="toc-text">设计方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">12.4.</span> <span class="toc-text">取舍分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">用例十二：布隆过滤器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">13.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">13.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">13.3.</span> <span class="toc-text">设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E9%98%B2%E6%8A%A4%E5%AE%9E%E6%88%98"><span class="toc-number">13.3.1.</span> <span class="toc-text">缓存穿透防护实战</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">13.4.</span> <span class="toc-text">取舍分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%91-%E6%A8%A1%E5%BC%8F%E6%8F%90%E7%82%BC%EF%BC%9A%E6%A6%82%E7%8E%87%E6%8D%A2%E7%A9%BA%E9%97%B4"><span class="toc-number">13.4.1.</span> <span class="toc-text">🔑 模式提炼：概率换空间</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">用例十三：分布式 ID 生成</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">14.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">14.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">14.3.</span> <span class="toc-text">设计方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%A6%E4%B8%9A%E5%8A%A1%E5%89%8D%E7%BC%80%E7%9A%84-id-%E7%94%9F%E6%88%90-lua-%E8%84%9A%E6%9C%AC"><span class="toc-number">14.3.1.</span> <span class="toc-text">带业务前缀的 ID 生成（Lua 脚本）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">14.4.</span> <span class="toc-text">取舍分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">用例十四：签到系统（Bitmap）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%97%AE%E9%A2%98"><span class="toc-number">15.1.</span> <span class="toc-text">业务问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89-redis"><span class="toc-number">15.2.</span> <span class="toc-text">为什么选 Redis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%96%B9%E6%A1%88"><span class="toc-number">15.3.</span> <span class="toc-text">设计方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E8%88%8D%E5%88%86%E6%9E%90"><span class="toc-number">15.4.</span> <span class="toc-text">取舍分析</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">全景对比：Redis 用例选型决策</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%94%A8%E4%BE%8B%E6%98%A0%E5%B0%84%E6%80%BB%E8%A7%88"><span class="toc-number">16.1.</span> <span class="toc-text">数据结构 → 用例映射总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-vs-%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%E5%86%B3%E7%AD%96%E7%9F%A9%E9%98%B5"><span class="toc-number">16.2.</span> <span class="toc-text">Redis vs 替代方案决策矩阵</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis-%E7%9A%84%E9%80%9A%E7%94%A8%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">16.3.</span> <span class="toc-text">Redis 的通用局限性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#key-%E5%91%BD%E5%90%8D%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">16.4.</span> <span class="toc-text">Key 命名最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">16.5.</span> <span class="toc-text">通用设计原则</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">模式速查表：从问题到方案的快速映射</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AC%E5%88%B0%E4%BB%80%E4%B9%88%E5%85%B3%E9%94%AE%E8%AF%8D-%E6%83%B3%E5%88%B0%E4%BB%80%E4%B9%88%E6%A8%A1%E5%BC%8F"><span class="toc-number">17.1.</span> <span class="toc-text">听到什么关键词 → 想到什么模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E5%A4%A7%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%84%E5%90%88%E4%BD%BF%E7%94%A8"><span class="toc-number">17.2.</span> <span class="toc-text">七大模式的组合使用</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>