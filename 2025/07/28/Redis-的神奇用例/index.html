<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Redis 的神奇用例 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="二级评论区 在现代 Web 应用中，评论系统是用户互动的核心功能之一。一个设计良好的评论系统不仅要能处理大量的读写请求，还需要支持诸如“回复评论”这样的嵌套结构（通常称为二级评论或评论回复）。Redis，作为一个高性能的内存数据库，凭借其丰富的数据结构，非常适合用来构建这样的系统。 本文将探讨如何利用 Redis 的 Hashes(哈希) 和 Sorted Sets(有序集合) 来设计和实现一个高">
<meta property="og:type" content="article">
<meta property="og:title" content="Redis 的神奇用例">
<meta property="og:url" content="https://magicliang.github.io/2025/07/28/Redis-%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E4%BE%8B/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="二级评论区 在现代 Web 应用中，评论系统是用户互动的核心功能之一。一个设计良好的评论系统不仅要能处理大量的读写请求，还需要支持诸如“回复评论”这样的嵌套结构（通常称为二级评论或评论回复）。Redis，作为一个高性能的内存数据库，凭借其丰富的数据结构，非常适合用来构建这样的系统。 本文将探讨如何利用 Redis 的 Hashes(哈希) 和 Sorted Sets(有序集合) 来设计和实现一个高">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-28.jpg">
<meta property="article:published_time" content="2025-07-28T12:48:32.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:33.089Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-28.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Redis 的神奇用例",
  "url": "https://magicliang.github.io/2025/07/28/Redis-%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E4%BE%8B/",
  "image": "https://magicliang.github.io/img/wall-paper-28.jpg",
  "datePublished": "2025-07-28T12:48:32.000Z",
  "dateModified": "2025-10-22T08:01:33.089Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2025/07/28/Redis-%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E4%BE%8B/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Redis 的神奇用例',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-28.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Redis 的神奇用例</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Redis 的神奇用例</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-28T12:48:32.000Z" title="Created 2025-07-28 20:48:32">2025-07-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:33.089Z" title="Updated 2025-10-22 16:01:33">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">4.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>16mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>二级评论区</h1>
<p>在现代 Web 应用中，评论系统是用户互动的核心功能之一。一个设计良好的评论系统不仅要能处理大量的读写请求，还需要支持诸如“回复评论”这样的嵌套结构（通常称为二级评论或评论回复）。Redis，作为一个高性能的内存数据库，凭借其丰富的数据结构，非常适合用来构建这样的系统。</p>
<p>本文将探讨如何利用 Redis 的 <strong>Hashes</strong>(哈希) 和 <strong>Sorted Sets</strong>(有序集合) 来设计和实现一个高效、可扩展的二级评论系统。</p>
<h2 id="核心设计理念">核心设计理念</h2>
<p>我们设计的核心思想可以概括为两点：</p>
<ol>
<li>实体存储: 使用 Redis Hash 来存储每条评论（包括一级评论和二级回复）的具体内容-不存博客的具体内容。</li>
<li>关系与排序: 使用 Redis Sorted Set 来维护评论之间的父子关系，并利用其天然的排序能力（基于 Score）来管理评论和回复的顺序（例如按时间倒序）。</li>
</ol>
<h2 id="数据结构详解">数据结构详解</h2>
<h3 id="存储评论-回复内容-hash">存储评论/回复内容 (Hash)</h3>
<p>我们将每条评论或回复的实际数据存储在一个 Hash 中。</p>
<ul>
<li>
<p><code>Key: comment:&#123;unique_comment_id&#125;</code> (例如 <code>comment:1001</code>, <code>comment:1002</code>)</p>
<ul>
<li><code>unique_comment_id</code>是一个全局唯一的标识符，可以通过<code>INCR</code>命令生成计数器或使用 UUID 等方式获得。</li>
</ul>
</li>
<li>
<p><strong>Fields and Values</strong>(字段和值):</p>
<ul>
<li><code>content</code>: 评论的文本内容。</li>
<li><code>user_id</code>: 发表评论的用户 ID。</li>
<li><code>post_id</code>: 评论所属的文章或帖子 ID（外键 id1）。</li>
<li><code>parent_id</code>: 父评论的 ID（外键 id2）。
<ul>
<li>对于一级评论，<code>parent_id</code>可以设为 “0” 或留空。</li>
<li>对于二级评论（回复），<code>parent_id</code>设为其所回复的那条评论的<code>unique_comment_id</code>。</li>
</ul>
</li>
<li><code>timestamp</code>: 发表时间戳 (Unix timestamp)，用于排序。</li>
<li><code>status</code>: 评论状态 (如 ‘active’, ‘deleted’)，方便实现逻辑删除。</li>
</ul>
</li>
</ul>
<p>优点: 通过唯一的<code>comment:&#123;id&#125; Key</code>，可以 O(1) 时间复杂度地获取单条评论的所有信息。</p>
<h3 id="存储文章下的一级评论列表-sorted-set">存储文章下的一级评论列表 (Sorted Set)</h3>
<p>对于每篇文章，我们使用一个 Sorted Set 来存储其下所有一级评论的 ID，并按时间排序。</p>
<ul>
<li>Key: <code>post:&#123;post_id&#125;:comments</code> (例如 <code>post:123:comments</code>)</li>
<li><strong>Member</strong>(成员): 一级评论的<code>unique_comment_id</code>(例如 1001)</li>
<li><strong>Score</strong>(分数): 该评论的<code>timestamp</code>。</li>
</ul>
<p><strong>优点</strong>: Sorted Set 保证了评论按时间排序，且可以方便地进行分页查询（如<code>ZREVRANGE ... LIMIT ...</code>）。</p>
<h3 id="存储评论下的回复列表-sorted-set">存储评论下的回复列表 (Sorted Set)</h3>
<p>类似地，对于每一条有回复的评论（通常是一级评论），我们使用一个 Sorted Set 来存储其直接回复的 ID，并按时间排序。</p>
<ul>
<li>Key:<code>comment:&#123;parent_comment_id&#125;:replies</code>(例如<code>comment:1001:replies</code>)<br>
<strong>Member</strong>(成员): 回复（二级评论）的<code>unique_comment_id</code>(例如 1002)<br>
<strong>Score</strong>(分数): 该回复的<code>timestamp</code>。</li>
</ul>
<p><strong>优点</strong>: 同样提供了对回复列表的快速排序和分页能力。</p>
<h2 id="核心操作流程">核心操作流程</h2>
<h3 id="发表一级评论">发表一级评论</h3>
<ol>
<li>生成唯一评论 ID (<code>new_comment_id</code>)。</li>
<li>使用<code>HSET comment:&#123;new_comment_id&#125;</code>存储评论内容，设置<code>parent_id</code>为 “0”。</li>
<li>使用<code>ZADD post:&#123;post_id&#125;:comments &#123;timestamp&#125; &#123;new_comment_id&#125;</code>将评论 ID 添加到文章的评论列表中。</li>
</ol>
<h3 id="发表二级评论-回复">发表二级评论 (回复)</h3>
<ol>
<li>生成唯一回复 ID (<code>new_reply_id</code>)。</li>
<li>使用<code>HSET comment:&#123;new_reply_id&#125;</code>存储回复内容，设置<code>parent_id</code>为被回复评论的 ID (<code>parent_comment_id</code>)。这一步和上一环节第二步一样，但是多了一个<code>parent_comment_id</code>。</li>
<li>使用<code>ZADD comment:&#123;parent_comment_id&#125;:replies &#123;timestamp&#125; &#123;new_reply_id&#125;</code>将回复 ID 添加到父评论的回复列表中。</li>
</ol>
<p>这里引入了一个设计，主表拥有关联表的主键控制权，而从表通过自身的<code>paren_id</code>来寻找父节点。不同元素之间不使用同一个<code>parent_id</code>而使用另一个类型的id作为外键。而且<strong>回复需要用一张单独的三级表</strong>。</p>
<h3 id="读取文章评论-带分页和回复">读取文章评论 (带分页和回复)</h3>
<p>这些步骤告诉我们，对多个数据结构就应该多步操作。</p>
<ol>
<li>获取一级评论列表: 使用<code>ZREVRANGE post:&#123;post_id&#125;:comments &#123;start&#125; &#123;end&#125;</code> 获取指定范围（如最新的 N 条）一级评论的 ID 列表。</li>
<li>获取评论详情: 遍历上一步获取的 ID 列表，对每个 ID 使用<code>HGETALL comment:&#123;comment_id&#125;</code>获取其完整内容。</li>
<li>（可选）获取回复列表: 对于每条一级评论，如果需要加载其回复：
<ul>
<li>使用<code>ZREVRANGE comment:&#123;parent_comment_id&#125;:replies 0 &#123;limit&#125;</code>获取该评论下的前<code>limit</code>条回复 ID。</li>
<li>再次遍历回复 ID 列表，使用<code>HGETALL comment:&#123;reply_id&#125;</code>获取每条回复的完整内容。</li>
</ul>
</li>
<li>删除评论
<ul>
<li>逻辑删除: 推荐做法是将 comment:{id} Hash 中的 status 字段更新为 ‘deleted’。在读取时过滤掉状态为 ‘deleted’ 的评论。</li>
<li>物理删除: 更复杂，需要同时从父级列表 (ZREM)、删除其回复列表 (DEL)、删除其内容 Hash (DEL)，并处理计数器等。</li>
</ul>
</li>
</ol>
<h2 id="示例-redis-命令">示例 (Redis 命令)</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 发表一级评论</span><br>INCR global:comment_id_counter <span class="hljs-comment"># 假设得到 1001</span><br>HSET comment:1001 content <span class="hljs-string">&quot;Great article!&quot;</span> user_id <span class="hljs-string">&quot;user_a&quot;</span> post_id <span class="hljs-string">&quot;post_123&quot;</span> parent_id <span class="hljs-string">&quot;0&quot;</span> timestamp 1700000000 status <span class="hljs-string">&quot;active&quot;</span><br><span class="hljs-comment"># 这里两张表可以用同一个 timestamp</span><br>ZADD post:post_123:comments 1700000000 1001<br><br><span class="hljs-comment"># 回复一级评论</span><br>INCR global:comment_id_counter <span class="hljs-comment"># 假设得到 1002</span><br>HSET comment:1002 content <span class="hljs-string">&quot;Thanks!&quot;</span> user_id <span class="hljs-string">&quot;user_b&quot;</span> post_id <span class="hljs-string">&quot;post_123&quot;</span> parent_id <span class="hljs-string">&quot;1001&quot;</span> timestamp 1700000050 status <span class="hljs-string">&quot;active&quot;</span><br><br><span class="hljs-comment"># 这里只插入 reply 表，没有插入 comment 表</span><br>ZADD comment:1001:replies 1700000050 1002<br><br><span class="hljs-comment"># 读取文章评论 (前1条) 及其回复 (前1条)</span><br><br><span class="hljs-comment"># 第一个 0 (start): 表示范围的起始索引。索引从 0 开始计数。所以 0 就是排序后的第一个元素。</span><br><span class="hljs-comment"># 第二个 0 (stop): 表示范围的结束索引。同样，索引从 0 开始计数。所以 0 也表示排序后的第一个元素。</span><br><span class="hljs-comment"># 组合起来 0 0: 意思就是“从排序后的第 1 个元素开始，到第 1 个元素结束”，也就是只获取排序后的第一个元素。</span><br>ZREVRANGE post:post_123:comments 0 0 WITHSCORES<br><span class="hljs-comment"># 假设返回: 1) &quot;1001&quot; 2) &quot;1700000000&quot; 注意这里只有一条返回值，1700000000 是时间戳</span><br><br>HGETALL comment:1001<br><span class="hljs-comment"># 返回评论 1001 的内容</span><br><br>ZREVRANGE comment:1001:replies 0 0<br><span class="hljs-comment"># 假设返回: 1) &quot;1002&quot;</span><br><br>HGETALL comment:1002<br><span class="hljs-comment"># 返回回复 1002 的内容</span><br></code></pre></td></tr></table></figure>
<h2 id="range-的提示：">range 的提示：</h2>
<p>在 Redis 中，像 0 -1 这样的起止点（通常用于 ZRANGE, ZREVRANGE, LRANGE, SUBSTR, GETRANGE 等命令）有其特定的设计含义，主要用于指定范围的开始和结束位置。这种设计在很多编程语言和数据结构库中都很常见。</p>
<p>以下是关键点：</p>
<ol>
<li>索引从 0 开始: 和大多数编程语言一样，Redis 中范围的索引通常是从 0 开始计数的。第一个元素的索引是 0，第二个是 1，依此类推。</li>
<li>负数索引: Redis 支持使用负数作为索引，这为从序列末尾开始计数提供了便利。
<ul>
<li>-1 表示最后一个元素。</li>
<li>-2 表示倒数第二个元素。</li>
<li>-3 表示倒数第三个元素。</li>
<li>以此类推。</li>
</ul>
</li>
<li>start 和 stop 参数:
<ul>
<li>start: 范围的起始索引（包含该位置的元素）。</li>
<li>stop: 范围的结束索引（也包含该位置的元素）。这与某些编程语言（如 Python 的切片，list[0:5] 不包含索引 5）有所不同，Redis 的范围是包含两端的。</li>
</ul>
</li>
<li>0 -1 的含义:
<ul>
<li>0: 从第一个元素开始。</li>
<li>-1: 到最后一个元素结束。</li>
<li>因此，0 -1 组合在一起，通常表示“从头到尾的所有元素”。</li>
</ul>
</li>
<li>其他常用组合:
<ul>
<li>0 0: 获取第一个元素。</li>
<li>0 4: 获取前 5 个元素 (索引 0, 1, 2, 3, 4)。</li>
<li>-1 -1: 获取最后一个元素。</li>
<li>-5 -1: 获取最后 5 个元素。</li>
<li>2 -1: 从第三个元素开始，到末尾的所有元素。</li>
</ul>
</li>
</ol>
<h1>延时队列</h1>
<p>延时队列是一种在指定时间后才处理消息的队列。在许多场景中非常有用，例如订单超时取消、邮件延迟发送、定时任务等。Redis 本身没有直接提供延时队列的功能，但我们可以利用其 <code>Sorted Set</code> (ZSet) 数据结构来实现一个高效且可靠的延时队列。</p>
<h2 id="核心设计思想">核心设计思想</h2>
<p>我们将使用 Redis 的 <code>Sorted Set</code> 来存储延时消息。<code>Sorted Set</code> 中的每个元素（消息）都有一个与之关联的 <code>Score</code>。我们可以将消息的<strong>预期处理时间戳</strong>（Unix Timestamp）作为 <code>Score</code>。这样，<code>Sorted Set</code> 会根据时间戳自动对消息进行排序。</p>
<p>一个后台的 Worker 进程会周期性地检查这个 <code>Sorted Set</code>，将所有 <code>Score</code>（到期时间）小于或等于当前时间戳的消息取出来进行处理。</p>
<h2 id="数据结构">数据结构</h2>
<ul>
<li><strong>Key</strong>: <code>delayed_queue:&#123;queue_name&#125;</code> (例如 <code>delayed_queue:order_timeout</code>, <code>delayed_queue:email_reminders</code>)
<ul>
<li>这是一个 <code>Sorted Set</code>。</li>
</ul>
</li>
<li><strong>Member</strong>(成员): 消息体。这可以是一个字符串，也可以是序列化后的 JSON 字符串，包含任务所需的所有信息。</li>
<li><strong>Score</strong>(分数): 消息的到期时间戳 (Unix Timestamp)。这是实现延时功能的关键。</li>
</ul>
<h2 id="核心操作流程">核心操作流程</h2>
<h3 id="添加延时消息-enqueue-with-delay">添加延时消息 (Enqueue with Delay)</h3>
<p>要添加一个延时消息，你需要：</p>
<ol>
<li>确定消息需要被处理的时间点，并计算出对应的 <strong>Unix 时间戳</strong> (<code>execution_timestamp</code>)。
<ul>
<li>例如：当前时间戳是 <code>1678886400</code>，你想让消息在 5 分钟（300 秒）后处理，那么 <code>execution_timestamp = 1678886400 + 300 = 1678886700</code>。</li>
</ul>
</li>
<li>准备好消息的内容 (<code>message</code>)。</li>
<li>使用 <code>ZADD</code> 命令将消息添加到 <code>Sorted Set</code> 中。</li>
</ol>
<p><strong>Redis 命令示例</strong>:</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 假设我们要在 1678886700 时间戳处理一条消息</span><br>ZADD delayed_queue:order_timeout 1678886700 <span class="hljs-string">&quot;&#123;\&quot;order_id\&quot;: \&quot;12345\&quot;, \&quot;action\&quot;: \&quot;cancel\&quot;&#125;&quot;</span><br></code></pre></td></tr></table></figure>
<ol>
<li>队列的value就是消息本身，而不是 hash。</li>
<li>队列名最好是性质加类型。</li>
</ol>
<h3 id="处理到期消息-dequeue-process-ready-messages">处理到期消息 (Dequeue / Process Ready Messages)</h3>
<p>这部分由一个后台 Worker 进程负责执行。</p>
<p>Worker 的核心逻辑:</p>
<ol>
<li>获取当前时间戳 (<code>current_timestamp</code>)。</li>
<li>查询到期消息: 使用<code>ZRANGEBYSCORE</code>命令查询<code>Sorted Set</code>中所有<code>Score</code>小于或等于 <code>current_timestamp</code>的消息。通常会限制一次取出的消息数量 (<code>LIMIT</code>) 以防止瞬间负载过高。</li>
<li>处理消息: 遍历查询到的到期消息，执行相应的业务逻辑（如取消订单、发送邮件）。</li>
<li>移除已处理消息: 非常重要：处理完成后，必须将这些消息从<code>Sorted Set</code> 中移除，避免被重复处理。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># --- Worker 查询到期消息 ---</span><br><span class="hljs-comment"># 获取当前时间戳 (由 Worker 程序生成)</span><br><span class="hljs-comment"># current_timestamp = 1678886800 # (示例值)</span><br><br><span class="hljs-comment"># 查询所有已到期的消息 (最多取 10 条)。如果要继续取值，在应用层写个 for 循环，获取本批最大的 score，最为新的 start 值，继续取。</span><br><br><span class="hljs-comment"># 这个设计比较好的地方是，如果存的是时间戳，就拿最新的时间戳作为 stop 值</span><br><span class="hljs-comment"># 不 revrange 就可以升序查询</span><br>ZRANGEBYSCORE delayed_queue:order_timeout 0 1678886800 LIMIT 0 10 WITHSCORES<br><span class="hljs-comment"># 假设返回:</span><br><span class="hljs-comment"># 1) &quot;&#123;\&quot;order_id\&quot;: \&quot;12345\&quot;, \&quot;action\&quot;: \&quot;cancel\&quot;&#125;&quot;</span><br><span class="hljs-comment"># 2) &quot;1678886700&quot;</span><br><br><span class="hljs-comment"># --- Worker 处理逻辑 (伪代码) ---</span><br><span class="hljs-comment"># 1. 获取当前 Unix 时间戳</span><br><span class="hljs-comment"># current_timestamp = get_current_unix_timestamp()</span><br><br><span class="hljs-comment"># 2. 查询到期消息</span><br><span class="hljs-comment"># expired_messages = redis_client.zrangebyscore(&#x27;delayed_queue:order_timeout&#x27;, 0, current_timestamp, start=0, num=10, withscores=True)</span><br><br><span class="hljs-comment"># 3. 遍历并处理</span><br><span class="hljs-comment"># for message, score in expired_messages:</span><br>    <span class="hljs-comment"># a. 解析消息内容 (例如 JSON)</span><br>    <span class="hljs-comment">#    task_data = json.loads(message)</span><br>    <span class="hljs-comment"># b. 执行业务逻辑 (关键步骤!)</span><br>    <span class="hljs-comment">#    if task_data[&#x27;action&#x27;] == &#x27;cancel&#x27;:</span><br>    <span class="hljs-comment">#        cancel_order(task_data[&#x27;order_id&#x27;])</span><br>    <span class="hljs-comment"># c. 从延时队列中移除已处理的消息 (关键步骤!)</span><br>    <span class="hljs-comment">#    redis_client.zrem(&#x27;delayed_queue:order_timeout&#x27;, message)</span><br></code></pre></td></tr></table></figure>
<p>记住，<strong><code>zrange</code>本身并不移除元素，而元素是必须通过 zrem 移除的</strong>！</p>
<h2 id="保证原子性-推荐">保证原子性 (推荐)</h2>
<p>在高并发场景下，可能存在多个 Worker 同时取出同一条消息的风险。为了避免重复处理，最好将“取出消息”和“移除消息”这两个操作变成一个原子操作。</p>
<p>可以使用 Redis 的 Lua 脚本来实现这一点：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- Lua script: 原子性地获取并移除一条到期消息</span><br><span class="hljs-keyword">local</span> expired = redis.call(<span class="hljs-string">&#x27;ZRANGEBYSCORE&#x27;</span>, KEYS[<span class="hljs-number">1</span>], <span class="hljs-number">0</span>, ARGV[<span class="hljs-number">1</span>], <span class="hljs-string">&#x27;LIMIT&#x27;</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> #expired &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;ZREM&#x27;</span>, KEYS[<span class="hljs-number">1</span>], expired[<span class="hljs-number">1</span>])<br>    <span class="hljs-keyword">return</span> expired[<span class="hljs-number">1</span>]<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p><strong>使用 Lua 脚本的 Worker 逻辑</strong>(伪代码)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># lua_script = redis_client.register_script(lua_code_above)</span><br><br><span class="hljs-comment"># while True: # Worker 持续运行</span><br>    <span class="hljs-comment"># current_timestamp = get_current_unix_timestamp()</span><br>    <span class="hljs-comment"># expired_message = lua_script(keys=[&#x27;delayed_queue:order_timeout&#x27;], args=[current_timestamp])</span><br>    <span class="hljs-comment"># if expired_message:</span><br>        <span class="hljs-comment"># parsed_message = json.loads(expired_message)</span><br>        <span class="hljs-comment"># process_message(parsed_message) # 执行业务逻辑</span><br>    <span class="hljs-comment"># else:</span><br>        <span class="hljs-comment"># time.sleep(1) # 没有消息时短暂休眠，避免空轮询</span><br></code></pre></td></tr></table></figure>
<h2 id="优点">优点</h2>
<ul>
<li>简单高效: 利用 Redis 原生的<code>Sorted Set</code>实现，无需引入额外的组件。</li>
<li>精确延时: 基于 Unix 时间戳，可以实现秒级甚至毫秒级的精确延时。</li>
<li>可扩展: 可以轻松创建多个不同的延时队列（通过不同的<code>queue_name</code>）。</li>
</ul>
<h2 id="注意事项">注意事项</h2>
<ul>
<li>时钟同步: 确保生成到期时间戳和 Worker 获取当前时间戳的服务器时钟是同步的。</li>
<li>Worker 可靠性: Worker 进程需要稳定运行，最好有监控和自动重启机制。</li>
<li>消息处理幂等性: Worker 处理消息的逻辑最好是幂等的，以防万一消息因故障被重复处理。</li>
<li>原子性: 强烈推荐使用 Lua 脚本或其他方式保证“获取并移除”操作的原子性。</li>
<li>持久化: 确保 Redis 配置了适当的持久化策略（RDB/AOF），以防宕机丢失延时消息。</li>
<li>性能: 如果消息量非常巨大，<code>ZRANGEBYSCORE</code> 的性能可能会成为瓶颈，需要考虑分片或其他优化策略。</li>
</ul>
<h1>排行榜</h1>
<p>排行榜是游戏中非常常见的功能，需要根据分数对用户进行实时排名。Redis 的 <strong>Sorted Set</strong>(ZSet) 是实现排行榜的理想选择，因为它天然支持按 Score 排序，并提供了丰富的命令来查询排名、分数和范围。</p>
<h2 id="数据结构设计">数据结构设计</h2>
<ol>
<li><strong>排行榜存储</strong>(Sorted Set)
<ul>
<li>Key: <code>leaderboard:&#123;board_name&#125;</code> (例如<code>leaderboard:global</code>, <code>leaderboard:weekly_scores</code>, <code>leaderboard:level_1</code>)</li>
<li><strong>Member</strong>(成员): 用户的唯一标识符 (User ID)。例如<code>user:123</code>,<code>player_abc</code>。</li>
<li><strong>Score</strong>(分数): 用户的得分。可以是整数或浮点数。</li>
</ul>
</li>
</ol>
<h2 id="核心操作流程">核心操作流程</h2>
<ol>
<li><strong>更新用户分数</strong>(Update Score)
<ul>
<li>当用户的分数发生变化时（例如，得分增加或减少），使用<code>ZADD</code>命令更新其在 Sorted Set 中的分数。</li>
<li>Redis 的<code>ZADD</code>命令非常智能，如果 Member (用户ID) 已经存在，它会更新其 Score；如果不存在，则会添加一个新的 Member-Score 对。</li>
<li>命令:<code>ZADD leaderboard:&#123;board_name&#125; &#123;new_score&#125; &#123;user_id&#125;</code></li>
<li>(可选): 如果只想在新分数更高时才更新，可以先用 ZSCORE 获取旧分数比较，或者使用<code>ZADD</code>的<code>GT</code>(Greater Than) 选项 (需要 Redis 6.2+)。</li>
<li><code>ZADD leaderboard:&#123;board_name&#125; GT &#123;new_score&#125; &#123;user_id&#125;</code></li>
</ul>
</li>
<li><strong>获取用户排名</strong>(Get User Rank)。我们经常使用遍历读操作来使用 redis，其实是可以用 rank 操作的，但是最好用<code>ZREVRANK</code>。
<ul>
<li>获取特定用户在排行榜中的排名（从高分到低分）。</li>
<li>命令: <code>ZREVRANK leaderboard:&#123;board_name&#125; &#123;user_id&#125;</code>。</li>
<li>注意: Redis 的排名是从 0 开始的。返回 0 表示第一名，1 表示第二名，以此类推。如果用户不在排行榜中，返回 nil。</li>
</ul>
</li>
<li><strong>获取用户分数</strong>(Get User Score)
<ul>
<li>获取特定用户的当前分数。</li>
<li>命令: <code>ZSCORE leaderboard:&#123;board_name&#125; &#123;user_id&#125;</code></li>
<li>如果用户不在排行榜中，返回 nil。</li>
</ul>
</li>
<li><strong>获取排行榜</strong>(Get Top N Players)
<ul>
<li>获取排行榜上前 N 名的用户及其分数。</li>
<li>命令: <code>ZREVRANGE leaderboard:&#123;board_name&#125; 0 &#123;N-1&#125; WITHSCORES</code></li>
<li><code>ZREVRANGE</code>按 Score 从高到低返回成员。<code>0 &#123;N-1&#125;</code>表示获取前 N 个成员。<code>WITHSCORES</code>会同时返回成员和其分数。</li>
</ul>
</li>
<li><strong>获取排行榜的一部分</strong>(Get Players Around a User / Pagination)
<ul>
<li>场景 1: 获取用户周围的排名 (例如，显示用户自己及前后各几位玩家)。
<ul>
<li>先获取用户的排名: <code>user_rank = ZREVRANK leaderboard:&#123;board_name&#125; &#123;user_id&#125;</code></li>
<li>计算起始和结束索引: <code>start = user_rank - k, end = user_rank + k</code> (k 是前后要显示的玩家数)。</li>
<li>获取范围: <code>ZREVRANGE leaderboard:&#123;board_name&#125; &#123;start&#125; &#123;end&#125; WITHSCORES</code></li>
</ul>
</li>
<li>场景 2: 分页显示排行榜。
<ul>
<li>决定每页显示多少名玩家 (<code>page_size</code>) 和当前页码 (<code>page_number</code>, 从 0 或 1 开始)。</li>
<li>计算起始和结束索引: <code>start = page_number * page_size, end = start + page_size - 1</code>。</li>
<li>获取范围: <code>ZREVRANGE leaderboard:&#123;board_name&#125; &#123;start&#125; &#123;end&#125; WITHSCORES</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>增加用户分数</strong>(Increment Score)
<ul>
<li>如果只是给用户增加分数（例如，获得奖励分数），可以使用<code>ZINCRBY</code>命令，这比先 <code>ZSCORE</code>再<code>ZADD</code>更高效且是原子操作。</li>
<li>命令: <code>ZINCRBY leaderboard:&#123;board_name&#125; &#123;increment_value&#125; &#123;user_id&#125;</code></li>
<li>例如，给用户<code>user:123</code>增加 10 分: <code>ZINCRBY leaderboard:global 10 user:123</code></li>
</ul>
</li>
</ol>
<h2 id="示例">示例</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># --- 场景：更新或添加用户分数 ---</span><br><span class="hljs-comment"># 玩家 player_1 获得了 1500 分</span><br>ZADD leaderboard:global 1500 player_1<br><br><span class="hljs-comment"># 玩家 player_2 获得了 2100 分</span><br>ZADD leaderboard:global 2100 player_2<br><br><span class="hljs-comment"># 玩家 player_1 再次游戏，分数更新为 1800 分</span><br>ZADD leaderboard:global 1800 player_1<br><br><span class="hljs-comment"># 玩家 player_3 获得 950 分</span><br>ZADD leaderboard:global 950 player_3<br><br><span class="hljs-comment"># --- 场景：获取玩家排名和分数 ---</span><br><span class="hljs-comment"># 获取 player_2 的排名 (0-based)</span><br>ZREVRANK leaderboard:global player_2<br><span class="hljs-comment"># 返回: (integer) 0  -&gt; player_2 是第一名</span><br><br><span class="hljs-comment"># 获取 player_1 的分数</span><br>ZSCORE leaderboard:global player_1<br><span class="hljs-comment"># 返回: &quot;1800&quot;</span><br><br><span class="hljs-comment"># --- 场景：获取排行榜 Top 3 ---</span><br>ZREVRANGE leaderboard:global 0 2 WITHSCORES<br><span class="hljs-comment"># 假设返回:</span><br><span class="hljs-comment"># 1) &quot;player_2&quot;</span><br><span class="hljs-comment"># 2) &quot;2100&quot;</span><br><span class="hljs-comment"># 3) &quot;player_1&quot;</span><br><span class="hljs-comment"># 4) &quot;1800&quot;</span><br><span class="hljs-comment"># 5) &quot;player_3&quot;</span><br><span class="hljs-comment"># 6) &quot;950&quot;</span><br><br><span class="hljs-comment"># --- 场景：玩家 player_3 获得额外奖励 50 分 ---</span><br>ZINCRBY leaderboard:global 50 player_3<br><span class="hljs-comment"># 返回 player_3 的新分数: &quot;1000&quot;</span><br><br><span class="hljs-comment"># --- 场景：获取 player_3 周围的排名 ---</span><br><span class="hljs-comment"># 获取 player_3 的排名</span><br>ZREVRANK leaderboard:global player_3<br><span class="hljs-comment"># 假设返回: (integer) 2 -&gt; player_3 现在是第三名 (索引 2)</span><br><br><span class="hljs-comment"># 显示 player_3 及其前后各一名玩家 (k=1)</span><br><span class="hljs-comment"># start_index = 2 - 1 = 1</span><br><span class="hljs-comment"># end_index = 2 + 1 = 3</span><br>ZREVRANGE leaderboard:global 1 3 WITHSCORES<br><span class="hljs-comment"># 假设返回 player_1, player_3, player_4 的信息</span><br></code></pre></td></tr></table></figure>
<p>zsort 的几个关键命令：</p>
<ol>
<li>zrange-zrevrange，从高到低。重要选项：WITHSCORES。升序要想清楚是不是从0开始，逆序一般是用来取排行榜<strong>最高排名</strong>的元素。</li>
<li>zscore：获取分数</li>
<li>zrank：查询一个 member 的分数</li>
<li>zadd：原子全量添加</li>
<li>zincr：原子加分</li>
<li>ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]：按<strong>分数区间</strong>找 member，这比 zscore要不方便一点。查找单个 member 的 score (ZSCORE) 比查找一个 score 范围内的所有 members (ZRANGEBYSCORE/ZREVRANGEBYSCORE) 要快得多，因为前者是直接哈希查找 O(1)，而后者涉及范围查询和遍历 O(log(N)+M)。只有在需要根据 score 范围获取 member 时才会使用 ZRANGEBYSCORE/ZREVRANGEBYSCORE。</li>
<li>我们容易忘记的是，区间查找即使在 redis 里也是需要加上 limit 的。</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2025/07/28/Redis-%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E4%BE%8B/">https://magicliang.github.io/2025/07/28/Redis-%E7%9A%84%E7%A5%9E%E5%A5%87%E7%94%A8%E4%BE%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Redis/">Redis</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-28.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2019/10/30/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81-%E5%93%A8%E5%85%B5-Sentinel/" title="Redis 笔记之十-哨兵 Sentinel"><img class="cover" src="/img/wall-paper-34.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-10-30</div><div class="info-item-2">Redis 笔记之十-哨兵 Sentinel</div></div><div class="info-2"><div class="info-item-1">Redis 有若干套高可用实现方案。2.8 开始提供哨兵功能（不要使用更低版本的哨兵，可能有 bug）。 基本概念  主从复制模式的问题 Redis 天然就带有主从复制的功能，但主从复制有若干缺点：  需要手工干预，缺乏自动 FO 机制-分布式高可用问题。 单机的写能力有限-分布式容量问题。 单机的存储能力有限-分布式容量问题。  一个经典的高可用场景 当一个主从集群的 主节点 失效的时候，经典的恢复步骤如下：  主节点失效。 选出新的从节点，slaveof no one。 先更新应用方的连接。 再让其他从节点换主。 再把恢复好的主节点作为新的从节点复制新的主节点。  3 和 4 的步骤可以互换。这种需要手工介入的运行机制不能被当作高可用的。而 sentinel 的作用是把这些经典步骤从手工实现为自动。 Sentinel 的高可用性 Sentinel 方案是在原生的 Master-Slave 集群之外加上一个 Sentinel 集群。 每个 Sentinel 节点会监控其他 Sentinel 节点和所有 Redis 节点。任何一个不可达的节点，它都会将其做下线标识。 如果标识的是...</div></div></div></a><a class="pagination-related" href="/2019/11/09/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%8D%81%E4%B8%80-%E9%9B%86%E7%BE%A4-Cluster/" title="Redis 笔记之十一-集群 Cluster"><img class="cover" src="/img/wall-paper-171.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-09</div><div class="info-item-2">Redis 笔记之十一-集群 Cluster</div></div><div class="info-2"><div class="info-item-1">背景 在 Redis Cluster 方案诞生以前，在 Redis 集群遇到单机资源和流量瓶颈时，有两种常见分布式解决方案：  客户端方案：需要自己处理分区逻辑、路由、故障转移（有时候 Routing、LB 和 Failover是同一个问题，都需要通过 routing 技术来切换流量的 endpoint）。 代理方案：减轻了客户端的职责和压力，架构上的负担过重。  Redis Cluster 的出现，极大地降低了架构师的负担，解放了生产力。 数据分布 数据分布理论 |分区方式|特点|代表产品|取舍逻辑| |:–:|:–:|:–:| |哈希分区| 离散度好 数据分布业务无关 无法顺序访问| KV型 Redis Cluster Cassandra Dynamo Elastic Search|如果需要平衡地存储大量数据而只有随机访问其中的若干条，则可以使用简单的哈希分区| |顺序分区|离散度易倾斜 数据分布业务相关 可顺序访问| 表型 Bigtable HBase Hypertable|如果需要存储大量数据且需要支持区间查找，则也需要使用简单的顺序分区，如果要解决负载均衡的问题可能需要...</div></div></div></a><a class="pagination-related" href="/2022/01/13/Redis-%E7%AC%94%E8%AE%B0%E4%B9%8B%EF%BC%9A%E5%86%85%E5%AD%98%E8%B0%83%E4%BC%98/" title="Redis 笔记之：内存调优"><img class="cover" src="/img/wall-paper-91.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-13</div><div class="info-item-2">Redis 笔记之：内存调优</div></div><div class="info-2"><div class="info-item-1">Redis 的 memory info Redis 的内存使用状况可以使用info memory来获取。 需要重点关注的值是 used_memory_rss（用于存储消耗的物理内存），used_memory（用于存储消耗的内存= 物理内存 + 硬盘），以及他们的比值mem_fragmentation_ratio（used_memory_rss/used_memory）。 used_memory_rss或者used_memory很高时，意味着当前的 Redis 实例正在蚕食系统中的内存/硬盘资源。 当这个mem_fragmentation_ratio大于 1 的时候，意味着用于存储消耗的物理内存超过了 Redis 自己掌控的内存值，也就意味着当前有些未能回收的内存泄漏或者碎片。 当这个mem_fragmentation_ratio小于 1 的时候，这意味着有一部分用于存储的内存，实际上是在使用虚拟内存中的 swap 空间，此时 Redis 的性能会非常差。 Redis 的内存轮廓 memory_used = 进程自身消耗的内存 + 存储对象的内存（大头） + buffer 内存 m...</div></div></div></a><a class="pagination-related" href="/2024/11/04/Redis-%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/" title="Redis 开发与运维"><img class="cover" src="/2024/11/04/Redis-%E5%BC%80%E5%8F%91%E4%B8%8E%E8%BF%90%E7%BB%B4/cover.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2024-11-04</div><div class="info-item-2">Redis 开发与运维</div></div><div class="info-2"><div class="info-item-1">Redis 特性 Redis 高性能的原因 Redis 的读写性能达到 10w/s，主要基于以下原因：  数据主要放在内存中。 Redis 使用距离 OS “层次更近”的 C 语言实现。 Redis 使用单线程架构，没有很高的 lock contention。 IO 多路复用技术 Redis 的代码实现得优雅而兼顾性能  Redis 的数据结构 Redis 本身是 Remote Dictionary Server 的简称，其中，老的、常见的数据结构有：  字符串 哈希 列表 set（集合） zset（有序集合）  但后来追加了几种新颖的数据机构，包括：bitmap、hyperloglog，更后来更添加了 GEO 地理信息相关的工具。 基于这些数据结构，我们可以实现一些常见的功能：  键过期，可以用来实现缓存，进而实现分布式锁。 发布订阅功能，进而实现消息系统（TODO）。 Lua 脚本功能，可以实现自定义的 Redis 命令（TODO）。 实现简单的事务功能，能在一定程度上实现事务特性。 提供流水线功能，能够让客户端一次性把一批命令一次性上传到 Redis 里，能够合并 IO 并...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">二级评论区</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">核心设计理念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.2.</span> <span class="toc-text">数据结构详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AF%84%E8%AE%BA-%E5%9B%9E%E5%A4%8D%E5%86%85%E5%AE%B9-hash"><span class="toc-number">1.2.1.</span> <span class="toc-text">存储评论&#x2F;回复内容 (Hash)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%87%E7%AB%A0%E4%B8%8B%E7%9A%84%E4%B8%80%E7%BA%A7%E8%AF%84%E8%AE%BA%E5%88%97%E8%A1%A8-sorted-set"><span class="toc-number">1.2.2.</span> <span class="toc-text">存储文章下的一级评论列表 (Sorted Set)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E8%AF%84%E8%AE%BA%E4%B8%8B%E7%9A%84%E5%9B%9E%E5%A4%8D%E5%88%97%E8%A1%A8-sorted-set"><span class="toc-number">1.2.3.</span> <span class="toc-text">存储评论下的回复列表 (Sorted Set)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">核心操作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E8%A1%A8%E4%B8%80%E7%BA%A7%E8%AF%84%E8%AE%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">发表一级评论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%91%E8%A1%A8%E4%BA%8C%E7%BA%A7%E8%AF%84%E8%AE%BA-%E5%9B%9E%E5%A4%8D"><span class="toc-number">1.3.2.</span> <span class="toc-text">发表二级评论 (回复)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%96%87%E7%AB%A0%E8%AF%84%E8%AE%BA-%E5%B8%A6%E5%88%86%E9%A1%B5%E5%92%8C%E5%9B%9E%E5%A4%8D"><span class="toc-number">1.3.3.</span> <span class="toc-text">读取文章评论 (带分页和回复)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-redis-%E5%91%BD%E4%BB%A4"><span class="toc-number">1.4.</span> <span class="toc-text">示例 (Redis 命令)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#range-%E7%9A%84%E6%8F%90%E7%A4%BA%EF%BC%9A"><span class="toc-number">1.5.</span> <span class="toc-text">range 的提示：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">延时队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3"><span class="toc-number">2.1.</span> <span class="toc-text">核心设计思想</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">2.3.</span> <span class="toc-text">核心操作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E5%BB%B6%E6%97%B6%E6%B6%88%E6%81%AF-enqueue-with-delay"><span class="toc-number">2.3.1.</span> <span class="toc-text">添加延时消息 (Enqueue with Delay)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%88%B0%E6%9C%9F%E6%B6%88%E6%81%AF-dequeue-process-ready-messages"><span class="toc-number">2.3.2.</span> <span class="toc-text">处理到期消息 (Dequeue &#x2F; Process Ready Messages)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7-%E6%8E%A8%E8%8D%90"><span class="toc-number">2.4.</span> <span class="toc-text">保证原子性 (推荐)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.5.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.6.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">排行榜</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text">数据结构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.2.</span> <span class="toc-text">核心操作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.3.</span> <span class="toc-text">示例</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>