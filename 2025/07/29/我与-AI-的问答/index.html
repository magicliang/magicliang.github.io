<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>我与 AI 的问答 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTTP 请求体只读一次之谜：Go 与 Java 的应对之道 作为一名后端开发者，你几乎肯定会遇到这个经典场景：为了实现日志记录、签名验证或请求重放，你需要在中间件（Middleware&#x2F;Filter）中读取 HTTP 请求体（Request Body）。然而，当你将请求传递给下一个处理程序时，却发现 Body 变成了空的！程序抛出错误，逻辑中断。 这不是一个 Bug，而是网络 I&#x2F;O 流处理的一">
<meta property="og:type" content="article">
<meta property="og:title" content="我与 AI 的问答">
<meta property="og:url" content="https://magicliang.github.io/2025/07/29/%E6%88%91%E4%B8%8E-AI-%E7%9A%84%E9%97%AE%E7%AD%94/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="HTTP 请求体只读一次之谜：Go 与 Java 的应对之道 作为一名后端开发者，你几乎肯定会遇到这个经典场景：为了实现日志记录、签名验证或请求重放，你需要在中间件（Middleware&#x2F;Filter）中读取 HTTP 请求体（Request Body）。然而，当你将请求传递给下一个处理程序时，却发现 Body 变成了空的！程序抛出错误，逻辑中断。 这不是一个 Bug，而是网络 I&#x2F;O 流处理的一">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-24.jpg">
<meta property="article:published_time" content="2025-07-29T07:05:34.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:33.089Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="程序设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-24.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "我与 AI 的问答",
  "url": "https://magicliang.github.io/2025/07/29/%E6%88%91%E4%B8%8E-AI-%E7%9A%84%E9%97%AE%E7%AD%94/",
  "image": "https://magicliang.github.io/img/wall-paper-24.jpg",
  "datePublished": "2025-07-29T07:05:34.000Z",
  "dateModified": "2025-10-22T08:01:33.089Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2025/07/29/%E6%88%91%E4%B8%8E-AI-%E7%9A%84%E9%97%AE%E7%AD%94/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '我与 AI 的问答',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-24.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">我与 AI 的问答</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">我与 AI 的问答</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-29T07:05:34.000Z" title="Created 2025-07-29 15:05:34">2025-07-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:33.089Z" title="Updated 2025-10-22 16:01:33">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">21.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>80mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>HTTP 请求体只读一次之谜：Go 与 Java 的应对之道</h1>
<p>作为一名后端开发者，你几乎肯定会遇到这个经典场景：为了实现日志记录、签名验证或请求重放，你需要在中间件（Middleware/Filter）中读取 HTTP 请求体（Request Body）。然而，当你将请求传递给下一个处理程序时，却发现 Body 变成了空的！程序抛出错误，逻辑中断。</p>
<p>这不是一个 Bug，而是网络 I/O 流处理的一个基本特性。本文将深入探讨这个问题的根源，并详细对比 Go 和 Java 在处理“可重复读 Body”这一问题上的不同解决方案，揭示其背后截然不同的设计哲学。</p>
<h2 id="第一部分：问题的根源-流的-阅后即焚-本质">第一部分：问题的根源——流的“阅后即焚”本质</h2>
<p>为什么 HTTP 请求体默认只能读取一次？</p>
<p>我们可以把请求体想象成一条从网络连接中实时流淌过来的数据河，而不是一块已经完整存放在硬盘上的文件。</p>
<ol>
<li>效率至上：当服务器收到一个 HTTP 请求时，特别是像文件上传这样带有巨大请求体的请求，如果需要先把整个几 GB 大小的文件都读到内存里才能开始处理，那将是极其低效且消耗内存的。在繁忙的服务器上，这会轻易导致内存溢出（Out of Memory）。</li>
<li>“传送带”模型：这个数据流就像一条单向传送带。你的代码站在传送带的某个点，当数据字节经过你面前时，你把它们取下来。一旦数据经过了你，它就从传送带上消失了，无法倒转。服务器从网络套接字（Socket）读取数据块，交给你的应用程序，然后就丢弃它，为下一块数据腾出空间。</li>
<li>流的定义：这种“只能向前”的读取机制就是“流”（Stream）的本质。它被设计用来顺序地、高效地处理可能非常大的数据，而无需一次性将所有内容都保存在内存中。<br>
所以，当你调用 Go 的<code>r.Body.Read()</code>或 Java 的<code>request.getInputStream()</code> 时，你接触到的就是这个一次性的、向前流动的数据源。一旦读完，数据就被“消费”了，无法再次获取。</li>
</ol>
<h2 id="第二部分：go-的解决方案-灵活直接的-io-工具箱">第二部分：Go 的解决方案——灵活直接的 io 工具箱</h2>
<p>Go 的标准库<code>net/http</code>在设计上赋予了开发者极大的灵活性。<code>http.Request</code>结构体中的<code>Body</code>是一个公开的、可以被修改的字段。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go 的 Request 结构体简化视图</span><br><span class="hljs-keyword">type</span> Request <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// ... 其他字段</span><br>    Body io.ReadCloser <span class="hljs-comment">// 这是一个公开的、可以修改的字段</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>正是因为<code>Body</code>字段可写，Go 提供了非常优雅的解决方案。</p>
<h3 id="方案一：先读后写-简单但有风险">方案一：先读后写（简单但有风险）</h3>
<p>最直观的方法是先把整个请求体读入内存，然后再用内存中的数据创建一个新的请求体写回去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bytes&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-comment">// 1. 将原始的 body 流一次性读取到字节切片中</span><br>reqBody, err := io.ReadAll(r.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-comment">// 处理错误...</span><br>&#125;<br>r.Body.Close() <span class="hljs-comment">// 别忘了关闭原始 Body</span><br><br><span class="hljs-comment">// 你现在可以对 reqBody 做任何事，比如打印日志</span><br>log.Printf(<span class="hljs-string">&quot;请求体内容: %s&quot;</span>, reqBody)<br><br><span class="hljs-comment">// 2. 从字节切片创建一个新的 reader，并用 io.NopCloser 包装</span><br><span class="hljs-comment">//    io.NopCloser 提供一个无操作的 Close 方法，以满足 io.ReadCloser 接口</span><br>r.Body = io.NopCloser(bytes.NewBuffer(reqBody))<br><br><span class="hljs-comment">// 3. 后续的 handler 可以正常读取 r.Body</span><br>next.ServeHTTP(w, r)<br></code></pre></td></tr></table></figure>
<p>这个方案的致命缺陷在于：<code>io.ReadAll</code>会尝试一次性分配整个请求体大小的内存。如果客户端上传一个 1GB 的文件，你的服务器内存会瞬间飙升 1GB，极易导致服务因内存耗尽而崩溃。</p>
<h3 id="方案二：边读边备-推荐的健壮模式">方案二：边读边备（推荐的健壮模式）</h3>
<p>为了解决内存问题，Go 的<code>io</code>包提供了一个神器：<code>io.TeeReader</code>。</p>
<p><code>TeeReader</code>像一个管道三通阀，它从一个读取器（Reader）中读取数据的同时，会把同样的数据写入到一个写入器（Writer）中。这让我们可以流式地处理数据，同时备份它。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bytes&quot;</span><br>    <span class="hljs-string">&quot;io&quot;</span><br>    <span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-comment">// 1. 创建一个内存缓冲区 buf</span><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br><br><span class="hljs-comment">// 2. 创建一个 TeeReader</span><br><span class="hljs-comment">// 它会从 r.Body 读取数据，并同时写入到 &amp;buf</span><br>tee := io.TeeReader(r.Body, &amp;buf)<br><br><span class="hljs-comment">// 假设我们只是想读取并记录，而不是解码</span><br><span class="hljs-comment">// 我们可以创建一个新的读取器 newBody，后续处理都用它</span><br><span class="hljs-comment">// 这样原始的 tee 就会把数据全部读出并存入 buf</span><br>io.Copy(io.Discard, tee) <span class="hljs-comment">// io.Discard 是一个“黑洞”，所有写入它的数据都被丢弃</span><br>log.Printf(<span class="hljs-string">&quot;请求体内容: %s&quot;</span>, buf.String())<br><br><br><span class="hljs-comment">// 4. 用已经填满数据的 buf 创建新 Body，并替换回去</span><br>r.Body = io.NopCloser(&amp;buf)<br><br><span class="hljs-comment">// 后续 handler 读取的是内存中 buf 的数据</span><br>next.ServeHTTP(w, r)<br></code></pre></td></tr></table></figure>
<p>为什么<code>TeeReader</code>更好？</p>
<p>它将内存分配从**“一次性预分配”变成了“渐进式增长”**。如果处理过程中出现错误（如格式错误），程序会提前中止，此时内存中只缓存了已处理过的一小部分数据，从而极大地提高了程序的健壮性和安全性。</p>
<blockquote>
<p>生产级提示：为了达到终极安全，还应组合使用<code>http.MaxBytesReader</code> 来限制请求体的最大尺寸，从根源上防止恶意的大请求。</p>
</blockquote>
<h3 id="第三部分：java-的解决方案-经典而严谨的设计模式">第三部分：Java 的解决方案——经典而严谨的设计模式</h3>
<p>与 Go 不同，Java 的<code>HttpServletRequest</code>是一个接口，它的设计遵循了严格的封装原则。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Servlet 接口的简化视图</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">HttpServletRequest</span> &#123;<br>    <span class="hljs-comment">// ... 其他方法</span><br>    <span class="hljs-keyword">public</span> ServletInputStream <span class="hljs-title function_">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException;<br>    <span class="hljs-comment">// 注意：这里没有 setInputStream() 方法！</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>你无法直接替换请求的输入流。因此，必须使用经典的装饰器模式（Decorator Pattern），通过 HttpServletRequestWrapper 来实现。</p>
<p>实现步骤如下：</p>
<p>创建自定义包装类：你需要创建一个新类，继承自<code>HttpServletRequestWrapper</code>。<br>
缓存请求体：在包装类的构造函数中，从原始的<code>request.getInputStream()</code>读取所有字节并保存到一个 <code>byte[]</code>数组中。<br>
重写<code>getInputStream</code>：重写<code>getInputStream()</code>和<code>getReader()</code> 方法。在你的新方法中，每次调用都从缓存的<code>byte[]</code>数组创建一个新的<code>ByteArrayInputStream</code>并返回。<br>
创建过滤器（Filter）：在你的过滤器中，实例化你的自定义包装类，并将这个包装类对象传递给过滤器链的下一个环节。<br>
代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 自定义包装类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CachedBodyHttpServletRequest</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServletRequestWrapper</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">byte</span>[] cachedBody;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CachedBodyHttpServletRequest</span><span class="hljs-params">(HttpServletRequest request)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-built_in">super</span>(request);<br>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">requestInputStream</span> <span class="hljs-operator">=</span> request.getInputStream();<br>        <span class="hljs-comment">// Spring 框架的工具类，可替换为原生 I/O 操作</span><br>        <span class="hljs-built_in">this</span>.cachedBody = StreamUtils.copyToByteArray(requestInputStream);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ServletInputStream <span class="hljs-title function_">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletInputStream</span>() &#123;<br>            <span class="hljs-keyword">private</span> <span class="hljs-type">InputStream</span> <span class="hljs-variable">cachedBodyInputStream</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(cachedBody);<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>                <span class="hljs-keyword">return</span> cachedBodyInputStream.read();<br>            &#125;<br>            <span class="hljs-comment">// ... 需要实现 isFinished, isReady, setReadListener 等方法</span><br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> BufferedReader <span class="hljs-title function_">getReader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(<span class="hljs-built_in">this</span>.cachedBody)));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 2. 在过滤器中使用</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CachingFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(ServletRequest request, ServletResponse response, FilterChain chain)</span><br>            <span class="hljs-keyword">throws</span> IOException, ServletException &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">httpRequest</span> <span class="hljs-operator">=</span> (HttpServletRequest) request;<br>        <span class="hljs-comment">// 使用包装类包装原始请求</span><br>        <span class="hljs-type">CachedBodyHttpServletRequest</span> <span class="hljs-variable">wrappedRequest</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CachedBodyHttpServletRequest</span>(httpRequest);<br>        <br>        <span class="hljs-comment">// 在这里可以从 wrappedRequest 中多次读取 body</span><br>        <span class="hljs-comment">// ...</span><br>        <br>        <span class="hljs-comment">// 将包装后的请求传递下去</span><br>        chain.doFilter(wrappedRequest, response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注：像 Spring<br>
框架提供了<code>ContentCachingRequestWrapper</code>这样的工具类，可以简化这个过程，但其底层原理是完全相同的。</p>
</blockquote>
<h2 id="第四部分：特殊情况-为何parsemultipartform可以重复调用？">第四部分：特殊情况——为何<code>ParseMultipartForm</code>可以重复调用？</h2>
<p>这是一个非常好的问题，它触及了 Go <code>net/http</code>包中一个精妙的设计细节。既然<code>r.Body</code> 只能消费一次，为什么在你的代码中，中间件和后续接口服务都能成功调用<code>r.ParseMultipartForm</code>呢？</p>
<p>答案是：<code>http.Request</code>对象在内部缓存了解析后的表单数据。真正的解析操作只会发生一次。</p>
<p>我们可以把<code>http.Request</code>结构体想象成有一个隐藏的标记：“我解析过表单了吗？”。</p>
<ol>
<li>第一次调用<code>r.ParseMultipartForm</code>(在中间件中)
<ul>
<li>方法被调用，它首先检查内部的<code>r.MultipartForm</code>字段。</li>
<li>它发现这个字段是<code>nil</code>(代表“还没解析过”)。</li>
<li>于是，它开始读取并消费<code>r.Body</code>流。</li>
<li>它从流中解析出 multipart 表单数据。</li>
<li>它将解析出的键值对和上传的文件，分别存入<code>Request</code>结构体内部的<code>r.Form</code>和<code>r.MultipartForm</code> 字段中。</li>
<li>此时，<code>r.Body</code>流虽然空了，但数据已经被安全地缓存在了<code>Request</code>对象内部。</li>
</ul>
</li>
<li>第二次调用<code>r.ParseMultipartForm</code> (在接口服务中)
<ul>
<li>方法再次被调用，它再次检查内部的<code>r.MultipartForm</code>字段。</li>
<li>这一次，它发现这个字段不是<code>nil</code>(代表“是的，我已经解析过了！”)。</li>
<li>于是，这个函数什么也不做，立刻返回。它不会再去尝试读取已经耗尽的 <code>r.Body</code>。这使得该操作在第一次成功调用后，后续调用都是幂等的。</li>
</ul>
</li>
<li><code>r.FormValue(&quot;uid&quot;)</code>的行为
<ul>
<li>这个便捷方法同样会先检查表单是否已解析。如果未解析，它会内部触发解析。如果已解析，它会直接从缓存的<code>r.Form</code>映射中查找并返回对应的值。</li>
</ul>
</li>
</ol>
<p>这个智能的缓存机制是 Go 标准库中有意为之的设计，它使得处理表单提交（一个非常常见的场景）变得既健壮又便捷，尤其是在包含多层中间件的应用中，优雅地规避了“流只读一次”的问题。</p>
<h2 id="第五部分：结论-一场关于设计哲学的对话">第五部分：结论——一场关于设计哲学的对话</h2>
<p>最终，Go 和 Java 的方案都有效地解决了问题。Go 的方法更轻量、更直接，体现了其作为现代云原生语言的实用主义哲学。而 Java 的方法则更加经典、严谨，反映了其在大型企业级应用中对稳定性和设计模式的重视。</p>
<p>理解这两种方法的差异，不仅能帮助你写出更健壮的代码，更能让你深刻体会到不同技术生态背后的设计思想。</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>Go (net/http)</th>
<th>Java (Servlet API)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心思想</strong></td>
<td>直接修改公开字段，组合工具</td>
<td>遵循接口规范，使用设计模式包装</td>
</tr>
<tr>
<td><strong>实现机制</strong></td>
<td>组合 <code>io</code> 包提供的原生工具（如 <code>TeeReader</code>）</td>
<td>继承和重写（如 <code>HttpServletRequestWrapper</code>）</td>
</tr>
<tr>
<td><strong>代码简洁性</strong></td>
<td><strong>高</strong><br>代码更少，意图更直接</td>
<td><strong>低</strong><br>需要创建新类，代码冗长且&quot;仪式化&quot;</td>
</tr>
<tr>
<td><strong>设计哲学</strong></td>
<td><strong>实用主义与灵活性</strong><br>相信开发者，提供强大可组合的工具箱</td>
<td><strong>严谨与封装</strong><br>通过严格接口和模式保护对象状态，强制执行契约</td>
</tr>
</tbody>
</table>
<h1>数据库写入的“潜规则”：深入分析合并树与MPP架构</h1>
<p>“为什么我的数据库不建议高频写入？”</p>
<p>这是一个让许多开发者困惑的问题，尤其是在使用 ClickHouse、HBase、Elasticsearch 等现代数据系统时。人们常常将其归因于“列式存储”，但这其实是一个误解。</p>
<p>真正的答案深藏在数据库的存储引擎架构中。今天，我们将深入剖析两大主流架构——<strong>合并树（Merge-Tree）</strong> 和 <strong>MPP（Massively Parallel Processing）</strong>——揭示它们各自的写入机制、性能权衡，以及为什么它们都“偏爱”批量写入。</p>
<hr>
<h2 id="part-1-合并-是宿命-两种不同的合并架构">Part 1: “合并”是宿命——两种不同的合并架构</h2>
<p>磁盘上产生大量小文件，然后通过后台任务将其合并成大文件，是许多现代分析型数据库的共同选择。但这背后，其实有两种主流的实现路径。</p>
<h3 id="1-1-经典-lsm-tree：为高频更新而生的缓冲合并-hbase-rocksdb">1.1 经典 LSM-Tree：为高频更新而生的缓冲合并 (HBase, RocksDB)</h3>
<p>LSM-Tree（Log-Structured Merge-Tree）是 HBase、Cassandra、RocksDB 等系统的基石。</p>
<ul>
<li>
<p><strong>核心思想</strong>：通过 <strong>“内存缓冲 -&gt; 磁盘刷写 -&gt; 后台合并”</strong> 的三部曲，将所有随机写入请求巧妙地转换成对磁盘的顺序写入。</p>
<ol>
<li><strong>写入内存 (MemTable)</strong>：数据先写入内存中的有序结构，响应极快。</li>
<li><strong>刷写到磁盘 (Flush)</strong>：内存表满了之后，作为一个整体的、有序的 <code>SSTable</code> 文件顺序写入磁盘。</li>
<li><strong>后台合并 (Compaction)</strong>：后台任务不断将小 <code>SSTable</code> 合并成大 <code>SSTable</code>。</li>
</ol>
</li>
<li>
<p><strong>瓶颈</strong>：当写入过于频繁，导致后台合并的速度跟不上小文件生成的速度时，就会产生性能问题。但其 <strong><code>MemTable</code> 的存在，本身就是一种天然的缓冲和批量化机制</strong>。</p>
</li>
</ul>
<h3 id="1-2-clickhouse-mergetree：为极致分析而生的直接合并">1.2 ClickHouse MergeTree：为极致分析而生的直接合并</h3>
<p>ClickHouse 的 <code>MergeTree</code> 引擎虽然也依赖“合并”，但它走了一条更直接、更极致的道路。</p>
<ul>
<li>
<p><strong>核心思想</strong>：<strong>它不是一个标准的 LSM-Tree，因为它没有 MemTable！</strong></p>
<ol>
<li><strong>直接写入磁盘 Part</strong>：每一个 <code>INSERT INTO ...</code> 语句，无论大小，都会被 ClickHouse 直接在文件系统上组织成一个或多个新的、不可变的“数据部件（Part）”。</li>
<li><strong>后台合并 (Merge)</strong>：和 LSM-Tree 一样，后台线程会持续地将这些小 Part 合并成更大的 Part，以保证查询性能。</li>
</ol>
</li>
<li>
<p><strong>瓶颈</strong>：这种设计的后果是，<strong><code>MergeTree</code> 对写入的“批量性”要求比经典 LSM-Tree 更高</strong>。如果进行高频、小批量的 <code>INSERT</code>，就等于直接在磁盘上制造了海量的小文件，这会立刻给后台合并带来巨大压力，并迅速拖垮查询性能。ClickHouse 把“攒批”的责任完全交给了用户（或通过 <code>async_insert</code> 等功能辅助完成）。</p>
</li>
</ul>
<blockquote>
<p><strong>一句话总结</strong>：经典 LSM-Tree 内置了写入缓冲，而 ClickHouse 的 MergeTree 则需要你（或其异步功能）在外部完成缓冲。</p>
</blockquote>
<hr>
<h2 id="part-2-mpp-架构的另一种权衡-aws-redshift">Part 2: MPP 架构的另一种权衡 - AWS Redshift</h2>
<p>现在，我们来看另一个分析型数据库巨头：AWS Redshift。它也推荐批量写入，但原因与上述的合并架构完全不同。</p>
<h3 id="架构剖析：mpp-列式存储">架构剖析：MPP + 列式存储</h3>
<p>Redshift 是一个典型的 <strong>MPP（Massively Parallel Processing，大规模并行处理）</strong> 架构的列式数据库。</p>
<ul>
<li><strong>MPP 架构</strong>：一个 Redshift 集群由一个**领导节点（Leader Node）<strong>和多个</strong>计算节点（Compute Nodes）**组成。领导节点负责接收查询、优化并生成执行计划，然后将任务分发给所有计算节点并行执行。数据被分散存储在各个计算节点上。</li>
<li><strong>列式存储</strong>：与 ClickHouse 样，Redshift 也采用列式存储，这使得它在执行分析类查询时能获得极高的 I/O 效率。</li>
</ul>
<p><strong>关键区别</strong>：Redshift 的底层<strong>不是合并树架构</strong>。它更像一个传统的、被分布式改造过的数据库，没有 MemTable 和后台合并的概念。</p>
<h3 id="写入机制：为-批量加载-而设计">写入机制：为“批量加载”而设计</h3>
<p>Redshift 的写入性能瓶颈，源于其 MPP 架构的协调成本。</p>
<ul>
<li>
<p><strong>最佳实践 <code>COPY</code> 命令</strong>：Redshift 最高效的写入方式是使用 <code>COPY</code> 命令，从 S3 等存储服务上进行大规模的并行数据加载。此时，每个计算节点会独立、并行地从 S3 拉取属于自己的那部分数据，效率极高。</p>
</li>
<li>
<p><strong>低效的单条 <code>INSERT</code></strong>：当你执行一条 <code>INSERT INTO ... VALUES (...)</code> 语句时，会发生以下情况：</p>
<ol>
<li>请求首先到达领导节点。</li>
<li>领导节点需要处理这个事务，并将其分发给存储对应数据的计算节点。</li>
<li>这涉及到跨节点的事务协调、加锁、数据分发等一系列开销。</li>
</ol>
</li>
</ul>
<p>为一条小小的记录，去启动整个集群的分布式事务流程，其开销是巨大的。这就好比为了运送一箱矿泉水，却启动了一整列高铁。</p>
<blockquote>
<p><strong>一个简单的类比</strong>：</p>
<ul>
<li><strong>合并树架构</strong> 的写入瓶颈在于**“写后”的家务活**（后台合并）。</li>
<li><strong>Redshift (MPP)</strong> 的写入瓶颈在于**“写入时”的沟通成本**（分布式事务协调）。</li>
</ul>
</blockquote>
<hr>
<h2 id="结论：殊途同归的-批量写入">结论：殊途同归的“批量写入”</h2>
<p>我们最终得出一个更精确的结论：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据库类型</th>
<th style="text-align:left">代表</th>
<th style="text-align:left">核心架构</th>
<th style="text-align:left">写入瓶颈根源</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>经典 LSM-Tree</strong></td>
<td style="text-align:left">HBase, Cassandra</td>
<td style="text-align:left">Log-Structured Merge-Tree (含MemTable)</td>
<td style="text-align:left"><strong>写后维护成本</strong>：后台合并（Compaction）跟不上由 <strong>MemTable 刷写</strong> 产生的小文件速度。</td>
</tr>
<tr>
<td style="text-align:left"><strong>合并树 (MergeTree)</strong></td>
<td style="text-align:left">ClickHouse</td>
<td style="text-align:left">类 LSM 的合并树 (无MemTable)</td>
<td style="text-align:left"><strong>写后维护成本</strong>：后台合并（Merge）跟不上由 <strong>直接 INSERT</strong> 产生的小文件（Parts）速度。</td>
</tr>
<tr>
<td style="text-align:left"><strong>MPP (非合并树)</strong></td>
<td style="text-align:left">AWS Redshift, Greenplum</td>
<td style="text-align:left">Massively Parallel Processing</td>
<td style="text-align:left"><strong>写入时协调成本</strong>：分布式事务和数据分发对于单条写入来说开销过大。</td>
</tr>
</tbody>
</table>
<p>无论是哪种架构，它们都通过各自的方式，最终指向了同一个最佳实践——<strong>“批量、低频次”地写入数据</strong>。</p>
<p>作为开发者和架构师，理解这个“为什么”至关重要。它不仅能帮助我们正确地使用这些强大的工具，避免性能陷阱，更能在技术选型时，根据业务的真实写入模式（是需要高频实时写入，还是可以接受批量延迟导入），做出最精准的决策。</p>
<h1>复制算法与架构</h1>
<h1>副本江湖：PacificA、Elasticsearch、Kafka、Pulsar 的“运输队”比喻</h1>
<p>想象有四支<strong>商队</strong>，都要把一车<strong>金子（数据）<strong>从北京安全送到上海，且沿途不能丢、不能假。<br>
它们的区别，就像四支运输队的</strong>组织方式</strong>：</p>
<table>
<thead>
<tr>
<th>商队</th>
<th>运输队比喻</th>
<th>核心梗概</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>原始 PacificA</strong></td>
<td><strong>皇家镖局</strong></td>
<td>只有一位总镖头（Primary），所有镖师（Secondaries）<strong>同时签收</strong>后才算送达；总镖头挂了，**御赐令牌（Configuration Manager）**立刻指认新镖头。</td>
</tr>
<tr>
<td><strong>Elasticsearch</strong></td>
<td><strong>驿站接力</strong></td>
<td>每座驿站（Shard）都有驿丞（Primary）和驿卒（Replicas）。驿丞写好<strong>奏折（Index）</strong>，驿卒抄完才算存档。驿丞病了，**兵部（Master Node）**立刻换驿丞，奏折继续。</td>
</tr>
<tr>
<td><strong>Kafka</strong></td>
<td><strong>驿站车队</strong></td>
<td>一条官道（Partition）只有一辆<strong>头车（Leader）</strong>，后面跟着<strong>护卫车（ISR）</strong>。头车把<strong>货单（Record Batch）<strong>写进</strong>驿站账本（Log Segment）</strong>，护卫车抄完账本才打勾。头车翻车，**驿站站长（Controller）**立刻让护卫车当新车头。</td>
</tr>
<tr>
<td><strong>Pulsar</strong></td>
<td><strong>码头+船队</strong></td>
<td><strong>码头（Broker）<strong>只负责</strong>调度</strong>，<strong>船队（Bookie）<strong>负责运货。每箱货都</strong>拆成多船（Ledger Fragment）</strong>，**船长（Bookie Ensemble）**各自记一份。码头沉了，换码头即可，<strong>船队不动</strong>。</td>
</tr>
</tbody>
</table>
<h2 id="架构与节点对比表">架构与节点对比表</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>PacificA 原始</th>
<th>Elasticsearch</th>
<th>Kafka</th>
<th>Pulsar</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>计算节点</strong></td>
<td>Primary</td>
<td>Data Node</td>
<td>Broker</td>
<td>Broker</td>
</tr>
<tr>
<td><strong>存储节点</strong></td>
<td>Secondary</td>
<td>Data Node（本地分片）</td>
<td>Broker（本地日志）</td>
<td>Bookie</td>
</tr>
<tr>
<td><strong>元数据节点</strong></td>
<td>Configuration Manager</td>
<td>Master Node</td>
<td>Controller (+ZK/KRaft)</td>
<td>Zookeeper</td>
</tr>
<tr>
<td><strong>副本粒度</strong></td>
<td>任意对象</td>
<td>Shard</td>
<td>Partition</td>
<td>Ledger Fragment</td>
</tr>
<tr>
<td><strong>一致性协议</strong></td>
<td>强一致（Write-All）</td>
<td>ES 级 PacificA 变体</td>
<td>ISR 机制（PacificA-like）</td>
<td>Quorum + Ensemble</td>
</tr>
<tr>
<td><strong>故障恢复</strong></td>
<td>令牌换 Primary</td>
<td>Master 换 Primary</td>
<td>Controller 换 Leader</td>
<td>Broker 无状态，Bookie 自愈</td>
</tr>
</tbody>
</table>
<h2 id="mermaid-架构速览">Mermaid 架构速览</h2>
<h3 id="原始-pacifica">原始 PacificA</h3>
<pre><code class="hljs mermaid">graph TD
    CM[Configuration Manager]
    P[Primary] --&gt; S1[Secondary1]
    P --&gt; S2[Secondary2]
    P --&gt; S3[Secondary3]
    CM -.-&gt; P
    CM -.-&gt; S1
    CM -.-&gt; S2
    CM -.-&gt; S3</code></pre>
<h3 id="elasticsearch">Elasticsearch</h3>
<pre><code class="hljs mermaid">graph TD
    Master[Master Node]
    P[Primary Shard] --&gt; R1[Replica1]
    P --&gt; R2[Replica2]
    Master -.-&gt; P
    Master -.-&gt; R1
    Master -.-&gt; R2</code></pre>
<h3 id="kafka">Kafka</h3>
<pre><code class="hljs mermaid">graph TD
    Controller[Controller]
    L[Leader Broker] --&gt; F1[Follower1]
    L --&gt; F2[Follower2]
    Controller -.-&gt; L
    Controller -.-&gt; F1
    Controller -.-&gt; F2</code></pre>
<h3 id="pulsar">Pulsar</h3>
<pre><code class="hljs mermaid">graph TD
    ZK[Zookeeper]
    B[Broker] --&gt; B1[Bookie1]
    B --&gt; B2[Bookie2]
    B --&gt; B3[Bookie3]
    ZK -.-&gt; B
    ZK -.-&gt; B1
    ZK -.-&gt; B2
    ZK -.-&gt; B3</code></pre>
<h1>原码 · 反码 · 补码：环形数轴 + 基准锤教程</h1>
<h2 id="1-背景">1  背景</h2>
<p>CPU 只有加法器，没有减法器。为了让 <code>A - B</code> 直接变成 <code>A + (-B)</code>，人们发明了<strong>补码</strong>；原码、反码只是推导脚手架。</p>
<h2 id="2-角色速览">2  角色速览</h2>
<table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
<th>常驻硬件</th>
<th>8 位 -5 示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>原码</td>
<td>人类直观写法（符号位+绝对值）</td>
<td>❌</td>
<td>1000 0101</td>
</tr>
<tr>
<td>反码</td>
<td>中间步骤（负数除符号位外取反）</td>
<td>❌</td>
<td>1111 1010</td>
</tr>
<tr>
<td>补码</td>
<td>CPU 真正使用的编码</td>
<td>✅</td>
<td>1111 1011</td>
</tr>
</tbody>
</table>
<h2 id="3-符号位">3  符号位</h2>
<p>最高位 = 0 → 正；最高位 = 1 → 负。</p>
<h2 id="4-三码计算流程-8-位">4  三码计算流程（8 位）</h2>
<ul>
<li><strong>正数</strong>：三码相同</li>
<li><strong>负数</strong>：符号位不动 → 其余位取反 → 反码 + 1</li>
</ul>
<h2 id="5-环形数轴-基准锤">5  环形数轴 + 基准锤</h2>
<p>把 256 个无符号值 <code>0…255</code> 重新贴到整数轴上：</p>
<ul>
<li>无符号:  0  1 …127  128 129 …255</li>
<li>重新标:  0  1 …127 −128 −127 …−1</li>
</ul>
<p>在这个设定里，-0，即10000000是-128。这个算法表明取反加一并不能算出全部的补码，也不代表补码的真正定义，只是一种常用计算方法。</p>
<ul>
<li>基准锤权重：<strong>-128</strong></li>
<li>公式：<br>
<code>value = -b7·128 + Σ(b6…b0)·2^i</code>即“值 = -128 × 符号位 + 其余七位按权展开”，这可以从1111 1011还原出-5。</li>
</ul>
<h2 id="6-为什么-反码-1">6  为什么“反码 + 1”</h2>
<ul>
<li>反码出现 <strong>双零</strong>（+0 = 0000 0000，−0 = 1111 1111），硬件无法唯一判断结果 0。</li>
<li>把反码整体 <strong>+1</strong> 后：
<ul>
<li>负零编码空位被 −1 顶替：正负零的补码是一样的</li>
<li>负数区间扩展：−128…−1</li>
</ul>
</li>
<li>零唯一、加法统一 → 补码诞生</li>
</ul>
<h2 id="7-补码-原码">7  补码 ↔ 原码</h2>
<ul>
<li><strong>补码再补一次</strong>即得原码（负数时）。
<ul>
<li>8 位示例：补码 <code>1111 1011</code> → 原码 <code>1000 0101</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left"><strong>公式/操作</strong></th>
<th style="text-align:left"><strong>输入 → 输出</strong></th>
<th style="text-align:left"><strong>解决的问题</strong></th>
<th style="text-align:left"><strong>典型场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>值 = -128 × 符号位 + 其余七位按权展开</code></td>
<td style="text-align:left">8 位补码 → 带符号十进制值</td>
<td style="text-align:left">“CPU 里存的是补码，我想知道它到底代表几”</td>
<td style="text-align:left">调试器、日志、人眼读数</td>
</tr>
<tr>
<td style="text-align:left"><strong>补码再补一次（取反+1）</strong></td>
<td style="text-align:left">8 位补码 → 原码的 8 位串</td>
<td style="text-align:left">“我想看看这个补码对应的人类直观写法（原码）长什么样”</td>
<td style="text-align:left">教学、手写演算</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>数学等价性说明</strong>：这两种从补码获取其代表十进制数值的方法在数学上是完全等价的。无论是使用按权展开公式 <code>值 = -128 × 符号位 + 其余七位按权展开</code> 计算，还是对补码再次执行“取反加一”操作来观察其对应原码的数值部分，最终都指向同一个十进制数。这源于补码系统的设计，其定义本身就保证了这种一致性。</p>
</blockquote>
<p>这个算法的本质是：<strong>你是我的补码，我也是你的补码</strong>。所以大家既可以用逆操作算补码，也可以用正操作算补码。</p>
<h2 id="8-减法即加法">8  减法即加法</h2>
<p>7 - 5<br>
= 0000 0111 + 1111 1011   // 补码相加<br>
= 1 0000 0010             // 溢出丢弃<br>
= 0000 0010 = 2</p>
<blockquote>
<p><strong>同余数概念</strong>：计算机中的补码运算可以看作是在模（Modulo）下的运算。例如，8位补码的模是256。计算 <code>7 - 5</code> 时，实际上是 <code>7 + (-5)</code>。-5在8位补码中表示为 <code>1111 1011</code>，其无符号值是251。所以计算 <code>7 + 251 = 258</code>。由于在8位系统中模是256，结果 <code>258</code> 与 <code>2</code> 在模256下是同余的（258 ≡ 2 (mod 256)），即它们除以256的余数相同。因此，丢弃溢出位的操作等价于取模运算，保证了结果的正确性。</p>
</blockquote>
<h2 id="9-速查表-8-位">9 速查表（8 位）</h2>
<table>
<thead>
<tr>
<th>十进制</th>
<th>补码</th>
<th>反码</th>
<th>原码</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0000 0000</td>
<td>0000 0000</td>
<td>0000 0000</td>
</tr>
<tr>
<td>1</td>
<td>0000 0001</td>
<td>0000 0001</td>
<td>0000 0001</td>
</tr>
<tr>
<td>-1</td>
<td>1111 1111</td>
<td>1111 1110</td>
<td>1000 0001</td>
</tr>
<tr>
<td>127</td>
<td>0111 1111</td>
<td>0111 1111</td>
<td>0111 1111</td>
</tr>
<tr>
<td>-128</td>
<td>1000 0000</td>
<td>-</td>
<td>-不存在源码</td>
</tr>
</tbody>
</table>
<p>-128 的补码 = -1 + -127 的补码</p>
<h2 id="10-口诀">10 口诀</h2>
<p>正数三码同，负数“反+1”，补码再补得原码，基准锤是 −128。可以把补码展开成10进制。</p>
<h2 id="11-java-位移运算符">11 Java 位移运算符</h2>
<p>Java 提供了三种位移运算符，它们直接操作整数的二进制位。</p>
<table>
<thead>
<tr>
<th style="text-align:left">运算符</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">规则</th>
<th style="text-align:left">示例 (8位, A=12, B=-12)</th>
<th style="text-align:left">用途/解决的问题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>&lt;&lt;</code></td>
<td style="text-align:left">左移</td>
<td style="text-align:left">所有位左移，右侧补0</td>
<td style="text-align:left"><code>A &lt;&lt; 1</code> = <code>00001100 &lt;&lt; 1</code> = <code>00011000</code> (24)</td>
<td style="text-align:left">快速乘以2的幂次</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;&gt;</code></td>
<td style="text-align:left">带符号右移 (算术右移)</td>
<td style="text-align:left">所有位右移，左侧补符号位</td>
<td style="text-align:left"><code>A &gt;&gt; 1</code> = <code>00001100 &gt;&gt; 1</code> = <code>00000110</code> (6)<br><code>B &gt;&gt; 1</code> = <code>11110100 &gt;&gt; 1</code> = <code>11111010</code> (-6)</td>
<td style="text-align:left">快速除以2的幂次（向下取整）</td>
</tr>
<tr>
<td style="text-align:left"><code>&gt;&gt;&gt;</code></td>
<td style="text-align:left">无符号右移 (逻辑右移)</td>
<td style="text-align:left">所有位右移，左侧补0</td>
<td style="text-align:left"><code>A &gt;&gt;&gt; 1</code> = <code>00001100 &gt;&gt;&gt; 1</code> = <code>00000110</code> (6)<br><code>B &gt;&gt;&gt; 1</code> = <code>11110100 &gt;&gt;&gt; 1</code> = <code>01111010</code> (122)</td>
<td style="text-align:left">处理无符号数或确保高位补0，常用于位掩码操作</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong><code>&gt;&gt;</code> 和 <code>&gt;&gt;&gt;</code> 的关键区别</strong>：对于<strong>正数</strong>，<code>&gt;&gt;</code> 和 <code>&gt;&gt;&gt;</code> 的结果相同，因为符号位是 0，补 0 和补符号位效果一样。对于<strong>负数</strong>，两者结果不同：<code>&gt;&gt;</code> 会用符号位（1）填充高位，保持结果为负数；而 <code>&gt;&gt;&gt;</code> 会用 0 填充高位，结果变为一个很大的正数。这一点在处理有符号数和无符号数时非常重要。</p>
<p><strong>操作本质</strong>：从位操作的纯粹性来看，<code>&lt;&lt;</code> 和 <code>&gt;&gt;&gt;</code> 可以视为&quot;纯粹的位移操作&quot;，因为它们在移位时总是用 0 来填充空位。而 <code>&gt;&gt;</code> 是一种&quot;智能&quot;的算术操作，它会根据原数的符号来决定填充位，以保持数值的正负性。</p>
</blockquote>
<h1>IEEE 754 浮点数：科学计数法的二进制实现</h1>
<h2 id="1-背景">1 背景</h2>
<p>计算机用有限二进制位表示实数时，需平衡 <strong>范围</strong> 与 <strong>精度</strong>。IEEE 754 标准（1985 年确立）通过三组件结构解决此问题，统一了不同硬件平台的浮点计算。</p>
<h2 id="2-角色速览">2 角色速览</h2>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
<th>双精度(64 位)</th>
<th>示例 (-7.25)</th>
</tr>
</thead>
<tbody>
<tr>
<td>符号位 S</td>
<td>正负标识</td>
<td>1 位</td>
<td>1（负数）</td>
</tr>
<tr>
<td>指数 E</td>
<td>缩放权重（偏移编码）</td>
<td>11 位（偏移 1023）</td>
<td>10000000010（实际指数 2）</td>
</tr>
<tr>
<td>尾数 M</td>
<td>有效数字（隐藏前导 1）</td>
<td>52 位</td>
<td>1101000…0（存储 1.1101 的小数部分）</td>
</tr>
</tbody>
</table>
<p>注：尾数隐含 1. 前缀，实际精度 = 53 位（52 显式 + 1 隐式）。</p>
<h2 id="3-核心公式">3 核心公式</h2>
<p>值 = (-1)^S × (1 + Σ_{i=1}^{52} b_i·2^{-i}) × 2^(E-1023)</p>
<h3 id="示例计算-7-25">示例计算 -7.25</h3>
<ul>
<li>转二进制：-111.01₂ = -1.1101₂ × 2²</li>
<li>拆分组件
<ul>
<li>S = 1</li>
<li>E = 2 + 1023 = 1025 = 10000000001₂</li>
<li>M = 1101000…0（取小数部分 1101）</li>
</ul>
</li>
<li>完整编码</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">1 10000000001 1101000000000000000000000000000000000000000000000000<br></code></pre></td></tr></table></figure>
<h2 id="4-特殊值：突破常规的编码">4 特殊值：突破常规的编码</h2>
<table>
<thead>
<tr>
<th>指数 E</th>
<th>尾数 M</th>
<th>含义</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>全 0</td>
<td>全 0</td>
<td>±0</td>
<td>符号位区分正负零（通常视为相等）</td>
</tr>
<tr>
<td>全 0</td>
<td>非 0</td>
<td>非规格化数</td>
<td>尾数无隐藏 1，指数固定为 1-1023，平滑接近 0（最小可表示 ±4.9×10⁻³²⁴）</td>
</tr>
<tr>
<td>全 1</td>
<td>全 0</td>
<td>±∞</td>
<td>如 1.0/0.0 的结果</td>
</tr>
<tr>
<td>全 1</td>
<td>非 0</td>
<td>NaN</td>
<td>无效操作（如 √(-1) 或 0/0）</td>
</tr>
</tbody>
</table>
<h2 id="5-精度标尺与陷阱">5 精度标尺与陷阱</h2>
<h3 id="5-1-精度范围">5.1 精度范围</h3>
<ul>
<li>
<p>整数是离散且可以精确的。</p>
</li>
<li>
<p><code>long</code>（64 位有符号）可完整表示 19 位十进制整数（最大 2⁶³-1 ≈ 9.22×10¹⁸），日常取 18 位作为完全精确的保守值。</p>
</li>
<li>
<p><code>double</code> 只能保证 15 位十进制有效数字，第 16 位开始就可能失真。</p>
</li>
<li>
<p>理论精度：15–17 位十进制数</p>
</li>
<li>
<p>可靠精度：前 15 位（16 位后可能舍入失真）</p>
</li>
</ul>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text"># 双精度存储 0.1 的实际值<br>0.1000000000000000055511151231257827021181583404541015625<br></code></pre></td></tr></table></figure>
<h3 id="5-2-经典陷阱">5.2 经典陷阱</h3>
<h4 id="累加误差">累加误差</h4>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">sum</span> = <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10_000_000</span>):<br>    <span class="hljs-built_in">sum</span> += <span class="hljs-number">0.1</span>   <span class="hljs-comment"># 结果 ≈ 999999.9444888305（误差 0.055%）</span><br></code></pre></td></tr></table></figure>
<h4 id="大数吃小数">大数吃小数</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">double</span> <span class="hljs-variable">large</span> <span class="hljs-operator">=</span> <span class="hljs-number">1e18</span>;<br><span class="hljs-type">double</span> <span class="hljs-variable">small</span> <span class="hljs-operator">=</span> <span class="hljs-number">1.0</span>;<br>System.out.println(large + small == large);  <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<h4 id="安全比较方案">安全比较方案</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">float_equal</span><span class="hljs-params">(<span class="hljs-type">double</span> a, <span class="hljs-type">double</span> b, <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-9</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">fabs</span>(a - b) &lt; eps;  <span class="hljs-comment">// 容忍误差</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="javascript-与后端-long-的精度丢失">JavaScript 与后端 Long 的精度丢失</h3>
<p>JavaScript 所有数字均采用 IEEE 754 双精度格式。<br>
最大安全整数：<code>Number.MAX_SAFE_INTEGER = 2^53 - 1 = 9007199254740991</code><br>
超过此值，整数无法一对一映射到浮点数，导致精度丢失。<br>
后端 Long 最大值为 9223372036854775807，远超安全范围，因此前端看到的 ID 可能与数据库不一致。</p>
<h4 id="示例">示例</h4>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">812782555915911412</span>); <span class="hljs-comment">// 输出 812782555915911400</span><br></code></pre></td></tr></table></figure>
<h4 id="解决方案">解决方案</h4>
<p>将 Long 作为字符串传输，前端不直接参与数值运算。<br>
需要运算时，使用 BigInt、bigint/bignum 等库。</p>
<h2 id="6-运算过程：四步平衡术">6 运算过程：四步平衡术</h2>
<ul>
<li>对阶：小指数向大指数对齐（尾数右移损失精度）
<ul>
<li>例：<code>1.1₂×2³ + 1.01₂×2¹ → 1.1₂×2³ + 0.0101₂×2³</code></li>
</ul>
</li>
<li>尾数运算：对齐后加减或乘除</li>
<li>规格化：调整至 1.M 形式（例<code>10.11₂×2³ → 1.011₂×2⁴</code>）</li>
<li>舍入：四种模式</li>
</ul>
<table>
<thead>
<tr>
<th>模式</th>
<th>规则</th>
<th>场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>就近舍入（默认）</td>
<td>四舍五入到最近值，平局取偶</td>
<td>科学计算</td>
</tr>
<tr>
<td>向零舍入</td>
<td>截断小数部分</td>
<td>金融计算</td>
</tr>
<tr>
<td>向 +∞ 舍入</td>
<td>天花板函数</td>
<td>区间分析</td>
</tr>
<tr>
<td>向 -∞ 舍入</td>
<td>地板函数</td>
<td>数值积分</td>
</tr>
</tbody>
</table>
<h2 id="7-编程实战：精度保卫战">7 编程实战：精度保卫战</h2>
<h3 id="7-1-内存布局查看-c">7.1 内存布局查看（C++）</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print_double_bits</span><span class="hljs-params">(<span class="hljs-type">double</span> d)</span> </span>&#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>* p = (<span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span>*)&amp;d;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">63</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%llu&quot;</span>, (*p &gt;&gt; i) &amp; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">63</span> || i == <span class="hljs-number">52</span>) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; &quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出 -7.25：1 10000000001 1101000000000000...0</span><br></code></pre></td></tr></table></figure>
<h3 id="7-2-跨语言精度方案">7.2 跨语言精度方案</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>方案</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>前端 JS 大整数</td>
<td>BigInt / String</td>
<td><code>BigInt(&quot;812782555915911412&quot;)</code></td>
</tr>
<tr>
<td>Java 超长整型</td>
<td><code>BigInteger</code></td>
<td><code>new BigInteger(&quot;9999999999999999999&quot;)</code></td>
</tr>
<tr>
<td>金融小数</td>
<td>十进制库</td>
<td><code>Python Decimal('0.1') + Decimal('0.2')</code></td>
</tr>
</tbody>
</table>
<h2 id="8-速查表：双精度关键边界">8 速查表：双精度关键边界</h2>
<table>
<thead>
<tr>
<th>类型</th>
<th>十六进制编码</th>
<th>十进制值</th>
</tr>
</thead>
<tbody>
<tr>
<td>最大规约数</td>
<td>7FEFFFFFFFFFFFFF</td>
<td>≈ 1.7976931348623157 × 10³⁰⁸</td>
</tr>
<tr>
<td>最小规约数</td>
<td>0010000000000000</td>
<td>≈ 2.2250738585072014 × 10⁻³⁰⁸</td>
</tr>
<tr>
<td>最大非规约数</td>
<td>000FFFFFFFFFFFFF</td>
<td>≈ 2.2250738585072009 × 10⁻³⁰⁸</td>
</tr>
<tr>
<td>+∞</td>
<td>7FF0000000000000</td>
<td>INF</td>
</tr>
<tr>
<td>NaN</td>
<td>7FF8000000000000</td>
<td>NaN</td>
</tr>
</tbody>
</table>
<h2 id="9-设计哲学与未来">9 设计哲学与未来</h2>
<ul>
<li>工程妥协：用 53 位尾数逼近无限实数，牺牲绝对精度换取动态范围（±10³⁰⁸）。</li>
<li>硬件友好：对阶、规格化步骤适配并行电路设计。</li>
<li>新兴趋势：
<ul>
<li>AI 低精度格式（bfloat16：8 位指数 + 7 位尾数）</li>
<li>十进制浮点数（IEEE 754-2008）</li>
<li>量子比特表示（理论阶段）</li>
</ul>
</li>
</ul>
<h2 id="终极口诀">终极口诀</h2>
<p>符号指数尾数位，隐含前导 1<br>
对阶舍入规格化，三步定结果<br>
大数慎吃小数，比较用容差<br>
超限转字符串，高精选库解</p>
<h2 id="ieee-754-的-float-公式">ieee 754 的 float 公式</h2>
<p>一个 32 比特长度的二进制数为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>b</mi><mn>31</mn></msub><msub><mi>b</mi><mn>30</mn></msub><msub><mi>b</mi><mn>29</mn></msub><mo>…</mo><msub><mi>b</mi><mn>2</mn></msub><msub><mi>b</mi><mn>1</mn></msub><msub><mi>b</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">b_{31} b_{30} b_{29} \ldots b_{2} b_{1} b_{0} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">9</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>根据 IEEE 754 标准，32-bit 长度的 float 由以下三个部分构成：</p>
<ul>
<li><strong>符号位 S</strong>：占 1 位，对应 $ b_{31} $</li>
<li><strong>指数位 E</strong>：占 8 位，对应 $ b_{30} b_{29} \ldots b_{23} $</li>
<li><strong>分数位 N</strong>：占 23 位，对应 $ b_{22} b_{21} \ldots b_{0} $</li>
</ul>
<p>二进制数 float 对应值的计算方法为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>v</mi><mi>a</mi><mi>l</mi><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><msub><mi>b</mi><mn>31</mn></msub></msup><mo>×</mo><msup><mn>2</mn><mrow><mo fence="true">(</mo><mo stretchy="false">(</mo><msub><mi>b</mi><mn>30</mn></msub><msub><mi>b</mi><mn>29</mn></msub><mo>…</mo><msub><mi>b</mi><mn>23</mn></msub><msub><mo stretchy="false">)</mo><mn>2</mn></msub><mo>−</mo><mn>127</mn><mo fence="true">)</mo></mrow></msup><mo>×</mo><msub><mrow><mo fence="true">(</mo><mn>1.</mn><msub><mi>b</mi><mn>22</mn></msub><msub><mi>b</mi><mn>21</mn></msub><mo>…</mo><msub><mi>b</mi><mn>0</mn></msub><mo fence="true">)</mo></mrow><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">val = (-1)^{b_{31}}
      \times 2^{\left( (b_{30} b_{29} \ldots b_{23})_2 - 127 \right)}
      \times \left( 1.b_{22} b_{21} \ldots b_{0} \right)_2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">v</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.899108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0213299999999998em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="minner mtight"><span class="mopen mtight delimcenter" style="top:0em;"><span class="mtight">(</span></span><span class="mopen mtight">(</span><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">9</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="minner mtight">…</span><span class="mord mtight"><span class="mord mathdefault mtight">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mclose mtight"><span class="mclose mtight">)</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">7</span><span class="mclose mtight delimcenter" style="top:0em;"><span class="mtight">)</span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0497em;vertical-align:-0.29969999999999997em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;">(</span><span class="mord">1</span><span class="mord">.</span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;">)</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151408em;"><span style="top:-2.4003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29969999999999997em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<p>转化到十进制下的计算公式为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow><mi mathvariant="normal">v</mi><mi mathvariant="normal">a</mi><mi mathvariant="normal">l</mi></mrow><mo>=</mo><mo stretchy="false">(</mo><mo>−</mo><mn>1</mn><msup><mo stretchy="false">)</mo><mi>S</mi></msup><mo>×</mo><msup><mn>2</mn><mrow><mi>E</mi><mo>−</mo><mn>127</mn></mrow></msup><mo>×</mo><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathrm{val} = (-1)^{S} \times 2^{E-127} \times (1 + N) 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathrm" style="margin-right:0.01389em;">v</span><span class="mord mathrm">a</span><span class="mord mathrm">l</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1413309999999999em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">−</span><span class="mord">1</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8913309999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">S</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.974661em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.891331em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05764em;">E</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mord mtight">2</span><span class="mord mtight">7</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span></span></span></span></span></p>
<p>其中各项的取值范围为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">}</mo><mo separator="true">,</mo><mspace width="1em"/><mi>E</mi><mo>∈</mo><mo stretchy="false">{</mo><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><mn>254</mn><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">S \in \{0,1\}, \quad E \in \{1,2,\ldots,254\} 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">}</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace" style="margin-right:1em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">E</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">{</span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mord">5</span><span class="mord">4</span><span class="mclose">}</span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>+</mo><mi>N</mi><mo stretchy="false">)</mo><mo>=</mo><mrow><mo fence="true">(</mo><mn>1</mn><mo>+</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mn>23</mn></munderover><msub><mi>b</mi><mrow><mn>23</mn><mo>−</mo><mi>i</mi></mrow></msub><mo>⋅</mo><msup><mn>2</mn><mrow><mo>−</mo><mi>i</mi></mrow></msup><mo fence="true">)</mo></mrow><mo>∈</mo><mrow><mo fence="true">[</mo><mn>1</mn><mo separator="true">,</mo><mtext> </mtext><mn>2</mn><mo>−</mo><msup><mn>2</mn><mrow><mo>−</mo><mn>23</mn></mrow></msup><mo fence="true">]</mo></mrow></mrow><annotation encoding="application/x-tex">(1+N) = \left( 1 + \sum_{i=1}^{23} b_{23-i} \cdot 2^{-i} \right) \in \left[ 1,\  2 - 2^{-23} \right] 
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.0787820000000004em;vertical-align:-1.277669em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size4">(</span></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8011130000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mtight">3</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.874664em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size4">)</span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.214118em;vertical-align:-0.35001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">[</span></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mspace"> </span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.864108em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">2</span><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">]</span></span></span></span></span></span></span></p>
<h1>从码点到字节：彻底吃透 Java 中的字符串、字符与编码</h1>
<p>在 Java 开发中，字符串和字符的处理是一个常见但又容易让人困惑的话题。本文将从 Unicode 码点开始，逐步深入到 Java 中的 <code>char</code> 类型、<code>String</code> 类，以及字符集（Charset）和编码（Encoding）的概念，帮助你彻底理解它们之间的关系和区别。</p>
<h2 id="1-unicode-码点-code-point">1. Unicode 码点（Code Point）</h2>
<p>Unicode 是一个国际标准，为世界上每一种字符分配了一个唯一的编号，称为<strong>码点（Code Point）</strong>。码点的范围从 <code>U+0000</code> 到 <code>U+10FFFF</code>，总共可以表示 1,114,112 个字符。</p>
<ul>
<li><strong>定义</strong>：Unicode 码点是一个 21 位的无符号整数，用于唯一标识一个字符。</li>
<li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">cat</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x1F431</span>; <span class="hljs-comment">// 🐱 的码点</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="2-java-中的-char-类型-与-byte-类型的字节差别">2. Java 中的 <code>char</code> 类型 与 <code>byte</code> 类型的字节差别</h2>
<p>理解 Java 中的字符处理，首先要明确 <code>char</code> 和 <code>byte</code> 这两个基本数据类型的差异：</p>
<ul>
<li><strong><code>byte</code></strong>:
<ul>
<li>是一个 8 位（1 字节）的有符号整数。</li>
<li>取值范围是 -128 到 127。</li>
<li>主要用于存储原始的二进制数据或使用单字节编码（如 ASCII, ISO-8859-1）的文本。</li>
</ul>
</li>
<li><strong><code>char</code></strong>:
<ul>
<li>是一个 16 位（2 字节）的无符号整数。</li>
<li>取值范围是 <code>'\u0000'</code> (0) 到 <code>'\uffff'</code> (65,535)。</li>
<li>专门设计用于存储字符，其内部编码是 <strong>UTF-16</strong>。</li>
<li>Java 选择 16 位是为了能够表示 Unicode 字符集中的大部分常用字符，特别是基本多文种平面 (BMP) 上的字符。</li>
</ul>
</li>
</ul>
<p><strong>核心区别</strong>：<code>char</code> 的大小是 <code>byte</code> 的两倍。这使得 <code>char</code> 能够直接表示 BMP 中的字符，但也引出了如何表示 BMP 之外字符的问题。</p>
<h2 id="3-unicode-平面-bmp-增补字符与代理对">3. Unicode 平面、BMP、增补字符与代理对</h2>
<p>为了容纳超过 65,536 个字符，Unicode 标准将整个码点范围（<code>U+0000</code> 到 <code>U+10FFFF</code>）划分为多个 <strong>平面 (Planes)</strong>。</p>
<ul>
<li><strong>基本多文种平面 (Basic Multilingual Plane - BMP)</strong>:
<ul>
<li>码点范围：<code>U+0000</code> 到 <code>U+FFFF</code>。</li>
<li>包含了世界上大多数常用字符，如拉丁字母、汉字、日文假名、阿拉伯文等。</li>
</ul>
</li>
<li><strong>增补平面 (Supplementary Planes)</strong>:
<ul>
<li>码点范围：<code>U+10000</code> 到 <code>U+10FFFF</code>。</li>
<li>包含了较少使用的字符，如历史文字、特殊符号、一些 emoji 等。这些码点超出了 <code>char</code> 类型能直接表示的 16 位范围。</li>
</ul>
</li>
<li><strong>增补字符 (Supplementary Characters)</strong>:
<ul>
<li>指那些位于增补平面（码点大于 <code>U+FFFF</code>）的字符。</li>
</ul>
</li>
<li><strong>代理对 (Surrogate Pairs)</strong>:
<ul>
<li>由于 Java 的 <code>char</code> 是 16 位的，无法直接表示增补字符（需要 21 位）。因此，UTF-16 编码引入了<strong>代理对</strong>机制来表示这些增补字符。</li>
<li>代理对由两个特殊的 16 位代码单元组成：
<ul>
<li><strong>高代理 (High Surrogate)</strong>：码点范围 <code>U+D800</code> 到 <code>U+DBFF</code>。</li>
<li><strong>低代理 (Low Surrogate)</strong>：码点范围 <code>U+DC00</code> 到 <code>U+DFFF</code>。</li>
</ul>
</li>
<li>一个增补字符需要一个高代理和一个低代理这两个 <code>char</code> 值来共同表示。这两个 <code>char</code> 值合起来看作一个 32 位（4 字节）的实体，用于编码 BMP 之外的码点。</li>
</ul>
</li>
</ul>
<h2 id="4-java-中的-char-类型-再探">4. Java 中的 <code>char</code> 类型 (再探)</h2>
<p>现在我们更深入地理解了背景，再来看 <code>char</code>：</p>
<ul>
<li><strong>定义</strong>：<code>char</code> 是 Java 中的 16 位<strong>代码单元（Code Unit）</strong>，用于表示 UTF-16 编码中的一个单元。</li>
<li><strong>与码点的关系</strong>：
<ul>
<li>如果码点在 BMP 范围内 (<code>U+0000</code> 到 <code>U+FFFF</code>)，一个码点对应一个 <code>char</code>。</li>
<li>如果码点在增补平面范围内 (<code>U+10000</code> 到 <code>U+10FFFF</code>)，一个码点需要两个 <code>char</code>（一个代理对）来表示。</li>
</ul>
</li>
<li>使用场景：
<ul>
<li><strong>存储/交换</strong>层：绝大多数文件、网页、网络协议、数据库默认用 UTF-8（空间省、兼容 ASCII）。</li>
<li><strong>内存/运算层</strong>：Java、C#、JavaScript、Objective-C/Swift 的 char/String 内部实现是 UTF-16（固定 16-bit 代码单元，方便随机索引、与早期 Unicode 兼容）。</li>
<li>存储到外部的字节流仍需 getBytes(StandardCharsets.UTF_8) 显式转码。</li>
</ul>
</li>
</ul>
<ul>
<li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// BMP 字符 &#x27;A&#x27; (U+0041)</span><br><span class="hljs-type">char</span> <span class="hljs-variable">letterA</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span>; <span class="hljs-comment">// 单个 char</span><br><br><span class="hljs-comment">// 增补字符 &#x27;𝄞&#x27; (U+1D11E) - 需要代理对</span><br><span class="hljs-type">char</span> <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;\uD834&#x27;</span>; <span class="hljs-comment">// 高代理 (High Surrogate)</span><br><span class="hljs-type">char</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;\uDD1E&#x27;</span>; <span class="hljs-comment">// 低代理 (Low Surrogate)</span><br><span class="hljs-comment">// hi 和 lo 一起代表码点 U+1D11E</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5-java-中的-string-类">5. Java 中的 <code>String</code> 类</h2>
<p><code>String</code> 是 Java 中用于表示字符串的类。它是一个<strong>不可变的 UTF-16 代码单元序列</strong>，即 <code>char[]</code>。</p>
<ul>
<li><strong>定义</strong>：<code>String</code> 是一个不可变的 UTF-16 代码单元序列。</li>
<li><strong><code>String.length()</code> 的真相</strong>：
<ul>
<li><code>String.length()</code> 返回的是<strong>代码单元</strong>（即 <code>char</code> 的数量）。</li>
<li>如果字符串中包含增补字符（需要代理对表示），<code>length()</code> 的值会大于实际的码点数量。</li>
</ul>
</li>
<li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">bmpString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Hello&quot;</span>; <span class="hljs-comment">// BMP 字符</span><br>System.out.println(bmpString.length()); <span class="hljs-comment">// 输出: 5 (5 个 char)</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">supplementaryString</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;𝄞&quot;</span>; <span class="hljs-comment">// 增补字符</span><br>System.out.println(supplementaryString.length()); <span class="hljs-comment">// 输出: 2 (需要 2 个 char，即一个代理对)</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">family</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;👨‍👩‍👧‍👦&quot;</span>; <span class="hljs-comment">// 复杂 emoji (由多个码点通过 ZWJ 组合)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">unitCount</span> <span class="hljs-operator">=</span> family.length(); <span class="hljs-comment">// 例如: 25 (代码单元数量)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">codePointCount</span> <span class="hljs-operator">=</span> family.codePointCount(<span class="hljs-number">0</span>, unitCount); <span class="hljs-comment">// 例如: 7 (码点数量)</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="6-字符集-charset-与编码-encoding">6. 字符集（Charset）与编码（Encoding）</h2>
<p>字符集（Charset）和编码（Encoding）是两个容易混淆的概念，但它们的作用完全不同。</p>
<ul>
<li><strong>字符集（Charset）</strong>：
<ul>
<li><strong>定义</strong>：字符集是一个字符的集合，定义了“有哪些字符”以及“每个字符的编号（码点）”。</li>
<li><strong>比喻</strong>：字符集就像一个图书馆的书架，书架上摆满了各种书籍（字符），每本书都有一个唯一的编号（码点）。</li>
<li><strong>示例</strong>：
<ul>
<li>Unicode：包含世界上所有字符的字符集。</li>
<li>ASCII：只包含 128 个字符的字符集，编号从 0 到 127。</li>
<li>GBK：包含中文字符和其他语言字符的字符集。</li>
</ul>
</li>
</ul>
</li>
<li><strong>编码（Encoding）</strong>：
<ul>
<li><strong>定义</strong>：编码是一套规则，用于将字符集中的字符（码点）转换成字节序列，以便在文件、网络等地方存储和传输。</li>
<li><strong>比喻</strong>：编码就像图书馆的借阅系统，它决定了如何把书（字符）借出来（转换成字节）以及如何把书放回书架（从字节还原成字符）。</li>
<li><strong>示例</strong>：
<ul>
<li>UTF-8：一种可变长的编码方式，一个码点可以占用 1 到 4 个字节。</li>
<li>UTF-16：一种可变长的编码方式，一个码点可以占用 2 或 4 个字节（即 1 或 2 个代码单元）。</li>
<li>GBK：一种通常固定长的编码方式（但也有双字节变长），一个字符占用 1 或 2 个字节。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="7-java-中的字符集与编码">7. Java 中的字符集与编码</h2>
<p>在 Java 中，字符集和编码的概念通过 <code>java.nio.charset.Charset</code> 类来体现。</p>
<ul>
<li><strong>字符集与编码的关系</strong>：
<ul>
<li>一个字符集可以有多种编码方式。例如，Unicode 字符集可以用 UTF-8、UTF-16 或 UTF-32 编码。</li>
<li>在 Java 中，<code>Charset</code> 类的实例名字（如 <code>&quot;UTF-8&quot;</code>、<code>&quot;ISO-8859-1&quot;</code>）既表示字符集，也表示编码方式。Java 内部使用 UTF-16 作为其原生字符编码。</li>
</ul>
</li>
<li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.nio.charset.StandardCharsets;<br><span class="hljs-comment">// 内存 (UTF-16) → 文件 (UTF-8)</span><br><span class="hljs-type">byte</span>[] utf8 = str.getBytes(StandardCharsets.UTF_8);<br><span class="hljs-comment">// 文件 (UTF-8) → 内存 (UTF-16)</span><br><span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(utf8, StandardCharsets.UTF_8);<br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="8-字形簇-grapheme-cluster">8. 字形簇（Grapheme Cluster）</h2>
<p>**字形簇（Grapheme Cluster）**是用户感知的一个“字符”，它可能由多个码点组成。例如，一个带重音符的字符 <code>é</code> 可以由两个码点（<code>U+0065</code> ‘e’ 和 <code>U+0301</code> 组合尖音符）组成。又如，某些 emoji 是由多个 emoji 码点通过零宽连接符 (ZWJ) 组合而成。</p>
<ul>
<li><strong>定义</strong>：字形簇是用户感知的一个“字符”，它可能由多个码点组成。</li>
<li><strong>比喻</strong>：字形簇就像一个由多个组件组成的复杂机器，用户看到的是一个整体，但内部可能由多个部分（码点）组成。</li>
<li><strong>示例</strong>：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">eAcute</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;é&quot;</span>; <span class="hljs-comment">// 一个字形簇，可能由 U+0065 和 U+0301 组成</span><br><span class="hljs-type">int</span> <span class="hljs-variable">codePointCount</span> <span class="hljs-operator">=</span> eAcute.codePointCount(<span class="hljs-number">0</span>, eAcute.length()); <span class="hljs-comment">// 1 或 2</span><br><br><span class="hljs-type">String</span> <span class="hljs-variable">familyEmoji</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;👨‍👩‍👧‍👦&quot;</span>; <span class="hljs-comment">// 一个字形簇，由多个 emoji 码点和 ZWJ 组成</span><br><span class="hljs-type">int</span> <span class="hljs-variable">visualCharCount</span> <span class="hljs-operator">=</span> ?; <span class="hljs-comment">// Java 标准库没有直接计算字形簇数量的方法</span><br><span class="hljs-type">int</span> <span class="hljs-variable">codePointCountFamily</span> <span class="hljs-operator">=</span> familyEmoji.codePointCount(<span class="hljs-number">0</span>, familyEmoji.length()); <span class="hljs-comment">// 码点数量 (&gt; 1)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">unitCountFamily</span> <span class="hljs-operator">=</span> familyEmoji.length(); <span class="hljs-comment">// 代码单元数量 (通常远大于码点数)</span><br></code></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="9-常见疑问快答">9. 常见疑问快答</h2>
<table>
<thead>
<tr>
<th style="text-align:left">问</th>
<th style="text-align:left">答</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>char</code> 永远是 2 字节吗？</td>
<td style="text-align:left">是的，在 Java 语言层面，<code>char</code> <strong>永远</strong>是 16 位（2 字节）。底层字节序由 JVM 隐藏。</td>
</tr>
<tr>
<td style="text-align:left"><code>byte</code> 和 <code>char</code> 有什么区别？</td>
<td style="text-align:left"><code>byte</code> 是 8 位（1 字节）的有符号整数，主要用于原始数据；<code>char</code> 是 16 位（2 字节）的无符号整数，用于存储 UTF-16 代码单元。</td>
</tr>
<tr>
<td style="text-align:left">什么是 BMP、增补字符、代理对？</td>
<td style="text-align:left">BMP (U+0000 到 U+FFFF) 是包含常用字符的平面；增补字符是 BMP 之外 (U+10000 到 U+10FFFF) 的字符；由于 <code>char</code> 只有 16 位，增补字符需要用两个特殊的 <code>char</code> (代理对) 来表示。</td>
</tr>
<tr>
<td style="text-align:left">字符串会出现看起来 7 个 emoji 但 <code>length()&gt;7</code>？</td>
<td style="text-align:left">会，复杂 emoji（使用 ZWJ 或修饰符）或增补字符会让 <code>length()</code> (代码单元数) 远大于视觉字符数或码点数。</td>
</tr>
<tr>
<td style="text-align:left">非 Unicode 字符集里的字符有 Unicode 码点吗？</td>
<td style="text-align:left">不一定。需要外部映射表，且可能缺码或映射不唯一。</td>
</tr>
<tr>
<td style="text-align:left">能把码点直接当字节写磁盘吗？</td>
<td style="text-align:left">不行，21 位的码点无法直接对齐到 8/16/24 位的字节，必须先经过编码（如 UTF-8, UTF-16）转换为字节序列。</td>
</tr>
</tbody>
</table>
<h2 id="10-速记口诀">10. 速记口诀</h2>
<ul>
<li><strong>码点</strong>：字符的身份证号（int）。</li>
<li><strong><code>char</code></strong>：固定 2 字节 (16 位) 的箱子，用于存放 UTF-16 代码单元。BMP 字符一个箱，增补字符需成双（代理对）。</li>
<li><strong><code>byte</code></strong>：固定 1 字节 (8 位) 的箱子，用于存放原始数据或编码后的字节流。</li>
<li><strong><code>String.length()</code></strong>：数箱子（代码单元 <code>char</code>），不数字符（码点或字形簇）。</li>
<li><strong>Charset</strong>：图书馆的书架，定义了“有哪些书（字符）”以及“每本书的编号（码点）”。</li>
<li><strong>Encoding</strong>：图书馆的借阅系统，决定了如何把书（字符/码点）借出来（转换成字节）以及如何把书放回书架（从字节还原成字符/码点）。</li>
<li><strong>字形簇</strong>：用户眼中的一个字，可能由多个码点拼成。</li>
</ul>
<h1>Java 集合与系统设计中的扩缩容机制全解析</h1>
<p>从 ArrayList、HashMap 到线程池、缓存系统，深入剖析扩缩容的设计原理、实现流程与核心取舍。附 Mermaid 流程图与 LRU/LFU 算法详解。</p>
<h2 id="目录">目录</h2>
<ol>
<li><a href="#%E4%B8%80arraylist-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">ArrayList 扩容机制</a></li>
<li><a href="#%E4%BA%8Chashmap-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6">HashMap 扩容机制</a></li>
<li><a href="#%E4%B8%89stringbuilder-%E6%89%A9%E5%AE%B9">StringBuilder 扩容</a></li>
<li><a href="#%E5%9B%9B%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8A%A8%E6%80%81%E6%89%A9%E7%BC%A9%E5%AE%B9">线程池动态扩缩容</a></li>
<li><a href="#%E4%BA%94%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%89%A9%E7%BC%A9%E5%AE%B9">数据库连接池扩缩容</a></li>
<li><a href="#%E5%85%ADredis-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E7%BC%A9%E5%AE%B9">Redis 缓存淘汰策略（缩容）</a></li>
<li><a href="#%E4%B8%83%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9%E8%AE%BE%E8%AE%A1">系统级弹性伸缩设计</a></li>
<li><a href="#%E5%85%ABlru-%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3">LRU 算法详解</a></li>
<li><a href="#%E4%B9%9Dlfu-%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3">LFU 算法详解</a></li>
<li><a href="#%E5%8D%81%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93">面试高频题总结</a></li>
</ol>
<hr>
<h2 id="一-arraylist-扩容机制">一、ArrayList 扩容机制</h2>
<h3 id="基本原理">基本原理</h3>
<p>ArrayList 是基于动态数组实现的列表，内部维护一个 Object[] elementData 数组。默认初始容量为 10。当添加元素时，若当前 size 大于等于数组长度，则触发扩容。</p>
<h3 id="扩容流程">扩容流程</h3>
<ol>
<li>检查是否需要扩容：<code>size &gt;= elementData.length</code></li>
<li>计算新容量：<code>newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1)</code>（即 1.5 倍）</li>
<li>若新容量仍不足，直接使用所需最小容量</li>
<li>创建新数组，调用 <code>Arrays.copyOf</code> 复制数据</li>
<li>更新引用</li>
</ol>
<h3 id="设计取舍">设计取舍</h3>
<ul>
<li><strong>优点</strong>：
<ul>
<li>1.5 倍增长比 2 倍更节省内存，旧数组释放的空间可能被后续扩容重用</li>
<li>随机访问性能好（O(1)）</li>
</ul>
</li>
<li><strong>缺点</strong>：
<ul>
<li>扩容需复制数组，时间复杂度 O(n)</li>
<li>不支持自动缩容，长期持有空闲内存</li>
<li>中间插入/删除需移动元素</li>
</ul>
</li>
</ul>
<h3 id="mermaid-图：arraylist-扩容流程">Mermaid 图：ArrayList 扩容流程</h3>
<pre><code class="hljs mermaid">graph TD
    A[添加元素] --&gt; B&#123;size &gt;= capacity?&#125;
    B -- 否 --&gt; C[直接插入]
    B -- 是 --&gt; D[计算新容量 = old + old&gt;&gt;1]
    D --&gt; E[创建新数组（1.5倍）]
    E --&gt; F[复制旧数组数据]
    F --&gt; G[更新 elementData 引用]
    G --&gt; H[完成插入]</code></pre>
<h2 id="二-hashmap-扩容机制">二、HashMap 扩容机制</h2>
<h3 id="基本原理">基本原理</h3>
<p>HashMap 使用数组 + 链表/红黑树结构。初始容量为 16，负载因子默认 0.75，阈值 threshold = capacity * loadFactor（默认 12）。</p>
<h3 id="扩容触发条件">扩容触发条件</h3>
<ul>
<li><code>size &gt; threshold</code></li>
<li>或链表长度 ≥ 8 且数组长度 ≥ 64（转红黑树，非扩容）</li>
</ul>
<h3 id="扩容流程">扩容流程</h3>
<ol>
<li>新容量 = 旧容量 × 2（必须是 2 的幂）</li>
<li>新阈值 = 新容量 × 负载因子</li>
<li>创建新 table 数组</li>
<li>遍历旧 table，对每个桶中的元素重新计算索引</li>
<li>利用高位掩码优化：newIndex = oldIndex 或 oldIndex + oldCap</li>
</ol>
<blockquote>
<p>“原因：容量为 2 的幂，<code>index = hash &amp; (capacity - 1)</code>。扩容后多一位高位，只需判断该位即可决定迁移位置。”</p>
</blockquote>
<h3 id="链表转红黑树">链表转红黑树</h3>
<ul>
<li>当某个桶的链表长度 ≥ 8，且<code>table.length &gt;= 64</code>，链表转为红黑树</li>
<li>当红黑树节点数 ≤ 6，自动转回链表</li>
<li>目的：防止哈希冲突严重时，查找退化为 O(n)</li>
</ul>
<h3 id="设计取舍">设计取舍</h3>
<ul>
<li>优点：
<ul>
<li>容量为 2 的幂，可用<code>&amp;</code>替代<code>%</code>，提升索引计算性能</li>
<li>负载因子 0.75 平衡空间利用率与冲突概率</li>
<li>红黑树保障最坏情况下的性能</li>
</ul>
</li>
<li>缺点：
<ul>
<li>扩容需 rehash，O(n) 时间开销</li>
<li>不支持自动缩容</li>
<li>结构复杂，小数据量时链表更高效</li>
</ul>
</li>
</ul>
<pre><code class="hljs mermaid">graph TD
    A[&quot;put() 添加元素&quot;] --&gt; B&#123;&quot;size &gt; threshold?&quot;&#125;
    B -- 否 --&gt; C[&quot;插入链表或树&quot;]
    B -- 是 --&gt; D[&quot;创建新 table（2倍）&quot;]
    D --&gt; E[&quot;遍历旧 table 每个桶&quot;]
    E --&gt; F[&quot;计算新索引: hash &amp; (newCap-1)&quot;]
    F --&gt; G&#123;&quot;高位为0?&quot;&#125;
    G -- 是 --&gt; H[&quot;留在原位置&quot;]
    G -- 否 --&gt; I[&quot;迁移到 index + oldCap&quot;]
    H --&gt; J[&quot;完成迁移&quot;]
    I --&gt; J
    J --&gt; K[&quot;更新 table 引用&quot;]</code></pre>
<h2 id="三-stringbuilder-扩容">三、StringBuilder 扩容</h2>
<h3 id="基本原理">基本原理</h3>
<p>StringBuilder 内部维护 char[] 数组，初始容量 16。当拼接字符串时容量不足，触发扩容。</p>
<h3 id="扩容公式">扩容公式</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">newCapacity = (oldCapacity &lt;&lt; <span class="hljs-number">1</span>) + <span class="hljs-number">2</span>; <span class="hljs-comment">// 约等于 2 倍</span><br></code></pre></td></tr></table></figure>
<p>确保新容量至少满足需求。</p>
<h3 id="与-arraylist-对比">与 ArrayList 对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>ARRAYLIST</th>
<th>STRINGBUILDER</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>扩容倍数</strong></td>
<td>1.5 倍</td>
<td>~2 倍</td>
</tr>
<tr>
<td><strong>主要场景</strong></td>
<td>通用集合操作</td>
<td>字符串频繁拼接</td>
</tr>
<tr>
<td><strong>设计目标</strong></td>
<td>节省内存</td>
<td>减少扩容次数</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph TD
    A[&quot;append() 字符串&quot;] --&gt; B&#123;&quot;容量足够?&quot;&#125;
    B -- 是 --&gt; C[&quot;直接写入&quot;]
    B -- 否 --&gt; D[&quot;计算新容量 = old&lt;&lt;1 + 2&quot;]
    D --&gt; E[&quot;创建更大 char[]&quot;]
    E --&gt; F[&quot;复制原字符&quot;]
    F --&gt; G[&quot;继续 append&quot;]</code></pre>
<h2 id="四-线程池动态扩缩容">四、线程池动态扩缩容</h2>
<h3 id="扩容逻辑">扩容逻辑</h3>
<ol>
<li>任务提交 → 核心线程处理</li>
<li>核心线程满 → 任务进入队列</li>
<li>队列满 → 创建非核心线程（直到最大线程数）</li>
<li>达到最大线程数 → 执行拒绝策略</li>
</ol>
<h3 id="缩容机制">缩容机制</h3>
<ul>
<li>非核心线程空闲时间超过 keepAliveTime 后自动终止</li>
<li>可通过 allowCoreThreadTimeOut(true) 使核心线程也可回收</li>
</ul>
<pre><code class="hljs mermaid">graph TD
    A[提交任务] --&gt; B&#123;核心线程空闲?&#125;
    B -- 是 --&gt; C[交给核心线程]
    B -- 否 --&gt; D&#123;队列未满?&#125;
    D -- 是 --&gt; E[放入任务队列]
    D -- 否 --&gt; F&#123;线程数 &lt; 最大线程数?&#125;
    F -- 是 --&gt; G[创建非核心线程]
    F -- 否 --&gt; H[执行拒绝策略]
    
    I[非核心线程空闲] --&gt; J&#123;超过 keepAliveTime?&#125;
    J -- 是 --&gt; K[线程终止]
    J -- 否 --&gt; L[继续等待]</code></pre>
<h2 id="五-数据库连接池扩缩容">五、数据库连接池扩缩容</h2>
<h3 id="扩缩容策略">扩缩容策略</h3>
<ul>
<li>初始化最小连接数（min）</li>
<li>请求增加 → 按需创建连接（≤最大连接数 max）</li>
<li>连接空闲超时 → 自动关闭</li>
</ul>
<h3 id="为什么要限制最大连接数？">为什么要限制最大连接数？</h3>
<ul>
<li>防止数据库连接耗尽（如 MySQL 默认 151）</li>
<li>控制内存使用（每个连接占用资源）</li>
<li>避免系统雪崩</li>
</ul>
<pre><code class="hljs mermaid">graph TD
    A[应用请求连接] --&gt; B&#123;有空闲连接?&#125;
    B -- 是 --&gt; C[返回连接]
    B -- 否 --&gt; D&#123;当前连接数 &lt; 最大?&#125;
    D -- 是 --&gt; E[创建新连接]
    D -- 否 --&gt; F[等待或拒绝]
    
    G[连接使用完毕] --&gt; H[归还连接池]
    H --&gt; I&#123;空闲时间 &gt; 超时?&#125;
    I -- 是 --&gt; J[关闭连接]
    I -- 否 --&gt; K[保持空闲]</code></pre>
<h2 id="六-redis-缓存淘汰策略-缩容">六、Redis 缓存淘汰策略（缩容）</h2>
<h3 id="缩容机制">缩容机制</h3>
<p>当内存使用超过 maxmemory 配置时，Redis 根据淘汰策略删除 key，实现“被动缩容”。</p>
<h3 id="常见淘汰策略">常见淘汰策略</h3>
<table>
<thead>
<tr>
<th>策略</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>noeviction</td>
<td>不淘汰，写操作返回错误</td>
</tr>
<tr>
<td>allkeys-lru</td>
<td>从所有 key 中淘汰最近最少使用</td>
</tr>
<tr>
<td>volatile-lru</td>
<td>仅从设置了过期时间的 key 中淘汰 LRU</td>
</tr>
<tr>
<td>allkeys-lfu</td>
<td>从所有 key 中淘汰最不经常使用</td>
</tr>
<tr>
<td>volatile-lfu</td>
<td>仅从有过期时间的 key 中淘汰 LFU</td>
</tr>
<tr>
<td>allkeys-random</td>
<td>随机淘汰</td>
</tr>
<tr>
<td>volatile-ttl</td>
<td>优先淘汰剩余时间最短的 key</td>
</tr>
</tbody>
</table>
<h2 id="七-系统级弹性伸缩设计">七、系统级弹性伸缩设计</h2>
<h3 id="类比-kubernetes-hpa">类比 Kubernetes HPA</h3>
<ul>
<li>监控指标：QPS、CPU、响应时间、缓存命中率</li>
<li>扩容：指标持续高于阈值 → 增加实例</li>
<li>缩容：指标低于下限 → 逐步下线</li>
<li>数据迁移：使用一致性哈希减少 rehash 影响</li>
</ul>
<pre><code class="hljs mermaid">graph TD
    A[监控系统] --&gt; B&#123;指标 &gt; 阈值?&#125;
    B -- 是 --&gt; C[触发扩容]
    C --&gt; D[启动新实例]
    D --&gt; E[注册到负载均衡]
    E --&gt; F[开始接收流量]

    G[监控空闲] --&gt; H&#123;指标 &lt; 下限?&#125;
    H -- 是 --&gt; I[触发缩容]
    I --&gt; J[从负载均衡摘除]
    J --&gt; K[等待请求完成]
    K --&gt; L[关闭实例]</code></pre>
<h2 id="八-lru-算法详解">八、LRU 算法详解</h2>
<h3 id="基本思想">基本思想</h3>
<p>Least Recently Used（最近最少使用）：淘汰最久未被访问的元素。</p>
<h3 id="实现方式">实现方式</h3>
<p>使用<code>LinkedHashMap</code>或<code>双向链表 + HashMap</code>。</p>
<h3 id="双向链表-hashmap-结构">双向链表 + HashMap 结构</h3>
<ul>
<li>双向链表：维护访问顺序，头为最老，尾为最新</li>
<li>HashMap：key → 链表节点，实现 O(1) 查找</li>
</ul>
<h3 id="操作流程">操作流程</h3>
<ul>
<li>get(key)：
<ul>
<li>若不存在，返回 -1</li>
<li>若存在，从链表中移除该节点，添加到尾部（最新）</li>
<li>返回值</li>
</ul>
</li>
<li>put(key, value)：
<ul>
<li>若 key 存在，更新值并移到尾部</li>
<li>若不存在：
<ul>
<li>若容量满，删除头节点（最老）</li>
<li>创建新节点，插入尾部</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="hljs mermaid">graph TD
    A[get 或 put 操作] --&gt; B&#123;key 是否存在?&#125;
    B -- 否 --&gt; C&#123;容量是否已满?&#125;
    C -- 是 --&gt; D[删除链表头节点]
    C -- 否 --&gt; E[创建新节点]
    D --&gt; E
    E --&gt; F[插入链表尾部]
    F --&gt; G[更新 HashMap]

    B -- 是 --&gt; H[从链表中移除该节点]
    H --&gt; I[插入链表尾部]
    I --&gt; J[更新值]</code></pre>
<h2 id="九-lfu-算法详解">九、LFU 算法详解</h2>
<h3 id="基本思想">基本思想</h3>
<p>Least Frequently Used（最不经常使用）：淘汰访问频率最低的元素。</p>
<h3 id="实现方式">实现方式</h3>
<p>使用<code>HashMap + 频率桶（Map&lt;Integer, DoublyLinkedList&gt;） + minFreq</code></p>
<h3 id="核心结构">核心结构</h3>
<ul>
<li><code>keyToVal</code>：key → value</li>
<li><code>keyToFreq</code>：key → 当前访问频率</li>
<li><code>freqToList</code>：频率 → 该频率下所有 key 的双向链表（支持 O(1) 删除）</li>
<li><code>minFreq</code>：当前最小频率，用于快速定位淘汰目标</li>
</ul>
<h3 id="操作流程">操作流程</h3>
<ul>
<li>get(key)：
<ul>
<li>若不存在，返回 -1</li>
<li>获取当前频率 f，从<code>freqToList[f]</code>中删除该 key</li>
<li>若<code>f == minFreq</code>且链表为空，<code>minFreq++</code></li>
<li>频率 +1，插入<code>freqToList[f+1]</code>尾部</li>
<li>返回值</li>
</ul>
</li>
<li>put(key, value)：
<ul>
<li>若 key 存在：更新值，执行 get 流程（频率+1）</li>
<li>若不存在：
<ul>
<li>若容量满且<code>size == capacity</code>：
<ul>
<li>从 freqToList[minFreq] 头部删除一个 key</li>
<li>清除其所有映射</li>
</ul>
</li>
<li>插入新 key，频率为 1，minFreq = 1</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="hljs mermaid">graph TD
    A[&quot;put 或 get&quot;] --&gt; B&#123;&quot;key 是否存在?&quot;&#125;
    B -- 否 --&gt; C&#123;&quot;容量是否满?&quot;&#125;
    C -- 是 --&gt; D[&quot;从 freqToList[minFreq] 删除头部&quot;]
    D --&gt; E[&quot;清除 key 映射&quot;]
    C -- 否 --&gt; E
    E --&gt; F[&quot;插入 freqToList[1]&quot;]
    F --&gt; G[&quot;更新 keyToVal, keyToFreq&quot;]
    G --&gt; H[&quot;minFreq = 1&quot;]

    B -- 是 --&gt; I[&quot;从 freqToList[f] 删除节点&quot;]
    I --&gt; J&#123;&quot;f == minFreq 且链表为空?&quot;&#125;
    J -- 是 --&gt; K[&quot;minFreq++&quot;]
    J -- 否 --&gt; L[&quot;继续&quot;]
    K --&gt; L
    L --&gt; M[&quot;插入 freqToList[f+1]&quot;]
    M --&gt; N[&quot;更新 freq 和值&quot;]</code></pre>
<h2 id="十-面试高频题总结">十、面试高频题总结</h2>
<table>
<thead>
<tr>
<th>问题</th>
<th>核心考点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ArrayList扩容为什么是1.5倍?</strong></td>
<td>内存碎片重用，避免浪费</td>
</tr>
<tr>
<td><strong>HashMap为什么容量是2的幂?</strong></td>
<td>位运算优化索引计算(hash &amp; (cap-1))</td>
</tr>
<tr>
<td><strong>扩容时 rehash如何优化?</strong></td>
<td>高位掩码，迁移位置为原位置或原位置+oldCap</td>
</tr>
<tr>
<td><strong>为什么不支持自动缩容?</strong></td>
<td>避免频繁 rehash 和性能抖动</td>
</tr>
<tr>
<td><strong>StringBuilder扩容策略?</strong></td>
<td>接近2倍，减少扩容次数</td>
</tr>
<tr>
<td><strong>线程池如何扩缩容?</strong></td>
<td>核心/最大线程+keepAliveTime控制生命周期</td>
</tr>
<tr>
<td><strong>Redis淘汰策略有哪些?</strong></td>
<td>LRU、LFU、TTL、noeviction等</td>
</tr>
<tr>
<td><strong>如何设计自动缩容的ArrayList?</strong></td>
<td>size&lt;25%容量时缩容，避免抖动</td>
</tr>
<tr>
<td><strong>LRU如何实现O(1)操作?</strong></td>
<td>双向链表+HashMap</td>
</tr>
<tr>
<td><strong>LFU如何维护最小频率?</strong></td>
<td>使用freqToList+minFreq变量</td>
</tr>
</tbody>
</table>
<h1>数据结构的衍生关系</h1>
<pre><code class="hljs mermaid">graph TD
    Root[数据结构] --&gt; Linear[线性结构 一对一顺序]
    Root --&gt; NonLinear[非线性结构 非顺序]

    Linear --&gt; Array[数组 连续内存]
    Linear --&gt; Linked[链表 离散节点]

    Array --&gt; Stack[栈]
    Array --&gt; Queue[队列]
    Array --&gt; Deque[双端队列]
    Array --&gt; ArrHash[哈希表 开放定址]

    Linked --&gt; SList[单向链表]
    Linked --&gt; DList[双向链表]
    Linked --&gt; LinkedDeque[双端队列 链式]
    Linked --&gt; LinkedHash[哈希表 链地址]

    NonLinear --&gt; TreeShape[树形结构 一对多]
    NonLinear --&gt; MeshShape[网状结构 多对多]

    TreeShape --&gt; Tree[树]
    TreeShape --&gt; Heap[堆]
    TreeShape --&gt; TreeHash[哈希表 树形桶]

    MeshShape --&gt; Graph[图]
    Graph --&gt; AdjList[邻接表 链表实现]

    classDef linear fill:#E1F5FE,stroke:#0288D1
    classDef nonlinear fill:#FFF3E0,stroke:#FB8C00
    class Array,SList,DList,Linked linear
    class TreeShape,MeshShape nonlinear</code></pre>
<h1>设计一个IM</h1>
<h2 id="1-需求分析-requirements-goals">1. 需求分析 (Requirements &amp; Goals)</h2>
<h3 id="功能性需求-functional">功能性需求 (Functional)</h3>
<ol>
<li>1对1聊天: 用户可以与另一个用户进行私聊。</li>
<li>群组聊天: 用户可以创建/加入群聊，与多个用户通信。</li>
<li>在线状态 (Presence): 显示好友是否在线、最后在线时间。</li>
<li>消息持久化与历史记录: 用户可以拉取历史消息。</li>
<li>多设备同步: 用户在手机上发送的消息，在桌面端应能看到。</li>
<li>推送通知: 当用户不在线时，能收到新消息的推送通知。</li>
<li>已读回执 (Read Receipts): 显示消息是否已被对方阅读。</li>
</ol>
<h3 id="非功能性需求-non-functional">非功能性需求 (Non-Functional)</h3>
<ol>
<li>高可用性 (High Availability): 系统应无单点故障，能够容忍部分组件失效。</li>
<li>低延迟 (Low Latency): 消息传递的端到端延迟应尽可能低（目标 &lt; 200ms）。</li>
<li>高可扩展性 (Scalability): 系统应能水平扩展以支持亿级用户和海量消息。</li>
<li>持久性 (Durability): 已发送的消息不能丢失。</li>
<li>一致性 (Consistency): 消息顺序在单个聊天中必须得到保证。跨设备的最终一致性是可接受的。</li>
</ol>
<h2 id="2-系统规模估算-capacity-estimation">2. 系统规模估算 (Capacity Estimation)</h2>
<p>假设我们的目标是支持一个大型社交应用：</p>
<ul>
<li>月活跃用户 (MAU): 5 亿</li>
<li>日活跃用户 (DAU): 1 亿 (通常为 MAU 的 20%)</li>
<li>每位用户日均发送消息数: 40</li>
<li>总消息写入量: 1亿用户 * 40条/天 = 40亿条/天</li>
<li>写入 QPS (每秒查询率): 40亿 / (24 * 3600s) ≈ 46,000 QPS</li>
<li>峰值写入 QPS: 假设峰值是平均值的 2-3 倍，约为 100,000 - 150,000 QPS。</li>
<li>存储估算: 假设平均每条消息大小为 100 字节。
<ul>
<li>每日存储: 40亿 * 100字节 = 400 GB</li>
<li>5年存储: 400 GB/天 * 365 * 5 ≈ 730 TB</li>
</ul>
</li>
</ul>
<p>结论: 这是一个写入密集型、数据量巨大的系统。传统的单体应用和关系型数据库无法支撑，必须采用分布式架构。</p>
<h2 id="3-高层架构设计-high-level-design">3. 高层架构设计 (High-Level Design)</h2>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;客户端 (Clients)&quot;
        U1[用户A: 手机/Web]
        U2[用户B: 手机/Web]
    end

    subgraph &quot;接入层 (Gateway Layer)&quot;
        LB(L4 负载均衡器)
        GW1(Chat Gateway 1)
        GW2(Chat Gateway 2)
        GWN(Chat Gateway N...)
    end

    subgraph &quot;消息队列 (Message Queues)&quot;
        MQ1[Kafka Topic: incoming_messages]
        MQ2[Kafka Topic: dispatch_messages]
    end

    subgraph &quot;后端服务 (Backend Services)&quot;
        MS(消息处理服务)
        PS(在线状态服务)
        NS(推送通知服务)
        RS(消息路由服务)
    end

    subgraph &quot;数据存储 (Data Stores)&quot;
        DB[(Cassandra/ScyllaDB&lt;br&gt;消息库)]
        Cache[(Redis Cluster&lt;br&gt;用户状态/连接路由)]
    end

    U1 -- WebSocket --&gt; LB
    U2 -- WebSocket --&gt; LB
    LB --&gt; GW1
    LB --&gt; GW2
    LB --&gt; GWN

    GW1 -- 发布消息 --&gt; MQ1
    GW2 -- 发布消息 --&gt; MQ1
    GWN -- 发布消息 --&gt; MQ1

    MQ1 -- 消费消息 --&gt; MS
    MS -- 写入 --&gt; DB
    MS -- 发布到 --&gt; MQ2

    MQ2 -- 消费 --&gt; RS
    RS -- 查询路由 --&gt; Cache
    RS -- 推送给在线用户 --&gt; GW1
    RS -- 推送给在线用户 --&gt; GW2
    RS -- 推送给在线用户 --&gt; GWN
    RS -- 请求推送 --&gt; NS

    GW1 -- 更新状态 --&gt; PS
    GW2 -- 更新状态 --&gt; PS
    GWN -- 更新状态 --&gt; PS
    PS -- 读/写 --&gt; Cache

    NS -- 调用 --&gt; ThirdPartyPush[APNS/FCM]

    GW1 --&gt; U1
    GW2 --&gt; U2</code></pre>
<h2 id="4-核心组件详解-detailed-component-design">4. 核心组件详解 (Detailed Component Design)</h2>
<h3 id="a-接入层-chat-gateway-聊天网关">a. 接入层: Chat Gateway (聊天网关)</h3>
<p>这是系统的有状态部分，负责维护与客户端的 WebSocket 长连接。</p>
<pre><code>- 职责:
    - 连接管理: 处理用户的连接、断开、心跳维持。
    - 认证与授权: 验证用户身份。
    - 消息接收: 从客户端接收消息，进行初步验证后，立即推送到消息队列1 (incoming_messages)。它不处理业务逻辑，只做快速转发。
    - 消息推送: 订阅属于自己的消息主题（由消息路由服务分发），将消息通过 WebSocket 推送给连接在本机上的客户端。
- 扩展性: 网关服务器可以水平无限扩展。负载均衡器（L4 LB）将客户端连接均匀分配到各个网关。
- 关键问题: 如何将消息路由到正确的网关？
    - 解决方案: 使用 Redis 作为会话存储/路由表。当用户连接到某个网关（如 GW2）时，GW2 会在 Redis 中记录：SET user_id_B &quot;gw2.ip.address&quot;。当需要给用户B发消息时，路由服务查询 Redis 即可知道该推送到哪个网关。
</code></pre>
<h3 id="b-解耦核心-消息队列-message-queues">b. 解耦核心: 消息队列 (Message Queues)</h3>
<p>您提到了两个消息队列，这是一个非常好的设计，可以实现多级解耦。我们使用 Kafka，因为它支持高吞吐量和持久化。</p>
<pre><code>- 队列1: incoming_messages (上行消息队列)

    - 目的: 解耦网关层和后端处理服务。
    - 工作流: 网关接收到消息后，直接扔进这个 Topic，然后就可以响应客户端“发送成功”了（这里的成功指服务器已接收）。这使得网关非常轻量，响应迅速。
    - 好处: 即使后端处理服务暂时宕机或繁忙，消息也不会丢失（存储在 Kafka 中），实现了削峰填谷和系统韧性。
- 队列2: dispatch_messages (下行分发队列)

    - 目的: 解耦消息持久化和消息扇出/分发。
    - 工作流: 消息处理服务在将消息成功存入数据库后，再将此消息发布到这个 Topic。
    - 好处: 多个不同的消费者可以订阅这个 Topic 来完成不同任务。例如：
        - 消息路由服务 (Real-time Delivery): 消费消息，推送给在线用户。
        - 分析服务 (Analytics): 消费消息，进行数据分析。
        - 内容审核服务 (Moderation): 消费消息，进行敏感词过滤。
</code></pre>
<h3 id="c-数据库设计-database-design">c. 数据库设计 (Database Design)</h3>
<p>对于海量消息，传统的关系型数据库（如 MySQL）的 message 表会成为瓶颈。我们需要使用 NoSQL 数据库，如 Cassandra 或 ScyllaDB，它们为大规模写入和横向扩展而生。</p>
<pre><code>- messages 表 (核心)
    - 查询模式: 最核心的查询是“获取某个聊天的最新 N 条消息”。
    - 表结构设计 (Cassandra CQL):
</code></pre>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> messages (<br>    chat_id uuid,          <span class="hljs-comment">-- 分区键: 同一个聊天的消息落在一个分区</span><br>    message_id timeuuid,   <span class="hljs-comment">-- 聚簇键: 按时间排序，保证消息顺序</span><br>    sender_id uuid,<br>    content text,<br>    metadata map<span class="hljs-operator">&lt;</span>text, text<span class="hljs-operator">&gt;</span>, <span class="hljs-comment">-- 存储额外信息，如@了谁</span><br>    <span class="hljs-keyword">PRIMARY KEY</span> (chat_id, message_id)<br>) <span class="hljs-keyword">WITH</span> CLUSTERING <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> (message_id <span class="hljs-keyword">DESC</span>);<br></code></pre></td></tr></table></figure>
<pre><code>    - 优势: 这个设计使得读取一个聊天的消息历史记录变成了一次高效的顺序扫描，性能极高。chat_id 作为分区键，将不同聊天的负载分散到整个集群。
- chats 表
    - 存储聊天元数据，如群聊名称、成员列表等。这张表的更新频率远低于 messages 表。
</code></pre>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE TABLE</span> chats (<br>    chat_id uuid <span class="hljs-keyword">PRIMARY KEY</span>,<br>    participants <span class="hljs-keyword">set</span><span class="hljs-operator">&lt;</span>uuid<span class="hljs-operator">&gt;</span>,<br>    name text,<br>    created_at <span class="hljs-type">timestamp</span><br>);<br></code></pre></td></tr></table></figure>
<h3 id="核心服务-backend-services">核心服务 (Backend Services)</h3>
<pre><code>- 消息处理服务 (Message Service)
    - 职责: 消费 incoming_messages 队列。
    - 逻辑:
        - 生成全局唯一的 message_id (使用 timeuuid)。
        - 将消息写入 Cassandra 的 messages 表。
        - 将写入成功的消息发布到 dispatch_messages 队列。
- 消息路由服务 (Routing Service)
    - 职责: 消费 dispatch_messages 队列，负责将消息扇出给所有相关方。
    - 逻辑 (对于一条发往 chat_id_X 的消息):
        - 从 chats 表或缓存中获取 chat_id_X 的所有参与者 participants。
        - 遍历 participants，对每个 recipient_id:
            - 查询 Redis 获取其在线状态和所在的网关地址 gw_address。
            - 如果在线: 将消息直接推送给对应的网关（例如，通过一个专为该网关设计的 Kafka Topic 或 gRPC 调用）。
            - 如果不在线: 将消息发送给推送通知服务 (Notification Service)。
- 在线状态服务 (Presence Service)
    - 职责: 维护用户的在线状态。
    - 逻辑:
        - 上线: 用户连接到网关时，网关通知此服务，服务在 Redis 中记录 SET user_id_A &quot;online&quot; 并设置一个较短的过期时间（如 60s）。
        - 心跳: 客户端通过 WebSocket 定期发送心跳，网关收到后通知此服务刷新 Redis 中对应键的过期时间。
        - 下线: 用户主动断开连接，或心跳超时（Redis 键过期），则认为用户下线。服务可以发布一个 user_offline 事件。
</code></pre>
<h3 id="5-功能扩展实现">5. 功能扩展实现</h3>
<pre><code>- 已读回执:
    - 客户端 B 阅读消息后，向其连接的网关发送一个 message_read 事件，包含 chat_id 和 message_id。
    - 此事件通过一个独立的轻量级队列（或复用 incoming_messages）流转到后端。
    - 后端服务更新 messages 表（例如，增加一个 read_by 集合字段），或者更新一个专门的 receipts 表。
    - 系统再通过 dispatch_messages 队列将“已读”状态通知给发送方 A。
- 群聊:
    - 上述架构天然支持群聊。路由服务只需从 chats 表中获取群的所有成员，然后对每个成员执行路由逻辑即可。
</code></pre>
<h3 id="6-总结与权衡">6. 总结与权衡</h3>
<p>这个设计方案通过以下关键决策实现了可扩展性和高可用性：</p>
<ol>
<li>WebSocket 网关层: 使用有状态的网关处理长连接，将连接负载分散。</li>
<li>彻底解耦: 通过两层 Kafka 消息队列，将实时性要求高的接入层与复杂的后端逻辑完全解耦，提升了系统的稳定性和吞吐能力。</li>
<li>选择合适的数据库: 针对消息流的特点，采用 Cassandra/ScyllaDB，通过精心设计分区键和聚簇键，解决了海量消息的存储和查询难题。</li>
<li>中心化状态管理: 使用 Redis 存储用户的实时状态（在线状态、连接路由），使得无状态的后端服务可以轻松协作。</li>
</ol>
<p>这个方案从一个简单的模型出发，演变成了一个健壮、可扩展、功能丰富的分布式 IM 系统，能够满足现代大规模应用的需求。</p>
<h1>算法的衍生关系</h1>
<pre><code class="hljs mermaid">%% 排序算法升级/退化关系图（单行文本版）
graph TD
    subgraph 基础退化链
        QS[&quot;快速排序 O(n log n)&quot;] --&gt;|分区极度不平衡| IS[&quot;插入排序 O(n^2)&quot;]
        IS --&gt;|步长=1| SS[&quot;选择排序 O(n^2)&quot;]
        IS --&gt;|增量序列=1| Shell[&quot;希尔排序 O(n log^2 n)&quot;]
    end
    subgraph 归并方向
        MS[&quot;归并排序 O(n log n)&quot;] --&gt;|自底向上| BU_MS[&quot;自底向上归并 O(n log n)&quot;]
        MS --&gt;|退化成分区长度为1| IS
    end
    subgraph 堆方向
        HS[&quot;堆排序 O(n log n)&quot;] --&gt;|完全不平衡| IS
    end
    subgraph 工程级混合
        Tim[&quot;Timsort(2002 Tim Peters) 现实数据常局部有序 先找自然有序段(run) run太短用插入补齐到≥32-64 栈式归并+galloping合并 稳定自适应 时间:最坏Θ(n log n) 最好Θ(n) 空间:Θ(n) 稳定性:是 Python/Java7+/Rust/Swift默认 教材未收录因工程常数多且晚于CLRS经典版&quot;]
        Tim -.-&gt;|小区间回退| IS
        Tim -.-&gt;|大区间归并| MS
        QS -.-&gt;|小区间回退| IS
    end
    style IS fill:#f9f,stroke:#333
    style QS fill:#bbf,stroke:#333
    style MS fill:#9f9,stroke:#333
    style Tim fill:#ff9,stroke:#333</code></pre>
<h1>经典面试问题的大数据解法</h1>
<h2 id="概览对比">概览对比</h2>
<table>
<thead>
<tr>
<th>经典问题</th>
<th>单机解法</th>
<th>大数据解法</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>TopK</td>
<td>堆/快选</td>
<td>Spark/Flink聚合</td>
<td>海量数据排名</td>
</tr>
<tr>
<td>排序</td>
<td>归并/快排</td>
<td>分布式排序</td>
<td>TB级数据排序</td>
</tr>
<tr>
<td>去重</td>
<td>HashSet</td>
<td>Bloom Filter + 精确去重</td>
<td>亿级数据去重</td>
</tr>
<tr>
<td>频率统计</td>
<td>HashMap</td>
<td>WordCount模式</td>
<td>实时热词统计</td>
</tr>
<tr>
<td>滑动窗口</td>
<td>双指针</td>
<td>Flink Window</td>
<td>实时流处理</td>
</tr>
</tbody>
</table>
<h2 id="1-topk-问题">1. TopK 问题</h2>
<h3 id="传统解法-vs-大数据解法">传统解法 vs 大数据解法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传统解法：小顶堆</span><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">topK</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    PriorityQueue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(k);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">if</span> (heap.size() &lt; k) &#123;<br>            heap.offer(num);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (num &gt; heap.peek()) &#123;<br>            heap.poll();<br>            heap.offer(num);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(heap);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="spark解法：分布式topk">Spark解法：分布式TopK</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// Spark SQL 解法</span><br><span class="hljs-keyword">val</span> topKWords = spark.sql(<span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">  SELECT word, count </span><br><span class="hljs-string">  FROM (</span><br><span class="hljs-string">    SELECT word, COUNT(*) as count,</span><br><span class="hljs-string">           ROW_NUMBER() OVER (ORDER BY COUNT(*) DESC) as rank</span><br><span class="hljs-string">    FROM words </span><br><span class="hljs-string">    GROUP BY word</span><br><span class="hljs-string">  ) </span><br><span class="hljs-string">  WHERE rank &lt;= 10</span><br><span class="hljs-string">&quot;&quot;&quot;</span>)<br><br><span class="hljs-comment">// Spark Core 解法</span><br><span class="hljs-keyword">val</span> topK = words<br>  .map(word =&gt; (word, <span class="hljs-number">1</span>))<br>  .reduceByKey(_ + _)<br>  .top(<span class="hljs-number">10</span>)(<span class="hljs-type">Ordering</span>.by(_._2))  <span class="hljs-comment">// 自动处理分布式TopK</span><br></code></pre></td></tr></table></figure>
<h3 id="flink解法：实时topk">Flink解法：实时TopK</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Flink 实时TopK热词</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopKHotWords</span> &#123;<br>    <br>    <span class="hljs-meta">@Data</span><br>    <span class="hljs-meta">@AllArgsConstructor</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WordCount</span> &#123;<br>        <span class="hljs-keyword">public</span> String word;<br>        <span class="hljs-keyword">public</span> Long count;<br>        <span class="hljs-keyword">public</span> Long windowEnd;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">StreamExecutionEnvironment</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();<br>        <br>        env.socketTextStream(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9999</span>)<br>           .flatMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Tokenizer</span>())<br>           .keyBy(value -&gt; value.f0)<br>           .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="hljs-number">10</span>)))<br>           .aggregate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CountAgg</span>(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">WindowResultFunction</span>())<br>           .keyBy(item -&gt; item.windowEnd)<br>           .process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TopKProcessFunction</span>(<span class="hljs-number">3</span>))<br>           .print();<br>           <br>        env.execute(<span class="hljs-string">&quot;TopK Hot Words&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自定义ProcessFunction实现TopK</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TopKProcessFunction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">KeyedProcessFunction</span>&lt;Long, WordCount, String&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> topSize;<br>        <span class="hljs-keyword">private</span> ListState&lt;WordCount&gt; itemState;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">TopKProcessFunction</span><span class="hljs-params">(<span class="hljs-type">int</span> topSize)</span> &#123;<br>            <span class="hljs-built_in">this</span>.topSize = topSize;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processElement</span><span class="hljs-params">(WordCount value, Context ctx, Collector&lt;String&gt; out)</span> &#123;<br>            itemState.add(value);<br>            <span class="hljs-comment">// 注册定时器，在窗口结束时触发TopK计算</span><br>            ctx.timerService().registerProcessingTimeTimer(value.windowEnd + <span class="hljs-number">1</span>);<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onTimer</span><span class="hljs-params">(<span class="hljs-type">long</span> timestamp, OnTimerContext ctx, Collector&lt;String&gt; out)</span> &#123;<br>            List&lt;WordCount&gt; allItems = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (WordCount item : itemState.get()) &#123;<br>                allItems.add(item);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 排序并取TopK</span><br>            allItems.sort((a, b) -&gt; Long.compare(b.count, a.count));<br>            <br>            <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-string">&quot;===== Top &quot;</span> + topSize + <span class="hljs-string">&quot; =====\n&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; Math.min(topSize, allItems.size()); i++) &#123;<br>                <span class="hljs-type">WordCount</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> allItems.get(i);<br>                result.append(<span class="hljs-string">&quot;第&quot;</span>).append(i + <span class="hljs-number">1</span>).append(<span class="hljs-string">&quot;名: &quot;</span>)<br>                      .append(item.word).append(<span class="hljs-string">&quot; 出现次数: &quot;</span>).append(item.count).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br>            <br>            out.collect(result.toString());<br>            itemState.clear();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-海量数据排序">2. 海量数据排序</h2>
<h3 id="传统解法-vs-大数据解法">传统解法 vs 大数据解法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传统解法：受内存限制</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>    Arrays.sort(nums);  <span class="hljs-comment">// 单机内存限制</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="spark解法：分布式排序">Spark解法：分布式排序</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 全局排序（慎用：需要shuffle）</span><br><span class="hljs-keyword">val</span> sortedData = data.sortBy(identity)<br><br><span class="hljs-comment">// 分区内排序（推荐）</span><br><span class="hljs-keyword">val</span> sortedData = data.mapPartitions(iter =&gt; iter.toList.sorted.iterator)<br><br><span class="hljs-comment">// 自定义排序器处理大数据</span><br><span class="hljs-keyword">val</span> sortedRDD = data<br>  .map(x =&gt; (x, x))  <span class="hljs-comment">// 创建key-value对</span><br>  .partitionBy(<span class="hljs-keyword">new</span> <span class="hljs-type">HashPartitioner</span>(<span class="hljs-number">100</span>))  <span class="hljs-comment">// 分区</span><br>  .sortByKey()  <span class="hljs-comment">// 分区内排序</span><br>  .map(_._2)  <span class="hljs-comment">// 提取值</span><br></code></pre></td></tr></table></figure>
<h3 id="flink解法：流式排序">Flink解法：流式排序</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Flink 窗口内排序</span><br>DataStream&lt;Integer&gt; sortedStream = numbers<br>    .windowAll(TumblingProcessingTimeWindows.of(Time.seconds(<span class="hljs-number">10</span>)))<br>    .process(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProcessAllWindowFunction</span>&lt;Integer, Integer, TimeWindow&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(Context context, Iterable&lt;Integer&gt; elements, Collector&lt;Integer&gt; out)</span> &#123;<br>            List&lt;Integer&gt; sortedList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            elements.forEach(sortedList::add);<br>            <br>            Collections.sort(sortedList);<br>            <br>            <span class="hljs-keyword">for</span> (Integer num : sortedList) &#123;<br>                out.collect(num);<br>            &#125;<br>        &#125;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<h2 id="3-海量数据去重">3. 海量数据去重</h2>
<h3 id="传统解法-vs-大数据解法">传统解法 vs 大数据解法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传统解法：内存限制</span><br>Set&lt;String&gt; unique = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(list);<br></code></pre></td></tr></table></figure>
<h3 id="spark解法：分布式去重">Spark解法：分布式去重</h3>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 精确去重</span><br><span class="hljs-keyword">val</span> distinctData = data.distinct()<br><br><span class="hljs-comment">// 内存优化的去重</span><br><span class="hljs-keyword">val</span> distinctData = data<br>  .map(x =&gt; (x, <span class="hljs-literal">null</span>))<br>  .reduceByKey((a, b) =&gt; a)<br>  .map(_._1)<br><br><span class="hljs-comment">// 近似去重（大数据场景推荐）</span><br><span class="hljs-keyword">import</span> org.apache.spark.util.sketch.<span class="hljs-type">BloomFilter</span><br><span class="hljs-keyword">val</span> expectedNumItems = <span class="hljs-number">1000000</span>L<br><span class="hljs-keyword">val</span> fpp = <span class="hljs-number">0.03</span>  <span class="hljs-comment">// 3%误判率</span><br><br><span class="hljs-keyword">val</span> bloomFilter = <span class="hljs-type">BloomFilter</span>.create(expectedNumItems, fpp)<br><span class="hljs-comment">// 使用Bloom Filter进行预过滤</span><br></code></pre></td></tr></table></figure>
<h3 id="flink解法：实时去重">Flink解法：实时去重</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Flink状态去重</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeduplicationProcessFunction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">KeyedProcessFunction</span>&lt;String, String, String&gt; &#123;<br>    <span class="hljs-keyword">private</span> ValueState&lt;Boolean&gt; seenBefore;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processElement</span><span class="hljs-params">(String value, Context ctx, Collector&lt;String&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (seenBefore.value() == <span class="hljs-literal">null</span>) &#123;<br>            seenBefore.update(<span class="hljs-literal">true</span>);<br>            out.collect(value);  <span class="hljs-comment">// 第一次见到，输出</span><br>        &#125;<br>        <span class="hljs-comment">// 重复数据，忽略</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="4-词频统计-wordcount升级版">4. 词频统计（WordCount升级版）</h2>
<h3 id="flink实时词频统计">Flink实时词频统计</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RealTimeWordCount</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">StreamExecutionEnvironment</span> <span class="hljs-variable">env</span> <span class="hljs-operator">=</span> StreamExecutionEnvironment.getExecutionEnvironment();<br>        <br>        <span class="hljs-comment">// 实时词频统计，每5秒输出一次结果</span><br>        env.socketTextStream(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9999</span>)<br>           .flatMap(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FlatMapFunction</span>&lt;String, Tuple2&lt;String, Integer&gt;&gt;() &#123;<br>               <span class="hljs-meta">@Override</span><br>               <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flatMap</span><span class="hljs-params">(String sentence, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> &#123;<br>                   <span class="hljs-keyword">for</span> (String word : sentence.split(<span class="hljs-string">&quot;\\s&quot;</span>)) &#123;<br>                       out.collect(Tuple2.of(word, <span class="hljs-number">1</span>));<br>                   &#125;<br>               &#125;<br>           &#125;)<br>           .keyBy(value -&gt; value.f0)<br>           .window(TumblingProcessingTimeWindows.of(Time.seconds(<span class="hljs-number">5</span>)))<br>           .sum(<span class="hljs-number">1</span>)<br>           .print();<br>           <br>        env.execute(<span class="hljs-string">&quot;Real Time Word Count&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="5-滑动窗口问题">5. 滑动窗口问题</h2>
<h3 id="传统解法-vs-flink解法">传统解法 vs Flink解法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传统解法：双指针滑动窗口</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">maxSumSubarray</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">windowSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        windowSum += nums[i];<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">maxSum</span> <span class="hljs-operator">=</span> windowSum;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> k; i &lt; nums.length; i++) &#123;<br>        windowSum = windowSum - nums[i - k] + nums[i];<br>        maxSum = Math.max(maxSum, windowSum);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="flink滑动窗口聚合">Flink滑动窗口聚合</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Flink 滑动窗口最大值</span><br>DataStream&lt;Integer&gt; maxValues = numbers<br>    .keyBy(x -&gt; <span class="hljs-string">&quot;global&quot;</span>)  <span class="hljs-comment">// 全局窗口</span><br>    .window(SlidingProcessingTimeWindows.of(Time.seconds(<span class="hljs-number">10</span>), Time.seconds(<span class="hljs-number">2</span>)))<br>    .max(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 复杂滑动窗口逻辑</span><br>DataStream&lt;Double&gt; avgValues = prices<br>    .keyBy(price -&gt; price.symbol)<br>    .window(SlidingProcessingTimeWindows.of(Time.minutes(<span class="hljs-number">5</span>), Time.seconds(<span class="hljs-number">30</span>)))<br>    .aggregate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AverageAggregate</span>());<br></code></pre></td></tr></table></figure>
<h2 id="6-经典面试题的flink实现集合">6. 经典面试题的Flink实现集合</h2>
<h3 id="6-1-两数之和-分布式版">6.1 两数之和（分布式版）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在大数据流中找到和为target的数字对</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoSumProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CoProcessFunction</span>&lt;Integer, Integer, Tuple2&lt;Integer, Integer&gt;&gt; &#123;<br>    <span class="hljs-keyword">private</span> ValueState&lt;Set&lt;Integer&gt;&gt; numbersState;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> target;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processElement1</span><span class="hljs-params">(Integer value, Context ctx, Collector&lt;Tuple2&lt;Integer, Integer&gt;&gt; out)</span> &#123;<br>        Set&lt;Integer&gt; numbers = numbersState.value();<br>        <span class="hljs-keyword">if</span> (numbers == <span class="hljs-literal">null</span>) numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">complement</span> <span class="hljs-operator">=</span> target - value;<br>        <span class="hljs-keyword">if</span> (numbers.contains(complement)) &#123;<br>            out.collect(Tuple2.of(complement, value));<br>        &#125;<br>        <br>        numbers.add(value);<br>        numbersState.update(numbers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-2-最长递增子序列-流式版">6.2 最长递增子序列（流式版）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在大数据流中找到和为target的数字对</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TwoSumProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CoProcessFunction</span>&lt;Integer, Integer, Tuple2&lt;Integer, Integer&gt;&gt; &#123;<br>    <span class="hljs-keyword">private</span> ValueState&lt;Set&lt;Integer&gt;&gt; numbersState;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> target;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processElement1</span><span class="hljs-params">(Integer value, Context ctx, Collector&lt;Tuple2&lt;Integer, Integer&gt;&gt; out)</span> &#123;<br>        Set&lt;Integer&gt; numbers = numbersState.value();<br>        <span class="hljs-keyword">if</span> (numbers == <span class="hljs-literal">null</span>) numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">complement</span> <span class="hljs-operator">=</span> target - value;<br>        <span class="hljs-keyword">if</span> (numbers.contains(complement)) &#123;<br>            out.collect(Tuple2.of(complement, value));<br>        &#125;<br>        <br>        numbers.add(value);<br>        numbersState.update(numbers);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-2-最长递增子序列-流式版">6.2 最长递增子序列（流式版）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 流式计算最长递增子序列长度</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LISProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">KeyedProcessFunction</span>&lt;String, Integer, Integer&gt; &#123;<br>    <span class="hljs-keyword">private</span> ListState&lt;Integer&gt; sequenceState;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processElement</span><span class="hljs-params">(Integer value, Context ctx, Collector&lt;Integer&gt; out)</span> &#123;<br>        List&lt;Integer&gt; sequence = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">if</span> (sequenceState.get() != <span class="hljs-literal">null</span>) &#123;<br>            sequenceState.get().forEach(sequence::add);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 二分查找插入位置</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">pos</span> <span class="hljs-operator">=</span> Collections.binarySearch(sequence, value);<br>        <span class="hljs-keyword">if</span> (pos &lt; <span class="hljs-number">0</span>) pos = -(pos + <span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-keyword">if</span> (pos == sequence.size()) &#123;<br>            sequence.add(value);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sequence.set(pos, value);<br>        &#125;<br>        <br>        sequenceState.update(sequence);<br>        out.collect(sequence.size());  <span class="hljs-comment">// 输出当前LIS长度</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="性能对比总结">性能对比总结</h2>
<table>
<thead>
<tr>
<th>数据量</th>
<th>传统算法</th>
<th>Spark</th>
<th>Flink</th>
<th>推荐方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>&lt;1GB</td>
<td>✓ 优选</td>
<td>▲ 过度设计</td>
<td>▲ 过度设计</td>
<td>传统算法</td>
</tr>
<tr>
<td>1GB-100GB</td>
<td>× 内存不足</td>
<td>✓ 优选</td>
<td>✓ 适用</td>
<td>Spark批处理</td>
</tr>
<tr>
<td>&gt;100GB</td>
<td>× 无法处理</td>
<td>✓ 优选</td>
<td>✓ 优选</td>
<td>Spark/Flink</td>
</tr>
<tr>
<td>实时流</td>
<td>× 无法处理</td>
<td>▲ 微批处理</td>
<td>✓ 优选</td>
<td>Flink流处理</td>
</tr>
</tbody>
</table>
<h2 id="最佳实践建议">最佳实践建议</h2>
<h3 id="选择原则">选择原则</h3>
<ol>
<li>数据量 &lt; 1GB: 传统算法 + 单机优化</li>
<li>数据量 1GB-100GB: Spark批处理</li>
<li>数据量 &gt; 100GB: Spark集群 + 分区优化</li>
<li>实时需求: Flink流处理</li>
<li>近似结果可接受: 概率数据结构（Bloom Filter, HyperLogLog）</li>
</ol>
<h1>缓存系统设计：从击穿到雪崩的完整面试攻略</h1>
<h2 id="核心概念重新定义">核心概念重新定义</h2>
<blockquote>
<p>关于术语说明：缓存击穿、缓存穿透等概念确实是中文技术圈的&quot;本土化&quot;表达。在英文环境中，我们通常用更直观的描述，如&quot;Cache Miss<br>
Storm&quot;、&quot;Database Overload&quot;等。</p>
</blockquote>
<h3 id="三大缓存问题的本质">三大缓存问题的本质</h3>
<table>
<thead>
<tr>
<th>问题类型</th>
<th>英文描述</th>
<th>核心症状</th>
<th>业务影响</th>
</tr>
</thead>
<tbody>
<tr>
<td>缓存穿透</td>
<td>Cache Penetration</td>
<td>恶意查询不存在的数据</td>
<td>数据库被打垮</td>
</tr>
<tr>
<td>缓存击穿</td>
<td>Cache Breakdown</td>
<td>热点数据过期瞬间</td>
<td>短时间内数据库压力激增</td>
</tr>
<tr>
<td>缓存雪崩</td>
<td>Cache Avalanche</td>
<td>大量缓存同时失效</td>
<td>整个系统瘫痪</td>
</tr>
</tbody>
</table>
<h2 id="经典面试题：设计一个高可用的缓存系统">经典面试题：设计一个高可用的缓存系统</h2>
<h3 id="题目背景">题目背景</h3>
<blockquote>
<p>面试官：假设你要为一个DAU 1000万的电商平台设计商品详情页的缓存系统。系统需要处理以下挑战：</p>
<ol>
<li>商品数据的实时性要求</li>
<li>热门商品的高并发访问</li>
<li>恶意爬虫的无效查询</li>
<li>大促期间的流量激增</li>
</ol>
</blockquote>
<h3 id="step-1-需求分析和规模估算">Step 1: 需求分析和规模估算</h3>
<h4 id="1-1-功能需求">1.1 功能需求</h4>
<p><strong>Primary Requirements:</strong></p>
<ul>
<li>商品详情数据缓存</li>
<li>支持实时数据更新</li>
<li>处理高并发读取</li>
</ul>
<p><strong>Non-functional Requirements:</strong></p>
<ul>
<li>99.9% 可用性</li>
<li>P99延迟 &lt; 100ms</li>
<li>支持水平扩展</li>
</ul>
<h4 id="1-2-规模估算">1.2 规模估算</h4>
<p><strong>Traffic Estimation:</strong></p>
<ul>
<li>DAU: 10M users</li>
<li>平均每用户查看商品: 20次/天</li>
<li>读取 QPS = 10M * 20 / 86400 ≈ 2,300 QPS</li>
<li>峰值 QPS = 2,300 * 10 = 23,000 QPS</li>
</ul>
<p><strong>Storage Estimation:</strong></p>
<ul>
<li>商品总数: 10M</li>
<li>每个商品详情: 10KB</li>
<li>总存储需求: 10M * 10KB = 100GB</li>
<li>考虑副本和缓存: 300GB</li>
</ul>
<h3 id="step-2-高层系统架构">Step 2: 高层系统架构</h3>
<pre><code class="hljs mermaid">graph TB
    Client[移动端/Web端] --&gt; LB[负载均衡器]
    LB --&gt; API[API Gateway]
    API --&gt; Cache[分布式缓存层]
    Cache --&gt; DB[(主数据库)]
    Cache --&gt; Replica[(读副本)]
    
    subgraph &quot;缓存层架构&quot;
        L1[L1: 本地缓存]
        L2[L2: Redis集群]
        L3[L3: 数据库]
    end
    
    subgraph &quot;防护措施&quot;
        BF[布隆过滤器]
        CB[熔断器]
        RL[限流器]
    end</code></pre>
<h3 id="step-3-核心问题解决方案">Step 3: 核心问题解决方案</h3>
<h4 id="3-1-缓存穿透解决方案">3.1 缓存穿透解决方案</h4>
<h5 id="问题场景">问题场景</h5>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">// 恶意查询不存在的商品ID<br>GET /api/products/999999999<br>GET /api/products/-1<br>GET /api/products/abc123<br></code></pre></td></tr></table></figure>
<h5 id="解决方案1：布隆过滤器">解决方案1：布隆过滤器</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductCacheService</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> BloomFilter&lt;String&gt; bloomFilter;<br>    <span class="hljs-keyword">private</span> RedisTemplate&lt;String, Object&gt; redisTemplate;<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initBloomFilter</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 初始化布隆过滤器，预估1000万商品，误判率0.01%</span><br>        bloomFilter = BloomFilter.create(<br>            Funnels.stringFunnel(Charset.defaultCharset()), <br>            <span class="hljs-number">10_000_000</span>, <br>            <span class="hljs-number">0.0001</span><br>        );<br>        <br>        <span class="hljs-comment">// 将所有存在的商品ID加入布隆过滤器</span><br>        loadExistingProductIds();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> ProductDTO <span class="hljs-title function_">getProduct</span><span class="hljs-params">(String productId)</span> &#123;<br>        <span class="hljs-comment">// 第一道防线：布隆过滤器</span><br>        <span class="hljs-keyword">if</span> (!bloomFilter.mightContain(productId)) &#123;<br>            log.info(<span class="hljs-string">&quot;Product &#123;&#125; filtered by bloom filter&quot;</span>, productId);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 直接返回，不查询数据库</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// 第二道防线：缓存查询</span><br>        <span class="hljs-type">ProductDTO</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> getFromCache(productId);<br>        <span class="hljs-keyword">if</span> (product != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> product;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 第三道防线：数据库查询 + 分布式锁</span><br>        <span class="hljs-keyword">return</span> getFromDatabaseWithLock(productId);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> ProductDTO <span class="hljs-title function_">getFromDatabaseWithLock</span><span class="hljs-params">(String productId)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;product_lock:&quot;</span> + productId;<br>        <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(lockKey)) &#123;<br>            <span class="hljs-comment">// 尝试获取锁，最多等待100ms</span><br>            <span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">100</span>, TimeUnit.MILLISECONDS)) &#123;<br>                <br>                <span class="hljs-comment">// 双重检查：再次从缓存查询</span><br>                <span class="hljs-type">ProductDTO</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> getFromCache(productId);<br>                <span class="hljs-keyword">if</span> (product != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> product;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 查询数据库</span><br>                product = productRepository.findById(productId);<br>                <br>                <span class="hljs-keyword">if</span> (product != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 存在则缓存</span><br>                    cacheProduct(productId, product, <span class="hljs-number">3600</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 不存在则缓存空值，防止缓存穿透</span><br>                    cacheEmptyValue(productId, <span class="hljs-number">300</span>);<br>                &#125;<br>                <br>                <span class="hljs-keyword">return</span> product;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 获取锁失败，返回空值或重试</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceException</span>(<span class="hljs-string">&quot;Lock interrupted&quot;</span>, e);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cacheEmptyValue</span><span class="hljs-params">(String productId, <span class="hljs-type">int</span> ttl)</span> &#123;<br>        <span class="hljs-comment">// 缓存空值标记，TTL较短</span><br>        redisTemplate.opsForValue().set(<br>            <span class="hljs-string">&quot;product:&quot;</span> + productId, <br>            <span class="hljs-string">&quot;EMPTY&quot;</span>, <br>            ttl, <br>            TimeUnit.SECONDS<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="解决方案2：缓存空值-短ttl">解决方案2：缓存空值 + 短TTL</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CachePenetrationDefense</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">EMPTY_CACHE_VALUE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;CACHE_EMPTY_OBJECT&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EMPTY_CACHE_TTL</span> <span class="hljs-operator">=</span> <span class="hljs-number">300</span>; <span class="hljs-comment">// 5分钟</span><br>    <br>    <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">getWithEmptyCache</span><span class="hljs-params">(String key, Function&lt;String, T&gt; dataLoader, </span><br><span class="hljs-params">                                   <span class="hljs-type">int</span> normalTtl, Class&lt;T&gt; clazz)</span> &#123;<br>        <br>        <span class="hljs-comment">// 1. 尝试从缓存获取</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">cached</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(key);<br>        <br>        <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (EMPTY_CACHE_VALUE.equals(cached)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 空值缓存命中</span><br>            &#125;<br>            <span class="hljs-keyword">return</span> JSON.parseObject(cached, clazz);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 2. 缓存未命中，查询数据源</span><br>        <span class="hljs-type">T</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> dataLoader.apply(key);<br>        <br>        <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 缓存正常数据</span><br>            redisTemplate.opsForValue().set(key, JSON.toJSONString(data), <br>                                          normalTtl, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 缓存空值，防止穿透</span><br>            redisTemplate.opsForValue().set(key, EMPTY_CACHE_VALUE, <br>                                          EMPTY_CACHE_TTL, TimeUnit.SECONDS);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-2-缓存击穿解决方案">3.2 缓存击穿解决方案</h4>
<h5 id="问题场景">问题场景</h5>
<blockquote>
<p>// 热门商品缓存过期瞬间，1000个并发请求同时打到数据库<br>
// Product ID: hot_product_123(iPhone新品)<br>
// 并发请求量: 1000 QPS → 数据库瞬间压力激增</p>
</blockquote>
<h5 id="解决方案1：分布式锁-双重检查">解决方案1：分布式锁 + 双重检查</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotDataCacheService</span> &#123;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedissonClient redissonClient;<br>    <br>    <span class="hljs-keyword">public</span> ProductDTO <span class="hljs-title function_">getHotProduct</span><span class="hljs-params">(String productId)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hot_product:&quot;</span> + productId;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:hot_product:&quot;</span> + productId;<br>        <br>        <span class="hljs-comment">// 第一次查询缓存</span><br>        <span class="hljs-type">ProductDTO</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> getFromCache(cacheKey);<br>        <span class="hljs-keyword">if</span> (product != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> product;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 缓存未命中，获取分布式锁</span><br>        <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(lockKey);<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 尝试获取锁，最多等待1秒，锁持有时间10秒</span><br>            <span class="hljs-keyword">if</span> (lock.tryLock(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS)) &#123;<br>                <br>                <span class="hljs-comment">// 双重检查：再次查询缓存</span><br>                product = getFromCache(cacheKey);<br>                <span class="hljs-keyword">if</span> (product != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> product; <span class="hljs-comment">// 其他线程已经加载过了</span><br>                &#125;<br>                <br>                <span class="hljs-comment">// 从数据库加载数据</span><br>                product = loadFromDatabase(productId);<br>                <br>                <span class="hljs-keyword">if</span> (product != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 缓存热点数据，设置较长TTL + 随机数防止雪崩</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">ttl</span> <span class="hljs-operator">=</span> <span class="hljs-number">3600</span> + RandomUtils.nextInt(<span class="hljs-number">0</span>, <span class="hljs-number">600</span>); <span class="hljs-comment">// 1-1.1小时</span><br>                    cacheWithTtl(cacheKey, product, ttl);<br>                &#125;<br>                <br>                <span class="hljs-keyword">return</span> product;<br>                <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 获取锁失败的策略</span><br>                <span class="hljs-keyword">return</span> handleLockFailure(productId);<br>            &#125;<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceException</span>(<span class="hljs-string">&quot;Cache lock interrupted&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (lock.isHeldByCurrentThread()) &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> ProductDTO <span class="hljs-title function_">handleLockFailure</span><span class="hljs-params">(String productId)</span> &#123;<br>        <span class="hljs-comment">// 策略1: 返回旧缓存数据（如果有）</span><br>        <span class="hljs-type">ProductDTO</span> <span class="hljs-variable">staleData</span> <span class="hljs-operator">=</span> getStaleCache(productId);<br>        <span class="hljs-keyword">if</span> (staleData != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> staleData;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 策略2: 降级到数据库查询（限流）</span><br>        <span class="hljs-keyword">return</span> rateLimitedDbQuery(productId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="解决方案2：热点数据预热-异步更新">解决方案2：热点数据预热 + 异步更新</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HotDataPreloader</span> &#123;<br>    <br>    <span class="hljs-meta">@Scheduled(fixedRate = 300000)</span> <span class="hljs-comment">// 每5分钟执行一次</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preloadHotData</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1. 从分析系统获取热点商品列表</span><br>        List&lt;String&gt; hotProductIds = analyticsService.getHotProducts(<span class="hljs-number">100</span>);<br>        <br>        <span class="hljs-comment">// 2. 并行预热缓存</span><br>        hotProductIds.parallelStream().forEach(<span class="hljs-built_in">this</span>::preloadProduct);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">preloadProduct</span><span class="hljs-params">(String productId)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ProductDTO</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> productRepository.findById(productId);<br>            <span class="hljs-keyword">if</span> (product != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">cacheKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hot_product:&quot;</span> + productId;<br>                <br>                <span class="hljs-comment">// 设置较长TTL + 随机偏移</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">baseTtl</span> <span class="hljs-operator">=</span> <span class="hljs-number">7200</span>; <span class="hljs-comment">// 2小时</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">randomOffset</span> <span class="hljs-operator">=</span> RandomUtils.nextInt(<span class="hljs-number">0</span>, <span class="hljs-number">1800</span>); <span class="hljs-comment">// 0-30分钟随机</span><br>                <br>                redisTemplate.opsForValue().set(cacheKey, <br>                    JSON.toJSONString(product), <br>                    baseTtl + randomOffset, <br>                    TimeUnit.SECONDS);<br>                <br>                log.info(<span class="hljs-string">&quot;Preloaded hot product: &#123;&#125;&quot;</span>, productId);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;Failed to preload product: &#123;&#125;&quot;</span>, productId, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="3-3-缓存雪崩解决方案">3.3 缓存雪崩解决方案</h4>
<h5 id="问题场景">问题场景</h5>
<blockquote>
<p>// 大促活动结束，大量商品缓存同时过期<br>
// 时间: 2023-11-11 23:59:59<br>
// 影响: 100万个商品缓存同时失效<br>
// 结果: 数据库瞬间承受100万QPS压力</p>
</blockquote>
<h5 id="解决方案：多层防护架构">解决方案：多层防护架构</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheAvalancheDefense</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1. TTL随机化：防止同时过期</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cacheWithRandomTtl</span><span class="hljs-params">(String key, Object value, <span class="hljs-type">int</span> baseTtl)</span> &#123;<br>        <span class="hljs-comment">// 基础TTL + 随机偏移(10%-20%)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">randomOffset</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (baseTtl * <span class="hljs-number">0.1</span> + Math.random() * baseTtl * <span class="hljs-number">0.1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">finalTtl</span> <span class="hljs-operator">=</span> baseTtl + randomOffset;<br>        <br>        redisTemplate.opsForValue().set(key, JSON.toJSONString(value), <br>                                      finalTtl, TimeUnit.SECONDS);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2. 多级缓存架构</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Component</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiLevelCache</span> &#123;<br>        <br>        <span class="hljs-keyword">private</span> LoadingCache&lt;String, ProductDTO&gt; localCache;<br>        <span class="hljs-keyword">private</span> RedisTemplate&lt;String, String&gt; redisTemplate;<br>        <br>        <span class="hljs-meta">@PostConstruct</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// L1: 本地缓存（Caffeine）</span><br>            localCache = Caffeine.newBuilder()<br>                .maximumSize(<span class="hljs-number">10_000</span>)<br>                .expireAfterWrite(<span class="hljs-number">5</span>, TimeUnit.MINUTES)<br>                .refreshAfterWrite(<span class="hljs-number">3</span>, TimeUnit.MINUTES)<br>                .build(<span class="hljs-built_in">this</span>::loadFromRedis);<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> ProductDTO <span class="hljs-title function_">getProduct</span><span class="hljs-params">(String productId)</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// L1: 本地缓存</span><br>                <span class="hljs-keyword">return</span> localCache.get(productId);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">// L1失败，降级到L2</span><br>                <span class="hljs-keyword">return</span> getFromRedisWithFallback(productId);<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">private</span> ProductDTO <span class="hljs-title function_">loadFromRedis</span><span class="hljs-params">(String productId)</span> &#123;<br>            <span class="hljs-comment">// L2: Redis缓存</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">cached</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;product:&quot;</span> + productId);<br>            <span class="hljs-keyword">if</span> (cached != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> JSON.parseObject(cached, ProductDTO.class);<br>            &#125;<br>            <br>            <span class="hljs-comment">// L3: 数据库（带熔断保护）</span><br>            <span class="hljs-keyword">return</span> loadFromDatabaseWithCircuitBreaker(productId);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 3. 熔断器保护数据库</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Component</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseCircuitBreaker</span> &#123;<br>        <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> CircuitBreaker circuitBreaker;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">DatabaseCircuitBreaker</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-built_in">this</span>.circuitBreaker = CircuitBreaker.ofDefaults(<span class="hljs-string">&quot;database&quot;</span>);<br>            <br>            <span class="hljs-comment">// 配置熔断器</span><br>            circuitBreaker.getEventPublisher()<br>                .onStateTransition(event -&gt; <br>                    log.info(<span class="hljs-string">&quot;Circuit breaker state transition: &#123;&#125;&quot;</span>, event));<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> ProductDTO <span class="hljs-title function_">queryDatabase</span><span class="hljs-params">(String productId)</span> &#123;<br>            <span class="hljs-keyword">return</span> circuitBreaker.executeSupplier(() -&gt; &#123;<br>                <span class="hljs-keyword">return</span> productRepository.findById(productId);<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="step-4-监控和运维方案">Step 4: 监控和运维方案</h3>
<h4 id="4-1-关键指标监控">4.1 关键指标监控</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheMetrics</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> MeterRegistry meterRegistry;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Counter cacheHits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Counter cacheMisses;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Counter cachePenetrations;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CacheMetrics</span><span class="hljs-params">(MeterRegistry meterRegistry)</span> &#123;<br>        <span class="hljs-built_in">this</span>.meterRegistry = meterRegistry;<br>        <span class="hljs-built_in">this</span>.cacheHits = Counter.builder(<span class="hljs-string">&quot;cache.hits&quot;</span>)<br>            .description(<span class="hljs-string">&quot;Cache hit count&quot;</span>)<br>            .register(meterRegistry);<br>        <br>        <span class="hljs-built_in">this</span>.cacheMisses = Counter.builder(<span class="hljs-string">&quot;cache.misses&quot;</span>)<br>            .description(<span class="hljs-string">&quot;Cache miss count&quot;</span>)<br>            .register(meterRegistry);<br>            <br>        <span class="hljs-built_in">this</span>.cachePenetrations = Counter.builder(<span class="hljs-string">&quot;cache.penetrations&quot;</span>)<br>            .description(<span class="hljs-string">&quot;Cache penetration count&quot;</span>)<br>            .register(meterRegistry);<br>    &#125;<br>    <br>    <span class="hljs-meta">@EventListener</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleCacheEvent</span><span class="hljs-params">(CacheEvent event)</span> &#123;<br>        <span class="hljs-keyword">switch</span> (event.getType()) &#123;<br>            <span class="hljs-keyword">case</span> HIT:<br>                cacheHits.increment();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> MISS:<br>                cacheMisses.increment();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> PENETRATION:<br>                cachePenetrations.increment();<br>                <span class="hljs-comment">// 触发告警</span><br>                alertService.sendAlert(<span class="hljs-string">&quot;Cache penetration detected: &quot;</span> + event.getKey());<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="4-2-实时告警配置">4.2 实时告警配置</h4>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># prometheus alerting rules</span><br><span class="hljs-attr">groups:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">cache.rules</span><br>    <span class="hljs-attr">rules:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">CacheHitRateLow</span><br>        <span class="hljs-attr">expr:</span> <span class="hljs-string">cache_hits_total</span> <span class="hljs-string">/</span> <span class="hljs-string">(cache_hits_total</span> <span class="hljs-string">+</span> <span class="hljs-string">cache_misses_total)</span> <span class="hljs-string">&lt;</span> <span class="hljs-number">0.8</span><br>        <span class="hljs-attr">for:</span> <span class="hljs-string">5m</span><br>        <span class="hljs-attr">labels:</span><br>          <span class="hljs-attr">severity:</span> <span class="hljs-string">warning</span><br>        <span class="hljs-attr">annotations:</span><br>          <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;Cache hit rate is below 80%&quot;</span><br>          <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">CachePenetrationHigh</span><br>        <span class="hljs-attr">expr:</span> <span class="hljs-string">rate(cache_penetrations_total[5m])</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">100</span><br>        <span class="hljs-attr">for:</span> <span class="hljs-string">1m</span><br>        <span class="hljs-attr">labels:</span><br>          <span class="hljs-attr">severity:</span> <span class="hljs-string">critical</span><br>        <span class="hljs-attr">annotations:</span><br>          <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;High cache penetration rate detected&quot;</span><br>          <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">alert:</span> <span class="hljs-string">DatabaseConnectionsHigh</span><br>        <span class="hljs-attr">expr:</span> <span class="hljs-string">database_connections_active</span> <span class="hljs-string">&gt;</span> <span class="hljs-number">80</span><br>        <span class="hljs-attr">for:</span> <span class="hljs-string">2m</span><br>        <span class="hljs-attr">labels:</span><br>          <span class="hljs-attr">severity:</span> <span class="hljs-string">critical</span><br>        <span class="hljs-attr">annotations:</span><br>          <span class="hljs-attr">summary:</span> <span class="hljs-string">&quot;Database connection pool near exhaustion&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="step-5-压力测试和容量规划">Step 5: 压力测试和容量规划</h3>
<h4 id="5-1-压力测试脚本">5.1 压力测试脚本</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheStressTest</span> &#123;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCachePenetrationDefense</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">100</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1000</span>);<br>        <br>        <span class="hljs-comment">// 模拟1000个并发请求查询不存在的商品</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">fakeProductId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;fake_product_&quot;</span> + i;<br>            <br>            executor.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                    <span class="hljs-type">ProductDTO</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> productCacheService.getProduct(fakeProductId);<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>                    <br>                    <span class="hljs-comment">// 记录响应时间</span><br>                    responseTimeRecorder.record(endTime - startTime, TimeUnit.MILLISECONDS);<br>                    <br>                    assertNull(<span class="hljs-string">&quot;Should return null for non-existent product&quot;</span>, product);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    latch.countDown();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <br>        latch.await(<span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>        <br>        <span class="hljs-comment">// 验证数据库连接数没有激增</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">dbConnections</span> <span class="hljs-operator">=</span> dataSource.getActiveConnections();<br>        assertTrue(<span class="hljs-string">&quot;DB connections should remain low&quot;</span>, dbConnections &lt; <span class="hljs-number">10</span>);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCacheBreakdownDefense</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 模拟热点数据缓存过期</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">hotProductId</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hot_product_iphone15&quot;</span>;<br>        <br>        <span class="hljs-comment">// 删除缓存，模拟过期</span><br>        redisTemplate.delete(<span class="hljs-string">&quot;product:&quot;</span> + hotProductId);<br>        <br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1000</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1000</span>);<br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">dbQueryCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-comment">// 1000个并发请求同时访问</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            executor.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">ProductDTO</span> <span class="hljs-variable">product</span> <span class="hljs-operator">=</span> productCacheService.getProduct(hotProductId);<br>                    assertNotNull(<span class="hljs-string">&quot;Should return product data&quot;</span>, product);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    latch.countDown();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <br>        latch.await(<span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>        <br>        <span class="hljs-comment">// 验证只有少数请求打到了数据库</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">actualDbQueries</span> <span class="hljs-operator">=</span> dbQueryCount.get();<br>        assertTrue(<span class="hljs-string">&quot;DB queries should be minimal due to locking&quot;</span>, actualDbQueries &lt; <span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="step-6-面试评分标准">Step 6: 面试评分标准</h3>
<p>作为面试官，我会从以下维度评估候选人：</p>
<ul>
<li>技术深度 (40%)
<ul>
<li>能否准确理解三种缓存问题的本质差异</li>
<li>解决方案的技术选型是否合理</li>
<li>代码实现的质量和可维护性</li>
</ul>
</li>
<li>系统设计思维 (30%)
<ul>
<li>是否考虑了完整的系统架构</li>
<li>扩展性和可用性的权衡</li>
<li>监控和运维的前瞻性思考</li>
</ul>
</li>
<li>业务理解 (20%)
<ul>
<li>对电商场景的理解深度</li>
<li>成本效益的考量</li>
<li>用户体验的关注</li>
</ul>
</li>
<li>沟通表达 (10%)
<ul>
<li>逻辑清晰，层次分明</li>
<li>能够化繁为简，深入浅出</li>
<li>主动询问需求，互动良好</li>
</ul>
</li>
</ul>
<h2 id="总结：从概念到实践的跃迁">总结：从概念到实践的跃迁</h2>
<p>这套完整的缓存系统设计方案涵盖了从基础概念到生产实践的全部要点。在实际面试中，优秀的候选人应该能够：</p>
<ol>
<li>深入理解业务场景：不仅知道技术方案，更要理解业务背景</li>
<li>全局思维：从单点优化扩展到系统性解决方案</li>
<li>工程实践：考虑监控、测试、运维等工程化要素</li>
<li>持续改进：具备迭代优化和技术演进的思维</li>
</ol>
<p>记住，技术面试不仅是技能考核，更是思维方式的交流。希望这套方案能帮助你在下次面试中脱颖而出！</p>
<h1>MESI 协议与 Java 锁的实现关系详解</h1>
<h2 id="📌-核心结论">📌 核心结论</h2>
<blockquote>
<p><strong>Java 锁通过内存屏障触发缓存同步，而缓存同步的底层实现依赖 MESI 协议保证多核 CPU 间的数据一致性，从而实现线程间的“可见性”。</strong></p>
</blockquote>
<hr>
<h2 id="一-什么是-mesi-协议？">一、什么是 MESI 协议？</h2>
<p>MESI 是现代多核 CPU 使用的<strong>缓存一致性协议</strong>（Cache Coherence Protocol），用于保证多个 CPU 核心看到的内存数据是一致的。</p>
<h3 id="mesi-四种状态：">MESI 四种状态：</h3>
<table>
<thead>
<tr>
<th>状态</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>M (Modified)</strong></td>
<td>修改</td>
<td>数据被本核修改，仅存在于本核缓存，主存是“脏”的</td>
</tr>
<tr>
<td><strong>E (Exclusive)</strong></td>
<td>独占</td>
<td>数据未被修改，仅存在于本核缓存，与主存一致</td>
</tr>
<tr>
<td><strong>S (Shared)</strong></td>
<td>共享</td>
<td>数据未被修改，存在于多个核缓存中</td>
</tr>
<tr>
<td><strong>I (Invalid)</strong></td>
<td>无效</td>
<td>缓存行无效，必须重新从主存或其他核加载</td>
</tr>
</tbody>
</table>
<h3 id="mesi-如何工作？">MESI 如何工作？</h3>
<ul>
<li>当 Core 0 修改缓存行 → 状态变为 <code>M</code></li>
<li>同时发送 <strong>Invalidate 消息</strong> → 其他核心对应缓存行变为 <code>I</code></li>
<li>其他核心再次访问该数据 → 必须重新加载最新值</li>
</ul>
<p>✅ <strong>MESI 保证了“写传播”和“事务串行化”</strong></p>
<hr>
<h2 id="二-java-锁的核心语义">二、Java 锁的核心语义</h2>
<p>Java 中的锁（如 <code>synchronized</code>, <code>ReentrantLock</code>）提供两个关键语义：</p>
<ol>
<li>
<p><strong>互斥性（Mutual Exclusion）</strong><br>
→ 同一时刻只有一个线程能进入临界区。</p>
</li>
<li>
<p><strong>可见性（Visibility）</strong><br>
→ 一个线程在临界区内对共享变量的修改，对后续进入临界区的线程是可见的。</p>
</li>
</ol>
<p>📌 <strong>“可见性”是 Java 内存模型（JMM）的核心要求之一。</strong></p>
<hr>
<h2 id="三-java-如何实现-可见性-？">三、Java 如何实现“可见性”？</h2>
<h3 id="关键机制：内存屏障-memory-barrier">关键机制：<strong>内存屏障（Memory Barrier）</strong></h3>
<p>JVM 在锁的边界插入内存屏障指令：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>    <span class="hljs-comment">// ← 进入时：插入 LoadLoad + LoadStore 屏障</span><br>    x = <span class="hljs-number">42</span>;<br>    <span class="hljs-comment">// ← 退出时：插入 StoreStore + StoreLoad 屏障</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="四种内存屏障：">四种内存屏障：</h3>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>LoadLoad</strong></td>
<td>保证前面的读操作在后面的读操作之前完成</td>
</tr>
<tr>
<td><strong>LoadStore</strong></td>
<td>保证前面的读操作在后面的写操作之前完成</td>
</tr>
<tr>
<td><strong>StoreStore</strong></td>
<td>保证前面的写操作在后面的写操作之前完成</td>
</tr>
<tr>
<td><strong>StoreLoad</strong></td>
<td>最强屏障，保证前面的写操作在后面的读操作之前完成，并刷新缓存</td>
</tr>
</tbody>
</table>
<blockquote>
<p>🔥 <strong>StoreLoad 是关键</strong>：它强制将 CPU 缓存中的修改写回主存（或同步给其他核），并使其他核缓存失效。</p>
</blockquote>
<h2 id="四-mesi-与-java-锁的协作流程">四、MESI 与 Java 锁的协作流程</h2>
<p>假设有两个线程分别运行在 Core 0 和 Core 1：</p>
<h3 id="场景：线程a-core-0-写数据-线程b-core-1-读数据">➤ 场景：线程A（Core 0）写数据，线程B（Core 1）读数据</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程A</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>    x = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 修改共享变量</span><br>&#125; <span class="hljs-comment">// 退出临界区</span><br><br><span class="hljs-comment">// 线程B</span><br><span class="hljs-keyword">synchronized</span>(lock) &#123;<br>    System.out.println(x); <span class="hljs-comment">// 应该看到 42</span><br>&#125; <span class="hljs-comment">// 进入临界区</span><br></code></pre></td></tr></table></figure>
<h3 id="执行流程：">执行流程：</h3>
<h4 id="step-1-线程a-修改-x">Step 1: 线程A 修改 x</h4>
<ul>
<li>Core 0 缓存行状态 → <code>M</code>（Modified）</li>
<li>x 的新值 <code>42</code> 暂存在 Core 0 缓存中，主存仍是旧值</li>
</ul>
<h4 id="step-2-线程a-释放锁">Step 2: 线程A 释放锁</h4>
<ul>
<li>JVM 插入 <strong>StoreLoad 屏障</strong></li>
<li>CPU 执行 StoreLoad → 强制刷新缓存</li>
<li>Core 0 发送 <strong>Invalidate 消息</strong> → Core 1 的 x 缓存行变为 <code>I</code></li>
</ul>
<h4 id="step-3-线程b-获取锁">Step 3: 线程B 获取锁</h4>
<ul>
<li>JVM 插入 LoadLoad 屏障</li>
<li>Core 1 读取 x → 发现缓存行是 <code>I</code> → 必须重新加载</li>
<li>从主存或 Core 0 加载最新值 <code>42</code></li>
<li>缓存行状态 → <code>S</code>（Shared）</li>
</ul>
<p>✅ <strong>可见性达成！</strong></p>
<h2 id="五-reentrantlock-与-mesi">五、ReentrantLock 与 MESI</h2>
<p><code>ReentrantLock</code> 基于 <code>Unsafe.compareAndSwapInt()</code>（CAS），CAS 操作本身具有 <strong>StoreLoad 语义</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>    <span class="hljs-keyword">return</span> unsafe.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>    <span class="hljs-comment">// CAS 成功时，隐含内存屏障，触发缓存同步</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以 <code>ReentrantLock</code> 也通过 CAS → 内存屏障 → MESI 协议，实现可见性。</p>
<hr>
<h2 id="六-volatile-与-synchronized-对比">六、volatile 与 synchronized 对比</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>volatile</th>
<th>synchronized</th>
</tr>
</thead>
<tbody>
<tr>
<td>可见性</td>
<td>✅（通过内存屏障）</td>
<td>✅（通过内存屏障 + 锁语义）</td>
</tr>
<tr>
<td>有序性</td>
<td>✅（禁止重排序）</td>
<td>✅（禁止重排序）</td>
</tr>
<tr>
<td>原子性</td>
<td>❌（仅单操作原子）</td>
<td>✅（临界区整体原子）</td>
</tr>
<tr>
<td>MESI 触发</td>
<td>✅（StoreLoad 屏障）</td>
<td>✅（StoreLoad 屏障）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>两者都依赖内存屏障 → 都触发 MESI → 都保证可见性。</p>
</blockquote>
<hr>
<h2 id="七-总结：java-锁与-mesi-的层级关系">七、总结：Java 锁与 MESI 的层级关系</h2>
<table>
<thead>
<tr>
<th>层级</th>
<th>组件</th>
<th>作用</th>
<th>如何关联</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>应用层</strong></td>
<td>Java <code>synchronized</code> / <code>ReentrantLock</code></td>
<td>提供锁语义，定义临界区</td>
<td>定义何时需要“可见性”</td>
</tr>
<tr>
<td><strong>JVM 层</strong></td>
<td>内存屏障（Memory Barrier）</td>
<td>强制缓存刷新、禁止重排序</td>
<td>在锁边界插入屏障，触发硬件行为</td>
</tr>
<tr>
<td><strong>硬件层</strong></td>
<td>MESI 协议</td>
<td>保证多核缓存一致性</td>
<td>被内存屏障触发，实现最终可见性</td>
</tr>
</tbody>
</table>
<blockquote>
<p>🧠 <strong>Java 锁的“可见性”不是魔法，而是通过内存屏障“命令”CPU 刷新缓存，再由 MESI 协议“协调”多核数据一致性来实现的。</strong></p>
</blockquote>
<hr>
<h2 id="💡-附加思考：如果没有-mesi？">💡 附加思考：如果没有 MESI？</h2>
<p>如果 CPU 没有缓存一致性协议（如早期多处理器系统），即使 JVM 插入内存屏障，也无法保证其他核心看到最新值 —— 必须依赖软件层面的“总线锁”或“缓存行锁”，性能极差。</p>
<p>✅ <strong>现代 CPU 的 MESI 协议，是高效并发编程的硬件基础！</strong></p>
<hr>
<h2 id="✅-最终结论">✅ 最终结论</h2>
<p><strong>Java 锁与 MESI 协议的关系是：</strong></p>
<blockquote>
<p>Java 锁定义语义 → 内存屏障实现语义 → MESI 协议保障语义在硬件层面正确执行。三者缺一不可。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2025/07/29/%E6%88%91%E4%B8%8E-AI-%E7%9A%84%E9%97%AE%E7%AD%94/">https://magicliang.github.io/2025/07/29/%E6%88%91%E4%B8%8E-AI-%E7%9A%84%E9%97%AE%E7%AD%94/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">程序设计</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-24.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">HTTP 请求体只读一次之谜：Go 与 Java 的应对之道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9A%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90-%E6%B5%81%E7%9A%84-%E9%98%85%E5%90%8E%E5%8D%B3%E7%84%9A-%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.1.</span> <span class="toc-text">第一部分：问题的根源——流的“阅后即焚”本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9Ago-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E7%81%B5%E6%B4%BB%E7%9B%B4%E6%8E%A5%E7%9A%84-io-%E5%B7%A5%E5%85%B7%E7%AE%B1"><span class="toc-number">1.2.</span> <span class="toc-text">第二部分：Go 的解决方案——灵活直接的 io 工具箱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%B8%80%EF%BC%9A%E5%85%88%E8%AF%BB%E5%90%8E%E5%86%99-%E7%AE%80%E5%8D%95%E4%BD%86%E6%9C%89%E9%A3%8E%E9%99%A9"><span class="toc-number">1.2.1.</span> <span class="toc-text">方案一：先读后写（简单但有风险）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%A1%88%E4%BA%8C%EF%BC%9A%E8%BE%B9%E8%AF%BB%E8%BE%B9%E5%A4%87-%E6%8E%A8%E8%8D%90%E7%9A%84%E5%81%A5%E5%A3%AE%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">方案二：边读边备（推荐的健壮模式）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9Ajava-%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88-%E7%BB%8F%E5%85%B8%E8%80%8C%E4%B8%A5%E8%B0%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">第三部分：Java 的解决方案——经典而严谨的设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%9A%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5-%E4%B8%BA%E4%BD%95parsemultipartform%E5%8F%AF%E4%BB%A5%E9%87%8D%E5%A4%8D%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">1.3.</span> <span class="toc-text">第四部分：特殊情况——为何ParseMultipartForm可以重复调用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%EF%BC%9A%E7%BB%93%E8%AE%BA-%E4%B8%80%E5%9C%BA%E5%85%B3%E4%BA%8E%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E7%9A%84%E5%AF%B9%E8%AF%9D"><span class="toc-number">1.4.</span> <span class="toc-text">第五部分：结论——一场关于设计哲学的对话</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">数据库写入的“潜规则”：深入分析合并树与MPP架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#part-1-%E5%90%88%E5%B9%B6-%E6%98%AF%E5%AE%BF%E5%91%BD-%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E5%90%88%E5%B9%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">2.1.</span> <span class="toc-text">Part 1: “合并”是宿命——两种不同的合并架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E7%BB%8F%E5%85%B8-lsm-tree%EF%BC%9A%E4%B8%BA%E9%AB%98%E9%A2%91%E6%9B%B4%E6%96%B0%E8%80%8C%E7%94%9F%E7%9A%84%E7%BC%93%E5%86%B2%E5%90%88%E5%B9%B6-hbase-rocksdb"><span class="toc-number">2.1.1.</span> <span class="toc-text">1.1 经典 LSM-Tree：为高频更新而生的缓冲合并 (HBase, RocksDB)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-clickhouse-mergetree%EF%BC%9A%E4%B8%BA%E6%9E%81%E8%87%B4%E5%88%86%E6%9E%90%E8%80%8C%E7%94%9F%E7%9A%84%E7%9B%B4%E6%8E%A5%E5%90%88%E5%B9%B6"><span class="toc-number">2.1.2.</span> <span class="toc-text">1.2 ClickHouse MergeTree：为极致分析而生的直接合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-2-mpp-%E6%9E%B6%E6%9E%84%E7%9A%84%E5%8F%A6%E4%B8%80%E7%A7%8D%E6%9D%83%E8%A1%A1-aws-redshift"><span class="toc-number">2.2.</span> <span class="toc-text">Part 2: MPP 架构的另一种权衡 - AWS Redshift</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E5%89%96%E6%9E%90%EF%BC%9Ampp-%E5%88%97%E5%BC%8F%E5%AD%98%E5%82%A8"><span class="toc-number">2.2.1.</span> <span class="toc-text">架构剖析：MPP + 列式存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E5%85%A5%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%B8%BA-%E6%89%B9%E9%87%8F%E5%8A%A0%E8%BD%BD-%E8%80%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.2.</span> <span class="toc-text">写入机制：为“批量加载”而设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A%E6%AE%8A%E9%80%94%E5%90%8C%E5%BD%92%E7%9A%84-%E6%89%B9%E9%87%8F%E5%86%99%E5%85%A5"><span class="toc-number">2.3.</span> <span class="toc-text">结论：殊途同归的“批量写入”</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">复制算法与架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">副本江湖：PacificA、Elasticsearch、Kafka、Pulsar 的“运输队”比喻</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%B6%E6%9E%84%E4%B8%8E%E8%8A%82%E7%82%B9%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">4.1.</span> <span class="toc-text">架构与节点对比表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mermaid-%E6%9E%B6%E6%9E%84%E9%80%9F%E8%A7%88"><span class="toc-number">4.2.</span> <span class="toc-text">Mermaid 架构速览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%A7%8B-pacifica"><span class="toc-number">4.2.1.</span> <span class="toc-text">原始 PacificA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#elasticsearch"><span class="toc-number">4.2.2.</span> <span class="toc-text">Elasticsearch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#kafka"><span class="toc-number">4.2.3.</span> <span class="toc-text">Kafka</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pulsar"><span class="toc-number">4.2.4.</span> <span class="toc-text">Pulsar</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">原码 · 反码 · 补码：环形数轴 + 基准锤教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%83%8C%E6%99%AF"><span class="toc-number">5.1.</span> <span class="toc-text">1  背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A7%92%E8%89%B2%E9%80%9F%E8%A7%88"><span class="toc-number">5.2.</span> <span class="toc-text">2  角色速览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%AC%A6%E5%8F%B7%E4%BD%8D"><span class="toc-number">5.3.</span> <span class="toc-text">3  符号位</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E4%B8%89%E7%A0%81%E8%AE%A1%E7%AE%97%E6%B5%81%E7%A8%8B-8-%E4%BD%8D"><span class="toc-number">5.4.</span> <span class="toc-text">4  三码计算流程（8 位）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%8E%AF%E5%BD%A2%E6%95%B0%E8%BD%B4-%E5%9F%BA%E5%87%86%E9%94%A4"><span class="toc-number">5.5.</span> <span class="toc-text">5  环形数轴 + 基准锤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E4%B8%BA%E4%BB%80%E4%B9%88-%E5%8F%8D%E7%A0%81-1"><span class="toc-number">5.6.</span> <span class="toc-text">6  为什么“反码 + 1”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%A1%A5%E7%A0%81-%E5%8E%9F%E7%A0%81"><span class="toc-number">5.7.</span> <span class="toc-text">7  补码 ↔ 原码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%87%8F%E6%B3%95%E5%8D%B3%E5%8A%A0%E6%B3%95"><span class="toc-number">5.8.</span> <span class="toc-text">8  减法即加法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E9%80%9F%E6%9F%A5%E8%A1%A8-8-%E4%BD%8D"><span class="toc-number">5.9.</span> <span class="toc-text">9 速查表（8 位）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E5%8F%A3%E8%AF%80"><span class="toc-number">5.10.</span> <span class="toc-text">10 口诀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-java-%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">5.11.</span> <span class="toc-text">11 Java 位移运算符</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">IEEE 754 浮点数：科学计数法的二进制实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E8%83%8C%E6%99%AF"><span class="toc-number">6.1.</span> <span class="toc-text">1 背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%A7%92%E8%89%B2%E9%80%9F%E8%A7%88"><span class="toc-number">6.2.</span> <span class="toc-text">2 角色速览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E5%85%AC%E5%BC%8F"><span class="toc-number">6.3.</span> <span class="toc-text">3 核心公式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E8%AE%A1%E7%AE%97-7-25"><span class="toc-number">6.3.1.</span> <span class="toc-text">示例计算 -7.25</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%89%B9%E6%AE%8A%E5%80%BC%EF%BC%9A%E7%AA%81%E7%A0%B4%E5%B8%B8%E8%A7%84%E7%9A%84%E7%BC%96%E7%A0%81"><span class="toc-number">6.4.</span> <span class="toc-text">4 特殊值：突破常规的编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E7%B2%BE%E5%BA%A6%E6%A0%87%E5%B0%BA%E4%B8%8E%E9%99%B7%E9%98%B1"><span class="toc-number">6.5.</span> <span class="toc-text">5 精度标尺与陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E7%B2%BE%E5%BA%A6%E8%8C%83%E5%9B%B4"><span class="toc-number">6.5.1.</span> <span class="toc-text">5.1 精度范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BB%8F%E5%85%B8%E9%99%B7%E9%98%B1"><span class="toc-number">6.5.2.</span> <span class="toc-text">5.2 经典陷阱</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%AF%E5%8A%A0%E8%AF%AF%E5%B7%AE"><span class="toc-number">6.5.2.1.</span> <span class="toc-text">累加误差</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B0%E5%90%83%E5%B0%8F%E6%95%B0"><span class="toc-number">6.5.2.2.</span> <span class="toc-text">大数吃小数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%AF%94%E8%BE%83%E6%96%B9%E6%A1%88"><span class="toc-number">6.5.2.3.</span> <span class="toc-text">安全比较方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javascript-%E4%B8%8E%E5%90%8E%E7%AB%AF-long-%E7%9A%84%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1"><span class="toc-number">6.5.3.</span> <span class="toc-text">JavaScript 与后端 Long 的精度丢失</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.5.3.1.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">6.5.3.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BF%90%E7%AE%97%E8%BF%87%E7%A8%8B%EF%BC%9A%E5%9B%9B%E6%AD%A5%E5%B9%B3%E8%A1%A1%E6%9C%AF"><span class="toc-number">6.6.</span> <span class="toc-text">6 运算过程：四步平衡术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%EF%BC%9A%E7%B2%BE%E5%BA%A6%E4%BF%9D%E5%8D%AB%E6%88%98"><span class="toc-number">6.7.</span> <span class="toc-text">7 编程实战：精度保卫战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E6%9F%A5%E7%9C%8B-c"><span class="toc-number">6.7.1.</span> <span class="toc-text">7.1 内存布局查看（C++）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E8%B7%A8%E8%AF%AD%E8%A8%80%E7%B2%BE%E5%BA%A6%E6%96%B9%E6%A1%88"><span class="toc-number">6.7.2.</span> <span class="toc-text">7.2 跨语言精度方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E9%80%9F%E6%9F%A5%E8%A1%A8%EF%BC%9A%E5%8F%8C%E7%B2%BE%E5%BA%A6%E5%85%B3%E9%94%AE%E8%BE%B9%E7%95%8C"><span class="toc-number">6.8.</span> <span class="toc-text">8 速查表：双精度关键边界</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E4%B8%8E%E6%9C%AA%E6%9D%A5"><span class="toc-number">6.9.</span> <span class="toc-text">9 设计哲学与未来</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%88%E6%9E%81%E5%8F%A3%E8%AF%80"><span class="toc-number">6.10.</span> <span class="toc-text">终极口诀</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ieee-754-%E7%9A%84-float-%E5%85%AC%E5%BC%8F"><span class="toc-number">6.11.</span> <span class="toc-text">ieee 754 的 float 公式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">从码点到字节：彻底吃透 Java 中的字符串、字符与编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-unicode-%E7%A0%81%E7%82%B9-code-point"><span class="toc-number">7.1.</span> <span class="toc-text">1. Unicode 码点（Code Point）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-java-%E4%B8%AD%E7%9A%84-char-%E7%B1%BB%E5%9E%8B-%E4%B8%8E-byte-%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%97%E8%8A%82%E5%B7%AE%E5%88%AB"><span class="toc-number">7.2.</span> <span class="toc-text">2. Java 中的 char 类型 与 byte 类型的字节差别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-unicode-%E5%B9%B3%E9%9D%A2-bmp-%E5%A2%9E%E8%A1%A5%E5%AD%97%E7%AC%A6%E4%B8%8E%E4%BB%A3%E7%90%86%E5%AF%B9"><span class="toc-number">7.3.</span> <span class="toc-text">3. Unicode 平面、BMP、增补字符与代理对</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-java-%E4%B8%AD%E7%9A%84-char-%E7%B1%BB%E5%9E%8B-%E5%86%8D%E6%8E%A2"><span class="toc-number">7.4.</span> <span class="toc-text">4. Java 中的 char 类型 (再探)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-java-%E4%B8%AD%E7%9A%84-string-%E7%B1%BB"><span class="toc-number">7.5.</span> <span class="toc-text">5. Java 中的 String 类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E5%AD%97%E7%AC%A6%E9%9B%86-charset-%E4%B8%8E%E7%BC%96%E7%A0%81-encoding"><span class="toc-number">7.6.</span> <span class="toc-text">6. 字符集（Charset）与编码（Encoding）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-java-%E4%B8%AD%E7%9A%84%E5%AD%97%E7%AC%A6%E9%9B%86%E4%B8%8E%E7%BC%96%E7%A0%81"><span class="toc-number">7.7.</span> <span class="toc-text">7. Java 中的字符集与编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-%E5%AD%97%E5%BD%A2%E7%B0%87-grapheme-cluster"><span class="toc-number">7.8.</span> <span class="toc-text">8. 字形簇（Grapheme Cluster）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%B8%B8%E8%A7%81%E7%96%91%E9%97%AE%E5%BF%AB%E7%AD%94"><span class="toc-number">7.9.</span> <span class="toc-text">9. 常见疑问快答</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E9%80%9F%E8%AE%B0%E5%8F%A3%E8%AF%80"><span class="toc-number">7.10.</span> <span class="toc-text">10. 速记口诀</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">Java 集合与系统设计中的扩缩容机制全解析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">8.1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-arraylist-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">8.2.</span> <span class="toc-text">一、ArrayList 扩容机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">8.2.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B"><span class="toc-number">8.2.2.</span> <span class="toc-text">扩容流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8F%96%E8%88%8D"><span class="toc-number">8.2.3.</span> <span class="toc-text">设计取舍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mermaid-%E5%9B%BE%EF%BC%9Aarraylist-%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B"><span class="toc-number">8.2.4.</span> <span class="toc-text">Mermaid 图：ArrayList 扩容流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-hashmap-%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">8.3.</span> <span class="toc-text">二、HashMap 扩容机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">8.3.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">8.3.2.</span> <span class="toc-text">扩容触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B"><span class="toc-number">8.3.3.</span> <span class="toc-text">扩容流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E8%BD%AC%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">8.3.4.</span> <span class="toc-text">链表转红黑树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8F%96%E8%88%8D"><span class="toc-number">8.3.5.</span> <span class="toc-text">设计取舍</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-stringbuilder-%E6%89%A9%E5%AE%B9"><span class="toc-number">8.4.</span> <span class="toc-text">三、StringBuilder 扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">8.4.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E5%85%AC%E5%BC%8F"><span class="toc-number">8.4.2.</span> <span class="toc-text">扩容公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E-arraylist-%E5%AF%B9%E6%AF%94"><span class="toc-number">8.4.3.</span> <span class="toc-text">与 ArrayList 对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8A%A8%E6%80%81%E6%89%A9%E7%BC%A9%E5%AE%B9"><span class="toc-number">8.5.</span> <span class="toc-text">四、线程池动态扩缩容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E9%80%BB%E8%BE%91"><span class="toc-number">8.5.1.</span> <span class="toc-text">扩容逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">8.5.2.</span> <span class="toc-text">缩容机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E6%89%A9%E7%BC%A9%E5%AE%B9"><span class="toc-number">8.6.</span> <span class="toc-text">五、数据库连接池扩缩容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E7%BC%A9%E5%AE%B9%E7%AD%96%E7%95%A5"><span class="toc-number">8.6.1.</span> <span class="toc-text">扩缩容策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%99%90%E5%88%B6%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0%EF%BC%9F"><span class="toc-number">8.6.2.</span> <span class="toc-text">为什么要限制最大连接数？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-redis-%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5-%E7%BC%A9%E5%AE%B9"><span class="toc-number">8.7.</span> <span class="toc-text">六、Redis 缓存淘汰策略（缩容）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">8.7.1.</span> <span class="toc-text">缩容机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">8.7.2.</span> <span class="toc-text">常见淘汰策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%BC%B9%E6%80%A7%E4%BC%B8%E7%BC%A9%E8%AE%BE%E8%AE%A1"><span class="toc-number">8.8.</span> <span class="toc-text">七、系统级弹性伸缩设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%AF%94-kubernetes-hpa"><span class="toc-number">8.8.1.</span> <span class="toc-text">类比 Kubernetes HPA</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB-lru-%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.9.</span> <span class="toc-text">八、LRU 算法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">8.9.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">8.9.2.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-hashmap-%E7%BB%93%E6%9E%84"><span class="toc-number">8.9.3.</span> <span class="toc-text">双向链表 + HashMap 结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.9.4.</span> <span class="toc-text">操作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D-lfu-%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.10.</span> <span class="toc-text">九、LFU 算法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3"><span class="toc-number">8.10.1.</span> <span class="toc-text">基本思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">8.10.2.</span> <span class="toc-text">实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84"><span class="toc-number">8.10.3.</span> <span class="toc-text">核心结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">8.10.4.</span> <span class="toc-text">操作流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81-%E9%9D%A2%E8%AF%95%E9%AB%98%E9%A2%91%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">8.11.</span> <span class="toc-text">十、面试高频题总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">数据结构的衍生关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">设计一个IM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90-requirements-goals"><span class="toc-number">10.1.</span> <span class="toc-text">1. 需求分析 (Requirements &amp; Goals)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82-functional"><span class="toc-number">10.1.1.</span> <span class="toc-text">功能性需求 (Functional)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E5%8A%9F%E8%83%BD%E6%80%A7%E9%9C%80%E6%B1%82-non-functional"><span class="toc-number">10.1.2.</span> <span class="toc-text">非功能性需求 (Non-Functional)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%B3%BB%E7%BB%9F%E8%A7%84%E6%A8%A1%E4%BC%B0%E7%AE%97-capacity-estimation"><span class="toc-number">10.2.</span> <span class="toc-text">2. 系统规模估算 (Capacity Estimation)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E9%AB%98%E5%B1%82%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1-high-level-design"><span class="toc-number">10.3.</span> <span class="toc-text">3. 高层架构设计 (High-Level Design)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3-detailed-component-design"><span class="toc-number">10.4.</span> <span class="toc-text">4. 核心组件详解 (Detailed Component Design)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E6%8E%A5%E5%85%A5%E5%B1%82-chat-gateway-%E8%81%8A%E5%A4%A9%E7%BD%91%E5%85%B3"><span class="toc-number">10.4.1.</span> <span class="toc-text">a. 接入层: Chat Gateway (聊天网关)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-%E8%A7%A3%E8%80%A6%E6%A0%B8%E5%BF%83-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-message-queues"><span class="toc-number">10.4.2.</span> <span class="toc-text">b. 解耦核心: 消息队列 (Message Queues)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1-database-design"><span class="toc-number">10.4.3.</span> <span class="toc-text">c. 数据库设计 (Database Design)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%8D%E5%8A%A1-backend-services"><span class="toc-number">10.4.4.</span> <span class="toc-text">核心服务 (Backend Services)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%8A%9F%E8%83%BD%E6%89%A9%E5%B1%95%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.4.5.</span> <span class="toc-text">5. 功能扩展实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%80%BB%E7%BB%93%E4%B8%8E%E6%9D%83%E8%A1%A1"><span class="toc-number">10.4.6.</span> <span class="toc-text">6. 总结与权衡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">算法的衍生关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">经典面试问题的大数据解法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%A7%88%E5%AF%B9%E6%AF%94"><span class="toc-number">12.1.</span> <span class="toc-text">概览对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-topk-%E9%97%AE%E9%A2%98"><span class="toc-number">12.2.</span> <span class="toc-text">1. TopK 问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%A7%A3%E6%B3%95-vs-%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%B3%95"><span class="toc-number">12.2.1.</span> <span class="toc-text">传统解法 vs 大数据解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spark%E8%A7%A3%E6%B3%95%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8Ftopk"><span class="toc-number">12.2.2.</span> <span class="toc-text">Spark解法：分布式TopK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flink%E8%A7%A3%E6%B3%95%EF%BC%9A%E5%AE%9E%E6%97%B6topk"><span class="toc-number">12.2.3.</span> <span class="toc-text">Flink解法：实时TopK</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E6%8E%92%E5%BA%8F"><span class="toc-number">12.3.</span> <span class="toc-text">2. 海量数据排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%A7%A3%E6%B3%95-vs-%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%B3%95"><span class="toc-number">12.3.1.</span> <span class="toc-text">传统解法 vs 大数据解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spark%E8%A7%A3%E6%B3%95%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E6%8E%92%E5%BA%8F"><span class="toc-number">12.3.2.</span> <span class="toc-text">Spark解法：分布式排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flink%E8%A7%A3%E6%B3%95%EF%BC%9A%E6%B5%81%E5%BC%8F%E6%8E%92%E5%BA%8F"><span class="toc-number">12.3.3.</span> <span class="toc-text">Flink解法：流式排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E5%8E%BB%E9%87%8D"><span class="toc-number">12.4.</span> <span class="toc-text">3. 海量数据去重</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%A7%A3%E6%B3%95-vs-%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%B3%95"><span class="toc-number">12.4.1.</span> <span class="toc-text">传统解法 vs 大数据解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spark%E8%A7%A3%E6%B3%95%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E5%8E%BB%E9%87%8D"><span class="toc-number">12.4.2.</span> <span class="toc-text">Spark解法：分布式去重</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flink%E8%A7%A3%E6%B3%95%EF%BC%9A%E5%AE%9E%E6%97%B6%E5%8E%BB%E9%87%8D"><span class="toc-number">12.4.3.</span> <span class="toc-text">Flink解法：实时去重</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1-wordcount%E5%8D%87%E7%BA%A7%E7%89%88"><span class="toc-number">12.5.</span> <span class="toc-text">4. 词频统计（WordCount升级版）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#flink%E5%AE%9E%E6%97%B6%E8%AF%8D%E9%A2%91%E7%BB%9F%E8%AE%A1"><span class="toc-number">12.5.1.</span> <span class="toc-text">Flink实时词频统计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98"><span class="toc-number">12.6.</span> <span class="toc-text">5. 滑动窗口问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%A7%A3%E6%B3%95-vs-flink%E8%A7%A3%E6%B3%95"><span class="toc-number">12.6.1.</span> <span class="toc-text">传统解法 vs Flink解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flink%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E8%81%9A%E5%90%88"><span class="toc-number">12.6.2.</span> <span class="toc-text">Flink滑动窗口聚合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9A%84flink%E5%AE%9E%E7%8E%B0%E9%9B%86%E5%90%88"><span class="toc-number">12.7.</span> <span class="toc-text">6. 经典面试题的Flink实现集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88"><span class="toc-number">12.7.1.</span> <span class="toc-text">6.1 两数之和（分布式版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-%E6%B5%81%E5%BC%8F%E7%89%88"><span class="toc-number">12.7.2.</span> <span class="toc-text">6.2 最长递增子序列（流式版）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97-%E6%B5%81%E5%BC%8F%E7%89%88"><span class="toc-number">12.7.3.</span> <span class="toc-text">6.2 最长递增子序列（流式版）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">12.8.</span> <span class="toc-text">性能对比总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="toc-number">12.9.</span> <span class="toc-text">最佳实践建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%8E%9F%E5%88%99"><span class="toc-number">12.9.1.</span> <span class="toc-text">选择原则</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">缓存系统设计：从击穿到雪崩的完整面试攻略</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89"><span class="toc-number">13.1.</span> <span class="toc-text">核心概念重新定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E7%BC%93%E5%AD%98%E9%97%AE%E9%A2%98%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">13.1.1.</span> <span class="toc-text">三大缓存问题的本质</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%9A%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E9%AB%98%E5%8F%AF%E7%94%A8%E7%9A%84%E7%BC%93%E5%AD%98%E7%B3%BB%E7%BB%9F"><span class="toc-number">13.2.</span> <span class="toc-text">经典面试题：设计一个高可用的缓存系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E8%83%8C%E6%99%AF"><span class="toc-number">13.2.1.</span> <span class="toc-text">题目背景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-1-%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90%E5%92%8C%E8%A7%84%E6%A8%A1%E4%BC%B0%E7%AE%97"><span class="toc-number">13.2.2.</span> <span class="toc-text">Step 1: 需求分析和规模估算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82"><span class="toc-number">13.2.2.1.</span> <span class="toc-text">1.1 功能需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E8%A7%84%E6%A8%A1%E4%BC%B0%E7%AE%97"><span class="toc-number">13.2.2.2.</span> <span class="toc-text">1.2 规模估算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-2-%E9%AB%98%E5%B1%82%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">13.2.3.</span> <span class="toc-text">Step 2: 高层系统架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-3-%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">13.2.4.</span> <span class="toc-text">Step 3: 核心问题解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">13.2.4.1.</span> <span class="toc-text">3.1 缓存穿透解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF"><span class="toc-number">13.2.4.1.1.</span> <span class="toc-text">问题场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881%EF%BC%9A%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8"><span class="toc-number">13.2.4.1.2.</span> <span class="toc-text">解决方案1：布隆过滤器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882%EF%BC%9A%E7%BC%93%E5%AD%98%E7%A9%BA%E5%80%BC-%E7%9F%ADttl"><span class="toc-number">13.2.4.1.3.</span> <span class="toc-text">解决方案2：缓存空值 + 短TTL</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">13.2.4.2.</span> <span class="toc-text">3.2 缓存击穿解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF"><span class="toc-number">13.2.4.2.1.</span> <span class="toc-text">问题场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%881%EF%BC%9A%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5"><span class="toc-number">13.2.4.2.2.</span> <span class="toc-text">解决方案1：分布式锁 + 双重检查</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%882%EF%BC%9A%E7%83%AD%E7%82%B9%E6%95%B0%E6%8D%AE%E9%A2%84%E7%83%AD-%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0"><span class="toc-number">13.2.4.2.3.</span> <span class="toc-text">解决方案2：热点数据预热 + 异步更新</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">13.2.4.3.</span> <span class="toc-text">3.3 缓存雪崩解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF"><span class="toc-number">13.2.4.3.1.</span> <span class="toc-text">问题场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E5%A4%9A%E5%B1%82%E9%98%B2%E6%8A%A4%E6%9E%B6%E6%9E%84"><span class="toc-number">13.2.4.3.2.</span> <span class="toc-text">解决方案：多层防护架构</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-4-%E7%9B%91%E6%8E%A7%E5%92%8C%E8%BF%90%E7%BB%B4%E6%96%B9%E6%A1%88"><span class="toc-number">13.2.5.</span> <span class="toc-text">Step 4: 监控和运维方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E5%85%B3%E9%94%AE%E6%8C%87%E6%A0%87%E7%9B%91%E6%8E%A7"><span class="toc-number">13.2.5.1.</span> <span class="toc-text">4.1 关键指标监控</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E5%AE%9E%E6%97%B6%E5%91%8A%E8%AD%A6%E9%85%8D%E7%BD%AE"><span class="toc-number">13.2.5.2.</span> <span class="toc-text">4.2 实时告警配置</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-5-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E5%92%8C%E5%AE%B9%E9%87%8F%E8%A7%84%E5%88%92"><span class="toc-number">13.2.6.</span> <span class="toc-text">Step 5: 压力测试和容量规划</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E8%84%9A%E6%9C%AC"><span class="toc-number">13.2.6.1.</span> <span class="toc-text">5.1 压力测试脚本</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step-6-%E9%9D%A2%E8%AF%95%E8%AF%84%E5%88%86%E6%A0%87%E5%87%86"><span class="toc-number">13.2.7.</span> <span class="toc-text">Step 6: 面试评分标准</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E4%BB%8E%E6%A6%82%E5%BF%B5%E5%88%B0%E5%AE%9E%E8%B7%B5%E7%9A%84%E8%B7%83%E8%BF%81"><span class="toc-number">13.3.</span> <span class="toc-text">总结：从概念到实践的跃迁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">MESI 协议与 Java 锁的实现关系详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E6%A0%B8%E5%BF%83%E7%BB%93%E8%AE%BA"><span class="toc-number">14.1.</span> <span class="toc-text">📌 核心结论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E4%BB%80%E4%B9%88%E6%98%AF-mesi-%E5%8D%8F%E8%AE%AE%EF%BC%9F"><span class="toc-number">14.2.</span> <span class="toc-text">一、什么是 MESI 协议？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mesi-%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">14.2.1.</span> <span class="toc-text">MESI 四种状态：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mesi-%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F"><span class="toc-number">14.2.2.</span> <span class="toc-text">MESI 如何工作？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-java-%E9%94%81%E7%9A%84%E6%A0%B8%E5%BF%83%E8%AF%AD%E4%B9%89"><span class="toc-number">14.3.</span> <span class="toc-text">二、Java 锁的核心语义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-java-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-%E5%8F%AF%E8%A7%81%E6%80%A7-%EF%BC%9F"><span class="toc-number">14.4.</span> <span class="toc-text">三、Java 如何实现“可见性”？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-memory-barrier"><span class="toc-number">14.4.1.</span> <span class="toc-text">关键机制：内存屏障（Memory Barrier）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9A"><span class="toc-number">14.4.2.</span> <span class="toc-text">四种内存屏障：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-mesi-%E4%B8%8E-java-%E9%94%81%E7%9A%84%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">14.5.</span> <span class="toc-text">四、MESI 与 Java 锁的协作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%EF%BC%9A%E7%BA%BF%E7%A8%8Ba-core-0-%E5%86%99%E6%95%B0%E6%8D%AE-%E7%BA%BF%E7%A8%8Bb-core-1-%E8%AF%BB%E6%95%B0%E6%8D%AE"><span class="toc-number">14.5.1.</span> <span class="toc-text">➤ 场景：线程A（Core 0）写数据，线程B（Core 1）读数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9A"><span class="toc-number">14.5.2.</span> <span class="toc-text">执行流程：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#step-1-%E7%BA%BF%E7%A8%8Ba-%E4%BF%AE%E6%94%B9-x"><span class="toc-number">14.5.2.1.</span> <span class="toc-text">Step 1: 线程A 修改 x</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-2-%E7%BA%BF%E7%A8%8Ba-%E9%87%8A%E6%94%BE%E9%94%81"><span class="toc-number">14.5.2.2.</span> <span class="toc-text">Step 2: 线程A 释放锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#step-3-%E7%BA%BF%E7%A8%8Bb-%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">14.5.2.3.</span> <span class="toc-text">Step 3: 线程B 获取锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-reentrantlock-%E4%B8%8E-mesi"><span class="toc-number">14.6.</span> <span class="toc-text">五、ReentrantLock 与 MESI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-volatile-%E4%B8%8E-synchronized-%E5%AF%B9%E6%AF%94"><span class="toc-number">14.7.</span> <span class="toc-text">六、volatile 与 synchronized 对比</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83-%E6%80%BB%E7%BB%93%EF%BC%9Ajava-%E9%94%81%E4%B8%8E-mesi-%E7%9A%84%E5%B1%82%E7%BA%A7%E5%85%B3%E7%B3%BB"><span class="toc-number">14.8.</span> <span class="toc-text">七、总结：Java 锁与 MESI 的层级关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1-%E9%99%84%E5%8A%A0%E6%80%9D%E8%80%83%EF%BC%9A%E5%A6%82%E6%9E%9C%E6%B2%A1%E6%9C%89-mesi%EF%BC%9F"><span class="toc-number">14.9.</span> <span class="toc-text">💡 附加思考：如果没有 MESI？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9C%85-%E6%9C%80%E7%BB%88%E7%BB%93%E8%AE%BA"><span class="toc-number">14.10.</span> <span class="toc-text">✅ 最终结论</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>