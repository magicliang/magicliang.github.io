<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 集合框架完全指南 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 集合框架完全指南 本文系统性地介绍 Java 集合框架的核心概念、实现原理和设计模式。内容涵盖集合框架体系结构、列表与队列机制、哈希表家族的扩缩容策略、缓存淘汰算法实现以及系统级扩缩容设计。通过深入分析源码实现和性能特征，帮助理解各集合类的适用场景和最佳实践。 第一章：全景导图 文章结构 mindmap   root((Java集合框架完全指南))     集合框架体系       It">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 集合框架完全指南">
<meta property="og:url" content="https://magicliang.github.io/2025/07/29/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="Java 集合框架完全指南 本文系统性地介绍 Java 集合框架的核心概念、实现原理和设计模式。内容涵盖集合框架体系结构、列表与队列机制、哈希表家族的扩缩容策略、缓存淘汰算法实现以及系统级扩缩容设计。通过深入分析源码实现和性能特征，帮助理解各集合类的适用场景和最佳实践。 第一章：全景导图 文章结构 mindmap   root((Java集合框架完全指南))     集合框架体系       It">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-178.jpeg">
<meta property="article:published_time" content="2025-07-29T07:05:34.000Z">
<meta property="article:modified_time" content="2026-02-08T03:48:08.017Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="系统设计">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-178.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 集合框架完全指南",
  "url": "https://magicliang.github.io/2025/07/29/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/",
  "image": "https://magicliang.github.io/img/wall-paper-178.jpeg",
  "datePublished": "2025-07-29T07:05:34.000Z",
  "dateModified": "2026-02-08T03:48:08.017Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2025/07/29/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 集合框架完全指南',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-178.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 集合框架完全指南</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java 集合框架完全指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-29T07:05:34.000Z" title="Created 2025-07-29 15:05:34">2025-07-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-08T03:48:08.017Z" title="Updated 2026-02-08 11:48:08">2026-02-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">22.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>106mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>Java 集合框架完全指南</h1>
<p>本文系统性地介绍 Java 集合框架的核心概念、实现原理和设计模式。内容涵盖集合框架体系结构、列表与队列机制、哈希表家族的扩缩容策略、缓存淘汰算法实现以及系统级扩缩容设计。通过深入分析源码实现和性能特征，帮助理解各集合类的适用场景和最佳实践。</p>
<h2 id="第一章：全景导图">第一章：全景导图</h2>
<h3 id="文章结构">文章结构</h3>
<pre><code class="hljs mermaid">mindmap
  root((Java集合框架完全指南))
    集合框架体系
      Iterable接口
      Collection体系
      Map体系
      Sorted接口
      Navigable接口
      抽象类层次
    列表与队列
      ArrayList扩缩容
      队列六操作
      PriorityQueue
      DelayQueue
      Deque体系
    哈希表家族
      HashMap结构
      扩容机制
      扰动函数
      树化反树化
      ConcurrentHashMap
      LinkedHashMap
      EnumSet/Map
      IdentityHashMap
      WeakHashMap
    缓存淘汰策略
      LRU缓存
      LFU缓存
      LinkedHashMap实现
      Guava Cache
      Caffeine Cache
    系统级扩缩容
      分片扩容
      一致性哈希
      动态扩缩容
      负载均衡</code></pre>
<h3 id="模式总览">模式总览</h3>
<table>
<thead>
<tr>
<th>模式名</th>
<th>口诀</th>
<th>覆盖场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>扩容因子1.5倍</td>
<td>扩容1.5倍，平衡空间时间</td>
<td>ArrayList扩容、StringBuilder扩容</td>
</tr>
<tr>
<td>队列六操作</td>
<td>add/offer/put，peek，poll/take</td>
<td>所有队列实现的标准操作</td>
</tr>
<tr>
<td>优先级堆</td>
<td>小顶堆TopK，大顶堆调度</td>
<td>PriorityQueue、任务调度</td>
</tr>
<tr>
<td>延迟队列</td>
<td>getDelay负值出队，compareTo排序</td>
<td>DelayQueue、缓存过期、订单超时</td>
</tr>
<tr>
<td>扰动函数</td>
<td>高16异或低16，分散哈希冲突</td>
<td>HashMap哈希优化</td>
</tr>
<tr>
<td>2的幂容量</td>
<td>位运算取余，快速计算索引</td>
<td>HashMap、ConcurrentHashMap</td>
</tr>
<tr>
<td>树化阈值8</td>
<td>泊松分布概率，红黑树优化</td>
<td>HashMap性能优化</td>
</tr>
<tr>
<td>反树化阈值6</td>
<td>低于阈值退化，避免频繁转换</td>
<td>HashMap内存优化</td>
</tr>
<tr>
<td>LRU缓存</td>
<td>访问移末尾， eldest移除</td>
<td>LinkedHashMap、Guava Cache</td>
</tr>
<tr>
<td>位向量存储</td>
<td>枚举位运算，O(1)操作</td>
<td>EnumSet、RegularEnumSet</td>
</tr>
<tr>
<td>数组存储映射</td>
<td>枚举索引映射，遍历有序</td>
<td>EnumMap</td>
</tr>
<tr>
<td>引用相等</td>
<td>==而非equals，深拷贝序列化</td>
<td>IdentityHashMap</td>
</tr>
<tr>
<td>弱引用键</td>
<td>弱引用GC，自动清理</td>
<td>WeakHashMap、元数据关联</td>
</tr>
<tr>
<td>写时复制</td>
<td>读快写慢，迭代一致</td>
<td>CopyOnWriteArrayList</td>
</tr>
</tbody>
</table>
<h2 id="第二章：集合框架体系">第二章：集合框架体系</h2>
<h3 id="uml-类图">UML 类图</h3>
<pre><code class="hljs mermaid">classDiagram
    class Iterable &#123;
        &lt;&lt;interface&gt;&gt;
        +iterator() Iterator~T~
        +forEach(Consumer~? super T~) void
    &#125;
    
    class Collection &#123;
        &lt;&lt;interface&gt;&gt;
        +size() int
        +isEmpty() boolean
        +contains(Object) boolean
        +iterator() Iterator~T~
        +toArray() Object[]
        +add(E) boolean
        +remove(Object) boolean
        +containsAll(Collection~?) boolean
        +addAll(Collection~? extends E~) boolean
        +removeAll(Collection~?) boolean
        +retainAll(Collection~?) boolean
        +clear() void
        +stream() Stream~T~
    &#125;
    
    class List &#123;
        &lt;&lt;interface&gt;&gt;
        +add(int, E) void
        +addAll(int, Collection~? extends E~) boolean
        +get(int) E
        +set(int, E) E
        +remove(int) E
        +indexOf(Object) int
        +lastIndexOf(Object) int
        +listIterator() ListIterator~E~
        +subList(int, int) List~E~
    &#125;
    
    class Set &#123;
        &lt;&lt;interface&gt;&gt;
    &#125;
    
    class Queue &#123;
        &lt;&lt;interface&gt;&gt;
        +add(E) boolean
        +offer(E) boolean
        +remove() E
        +poll() E
        +element() E
        +peek() E
    &#125;
    
    class Deque &#123;
        &lt;&lt;interface&gt;&gt;
        +addFirst(E) void
        +addLast(E) void
        +offerFirst(E) boolean
        +offerLast(E) boolean
        +removeFirst() E
        +removeLast() E
        +pollFirst() E
        +pollLast() E
        +getFirst() E
        +getLast() E
        +peekFirst() E
        +peekLast() E
        +removeFirstOccurrence(Object) boolean
        +removeLastOccurrence(Object) boolean
    &#125;
    
    class Map &#123;
        &lt;&lt;interface&gt;&gt;
        +size() int
        +isEmpty() boolean
        +containsKey(Object) boolean
        +containsValue(Object) boolean
        +get(Object) V
        +put(K, V) V
        +remove(Object) V
        +putAll(Map~? extends K, ? extends V~) void
        +clear() void
        +keySet() Set~K~
        +values() Collection~V~
        +entrySet() Set~Map.Entry~K,V~~
    &#125;
    
    class SortedSet &#123;
        &lt;&lt;interface&gt;&gt;
        +comparator() Comparator~? super E~
        +subSet(E, E) SortedSet~E~
        +headSet(E) SortedSet~E~
        +tailSet(E) SortedSet~E~
        +first() E
        +last() E
    &#125;
    
    class SortedMap &#123;
        &lt;&lt;interface&gt;&gt;
        +comparator() Comparator~? super K~
        +subMap(K, K) SortedMap~K,V~
        +headMap(K) SortedMap~K,V~
        +tailMap(K) SortedMap~K,V~
        +firstKey() K
        +lastKey() K
    &#125;
    
    class NavigableSet &#123;
        &lt;&lt;interface&gt;&gt;
        +lower(E) E
        +floor(E) E
        +ceiling(E) E
        +higher(E) E
        +pollFirst() E
        +pollLast() E
        +descendingIterator() Iterator~E~
        +descendingSet() NavigableSet~E~
        +subSet(E, boolean, E, boolean) NavigableSet~E~
        +headSet(E, boolean) NavigableSet~E~
        +tailSet(E, boolean) NavigableSet~E~
    &#125;
    
    class NavigableMap &#123;
        &lt;&lt;interface&gt;&gt;
        +lower(K) K
        +floor(K) K
        +ceiling(K) K
        +higher(K) K
        +lowerEntry(K) Map.Entry~K,V~
        +floorEntry(K) Map.Entry~K,V~
        +ceilingEntry(K) Map.Entry~K,V~
        +higherEntry(K) Map.Entry~K,V~
        +firstEntry() Map.Entry~K,V~
        +lastEntry() Map.Entry~K,V~
        +pollFirstEntry() Map.Entry~K,V~
        +pollLastEntry() Map.Entry~K,V~
        +descendingMap() NavigableMap~K,V~
        +navigableKeySet() NavigableSet~K~
        +subMap(K, boolean, K, boolean) NavigableMap~K,V~
        +headMap(K, boolean) NavigableMap~K,V~
        +tailMap(K, boolean) NavigableMap~K,V~
    &#125;
    
    class AbstractCollection &#123;
        &lt;&lt;abstract&gt;&gt;
        +iterator() Iterator~T~
        +size() int
    &#125;
    
    class AbstractList &#123;
        &lt;&lt;abstract&gt;&gt;
    &#125;
    
    class AbstractSequentialList &#123;
        &lt;&lt;abstract&gt;&gt;
    &#125;
    
    class AbstractSet &#123;
        &lt;&lt;abstract&gt;&gt;
    &#125;
    
    class AbstractMap &#123;
        &lt;&lt;abstract&gt;&gt;
    &#125;
    
    class AbstractQueue &#123;
        &lt;&lt;abstract&gt;&gt;
    &#125;
    
    class ArrayList &#123;
        -elementData Object[]
        -size int
        +ArrayList()
        +ArrayList(int)
        +ensureCapacity(int)
        +trimToSize()
    &#125;
    
    class LinkedList &#123;
        -first Node~E~
        -last Node~E~
        +LinkedList()
        +addFirst(E)
        +addLast(E)
    &#125;
    
    class HashSet &#123;
        -map HashMap~E,Object~
        +HashSet()
        +HashSet(int)
        +HashSet(int, float)
    &#125;
    
    class LinkedHashSet &#123;
        +LinkedHashSet()
        +LinkedHashSet(int)
        +LinkedHashSet(int, float)
    &#125;
    
    class TreeSet &#123;
        -m NavigableMap~E,Object~
        +TreeSet()
        +TreeSet(Comparator~? super E~)
    &#125;
    
    class PriorityQueue &#123;
        -queue Object[]
        +PriorityQueue()
        +PriorityQueue(int)
        +PriorityQueue(Comparator~? super E~)
    &#125;
    
    class DelayQueue &#123;
        -q PriorityQueue~E extends Delayed~
        +DelayQueue()
        +put(E)
        +take() E
    &#125;
    
    class ArrayDeque &#123;
        -elements Object[]
        -head int
        -tail int
        +ArrayDeque()
        +addFirst(E)
        +addLast(E)
    &#125;
    
    class HashMap &#123;
        -table Node~K,V~[]
        -size int
        -loadFactor float
        -threshold int
        +HashMap()
        +HashMap(int)
        +HashMap(int, float)
        +put(K, V) V
        +get(Object) V
    &#125;
    
    class LinkedHashMap &#123;
        -accessOrder boolean
        +LinkedHashMap()
        +LinkedHashMap(int, float, boolean)
        +removeEldestEntry(Map.Entry)
    &#125;
    
    class WeakHashMap &#123;
        -table Entry~K,V~[]
        +WeakHashMap()
        +WeakHashMap(int)
    &#125;
    
    class ConcurrentHashMap &#123;
        -table Node~K,V~[]
        -sizeCtl long
        +ConcurrentHashMap()
        +put(K, V) V
        +get(Object) V
    &#125;
    
    class EnumSet &#123;
        +noneOf(Class~E~)
        +of(E...)
        +allOf(Class~E~)
        +range(E, E)
        +complementOf(EnumSet~E~)
    &#125;
    
    class EnumMap &#123;
        -keyUniverse K[]
        -vals Object[]
        +EnumMap(Class~K~)
        +put(K, V) V
        +get(Object) V
    &#125;
    
    class IdentityHashMap &#123;
        -table Object[]
        +IdentityHashMap()
        +put(K, V) V
    &#125;
    
    class TreeMap &#123;
        -root Entry~K,V~
        -comparator Comparator~? super K~
        +TreeMap()
        +TreeMap(Comparator~? super K~)
    &#125;
    
    Iterable &lt;|.. Collection
    Iterable &lt;|.. Map
    Collection &lt;|-- List
    Collection &lt;|-- Set
    Collection &lt;|-- Queue
    Collection &lt;|-- AbstractCollection
    List &lt;|-- SortedSet
    SortedSet &lt;|-- NavigableSet
    Set &lt;|-- SortedSet
    Queue &lt;|-- Deque
    Map &lt;|-- SortedMap
    SortedMap &lt;|-- NavigableMap
    AbstractCollection &lt;|-- AbstractList
    AbstractCollection &lt;|-- AbstractSet
    AbstractCollection &lt;|-- AbstractQueue
    AbstractList &lt;|-- ArrayList
    AbstractList &lt;|-- AbstractSequentialList
    AbstractSequentialList &lt;|-- LinkedList
    AbstractSet &lt;|-- HashSet
    HashSet &lt;|-- LinkedHashSet
    AbstractSet &lt;|-- TreeSet
    AbstractQueue &lt;|-- PriorityQueue
    AbstractQueue &lt;|-- ArrayDeque
    Deque &lt;|-- LinkedList
    Deque &lt;|-- ArrayDeque
    Queue &lt;|-- PriorityQueue
    PriorityQueue &lt;|-- DelayQueue
    AbstractMap &lt;|-- HashMap
    AbstractMap &lt;|-- TreeMap
    AbstractMap &lt;|-- WeakHashMap
    AbstractMap &lt;|-- IdentityHashMap
    HashMap &lt;|-- LinkedHashMap
    HashMap &lt;|-- ConcurrentHashMap</code></pre>
<h3 id="核心接口说明">核心接口说明</h3>
<h4 id="sorted-接口">Sorted 接口</h4>
<p>SortedSet 和 SortedMap 提供了基于<strong>全序关系</strong>（total ordering）的有序集合操作。</p>
<p><strong>接口特性</strong></p>
<ul>
<li><strong>引入版本</strong>：JDK 1.2</li>
<li><strong>核心概念</strong>：维护元素的全序关系</li>
<li><strong>三类操作</strong>：范围子集、首尾元素、比较器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SortedSet 示例</span><br>SortedSet&lt;Integer&gt; sortedSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>sortedSet.addAll(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>));<br><br><span class="hljs-comment">// 获取比较器</span><br>Comparator&lt;? <span class="hljs-built_in">super</span> Integer&gt; comparator = sortedSet.comparator();<br>System.out.println(<span class="hljs-string">&quot;Comparator: &quot;</span> + comparator);<br><br><span class="hljs-comment">// 范围子集 [3, 7)</span><br>SortedSet&lt;Integer&gt; subSet = sortedSet.subSet(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>);<br>System.out.println(<span class="hljs-string">&quot;SubSet [3, 7): &quot;</span> + subSet); <span class="hljs-comment">// [3, 5]</span><br><br><span class="hljs-comment">// 前缀子集 [0, 5)</span><br>SortedSet&lt;Integer&gt; headSet = sortedSet.headSet(<span class="hljs-number">5</span>);<br>System.out.println(<span class="hljs-string">&quot;HeadSet [0, 5): &quot;</span> + headSet); <span class="hljs-comment">// [1, 3]</span><br><br><span class="hljs-comment">// 后缀子集 [7, ∞)</span><br>SortedSet&lt;Integer&gt; tailSet = sortedSet.tailSet(<span class="hljs-number">7</span>);<br>System.out.println(<span class="hljs-string">&quot;TailSet [7, ∞): &quot;</span> + tailSet); <span class="hljs-comment">// [7, 9]</span><br><br><span class="hljs-comment">// 首尾元素</span><br>System.out.println(<span class="hljs-string">&quot;First: &quot;</span> + sortedSet.first()); <span class="hljs-comment">// 1</span><br>System.out.println(<span class="hljs-string">&quot;Last: &quot;</span> + sortedSet.last()); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SortedMap 示例</span><br>SortedMap&lt;Integer, String&gt; sortedMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>sortedMap.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>sortedMap.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>sortedMap.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;E&quot;</span>);<br>sortedMap.put(<span class="hljs-number">7</span>, <span class="hljs-string">&quot;G&quot;</span>);<br>sortedMap.put(<span class="hljs-number">9</span>, <span class="hljs-string">&quot;I&quot;</span>);<br><br><span class="hljs-comment">// 范围子集 [3, 7)</span><br>SortedMap&lt;Integer, String&gt; subMap = sortedMap.subMap(<span class="hljs-number">3</span>, <span class="hljs-number">7</span>);<br>System.out.println(<span class="hljs-string">&quot;SubMap [3, 7): &quot;</span> + subMap); <span class="hljs-comment">// &#123;3=C, 5=E&#125;</span><br><br><span class="hljs-comment">// 前缀子集 [0, 5)</span><br>SortedMap&lt;Integer, String&gt; headMap = sortedMap.headMap(<span class="hljs-number">5</span>);<br>System.out.println(<span class="hljs-string">&quot;HeadMap [0, 5): &quot;</span> + headMap); <span class="hljs-comment">// &#123;1=A, 3=C&#125;</span><br><br><span class="hljs-comment">// 后缀子集 [7, ∞)</span><br>SortedMap&lt;Integer, String&gt; tailMap = sortedMap.tailMap(<span class="hljs-number">7</span>);<br>System.out.println(<span class="hljs-string">&quot;TailMap [7, ∞): &quot;</span> + tailMap); <span class="hljs-comment">// &#123;7=G, 9=I&#125;</span><br><br><span class="hljs-comment">// 首尾键值</span><br>System.out.println(<span class="hljs-string">&quot;FirstKey: &quot;</span> + sortedMap.firstKey()); <span class="hljs-comment">// 1</span><br>System.out.println(<span class="hljs-string">&quot;LastKey: &quot;</span> + sortedMap.lastKey()); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure>
<h4 id="navigable-接口">Navigable 接口</h4>
<p>NavigableSet 和 NavigableMap 扩展了 Sorted 接口，提供了<strong>导航方法</strong>（navigation methods）用于查找邻近元素。</p>
<p><strong>接口特性</strong></p>
<ul>
<li><strong>引入版本</strong>：JDK 1.6</li>
<li><strong>核心方法</strong>：lower、floor、ceiling、higher</li>
<li><strong>扩展功能</strong>：降序视图、精确范围视图</li>
</ul>
<h5 id="导航方法">导航方法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">NavigableSet&lt;Integer&gt; navigableSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>navigableSet.addAll(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>));<br><br><span class="hljs-comment">// lower(E e): 返回严格小于 e 的最大元素</span><br>System.out.println(<span class="hljs-string">&quot;lower(5): &quot;</span> + navigableSet.lower(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// floor(E e): 返回小于等于 e 的最大元素</span><br>System.out.println(<span class="hljs-string">&quot;floor(5): &quot;</span> + navigableSet.floor(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 5</span><br><br><span class="hljs-comment">// ceiling(E e): 返回大于等于 e 的最小元素</span><br>System.out.println(<span class="hljs-string">&quot;ceiling(5): &quot;</span> + navigableSet.ceiling(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 5</span><br><br><span class="hljs-comment">// higher(E e): 返回严格大于 e 的最小元素</span><br>System.out.println(<span class="hljs-string">&quot;higher(5): &quot;</span> + navigableSet.higher(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 7</span><br><br><span class="hljs-comment">// 非存在元素测试</span><br>System.out.println(<span class="hljs-string">&quot;lower(4): &quot;</span> + navigableSet.lower(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 3</span><br>System.out.println(<span class="hljs-string">&quot;floor(4): &quot;</span> + navigableSet.floor(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 3</span><br>System.out.println(<span class="hljs-string">&quot;ceiling(4): &quot;</span> + navigableSet.ceiling(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 5</span><br>System.out.println(<span class="hljs-string">&quot;higher(4): &quot;</span> + navigableSet.higher(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">NavigableMap&lt;Integer, String&gt; navigableMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>navigableMap.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>navigableMap.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>navigableMap.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;E&quot;</span>);<br>navigableMap.put(<span class="hljs-number">7</span>, <span class="hljs-string">&quot;G&quot;</span>);<br>navigableMap.put(<span class="hljs-number">9</span>, <span class="hljs-string">&quot;I&quot;</span>);<br><br><span class="hljs-comment">// 导航方法</span><br>System.out.println(<span class="hljs-string">&quot;lowerEntry(5): &quot;</span> + navigableMap.lowerEntry(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 3=C</span><br>System.out.println(<span class="hljs-string">&quot;floorEntry(5): &quot;</span> + navigableMap.floorEntry(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 5=E</span><br>System.out.println(<span class="hljs-string">&quot;ceilingEntry(5): &quot;</span> + navigableMap.ceilingEntry(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 5=E</span><br>System.out.println(<span class="hljs-string">&quot;higherEntry(5): &quot;</span> + navigableMap.higherEntry(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 7=E</span><br><br><span class="hljs-comment">// pollFirstEntry 和 pollLastEntry</span><br>Map.Entry&lt;Integer, String&gt; first = navigableMap.pollFirstEntry();<br>System.out.println(<span class="hljs-string">&quot;Polled first: &quot;</span> + first); <span class="hljs-comment">// 1=A</span><br>System.out.println(<span class="hljs-string">&quot;Remaining: &quot;</span> + navigableMap); <span class="hljs-comment">// &#123;3=C, 5=E, 7=G, 9=I&#125;</span><br></code></pre></td></tr></table></figure>
<h5 id="范围视图">范围视图</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">NavigableSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>));<br><br><span class="hljs-comment">// 精确范围视图：[3, 7]（包含边界）</span><br>NavigableSet&lt;Integer&gt; inclusiveRange = set.subSet(<span class="hljs-number">3</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">7</span>, <span class="hljs-literal">true</span>);<br>System.out.println(<span class="hljs-string">&quot;Inclusive [3, 7]: &quot;</span> + inclusiveRange); <span class="hljs-comment">// [3, 4, 5, 6, 7]</span><br><br><span class="hljs-comment">// 半开范围视图：[3, 7)（左闭右开）</span><br>NavigableSet&lt;Integer&gt; halfOpenRange = set.subSet(<span class="hljs-number">3</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">7</span>, <span class="hljs-literal">false</span>);<br>System.out.println(<span class="hljs-string">&quot;HalfOpen [3, 7): &quot;</span> + halfOpenRange); <span class="hljs-comment">// [3, 4, 5, 6]</span><br><br><span class="hljs-comment">// 开区间视图：(3, 7)（不包含边界）</span><br>NavigableSet&lt;Integer&gt; openRange = set.subSet(<span class="hljs-number">3</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">7</span>, <span class="hljs-literal">false</span>);<br>System.out.println(<span class="hljs-string">&quot;Open (3, 7): &quot;</span> + openRange); <span class="hljs-comment">// [4, 5, 6]</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">NavigableMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span>; i++) &#123;<br>    map.put(i, String.valueOf((<span class="hljs-type">char</span>) (<span class="hljs-number">64</span> + i)));<br>&#125;<br><br><span class="hljs-comment">// 精确范围视图：[3, 7]</span><br>NavigableMap&lt;Integer, String&gt; inclusiveRange = map.subMap(<span class="hljs-number">3</span>, <span class="hljs-literal">true</span>, <span class="hljs-number">7</span>, <span class="hljs-literal">true</span>);<br>System.out.println(<span class="hljs-string">&quot;Inclusive [3, 7]: &quot;</span> + inclusiveRange); <span class="hljs-comment">// &#123;3=C, 4=D, 5=E, 6=F, 7=G&#125;</span><br></code></pre></td></tr></table></figure>
<h5 id="降序视图">降序视图</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">NavigableSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>));<br><br><span class="hljs-comment">// 降序视图</span><br>NavigableSet&lt;Integer&gt; descendingSet = set.descendingSet();<br>System.out.println(<span class="hljs-string">&quot;Descending: &quot;</span> + descendingSet); <span class="hljs-comment">// [9, 7, 5, 3, 1]</span><br><br><span class="hljs-comment">// 降序迭代器</span><br>Iterator&lt;Integer&gt; descendingIterator = set.descendingIterator();<br>System.out.print(<span class="hljs-string">&quot;Descending iteration: &quot;</span>);<br><span class="hljs-keyword">while</span> (descendingIterator.hasNext()) &#123;<br>    System.out.print(descendingIterator.next() + <span class="hljs-string">&quot; &quot;</span>);<br>&#125;<br><span class="hljs-comment">// 输出: 9 7 5 3 1</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">NavigableMap&lt;Integer, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>map.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;A&quot;</span>);<br>map.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;C&quot;</span>);<br>map.put(<span class="hljs-number">5</span>, <span class="hljs-string">&quot;E&quot;</span>);<br><br><span class="hljs-comment">// 降序视图</span><br>NavigableMap&lt;Integer, String&gt; descendingMap = map.descendingMap();<br>System.out.println(<span class="hljs-string">&quot;Descending: &quot;</span> + descendingMap); <span class="hljs-comment">// &#123;5=E, 3=C, 1=A&#125;</span><br></code></pre></td></tr></table></figure>
<h4 id="abstractlist-与-abstractsequentiallist">AbstractList 与 AbstractSequentialList</h4>
<p><strong>AbstractList</strong></p>
<ul>
<li><strong>定位</strong>：随机访问列表的抽象基类</li>
<li><strong>核心方法</strong>：get(int index)、size()</li>
<li><strong>实现类</strong>：ArrayList、Vector、AbstractList 的子类</li>
</ul>
<p><strong>AbstractSequentialList</strong></p>
<ul>
<li><strong>定位</strong>：顺序访问列表的抽象基类</li>
<li><strong>核心方法</strong>：listIterator(int index)</li>
<li><strong>实现类</strong>：LinkedList</li>
</ul>
<p><strong>区别总结</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>AbstractList</th>
<th>AbstractSequentialList</th>
</tr>
</thead>
<tbody>
<tr>
<td>访问方式</td>
<td>随机访问</td>
<td>顺序访问</td>
</tr>
<tr>
<td>核心方法</td>
<td>get(int index)</td>
<td>listIterator(int index)</td>
</tr>
<tr>
<td>性能特征</td>
<td>O(1) 索引访问</td>
<td>O(n) 索引访问</td>
</tr>
<tr>
<td>典型实现</td>
<td>ArrayList</td>
<td>LinkedList</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractList 子类实现示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> Object[] elementData;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyArrayList</span><span class="hljs-params">(<span class="hljs-type">int</span> initialCapacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.elementData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>        <span class="hljs-built_in">this</span>.size = <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= size) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>();<br>        &#125;<br>        <span class="hljs-keyword">return</span> (E) elementData[index];<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>        ensureCapacity(size + <span class="hljs-number">1</span>);<br>        elementData[size++] = e;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (minCapacity &gt; elementData.length) &#123;<br>            Object[] newData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[elementData.length * <span class="hljs-number">2</span>];<br>            System.arraycopy(elementData, <span class="hljs-number">0</span>, newData, <span class="hljs-number">0</span>, size);<br>            elementData = newData;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractSequentialList 子类实现示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyLinkedList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSequentialList</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        E item;<br>        Node&lt;E&gt; next;<br>        Node&lt;E&gt; prev;<br>        <br>        Node(Node&lt;E&gt; prev, E item, Node&lt;E&gt; next) &#123;<br>            <span class="hljs-built_in">this</span>.prev = prev;<br>            <span class="hljs-built_in">this</span>.item = item;<br>            <span class="hljs-built_in">this</span>.next = next;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; first;<br>    <span class="hljs-keyword">private</span> Node&lt;E&gt; last;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ListIterator&lt;E&gt; <span class="hljs-title function_">listIterator</span><span class="hljs-params">(<span class="hljs-type">int</span> index)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListItr</span>(index);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ListItr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ListIterator</span>&lt;E&gt; &#123;<br>        <span class="hljs-keyword">private</span> Node&lt;E&gt; lastReturned;<br>        <span class="hljs-keyword">private</span> Node&lt;E&gt; next;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> nextIndex;<br>        <br>        ListItr(<span class="hljs-type">int</span> index) &#123;<br>            <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (index &lt; (size &gt;&gt; <span class="hljs-number">1</span>)) &#123;<br>                next = first;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; index; i++) &#123;<br>                    next = next.next;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                next = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> size - <span class="hljs-number">1</span>; i &gt;= index; i--) &#123;<br>                    next = (next == <span class="hljs-literal">null</span>) ? last : next.prev;<br>                &#125;<br>            &#125;<br>            nextIndex = index;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> nextIndex &lt; size;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (!hasNext()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            &#125;<br>            lastReturned = next;<br>            next = next.next;<br>            nextIndex++;<br>            <span class="hljs-keyword">return</span> lastReturned.item;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasPrevious</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> nextIndex &gt; <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> E <span class="hljs-title function_">previous</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (!hasPrevious()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>            &#125;<br>            lastReturned = (next == <span class="hljs-literal">null</span>) ? last : next.prev;<br>            next = lastReturned;<br>            nextIndex--;<br>            <span class="hljs-keyword">return</span> lastReturned.item;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextIndex</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> nextIndex;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">previousIndex</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> nextIndex - <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(E e)</span> &#123;<br>            <span class="hljs-keyword">if</span> (lastReturned == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>            &#125;<br>            lastReturned.item = e;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>            lastReturned = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;<br>                linkLast(e);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                linkBefore(e, next);<br>            &#125;<br>            nextIndex++;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (lastReturned == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();<br>            &#125;<br>            Node&lt;E&gt; lastNext = lastReturned.next;<br>            unlink(lastReturned);<br>            <span class="hljs-keyword">if</span> (next == lastReturned) &#123;<br>                next = lastNext;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                nextIndex--;<br>            &#125;<br>            lastReturned = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkLast</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; l = last;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(l, e, <span class="hljs-literal">null</span>);<br>        last = newNode;<br>        <span class="hljs-keyword">if</span> (l == <span class="hljs-literal">null</span>) &#123;<br>            first = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l.next = newNode;<br>        &#125;<br>        size++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkBefore</span><span class="hljs-params">(E e, Node&lt;E&gt; succ)</span> &#123;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; pred = succ.prev;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(pred, e, succ);<br>        succ.prev = newNode;<br>        <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>) &#123;<br>            first = newNode;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pred.next = newNode;<br>        &#125;<br>        size++;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlink</span><span class="hljs-params">(Node&lt;E&gt; x)</span> &#123;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; next = x.next;<br>        <span class="hljs-keyword">final</span> Node&lt;E&gt; prev = x.prev;<br>        <br>        <span class="hljs-keyword">if</span> (prev == <span class="hljs-literal">null</span>) &#123;<br>            first = next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            prev.next = next;<br>            x.prev = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>) &#123;<br>            last = prev;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            next.prev = prev;<br>            x.next = <span class="hljs-literal">null</span>;<br>        &#125;<br>        <br>        x.item = <span class="hljs-literal">null</span>;<br>        size--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>🔑 <strong>模式提炼：抽象基类选择</strong></p>
<p>当实现自定义集合时，根据访问模式选择合适的抽象基类：随机访问选择 AbstractList，顺序访问选择 AbstractSequentialList。这确保了实现类能够提供最优的性能特征。</p>
<h3 id="fail-fast-与-fail-safe-机制">fail-fast 与 fail-safe 机制</h3>
<p>Java 集合框架提供了两种迭代器行为机制：fail-fast（快速失败）和 fail-safe（安全失败）。</p>
<p><strong>fail-fast 原理</strong></p>
<p>fail-fast 是 Java 集合的默认行为，通过 <code>modCount</code> 字段实现。每次集合结构发生修改（增加、删除元素）时，<code>modCount</code> 会递增。迭代器在创建时记录当前的 <code>modCount</code> 值为 <code>expectedModCount</code>，每次调用 <code>next()</code> 时都会检查两者是否一致。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ArrayList 的迭代器实现（简化）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-type">int</span> cursor;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">lastRet</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">expectedModCount</span> <span class="hljs-operator">=</span> modCount; <span class="hljs-comment">// 创建时记录 modCount</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cursor != size;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        checkForComodification(); <span class="hljs-comment">// 每次调用 next() 都检查</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> cursor;<br>        <span class="hljs-keyword">if</span> (i &gt;= size)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        Object[] elementData = ArrayList.<span class="hljs-built_in">this</span>.elementData;<br>        <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>        cursor = i + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkForComodification</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (modCount != expectedModCount)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentModificationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>触发条件</strong></p>
<p>fail-fast 异常在以下情况触发：</p>
<ol>
<li>在迭代过程中，通过集合本身（而非迭代器的方法）修改集合结构</li>
<li>多线程环境下，一个线程在迭代时，另一个线程修改了集合</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：在迭代时通过集合本身删除元素</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>list.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span> (String item : list) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;B&quot;</span>.equals(item)) &#123;<br>        list.remove(<span class="hljs-string">&quot;B&quot;</span>); <span class="hljs-comment">// 抛出 ConcurrentModificationException</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>正确的迭代器删除方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正确示例：使用迭代器的 remove() 方法</span><br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>list.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br>Iterator&lt;String&gt; iterator = list.iterator();<br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> iterator.next();<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;B&quot;</span>.equals(item)) &#123;<br>        iterator.remove(); <span class="hljs-comment">// 正确：通过迭代器删除</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 或者使用 removeIf（Java 8+）</span><br>list.removeIf(<span class="hljs-string">&quot;B&quot;</span>::equals);<br></code></pre></td></tr></table></figure>
<p><strong>fail-safe 机制</strong></p>
<p>fail-safe 机制不会抛出 ConcurrentModificationException，因为它操作的是集合的快照副本。</p>
<p><strong>代表实现</strong></p>
<ul>
<li><code>CopyOnWriteArrayList</code>：迭代时复制整个数组</li>
<li><code>ConcurrentHashMap</code>：迭代器基于创建时的快照</li>
<li><code>CopyOnWriteArraySet</code>：基于 CopyOnWriteArrayList</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CopyOnWriteArrayList 示例</span><br>CopyOnWriteArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>list.add(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span> (String item : list) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;B&quot;</span>.equals(item)) &#123;<br>        list.remove(<span class="hljs-string">&quot;B&quot;</span>); <span class="hljs-comment">// 不会抛出异常</span><br>    &#125;<br>&#125;<br>System.out.println(list); <span class="hljs-comment">// 输出：[A, C]</span><br></code></pre></td></tr></table></figure>
<p><strong>fail-safe 原理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CopyOnWriteArrayList 的迭代器（简化）</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">COWIterator</span>&lt;E&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ListIterator</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] snapshot; <span class="hljs-comment">// 快照数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> cursor;<br><br>    COWIterator(Object[] elements, <span class="hljs-type">int</span> initialCursor) &#123;<br>        cursor = initialCursor;<br>        snapshot = elements; <span class="hljs-comment">// 保存创建时的数组快照</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cursor &lt; snapshot.length;<br>    &#125;<br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (!hasNext())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>        <span class="hljs-keyword">return</span> (E) snapshot[cursor++]; <span class="hljs-comment">// 遍历快照，不检查 modCount</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>机制对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>fail-fast</th>
<th>fail-safe</th>
</tr>
</thead>
<tbody>
<tr>
<td>异常行为</td>
<td>抛出 ConcurrentModificationException</td>
<td>不抛出异常</td>
</tr>
<tr>
<td>数据一致性</td>
<td>反映迭代时的实时状态</td>
<td>反映迭代器创建时的快照</td>
</tr>
<tr>
<td>内存开销</td>
<td>低</td>
<td>高（需要复制数据）</td>
</tr>
<tr>
<td>性能</td>
<td>高</td>
<td>低（复制操作）</td>
</tr>
<tr>
<td>典型实现</td>
<td>ArrayList、HashMap、LinkedList</td>
<td>CopyOnWriteArrayList、ConcurrentHashMap</td>
</tr>
<tr>
<td>适用场景</td>
<td>单线程或需要检测并发修改</td>
<td>多线程且允许弱一致性</td>
</tr>
</tbody>
</table>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>fail-fast 不保证一定抛出异常</strong>：这是 Java 文档明确说明的，仅作为一种 best-effort 的 bug 检测机制</li>
<li><strong>fail-safe 存在数据不一致</strong>：迭代期间集合的修改不会反映到迭代器中</li>
<li><strong>性能权衡</strong>：fail-safe 机制通过牺牲内存和性能换取安全性</li>
</ol>
<p>🔑 <strong>模式提炼：</strong> fail-fast 是一种防御性编程机制，用于快速发现并发修改错误。fail-safe 则适用于多线程场景，通过快照机制避免并发修改异常，但需要权衡内存和性能开销。</p>
<h2 id="第三章：列表与队列">第三章：列表与队列</h2>
<h3 id="3-1-arraylist-扩缩容机制">3.1 ArrayList 扩缩容机制</h3>
<h4 id="内部结构">内部结构</h4>
<p>ArrayList 内部维护两个核心字段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span>&lt;E&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractList</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 存储元素的数组</span><br>    <span class="hljs-keyword">transient</span> Object[] elementData;<br>    <br>    <span class="hljs-comment">// 实际元素数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br>    <br>    <span class="hljs-comment">// 默认初始容量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键特性</strong></p>
<ul>
<li><code>elementData</code>：动态数组，可能大于实际元素数量</li>
<li><code>size</code>：实际元素数量，始终 ≤ elementData.length</li>
<li>空构造器创建时，elementData 为空数组，首次添加时扩容到 10</li>
</ul>
<h4 id="扩容因子-1-5-倍">扩容因子 1.5 倍</h4>
<p>ArrayList 的扩容因子为 1.5 倍，即新容量 = 旧容量 + (旧容量 &gt;&gt; 1)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">grow</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> elementData.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>); <span class="hljs-comment">// 1.5 倍扩容</span><br>    <br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>        newCapacity = minCapacity;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>) &#123;<br>        newCapacity = hugeCapacity(minCapacity);<br>    &#125;<br>    <br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么选择 1.5 倍？</strong></p>
<ol>
<li><strong>vs 2 倍扩容</strong></li>
</ol>
<table>
<thead>
<tr>
<th>扩容因子</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td>2 倍</td>
<td>位运算简单</td>
<td>内存浪费严重，扩容后可能长期空闲</td>
</tr>
<tr>
<td>1.5 倍</td>
<td>内存利用率高</td>
<td>计算略复杂（加右移）</td>
</tr>
</tbody>
</table>
<ol start="2">
<li><strong>vs 黄金比例 (1.618)</strong></li>
</ol>
<ul>
<li>黄金比例在理论上是最优的，但 1.5 倍实现更简单</li>
<li>1.5 倍已经足够接近最优解，避免了复杂的浮点运算</li>
</ul>
<ol start="3">
<li><strong>均摊分析</strong></li>
</ol>
<p>假设初始容量为 1，插入 n 个元素：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs excel">扩容次数：<span class="hljs-built_in">log</span>₂(<span class="hljs-built_in">n</span>)<br>总拷贝次数：<span class="hljs-number">1</span> + <span class="hljs-number">2</span> + <span class="hljs-number">4</span> + ... + <span class="hljs-built_in">n</span>/<span class="hljs-number">2</span> = <span class="hljs-built_in">n</span> - <span class="hljs-number">1</span><br>均摊拷贝次数：(<span class="hljs-built_in">n</span> - <span class="hljs-number">1</span>) / <span class="hljs-built_in">n</span> ≈ <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>
<p>因此，均摊时间复杂度为 O(1)。</p>
<h4 id="集合初始容量选择指南">集合初始容量选择指南</h4>
<p>合理设置集合的初始容量可以避免不必要的扩容操作，提高性能。根据对元素数量的了解程度，选择不同的容量设置策略。</p>
<p><strong>容量选择决策表</strong></p>
<table>
<thead>
<tr>
<th>元素数量了解程度</th>
<th>推荐策略</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr>
<td>确切已知</td>
<td>设置为元素数量</td>
<td>避免任何扩容，性能最优</td>
</tr>
<tr>
<td>可估算范围</td>
<td>设置为估算值</td>
<td>减少扩容次数，预留少量空间</td>
</tr>
<tr>
<td>完全未知</td>
<td>使用默认值</td>
<td>避免过度预分配浪费内存</td>
</tr>
</tbody>
</table>
<p>** ArrayList 容量选择**</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：使用默认容量，导致多次扩容</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// 默认容量 10</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    list.add(i);<br>&#125;<br><span class="hljs-comment">// 扩容次数：log₂(1000) ≈ 10 次</span><br><br><span class="hljs-comment">// 正确示例：设置初始容量为 1000，避免扩容</span><br>List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    list.add(i);<br>&#125;<br><span class="hljs-comment">// 扩容次数：0 次</span><br></code></pre></td></tr></table></figure>
<p><strong>HashMap 容量选择</strong></p>
<p>HashMap 的初始容量需要考虑负载因子（默认 0.75）。为了避免扩容，初始容量应设置为 <code>元素数量 / 0.75 + 1</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：直接设置为元素数量，仍会扩容</span><br>Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">1000</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    map.put(<span class="hljs-string">&quot;key&quot;</span> + i, i);<br>&#125;<br><span class="hljs-comment">// 实际触发扩容阈值：1000 * 0.75 = 750</span><br><span class="hljs-comment">// 扩容次数：1 次</span><br><br><span class="hljs-comment">// 正确示例：考虑负载因子，避免扩容</span><br><span class="hljs-type">int</span> <span class="hljs-variable">expectedSize</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">initialCapacity</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (expectedSize / <span class="hljs-number">0.75</span>) + <span class="hljs-number">1</span>;<br>Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(initialCapacity);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    map.put(<span class="hljs-string">&quot;key&quot;</span> + i, i);<br>&#125;<br><span class="hljs-comment">// 扩容次数：0 次</span><br></code></pre></td></tr></table></figure>
<p><strong>StringBuilder 容量选择</strong></p>
<p>StringBuilder 的初始容量需要考虑额外空间。已知字符串长度为 n 时，初始容量应设置为 <code>n + 16</code>（16 是 StringBuilder 的默认额外空间）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：使用默认容量，导致多次扩容</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(); <span class="hljs-comment">// 默认容量 16</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    sb.append(<span class="hljs-string">&quot;Item &quot;</span>).append(i).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 扩容次数：约 10 次</span><br><br><span class="hljs-comment">// 正确示例：预估最终长度，设置初始容量</span><br><span class="hljs-type">int</span> <span class="hljs-variable">estimatedLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">10</span>; <span class="hljs-comment">// 每行约 10 字符</span><br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(estimatedLength + <span class="hljs-number">16</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    sb.append(<span class="hljs-string">&quot;Item &quot;</span>).append(i).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 扩容次数：0 次</span><br></code></pre></td></tr></table></figure>
<p><strong>容量设置对比</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>错误设置</th>
<th>正确设置</th>
<th>性能提升</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList 存储 1000 元素</td>
<td><code>new ArrayList&lt;&gt;()</code></td>
<td><code>new ArrayList&lt;&gt;(1000)</code></td>
<td>避免约 10 次扩容</td>
</tr>
<tr>
<td>HashMap 存储 1000 键值对</td>
<td><code>new HashMap&lt;&gt;(1000)</code></td>
<td><code>new HashMap&lt;&gt;(1334)</code></td>
<td>避免扩容</td>
</tr>
<tr>
<td>StringBuilder 拼接 10000 字符</td>
<td><code>new StringBuilder()</code></td>
<td><code>new StringBuilder(10016)</code></td>
<td>避免约 13 次扩容</td>
</tr>
</tbody>
</table>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>避免过度预分配</strong>：如果预估的容量远大于实际使用，会造成内存浪费</li>
<li><strong>考虑增长空间</strong>：如果集合会持续增长，可以预留 20%-30% 的额外空间</li>
<li><strong>权衡内存与性能</strong>：内存紧张时使用默认值，性能敏感时精确设置容量</li>
<li><strong>使用工具方法</strong>：Guava 提供了 <code>Maps.newHashMapWithExpectedSize()</code> 等工具方法</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Guava 工具方法示例</span><br><span class="hljs-keyword">import</span> com.google.common.collect.Maps;<br><br><span class="hljs-comment">// 自动计算合适的初始容量</span><br>Map&lt;String, Integer&gt; map = Maps.newHashMapWithExpectedSize(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>
<p>🔑 <strong>模式提炼：</strong> 集合初始容量的设置体现了&quot;预分配优化&quot;的思想。在能够预估元素数量的情况下，合理设置初始容量可以显著提高性能，避免扩容带来的性能损耗。</p>
<h4 id="扩容流程">扩容流程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">add</span><span class="hljs-params">(E e)</span> &#123;<br>    ensureCapacityInternal(size + <span class="hljs-number">1</span>);<br>    elementData[size++] = e;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    <span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    ensureExplicitCapacity(minCapacity);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> &#123;<br>    modCount++;<br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>) &#123;<br>        grow(minCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>扩容示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(); <span class="hljs-comment">// elementData = []</span><br>list.add(<span class="hljs-number">1</span>); <span class="hljs-comment">// 扩容到 10，elementData = [1, null, null, ...]</span><br><span class="hljs-comment">// 依次添加到第 10 个元素</span><br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br><span class="hljs-comment">// ...</span><br>list.add(<span class="hljs-number">10</span>); <span class="hljs-comment">// elementData = [1, 2, 3, ..., 10]</span><br><br>list.add(<span class="hljs-number">11</span>); <span class="hljs-comment">// 触发扩容：10 → 15</span><br><span class="hljs-comment">// elementData = [1, 2, 3, ..., 10, 11, null, null, null, null]</span><br><br>list.add(<span class="hljs-number">16</span>); <span class="hljs-comment">// 触发扩容：15 → 22</span><br></code></pre></td></tr></table></figure>
<h4 id="缩容机制">缩容机制</h4>
<p>ArrayList <strong>不会自动缩容</strong>，即使删除了大量元素。需要手动调用 <code>trimToSize()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">trimToSize</span><span class="hljs-params">()</span> &#123;<br>    modCount++;<br>    <span class="hljs-keyword">if</span> (size &lt; elementData.length) &#123;<br>        elementData = (size == <span class="hljs-number">0</span>) <br>            ? EMPTY_ELEMENTDATA <br>            : Arrays.copyOf(elementData, size);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>缩容示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;Integer&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">100</span>);<br>list.add(<span class="hljs-number">1</span>);<br>list.add(<span class="hljs-number">2</span>);<br>list.add(<span class="hljs-number">3</span>);<br><br>System.out.println(<span class="hljs-string">&quot;Before trim: &quot;</span> + list.size()); <span class="hljs-comment">// 3</span><br>System.out.println(<span class="hljs-string">&quot;Capacity: &quot;</span> + getCapacity(list)); <span class="hljs-comment">// 100</span><br><br>list.trimToSize();<br><br>System.out.println(<span class="hljs-string">&quot;After trim: &quot;</span> + list.size()); <span class="hljs-comment">// 3</span><br>System.out.println(<span class="hljs-string">&quot;Capacity: &quot;</span> + getCapacity(list)); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>
<p><strong>获取容量的反射方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCapacity</span><span class="hljs-params">(ArrayList&lt;?&gt; list)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> ArrayList.class.getDeclaredField(<span class="hljs-string">&quot;elementData&quot;</span>);<br>        field.setAccessible(<span class="hljs-literal">true</span>);<br>        Object[] elementData = (Object[]) field.get(list);<br>        <span class="hljs-keyword">return</span> elementData.length;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ul>
<li>频繁的扩容和缩容会影响性能</li>
<li>如果已知大致容量，建议在构造时指定初始容量</li>
<li><code>trimToSize()</code> 适用于内存敏感场景，但可能触发后续扩容</li>
</ul>
<p>🔑 <strong>模式提炼：容量预分配</strong></p>
<p>当已知集合大致容量时，使用带容量的构造器可以避免多次扩容。适用于批量数据导入、已知大小的数据处理等场景。</p>
<h3 id="3-2-队列的六个操作">3.2 队列的六个操作</h3>
<p>Java 队列接口定义了六个核心操作，分为三类：插入、检查、移除。</p>
<h4 id="操作分类">操作分类</h4>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>抛出异常</th>
<th>返回特殊值</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>add(E)</td>
<td>offer(E)</td>
</tr>
<tr>
<td>检查</td>
<td>element()</td>
<td>peek()</td>
</tr>
<tr>
<td>移除</td>
<td>remove()</td>
<td>poll()</td>
</tr>
</tbody>
</table>
<h4 id="阻塞与非阻塞">阻塞与非阻塞</h4>
<p>阻塞队列（BlockingQueue）额外提供了两个阻塞操作：</p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>阻塞方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入</td>
<td>put(E)</td>
</tr>
<tr>
<td>移除</td>
<td>take()</td>
</tr>
</tbody>
</table>
<h4 id="操作详解">操作详解</h4>
<p><strong>插入操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Queue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br><br><span class="hljs-comment">// add(E): 队列满时抛出 IllegalStateException</span><br><span class="hljs-keyword">try</span> &#123;<br>    queue.add(<span class="hljs-string">&quot;A&quot;</span>);<br>    queue.add(<span class="hljs-string">&quot;B&quot;</span>);<br>    queue.add(<span class="hljs-string">&quot;C&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;Queue: &quot;</span> + queue); <span class="hljs-comment">// [A, B, C]</span><br>&#125; <span class="hljs-keyword">catch</span> (IllegalStateException e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Queue is full&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// offer(E): 队列满时返回 false</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> queue.offer(<span class="hljs-string">&quot;D&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;Offer result: &quot;</span> + success); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<p><strong>检查操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// element(): 队列空时抛出 NoSuchElementException</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> queue.element();<br>    System.out.println(<span class="hljs-string">&quot;Head: &quot;</span> + head); <span class="hljs-comment">// A</span><br>&#125; <span class="hljs-keyword">catch</span> (NoSuchElementException e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Queue is empty&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// peek(): 队列空时返回 null</span><br><span class="hljs-type">String</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> queue.peek();<br>System.out.println(<span class="hljs-string">&quot;Peek: &quot;</span> + head); <span class="hljs-comment">// A</span><br></code></pre></td></tr></table></figure>
<p><strong>移除操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// remove(): 队列空时抛出 NoSuchElementException</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> queue.remove();<br>    System.out.println(<span class="hljs-string">&quot;Removed: &quot;</span> + removed); <span class="hljs-comment">// A</span><br>    System.out.println(<span class="hljs-string">&quot;Queue: &quot;</span> + queue); <span class="hljs-comment">// [B, C, D]</span><br>&#125; <span class="hljs-keyword">catch</span> (NoSuchElementException e) &#123;<br>    System.out.println(<span class="hljs-string">&quot;Queue is empty&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// poll(): 队列空时返回 null</span><br><span class="hljs-type">String</span> <span class="hljs-variable">removed</span> <span class="hljs-operator">=</span> queue.poll();<br>System.out.println(<span class="hljs-string">&quot;Polled: &quot;</span> + removed); <span class="hljs-comment">// B</span><br>System.out.println(<span class="hljs-string">&quot;Queue: &quot;</span> + queue); <span class="hljs-comment">// [C, D]</span><br></code></pre></td></tr></table></figure>
<p><strong>阻塞操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">BlockingQueue&lt;String&gt; blockingQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// put(E): 队列满时阻塞</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        blockingQueue.put(<span class="hljs-string">&quot;A&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Put A&quot;</span>);<br>        blockingQueue.put(<span class="hljs-string">&quot;B&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Put B&quot;</span>);<br>        blockingQueue.put(<span class="hljs-string">&quot;C&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Put C&quot;</span>);<br>        blockingQueue.put(<span class="hljs-string">&quot;D&quot;</span>); <span class="hljs-comment">// 阻塞，直到有空间</span><br>        System.out.println(<span class="hljs-string">&quot;Put D&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt();<br>    &#125;<br>&#125;).start();<br><br><span class="hljs-comment">// take(): 队列空时阻塞</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">taken</span> <span class="hljs-operator">=</span> blockingQueue.take();<br>        System.out.println(<span class="hljs-string">&quot;Taken: &quot;</span> + taken); <span class="hljs-comment">// A</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt();<br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<h4 id="操作选择建议">操作选择建议</h4>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>正常流程，容量充足</td>
<td>add() / element() / remove()</td>
</tr>
<tr>
<td>容量受限，需要容错</td>
<td>offer() / peek() / poll()</td>
</tr>
<tr>
<td>生产者-消费者模式</td>
<td>put() / take()</td>
</tr>
<tr>
<td>定时等待</td>
<td>offer(E, long, TimeUnit) / poll(long, TimeUnit)</td>
</tr>
</tbody>
</table>
<p>🔑 <strong>模式提炼：队列操作六法</strong></p>
<p>根据业务场景选择合适的队列操作：正常流程用异常版本，容量受限用特殊值版本，并发场景用阻塞版本。这确保了代码的健壮性和可预测性。</p>
<h3 id="3-3-priorityqueue">3.3 PriorityQueue</h3>
<p>PriorityQueue 是基于<strong>二叉堆</strong>（Binary Heap）实现的优先级队列，元素按照自然顺序或指定的 Comparator 排序。</p>
<h4 id="基本特性">基本特性</h4>
<ul>
<li><strong>数据结构</strong>：最小堆（min-heap），堆顶是最小元素</li>
<li><strong>排序方式</strong>：自然顺序或自定义 Comparator</li>
<li><strong>时间复杂度</strong>：插入 O(log n)，删除 O(log n)，查找 O(1)</li>
<li><strong>线程安全</strong>：非线程安全，并发场景使用 PriorityBlockingQueue</li>
</ul>
<h4 id="基本使用">基本使用</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自然顺序（升序）</span><br>PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>minHeap.add(<span class="hljs-number">5</span>);<br>minHeap.add(<span class="hljs-number">2</span>);<br>minHeap.add(<span class="hljs-number">8</span>);<br>minHeap.add(<span class="hljs-number">1</span>);<br><br>System.out.println(<span class="hljs-string">&quot;Min heap: &quot;</span> + minHeap); <span class="hljs-comment">// [1, 2, 8, 5]</span><br>System.out.println(<span class="hljs-string">&quot;Peek: &quot;</span> + minHeap.peek()); <span class="hljs-comment">// 1</span><br>System.out.println(<span class="hljs-string">&quot;Poll: &quot;</span> + minHeap.poll()); <span class="hljs-comment">// 1</span><br>System.out.println(<span class="hljs-string">&quot;After poll: &quot;</span> + minHeap); <span class="hljs-comment">// [2, 5, 8]</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义 Comparator（降序）</span><br>PriorityQueue&lt;Integer&gt; maxHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(Collections.reverseOrder());<br>maxHeap.add(<span class="hljs-number">5</span>);<br>maxHeap.add(<span class="hljs-number">2</span>);<br>maxHeap.add(<span class="hljs-number">8</span>);<br>maxHeap.add(<span class="hljs-number">1</span>);<br><br>System.out.println(<span class="hljs-string">&quot;Max heap: &quot;</span> + maxHeap); <span class="hljs-comment">// [8, 5, 2, 1]</span><br>System.out.println(<span class="hljs-string">&quot;Peek: &quot;</span> + maxHeap.peek()); <span class="hljs-comment">// 8</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义对象排序</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Task&gt; &#123;<br>    String name;<br>    <span class="hljs-type">int</span> priority;<br>    <br>    Task(String name, <span class="hljs-type">int</span> priority) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.priority = priority;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Task other)</span> &#123;<br>        <span class="hljs-keyword">return</span> Integer.compare(<span class="hljs-built_in">this</span>.priority, other.priority);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;(&quot;</span> + priority + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br><br>PriorityQueue&lt;Task&gt; taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>taskQueue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-string">&quot;Task A&quot;</span>, <span class="hljs-number">3</span>));<br>taskQueue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-string">&quot;Task B&quot;</span>, <span class="hljs-number">1</span>));<br>taskQueue.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>(<span class="hljs-string">&quot;Task C&quot;</span>, <span class="hljs-number">2</span>));<br><br>System.out.println(<span class="hljs-string">&quot;Task queue: &quot;</span> + taskQueue); <span class="hljs-comment">// [Task B(1), Task A(3), Task C(2)]</span><br>System.out.println(<span class="hljs-string">&quot;Next task: &quot;</span> + taskQueue.poll()); <span class="hljs-comment">// Task B(1)</span><br></code></pre></td></tr></table></figure>
<h4 id="top-k-问题">Top-K 问题</h4>
<p><strong>场景：找出前 K 个最大的元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Integer&gt; <span class="hljs-title function_">topKLargest</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums, <span class="hljs-type">int</span> k)</span> &#123;<br>    <span class="hljs-comment">// 使用最小堆，保持堆大小为 k</span><br>    PriorityQueue&lt;Integer&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : nums) &#123;<br>        minHeap.offer(num);<br>        <span class="hljs-keyword">if</span> (minHeap.size() &gt; k) &#123;<br>            minHeap.poll(); <span class="hljs-comment">// 移除最小的元素</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 堆中剩余的就是前 k 个最大的元素</span><br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(minHeap);<br>    Collections.sort(result, Collections.reverseOrder());<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-type">int</span>[] nums = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">4</span>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>System.out.println(<span class="hljs-string">&quot;Top &quot;</span> + k + <span class="hljs-string">&quot; largest: &quot;</span> + topKLargest(nums, k)); <span class="hljs-comment">// [6, 5]</span><br></code></pre></td></tr></table></figure>
<p><strong>场景：合并 K 个有序链表</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode next;<br>    ListNode(<span class="hljs-type">int</span> val) &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>    <span class="hljs-comment">// 优先队列：按节点值排序</span><br>    PriorityQueue&lt;ListNode&gt; minHeap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(<br>        (a, b) -&gt; Integer.compare(a.val, b.val)<br>    );<br>    <br>    <span class="hljs-comment">// 将所有链表的头节点加入堆</span><br>    <span class="hljs-keyword">for</span> (ListNode head : lists) &#123;<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-literal">null</span>) &#123;<br>            minHeap.offer(head);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-type">ListNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> dummy;<br>    <br>    <span class="hljs-keyword">while</span> (!minHeap.isEmpty()) &#123;<br>        <span class="hljs-comment">// 取出最小的节点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> minHeap.poll();<br>        current.next = node;<br>        current = current.next;<br>        <br>        <span class="hljs-comment">// 将该节点的下一个节点加入堆</span><br>        <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>) &#123;<br>            minHeap.offer(node.next);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="任务调度">任务调度</h4>
<p><strong>场景：按优先级执行任务</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;ScheduledTask&gt; &#123;<br>    String name;<br>    <span class="hljs-type">int</span> priority;<br>    Runnable task;<br>    <br>    ScheduledTask(String name, <span class="hljs-type">int</span> priority, Runnable task) &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.priority = priority;<br>        <span class="hljs-built_in">this</span>.task = task;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(ScheduledTask other)</span> &#123;<br>        <span class="hljs-comment">// 优先级越高（数值越小）越先执行</span><br>        <span class="hljs-keyword">return</span> Integer.compare(<span class="hljs-built_in">this</span>.priority, other.priority);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Executing: &quot;</span> + name + <span class="hljs-string">&quot; (priority: &quot;</span> + priority + <span class="hljs-string">&quot;)&quot;</span>);<br>        task.run();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskScheduler</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityQueue&lt;ScheduledTask&gt; taskQueue;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TaskScheduler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.taskQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">schedule</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> priority, Runnable task)</span> &#123;<br>        taskQueue.offer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledTask</span>(name, priority, task));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!taskQueue.isEmpty()) &#123;<br>            <span class="hljs-type">ScheduledTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> taskQueue.poll();<br>            task.execute();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-type">TaskScheduler</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskScheduler</span>();<br>scheduler.schedule(<span class="hljs-string">&quot;Task A&quot;</span>, <span class="hljs-number">3</span>, () -&gt; System.out.println(<span class="hljs-string">&quot;Task A running&quot;</span>));<br>scheduler.schedule(<span class="hljs-string">&quot;Task B&quot;</span>, <span class="hljs-number">1</span>, () -&gt; System.out.println(<span class="hljs-string">&quot;Task B running&quot;</span>));<br>scheduler.schedule(<span class="hljs-string">&quot;Task C&quot;</span>, <span class="hljs-number">2</span>, () -&gt; System.out.println(<span class="hljs-string">&quot;Task C running&quot;</span>));<br><br>scheduler.run();<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Executing: Task B (priority: 1)</span><br><span class="hljs-comment">// Task B running</span><br><span class="hljs-comment">// Executing: Task C (priority: 2)</span><br><span class="hljs-comment">// Task C running</span><br><span class="hljs-comment">// Executing: Task A (priority: 3)</span><br><span class="hljs-comment">// Task A running</span><br></code></pre></td></tr></table></figure>
<p>🔑 <strong>模式提炼：优先级堆</strong></p>
<p>当需要按优先级处理数据时，PriorityQueue 提供了高效的实现。适用于 Top-K 问题、任务调度、事件驱动系统等场景。</p>
<h3 id="3-4-delayqueue">3.4 DelayQueue</h3>
<p>DelayQueue 是一个无界阻塞队列，只有当元素的延迟时间到期时才能从队列中取出。元素必须实现 Delayed 接口。</p>
<h4 id="delayed-接口">Delayed 接口</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Delayed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Delayed&gt; &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回剩余延迟时间（负值表示已到期）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> unit 时间单位</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 剩余延迟时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="基本使用">基本使用</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedElement</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> delayTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> expireTime;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DelayedElement</span><span class="hljs-params">(String name, <span class="hljs-type">long</span> delay, TimeUnit unit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.delayTime = unit.toMillis(delay);<br>        <span class="hljs-built_in">this</span>.expireTime = System.currentTimeMillis() + <span class="hljs-built_in">this</span>.delayTime;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> expireTime - System.currentTimeMillis();<br>        <span class="hljs-keyword">return</span> unit.convert(remaining, TimeUnit.MILLISECONDS);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == other) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">DelayedElement</span> <span class="hljs-variable">otherElement</span> <span class="hljs-operator">=</span> (DelayedElement) other;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.expireTime - otherElement.expireTime;<br>        <span class="hljs-keyword">return</span> (diff &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : (diff &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot; (expires in &quot;</span> + getDelay(TimeUnit.MILLISECONDS) + <span class="hljs-string">&quot;ms)&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayQueueExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        DelayQueue&lt;DelayedElement&gt; delayQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 添加延迟元素</span><br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedElement</span>(<span class="hljs-string">&quot;Element A&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS));<br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedElement</span>(<span class="hljs-string">&quot;Element B&quot;</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS));<br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedElement</span>(<span class="hljs-string">&quot;Element C&quot;</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS));<br>        <br>        System.out.println(<span class="hljs-string">&quot;Elements added to delay queue&quot;</span>);<br>        <br>        <span class="hljs-comment">// 取出元素（会阻塞直到延迟到期）</span><br>        <span class="hljs-keyword">while</span> (!delayQueue.isEmpty()) &#123;<br>            <span class="hljs-type">DelayedElement</span> <span class="hljs-variable">element</span> <span class="hljs-operator">=</span> delayQueue.take();<br>            System.out.println(<span class="hljs-string">&quot;Taken: &quot;</span> + element);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Elements added to delay queue</span><br><span class="hljs-comment">// Taken: Element B (expires in -1000ms)</span><br><span class="hljs-comment">// Taken: Element C (expires in -2000ms)</span><br><span class="hljs-comment">// Taken: Element A (expires in -3000ms)</span><br></code></pre></td></tr></table></figure>
<h4 id="缓存过期实现">缓存过期实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheItem</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> V value;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> expireTime;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CacheItem</span><span class="hljs-params">(K key, V value, <span class="hljs-type">long</span> ttl, TimeUnit unit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.key = key;<br>        <span class="hljs-built_in">this</span>.value = value;<br>        <span class="hljs-built_in">this</span>.expireTime = System.currentTimeMillis() + unit.toMillis(ttl);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> expireTime - System.currentTimeMillis();<br>        <span class="hljs-keyword">return</span> unit.convert(remaining, TimeUnit.MILLISECONDS);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == other) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        CacheItem&lt;?, ?&gt; otherItem = (CacheItem&lt;?, ?&gt;) other;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.expireTime - otherItem.expireTime;<br>        <span class="hljs-keyword">return</span> (diff &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : (diff &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> K <span class="hljs-title function_">getKey</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">getValue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExpiringCache</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;K, V&gt; cache;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DelayQueue&lt;CacheItem&lt;K, V&gt;&gt; expirationQueue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService cleanupExecutor;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ExpiringCache</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.expirationQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.cleanupExecutor = Executors.newSingleThreadScheduledExecutor();<br>        <br>        <span class="hljs-comment">// 启动清理线程</span><br>        cleanupExecutor.scheduleAtFixedRate(<span class="hljs-built_in">this</span>::cleanup, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value, <span class="hljs-type">long</span> ttl, TimeUnit unit)</span> &#123;<br>        CacheItem&lt;K, V&gt; item = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheItem</span>&lt;&gt;(key, value, ttl, unit);<br>        cache.put(key, value);<br>        expirationQueue.put(item);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;<br>        <span class="hljs-keyword">return</span> cache.get(key);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">()</span> &#123;<br>        CacheItem&lt;K, V&gt; item;<br>        <span class="hljs-keyword">while</span> ((item = expirationQueue.poll()) != <span class="hljs-literal">null</span>) &#123;<br>            cache.remove(item.getKey());<br>            System.out.println(<span class="hljs-string">&quot;Expired: &quot;</span> + item.getKey());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>        cleanupExecutor.shutdown();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>ExpiringCache&lt;String, String&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExpiringCache</span>&lt;&gt;();<br>cache.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>cache.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br><br>System.out.println(<span class="hljs-string">&quot;key1: &quot;</span> + cache.get(<span class="hljs-string">&quot;key1&quot;</span>)); <span class="hljs-comment">// value1</span><br>Thread.sleep(<span class="hljs-number">2500</span>);<br>System.out.println(<span class="hljs-string">&quot;key1: &quot;</span> + cache.get(<span class="hljs-string">&quot;key1&quot;</span>)); <span class="hljs-comment">// null</span><br><br>cache.shutdown();<br></code></pre></td></tr></table></figure>
<h4 id="订单超时取消">订单超时取消</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Order</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String orderId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> expireTime;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Order</span><span class="hljs-params">(String orderId, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        <span class="hljs-built_in">this</span>.orderId = orderId;<br>        <span class="hljs-built_in">this</span>.expireTime = System.currentTimeMillis() + unit.toMillis(timeout);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> expireTime - System.currentTimeMillis();<br>        <span class="hljs-keyword">return</span> unit.convert(remaining, TimeUnit.MILLISECONDS);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> == other) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">Order</span> <span class="hljs-variable">otherOrder</span> <span class="hljs-operator">=</span> (Order) other;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.expireTime - otherOrder.expireTime;<br>        <span class="hljs-keyword">return</span> (diff &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : (diff &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOrderId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> orderId;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderTimeoutService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DelayQueue&lt;Order&gt; timeoutQueue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService timeoutExecutor;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderTimeoutService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.timeoutQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.timeoutExecutor = Executors.newSingleThreadScheduledExecutor();<br>        <br>        <span class="hljs-comment">// 启动超时检查线程</span><br>        timeoutExecutor.execute(<span class="hljs-built_in">this</span>::checkTimeout);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">placeOrder</span><span class="hljs-params">(String orderId, <span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Order placed: &quot;</span> + orderId);<br>        timeoutQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Order</span>(orderId, timeout, unit));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">payOrder</span><span class="hljs-params">(String orderId)</span> &#123;<br>        <span class="hljs-comment">// 支付成功后，从超时队列中移除</span><br>        <span class="hljs-comment">// 实际实现需要维护订单状态</span><br>        System.out.println(<span class="hljs-string">&quot;Order paid: &quot;</span> + orderId);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkTimeout</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Order</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> timeoutQueue.take();<br>                System.out.println(<span class="hljs-string">&quot;Order timeout: &quot;</span> + order.getOrderId());<br>                <span class="hljs-comment">// 执行取消订单逻辑</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>        timeoutExecutor.shutdown();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br><span class="hljs-type">OrderTimeoutService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderTimeoutService</span>();<br>service.placeOrder(<span class="hljs-string">&quot;ORD001&quot;</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>service.placeOrder(<span class="hljs-string">&quot;ORD002&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br><br>Thread.sleep(<span class="hljs-number">6000</span>);<br>service.shutdown();<br></code></pre></td></tr></table></figure>
<p>🔑 <strong>模式提炼：延迟队列</strong></p>
<p>当需要基于时间延迟处理任务时，DelayQueue 提供了优雅的解决方案。适用于缓存过期、订单超时、定时任务调度等场景。</p>
<h2 id="第四章：哈希表家族">第四章：哈希表家族</h2>
<h3 id="4-1-hashmap-内部结构">4.1 HashMap 内部结构</h3>
<p>HashMap 是 Java 中最常用的键值对集合，其内部结构在 Java 8 中引入了红黑树优化。</p>
<h4 id="java-8-内部结构">Java 8+ 内部结构</h4>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">HashMap</span> 内部结构（桶数组 + 链表 + 红黑树）<br><br>┌─────────────────────────────────────────────────────────────┐<br>│                    <span class="hljs-built_in">HashMap</span> 桶数组                             │<br>│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐       │<br>│  │ Bucket <span class="hljs-number">0</span>│  │ Bucket <span class="hljs-number">1</span>│  │ Bucket <span class="hljs-number">2</span>│  │ Bucket <span class="hljs-number">3</span>│  ...  │<br>│  └────┬────┘  └────┬────┘  └────┬────┘  └────┬────┘       │<br>│       │            │            │            │              │<br>│       ▼            ▼            ▼            ▼              │<br>│  ┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐       │<br>│  │  <span class="hljs-literal">null</span>   │  │  Node   │  │  Node   │  │ TreeNode │       │<br>│  └─────────┘  └────┬────┘  └────┬────┘  └────┬────┘       │<br>│                     │            │            │              │<br>│                     ▼            ▼            ▼              │<br>│                ┌─────────┐  ┌─────────┐  ┌─────────┐       │<br>│                │  Node   │  │  Node   │  │ TreeNode │       │<br>│                └────┬────┘  └────┬────┘  └────┬────┘       │<br>│                     │            │            │              │<br>│                     ▼            ▼            ▼              │<br>│                ┌─────────┐  ┌─────────┐  ┌─────────┐       │<br>│                │  Node   │  │  <span class="hljs-literal">null</span>   │  │ TreeNode │       │<br>│                └────┬────┘  └─────────┘  └────┬────┘       │<br>│                     │                         │              │<br>│                     ▼                         ▼              │<br>│                ┌─────────┐              ┌─────────┐         │<br>│                │  <span class="hljs-literal">null</span>   │              │ TreeNode │         │<br>│                └─────────┘              └────┬────┘         │<br>│                                                 │            │<br>│                                                 ▼            │<br>│                                            ┌─────────┐      │<br>│                                            │TreeNode  │      │<br>│                                            └────┬────┘      │<br>│                                                 │            │<br>│                                                 ▼            │<br>│                                            ┌─────────┐      │<br>│                                            │  <span class="hljs-literal">null</span>   │      │<br>│                                            └─────────┘      │<br>└─────────────────────────────────────────────────────────────┘<br><br>Node 结构（链表节点）<br>┌─────────────────────────────────────────┐<br>│  <span class="hljs-type">int</span>    hash     <span class="hljs-comment">// 哈希值               │</span><br>│  K       <span class="hljs-built_in">key</span>      <span class="hljs-comment">// 键                  │</span><br>│  V       value    <span class="hljs-comment">// 值                  │</span><br>│  Node&lt;K,V&gt; next   <span class="hljs-comment">// 下一个节点          │</span><br>└─────────────────────────────────────────┘<br><br>TreeNode 结构（红黑树节点）<br>┌─────────────────────────────────────────┐<br>│  <span class="hljs-type">int</span>    hash     <span class="hljs-comment">// 哈希值               │</span><br>│  K       <span class="hljs-built_in">key</span>      <span class="hljs-comment">// 键                  │</span><br>│  V       value    <span class="hljs-comment">// 值                  │</span><br>│  TreeNode&lt;K,V&gt; parent <span class="hljs-comment">// 父节点          │</span><br>│  TreeNode&lt;K,V&gt; left   <span class="hljs-comment">// 左子节点        │</span><br>│  TreeNode&lt;K,V&gt; right  <span class="hljs-comment">// 右子节点        │</span><br>│  TreeNode&lt;K,V&gt; prev   <span class="hljs-comment">// 前驱节点（用于删除）│</span><br>│  <span class="hljs-type">boolean</span> <span class="hljs-built_in">red</span>          <span class="hljs-comment">// 红黑颜色         │</span><br>└─────────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<h4 id="核心字段">核心字段</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashMap</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractMap</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-comment">// 桶数组，初始化为空数组，第一次 put 时扩容</span><br>    <span class="hljs-keyword">transient</span> Node&lt;K, V&gt;[] table;<br>    <br>    <span class="hljs-comment">// 实际键值对数量</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> size;<br>    <br>    <span class="hljs-comment">// 扩容阈值 = capacity * loadFactor</span><br>    <span class="hljs-type">int</span> threshold;<br>    <br>    <span class="hljs-comment">// 负载因子，默认 0.75</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br>    <br>    <span class="hljs-comment">// 默认初始容量 16</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br>    <br>    <span class="hljs-comment">// 最大容量 2^30</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br>    <br>    <span class="hljs-comment">// 默认负载因子</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> <span class="hljs-variable">DEFAULT_LOAD_FACTOR</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.75f</span>;<br>    <br>    <span class="hljs-comment">// 树化阈值：链表长度 &gt;= 8 时转换为红黑树</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <br>    <span class="hljs-comment">// 反树化阈值：红黑树节点数 &lt;= 6 时转换为链表</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNTREEIFY_THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br>    <br>    <span class="hljs-comment">// 最小树化容量：64（避免扩容时频繁树化）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MIN_TREEIFY_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-2-hashmap-关键参数表">4.2 HashMap 关键参数表</h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>默认值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>初始容量</td>
<td>16</td>
<td>桶数组的初始大小，必须是 2 的幂</td>
</tr>
<tr>
<td>负载因子</td>
<td>0.75</td>
<td>扩容阈值 = 容量 × 负载因子</td>
</tr>
<tr>
<td>树化阈值</td>
<td>8</td>
<td>链表长度 ≥ 8 时转换为红黑树</td>
</tr>
<tr>
<td>反树化阈值</td>
<td>6</td>
<td>红黑树节点数 ≤ 6 时转换为链表</td>
</tr>
<tr>
<td>最小树化容量</td>
<td>64</td>
<td>容量 ≥ 64 时才允许树化</td>
</tr>
</tbody>
</table>
<p><strong>参数选择原理</strong></p>
<ol>
<li>
<p><strong>负载因子 0.75</strong></p>
<ul>
<li>0.75 是时间和空间的平衡点</li>
<li>负载因子过高：哈希冲突增加，查询性能下降</li>
<li>负载因子过低：空间浪费严重</li>
</ul>
</li>
<li>
<p><strong>树化阈值 8</strong></p>
<ul>
<li>基于泊松分布计算，链表长度 ≥ 8 的概率极低</li>
<li>树化是为了优化极端情况下的性能</li>
</ul>
</li>
<li>
<p><strong>反树化阈值 6</strong></p>
<ul>
<li>避免 7-8 之间的频繁转换</li>
<li>提供一定的缓冲空间</li>
</ul>
</li>
</ol>
<h3 id="4-3-hashmap-扩容流程">4.3 HashMap 扩容流程</h3>
<h4 id="扩容触发条件">扩容触发条件</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> V <span class="hljs-title function_">putVal</span><span class="hljs-params">(<span class="hljs-type">int</span> hash, K key, V value, <span class="hljs-type">boolean</span> onlyIfAbsent, <span class="hljs-type">boolean</span> evict)</span> &#123;<br>    Node&lt;K, V&gt;[] tab;<br>    Node&lt;K, V&gt; p;<br>    <span class="hljs-type">int</span> n, i;<br>    <br>    <span class="hljs-comment">// 初始化桶数组</span><br>    <span class="hljs-keyword">if</span> ((tab = table) == <span class="hljs-literal">null</span> || (n = tab.length) == <span class="hljs-number">0</span>) &#123;<br>        n = (tab = resize()).length;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 计算索引</span><br>    <span class="hljs-keyword">if</span> ((p = tab[i = (n - <span class="hljs-number">1</span>) &amp; hash]) == <span class="hljs-literal">null</span>) &#123;<br>        tab[i] = newNode(hash, key, value, <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 处理哈希冲突</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 检查是否需要扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold) &#123;<br>        resize();<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="resize-方法">resize 方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;<br>    Node&lt;K, V&gt;[] oldTab = table;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldCap</span> <span class="hljs-operator">=</span> (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : oldTab.length;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldThr</span> <span class="hljs-operator">=</span> threshold;<br>    <span class="hljs-type">int</span> newCap, newThr = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">// 计算新容量</span><br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 新容量 = 旧容量 × 2</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;<br>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;<br>            newThr = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// 新阈值 = 旧阈值 × 2</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) &#123;<br>        newCap = oldThr;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 首次初始化</span><br>        newCap = DEFAULT_INITIAL_CAPACITY;<br>        newThr = (<span class="hljs-type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (newThr == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">float</span> <span class="hljs-variable">ft</span> <span class="hljs-operator">=</span> (<span class="hljs-type">float</span>)newCap * loadFactor;<br>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; MAXIMUM_CAPACITY ?<br>                  (<span class="hljs-type">int</span>)ft : Integer.MAX_VALUE);<br>    &#125;<br>    threshold = newThr;<br>    <br>    <span class="hljs-comment">// 创建新数组</span><br>    Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>[newCap];<br>    table = newTab;<br>    <br>    <span class="hljs-comment">// 迁移数据</span><br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K, V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 单个节点，直接计算新索引</span><br>                    newTab[e.hash &amp; (newCap - <span class="hljs-number">1</span>)] = e;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> TreeNode) &#123;<br>                    <span class="hljs-comment">// 红黑树节点</span><br>                    ((TreeNode&lt;K, V&gt;)e).split(<span class="hljs-built_in">this</span>, newTab, j, oldCap);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 链表节点</span><br>                    Node&lt;K, V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K, V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K, V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 原索引不变</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>) &#123;<br>                                loHead = e;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                loTail.next = e;<br>                            &#125;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 原索引 + oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>) &#123;<br>                                hiHead = e;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                hiTail.next = e;<br>                            &#125;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        newTab[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> newTab;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="重新分配优化">重新分配优化</h4>
<p>扩容时，节点的索引计算不需要重新哈希，而是通过位运算快速确定：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原索引</span><br><span class="hljs-type">int</span> <span class="hljs-variable">oldIndex</span> <span class="hljs-operator">=</span> hash &amp; (oldCap - <span class="hljs-number">1</span>);<br><br><span class="hljs-comment">// 新索引：要么不变，要么 = oldIndex + oldCap</span><br><span class="hljs-type">int</span> <span class="hljs-variable">newIndex</span> <span class="hljs-operator">=</span> (hash &amp; oldCap) == <span class="hljs-number">0</span> ? oldIndex : oldIndex + oldCap;<br></code></pre></td></tr></table></figure>
<p><strong>原理</strong></p>
<ul>
<li><code>oldCap</code> 是 2 的幂，其二进制表示只有一个 1</li>
<li><code>hash &amp; oldCap</code> 检查 hash 的对应位是 0 还是 1</li>
<li>如果是 0，新索引不变</li>
<li>如果是 1，新索引 = 原索引 + oldCap</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs maxima">假设 oldCap = <span class="hljs-number">16</span> (<span class="hljs-number">0b10000</span>)<br><br>hash = <span class="hljs-number">0b00101</span> (<span class="hljs-number">5</span>)<br>hash &amp; oldCap = <span class="hljs-number">0b00101</span> &amp; <span class="hljs-number">0b10000</span> = <span class="hljs-number">0b00000</span> (<span class="hljs-number">0</span>)<br>新索引 = <span class="hljs-number">5</span> &amp; <span class="hljs-number">15</span> = <span class="hljs-number">5</span> (不变)<br><br>hash = <span class="hljs-number">0b10101</span> (<span class="hljs-number">21</span>)<br>hash &amp; oldCap = <span class="hljs-number">0b10101</span> &amp; <span class="hljs-number">0b10000</span> = <span class="hljs-number">0b10000</span> (<span class="hljs-number">16</span>)<br>新索引 = <span class="hljs-number">21</span> &amp; <span class="hljs-number">31</span> = <span class="hljs-number">21</span> = <span class="hljs-number">5</span> + <span class="hljs-number">16</span> (原索引 + oldCap)<br></code></pre></td></tr></table></figure>
<h4 id="为什么容量必须是-2-的幂">为什么容量必须是 2 的幂</h4>
<ol>
<li>
<p><strong>快速取余</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通取余</span><br>index = hash % capacity;<br><br><span class="hljs-comment">// 位运算取余（要求 capacity 是 2 的幂）</span><br>index = hash &amp; (capacity - <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>扩容优化</strong></p>
<ul>
<li>容量是 2 的幂，扩容时只需要左移一位</li>
<li>节点重新分配时，只需要检查 hash 的一个位</li>
</ul>
</li>
<li>
<p><strong>哈希分布均匀</strong></p>
<ul>
<li>2 的幂确保哈希值能够均匀分布到各个桶</li>
<li>避免某些桶过度拥挤</li>
</ul>
</li>
</ol>
<h3 id="4-4-扰动函数">4.4 扰动函数</h3>
<p>扰动函数用于优化哈希值的分布，减少哈希冲突。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span><span class="hljs-params">(Object key)</span> &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// 高 16 位与低 16 位异或</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>原理</strong></p>
<ul>
<li>假设容量为 16，索引计算只使用 hash 的低 4 位</li>
<li>如果只使用低位，高位的差异会被忽略</li>
<li>异或操作将高位信息混合到低位，增加随机性</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs maxima">假设 capacity = <span class="hljs-number">16</span> (<span class="hljs-number">0b10000</span>)<br><br>hash = <span class="hljs-number">0b1111111100000000</span> (<span class="hljs-number">65280</span>)<br>hashCode = <span class="hljs-number">65280</span><br><br>扰动前：<br>index = <span class="hljs-number">65280</span> &amp; <span class="hljs-number">15</span> = <span class="hljs-number">0b1111111100000000</span> &amp; <span class="hljs-number">0b1111</span> = <span class="hljs-number">0b0000</span> = <span class="hljs-number">0</span><br><br>扰动后：<br>h &gt;&gt;&gt; <span class="hljs-number">16</span> = <span class="hljs-number">0b1111111100000000</span> &gt;&gt;&gt; <span class="hljs-number">16</span> = <span class="hljs-number">0b11111111</span> (<span class="hljs-number">255</span>)<br>hash = <span class="hljs-number">65280</span> ^ <span class="hljs-number">255</span> = <span class="hljs-number">0b1111111100000000</span> ^ <span class="hljs-number">0b0000000011111111</span> = <span class="hljs-number">0b1111111111111111</span> (<span class="hljs-number">65535</span>)<br>index = <span class="hljs-number">65535</span> &amp; <span class="hljs-number">15</span> = <span class="hljs-number">0b1111111111111111</span> &amp; <span class="hljs-number">0b1111</span> = <span class="hljs-number">0b1111</span> = <span class="hljs-number">15</span><br></code></pre></td></tr></table></figure>
<p><strong>效果</strong></p>
<ul>
<li>扰动前，所有 hash 只有低 4 位不同，容易冲突</li>
<li>扰动后，高位信息被利用，哈希分布更均匀</li>
</ul>
<h3 id="4-5-树化与反树化">4.5 树化与反树化</h3>
<h4 id="树化条件">树化条件</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">treeifyBin</span><span class="hljs-params">(Node&lt;K, V&gt;[] tab, <span class="hljs-type">int</span> hash)</span> &#123;<br>    <span class="hljs-type">int</span> n, index;<br>    Node&lt;K, V&gt; e;<br>    <br>    <span class="hljs-comment">// 检查容量是否达到最小树化容量</span><br>    <span class="hljs-keyword">if</span> (tab == <span class="hljs-literal">null</span> || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) &#123;<br>        resize(); <span class="hljs-comment">// 容量不足，扩容而不是树化</span><br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((e = tab[index = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        TreeNode&lt;K, V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 将链表节点转换为红黑树节点</span><br>            TreeNode&lt;K, V&gt; p = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>) &#123;<br>                hd = p;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                p.prev = tl;<br>                tl.next = p;<br>            &#125;<br>            tl = p;<br>        &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        <br>        <span class="hljs-comment">// 构建红黑树</span><br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>) &#123;<br>            hd.treeify(tab);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="泊松分布解释阈值-8">泊松分布解释阈值 8</h4>
<p>根据泊松分布，在负载因子 0.75 下，链表长度达到 8 的概率非常低：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">P(k) = (λ^k * e^(-λ)) / k!<br><br>其中 λ = 0.75<br><br><span class="hljs-attribute">k</span>=0: 47.2%<br><span class="hljs-attribute">k</span>=1: 35.4%<br><span class="hljs-attribute">k</span>=2: 13.3%<br><span class="hljs-attribute">k</span>=3: 3.3%<br><span class="hljs-attribute">k</span>=4: 0.62%<br><span class="hljs-attribute">k</span>=5: 0.094%<br><span class="hljs-attribute">k</span>=6: 0.012%<br><span class="hljs-attribute">k</span>=7: 0.0013%<br><span class="hljs-attribute">k</span>=8: 0.00016% (极低)<br></code></pre></td></tr></table></figure>
<p>因此，链表长度达到 8 是极端情况，此时树化可以显著提升查询性能。</p>
<h4 id="反树化阈值-6">反树化阈值 6</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> Node&lt;K, V&gt; <span class="hljs-title function_">untreeify</span><span class="hljs-params">(HashMap&lt;K, V&gt; map)</span> &#123;<br>    Node&lt;K, V&gt; hd = <span class="hljs-literal">null</span>, tl = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">for</span> (Node&lt;K, V&gt; q = <span class="hljs-built_in">this</span>; q != <span class="hljs-literal">null</span>; q = q.next) &#123;<br>        <span class="hljs-comment">// 将红黑树节点转换为链表节点</span><br>        Node&lt;K, V&gt; p = map.replacementNode(q, <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> (tl == <span class="hljs-literal">null</span>) &#123;<br>            hd = p;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            tl.next = p;<br>        &#125;<br>        tl = p;<br>    &#125;<br>    <span class="hljs-keyword">return</span> hd;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么反树化阈值是 6？</strong></p>
<ul>
<li>树化阈值是 8，反树化阈值是 6</li>
<li>避免 7-8 之间的频繁转换（8 树化，7 反树化，8 树化…）</li>
<li>提供一定的缓冲空间，减少转换开销</li>
</ul>
<h3 id="4-6-concurrenthashmap-扩容">4.6 ConcurrentHashMap 扩容</h3>
<h4 id="分段迁移">分段迁移</h4>
<p>ConcurrentHashMap 的扩容采用<strong>多线程分段迁移</strong>策略，提高扩容效率。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">transfer</span><span class="hljs-params">(Node&lt;K, V&gt;[] tab, Node&lt;K, V&gt;[] nextTab)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length, stride;<br>    <br>    <span class="hljs-comment">// 计算每个线程处理的步长</span><br>    <span class="hljs-keyword">if</span> ((stride = (NCPU &gt; <span class="hljs-number">1</span>) ? (n &gt;&gt;&gt; <span class="hljs-number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) &#123;<br>        stride = MIN_TRANSFER_STRIDE;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (nextTab == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 创建新数组，容量为 2 倍</span><br>            nextTab = (Node&lt;K, V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;?, ?&gt;[n &lt;&lt; <span class="hljs-number">1</span>];<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>            sizeCtl = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        nextTable = nextTab;<br>        transferIndex = n;<br>    &#125;<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">nextn</span> <span class="hljs-operator">=</span> nextTab.length;<br>    ForwardingNode&lt;K, V&gt; fwd = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForwardingNode</span>&lt;K, V&gt;(nextTab);<br>    <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">advance</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">finishing</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, bound = <span class="hljs-number">0</span>;;) &#123;<br>        Node&lt;K, V&gt; f;<br>        <span class="hljs-type">int</span> fh;<br>        <br>        <span class="hljs-keyword">while</span> (advance) &#123;<br>            <span class="hljs-type">int</span> nextIndex, nextBound;<br>            <span class="hljs-keyword">if</span> (--i &gt;= bound || finishing) &#123;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="hljs-number">0</span>) &#123;<br>                i = -<span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, TRANSFERINDEX, nextIndex,<br>                                          nextBound = (nextIndex &gt; stride ?<br>                                                       nextIndex - stride : <span class="hljs-number">0</span>))) &#123;<br>                bound = nextBound;<br>                i = nextIndex - <span class="hljs-number">1</span>;<br>                advance = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;<br>            <span class="hljs-keyword">if</span> (finishing) &#123;<br>                nextTable = <span class="hljs-literal">null</span>;<br>                table = nextTab;<br>                sizeCtl = (n &lt;&lt; <span class="hljs-number">1</span>) - (n &gt;&gt;&gt; <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (U.compareAndSwapInt(<span class="hljs-built_in">this</span>, SIZECTL, sizeCtl = -<span class="hljs-number">1</span>, sc = sizeCtl)) &#123;<br>                <span class="hljs-keyword">if</span> (sc == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                finishing = advance = <span class="hljs-literal">true</span>;<br>                i = n;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((f = tabAt(tab, i)) == <span class="hljs-literal">null</span>) &#123;<br>            advance = casTabAt(tab, i, <span class="hljs-literal">null</span>, fwd);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((fh = f.hash) == MOVED) &#123;<br>            advance = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (f) &#123;<br>                <span class="hljs-keyword">if</span> (tabAt(tab, i) == f) &#123;<br>                    Node&lt;K, V&gt; ln, hn;<br>                    <span class="hljs-keyword">if</span> (fh &gt;= <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 链表节点迁移</span><br>                        <span class="hljs-type">int</span> <span class="hljs-variable">runBit</span> <span class="hljs-operator">=</span> fh &amp; n;<br>                        Node&lt;K, V&gt; lastRun = f;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K, V&gt; p = f.next; p != <span class="hljs-literal">null</span>; p = p.next) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> p.hash &amp; n;<br>                            <span class="hljs-keyword">if</span> (b != runBit) &#123;<br>                                runBit = b;<br>                                lastRun = p;<br>                            &#125;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (runBit == <span class="hljs-number">0</span>) &#123;<br>                            ln = lastRun;<br>                            hn = <span class="hljs-literal">null</span>;<br>                        &#125; <span class="hljs-keyword">else</span> &#123;<br>                            hn = lastRun;<br>                            ln = <span class="hljs-literal">null</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K, V&gt; p = f; p != lastRun; p = p.next) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">ph</span> <span class="hljs-operator">=</span> p.hash;<br>                            <span class="hljs-type">K</span> <span class="hljs-variable">pk</span> <span class="hljs-operator">=</span> p.key;<br>                            <span class="hljs-type">V</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> p.val;<br>                            <span class="hljs-keyword">if</span> ((ph &amp; n) == <span class="hljs-number">0</span>) &#123;<br>                                ln = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt;(ph, pk, pv, ln);<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                hn = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt;(ph, pk, pv, hn);<br>                            &#125;<br>                        &#125;<br>                        setTabAt(nextTab, i, ln);<br>                        setTabAt(nextTab, i + n, hn);<br>                        setTabAt(tab, i, fwd);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (f <span class="hljs-keyword">instanceof</span> TreeBin) &#123;<br>                        <span class="hljs-comment">// 红黑树节点迁移</span><br>                        TreeBin&lt;K, V&gt; t = (TreeBin&lt;K, V&gt;) f;<br>                        TreeNode&lt;K, V&gt; lo = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                        TreeNode&lt;K, V&gt; hi = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">lc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, hc = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">for</span> (Node&lt;K, V&gt; e = t.first; e != <span class="hljs-literal">null</span>; e = e.next) &#123;<br>                            <span class="hljs-type">int</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> e.hash;<br>                            <span class="hljs-type">K</span> <span class="hljs-variable">pk</span> <span class="hljs-operator">=</span> e.key;<br>                            <span class="hljs-type">V</span> <span class="hljs-variable">pv</span> <span class="hljs-operator">=</span> e.val;<br>                            <span class="hljs-keyword">if</span> ((h &amp; n) == <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-keyword">if</span> ((e.prev = loTail) == <span class="hljs-literal">null</span>) &#123;<br>                                    lo = e;<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    loTail.next = e;<br>                                &#125;<br>                                loTail = e;<br>                                ++lc;<br>                            &#125; <span class="hljs-keyword">else</span> &#123;<br>                                <span class="hljs-keyword">if</span> ((e.prev = hiTail) == <span class="hljs-literal">null</span>) &#123;<br>                                    hi = e;<br>                                &#125; <span class="hljs-keyword">else</span> &#123;<br>                                    hiTail.next = e;<br>                                &#125;<br>                                hiTail = e;<br>                                ++hc;<br>                            &#125;<br>                        &#125;<br>                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :<br>                            (hc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K, V&gt;(lo) : t;<br>                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :<br>                            (lc != <span class="hljs-number">0</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeBin</span>&lt;K, V&gt;(hi) : t;<br>                        setTabAt(nextTab, i, ln);<br>                        setTabAt(nextTab, i + n, hn);<br>                        setTabAt(tab, i, fwd);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="sizectl-字段含义">sizeCtl 字段含义</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sizeCtl 的不同值表示不同状态</span><br><br><span class="hljs-comment">// 负数：表示正在初始化或扩容</span><br><span class="hljs-comment">// -1：正在初始化</span><br><span class="hljs-comment">// -N：表示有 N-1 个线程正在扩容</span><br><br><span class="hljs-comment">// 正数：</span><br><span class="hljs-comment">// 0：默认值，表示未初始化</span><br><span class="hljs-comment">// &gt;0：表示扩容阈值（类似 HashMap 的 threshold）</span><br></code></pre></td></tr></table></figure>
<p><strong>扩容流程</strong></p>
<ol>
<li>检测到 size &gt; threshold</li>
<li>设置 sizeCtl 为负数，标记扩容状态</li>
<li>多线程分段迁移桶数组</li>
<li>迁移完成后，更新 sizeCtl 为新的阈值</li>
</ol>
<h4 id="jdk-7-与-jdk-8-的实现对比">JDK 7 与 JDK 8 的实现对比</h4>
<p>ConcurrentHashMap 在 JDK 7 和 JDK 8 中经历了重大架构调整，从分段锁演进为更细粒度的锁机制。</p>
<p><strong>JDK 7 分段锁架构</strong></p>
<p>JDK 7 采用分段锁（Segment）设计，将数据分成多个段（默认 16 个），每个段是一个独立的 HashMap，使用 ReentrantLock 保护。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 7 ConcurrentHashMap 结构（简化）</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Segment</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReentrantLock</span> &#123;<br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> HashEntry&lt;K, V&gt;[] table;<br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> count;<br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> modCount;<br>    <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> threshold;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">float</span> loadFactor;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashEntry</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V value;<br>    <span class="hljs-keyword">volatile</span> HashEntry&lt;K, V&gt; next;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>JDK 8 CAS + synchronized 架构</strong></p>
<p>JDK 8 摒弃了 Segment，采用数组 + 链表 + 红黑树结构，使用 CAS + synchronized 实现更细粒度的锁控制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 8 ConcurrentHashMap 结构（简化）</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Map</span>.Entry&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> hash;<br>    <span class="hljs-keyword">final</span> K key;<br>    <span class="hljs-keyword">volatile</span> V val;<br>    <span class="hljs-keyword">volatile</span> Node&lt;K, V&gt; next;<br>&#125;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; &#123;<br>    TreeNode&lt;K, V&gt; parent;<br>    TreeNode&lt;K, V&gt; left;<br>    TreeNode&lt;K, V&gt; right;<br>    TreeNode&lt;K, V&gt; prev;<br>    <span class="hljs-type">boolean</span> red;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>实现对比</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>JDK 7</th>
<th>JDK 8</th>
</tr>
</thead>
<tbody>
<tr>
<td>锁机制</td>
<td>ReentrantLock（分段锁）</td>
<td>CAS + synchronized</td>
</tr>
<tr>
<td>锁粒度</td>
<td>Segment 级别（默认 16 个）</td>
<td>桶级别（Node 级别）</td>
</tr>
<tr>
<td>数据结构</td>
<td>Segment 数组 + HashEntry 链表</td>
<td>Node 数组 + 链表 + 红黑树</td>
</tr>
<tr>
<td>并发度</td>
<td>固定为 Segment 数量</td>
<td>理论上为桶数量</td>
</tr>
<tr>
<td>扩容方式</td>
<td>Segment 独立扩容</td>
<td>多线程协作扩容</td>
</tr>
<tr>
<td>内存占用</td>
<td>较高（Segment 数组开销）</td>
<td>较低（无额外数组）</td>
</tr>
<tr>
<td>查询性能</td>
<td>需要两次哈希定位</td>
<td>一次哈希定位</td>
</tr>
</tbody>
</table>
<p><strong>锁粒度对比</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 7：锁整个 Segment</span><br>Segment&lt;K, V&gt; s = segmentFor(hash);<br>s.lock(); <span class="hljs-comment">// 锁住整个 Segment</span><br><span class="hljs-keyword">try</span> &#123;<br>    HashEntry&lt;K, V&gt;[] tab = s.table;<br>    <span class="hljs-comment">// 操作整个 Segment 的数据</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    s.unlock();<br>&#125;<br><br><span class="hljs-comment">// JDK 8：只锁单个桶</span><br>Node&lt;K, V&gt;[] tab = table;<br><span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> tab.length;<br>Node&lt;K, V&gt; f = tabAt(tab, (n - <span class="hljs-number">1</span>) &amp; hash);<br><span class="hljs-keyword">if</span> (f == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// CAS 设置新节点</span><br>    <span class="hljs-keyword">if</span> (casTabAt(tab, i, <span class="hljs-literal">null</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt;(hash, key, val, <span class="hljs-literal">null</span>))) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (f) &#123; <span class="hljs-comment">// 只锁当前桶的头节点</span><br>        <span class="hljs-comment">// 操作当前桶的链表或红黑树</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>并发度提升</strong></p>
<p>JDK 7 的并发度受限于 Segment 数量（默认 16），即使有更多线程也无法充分利用。JDK 8 将锁粒度细化到桶级别，理论上并发度等于桶数量，大幅提升了高并发场景下的性能。</p>
<p>🔑 <strong>模式提炼：</strong> JDK 8 的改进体现了&quot;锁粒度细化&quot;的设计思想，将粗粒度锁拆分为多个细粒度锁，减少线程竞争，提高并发性能。</p>
<h3 id="4-7-linkedhashmap">4.7 LinkedHashMap</h3>
<p>LinkedHashMap 在 HashMap 的基础上增加了<strong>顺序保持</strong>功能，可以按照插入顺序或访问顺序遍历元素。</p>
<h4 id="保持插入顺序">保持插入顺序</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LinkedHashMap 默认按插入顺序遍历</span><br>LinkedHashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">1</span>);<br>map.put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">2</span>);<br>map.put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 遍历顺序：A -&gt; B -&gt; C</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;String, Integer&gt; entry : map.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>&#125;<br><br><span class="hljs-comment">// LinkedHashSet 同理</span><br>LinkedHashSet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;&gt;();<br>set.add(<span class="hljs-string">&quot;A&quot;</span>);<br>set.add(<span class="hljs-string">&quot;B&quot;</span>);<br>set.add(<span class="hljs-string">&quot;C&quot;</span>);<br>System.out.println(set); <span class="hljs-comment">// [A, B, C]</span><br></code></pre></td></tr></table></figure>
<h4 id="保持访问顺序-lru-缓存">保持访问顺序（LRU 缓存）</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// accessOrder=true：按访问顺序遍历</span><br>LinkedHashMap&lt;String, Integer&gt; lruCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;&gt;(<span class="hljs-number">16</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;String, Integer&gt; eldest)</span> &#123;<br>        <span class="hljs-keyword">return</span> size() &gt; <span class="hljs-number">3</span>; <span class="hljs-comment">// 缓存大小限制为 3</span><br>    &#125;<br>&#125;;<br><br>lruCache.put(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">1</span>);<br>lruCache.put(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">2</span>);<br>lruCache.put(<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 访问 &quot;A&quot;，将其移到末尾</span><br>lruCache.get(<span class="hljs-string">&quot;A&quot;</span>);<br><br><span class="hljs-comment">// 添加 &quot;D&quot;，触发 eldest 移除（&quot;B&quot; 是最久未访问的）</span><br>lruCache.put(<span class="hljs-string">&quot;D&quot;</span>, <span class="hljs-number">4</span>);<br><br><span class="hljs-comment">// 当前顺序：C -&gt; A -&gt; D</span><br>System.out.println(lruCache.keySet()); <span class="hljs-comment">// [C, A, D]</span><br></code></pre></td></tr></table></figure>
<h4 id="lru-缓存实现">LRU 缓存实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxSize;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> maxSize)</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-number">16</span>, <span class="hljs-number">0.75f</span>, <span class="hljs-literal">true</span>);<br>        <span class="hljs-built_in">this</span>.maxSize = maxSize;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;<br>        <span class="hljs-keyword">return</span> size() &gt; maxSize;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>LRUCache&lt;String, String&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>cache.put(<span class="hljs-string">&quot;key1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>cache.put(<span class="hljs-string">&quot;key2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br>cache.put(<span class="hljs-string">&quot;key3&quot;</span>, <span class="hljs-string">&quot;value3&quot;</span>);<br><br>cache.get(<span class="hljs-string">&quot;key1&quot;</span>); <span class="hljs-comment">// 访问 key1</span><br>cache.put(<span class="hljs-string">&quot;key4&quot;</span>, <span class="hljs-string">&quot;value4&quot;</span>); <span class="hljs-comment">// 添加 key4，移除 key2（最久未访问）</span><br><br>System.out.println(cache.keySet()); <span class="hljs-comment">// [key3, key1, key4]</span><br></code></pre></td></tr></table></figure>
<h4 id="性能对比">性能对比</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>HashMap</th>
<th>LinkedHashMap</th>
</tr>
</thead>
<tbody>
<tr>
<td>插入/删除</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>查找</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td>遍历顺序</td>
<td>无序</td>
<td>插入顺序/访问顺序</td>
</tr>
<tr>
<td>内存开销</td>
<td>较小</td>
<td>较大（维护双向链表）</td>
</tr>
</tbody>
</table>
<p>🔑 <strong>模式提炼：有序集合与 LRU 缓存</strong></p>
<p>当需要保持元素顺序或实现 LRU 缓存时，LinkedHashMap/LinkedHashSet 提供了比手动维护顺序更优雅的解决方案。适用于历史记录、最近访问列表、缓存淘汰等场景。</p>
<h3 id="4-8-enumset">4.8 EnumSet</h3>
<p>EnumSet 是专为枚举类型设计的高性能 Set，使用位向量（Bit Vector）存储，空间和时间效率极高。</p>
<h4 id="enumset-的限制">EnumSet 的限制</h4>
<ul>
<li>只能包含枚举值，且所有值必须属于同一个枚举</li>
<li>不允许添加 null 值，尝试添加会抛出 NullPointerException</li>
<li>不是线程安全的，如果需要则需外部同步</li>
<li>元素按照枚举中声明的顺序存储</li>
<li>使用 fail-safe 迭代器，在迭代时修改集合不会抛出 ConcurrentModificationException</li>
</ul>
<h4 id="创建与使用">创建与使用</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Day</span> &#123;<br>    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY<br>&#125;<br><br><span class="hljs-comment">// 创建 EnumSet</span><br>EnumSet&lt;Day&gt; weekdays = EnumSet.of(Day.MONDAY, Day.TUESDAY, Day.WEDNESDAY, <br>                                   Day.THURSDAY, Day.FRIDAY);<br>EnumSet&lt;Day&gt; weekend = EnumSet.of(Day.SATURDAY, Day.SUNDAY);<br><br><span class="hljs-comment">// 范围创建</span><br>EnumSet&lt;Day&gt; allDays = EnumSet.allOf(Day.class);<br>EnumSet&lt;Day&gt; noDays = EnumSet.noneOf(Day.class);<br><br><span class="hljs-comment">// 补集操作</span><br>EnumSet&lt;Day&gt; complement = EnumSet.complementOf(weekdays); <span class="hljs-comment">// weekend</span><br><br><span class="hljs-comment">// 集合操作</span><br>EnumSet&lt;Day&gt; workDays = EnumSet.range(Day.MONDAY, Day.FRIDAY);<br>System.out.println(workDays.add(Day.SATURDAY)); <span class="hljs-comment">// false (已满)</span><br>System.out.println(workDays.remove(Day.SUNDAY)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>
<h4 id="jdk-实现细节">JDK 实现细节</h4>
<p>JDK 提供两个默认参考实现：</p>
<ul>
<li><strong>RegularEnumSet</strong>：当枚举值数量 ≤ 64 时，使用单个 long 值作为位向量</li>
<li><strong>JumboEnumSet</strong>：当枚举值数量 &gt; 64 时，使用 long 数组作为位向量</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">EnumSet&lt;InsPayOrderStatusEnum&gt; BAD_FINAL_STATUSES = EnumSet.of(FAILED, CLOSED, BOUNCED);<br></code></pre></td></tr></table></figure>
<h4 id="性能优势">性能优势</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// EnumSet vs HashSet</span><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123; RED, GREEN, BLUE, YELLOW &#125;<br><br><span class="hljs-comment">// EnumSet: 使用单个 long 值存储（64位可存储64个枚举）</span><br>EnumSet&lt;Color&gt; enumSet = EnumSet.of(Color.RED, Color.GREEN);<br><span class="hljs-comment">// 内部结构：long = 0b0011 (位向量)</span><br><br><span class="hljs-comment">// HashSet: 使用数组+链表存储</span><br>HashSet&lt;Color&gt; hashSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;();<br>hashSet.add(Color.RED);<br>hashSet.add(Color.GREEN);<br><span class="hljs-comment">// 内部结构：Node[] 数组 + 链表节点</span><br><br><span class="hljs-comment">// 性能测试</span><br>EnumSet&lt;Color&gt; es = EnumSet.allOf(Color.class);<br>HashSet&lt;Color&gt; hs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(Color.values()));<br><br><span class="hljs-comment">// EnumSet 的 contains 操作：位运算 O(1)</span><br><span class="hljs-comment">// HashSet 的 contains 操作：哈希计算 + 链表遍历 O(1) 平均</span><br></code></pre></td></tr></table></figure>
<p>🔑 <strong>模式提炼：枚举专用集合</strong></p>
<p>当集合元素类型是枚举时，EnumSet/EnumMap 提供了比通用集合更好的性能和更紧凑的内存占用。适用于标志位集合、状态机、配置管理等场景。</p>
<h3 id="4-9-enummap">4.9 EnumMap</h3>
<p>EnumMap 是专为枚举类型设计的高性能 Map，使用数组存储，键必须是枚举类型。</p>
<h4 id="创建与使用">创建与使用</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Operation</span> &#123;<br>    ADD, SUBTRACT, MULTIPLY, DIVIDE<br>&#125;<br><br>EnumMap&lt;Operation, String&gt; descriptions = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnumMap</span>&lt;&gt;(Operation.class);<br>descriptions.put(Operation.ADD, <span class="hljs-string">&quot;加法&quot;</span>);<br>descriptions.put(Operation.SUBTRACT, <span class="hljs-string">&quot;减法&quot;</span>);<br>descriptions.put(Operation.MULTIPLY, <span class="hljs-string">&quot;乘法&quot;</span>);<br>descriptions.put(Operation.DIVIDE, <span class="hljs-string">&quot;除法&quot;</span>);<br><br><span class="hljs-comment">// 遍历（保证按枚举声明顺序）</span><br><span class="hljs-keyword">for</span> (Map.Entry&lt;Operation, String&gt; entry : descriptions.entrySet()) &#123;<br>    System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="高级用法">高级用法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 复制构造器</span><br>Map&lt;DayOfWeek, String&gt; ordinaryMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>ordinaryMap.put(DayOfWeek.MONDAY, <span class="hljs-string">&quot;Soccer&quot;</span>);<br>EnumMap&lt;DayOfWeek, String&gt; enumMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnumMap</span>&lt;&gt;(ordinaryMap);<br><br><span class="hljs-comment">// 双参数的 remove</span><br>activityMap.put(DayOfWeek.MONDAY, <span class="hljs-string">&quot;Soccer&quot;</span>);<br>assertThat(activityMap.remove(DayOfWeek.MONDAY, <span class="hljs-string">&quot;Hiking&quot;</span>)).isEqualTo(<span class="hljs-literal">false</span>);<br>assertThat(activityMap.remove(DayOfWeek.MONDAY, <span class="hljs-string">&quot;Soccer&quot;</span>)).isEqualTo(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>
<h4 id="性能优势">性能优势</h4>
<p>使用 Enum 作为 key 使得可以做一些额外的性能优化，比如更快的哈希计算，因为所有可能的键都是预先知道的。</p>
<p>因为枚举的顺序已经被事先知道了，所以可以进行某些极致的优化。</p>
<p>EnumMap 是一个有序 map，它的视图会按照枚举顺序迭代。虽然 LinkedHashMap 和 TreeMap 也可以提供类似的行为，但 EnumMap 的性能更优。</p>
<h3 id="4-10-identityhashmap">4.10 IdentityHashMap</h3>
<p>IdentityHashMap 的用法和 HashMap 的用法差不多，它们之间最大的区别就是 IdentityHashMap 判断两个 key 是否相等，是通过严格相等即（key1 == key2）来判断的，而 HashMap 是通过 equals() 方法和 hashCode() 这两个方法来判断 key 是否相等的。</p>
<h4 id="用途">用途</h4>
<ul>
<li>需要比对独一无二的对象，如全局的 class，可以用 IdentityHashMap 来控制唯一性</li>
<li>深拷贝的时候需要容忍相同的值不同引用的对象</li>
</ul>
<h4 id="使用示例">使用示例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通 HashMap：基于 equals() 和 hashCode()</span><br>HashMap&lt;String, String&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-type">String</span> <span class="hljs-variable">key1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;test&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">key2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>hashMap.put(key1, <span class="hljs-string">&quot;value1&quot;</span>);<br>hashMap.put(key2, <span class="hljs-string">&quot;value2&quot;</span>);<br>System.out.println(hashMap.size()); <span class="hljs-comment">// 1（key1.equals(key2) 返回 true）</span><br><br><span class="hljs-comment">// IdentityHashMap：基于引用相等</span><br>IdentityHashMap&lt;String, String&gt; identityMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdentityHashMap</span>&lt;&gt;();<br>identityMap.put(key1, <span class="hljs-string">&quot;value1&quot;</span>);<br>identityMap.put(key2, <span class="hljs-string">&quot;value2&quot;</span>);<br>System.out.println(identityMap.size()); <span class="hljs-comment">// 2（key1 != key2）</span><br></code></pre></td></tr></table></figure>
<h4 id="实际应用场景">实际应用场景</h4>
<p><strong>深拷贝场景</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 深拷贝时需要区分相同值的不同引用</span><br>IdentityHashMap&lt;Object, Object&gt; visited = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdentityHashMap</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deepCopy</span><span class="hljs-params">(Object obj)</span> &#123;<br>    <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-comment">// 检查是否已经复制过（基于引用）</span><br>    <span class="hljs-keyword">if</span> (visited.containsKey(obj)) &#123;<br>        <span class="hljs-keyword">return</span> visited.get(obj);<br>    &#125;<br>    <br>    <span class="hljs-type">Object</span> <span class="hljs-variable">copy</span> <span class="hljs-operator">=</span> createCopy(obj);<br>    visited.put(obj, copy); <span class="hljs-comment">// 记录已复制的对象</span><br>    <br>    <span class="hljs-comment">// 递归复制引用</span><br>    <span class="hljs-keyword">for</span> (Object ref : getReferences(obj)) &#123;<br>        copyReference(copy, deepCopy(ref));<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> copy;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>序列化场景</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 序列化时需要维护对象引用关系</span><br>IdentityHashMap&lt;Object, Integer&gt; objectMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdentityHashMap</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serialize</span><span class="hljs-params">(Object obj, ObjectOutputStream out)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 为每个对象分配唯一 ID（基于引用）</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> objectMap.size();<br>    objectMap.put(obj, id);<br>    <br>    out.writeObject(id);<br>    <span class="hljs-comment">// 序列化对象内容...</span><br>&#125;<br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">deserialize</span><span class="hljs-params">(ObjectInputStream in)</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> in.readInt();<br>    <span class="hljs-comment">// 根据 ID 反序列化对象...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>🔑 <strong>模式提炼：引用语义映射</strong></p>
<p>当需要基于对象引用而非对象相等性进行映射时，IdentityHashMap 提供了精确的引用语义。适用于深拷贝、序列化、对象跟踪等场景。</p>
<h3 id="4-11-weakhashmap">4.11 WeakHashMap</h3>
<p>WeakHashMap 是一个使用弱引用作为键的 HashMap。当键不再被外部引用时，它可以被垃圾回收器回收，对应的键值对也会自动从 Map 中移除。</p>
<h4 id="弱引用机制">弱引用机制</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通 HashMap：键被强引用</span><br>HashMap&lt;String, String&gt; strongMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>strongMap.put(key, <span class="hljs-string">&quot;value&quot;</span>);<br>key = <span class="hljs-literal">null</span>; <span class="hljs-comment">// key 仍被 Map 引用，不会被 GC</span><br><br><span class="hljs-comment">// WeakHashMap：键被弱引用</span><br>WeakHashMap&lt;String, String&gt; weakMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br>key = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;test&quot;</span>);<br>weakMap.put(key, <span class="hljs-string">&quot;value&quot;</span>);<br>key = <span class="hljs-literal">null</span>; <span class="hljs-comment">// key 不再被强引用，GC 时会被回收</span><br><br>System.gc(); <span class="hljs-comment">// 触发 GC</span><br>System.out.println(weakMap.size()); <span class="hljs-comment">// 可能输出 0</span><br></code></pre></td></tr></table></figure>
<h4 id="实际应用场景">实际应用场景</h4>
<p><strong>缓存实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakCache</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">private</span> WeakHashMap&lt;K, V&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        cache.put(key, value);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;<br>        <span class="hljs-keyword">return</span> cache.get(key);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">size</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cache.size();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用场景：缓存大对象，当内存不足时自动释放</span><br>WeakCache&lt;String, <span class="hljs-type">byte</span>[]&gt; imageCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakCache</span>&lt;&gt;();<br>imageCache.put(<span class="hljs-string">&quot;image1&quot;</span>, loadLargeImage(<span class="hljs-string">&quot;image1.jpg&quot;</span>));<br><span class="hljs-comment">// 当内存紧张时，这些大对象会被自动回收</span><br></code></pre></td></tr></table></figure>
<p><strong>对象元数据关联</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 为对象附加元数据，不阻止对象被回收</span><br>WeakHashMap&lt;Object, Map&lt;String, Object&gt;&gt; metadataMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">attachMetadata</span><span class="hljs-params">(Object obj, String key, Object value)</span> &#123;<br>    metadataMap.computeIfAbsent(obj, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;()).put(key, value);<br>&#125;<br><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getMetadata</span><span class="hljs-params">(Object obj, String key)</span> &#123;<br>    Map&lt;String, Object&gt; metadata = metadataMap.get(obj);<br>    <span class="hljs-keyword">return</span> metadata != <span class="hljs-literal">null</span> ? metadata.get(key) : <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 当 obj 不再被使用时，其元数据也会自动清理</span><br></code></pre></td></tr></table></figure>
<h4 id="注意事项">注意事项</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：使用字符串字面量作为键</span><br>WeakHashMap&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakHashMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;test&quot;</span>, <span class="hljs-string">&quot;value&quot;</span>); <span class="hljs-comment">// &quot;test&quot; 是字符串常量，不会被 GC</span><br>System.gc();<br>System.out.println(map.size()); <span class="hljs-comment">// 仍然是 1</span><br><br><span class="hljs-comment">// 正确示例：使用新创建的对象作为键</span><br>map.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;test&quot;</span>), <span class="hljs-string">&quot;value&quot;</span>);<br>System.gc();<br>System.out.println(map.size()); <span class="hljs-comment">// 可能是 0</span><br></code></pre></td></tr></table></figure>
<p>🔑 <strong>模式提炼：自动清理缓存</strong></p>
<p>当需要缓存数据但不希望缓存阻止对象被垃圾回收时，WeakHashMap 提供了自动清理机制。适用于对象元数据、临时缓存、监听器注册等场景。</p>
<h2 id="第五章：有序集合与并发集合">第五章：有序集合与并发集合</h2>
<h3 id="5-1-treeset-与-treemap">5.1 TreeSet 与 TreeMap</h3>
<p>TreeSet 和 TreeMap 基于红黑树实现，提供自动排序和范围查询能力。红黑树是一种自平衡二叉搜索树，确保所有操作的时间复杂度为 O(log n)。</p>
<p><strong>TreeSet 基本用法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.TreeSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeSetExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 自然排序（升序）</span><br>        TreeSet&lt;Integer&gt; numbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        numbers.add(<span class="hljs-number">5</span>);<br>        numbers.add(<span class="hljs-number">2</span>);<br>        numbers.add(<span class="hljs-number">8</span>);<br>        numbers.add(<span class="hljs-number">1</span>);<br>        numbers.add(<span class="hljs-number">3</span>);<br>        <br>        <span class="hljs-comment">// 自动排序输出：[1, 2, 3, 5, 8]</span><br>        System.out.println(numbers);<br>        <br>        <span class="hljs-comment">// 范围查询：获取大于等于3的元素</span><br>        System.out.println(numbers.tailSet(<span class="hljs-number">3</span>)); <span class="hljs-comment">// [3, 5, 8]</span><br>        <br>        <span class="hljs-comment">// 范围查询：获取小于5的元素</span><br>        System.out.println(numbers.headSet(<span class="hljs-number">5</span>)); <span class="hljs-comment">// [1, 2, 3]</span><br>        <br>        <span class="hljs-comment">// 范围查询：获取2到8之间的元素（包含2，不包含8）</span><br>        System.out.println(numbers.subSet(<span class="hljs-number">2</span>, <span class="hljs-number">8</span>)); <span class="hljs-comment">// [2, 3, 5]</span><br>        <br>        <span class="hljs-comment">// 获取第一个和最后一个元素</span><br>        System.out.println(<span class="hljs-string">&quot;First: &quot;</span> + numbers.first()); <span class="hljs-comment">// 1</span><br>        System.out.println(<span class="hljs-string">&quot;Last: &quot;</span> + numbers.last()); <span class="hljs-comment">// 8</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>TreeMap 基本用法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.TreeMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeMapExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, Integer&gt; scores = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        scores.put(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">95</span>);<br>        scores.put(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">87</span>);<br>        scores.put(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">92</span>);<br>        scores.put(<span class="hljs-string">&quot;David&quot;</span>, <span class="hljs-number">88</span>);<br>        <br>        <span class="hljs-comment">// 按键自动排序输出</span><br>        System.out.println(scores);<br>        <span class="hljs-comment">// &#123;Alice=95, Bob=87, Charlie=92, David=88&#125;</span><br>        <br>        <span class="hljs-comment">// 范围查询：获取键在&quot;Bob&quot;到&quot;David&quot;之间的条目</span><br>        Map&lt;String, Integer&gt; subMap = scores.subMap(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;David&quot;</span>);<br>        System.out.println(subMap); <span class="hljs-comment">// &#123;Bob=87, Charlie=92&#125;</span><br>        <br>        <span class="hljs-comment">// 获取第一个和最后一个键</span><br>        System.out.println(<span class="hljs-string">&quot;First key: &quot;</span> + scores.firstKey()); <span class="hljs-comment">// Alice</span><br>        System.out.println(<span class="hljs-string">&quot;Last key: &quot;</span> + scores.lastKey()); <span class="hljs-comment">// David</span><br>        <br>        <span class="hljs-comment">// 获取大于等于&quot;Charlie&quot;的所有条目</span><br>        Map&lt;String, Integer&gt; tailMap = scores.tailMap(<span class="hljs-string">&quot;Charlie&quot;</span>);<br>        System.out.println(tailMap); <span class="hljs-comment">// &#123;Charlie=92, David=88&#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>自定义排序：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.TreeSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomSortExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 降序排序</span><br>        TreeSet&lt;Integer&gt; descendingNumbers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<br>            Comparator.reverseOrder()<br>        );<br>        descendingNumbers.add(<span class="hljs-number">5</span>);<br>        descendingNumbers.add(<span class="hljs-number">2</span>);<br>        descendingNumbers.add(<span class="hljs-number">8</span>);<br>        <br>        System.out.println(descendingNumbers); <span class="hljs-comment">// [8, 5, 2]</span><br>        <br>        <span class="hljs-comment">// 按字符串长度排序</span><br>        TreeSet&lt;String&gt; byLength = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(<br>            Comparator.comparingInt(String::length)<br>        );<br>        byLength.add(<span class="hljs-string">&quot;apple&quot;</span>);<br>        byLength.add(<span class="hljs-string">&quot;banana&quot;</span>);<br>        byLength.add(<span class="hljs-string">&quot;pear&quot;</span>);<br>        byLength.add(<span class="hljs-string">&quot;kiwi&quot;</span>);<br>        <br>        System.out.println(byLength); <span class="hljs-comment">// [pear, kiwi, apple, banana]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-2-treeset-treemap-应用场景">5.2 TreeSet/TreeMap 应用场景</h3>
<p><strong>排行榜实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.TreeSet;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Player</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;Player&gt; &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Player</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Player other)</span> &#123;<br>        <span class="hljs-comment">// 分数降序排序</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">scoreCompare</span> <span class="hljs-operator">=</span> Integer.compare(other.score, <span class="hljs-built_in">this</span>.score);<br>        <span class="hljs-keyword">if</span> (scoreCompare != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> scoreCompare;<br>        &#125;<br>        <span class="hljs-comment">// 分数相同则按名字升序</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.compareTo(other.name);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;: &quot;</span> + score;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LeaderboardExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TreeSet&lt;Player&gt; leaderboard = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;();<br>        <br>        leaderboard.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">95</span>));<br>        leaderboard.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">87</span>));<br>        leaderboard.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">95</span>));<br>        leaderboard.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-string">&quot;David&quot;</span>, <span class="hljs-number">88</span>));<br>        <br>        <span class="hljs-comment">// 输出排行榜（自动排序）</span><br>        System.out.println(<span class="hljs-string">&quot;=== 排行榜 ===&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rank</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (Player player : leaderboard) &#123;<br>            System.out.println(rank + <span class="hljs-string">&quot;. &quot;</span> + player);<br>            rank++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 获取前3名</span><br>        System.out.println(<span class="hljs-string">&quot;\n=== 前3名 ===&quot;</span>);<br>        TreeSet&lt;Player&gt; top3 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeSet</span>&lt;&gt;(leaderboard);<br>        <span class="hljs-keyword">while</span> (top3.size() &gt; <span class="hljs-number">3</span>) &#123;<br>            top3.pollLast();<br>        &#125;<br>        rank = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (Player player : top3) &#123;<br>            System.out.println(rank + <span class="hljs-string">&quot;. &quot;</span> + player);<br>            rank++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 查询分数在90分以上的玩家</span><br>        System.out.println(<span class="hljs-string">&quot;\n=== 90分以上 ===&quot;</span>);<br>        <span class="hljs-type">Player</span> <span class="hljs-variable">threshold</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Player</span>(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">90</span>);<br>        <span class="hljs-keyword">for</span> (Player player : leaderboard) &#123;<br>            <span class="hljs-keyword">if</span> (player.compareTo(threshold) &gt;= <span class="hljs-number">0</span>) &#123;<br>                System.out.println(player);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>区间查询应用：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.TreeMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriceRangeQuery</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        TreeMap&lt;Integer, String&gt; products = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TreeMap</span>&lt;&gt;();<br>        products.put(<span class="hljs-number">100</span>, <span class="hljs-string">&quot;Product A&quot;</span>);<br>        products.put(<span class="hljs-number">250</span>, <span class="hljs-string">&quot;Product B&quot;</span>);<br>        products.put(<span class="hljs-number">500</span>, <span class="hljs-string">&quot;Product C&quot;</span>);<br>        products.put(<span class="hljs-number">800</span>, <span class="hljs-string">&quot;Product D&quot;</span>);<br>        products.put(<span class="hljs-number">1200</span>, <span class="hljs-string">&quot;Product E&quot;</span>);<br>        <br>        <span class="hljs-comment">// 查询价格在200到600之间的产品</span><br>        System.out.println(<span class="hljs-string">&quot;=== 价格区间 200-600 ===&quot;</span>);<br>        Map&lt;Integer, String&gt; rangeProducts = products.subMap(<span class="hljs-number">200</span>, <span class="hljs-number">600</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : rangeProducts.entrySet()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;¥&quot;</span> + entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>        &#125;<br>        <br>        <span class="hljs-comment">// 查询价格大于等于500的产品</span><br>        System.out.println(<span class="hljs-string">&quot;\n=== 价格 &gt;= 500 ===&quot;</span>);<br>        Map&lt;Integer, String&gt; expensiveProducts = products.tailMap(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : expensiveProducts.entrySet()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;¥&quot;</span> + entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>        &#125;<br>        <br>        <span class="hljs-comment">// 查询价格小于500的产品</span><br>        System.out.println(<span class="hljs-string">&quot;\n=== 价格 &lt; 500 ===&quot;</span>);<br>        Map&lt;Integer, String&gt; cheapProducts = products.headMap(<span class="hljs-number">500</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : cheapProducts.entrySet()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;¥&quot;</span> + entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>🔑 <strong>模式提炼：</strong> 自动排序数据结构适用于需要维护有序状态、频繁范围查询的场景。红黑树保证 O(log n) 的操作复杂度，但插入和删除性能低于哈希表。</p>
<h3 id="5-3-copyonwritearraylist">5.3 CopyOnWriteArrayList</h3>
<p>CopyOnWriteArrayList 采用写时复制策略，保证读操作的无锁性和强一致性。写操作时会创建底层数组的新副本，修改完成后原子性地替换引用。</p>
<p><strong>基本用法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CopyOnWriteExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C&quot;</span>);<br>        <br>        <span class="hljs-comment">// 读操作无需加锁</span><br>        <span class="hljs-keyword">for</span> (String item : list) &#123;<br>            System.out.println(item);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 写操作会复制整个数组</span><br>        list.add(<span class="hljs-string">&quot;D&quot;</span>);<br>        <br>        <span class="hljs-comment">// 迭代器遍历</span><br>        Iterator&lt;String&gt; iterator = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> iterator.next();<br>            System.out.println(item);<br>            <span class="hljs-comment">// iterator.remove() 会抛出 UnsupportedOperationException</span><br>            <span class="hljs-comment">// iterator.remove(); // ❌ 不支持</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>读一致性问题：</strong></p>
<p>CopyOnWriteArrayList 的迭代器基于创建时的数组快照，可能出现三种读不一致情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Iterator;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsistencyExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;A&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;B&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;C&quot;</span>);<br>        <br>        <span class="hljs-comment">// 情况1：迭代器创建后，其他线程修改列表，迭代器看不到新数据</span><br>        Iterator&lt;String&gt; iterator1 = list.iterator();<br>        list.add(<span class="hljs-string">&quot;D&quot;</span>); <span class="hljs-comment">// 迭代器1看不到&quot;D&quot;</span><br>        <br>        <span class="hljs-comment">// 情况2：迭代器遍历过程中，其他线程修改列表</span><br>        Iterator&lt;String&gt; iterator2 = list.iterator();<br>        <span class="hljs-keyword">while</span> (iterator2.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> iterator2.next();<br>            System.out.println(item);<br>            <span class="hljs-keyword">if</span> (item.equals(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>                list.add(<span class="hljs-string">&quot;E&quot;</span>); <span class="hljs-comment">// 迭代器2看不到&quot;E&quot;</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 情况3：多次获取迭代器，每次都是新的快照</span><br>        Iterator&lt;String&gt; iterator3a = list.iterator();<br>        list.add(<span class="hljs-string">&quot;F&quot;</span>);<br>        Iterator&lt;String&gt; iterator3b = list.iterator();<br>        <span class="hljs-comment">// iterator3a看不到&quot;F&quot;，iterator3b可以看到&quot;F&quot;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>适用场景：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.concurrent.CopyOnWriteArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EventListenerExample</span> &#123;<br>    <span class="hljs-comment">// 事件监听器列表：读多写少场景</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;EventListener&gt; listeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addListener</span><span class="hljs-params">(EventListener listener)</span> &#123;<br>        listeners.add(listener);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeListener</span><span class="hljs-params">(EventListener listener)</span> &#123;<br>        listeners.remove(listener);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 事件通知：频繁读操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">fireEvent</span><span class="hljs-params">(Event event)</span> &#123;<br>        <span class="hljs-keyword">for</span> (EventListener listener : listeners) &#123;<br>            listener.onEvent(event);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">interface</span> <span class="hljs-title class_">EventListener</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onEvent</span><span class="hljs-params">(Event event)</span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Event</span> &#123;<br>    <span class="hljs-keyword">private</span> String type;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Event</span><span class="hljs-params">(String type)</span> &#123;<br>        <span class="hljs-built_in">this</span>.type = type;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> type;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意事项：</strong></p>
<ol>
<li>迭代器的 <code>remove()</code> 方法会抛出 <code>UnsupportedOperationException</code></li>
<li>写操作会复制整个数组，内存开销较大</li>
<li>适用于读多写少、数据量不大的场景</li>
<li>不能保证实时一致性，只能保证最终一致性</li>
</ol>
<p>🔑 <strong>模式提炼：</strong> 写时复制适用于读多写少、数据量小的场景。通过空间换时间，实现读操作的无锁强一致性，但写操作性能较差且内存开销大。</p>
<h3 id="5-4-concurrentskiplistset-map">5.4 ConcurrentSkipListSet/Map</h3>
<p>ConcurrentSkipListSet 和 ConcurrentSkipListMap 基于跳表结构实现，提供 O(log n) 时间复杂度的有序操作，并保证线程安全。</p>
<p><strong>跳表结构：</strong></p>
<p>跳表是一种多层链表结构，通过索引层加速查找。底层链表包含所有元素，上层链表作为索引，通过&quot;跳跃&quot;快速定位目标元素。</p>
<p><strong>ConcurrentSkipListSet 基本用法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentSkipListSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentSkipListSetExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ConcurrentSkipListSet&lt;Integer&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListSet</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 并发添加元素</span><br>        set.add(<span class="hljs-number">5</span>);<br>        set.add(<span class="hljs-number">2</span>);<br>        set.add(<span class="hljs-number">8</span>);<br>        set.add(<span class="hljs-number">1</span>);<br>        set.add(<span class="hljs-number">3</span>);<br>        <br>        <span class="hljs-comment">// 自动排序输出</span><br>        System.out.println(set); <span class="hljs-comment">// [1, 2, 3, 5, 8]</span><br>        <br>        <span class="hljs-comment">// 范围查询</span><br>        System.out.println(<span class="hljs-string">&quot;tailSet(3): &quot;</span> + set.tailSet(<span class="hljs-number">3</span>)); <span class="hljs-comment">// [3, 5, 8]</span><br>        System.out.println(<span class="hljs-string">&quot;headSet(5): &quot;</span> + set.headSet(<span class="hljs-number">5</span>)); <span class="hljs-comment">// [1, 2, 3]</span><br>        <br>        <span class="hljs-comment">// 并发删除</span><br>        set.remove(<span class="hljs-number">5</span>);<br>        System.out.println(<span class="hljs-string">&quot;After remove(5): &quot;</span> + set); <span class="hljs-comment">// [1, 2, 3, 8]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>ConcurrentSkipListMap 基本用法：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentSkipListMapExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Map&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 并发添加键值对</span><br>        map.put(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">95</span>);<br>        map.put(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-number">87</span>);<br>        map.put(<span class="hljs-string">&quot;Charlie&quot;</span>, <span class="hljs-number">92</span>);<br>        map.put(<span class="hljs-string">&quot;David&quot;</span>, <span class="hljs-number">88</span>);<br>        <br>        <span class="hljs-comment">// 按键自动排序</span><br>        System.out.println(map);<br>        <span class="hljs-comment">// &#123;Alice=95, Bob=87, Charlie=92, David=88&#125;</span><br>        <br>        <span class="hljs-comment">// 范围查询</span><br>        Map&lt;String, Integer&gt; subMap = map.subMap(<span class="hljs-string">&quot;Bob&quot;</span>, <span class="hljs-string">&quot;David&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;subMap: &quot;</span> + subMap); <span class="hljs-comment">// &#123;Bob=87, Charlie=92&#125;</span><br>        <br>        <span class="hljs-comment">// 获取第一个和最后一个键</span><br>        System.out.println(<span class="hljs-string">&quot;firstKey: &quot;</span> + map.firstKey()); <span class="hljs-comment">// Alice</span><br>        System.out.println(<span class="hljs-string">&quot;lastKey: &quot;</span> + map.lastKey()); <span class="hljs-comment">// David</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-5-concurrentskiplistmap-应用">5.5 ConcurrentSkipListMap 应用</h3>
<p><strong>高并发排行榜实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentPlayer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span>&lt;ConcurrentPlayer&gt; &#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> score;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConcurrentPlayer</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getScore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> score;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setScore</span><span class="hljs-params">(<span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-built_in">this</span>.score = score;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(ConcurrentPlayer other)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">scoreCompare</span> <span class="hljs-operator">=</span> Integer.compare(other.score, <span class="hljs-built_in">this</span>.score);<br>        <span class="hljs-keyword">if</span> (scoreCompare != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> scoreCompare;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name.compareTo(other.name);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> name + <span class="hljs-string">&quot;: &quot;</span> + score;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConcurrentLeaderboard</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentSkipListMap&lt;ConcurrentPlayer, String&gt; leaderboard = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateScore</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> score)</span> &#123;<br>        <span class="hljs-type">ConcurrentPlayer</span> <span class="hljs-variable">player</span> <span class="hljs-operator">=</span> findPlayer(name);<br>        <span class="hljs-keyword">if</span> (player != <span class="hljs-literal">null</span>) &#123;<br>            leaderboard.remove(player);<br>            player.setScore(score);<br>            leaderboard.put(player, <span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            leaderboard.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentPlayer</span>(name, score), <span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> ConcurrentPlayer <span class="hljs-title function_">findPlayer</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">for</span> (ConcurrentPlayer player : leaderboard.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (player.getName().equals(name)) &#123;<br>                <span class="hljs-keyword">return</span> player;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">printTopN</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;=== Top &quot;</span> + n + <span class="hljs-string">&quot; ===&quot;</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rank</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (ConcurrentPlayer player : leaderboard.keySet()) &#123;<br>            <span class="hljs-keyword">if</span> (rank &gt; n) <span class="hljs-keyword">break</span>;<br>            System.out.println(rank + <span class="hljs-string">&quot;. &quot;</span> + player);<br>            rank++;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ConcurrentLeaderboard</span> <span class="hljs-variable">leaderboard</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLeaderboard</span>();<br>        <br>        <span class="hljs-comment">// 并发更新分数</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> i;<br>            executor.submit(() -&gt; &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Player&quot;</span> + (index % <span class="hljs-number">10</span>);<br>                <span class="hljs-type">int</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (Math.random() * <span class="hljs-number">100</span>);<br>                leaderboard.updateScore(name, score);<br>            &#125;);<br>        &#125;<br>        <br>        executor.shutdown();<br>        executor.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        <br>        leaderboard.printTopN(<span class="hljs-number">5</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>时间窗口查询：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentSkipListMap;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeWindowQuery</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentSkipListMap&lt;LocalDateTime, String&gt; events = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addEvent</span><span class="hljs-params">(LocalDateTime time, String event)</span> &#123;<br>        events.put(time, event);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Map&lt;LocalDateTime, String&gt; <span class="hljs-title function_">getEventsInWindow</span><span class="hljs-params">(</span><br><span class="hljs-params">            LocalDateTime start, LocalDateTime end)</span> &#123;<br>        <span class="hljs-keyword">return</span> events.subMap(start, end);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Map&lt;LocalDateTime, String&gt; <span class="hljs-title function_">getEventsAfter</span><span class="hljs-params">(LocalDateTime time)</span> &#123;<br>        <span class="hljs-keyword">return</span> events.tailMap(time);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> Map&lt;LocalDateTime, String&gt; <span class="hljs-title function_">getEventsBefore</span><span class="hljs-params">(LocalDateTime time)</span> &#123;<br>        <span class="hljs-keyword">return</span> events.headMap(time);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">TimeWindowQuery</span> <span class="hljs-variable">query</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeWindowQuery</span>();<br>        <br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        query.addEvent(now.minusHours(<span class="hljs-number">2</span>), <span class="hljs-string">&quot;Event 2 hours ago&quot;</span>);<br>        query.addEvent(now.minusHours(<span class="hljs-number">1</span>), <span class="hljs-string">&quot;Event 1 hour ago&quot;</span>);<br>        query.addEvent(now.minusMinutes(<span class="hljs-number">30</span>), <span class="hljs-string">&quot;Event 30 minutes ago&quot;</span>);<br>        query.addEvent(now, <span class="hljs-string">&quot;Event now&quot;</span>);<br>        <br>        <span class="hljs-comment">// 查询最近1小时的事件</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">oneHourAgo</span> <span class="hljs-operator">=</span> now.minusHours(<span class="hljs-number">1</span>);<br>        Map&lt;LocalDateTime, String&gt; recentEvents = <br>            query.getEventsAfter(oneHourAgo);<br>        <br>        System.out.println(<span class="hljs-string">&quot;=== Events in last hour ===&quot;</span>);<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;LocalDateTime, String&gt; entry : recentEvents.entrySet()) &#123;<br>            System.out.println(entry.getKey() + <span class="hljs-string">&quot;: &quot;</span> + entry.getValue());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>性能特点对比：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ConcurrentSkipListMap</th>
<th>TreeMap</th>
<th>ConcurrentHashMap</th>
</tr>
</thead>
<tbody>
<tr>
<td>线程安全</td>
<td>是</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>有序性</td>
<td>是（自然排序）</td>
<td>是（自然排序）</td>
<td>否</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>O(log n)</td>
<td>O(log n)</td>
<td>O(1) 平均</td>
</tr>
<tr>
<td>内存开销</td>
<td>较高</td>
<td>较低</td>
<td>较低</td>
</tr>
<tr>
<td>适用场景</td>
<td>高并发有序数据</td>
<td>单线程有序数据</td>
<td>高并发无序数据</td>
</tr>
</tbody>
</table>
<p>🔑 <strong>模式提炼：</strong> 跳表结构提供有序且线程安全的集合操作，适用于高并发场景下的排行榜、时间窗口查询等需求。相比红黑树，跳表的实现更简单且支持无锁并发。</p>
<h2 id="第六章：缓存淘汰策略">第六章：缓存淘汰策略</h2>
<h3 id="6-1-lru-least-recently-used">6.1 LRU（Least Recently Used）</h3>
<p>LRU（Least Recently Used）是一种缓存淘汰策略，当缓存满时，优先淘汰最近最少使用的数据。核心思想是：最近被访问的数据将来被访问的概率更高。</p>
<p><strong>LinkedHashMap 实现 LRU：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LRUCache</span>&lt;K, V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LinkedHashMap</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxCapacity;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> maxCapacity)</span> &#123;<br>        <span class="hljs-built_in">super</span>(maxCapacity, <span class="hljs-number">0.75f</span>, <span class="hljs-literal">true</span>); <span class="hljs-comment">// accessOrder = true</span><br>        <span class="hljs-built_in">this</span>.maxCapacity = maxCapacity;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;K, V&gt; eldest)</span> &#123;<br>        <span class="hljs-keyword">return</span> size() &gt; maxCapacity;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LRUCache&lt;Integer, String&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LRUCache</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <br>        cache.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;One&quot;</span>);<br>        cache.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Two&quot;</span>);<br>        cache.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Three&quot;</span>);<br>        System.out.println(cache); <span class="hljs-comment">// &#123;1=One, 2=Two, 3=Three&#125;</span><br>        <br>        <span class="hljs-comment">// 访问 key 1，使其变为最近使用</span><br>        cache.get(<span class="hljs-number">1</span>);<br>        System.out.println(cache); <span class="hljs-comment">// &#123;2=Two, 3=Three, 1=One&#125;</span><br>        <br>        <span class="hljs-comment">// 添加新元素，淘汰最久未使用的 key 2</span><br>        cache.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Four&quot;</span>);<br>        System.out.println(cache); <span class="hljs-comment">// &#123;3=Three, 1=One, 4=Four&#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-2-lru-手动实现">6.2 LRU 手动实现</h3>
<p>手动实现 LRU 需要结合 HashMap 的 O(1) 查询特性和双向链表的维护顺序能力。</p>
<p><strong>完整实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ManualLRUCache</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, Node&lt;K, V&gt;&gt; cache;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K, V&gt; head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node&lt;K, V&gt; tail;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; &#123;<br>        K key;<br>        V value;<br>        Node&lt;K, V&gt; prev;<br>        Node&lt;K, V&gt; next;<br>        <br>        Node(K key, V value) &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ManualLRUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 哨兵节点，简化边界处理</span><br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        <span class="hljs-built_in">this</span>.tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        head.next = tail;<br>        tail.prev = head;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;<br>        Node&lt;K, V&gt; node = cache.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 访问后移动到尾部（最近使用）</span><br>        moveToTail(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        Node&lt;K, V&gt; node = cache.get(key);<br>        <br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 更新现有节点</span><br>            node.value = value;<br>            moveToTail(node);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 创建新节点</span><br>            Node&lt;K, V&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(key, value);<br>            cache.put(key, newNode);<br>            addToTail(newNode);<br>            <br>            <span class="hljs-comment">// 检查是否需要淘汰</span><br>            <span class="hljs-keyword">if</span> (cache.size() &gt; capacity) &#123;<br>                Node&lt;K, V&gt; lru = removeHead();<br>                cache.remove(lru.key);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">moveToTail</span><span class="hljs-params">(Node&lt;K, V&gt; node)</span> &#123;<br>        removeNode(node);<br>        addToTail(node);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeNode</span><span class="hljs-params">(Node&lt;K, V&gt; node)</span> &#123;<br>        node.prev.next = node.next;<br>        node.next.prev = node.prev;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addToTail</span><span class="hljs-params">(Node&lt;K, V&gt; node)</span> &#123;<br>        node.prev = tail.prev;<br>        node.next = tail;<br>        tail.prev.next = node;<br>        tail.prev = node;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Node&lt;K, V&gt; <span class="hljs-title function_">removeHead</span><span class="hljs-params">()</span> &#123;<br>        Node&lt;K, V&gt; node = head.next;<br>        removeNode(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        sb.append(<span class="hljs-string">&quot;[&quot;</span>);<br>        Node&lt;K, V&gt; node = head.next;<br>        <span class="hljs-keyword">while</span> (node != tail) &#123;<br>            sb.append(node.key).append(<span class="hljs-string">&quot;=&quot;</span>).append(node.value);<br>            <span class="hljs-keyword">if</span> (node.next != tail) &#123;<br>                sb.append(<span class="hljs-string">&quot;, &quot;</span>);<br>            &#125;<br>            node = node.next;<br>        &#125;<br>        sb.append(<span class="hljs-string">&quot;]&quot;</span>);<br>        <span class="hljs-keyword">return</span> sb.toString();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        ManualLRUCache&lt;Integer, String&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ManualLRUCache</span>&lt;&gt;(<span class="hljs-number">3</span>);<br>        <br>        cache.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;One&quot;</span>);<br>        cache.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Two&quot;</span>);<br>        cache.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Three&quot;</span>);<br>        System.out.println(cache); <span class="hljs-comment">// [1=One, 2=Two, 3=Three]</span><br>        <br>        cache.get(<span class="hljs-number">1</span>);<br>        System.out.println(cache); <span class="hljs-comment">// [2=Two, 3=Three, 1=One]</span><br>        <br>        cache.put(<span class="hljs-number">4</span>, <span class="hljs-string">&quot;Four&quot;</span>);<br>        System.out.println(cache); <span class="hljs-comment">// [3=Three, 1=One, 4=Four]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-3-lfu-least-frequently-used">6.3 LFU（Least Frequently Used）</h3>
<p>LFU（Least Frequently Used）淘汰策略优先淘汰访问频率最低的数据。相比 LRU，LFU 需要维护每个键的访问频率。</p>
<p><strong>完整实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.HashSet;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.Set;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LFUCache</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> minFrequency;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K, Node&lt;K, V&gt;&gt; keyToNode;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Set&lt;Node&lt;K, V&gt;&gt;&gt; frequencyToKeys;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;K, V&gt; &#123;<br>        K key;<br>        V value;<br>        <span class="hljs-type">int</span> frequency;<br>        <br>        Node(K key, V value) &#123;<br>            <span class="hljs-built_in">this</span>.key = key;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.frequency = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LFUCache</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>        <span class="hljs-built_in">this</span>.minFrequency = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">this</span>.keyToNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <span class="hljs-built_in">this</span>.frequencyToKeys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;<br>        Node&lt;K, V&gt; node = keyToNode.get(key);<br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 更新频率</span><br>        updateFrequency(node);<br>        <span class="hljs-keyword">return</span> node.value;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (capacity &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        Node&lt;K, V&gt; node = keyToNode.get(key);<br>        <br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 更新现有节点</span><br>            node.value = value;<br>            updateFrequency(node);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 创建新节点</span><br>            <span class="hljs-keyword">if</span> (keyToNode.size() &gt;= capacity) &#123;<br>                <span class="hljs-comment">// 淘汰频率最低的节点</span><br>                evict();<br>            &#125;<br>            <br>            Node&lt;K, V&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(key, value);<br>            keyToNode.put(key, newNode);<br>            minFrequency = <span class="hljs-number">1</span>;<br>            frequencyToKeys.computeIfAbsent(<span class="hljs-number">1</span>, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;()).add(newNode);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">updateFrequency</span><span class="hljs-params">(Node&lt;K, V&gt; node)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldFreq</span> <span class="hljs-operator">=</span> node.frequency;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newFreq</span> <span class="hljs-operator">=</span> oldFreq + <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 从旧频率集合中移除</span><br>        Set&lt;Node&lt;K, V&gt;&gt; oldSet = frequencyToKeys.get(oldFreq);<br>        oldSet.remove(node);<br>        <br>        <span class="hljs-comment">// 如果旧频率集合为空且是最小频率，更新 minFrequency</span><br>        <span class="hljs-keyword">if</span> (oldSet.isEmpty() &amp;&amp; oldFreq == minFrequency) &#123;<br>            minFrequency++;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 添加到新频率集合</span><br>        node.frequency = newFreq;<br>        frequencyToKeys.computeIfAbsent(newFreq, k -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;()).add(node);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">evict</span><span class="hljs-params">()</span> &#123;<br>        Set&lt;Node&lt;K, V&gt;&gt; minFreqSet = frequencyToKeys.get(minFrequency);<br>        Node&lt;K, V&gt; nodeToRemove = minFreqSet.iterator().next();<br>        <br>        minFreqSet.remove(nodeToRemove);<br>        keyToNode.remove(nodeToRemove.key);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> keyToNode.toString();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        LFUCache&lt;Integer, String&gt; cache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LFUCache</span>&lt;&gt;(<span class="hljs-number">2</span>);<br>        <br>        cache.put(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;One&quot;</span>);<br>        cache.put(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;Two&quot;</span>);<br>        System.out.println(cache);<br>        <br>        cache.get(<span class="hljs-number">1</span>); <span class="hljs-comment">// 频率：1-&gt;2</span><br>        cache.get(<span class="hljs-number">1</span>); <span class="hljs-comment">// 频率：2-&gt;3</span><br>        cache.get(<span class="hljs-number">2</span>); <span class="hljs-comment">// 频率：1-&gt;2</span><br>        <br>        cache.put(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;Three&quot;</span>); <span class="hljs-comment">// 淘汰 key 2（频率2）</span><br>        System.out.println(cache); <span class="hljs-comment">// &#123;1=One (freq=3), 3=Three (freq=1)&#125;</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-4-redis-近似-lru">6.4 Redis 近似 LRU</h3>
<p>Redis 的 LRU 实现是近似的，而非精确的。原因在于维护精确的 LRU 链表需要额外的内存开销。</p>
<p><strong>24 位访问时间：</strong></p>
<p>Redis 在对象结构中维护一个 24 位的 LRU 时钟，记录对象的最后访问时间。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Redis 对象结构（简化版）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;        <span class="hljs-comment">// 对象类型</span><br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;    <span class="hljs-comment">// 编码方式</span><br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;  <span class="hljs-comment">// 24位 LRU 时间</span><br>    <span class="hljs-type">int</span> refcount;           <span class="hljs-comment">// 引用计数</span><br>    <span class="hljs-type">void</span> *ptr;              <span class="hljs-comment">// 指向底层数据结构的指针</span><br>&#125; robj;<br></code></pre></td></tr></table></figure>
<p><strong>随机采样策略：</strong></p>
<p>当需要淘汰数据时，Redis 随机采样 N 个 key（默认 5 个），从中选择 LRU 值最大的 key 进行淘汰。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Redis 近似 LRU 淘汰算法（简化版）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">evictionPoolPopulate</span><span class="hljs-params">(dict *masterDict, dict *evictionDict)</span> &#123;<br>    <span class="hljs-type">int</span> samples = server.maxmemory_samples; <span class="hljs-comment">// 默认 5</span><br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; samples; k++) &#123;<br>        <span class="hljs-comment">// 随机选择一个 key</span><br>        sds key = dictGetRandomKey(masterDict);<br>        robj *o = dictGetVal(key);<br>        <br>        <span class="hljs-comment">// 计算 idle 时间</span><br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> idle = estimateObjectIdleTime(o);<br>        <br>        <span class="hljs-comment">// 将 key 加入候选池</span><br>        addToEvictionPool(o, idle);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 从候选池中选择 idle 时间最长的 key</span><br>    <span class="hljs-keyword">return</span> selectBestEvictionCandidate();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-5-redis-近似-lfu-4-0">6.5 Redis 近似 LFU（4.0+）</h3>
<p>Redis 4.0 引入了 LFU 淘汰策略，使用 8 位的 Morris Counter 来记录访问频率，并引入频率衰减机制。</p>
<p><strong>8 位 Morris Counter：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">redisObject</span> &#123;</span><br>    <span class="hljs-type">unsigned</span> type:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> encoding:<span class="hljs-number">4</span>;<br>    <span class="hljs-type">unsigned</span> lru:LRU_BITS;  <span class="hljs-comment">// LFU 模式下，高16位为时间，低8位为频率</span><br>    <span class="hljs-type">int</span> refcount;<br>    <span class="hljs-type">void</span> *ptr;<br>&#125; robj;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> LFU_BITS 8</span><br></code></pre></td></tr></table></figure>
<p><strong>频率衰减：</strong></p>
<p>为了避免历史访问频率影响新数据的淘汰，LFU 使用衰减算法定期降低所有 key 的频率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// LFU 频率更新（简化版）</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">updateLFU</span><span class="hljs-params">(robj *o)</span> &#123;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> ldt = o-&gt;lru &gt;&gt; <span class="hljs-number">8</span>;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> counter = o-&gt;lru &amp; <span class="hljs-number">255</span>;<br>    <br>    <span class="hljs-comment">// 计算衰减</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> num_periods = server.unixtime - ldt;<br>    <span class="hljs-keyword">if</span> (num_periods &gt; LFU_DECAY_TIME) &#123;<br>        counter = counter &gt;&gt; num_periods;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 频率递增</span><br>    counter = lfuLogIncr(counter);<br>    o-&gt;lru = (ldt &lt;&lt; <span class="hljs-number">8</span>) | counter;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-6-redis-7-0-listpack-改进">6.6 Redis 7.0 listpack 改进</h3>
<p>Redis 7.0 引入 listpack 替代 ziplist，用于小集合和有序集合，消除了连锁更新的问题。</p>
<p><strong>listpack 结构：</strong></p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<br>| HEAD | ENTRY| <span class="hljs-string">...</span>      | ENTRY   | END  | TAIL |<br>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">----------</span>+<span class="hljs-params">------</span>+<span class="hljs-params">------</span>+<br></code></pre></td></tr></table></figure>
<p><strong>优势：</strong></p>
<ul>
<li>消除了连锁更新风险（ziplist 的缺陷）</li>
<li>节省内存</li>
<li>提高插入删除性能</li>
</ul>
<p>🔑 <strong>模式提炼：</strong> 淘汰策略本质上是缩容机制。LRU 适合时序性强的访问模式，LFU 适合热点数据明显的场景。Redis 的近似实现通过随机采样和概率计数在性能和准确性之间取得平衡。</p>
<h2 id="第七章：系统级扩缩容">第七章：系统级扩缩容</h2>
<h3 id="7-1-stringbuilder-扩容">7.1 StringBuilder 扩容</h3>
<p>StringBuilder 内部使用字符数组存储字符串，当容量不足时会触发扩容。</p>
<p><strong>扩容机制：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StringBuilder 源码（简化版）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractStringBuilder</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">StringBuilder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(<span class="hljs-number">16</span>); <span class="hljs-comment">// 默认初始容量 16</span><br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> StringBuilder <span class="hljs-title function_">append</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-built_in">super</span>.append(str);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractStringBuilder</span> &#123;<br>    <span class="hljs-type">char</span>[] value;<br>    <span class="hljs-type">int</span> count;<br>    <br>    AbstractStringBuilder(<span class="hljs-type">int</span> capacity) &#123;<br>        value = <span class="hljs-keyword">new</span> <span class="hljs-title class_">char</span>[capacity];<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> AbstractStringBuilder <span class="hljs-title function_">append</span><span class="hljs-params">(String str)</span> &#123;<br>        <span class="hljs-keyword">if</span> (str == <span class="hljs-literal">null</span>) &#123;<br>            str = <span class="hljs-string">&quot;null&quot;</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> str.length();<br>        ensureCapacityInternal(count + len);<br>        str.getChars(<span class="hljs-number">0</span>, len, value, count);<br>        count += len;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-type">int</span> minimumCapacity)</span> &#123;<br>        <span class="hljs-keyword">if</span> (minimumCapacity - value.length &gt; <span class="hljs-number">0</span>) &#123;<br>            expandCapacity(minimumCapacity);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">expandCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minimumCapacity)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> value.length * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>; <span class="hljs-comment">// 2倍 + 2</span><br>        <span class="hljs-keyword">if</span> (newCapacity - minimumCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>            newCapacity = minimumCapacity;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (newCapacity &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>        &#125;<br>        value = Arrays.copyOf(value, newCapacity);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么 +2？</strong></p>
<p>扩容公式 <code>newCapacity = value.length * 2 + 2</code> 中的 +2 是为了处理边界情况：</p>
<ol>
<li>当初始容量为 0 时，扩容后容量为 2（0 * 2 + 2）</li>
<li>避免频繁扩容，提高性能</li>
<li>历史遗留设计，早期版本用于处理空字符串情况</li>
</ol>
<p><strong>Compact Strings 影响：</strong></p>
<p>Java 9 引入 Compact Strings 特性，StringBuilder 内部使用 <code>byte[]</code> 而非 <code>char[]</code> 来存储只包含 ASCII 字符的字符串，节省内存。</p>
<p><strong>最佳实践：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringBuilderBestPractice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 预估容量，避免频繁扩容</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(<span class="hljs-number">100</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            sb.append(<span class="hljs-string">&quot;Item &quot;</span>).append(i).append(<span class="hljs-string">&quot;\n&quot;</span>);<br>        &#125;<br>        <br>        System.out.println(sb.length());<br>        System.out.println(sb.capacity());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="7-2-线程池扩缩容">7.2 线程池扩缩容</h3>
<p>ThreadPoolExecutor 提供了灵活的线程池管理机制，支持动态扩容和缩容。</p>
<p><strong>核心参数：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">5</span>,                      <span class="hljs-comment">// corePoolSize：核心线程数</span><br>            <span class="hljs-number">10</span>,                     <span class="hljs-comment">// maximumPoolSize：最大线程数</span><br>            <span class="hljs-number">60L</span>,                    <span class="hljs-comment">// keepAliveTime：空闲线程存活时间</span><br>            TimeUnit.SECONDS,       <span class="hljs-comment">// 时间单位</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>), <span class="hljs-comment">// 工作队列</span><br>            Executors.defaultThreadFactory(), <span class="hljs-comment">// 线程工厂</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy() <span class="hljs-comment">// 拒绝策略</span><br>        );<br>        <br>        <span class="hljs-comment">// 提交任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            executor.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                    System.out.println(<span class="hljs-string">&quot;Task executed by: &quot;</span> + <br>                        Thread.currentThread().getName());<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>扩容流程：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs">任务提交<br>    ↓<br>核心线程数 &lt; corePoolSize?<br>    ├─ 是 → 创建新核心线程<br>    └─ 否 → 工作队列已满?<br>              ├─ 否 → 加入队列<br>              └─ 是 → 当前线程数 &lt; maximumPoolSize?<br>                      ├─ 是 → 创建非核心线程<br>                      └─ 否 → 执行拒绝策略<br></code></pre></td></tr></table></figure>
<p><strong>缩容机制：</strong></p>
<p>当非核心线程空闲时间超过 <code>keepAliveTime</code> 时，会被回收。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 动态调整线程池大小</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicThreadPool</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">2</span>, <span class="hljs-number">10</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>)<br>        );<br>        <br>        <span class="hljs-comment">// 提交任务触发扩容</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">15</span>; i++) &#123;<br>            executor.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                    System.out.println(<span class="hljs-string">&quot;Active threads: &quot;</span> + <br>                        executor.getActiveCount());<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <br>        System.out.println(<span class="hljs-string">&quot;Pool size: &quot;</span> + executor.getPoolSize());<br>        <br>        <span class="hljs-comment">// 等待任务完成，观察缩容</span><br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        System.out.println(<span class="hljs-string">&quot;Pool size after shrink: &quot;</span> + executor.getPoolSize());<br>        <br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>四种拒绝策略：</strong></p>
<table>
<thead>
<tr>
<th>策略</th>
<th>行为</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbortPolicy</td>
<td>抛出 RejectedExecutionException</td>
<td>需要明确感知任务被拒绝</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>由提交任务的线程执行</td>
<td>能够接受任务执行延迟</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>静默丢弃</td>
<td>允许丢失部分任务</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃队列中最老的任务</td>
<td>优先处理新任务</td>
</tr>
</tbody>
</table>
<p><strong>CallerRunsPolicy 隐含风险：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallerRunsRisk</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, TimeUnit.SECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()<br>        );<br>        <br>        <span class="hljs-comment">// 主线程提交任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;Task &quot;</span> + taskId + <span class="hljs-string">&quot; executed by: &quot;</span> + <br>                    Thread.currentThread().getName());<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>常见线程池配置：</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>corePoolSize</th>
<th>maximumPoolSize</th>
<th>队列类型</th>
<th>keepAliveTime</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU 密集型</td>
<td>CPU 核心数 + 1</td>
<td>CPU 核心数 + 1</td>
<td>SynchronousQueue</td>
<td>0</td>
</tr>
<tr>
<td>IO 密集型</td>
<td>CPU 核心数 * 2</td>
<td>CPU 核心数 * 2</td>
<td>LinkedBlockingQueue</td>
<td>60s</td>
</tr>
<tr>
<td>混合型</td>
<td>CPU 核心数</td>
<td>CPU 核心数 * 2</td>
<td>LinkedBlockingQueue</td>
<td>30s</td>
</tr>
</tbody>
</table>
<p><strong>动态调整代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DynamicAdjustment</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>)<br>        );<br>        <br>        <span class="hljs-comment">// 根据系统负载动态调整</span><br>        adjustThreadPoolSize(executor);<br>        <br>        executor.shutdown();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustThreadPoolSize</span><span class="hljs-params">(ThreadPoolExecutor executor)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">cpuCores</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br>        <span class="hljs-type">double</span> <span class="hljs-variable">loadAverage</span> <span class="hljs-operator">=</span> getSystemLoadAverage();<br>        <br>        <span class="hljs-keyword">if</span> (loadAverage &gt; cpuCores * <span class="hljs-number">0.8</span>) &#123;<br>            <span class="hljs-comment">// 高负载：减少线程数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">newSize</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">1</span>, cpuCores / <span class="hljs-number">2</span>);<br>            executor.setCorePoolSize(newSize);<br>            executor.setMaximumPoolSize(newSize * <span class="hljs-number">2</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (loadAverage &lt; cpuCores * <span class="hljs-number">0.3</span>) &#123;<br>            <span class="hljs-comment">// 低负载：增加线程数</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">newSize</span> <span class="hljs-operator">=</span> cpuCores * <span class="hljs-number">2</span>;<br>            executor.setCorePoolSize(newSize);<br>            executor.setMaximumPoolSize(newSize * <span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getSystemLoadAverage</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> ManagementFactory.getOperatingSystemMXBean()<br>            .getSystemLoadAverage();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="java-21-虚拟线程的影响">Java 21+ 虚拟线程的影响</h4>
<p>Java 21 引入的虚拟线程（Project Loom）彻底改变了线程池的设计假设。传统线程池的核心假设是&quot;线程是昂贵资源&quot;，因此需要复用线程来提高性能。虚拟线程使得线程创建成本极低，这一假设被打破。</p>
<p><strong>虚拟线程的特性</strong></p>
<p>虚拟线程是轻量级线程，由 JVM 管理，不直接映射到操作系统线程。其特点包括：</p>
<ul>
<li>创建成本低：可以轻松创建数百万个虚拟线程</li>
<li>内存占用小：每个虚拟线程仅占用几百字节</li>
<li>阻塞不阻塞平台线程：虚拟线程阻塞时，平台线程可以执行其他虚拟线程</li>
</ul>
<p><strong>传统线程池 vs 虚拟线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.stream.IntStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadComparison</span> &#123;<br>    <br>    <span class="hljs-comment">// 传统线程池：固定大小线程池</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traditionalThreadPool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1000</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 模拟 IO 操作</span><br>                    System.out.println(<span class="hljs-string">&quot;Task &quot;</span> + taskId + <span class="hljs-string">&quot; completed&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    latch.countDown();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <br>        latch.await();<br>        executor.shutdown();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - startTime;<br>        System.out.println(<span class="hljs-string">&quot;Traditional thread pool duration: &quot;</span> + duration + <span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 虚拟线程：每个任务一个虚拟线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">virtualThreadPerTask</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor();<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1000</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 模拟 IO 操作</span><br>                    System.out.println(<span class="hljs-string">&quot;Task &quot;</span> + taskId + <span class="hljs-string">&quot; completed&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    latch.countDown();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <br>        latch.await();<br>        executor.shutdown();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - startTime;<br>        System.out.println(<span class="hljs-string">&quot;Virtual thread duration: &quot;</span> + duration + <span class="hljs-string">&quot;ms&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 虚拟线程：使用 try-with-resources 自动关闭</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">virtualThreadWithTryWithResources</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>            <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1000</span>);<br>            <br>            IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">1000</span>).forEach(i -&gt; &#123;<br>                executor.submit(() -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">100</span>);<br>                        System.out.println(<span class="hljs-string">&quot;Task &quot;</span> + i + <span class="hljs-string">&quot; completed&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        Thread.currentThread().interrupt();<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        latch.countDown();<br>                    &#125;<br>                &#125;);<br>            &#125;);<br>            <br>            latch.await();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        System.out.println(<span class="hljs-string">&quot;=== Traditional Thread Pool ===&quot;</span>);<br>        traditionalThreadPool();<br>        <br>        System.out.println(<span class="hljs-string">&quot;\n=== Virtual Thread Per Task ===&quot;</span>);<br>        virtualThreadPerTask();<br>        <br>        System.out.println(<span class="hljs-string">&quot;\n=== Virtual Thread with Try-With-Resources ===&quot;</span>);<br>        virtualThreadWithTryWithResources();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>虚拟线程的适用场景</strong></p>
<p>虚拟线程适用于 IO 密集型任务，不适合 CPU 密集型任务。</p>
<table>
<thead>
<tr>
<th>任务类型</th>
<th>适用线程池</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>IO 密集型（HTTP 请求、数据库查询）</td>
<td>虚拟线程</td>
<td>阻塞操作不会浪费平台线程资源</td>
</tr>
<tr>
<td>CPU 密集型（计算、数据处理）</td>
<td>平台线程池</td>
<td>需要绑定到 CPU 核心进行计算</td>
</tr>
<tr>
<td>混合型</td>
<td>分离使用</td>
<td>IO 操作用虚拟线程，计算用平台线程</td>
</tr>
</tbody>
</table>
<p><strong>虚拟线程与平台线程的混合使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HybridThreadUsage</span> &#123;<br>    <br>    <span class="hljs-comment">// 混合使用：IO 操作用虚拟线程，CPU 密集型任务用平台线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">hybridThreadPool</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// CPU 密集型任务的平台线程池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuExecutor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<br>            Runtime.getRuntime().availableProcessors()<br>        );<br>        <br>        <span class="hljs-comment">// IO 密集型任务的虚拟线程执行器</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ioExecutor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor();<br>        <br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">100</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            <br>            <span class="hljs-comment">// 虚拟线程处理 IO 操作</span><br>            ioExecutor.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 模拟 IO 操作</span><br>                    Thread.sleep(<span class="hljs-number">50</span>);<br>                    <br>                    <span class="hljs-comment">// 将 CPU 密集型任务提交到平台线程池</span><br>                    Future&lt;String&gt; result = cpuExecutor.submit(() -&gt; &#123;<br>                        <span class="hljs-keyword">return</span> performCPUIntensiveTask(taskId);<br>                    &#125;);<br>                    <br>                    System.out.println(<span class="hljs-string">&quot;Task &quot;</span> + taskId + <span class="hljs-string">&quot; result: &quot;</span> + result.get());<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    latch.countDown();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <br>        latch.await();<br>        <br>        ioExecutor.close();<br>        cpuExecutor.shutdown();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">performCPUIntensiveTask</span><span class="hljs-params">(<span class="hljs-type">int</span> taskId)</span> &#123;<br>        <span class="hljs-comment">// 模拟 CPU 密集型计算</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            result += Math.sqrt(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result-&quot;</span> + taskId + <span class="hljs-string">&quot;-&quot;</span> + result;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        hybridThreadPool();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>不要用虚拟线程执行 CPU 密集型任务</strong>：虚拟线程仍然需要平台线程执行 CPU 操作，不会带来性能提升</li>
<li><strong>不要在虚拟线程中使用 synchronized 锁</strong>：会钉住平台线程，影响性能。应该使用 java.util.concurrent 下的锁机制</li>
<li><strong>不要限制虚拟线程数量</strong>：虚拟线程设计初衷就是可以大量创建，不需要像传统线程池那样限制大小</li>
<li><strong>正确处理中断</strong>：虚拟线程的可中断性更强，需要正确处理 InterruptedException</li>
</ol>
<p>🔑 <strong>模式提炼：</strong> 虚拟线程打破了&quot;线程是昂贵资源&quot;的传统假设，使得&quot;每个任务一个线程&quot;成为可能。在 IO 密集型场景下，虚拟线程提供了更简单、更高效的并发编程模型。</p>
<h3 id="7-3-redis-渐进式-rehash">7.3 Redis 渐进式 Rehash</h3>
<p>Redis 的哈希表扩容采用渐进式 rehash 策略，避免一次性迁移导致的性能抖动。</p>
<p><strong>为什么需要渐进式？</strong></p>
<p>如果一次性迁移所有键值对，会导致：</p>
<ol>
<li>长时间阻塞主线程</li>
<li>响应延迟激增</li>
<li>可能触发超时</li>
</ol>
<p><strong>双哈希表结构：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Redis 字典结构（简化版）</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dict</span> &#123;</span><br>    dictht ht[<span class="hljs-number">2</span>];        <span class="hljs-comment">// 两个哈希表</span><br>    <span class="hljs-type">long</span> rehashidx;      <span class="hljs-comment">// rehash 索引，-1 表示未进行 rehash</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> iterators; <span class="hljs-comment">// 正在迭代的迭代器数量</span><br>&#125; dict;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictht</span> &#123;</span><br>    dictEntry **table;   <span class="hljs-comment">// 哈希表数组</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> size;  <span class="hljs-comment">// 哈希表大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> sizemask; <span class="hljs-comment">// 哈希表大小掩码</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> used;  <span class="hljs-comment">// 已有节点数量</span><br>&#125; dictht;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> &#123;</span><br>    <span class="hljs-type">void</span> *key;           <span class="hljs-comment">// 键</span><br>    <span class="hljs-class"><span class="hljs-keyword">union</span> &#123;</span><br>        <span class="hljs-type">void</span> *val;       <span class="hljs-comment">// 值</span><br>        <span class="hljs-type">uint64_t</span> u64;<br>        <span class="hljs-type">int64_t</span> s64;<br>    &#125; v;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dictEntry</span> *<span class="hljs-title">next</span>;</span> <span class="hljs-comment">// 下一个节点（链表解决冲突）</span><br>&#125; dictEntry;<br></code></pre></td></tr></table></figure>
<p><strong>渐进式 Rehash 流程：</strong></p>
<ol>
<li><strong>触发条件</strong>：负载因子 &gt; 1（或 &gt; 5 且无子进程）</li>
<li><strong>分配空间</strong>：为 ht[1] 分配新空间（大小为第一个大于等于 ht[0].used * 2 的 2^n）</li>
<li><strong>渐进迁移</strong>：
<ul>
<li>rehashidx 记录当前迁移进度</li>
<li>每次增删改查时，迁移一个 bucket</li>
<li>定时任务辅助迁移</li>
</ul>
</li>
<li><strong>完成迁移</strong>：ht[0] 清空，ht[1] 变为 ht[0]，ht[1] 重置</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Redis 渐进式 rehash（简化版）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">dictRehash</span><span class="hljs-params">(dict *d, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> empty_visits = n * <span class="hljs-number">10</span>; <span class="hljs-comment">// 最多访问 10n 个空 bucket</span><br>    <br>    <span class="hljs-keyword">while</span> (n-- &amp;&amp; d-&gt;ht[<span class="hljs-number">0</span>].used != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 跳过空 bucket</span><br>        <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx] == <span class="hljs-literal">NULL</span>) &#123;<br>            d-&gt;rehashidx++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 迁移当前 bucket 的所有节点</span><br>        dictEntry *de, *nextde;<br>        de = d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx];<br>        <br>        <span class="hljs-keyword">while</span> (de) &#123;<br>            nextde = de-&gt;next;<br>            <br>            <span class="hljs-comment">// 计算在新哈希表中的位置</span><br>            <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> h = dictHashKey(d, de-&gt;key) &amp; d-&gt;ht[<span class="hljs-number">1</span>].sizemask;<br>            <br>            <span class="hljs-comment">// 插入到新哈希表</span><br>            de-&gt;next = d-&gt;ht[<span class="hljs-number">1</span>].table[h];<br>            d-&gt;ht[<span class="hljs-number">1</span>].table[h] = de;<br>            <br>            d-&gt;ht[<span class="hljs-number">0</span>].used--;<br>            d-&gt;ht[<span class="hljs-number">1</span>].used++;<br>            de = nextde;<br>        &#125;<br>        <br>        d-&gt;ht[<span class="hljs-number">0</span>].table[d-&gt;rehashidx] = <span class="hljs-literal">NULL</span>;<br>        d-&gt;rehashidx++;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 检查是否完成</span><br>    <span class="hljs-keyword">if</span> (d-&gt;ht[<span class="hljs-number">0</span>].used == <span class="hljs-number">0</span>) &#123;<br>        zfree(d-&gt;ht[<span class="hljs-number">0</span>].table);<br>        d-&gt;ht[<span class="hljs-number">0</span>] = d-&gt;ht[<span class="hljs-number">1</span>];<br>        _dictReset(&amp;d-&gt;ht[<span class="hljs-number">1</span>]);<br>        d-&gt;rehashidx = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>定时辅助迁移：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// Redis 定时任务辅助 rehash（简化版）</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">incrementallyRehash</span><span class="hljs-params">(<span class="hljs-type">int</span> dbid)</span> &#123;<br>    dict *d = server.db[dbid].dict;<br>    <br>    <span class="hljs-keyword">if</span> (dictIsRehashing(d)) &#123;<br>        <span class="hljs-comment">// 每次迁移 100 个 bucket</span><br>        dictRehash(d, <span class="hljs-number">100</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>缩容触发条件：</strong></p>
<ol>
<li>负载因子 &lt; 0.1</li>
<li>无子进程执行</li>
<li>缩容后的容量 &gt;= 4</li>
</ol>
<p>🔑 <strong>模式提炼：</strong> 渐进式迁移通过将大任务拆分为小任务，避免长时间阻塞，适用于需要平滑过渡的场景。核心思想是：将一次性操作分散到多次操作中执行。</p>
<h2 id="第八章：扩缩容的通用设计模式">第八章：扩缩容的通用设计模式</h2>
<h3 id="8-1-数据结构衍生关系">8.1 数据结构衍生关系</h3>
<pre><code class="hljs mermaid">graph TD
    A[数组 Array] --&gt; B[ArrayList]
    A --&gt; C[HashMap]
    A --&gt; D[ArrayDeque]
    
    E[链表 LinkedList] --&gt; F[LRU Cache]
    
    C --&gt; G[LinkedHashMap]
    C --&gt; H[ConcurrentHashMap]
    C --&gt; I[HashSet]
    
    J[二叉搜索树 BST] --&gt; K[AVL Tree]
    J --&gt; L[红黑树 Red-Black Tree]
    L --&gt; M[TreeMap]
    L --&gt; N[TreeSet]
    
    O[堆 Heap] --&gt; P[PriorityQueue]
    
    Q[跳表 SkipList] --&gt; R[ConcurrentSkipListMap]
    Q --&gt; S[ConcurrentSkipListSet]
    Q --&gt; T[Redis ZSet]</code></pre>
<h3 id="8-2-模式一：倍增策略表">8.2 模式一：倍增策略表</h3>
<table>
<thead>
<tr>
<th>数据结构/系统</th>
<th>扩容因子</th>
<th>初始容量</th>
<th>特殊处理</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>1.5x</td>
<td>10</td>
<td>newCapacity = old + (old &gt;&gt; 1)</td>
</tr>
<tr>
<td>HashMap</td>
<td>2x</td>
<td>16</td>
<td>必须是 2 的幂次方</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>2x + 2</td>
<td>16</td>
<td>处理空数组边界</td>
</tr>
<tr>
<td>Redis</td>
<td>2x</td>
<td>4</td>
<td>必须是 2 的幂次方</td>
</tr>
<tr>
<td>Go slice</td>
<td>2x</td>
<td>0</td>
<td>容量 &lt; 1024 时 2x，否则 1.25x</td>
</tr>
</tbody>
</table>
<p><strong>倍增策略的优势：</strong></p>
<ol>
<li>均摊时间复杂度为 O(1)</li>
<li>减少扩容频率</li>
<li>内存利用率合理</li>
</ol>
<h3 id="8-3-模式二：渐进式迁移表">8.3 模式二：渐进式迁移表</h3>
<table>
<thead>
<tr>
<th>系统</th>
<th>迁移策略</th>
<th>触发时机</th>
<th>完成条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>Redis Rehash</td>
<td>每次操作迁移 1 个 bucket</td>
<td>负载因子 &gt; 1</td>
<td>ht[0].used == 0</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>分段迁移</td>
<td>节点数 &gt; 阈值</td>
<td>所有 segment 迁移完成</td>
</tr>
<tr>
<td>Elasticsearch Reindex</td>
<td>Scroll 批量迁移</td>
<td>索引重建</td>
<td>所有文档迁移完成</td>
</tr>
</tbody>
</table>
<p><strong>渐进式迁移的关键点：</strong></p>
<ol>
<li>维护新旧两个数据结构</li>
<li>每次操作迁移少量数据</li>
<li>读写操作同时访问新旧结构</li>
<li>迁移完成后切换引用</li>
</ol>
<h3 id="8-4-模式三：水位线触发表">8.4 模式三：水位线触发表</h3>
<table>
<thead>
<tr>
<th>系统</th>
<th>扩容水位线</th>
<th>缩容水位线</th>
<th>触发动作</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap</td>
<td>size &gt; capacity * loadFactor</td>
<td>不支持</td>
<td>2x 扩容</td>
</tr>
<tr>
<td>Redis</td>
<td>used &gt; size * loadFactor</td>
<td>used &lt; size * 0.1</td>
<td>2x 扩容 / 缩容</td>
</tr>
<tr>
<td>线程池</td>
<td>queue full &amp; size &lt; max</td>
<td>idle &gt; keepAliveTime</td>
<td>创建线程 / 回收线程</td>
</tr>
<tr>
<td>K8s HPA</td>
<td>CPU &gt; 80%</td>
<td>CPU &lt; 50%</td>
<td>增加副本 / 减少副本</td>
</tr>
</tbody>
</table>
<p><strong>水位线设计原则：</strong></p>
<ol>
<li>扩容水位线 &gt; 使用水位线，预留缓冲</li>
<li>缩容水位线 &lt; 扩容水位线，避免抖动</li>
<li>设置最小值和最大值，防止无限扩缩容</li>
</ol>
<h3 id="8-5-模式四：淘汰策略表">8.5 模式四：淘汰策略表</h3>
<table>
<thead>
<tr>
<th>策略</th>
<th>核心思想</th>
<th>时间复杂度</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>LRU</td>
<td>最近最少使用</td>
<td>O(1)（双向链表 + HashMap）</td>
<td>时序性强的访问模式</td>
</tr>
<tr>
<td>LFU</td>
<td>最少频率使用</td>
<td>O(1)（双 HashMap）</td>
<td>热点数据明显</td>
</tr>
<tr>
<td>FIFO</td>
<td>先进先出</td>
<td>O(1)（队列）</td>
<td>简单场景</td>
</tr>
<tr>
<td>Random</td>
<td>随机淘汰</td>
<td>O(1)</td>
<td>对淘汰精度要求不高</td>
</tr>
<tr>
<td>TTL</td>
<td>生存时间</td>
<td>O(log n)（时间轮）</td>
<td>有明确过期时间</td>
</tr>
</tbody>
</table>
<h2 id="总结">总结</h2>
<h3 id="总结对比表">总结对比表</h3>
<table>
<thead>
<tr>
<th>数据结构/系统</th>
<th>初始容量</th>
<th>扩容因子</th>
<th>缩容</th>
<th>特殊机制</th>
</tr>
</thead>
<tbody>
<tr>
<td>ArrayList</td>
<td>10</td>
<td>1.5x</td>
<td>不支持</td>
<td>trimToSize() 手动缩容</td>
</tr>
<tr>
<td>HashMap</td>
<td>16</td>
<td>2x</td>
<td>不支持</td>
<td>负载因子 0.75</td>
</tr>
<tr>
<td>StringBuilder</td>
<td>16</td>
<td>2x + 2</td>
<td>不支持</td>
<td>Compact Strings</td>
</tr>
<tr>
<td>Redis Dict</td>
<td>4</td>
<td>2x</td>
<td>支持（&lt; 0.1）</td>
<td>渐进式 Rehash</td>
</tr>
<tr>
<td>线程池</td>
<td>corePoolSize</td>
<td>maximumPoolSize</td>
<td>keepAliveTime</td>
<td>拒绝策略</td>
</tr>
<tr>
<td>ConcurrentSkipListMap</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>跳表结构</td>
</tr>
</tbody>
</table>
<h3 id="核心设计原则">核心设计原则</h3>
<ol>
<li><strong>预分配</strong>：合理设置初始容量，减少扩容次数</li>
<li><strong>均摊 O(1)</strong>：倍增策略保证均摊时间复杂度为 O(1)</li>
<li><strong>渐进式</strong>：将大任务拆分为小任务，避免阻塞</li>
<li><strong>水位线</strong>：设置合理的扩缩容阈值，避免抖动</li>
</ol>
<h3 id="模式速查表">模式速查表</h3>
<table>
<thead>
<tr>
<th>需求关键词</th>
<th>对应模式</th>
<th>方案</th>
<th>口诀</th>
</tr>
</thead>
<tbody>
<tr>
<td>高性能扩容</td>
<td>倍增策略</td>
<td>1.5x 或 2x 扩容</td>
<td>翻倍扩容，均摊 O(1)</td>
</tr>
<tr>
<td>避免阻塞</td>
<td>渐进式迁移</td>
<td>分批迁移，双结构</td>
<td>分批迁移，平滑过渡</td>
</tr>
<tr>
<td>动态调整</td>
<td>水位线触发</td>
<td>设置阈值，自动调整</td>
<td>高扩低缩，避免抖动</td>
</tr>
<tr>
<td>限制大小</td>
<td>淘汰策略</td>
<td>LRU/LFU/TTL</td>
<td>淘汰即缩容</td>
</tr>
</tbody>
</table>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk-21/src/java.base/share/classes/java/util/ArrayList.java">Java ArrayList 源码</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/openjdk/jdk/blob/jdk-21/src/java.base/share/classes/java/util/HashMap.java">Java HashMap 源码</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/redis/redis/blob/unstable/src/dict.c">Redis 源码 dict.c</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/collections/design.html">Collection Hierarchy</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2025/07/29/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/">https://magicliang.github.io/2025/07/29/Java-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/">系统设计</a><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-178.jpeg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-124.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2017/11/30/Java%E4%B8%AD%E7%9A%84%E5%B9%BD%E7%81%B5%E7%B1%BB%E5%9E%8B/" title="Java中的幽灵类型"><img class="cover" src="/img/wall-paper-163.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-30</div><div class="info-item-2">Java中的幽灵类型</div></div><div class="info-2"><div class="info-item-1">什么是幽灵类型 先上结论：幽灵类型（Phantom Type）顾名思义，就是幽灵般的类型，这种类型往往在运行时可以消失，因为在运行时没有任何作用，它们最大的特点就是没有任何实例（Java 的 Void 就是一个不可实例化类型的例子，常被用作幽灵类型的类型参数，如 Future&lt;Void&gt;）。幽灵类型是一种可以把有些运行时才能检测到的错误，在编译时检测出来的技巧。按照有些老外的观点，就是&quot;Making Wrong Code Look Wrong&quot;。在面向对象的编程语言之中，幽灵类型的实现，往往与状态模式较为接近，但比状态模式提供了更强的纠错功能。在 Java 5 以后的版本里，程序员可以使用泛型。通过泛型的类型参数，Java 中也拥有了幽灵类型的能力。 上面的阐述是不是很难看懂？直接进入具体的例子。假设有一个飞机控制程序，操作飞机起飞或者落地。这个程序有一个非常强的业务约束，就是必须保证飞机一开始必须出现在地上，只有在地上的飞机可以起飞，只有起飞的飞机可以落地，那么应该怎样设计程序（主要是类型关系），来保证这个约束必然成立呢？ 定义状态接口 先来定义...</div></div></div></a><a class="pagination-related" href="/2018/05/29/JPA-%E7%9A%84-id-%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/" title="JPA 的 id 生成策略"><img class="cover" src="/img/wall-paper-132.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-05-29</div><div class="info-item-2">JPA 的 id 生成策略</div></div><div class="info-2"><div class="info-item-1">JPA 有一个@GeneratedValue注解，有一个strategy attribute，如 @GeneratedValue(strategy = GenerationType.IDENTITY)。 常见的可选策略主要有IDENTITY和SEQUENCE。 GenerationType.IDENTITY 要求底层有一个 integer 或者 bigint 类型的自增列（ auto-incremented column)。自增列的赋值必须在插入操作之后发生，因为这个原因，Hibernate 无法进行各种优化（特别是 JDBC 的 batch 处理，一次 flush 操作会产生很多条insert 语句，分别执行）。如果事务回滚，自增列的值就会被丢弃。数据库在这个自增操作上有个高度优化的轻量级锁机制，性能非常棒。 MySQL 支持这种 id 生成策略， 使用 MySQL 应该尽量使用这个策略，即使它无法优化。 JPA 用它生成 id，会一条一条地插入新的 entity。 GenerationType.SEQUENCE 数据库有一个所谓的 sequence 对象，可以通过 selec...</div></div></div></a><a class="pagination-related" href="/2018/06/19/%E5%A6%82%E4%BD%95%E5%81%9A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8B%E7%9A%84%E7%AD%94%E6%A1%88/" title="如何做性能测试的问题下的答案"><img class="cover" src="/img/wall-paper-130.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-19</div><div class="info-item-2">如何做性能测试的问题下的答案</div></div><div class="info-2"><div class="info-item-1">试着回答一下这个问题。 首先要划分系统类型：有状态还是无状态，业务系统还是存储系统。根据不同的业务场景，设立性能测试的目标：是要测 QPS，还是 TPS 还是 TPS，还是任何其他【性能】-从广义来讲，一个存储系统到底能够以多高的平均时延来管理大多的存储空间，可能也是性能的一种。 有了性能测试的目标，接下来就是拆解用例。如果把性能测试归为测试的话，测试就需要测试用例，测试用例只是用例的形式化表达。把用户的使用场景勾勒出来，把每一步拆解成的流程图或者时序图–我们已经得到了一个纸上的集成测试计划，只是没有跟性能挂上钩。 接下来就进入真正写测试用例的环节了。 我们的测试报告如果要涵盖足够立体的信息，则既要了解每一个环节/接口/API 的性能指标，又要了解整体的性能指标。 这个时候测试工具的覆盖面就很重要了。如果我们选择偏黑盒的测试工具，apache ab /JMeter，则我们的测试用例就要围绕着对外交互的 API写，也只能测到外围接口的性能。这样的测试用例写起来最简单，无需侵入任何内部代码中。 如果我们使用了 JMH 一类的工具，则可以自由编写对任何方法的测试用例。但需要对系统有非常...</div></div></div></a><a class="pagination-related" href="/2018/09/07/%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/" title="日期与时间"><img class="cover" src="/img/wall-paper-76.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-09-07</div><div class="info-item-2">日期与时间</div></div><div class="info-2"><div class="info-item-1">JSR 310 Java Date与Time API 新旧 API 的更迭 旧的 Java API 主要包括java.util.Date和java.util.Calendar 两个包的内容。这两个包的时间类型是可变的。如 Date 的实例可以通过 setYear 来产生变化。 JSR 310 中包括的日期类型主要有：  计算机时间：Instant，对应 java.util.Date，它代表了一个确定的时间点，即相对于标准Java纪元（1970年1月1日）的偏移量；但与java.util.Date类不同的是其精确到了纳秒级别。 人类时间：对应于人类自身的观念，比如LocalDate和LocalTime。他们代表了一般的时区概念，要么是日期（不包含时间），要么是时间（不包含日期），类似于java.sql的表示方式。此外，还有一个MonthDay，它可以存储某人的生日（不包含年份）。每个类都在内部存储正确的数据而不是像java.util.Date那样利用午夜12点来区分日期，利用1970-01-01来表示时间。这些类型的实例是 immutable 的，而且只能通过工厂方法创建。  时区...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-5.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">卡表和 RSet 问题定义：为什么需要跨区域引用记录 JVM 垃圾收集器的核心工作之一是确定 live set——哪些对象仍然存活、不可回收。确定 live set 的标准做法是从 GC Roots（栈帧中的局部变量、静态字段等）出发，沿引用链遍历所有可达对象。 问题在于：当堆被划分为多个区域（代、Region）并且只回收其中一部分时，如何高效地找到从&quot;不回收区域&quot;指向&quot;回收区域&quot;的引用？ 以 Young GC 为例：只回收新生代，但老年代中可能持有指向新生代对象的引用。如果不处理这些跨代引用，就会错误地回收仍被老年代引用的新生代对象。最朴素的做法是扫描整个老年代来找出这些引用——但老年代通常远大于新生代，这样做的代价过高，违背了分代收集&quot;只回收一部分堆&quot;的初衷。 卡表（Card Table）和 RSet（Remembered Set）正是为解决这个问题而设计的辅助数据结构。二者的关系并非互相替代，而是层次不同、协作互补：卡表是底层的脏标记机制，RSet 是建立在卡表之上的更高层索引结构。 核心概念速览 在深入细节之前，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Java 集合框架完全指南</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%85%A8%E6%99%AF%E5%AF%BC%E5%9B%BE"><span class="toc-number">1.1.</span> <span class="toc-text">第一章：全景导图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">文章结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88"><span class="toc-number">1.1.2.</span> <span class="toc-text">模式总览</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E4%BD%93%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">第二章：集合框架体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#uml-%E7%B1%BB%E5%9B%BE"><span class="toc-number">1.2.1.</span> <span class="toc-text">UML 类图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%8E%A5%E5%8F%A3%E8%AF%B4%E6%98%8E"><span class="toc-number">1.2.2.</span> <span class="toc-text">核心接口说明</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sorted-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">Sorted 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#navigable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">Navigable 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%BC%E8%88%AA%E6%96%B9%E6%B3%95"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">导航方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%8C%83%E5%9B%B4%E8%A7%86%E5%9B%BE"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">范围视图</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%99%8D%E5%BA%8F%E8%A7%86%E5%9B%BE"><span class="toc-number">1.2.2.2.3.</span> <span class="toc-text">降序视图</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abstractlist-%E4%B8%8E-abstractsequentiallist"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">AbstractList 与 AbstractSequentialList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fail-fast-%E4%B8%8E-fail-safe-%E6%9C%BA%E5%88%B6"><span class="toc-number">1.2.3.</span> <span class="toc-text">fail-fast 与 fail-safe 机制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%88%97%E8%A1%A8%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">1.3.</span> <span class="toc-text">第三章：列表与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-arraylist-%E6%89%A9%E7%BC%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 ArrayList 扩缩容机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">内部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E5%9B%A0%E5%AD%90-1-5-%E5%80%8D"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">扩容因子 1.5 倍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E5%90%88%E5%88%9D%E5%A7%8B%E5%AE%B9%E9%87%8F%E9%80%89%E6%8B%A9%E6%8C%87%E5%8D%97"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">集合初始容量选择指南</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">扩容流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%A9%E5%AE%B9%E6%9C%BA%E5%88%B6"><span class="toc-number">1.3.1.5.</span> <span class="toc-text">缩容机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E9%98%9F%E5%88%97%E7%9A%84%E5%85%AD%E4%B8%AA%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 队列的六个操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">操作分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E9%9D%9E%E9%98%BB%E5%A1%9E"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">阻塞与非阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">操作详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">操作选择建议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-priorityqueue"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 PriorityQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">基本特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#top-k-%E9%97%AE%E9%A2%98"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">Top-K 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">任务调度</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-delayqueue"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 DelayQueue</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#delayed-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">Delayed 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.4.3.</span> <span class="toc-text">缓存过期实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A2%E5%8D%95%E8%B6%85%E6%97%B6%E5%8F%96%E6%B6%88"><span class="toc-number">1.3.4.4.</span> <span class="toc-text">订单超时取消</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8%E5%AE%B6%E6%97%8F"><span class="toc-number">1.4.</span> <span class="toc-text">第四章：哈希表家族</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-hashmap-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 HashMap 内部结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-8-%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">Java 8+ 内部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AD%97%E6%AE%B5"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">核心字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-hashmap-%E5%85%B3%E9%94%AE%E5%8F%82%E6%95%B0%E8%A1%A8"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 HashMap 关键参数表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-hashmap-%E6%89%A9%E5%AE%B9%E6%B5%81%E7%A8%8B"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 HashMap 扩容流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A9%E5%AE%B9%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">扩容触发条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resize-%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">resize 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8D%E6%96%B0%E5%88%86%E9%85%8D%E4%BC%98%E5%8C%96"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">重新分配优化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%B9%E9%87%8F%E5%BF%85%E9%A1%BB%E6%98%AF-2-%E7%9A%84%E5%B9%82"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">为什么容量必须是 2 的幂</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E6%89%B0%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 扰动函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-%E6%A0%91%E5%8C%96%E4%B8%8E%E5%8F%8D%E6%A0%91%E5%8C%96"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 树化与反树化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%8C%96%E6%9D%A1%E4%BB%B6"><span class="toc-number">1.4.5.1.</span> <span class="toc-text">树化条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%8A%E6%9D%BE%E5%88%86%E5%B8%83%E8%A7%A3%E9%87%8A%E9%98%88%E5%80%BC-8"><span class="toc-number">1.4.5.2.</span> <span class="toc-text">泊松分布解释阈值 8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E6%A0%91%E5%8C%96%E9%98%88%E5%80%BC-6"><span class="toc-number">1.4.5.3.</span> <span class="toc-text">反树化阈值 6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-concurrenthashmap-%E6%89%A9%E5%AE%B9"><span class="toc-number">1.4.6.</span> <span class="toc-text">4.6 ConcurrentHashMap 扩容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E8%BF%81%E7%A7%BB"><span class="toc-number">1.4.6.1.</span> <span class="toc-text">分段迁移</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sizectl-%E5%AD%97%E6%AE%B5%E5%90%AB%E4%B9%89"><span class="toc-number">1.4.6.2.</span> <span class="toc-text">sizeCtl 字段含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-7-%E4%B8%8E-jdk-8-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.6.3.</span> <span class="toc-text">JDK 7 与 JDK 8 的实现对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-linkedhashmap"><span class="toc-number">1.4.7.</span> <span class="toc-text">4.7 LinkedHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81%E6%8F%92%E5%85%A5%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.4.7.1.</span> <span class="toc-text">保持插入顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%9D%E6%8C%81%E8%AE%BF%E9%97%AE%E9%A1%BA%E5%BA%8F-lru-%E7%BC%93%E5%AD%98"><span class="toc-number">1.4.7.2.</span> <span class="toc-text">保持访问顺序（LRU 缓存）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lru-%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.7.3.</span> <span class="toc-text">LRU 缓存实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.7.4.</span> <span class="toc-text">性能对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-8-enumset"><span class="toc-number">1.4.8.</span> <span class="toc-text">4.8 EnumSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#enumset-%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.4.8.1.</span> <span class="toc-text">EnumSet 的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.8.2.</span> <span class="toc-text">创建与使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk-%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-number">1.4.8.3.</span> <span class="toc-text">JDK 实现细节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF"><span class="toc-number">1.4.8.4.</span> <span class="toc-text">性能优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-enummap"><span class="toc-number">1.4.9.</span> <span class="toc-text">4.9 EnumMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">1.4.9.1.</span> <span class="toc-text">创建与使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95"><span class="toc-number">1.4.9.2.</span> <span class="toc-text">高级用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF"><span class="toc-number">1.4.9.3.</span> <span class="toc-text">性能优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-identityhashmap"><span class="toc-number">1.4.10.</span> <span class="toc-text">4.10 IdentityHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">1.4.10.1.</span> <span class="toc-text">用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.4.10.2.</span> <span class="toc-text">使用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.10.3.</span> <span class="toc-text">实际应用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-11-weakhashmap"><span class="toc-number">1.4.11.</span> <span class="toc-text">4.11 WeakHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%B1%E5%BC%95%E7%94%A8%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.11.1.</span> <span class="toc-text">弱引用机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.11.2.</span> <span class="toc-text">实际应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.4.11.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0%EF%BC%9A%E6%9C%89%E5%BA%8F%E9%9B%86%E5%90%88%E4%B8%8E%E5%B9%B6%E5%8F%91%E9%9B%86%E5%90%88"><span class="toc-number">1.5.</span> <span class="toc-text">第五章：有序集合与并发集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-treeset-%E4%B8%8E-treemap"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 TreeSet 与 TreeMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-treeset-treemap-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 TreeSet&#x2F;TreeMap 应用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-copyonwritearraylist"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-concurrentskiplistset-map"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 ConcurrentSkipListSet&#x2F;Map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-concurrentskiplistmap-%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5 ConcurrentSkipListMap 应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0%EF%BC%9A%E7%BC%93%E5%AD%98%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5"><span class="toc-number">1.6.</span> <span class="toc-text">第六章：缓存淘汰策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-lru-least-recently-used"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 LRU（Least Recently Used）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-lru-%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 LRU 手动实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-lfu-least-frequently-used"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 LFU（Least Frequently Used）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-redis-%E8%BF%91%E4%BC%BC-lru"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 Redis 近似 LRU</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-redis-%E8%BF%91%E4%BC%BC-lfu-4-0"><span class="toc-number">1.6.5.</span> <span class="toc-text">6.5 Redis 近似 LFU（4.0+）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-redis-7-0-listpack-%E6%94%B9%E8%BF%9B"><span class="toc-number">1.6.6.</span> <span class="toc-text">6.6 Redis 7.0 listpack 改进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%EF%BC%9A%E7%B3%BB%E7%BB%9F%E7%BA%A7%E6%89%A9%E7%BC%A9%E5%AE%B9"><span class="toc-number">1.7.</span> <span class="toc-text">第七章：系统级扩缩容</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-stringbuilder-%E6%89%A9%E5%AE%B9"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 StringBuilder 扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%A9%E7%BC%A9%E5%AE%B9"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 线程池扩缩容</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-21-%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">Java 21+ 虚拟线程的影响</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-redis-%E6%B8%90%E8%BF%9B%E5%BC%8F-rehash"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 Redis 渐进式 Rehash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0%EF%BC%9A%E6%89%A9%E7%BC%A9%E5%AE%B9%E7%9A%84%E9%80%9A%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.8.</span> <span class="toc-text">第八章：扩缩容的通用设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%A1%8D%E7%94%9F%E5%85%B3%E7%B3%BB"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 数据结构衍生关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%A8%A1%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%80%8D%E5%A2%9E%E7%AD%96%E7%95%A5%E8%A1%A8"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 模式一：倍增策略表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-%E6%A8%A1%E5%BC%8F%E4%BA%8C%EF%BC%9A%E6%B8%90%E8%BF%9B%E5%BC%8F%E8%BF%81%E7%A7%BB%E8%A1%A8"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 模式二：渐进式迁移表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-%E6%A8%A1%E5%BC%8F%E4%B8%89%EF%BC%9A%E6%B0%B4%E4%BD%8D%E7%BA%BF%E8%A7%A6%E5%8F%91%E8%A1%A8"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 模式三：水位线触发表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-%E6%A8%A1%E5%BC%8F%E5%9B%9B%EF%BC%9A%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E8%A1%A8"><span class="toc-number">1.8.5.</span> <span class="toc-text">8.5 模式四：淘汰策略表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.9.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">1.9.1.</span> <span class="toc-text">总结对比表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.9.2.</span> <span class="toc-text">核心设计原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="toc-number">1.9.3.</span> <span class="toc-text">模式速查表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">1.10.</span> <span class="toc-text">参考资料</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>