<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MESI 协议与 Java 并发可见性——从硬件到 JMM | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="为什么 volatile 能保证可见性？为什么 synchronized 既保证原子性又保证可见性？答案藏在 CPU 缓存一致性协议和内存屏障中。本文将从硬件层面的 MESI 协议出发，逐步上升到 Java 内存模型（JMM），揭示并发可见性问题的完整因果链。  Part 1: CPU 缓存架构 为什么需要 CPU 缓存 现代 CPU 的运算速度远超内存访问速度，两者之间存在巨大的速度鸿沟：">
<meta property="og:type" content="article">
<meta property="og:title" content="MESI 协议与 Java 并发可见性——从硬件到 JMM">
<meta property="og:url" content="https://magicliang.github.io/2025/07/29/MESI-%E5%8D%8F%E8%AE%AE%E4%B8%8E-Java-%E5%B9%B6%E5%8F%91%E5%8F%AF%E8%A7%81%E6%80%A7/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="为什么 volatile 能保证可见性？为什么 synchronized 既保证原子性又保证可见性？答案藏在 CPU 缓存一致性协议和内存屏障中。本文将从硬件层面的 MESI 协议出发，逐步上升到 Java 内存模型（JMM），揭示并发可见性问题的完整因果链。  Part 1: CPU 缓存架构 为什么需要 CPU 缓存 现代 CPU 的运算速度远超内存访问速度，两者之间存在巨大的速度鸿沟：">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-176.jpeg">
<meta property="article:published_time" content="2025-07-29T07:05:34.000Z">
<meta property="article:modified_time" content="2026-02-07T06:22:08.734Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="并发编程">
<meta property="article:tag" content="计算机体系结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-176.jpeg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MESI 协议与 Java 并发可见性——从硬件到 JMM",
  "url": "https://magicliang.github.io/2025/07/29/MESI-%E5%8D%8F%E8%AE%AE%E4%B8%8E-Java-%E5%B9%B6%E5%8F%91%E5%8F%AF%E8%A7%81%E6%80%A7/",
  "image": "https://magicliang.github.io/img/wall-paper-176.jpeg",
  "datePublished": "2025-07-29T07:05:34.000Z",
  "dateModified": "2026-02-07T06:22:08.734Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2025/07/29/MESI-%E5%8D%8F%E8%AE%AE%E4%B8%8E-Java-%E5%B9%B6%E5%8F%91%E5%8F%AF%E8%A7%81%E6%80%A7/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MESI 协议与 Java 并发可见性——从硬件到 JMM',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-176.jpeg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">MESI 协议与 Java 并发可见性——从硬件到 JMM</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">MESI 协议与 Java 并发可见性——从硬件到 JMM</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2025-07-29T07:05:34.000Z" title="Created 2025-07-29 15:05:34">2025-07-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-07T06:22:08.734Z" title="Updated 2026-02-07 14:22:08">2026-02-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">5.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>18mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>为什么 <code>volatile</code> 能保证可见性？为什么 <code>synchronized</code> 既保证原子性又保证可见性？答案藏在 CPU 缓存一致性协议和内存屏障中。本文将从硬件层面的 MESI 协议出发，逐步上升到 Java 内存模型（JMM），揭示并发可见性问题的完整因果链。</p>
<hr>
<h2 id="part-1-cpu-缓存架构">Part 1: CPU 缓存架构</h2>
<h3 id="为什么需要-cpu-缓存">为什么需要 CPU 缓存</h3>
<p>现代 CPU 的运算速度远超内存访问速度，两者之间存在巨大的<strong>速度鸿沟</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>延迟</th>
<th>相对速度</th>
</tr>
</thead>
<tbody>
<tr>
<td>CPU 寄存器访问</td>
<td>~0.3 ns</td>
<td>1x</td>
</tr>
<tr>
<td>L1 Cache 访问</td>
<td>~1 ns</td>
<td>3x</td>
</tr>
<tr>
<td>L2 Cache 访问</td>
<td>~4 ns</td>
<td>13x</td>
</tr>
<tr>
<td>L3 Cache 访问</td>
<td>~12 ns</td>
<td>40x</td>
</tr>
<tr>
<td>主内存访问</td>
<td>~100 ns</td>
<td>333x</td>
</tr>
</tbody>
</table>
<p>如果 CPU 每次都直接访问主内存，大部分时间都在<strong>等待数据</strong>。缓存利用了<strong>时间局部性</strong>和<strong>空间局部性</strong>，将最近和附近的数据保存在更快的存储中。</p>
<h3 id="多级缓存架构">多级缓存架构</h3>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">┌──────────────────────────────────────────────────────┐<br>│                    <span class="hljs-meta">CPU</span> <span class="hljs-number">0</span>                              │<br>│  ┌──────┐  ┌──────┐                                  │<br>│  │ Core0│  │ Core1│                                  │<br>│  │ ┌──┐ │  │ ┌──┐ │                                  │<br>│  │ │L1│ │  │ │L1│ │  ← 每个核心私有                    │<br>│  │ └──┘ │  │ └──┘ │                                  │<br>│  │ ┌──┐ │  │ ┌──┐ │                                  │<br>│  │ │L2│ │  │ │L2│ │  ← 每个核心私有（部分架构共享）      │<br>│  │ └──┘ │  │ └──┘ │                                  │<br>│  └──────┘  └──────┘                                  │<br>│  ┌─────────────────┐                                  │<br>│  │       L3        │  ← 同一 <span class="hljs-meta">CPU</span> 内所有核心共享         │<br>│  └─────────────────┘                                  │<br>└──────────┬───────────────────────────────────────────┘<br>           │<br>    ┌──────▼──────┐<br>    │   主内存     │  ← 所有 <span class="hljs-meta">CPU</span> 共享<br>    └─────────────┘<br></code></pre></td></tr></table></figure>
<h3 id="缓存行-cache-line">缓存行（Cache Line）</h3>
<p>CPU 缓存的最小操作单位是<strong>缓存行（Cache Line）</strong>，通常为 <strong>64 字节</strong>。</p>
<p>当 CPU 读取一个变量时，会将该变量所在的整个缓存行（64 字节）加载到缓存中。这意味着：</p>
<ul>
<li>相邻的变量会被一起加载（空间局部性）</li>
<li>修改一个变量可能影响同一缓存行中的其他变量（<strong>伪共享问题</strong>）</li>
</ul>
<hr>
<h2 id="mesi-协议的必要性">MESI 协议的必要性</h2>
<p>当多个 CPU 核心同时访问同一块内存时，如果没有缓存一致性协议，会出现数据不一致的问题：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs gherkin"><br><span class="hljs-comment">### MESI 的四种状态</span><br><br><span class="hljs-symbol">*</span><span class="hljs-symbol">*</span>MESI<span class="hljs-symbol">*</span><span class="hljs-symbol">*</span> 是最经典的缓存一致性协议，每个缓存行有四种状态：<br><br>|<span class="hljs-string"> 状态 </span>|<span class="hljs-string"> 全称 </span>|<span class="hljs-string"> 含义 </span>|<span class="hljs-string"> 可以直接读？ </span>|<span class="hljs-string"> 可以直接写？ </span>|<br>|<span class="hljs-string">------</span>|<span class="hljs-string">------</span>|<span class="hljs-string">------</span>|<span class="hljs-string">------------</span>|<span class="hljs-string">------------</span>|<br>|<span class="hljs-string"> **M（Modified）** </span>|<span class="hljs-string"> 已修改 </span>|<span class="hljs-string"> 只有本核心有，且已修改，与主内存不一致 </span>|<span class="hljs-string"> ✅ </span>|<span class="hljs-string"> ✅ </span>|<br>|<span class="hljs-string"> **E（Exclusive）** </span>|<span class="hljs-string"> 独占 </span>|<span class="hljs-string"> 只有本核心有，与主内存一致 </span>|<span class="hljs-string"> ✅ </span>|<span class="hljs-string"> ✅（变为 M） </span>|<br>|<span class="hljs-string"> **S（Shared）** </span>|<span class="hljs-string"> 共享 </span>|<span class="hljs-string"> 多个核心都有，与主内存一致 </span>|<span class="hljs-string"> ✅ </span>|<span class="hljs-string"> ❌（需先失效其他核心） </span>|<br>|<span class="hljs-string"> **I（Invalid）** </span>|<span class="hljs-string"> 无效 </span>|<span class="hljs-string"> 缓存行无效，不可使用 </span>|<span class="hljs-string"> ❌ </span>|<span class="hljs-string"> ❌ </span>|<br><br><span class="hljs-comment">### 状态转换</span><br><br>```mermaid<br>stateDiagram-v2<br>    [<span class="hljs-symbol">*</span>] --&gt; I<br>    I --&gt; E: 本核心读取（其他核心无此数据）<br>    I --&gt; S: 本核心读取（其他核心有此数据）<br>    E --&gt; M: 本核心写入<br>    E --&gt; S: 其他核心读取<br>    E --&gt; I: 其他核心写入<br>    S --&gt; M: 本核心写入（其他核心的副本变为 I）<br>    S --&gt; I: 其他核心写入<br>    M --&gt; S: 其他核心读取（先写回主内存）<br>    M --&gt; I: 其他核心写入（先写回主内存）<br></code></pre></td></tr></table></figure>
<h3 id="详细的状态转换场景">详细的状态转换场景</h3>
<p><strong>场景一：Core 0 独占读取</strong></p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css">初始状态：<span class="hljs-attribute">x</span> 不在任何缓存中<br><br>Core <span class="hljs-number">0</span> 读取 <span class="hljs-attribute">x</span>：<br><span class="hljs-number">1</span>. Core <span class="hljs-number">0</span> 发出 Read 请求<br><span class="hljs-number">2</span>. 总线嗅探：没有其他核心有 <span class="hljs-attribute">x</span><br><span class="hljs-number">3</span>. 从主内存加载 <span class="hljs-attribute">x</span> 到 Core <span class="hljs-number">0</span> 的缓存<br><span class="hljs-number">4</span>. 状态：E（独占）<br></code></pre></td></tr></table></figure>
<p><strong>场景二：Core 1 也读取 x</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Core</span> <span class="hljs-number">0</span> 缓存: x = <span class="hljs-number">42</span> (E)<br><br><span class="hljs-attribute">Core</span> <span class="hljs-number">1</span> 读取 x：<br><span class="hljs-attribute">1</span>. Core <span class="hljs-number">1</span> 发出 Read 请求<br><span class="hljs-attribute">2</span>. 总线嗅探：Core <span class="hljs-number">0</span> 有 x（状态 E）<br><span class="hljs-attribute">3</span>. Core <span class="hljs-number">0</span> 将 x 提供给 Core <span class="hljs-number">1</span>（可能通过缓存到缓存传输）<br><span class="hljs-attribute">4</span>. Core <span class="hljs-number">0</span> 状态：E → S<br><span class="hljs-attribute">5</span>. Core <span class="hljs-number">1</span> 状态：I → S<br></code></pre></td></tr></table></figure>
<p><strong>场景三：Core 0 写入 x</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Core</span> <span class="hljs-number">0</span> 缓存: x = <span class="hljs-number">42</span> (S)<br><span class="hljs-attribute">Core</span> <span class="hljs-number">1</span> 缓存: x = <span class="hljs-number">42</span> (S)<br><br><span class="hljs-attribute">Core</span> <span class="hljs-number">0</span> 写入 x = <span class="hljs-number">100</span>：<br><span class="hljs-attribute">1</span>. Core <span class="hljs-number">0</span> 发出 Invalidate 请求<br><span class="hljs-attribute">2</span>. Core <span class="hljs-number">1</span> 收到 Invalidate，将 x 标记为 I（无效）<br><span class="hljs-attribute">3</span>. Core <span class="hljs-number">1</span> 发送 Invalidate Acknowledge<br><span class="hljs-attribute">4</span>. Core <span class="hljs-number">0</span> 收到所有 Acknowledge 后，执行写入<br><span class="hljs-attribute">5</span>. Core <span class="hljs-number">0</span> 状态：S → M<br><span class="hljs-attribute">6</span>. Core <span class="hljs-number">1</span> 状态：S → I<br></code></pre></td></tr></table></figure>
<p><strong>场景四：Core 1 读取被修改的 x</strong></p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Core</span> <span class="hljs-number">0</span> 缓存: x = <span class="hljs-number">100</span> (M)<br><span class="hljs-attribute">Core</span> <span class="hljs-number">1</span> 缓存: x = <span class="hljs-number">42</span> (I)<br><br><span class="hljs-attribute">Core</span> <span class="hljs-number">1</span> 读取 x：<br><span class="hljs-attribute">1</span>. Core <span class="hljs-number">1</span> 发出 Read 请求<br><span class="hljs-attribute">2</span>. 总线嗅探：Core <span class="hljs-number">0</span> 有 x（状态 M）<br><span class="hljs-attribute">3</span>. Core <span class="hljs-number">0</span> 将 x = <span class="hljs-number">100</span> 写回主内存<br><span class="hljs-attribute">4</span>. Core <span class="hljs-number">0</span> 将 x = <span class="hljs-number">100</span> 提供给 Core <span class="hljs-number">1</span><br><span class="hljs-attribute">5</span>. Core <span class="hljs-number">0</span> 状态：M → S<br><span class="hljs-attribute">6</span>. Core <span class="hljs-number">1</span> 状态：I → S<br><span class="hljs-attribute">7</span>. Core <span class="hljs-number">1</span> 读到的值：<span class="hljs-number">100</span>（最新值）<br></code></pre></td></tr></table></figure>
<h3 id="总线嗅探-bus-snooping">总线嗅探（Bus Snooping）</h3>
<p>MESI 协议通过<strong>总线嗅探</strong>实现：每个核心的缓存控制器都在监听总线上的所有事务。当检测到与自己缓存行相关的操作时，自动更新状态。</p>
<p><strong>总线嗅探的局限性</strong>：</p>
<ul>
<li>总线带宽有限，核心数增多时成为瓶颈</li>
<li>现代多核处理器（如 AMD EPYC）使用**目录协议（Directory Protocol）**替代总线嗅探</li>
</ul>
<hr>
<h2 id="part-3-store-buffer-与-invalidate-queue">Part 3: Store Buffer 与 Invalidate Queue</h2>
<h3 id="为什么-mesi-还不够">为什么 MESI 还不够</h3>
<p>MESI 协议保证了缓存一致性，但它有一个性能问题：<strong>写入操作需要等待所有其他核心的 Invalidate Acknowledge</strong>。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Core 0 写入 x（状态 S）：<br><span class="hljs-bullet">1.</span> 发送 Invalidate 到 Core 1, Core 2, Core 3  <br><span class="hljs-bullet">2.</span> 等待 Core 1 的 Acknowledge  ← 可能需要几十个时钟周期  <br><span class="hljs-bullet">3.</span> 等待 Core 2 的 Acknowledge  ← 可能需要几十个时钟周期  <br><span class="hljs-bullet">4.</span> 等待 Core 3 的 Acknowledge  ← 可能需要几十个时钟周期  <br><span class="hljs-bullet">5.</span> 才能执行写入  <br><br>这个等待时间对 CPU 来说是不可接受的。<br><br><span class="hljs-section">### Store Buffer（写缓冲区）</span><br><br>为了避免等待，CPU 引入了 <span class="hljs-strong">**Store Buffer**</span>：<br><br></code></pre></td></tr></table></figure>
<p>Core 0 写入 x = 100：</p>
<ol>
<li>将 x = 100 写入 Store Buffer（立即返回，不等待）</li>
<li>异步发送 Invalidate 到其他核心</li>
<li>收到所有 Acknowledge 后，将 Store Buffer 中的值写入缓存</li>
</ol>
<figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gml"><br>**Store Buffer 带来的问题**：<br><br>```java<br><span class="hljs-comment">// 初始值：a = 0, b = 0</span><br><br><span class="hljs-comment">// Core 0                    // Core 1</span><br>a = <span class="hljs-number">1</span>;                       b = <span class="hljs-number">1</span>;<br><span class="hljs-variable language_">x</span> = b;                       <span class="hljs-variable language_">y</span> = a;<br><br><span class="hljs-comment">// 可能的结果：x = 0, y = 0（都读到了旧值！）</span><br></code></pre></td></tr></table></figure>
<p><strong>原因</strong>：Core 0 写入 <code>a = 1</code> 时，值还在 Store Buffer 中，尚未对 Core 1 可见。Core 1 同理。</p>
<h3 id="invalidate-queue-失效队列">Invalidate Queue（失效队列）</h3>
<p>类似地，接收 Invalidate 请求的核心也不想立即处理（处理需要时间），于是引入了 <strong>Invalidate Queue</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">Core 1 收到 Invalidate(x)：<br><span class="hljs-bullet">1.</span> 将 Invalidate 请求放入 Invalidate Queue<br><span class="hljs-bullet">2.</span> 立即发送 Acknowledge（不等待实际失效）<br><span class="hljs-bullet">3.</span> 稍后处理 Queue 中的请求，将缓存行标记为 I<br></code></pre></td></tr></table></figure>
<p><strong>Invalidate Queue 带来的问题</strong>：Core 1 可能在处理 Invalidate 之前读取了缓存中的旧值。</p>
<h3 id="重排序的根源">重排序的根源</h3>
<p>Store Buffer 和 Invalidate Queue 是 CPU <strong>指令重排序</strong>的硬件根源：</p>
<table>
<thead>
<tr>
<th>重排序类型</th>
<th>原因</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Store-Store 重排序</strong></td>
<td>Store Buffer 中的写入可能乱序刷出</td>
<td>先写 a 后写 b，但 b 先对其他核心可见</td>
</tr>
<tr>
<td><strong>Load-Load 重排序</strong></td>
<td>Invalidate Queue 中的失效可能延迟处理</td>
<td>读到了已经被其他核心修改的旧值</td>
</tr>
<tr>
<td><strong>Store-Load 重排序</strong></td>
<td>Store Buffer 中的写入对本核心的后续读取不可见</td>
<td>写入 a 后读取 b，但 a 的写入还在 Store Buffer 中</td>
</tr>
<tr>
<td><strong>Load-Store 重排序</strong></td>
<td>较少见，某些架构可能发生</td>
<td>—</td>
</tr>
</tbody>
</table>
<hr>
<h2 id="part-4-内存屏障-memory-barrier">Part 4: 内存屏障（Memory Barrier）</h2>
<h3 id="什么是内存屏障">什么是内存屏障</h3>
<p><strong>内存屏障（Memory Barrier / Memory Fence）</strong> 是 CPU 提供的指令，用于限制重排序：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>作用</th>
<th>实现方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Store Barrier（写屏障）</strong></td>
<td>屏障前的写入必须在屏障后的写入之前完成</td>
<td>刷出 Store Buffer</td>
</tr>
<tr>
<td><strong>Load Barrier（读屏障）</strong></td>
<td>屏障前的读取必须在屏障后的读取之前完成</td>
<td>处理 Invalidate Queue</td>
</tr>
<tr>
<td><strong>Full Barrier（全屏障）</strong></td>
<td>同时具有读屏障和写屏障的效果</td>
<td>刷出 Store Buffer + 处理 Invalidate Queue</td>
</tr>
</tbody>
</table>
<h3 id="x86-的内存模型">x86 的内存模型</h3>
<p>x86 架构使用 <strong>TSO（Total Store Order）</strong> 内存模型，这是一个相对强的内存模型：</p>
<table>
<thead>
<tr>
<th>重排序类型</th>
<th>x86 是否允许</th>
</tr>
</thead>
<tbody>
<tr>
<td>Load-Load</td>
<td>❌ 不允许</td>
</tr>
<tr>
<td>Load-Store</td>
<td>❌ 不允许</td>
</tr>
<tr>
<td>Store-Store</td>
<td>❌ 不允许</td>
</tr>
<tr>
<td><strong>Store-Load</strong></td>
<td><strong>✅ 允许</strong></td>
</tr>
</tbody>
</table>
<p>x86 只允许 <strong>Store-Load 重排序</strong>（写入后的读取可能读到旧值）。这意味着在 x86 上，大多数情况下不需要显式的内存屏障，只有 Store-Load 场景需要 <code>mfence</code> 指令。</p>
<p><strong>TSO 的实现机制</strong>：</p>
<ul>
<li>所有写操作进入 Store Buffer</li>
<li>写操作按顺序从 Store Buffer 刷出到缓存</li>
<li>读操作会检查 Store Buffer，如果命中则返回 Store Buffer 中的值</li>
<li>这保证了 Store-Store 顺序，但无法保证 Store-Load 顺序</li>
</ul>
<p><strong>x86 内存屏障指令</strong>：</p>
<ul>
<li><code>mfence</code>：全屏障（禁止所有重排序）</li>
<li><code>sfence</code>：Store 屏障（禁止 Store-Store 和 Store-Load 重排序）</li>
<li><code>lfence</code>：Load 屏障（禁止 Load-Load 和 Load-Store 重排序）</li>
<li><code>lock</code> 前缀：隐式全屏障（如 <code>lock addl $0, (%rsp)</code>）</li>
</ul>
<h3 id="arm-risc-v-的弱内存模型">ARM/RISC-V 的弱内存模型</h3>
<p>ARM 和 RISC-V 使用<strong>弱内存模型</strong>，允许所有四种重排序：</p>
<table>
<thead>
<tr>
<th>重排序类型</th>
<th>ARM 是否允许</th>
<th>RISC-V 是否允许</th>
</tr>
</thead>
<tbody>
<tr>
<td>Load-Load</td>
<td>✅ 允许</td>
<td>✅ 允许</td>
</tr>
<tr>
<td>Load-Store</td>
<td>✅ 允许</td>
<td>✅ 允许</td>
</tr>
<tr>
<td>Store-Store</td>
<td>✅ 允许</td>
<td>✅ 允许</td>
</tr>
<tr>
<td>Store-Load</td>
<td>✅ 允许</td>
<td>✅ 允许</td>
</tr>
</tbody>
</table>
<p>因此在这些架构上，需要更多的内存屏障指令。</p>
<p><strong>ARM 内存屏障指令</strong>（ARMv8）：</p>
<ul>
<li><code>DMB</code> (Data Memory Barrier)：数据内存屏障</li>
<li><code>DSB</code> (Data Synchronization Barrier)：数据同步屏障</li>
<li><code>ISB</code> (Instruction Synchronization Barrier)：指令同步屏障</li>
</ul>
<p><strong>RISC-V 内存屏障指令</strong>：</p>
<ul>
<li><code>fence rw, rw</code>：全屏障</li>
<li><code>fence r, r</code>：读屏障</li>
<li><code>fence w, w</code>：写屏障</li>
</ul>
<p><strong>跨平台差异的影响</strong>：</p>
<ul>
<li>某些并发 Bug 在 x86 上不会出现，但在 ARM 上会出现</li>
<li>JVM 需要为不同架构生成不同的屏障指令</li>
<li>ARM/PowerPC 等弱内存模型架构需要更多的屏障指令，可能影响性能</li>
</ul>
<hr>
<h2 id="part-5-java-内存模型-jmm">Part 5: Java 内存模型（JMM）</h2>
<h3 id="jmm-的设计目标">JMM 的设计目标</h3>
<p>Java 内存模型（Java Memory Model, JMM）定义在 <strong>JSR-133</strong>（Java 5）中，其目标是：</p>
<ol>
<li><strong>为程序员提供足够强的保证</strong>：正确同步的程序在所有平台上行为一致</li>
<li><strong>为编译器和 CPU 提供足够的优化空间</strong>：不过度限制重排序</li>
</ol>
<h3 id="jmm-的抽象模型">JMM 的抽象模型</h3>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">┌──────────┐  ┌──────────┐  ┌──────────┐<br>│ <span class="hljs-keyword">Thread</span> <span class="hljs-number">1</span> │  │ <span class="hljs-keyword">Thread</span> <span class="hljs-number">2</span> │  │ <span class="hljs-keyword">Thread</span> <span class="hljs-number">3</span> │<br>│ ┌──────┐ │  │ ┌──────┐ │  │ ┌──────┐ │<br>│ │工作内存│ │  │ │工作内存│ │  │ │工作内存│ │<br>│ │(本地) │ │  │ │(本地) │ │  │ │(本地) │ │<br>│ └──┬───┘ │  │ └──┬───┘ │  │ └──┬───┘ │<br>└────┼─────┘  └────┼─────┘  └────┼─────┘<br>     │             │             │<br>     ▼             ▼             ▼<br>┌─────────────────────────────────────┐<br>│            主内存（Main Memory）      │<br>│     所有共享变量存储在这里             │<br>└─────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<p><strong>注意</strong>：JMM 是一个<strong>抽象模型</strong>，不是物理实现。&quot;工作内存&quot;对应的是 CPU 缓存、Store Buffer、寄存器等硬件结构的抽象。</p>
<h3 id="happens-before-关系">Happens-Before 关系</h3>
<p><strong>Happens-Before</strong> 是 JMM 的核心概念：如果操作 A happens-before 操作 B，那么 A 的结果对 B 可见。</p>
<p>JMM 定义了以下 Happens-Before 规则：</p>
<table>
<thead>
<tr>
<th>规则</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>程序顺序规则</strong></td>
<td>同一线程中，前面的操作 happens-before 后面的操作</td>
<td><code>a = 1; b = 2;</code> 中 <code>a=1</code> hb <code>b=2</code></td>
</tr>
<tr>
<td><strong>Monitor 锁规则</strong></td>
<td>unlock 操作 happens-before 后续对同一锁的 lock 操作</td>
<td><code>synchronized</code> 块解锁后的操作对后续加锁可见</td>
</tr>
<tr>
<td><strong>volatile 规则</strong></td>
<td>volatile 写 happens-before 后续对同一 volatile 变量的读</td>
<td><code>volatile flag = true;</code> 后的读取保证看到 true</td>
</tr>
<tr>
<td><strong>线程启动规则</strong></td>
<td>Thread.start() happens-before 该线程中的任何操作</td>
<td>主线程调用 <code>start()</code> 前的操作对新线程可见</td>
</tr>
<tr>
<td><strong>线程终止规则</strong></td>
<td>线程中的任何操作 happens-before Thread.join() 返回</td>
<td><code>join()</code> 返回后，线程的所有修改对调用者可见</td>
</tr>
<tr>
<td><strong>中断规则</strong></td>
<td>Thread.interrupt() happens-before 被中断线程检测到中断</td>
<td>调用 <code>interrupt()</code> 后，线程能检测到中断状态</td>
</tr>
<tr>
<td><strong>终结器规则</strong></td>
<td>构造函数完成 happens-before finalize() 开始</td>
<td>对象构造完成 before 垃圾回收调用 finalize()</td>
</tr>
<tr>
<td><strong>传递性</strong></td>
<td>如果 A hb B，B hb C，则 A hb C</td>
<td>A=1 hb B=2 hb C=3 ⇒ A=1 hb C=3</td>
</tr>
</tbody>
</table>
<h3 id="happens-before-不等于时间上的先后">Happens-Before 不等于时间上的先后</h3>
<p>Happens-Before 是一种<strong>可见性保证</strong>，不是时间顺序。即使操作 A 在时间上先于操作 B 执行，如果没有 Happens-Before 关系，B 也不一定能看到 A 的结果。</p>
<hr>
<h2 id="part-6-volatile-的实现原理">Part 6: volatile 的实现原理</h2>
<h3 id="volatile-的语义">volatile 的语义</h3>
<ol>
<li><strong>可见性</strong>：对 volatile 变量的写入，对后续读取该变量的线程立即可见</li>
<li><strong>有序性</strong>：禁止 volatile 读写与前后操作的重排序</li>
<li><strong>不保证原子性</strong>：<code>volatile int count; count++</code> 不是原子操作</li>
</ol>
<h3 id="volatile-的内存屏障">volatile 的内存屏障</h3>
<p>JVM 在 volatile 读写前后插入内存屏障：</p>
<p><strong>volatile 写</strong>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino">普通写操作<br>StoreStore Barrier  ← 禁止上面的普通写与下面的 <span class="hljs-keyword">volatile</span> 写重排序<br><span class="hljs-keyword">volatile</span> 写操作<br>StoreLoad Barrier   ← 禁止 <span class="hljs-keyword">volatile</span> 写与下面的 <span class="hljs-keyword">volatile</span> 读/写重排序<br></code></pre></td></tr></table></figure>
<p><strong>volatile 读</strong>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">volatile</span> 读操作<br>LoadLoad Barrier    ← 禁止 <span class="hljs-keyword">volatile</span> 读与下面的普通读重排序<br>LoadStore Barrier   ← 禁止 <span class="hljs-keyword">volatile</span> 读与下面的普通写重排序<br>普通读操作<br></code></pre></td></tr></table></figure>
<h3 id="volatile-在-x86-上的实现">volatile 在 x86 上的实现</h3>
<p>由于 x86 的 TSO 内存模型已经禁止了大部分重排序，volatile 在 x86 上的实现非常轻量：</p>
<ul>
<li><strong>volatile 读</strong>：普通的 <code>mov</code> 指令（不需要额外屏障）</li>
<li><strong>volatile 写</strong>：<code>mov</code> + <code>lock addl $0, (%rsp)</code>（<code>lock</code> 前缀指令充当 StoreLoad Barrier）</li>
</ul>
<p><code>lock</code> 前缀指令的效果：</p>
<ol>
<li>锁定缓存行（或总线）</li>
<li>将 Store Buffer 中的所有写入刷出到缓存</li>
<li>使其他核心的对应缓存行失效</li>
</ol>
<p><strong>JIT 编译产物分析</strong>：</p>
<p>对于以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> counter;<br>counter++;<br></code></pre></td></tr></table></figure>
<p>在 x86 上，JIT 编译器（如 HotSpot C2）会生成类似以下的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; volatile 读<br>mov eax, [counter]     ; 从内存读取 counter 值到 eax<br><br>; 递增操作（非原子）<br>inc eax                ; eax++<br><br>; volatile 写<br>lock add dword [counter], 1  ; 原子递增（如果使用 Atomic 类）<br>; 或者：<br>mov [counter], eax     ; 写入 eax 到 counter（非原子，需要额外同步）<br></code></pre></td></tr></table></figure>
<p><strong>注意</strong>：<code>volatile int counter; counter++</code> 不是原子操作，实际包含：</p>
<ol>
<li>volatile 读 counter</li>
<li>递增</li>
<li>volatile 写 counter</li>
</ol>
<p>这三个步骤之间可能被其他线程插入，导致竞态条件。如果需要原子递增，应使用 <code>AtomicInteger.incrementAndGet()</code>。</p>
<p><strong>AtomicInteger 的实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>counter.incrementAndGet();<br></code></pre></td></tr></table></figure>
<p>JIT 会生成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; CAS (Compare-And-Swap) 循环<br>retry:<br>mov eax, [counter]     ; 读取当前值<br>mov ebx, eax<br>inc ebx                ; 计算新值<br>lock cmpxchg [counter], ebx  ; CAS 操作<br>jne retry              ; 如果失败则重试<br></code></pre></td></tr></table></figure>
<p><code>lock cmpxchg</code> 指令是原子的，保证了递增操作的原子性。</p>
<h3 id="volatile-的典型应用">volatile 的典型应用</h3>
<p><strong>双重检查锁定（DCL）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;  <span class="hljs-comment">// 必须是 volatile</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;                  <span class="hljs-comment">// 第一次检查（无锁）</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;          <span class="hljs-comment">// 第二次检查（有锁）</span><br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">// 非原子操作！</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么 <code>instance</code> 必须是 volatile？</strong></p>
<p><code>instance = new Singleton()</code> 实际上包含三步：</p>
<ol>
<li>分配内存</li>
<li>调用构造函数初始化</li>
<li>将引用赋值给 <code>instance</code></li>
</ol>
<p>如果没有 volatile，步骤 2 和 3 可能被重排序：先赋值引用（此时对象尚未初始化），另一个线程看到 <code>instance != null</code>，直接使用了未初始化的对象。</p>
<p>volatile 禁止了这种重排序，保证构造函数完成后才赋值引用。</p>
<p><strong>状态标志</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskRunner</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (running) &#123;  <span class="hljs-comment">// volatile 读，保证看到最新值</span><br>            doWork();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> &#123;<br>        running = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// volatile 写，立即对其他线程可见</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="part-7-synchronized-的内存语义">Part 7: synchronized 的内存语义</h2>
<h3 id="synchronized-的三重保证">synchronized 的三重保证</h3>
<table>
<thead>
<tr>
<th>保证</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>原子性</strong></td>
<td>同一时刻只有一个线程执行临界区代码</td>
</tr>
<tr>
<td><strong>可见性</strong></td>
<td>解锁时将工作内存刷新到主内存，加锁时从主内存重新加载</td>
</tr>
<tr>
<td><strong>有序性</strong></td>
<td>临界区内的操作不会与临界区外的操作重排序</td>
</tr>
</tbody>
</table>
<h3 id="synchronized-的内存屏障">synchronized 的内存屏障</h3>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">加锁（monitorenter）：<br><span class="hljs-bullet">1.</span> 获取锁<br><span class="hljs-bullet">2.</span> 清空工作内存（从主内存重新加载所有共享变量）<br>   → 相当于 LoadLoad + LoadStore Barrier<br><br>临界区代码执行<br><br>解锁（monitorexit）：<br><span class="hljs-bullet">1.</span> 将工作内存中的修改刷新到主内存<br>   → 相当于 StoreStore + StoreLoad Barrier<br><span class="hljs-bullet">2.</span> 释放锁<br></code></pre></td></tr></table></figure>
<h3 id="synchronized-的锁升级">synchronized 的锁升级</h3>
<p>Java 6 引入了<strong>锁升级</strong>机制，根据竞争程度自动选择最优的锁实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">无锁 → 偏向锁 → 轻量级锁 → 重量级锁<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>适用场景</th>
<th>实现方式</th>
<th>性能</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>偏向锁</strong></td>
<td>只有一个线程访问</td>
<td>在对象头记录线程 ID</td>
<td>最快（无 CAS）</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>少量线程交替访问（无竞争）</td>
<td>CAS + 自旋</td>
<td>快（用户态）</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>多线程竞争</td>
<td>OS Mutex</td>
<td>慢（内核态切换）</td>
</tr>
</tbody>
</table>
<p><strong>对象头中的锁标志位</strong>：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tap">┌──────────────────────────────────────────────────────┐<br>│                    对象头（Mark Word）                  │<br>├──────────────────────────────────────┬───────────────┤<br>│              内容                     │ 锁标志位(2bit) │<br>├──────────────────────────────────────┼───────────────┤<br>│ hashCode | age |<span class="hljs-number"> 0 </span>                  │    <span class="hljs-number"> 01 </span>       │ 无锁<br>│ thread ID | epoch | age |<span class="hljs-number"> 1 </span>         │    <span class="hljs-number"> 01 </span>       │ 偏向锁<br>│ 指向栈中锁记录的指针                   │    <span class="hljs-number"> 00 </span>       │ 轻量级锁<br>│ 指向 Monitor 的指针                   │    <span class="hljs-number"> 10 </span>       │ 重量级锁<br>│ 空                                   │    <span class="hljs-number"> 11 </span>       │ GC 标记<br>└──────────────────────────────────────┴───────────────┘<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="part-8-伪共享-false-sharing">Part 8: 伪共享（False Sharing）</h2>
<h3 id="问题描述">问题描述</h3>
<p>当两个线程分别修改<strong>同一缓存行中的不同变量</strong>时，虽然它们操作的是不同的数据，但由于 MESI 协议以缓存行为单位工作，会导致缓存行在两个核心之间不断失效和重新加载——这就是<strong>伪共享（False Sharing）</strong>。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs scss">缓存行（<span class="hljs-number">64</span> 字节）：<br>┌─────────┬─────────┬──────────────────────────┐<br>│ <span class="hljs-attribute">x</span> (<span class="hljs-number">8</span>B)  │ <span class="hljs-attribute">y</span> (<span class="hljs-number">8</span>B)  │ <span class="hljs-attribute">padding</span> (<span class="hljs-number">48</span>B)            │<br>└─────────┴─────────┴──────────────────────────┘<br><br>Core <span class="hljs-number">0</span> 修改 <span class="hljs-attribute">x</span> → 整个缓存行在 Core <span class="hljs-number">1</span> 中失效<br>Core <span class="hljs-number">1</span> 修改 <span class="hljs-attribute">y</span> → 整个缓存行在 Core <span class="hljs-number">0</span> 中失效<br>→ 缓存行在两个核心之间&quot;乒乓&quot;，性能急剧下降<br></code></pre></td></tr></table></figure>
<h3 id="解决方案：缓存行填充">解决方案：缓存行填充</h3>
<p><strong>Java 8 之前：手动填充</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaddedAtomicLong</span> &#123;<br>    <span class="hljs-comment">// 前填充（7 个 long = 56 字节）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> p1, p2, p3, p4, p5, p6, p7;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br><br>    <span class="hljs-comment">// 后填充（7 个 long = 56 字节）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> p8, p9, p10, p11, p12, p13, p14;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Java 8+：@Contended 注解</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@sun</span>.misc.Contended  <span class="hljs-comment">// JVM 自动添加填充</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaddedValue</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>需要 JVM 参数 <code>-XX:-RestrictContended</code> 才能在非 JDK 内部类中使用。</p>
<h3 id="实际案例">实际案例</h3>
<p><strong>Disruptor</strong>（高性能队列）使用缓存行填充来避免伪共享：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Disruptor 的 Sequence 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LhsPadding</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> p1, p2, p3, p4, p5, p6, p7;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Value</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LhsPadding</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RhsPadding</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Value</span> &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">long</span> p9, p10, p11, p12, p13, p14, p15;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sequence</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RhsPadding</span> &#123;<br>    <span class="hljs-comment">// value 字段被前后各 56 字节的填充包围</span><br>    <span class="hljs-comment">// 保证 value 独占一个缓存行</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Java 的 Thread 类</strong>中的 <code>@Contended</code> 使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java.lang.Thread 中的 ThreadLocalRandom 字段</span><br><span class="hljs-meta">@jdk</span>.internal.vm.annotation.Contended(<span class="hljs-string">&quot;tlr&quot;</span>)<br><span class="hljs-type">long</span> threadLocalRandomSeed;<br><br><span class="hljs-meta">@jdk</span>.internal.vm.annotation.Contended(<span class="hljs-string">&quot;tlr&quot;</span>)<br><span class="hljs-type">int</span> threadLocalRandomProbe;<br><br><span class="hljs-meta">@jdk</span>.internal.vm.annotation.Contended(<span class="hljs-string">&quot;tlr&quot;</span>)<br><span class="hljs-type">int</span> threadLocalRandomSecondarySeed;<br></code></pre></td></tr></table></figure>
<hr>
<h2 id="part-9-final-的内存语义">Part 9: final 的内存语义</h2>
<h3 id="final-字段的特殊保证">final 字段的特殊保证</h3>
<p>JMM 对 <code>final</code> 字段提供了特殊的可见性保证：</p>
<blockquote>
<p>在构造函数中对 final 字段的写入，与随后将该对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p>
</blockquote>
<p>这意味着：<strong>只要对象的引用不在构造函数中逸出，其他线程看到该对象时，final 字段一定已经被正确初始化</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> y;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalExample</span><span class="hljs-params">()</span> &#123;<br>        x = <span class="hljs-number">42</span>;  <span class="hljs-comment">// final 字段写入</span><br>        y = <span class="hljs-number">42</span>;  <span class="hljs-comment">// 普通字段写入</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 另一个线程</span><br><span class="hljs-type">FinalExample</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> sharedRef;  <span class="hljs-comment">// 读取共享引用</span><br><span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> obj.x;  <span class="hljs-comment">// 保证读到 42</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> obj.y;  <span class="hljs-comment">// 不保证读到 42（可能读到 0）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="构造函数中的-this-逸出">构造函数中的 this 逸出</h3>
<p>如果在构造函数中将 <code>this</code> 引用泄露给其他线程，final 的保证将失效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnsafePublication</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">UnsafePublication</span><span class="hljs-params">(EventSource source)</span> &#123;<br>        source.registerListener(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// this 逸出！构造函数尚未完成</span><br>        value = <span class="hljs-number">42</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其他线程可能通过 <code>registerListener</code> 获取到未完全构造的对象，此时 <code>value</code> 可能还是 0。</p>
<hr>
<h2 id="part-10-从硬件到-jmm-的完整映射">Part 10: 从硬件到 JMM 的完整映射</h2>
<h3 id="完整的因果链">完整的因果链</h3>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">硬件层面                          JMM 层面<br>─────────                        ────────<br>CPU 缓存（L1<span class="hljs-regexp">/L2/</span>L3）      →      工作内存<br>主内存（RAM）              →      主内存<br>Store Buffer              →      写入不立即可见<br>Invalidate Queue          →      读取可能读到旧值<br>MESI 协议                 →      缓存一致性（但不够）<br>内存屏障指令               →      <span class="hljs-keyword">volatile</span> / <span class="hljs-keyword">synchronized</span> 的底层实现<br></code></pre></td></tr></table></figure>
<h3 id="volatile-vs-synchronized-vs-final">volatile vs synchronized vs final</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>volatile</th>
<th>synchronized</th>
<th>final</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>可见性</strong></td>
<td>✅</td>
<td>✅</td>
<td>✅（构造函数完成后）</td>
</tr>
<tr>
<td><strong>原子性</strong></td>
<td>❌（仅单次读/写）</td>
<td>✅</td>
<td>N/A</td>
</tr>
<tr>
<td><strong>有序性</strong></td>
<td>✅（禁止重排序）</td>
<td>✅（临界区内外不重排）</td>
<td>✅（构造函数内）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>低开销</td>
<td>中-高开销</td>
<td>零开销</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>状态标志、DCL</td>
<td>临界区保护</td>
<td>不可变对象</td>
</tr>
</tbody>
</table>
<h3 id="实际编程建议">实际编程建议</h3>
<ol>
<li><strong>优先使用不可变对象</strong>：<code>final</code> 字段 + 不可变类，天然线程安全</li>
<li><strong>其次使用 volatile</strong>：适合简单的状态标志和发布不可变对象</li>
<li><strong>需要复合操作时使用 synchronized 或 Lock</strong>：保证原子性</li>
<li><strong>考虑使用 java.util.concurrent</strong>：<code>AtomicInteger</code>、<code>ConcurrentHashMap</code> 等已经处理好了并发问题</li>
<li><strong>注意伪共享</strong>：高性能场景下使用 <code>@Contended</code> 或手动填充</li>
</ol>
<hr>
<h2 id="总结">总结</h2>
<table>
<thead>
<tr>
<th>层次</th>
<th>概念</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>硬件</strong></td>
<td>CPU 缓存 + MESI 协议</td>
<td>保证缓存一致性</td>
</tr>
<tr>
<td><strong>硬件</strong></td>
<td>Store Buffer + Invalidate Queue</td>
<td>提升性能，但引入可见性问题</td>
</tr>
<tr>
<td><strong>硬件</strong></td>
<td>内存屏障指令</td>
<td>限制重排序，恢复可见性</td>
</tr>
<tr>
<td><strong>JVM</strong></td>
<td>volatile / synchronized / final</td>
<td>将内存屏障封装为语言级语义</td>
</tr>
<tr>
<td><strong>JMM</strong></td>
<td>Happens-Before 规则</td>
<td>为程序员提供可见性保证</td>
</tr>
</tbody>
</table>
<p><strong>核心认知</strong>：并发可见性问题的根源不是&quot;线程切换&quot;，而是 <strong>CPU 缓存和写缓冲区导致的数据不一致</strong>。volatile 和 synchronized 通过插入内存屏障，强制将数据从 Store Buffer 刷出到缓存/主内存，并处理 Invalidate Queue 中的失效请求，从而保证可见性。</p>
<h2 id="参考资料">参考资料</h2>
<blockquote>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.cs.umd.edu/~pugh/java/memoryModel/jsr133.pdf">JSR-133: Java Memory Model and Thread Specification</a></li>
<li><a target="_blank" rel="noopener" href="https://jcip.net/">Java Concurrency in Practice - Brian Goetz</a></li>
<li><a target="_blank" rel="noopener" href="https://www.morganclaypool.com/doi/abs/10.2200/S00346ED1V01Y201104CAC018">A Primer on Memory Consistency and Cache Coherence</a></li>
<li><a target="_blank" rel="noopener" href="https://www.puppetmastertrading.com/images/hwViewForSwHackers.pdf">Memory Barriers: a Hardware View for Software Hackers</a></li>
<li><a target="_blank" rel="noopener" href="https://lmax-exchange.github.io/disruptor/disruptor.html">Disruptor 技术白皮书</a></li>
<li><a target="_blank" rel="noopener" href="https://gee.cs.oswego.edu/dl/jmm/cookbook.html">Doug Lea - The JSR-133 Cookbook for Compiler Writers</a></li>
</ul>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2025/07/29/MESI-%E5%8D%8F%E8%AE%AE%E4%B8%8E-Java-%E5%B9%B6%E5%8F%91%E5%8F%AF%E8%A7%81%E6%80%A7/">https://magicliang.github.io/2025/07/29/MESI-%E5%8D%8F%E8%AE%AE%E4%B8%8E-Java-%E5%B9%B6%E5%8F%91%E5%8F%AF%E8%A7%81%E6%80%A7/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">并发编程</a><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/">计算机体系结构</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-176.jpeg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2020/04/01/ThreadLocal-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" title="ThreadLocal 的设计模式"><img class="cover" src="/img/wall-paper-107.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-01</div><div class="info-item-2">ThreadLocal 的设计模式</div></div><div class="info-2"><div class="info-item-1">ThreadLocal 是 Java 并发编程中实现**线程封闭（Thread Confinement）**的核心工具。本文将从原理到实践，系统性地讲解 ThreadLocal 的设计哲学、内部机制、使用模式以及跨线程传递方案。 原理篇：ThreadLocal 的内部机制 核心设计理念：为什么不用 Map&lt;Thread, Value&gt;？ 很多人初次设计线程本地存储时，会想到用一个全局的 Map&lt;Thread, Value&gt; 来存储每个线程的数据。但这种设计有致命缺陷：Thread 对象会被 Map 强引用，导致线程无法被 JVM 回收，造成严重的内存泄漏。 ThreadLocal 采用了相反的设计：让 Thread 持有 Map，而不是让 Map 持有 Thread。每个 Thread 内部都有一个 ThreadLocalMap，用于存储该线程的所有线程本地变量。这样设计的好处是：  线程销毁时，ThreadLocalMap 随之销毁，数据自动清理 ThreadLocal 对象可以被显式管理（如声明为静态变量） 线程内部的存储容器是隐式的，由线程自己管理 ...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-39.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2017/11/30/Java%E4%B8%AD%E7%9A%84%E5%B9%BD%E7%81%B5%E7%B1%BB%E5%9E%8B/" title="Java中的幽灵类型"><img class="cover" src="/img/wall-paper-167.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-30</div><div class="info-item-2">Java中的幽灵类型</div></div><div class="info-2"><div class="info-item-1">什么是幽灵类型 先上结论：幽灵类型（Phantom Type）顾名思义，就是幽灵般的类型，这种类型往往在运行时可以消失，因为在运行时没有任何作用，它们最大的特点就是没有任何实例（Java 的 Void 就是一个不可实例化类型的例子，常被用作幽灵类型的类型参数，如 Future&lt;Void&gt;）。幽灵类型是一种可以把有些运行时才能检测到的错误，在编译时检测出来的技巧。按照有些老外的观点，就是&quot;Making Wrong Code Look Wrong&quot;。在面向对象的编程语言之中，幽灵类型的实现，往往与状态模式较为接近，但比状态模式提供了更强的纠错功能。在 Java 5 以后的版本里，程序员可以使用泛型。通过泛型的类型参数，Java 中也拥有了幽灵类型的能力。 上面的阐述是不是很难看懂？直接进入具体的例子。假设有一个飞机控制程序，操作飞机起飞或者落地。这个程序有一个非常强的业务约束，就是必须保证飞机一开始必须出现在地上，只有在地上的飞机可以起飞，只有起飞的飞机可以落地，那么应该怎样设计程序（主要是类型关系），来保证这个约束必然成立呢？ 定义状态接口 先来定义...</div></div></div></a><a class="pagination-related" href="/2018/05/29/JPA-%E7%9A%84-id-%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/" title="JPA 的 id 生成策略"><img class="cover" src="/img/wall-paper-59.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-05-29</div><div class="info-item-2">JPA 的 id 生成策略</div></div><div class="info-2"><div class="info-item-1">JPA 有一个@GeneratedValue注解，有一个strategy attribute，如 @GeneratedValue(strategy = GenerationType.IDENTITY)。 常见的可选策略主要有IDENTITY和SEQUENCE。 GenerationType.IDENTITY 要求底层有一个 integer 或者 bigint 类型的自增列（ auto-incremented column)。自增列的赋值必须在插入操作之后发生，因为这个原因，Hibernate 无法进行各种优化（特别是 JDBC 的 batch 处理，一次 flush 操作会产生很多条insert 语句，分别执行）。如果事务回滚，自增列的值就会被丢弃。数据库在这个自增操作上有个高度优化的轻量级锁机制，性能非常棒。 MySQL 支持这种 id 生成策略， 使用 MySQL 应该尽量使用这个策略，即使它无法优化。 JPA 用它生成 id，会一条一条地插入新的 entity。 GenerationType.SEQUENCE 数据库有一个所谓的 sequence 对象，可以通过 selec...</div></div></div></a><a class="pagination-related" href="/2018/06/19/%E5%A6%82%E4%BD%95%E5%81%9A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8B%E7%9A%84%E7%AD%94%E6%A1%88/" title="如何做性能测试的问题下的答案"><img class="cover" src="/img/wall-paper-88.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-06-19</div><div class="info-item-2">如何做性能测试的问题下的答案</div></div><div class="info-2"><div class="info-item-1">试着回答一下这个问题。 首先要划分系统类型：有状态还是无状态，业务系统还是存储系统。根据不同的业务场景，设立性能测试的目标：是要测 QPS，还是 TPS 还是 TPS，还是任何其他【性能】-从广义来讲，一个存储系统到底能够以多高的平均时延来管理大多的存储空间，可能也是性能的一种。 有了性能测试的目标，接下来就是拆解用例。如果把性能测试归为测试的话，测试就需要测试用例，测试用例只是用例的形式化表达。把用户的使用场景勾勒出来，把每一步拆解成的流程图或者时序图–我们已经得到了一个纸上的集成测试计划，只是没有跟性能挂上钩。 接下来就进入真正写测试用例的环节了。 我们的测试报告如果要涵盖足够立体的信息，则既要了解每一个环节/接口/API 的性能指标，又要了解整体的性能指标。 这个时候测试工具的覆盖面就很重要了。如果我们选择偏黑盒的测试工具，apache ab /JMeter，则我们的测试用例就要围绕着对外交互的 API写，也只能测到外围接口的性能。这样的测试用例写起来最简单，无需侵入任何内部代码中。 如果我们使用了 JMH 一类的工具，则可以自由编写对任何方法的测试用例。但需要对系统有非常...</div></div></div></a><a class="pagination-related" href="/2018/09/07/%E6%97%A5%E6%9C%9F%E4%B8%8E%E6%97%B6%E9%97%B4/" title="日期与时间"><img class="cover" src="/img/wall-paper-86.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-09-07</div><div class="info-item-2">日期与时间</div></div><div class="info-2"><div class="info-item-1">JSR 310 Java Date与Time API 新旧 API 的更迭 旧的 Java API 主要包括java.util.Date和java.util.Calendar 两个包的内容。这两个包的时间类型是可变的。如 Date 的实例可以通过 setYear 来产生变化。 JSR 310 中包括的日期类型主要有：  计算机时间：Instant，对应 java.util.Date，它代表了一个确定的时间点，即相对于标准Java纪元（1970年1月1日）的偏移量；但与java.util.Date类不同的是其精确到了纳秒级别。 人类时间：对应于人类自身的观念，比如LocalDate和LocalTime。他们代表了一般的时区概念，要么是日期（不包含时间），要么是时间（不包含日期），类似于java.sql的表示方式。此外，还有一个MonthDay，它可以存储某人的生日（不包含年份）。每个类都在内部存储正确的数据而不是像java.util.Date那样利用午夜12点来区分日期，利用1970-01-01来表示时间。这些类型的实例是 immutable 的，而且只能通过工厂方法创建。  时区...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#part-1-cpu-%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">Part 1: CPU 缓存架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-cpu-%E7%BC%93%E5%AD%98"><span class="toc-number">1.1.</span> <span class="toc-text">为什么需要 CPU 缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">多级缓存架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E8%A1%8C-cache-line"><span class="toc-number">1.3.</span> <span class="toc-text">缓存行（Cache Line）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mesi-%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">2.</span> <span class="toc-text">MESI 协议的必要性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%9A%84%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9C%BA%E6%99%AF"><span class="toc-number">2.1.</span> <span class="toc-text">详细的状态转换场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BA%BF%E5%97%85%E6%8E%A2-bus-snooping"><span class="toc-number">2.2.</span> <span class="toc-text">总线嗅探（Bus Snooping）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-3-store-buffer-%E4%B8%8E-invalidate-queue"><span class="toc-number">3.</span> <span class="toc-text">Part 3: Store Buffer 与 Invalidate Queue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-mesi-%E8%BF%98%E4%B8%8D%E5%A4%9F"><span class="toc-number">3.1.</span> <span class="toc-text">为什么 MESI 还不够</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#invalidate-queue-%E5%A4%B1%E6%95%88%E9%98%9F%E5%88%97"><span class="toc-number">3.2.</span> <span class="toc-text">Invalidate Queue（失效队列）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E6%8E%92%E5%BA%8F%E7%9A%84%E6%A0%B9%E6%BA%90"><span class="toc-number">3.3.</span> <span class="toc-text">重排序的根源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-4-%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-memory-barrier"><span class="toc-number">4.</span> <span class="toc-text">Part 4: 内存屏障（Memory Barrier）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">4.1.</span> <span class="toc-text">什么是内存屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x86-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.2.</span> <span class="toc-text">x86 的内存模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arm-risc-v-%E7%9A%84%E5%BC%B1%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text">ARM&#x2F;RISC-V 的弱内存模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-5-java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B-jmm"><span class="toc-number">5.</span> <span class="toc-text">Part 5: Java 内存模型（JMM）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#jmm-%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">5.1.</span> <span class="toc-text">JMM 的设计目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmm-%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">JMM 的抽象模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happens-before-%E5%85%B3%E7%B3%BB"><span class="toc-number">5.3.</span> <span class="toc-text">Happens-Before 关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happens-before-%E4%B8%8D%E7%AD%89%E4%BA%8E%E6%97%B6%E9%97%B4%E4%B8%8A%E7%9A%84%E5%85%88%E5%90%8E"><span class="toc-number">5.4.</span> <span class="toc-text">Happens-Before 不等于时间上的先后</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-6-volatile-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">Part 6: volatile 的实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="toc-number">6.1.</span> <span class="toc-text">volatile 的语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E7%9A%84%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">6.2.</span> <span class="toc-text">volatile 的内存屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E5%9C%A8-x86-%E4%B8%8A%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.3.</span> <span class="toc-text">volatile 在 x86 上的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8"><span class="toc-number">6.4.</span> <span class="toc-text">volatile 的典型应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-7-synchronized-%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="toc-number">7.</span> <span class="toc-text">Part 7: synchronized 的内存语义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E7%9A%84%E4%B8%89%E9%87%8D%E4%BF%9D%E8%AF%81"><span class="toc-number">7.1.</span> <span class="toc-text">synchronized 的三重保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E7%9A%84%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">7.2.</span> <span class="toc-text">synchronized 的内存屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E7%9A%84%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-number">7.3.</span> <span class="toc-text">synchronized 的锁升级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-8-%E4%BC%AA%E5%85%B1%E4%BA%AB-false-sharing"><span class="toc-number">8.</span> <span class="toc-text">Part 8: 伪共享（False Sharing）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">8.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%9A%E7%BC%93%E5%AD%98%E8%A1%8C%E5%A1%AB%E5%85%85"><span class="toc-number">8.2.</span> <span class="toc-text">解决方案：缓存行填充</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%A1%88%E4%BE%8B"><span class="toc-number">8.3.</span> <span class="toc-text">实际案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-9-final-%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="toc-number">9.</span> <span class="toc-text">Part 9: final 的内存语义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final-%E5%AD%97%E6%AE%B5%E7%9A%84%E7%89%B9%E6%AE%8A%E4%BF%9D%E8%AF%81"><span class="toc-number">9.1.</span> <span class="toc-text">final 字段的特殊保证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%AD%E7%9A%84-this-%E9%80%B8%E5%87%BA"><span class="toc-number">9.2.</span> <span class="toc-text">构造函数中的 this 逸出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#part-10-%E4%BB%8E%E7%A1%AC%E4%BB%B6%E5%88%B0-jmm-%E7%9A%84%E5%AE%8C%E6%95%B4%E6%98%A0%E5%B0%84"><span class="toc-number">10.</span> <span class="toc-text">Part 10: 从硬件到 JMM 的完整映射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%9B%A0%E6%9E%9C%E9%93%BE"><span class="toc-number">10.1.</span> <span class="toc-text">完整的因果链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-vs-synchronized-vs-final"><span class="toc-number">10.2.</span> <span class="toc-text">volatile vs synchronized vs final</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E7%BC%96%E7%A8%8B%E5%BB%BA%E8%AE%AE"><span class="toc-number">10.3.</span> <span class="toc-text">实际编程建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">11.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99"><span class="toc-number">12.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>