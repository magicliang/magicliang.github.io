<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>MySQL 存储引擎 InnoDB 技术内幕 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这本书的电子版的一个博客。 InnoDB.xmind  前言 MySQL 是处理海量数据（尤其 是OLTP 写入）时仍能获得最佳性能的最佳选择之一，它的 CPU 效率可能其他任何基于磁盘的关系型数据库所不能匹敌的-但它应该能够匹敌 Redis。 Think Different 而不是 Think Differently，这意味着要思考不同的东西，而不只是思考不同的方式。 不要相信网上的传言，去做测">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL 存储引擎 InnoDB 技术内幕">
<meta property="og:url" content="https://magicliang.github.io/2021/03/28/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="这本书的电子版的一个博客。 InnoDB.xmind  前言 MySQL 是处理海量数据（尤其 是OLTP 写入）时仍能获得最佳性能的最佳选择之一，它的 CPU 效率可能其他任何基于磁盘的关系型数据库所不能匹敌的-但它应该能够匹敌 Redis。 Think Different 而不是 Think Differently，这意味着要思考不同的东西，而不只是思考不同的方式。 不要相信网上的传言，去做测">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2021/03/28/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/InnoDBStructure.png">
<meta property="article:published_time" content="2021-03-28T08:22:25.000Z">
<meta property="article:modified_time" content="2026-01-24T07:32:07.176Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="MySQL">
<meta property="article:tag" content="数据库">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2021/03/28/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/InnoDBStructure.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "MySQL 存储引擎 InnoDB 技术内幕",
  "url": "https://magicliang.github.io/2021/03/28/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/",
  "image": "https://magicliang.github.io/2021/03/28/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/InnoDBStructure.png",
  "datePublished": "2021-03-28T08:22:25.000Z",
  "dateModified": "2026-01-24T07:32:07.176Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2021/03/28/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL 存储引擎 InnoDB 技术内幕',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2021/03/28/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/InnoDBStructure.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">MySQL 存储引擎 InnoDB 技术内幕</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">MySQL 存储引擎 InnoDB 技术内幕</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-03-28T08:22:25.000Z" title="Created 2021-03-28 16:22:25">2021-03-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T07:32:07.176Z" title="Updated 2026-01-24 15:32:07">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">12.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>45mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wade-luffy/p/6289448.html">这本书的电子版的一个博客</a>。</p>
<p><a href="InnoDB.xmind">InnoDB.xmind</a><br>
<img src="InnoDB.png" alt="InnoDB"></p>
<h1>前言</h1>
<p>MySQL 是处理海量数据（尤其 是OLTP 写入）时仍能获得最佳性能的最佳选择之一，它的 CPU 效率可能其他任何基于磁盘的关系型数据库所不能匹敌的-但它应该能够匹敌 Redis。</p>
<p>Think Different 而不是 Think Differently，这意味着要思考不同的东西，而不只是思考不同的方式。</p>
<p>不要相信网上的传言，去做测试，根据自己的实践做决定。很多伟大的作者写的伟大的书里面，关于性能的说法都来源于他们个人的随身电脑的直观测试。</p>
<p>change buffer 是 inert buffer 的升级版本。</p>
<h1>MySQL 体系结构和存储引擎</h1>
<h2 id="定义数据库和实例">定义数据库和实例</h2>
<ul>
<li>数据库：物理操作系统文件或其他形式文件类型的集合。</li>
<li>实例：操作系统后台进程（线程和一堆共享内存）。</li>
<li>存储引擎：基于表而不是基于库的，所以一个库可以有不同的表使用不同的存储引擎。</li>
</ul>
<p>InnoDB 将数据存储在逻辑的表空间中，这个表空间就像黑盒一样。</p>
<p>存储引擎不一定需要事务。比如没有 ETL 的操作，单纯的查询操作不需要考虑并发控制问题，不需要产生一致性视图。</p>
<p>NDB 存储引擎是一个集群存储引擎，类似 RAC 集群。不过与 Oracle RAC share everything 不同，NDB share nothing，而且把数据放在内存中。</p>
<p><strong>如果不需要事务，文件系统就可以当做数据库</strong>（这话有点以偏概全，文件系统没有做过查询优化，无格式不易于查找，SQL 的 structure 体现不出来）。数据库区别于文件系统的地方就是，数据库可以支持事务（不代表必然使用事务）。</p>
<p>用户可以按照文档 16 章自己写自己的存储引擎。</p>
<h1>InnoDB 的存储引擎</h1>
<p>InnoDB 是 transactional-safe 的 MySQL 存储引擎。</p>
<h2 id="innodb-存储引擎概述">InnoDB 存储引擎概述</h2>
<p>InnoDB 当前支持每秒 800 次的写入，也可以存储 1tb 以上的数据。</p>
<p>InnoDB 的体系结构可以大体包括：</p>
<p>后台线程 + 内存池 + 文件</p>
<p><img src="innodb%E6%9E%B6%E6%9E%84.jpg" alt="innodb架构"></p>
<h3 id="后台线程包括">后台线程包括</h3>
<h4 id="master-thread">master thread</h4>
<p><img src="%E4%B8%BB%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B.jpg" alt="主循环流程"></p>
<p>负责异步地将缓冲池中的数据异步地刷新到磁盘，dirty page refresh、merging insert buffer。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++) &#123;<br>    thread_sleep(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">do</span> <span class="hljs-built_in">log</span> buffer flush to disk<br>    <span class="hljs-title function_">if</span> <span class="hljs-params">( last_one_second_ios &lt; <span class="hljs-number">5</span>)</span> &#123;<br>        <span class="hljs-keyword">do</span> merge at most <span class="hljs-number">5</span> insert buffer<br>    &#125;<br>    <span class="hljs-keyword">if</span> (buf_get_modified_ratio_pct &gt; innodb_max_ditry_pages_pct) &#123;<br>        <span class="hljs-keyword">do</span> buffer pool flush <span class="hljs-number">100</span> dirty page<br>    &#125;<br>    <span class="hljs-keyword">if</span> (no user activity) &#123;<br>        <span class="hljs-keyword">goto</span> background loop<br>    &#125;<br>&#125;<br><span class="hljs-keyword">if</span> (last_ten_second_ios &lt; <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-keyword">do</span> buffer pool flush <span class="hljs-number">100</span> dirty page<br>&#125;<br><span class="hljs-keyword">do</span> merge at most <span class="hljs-number">5</span> insert buffer<br><span class="hljs-keyword">do</span> <span class="hljs-built_in">log</span> buffer flush to disk<br><span class="hljs-keyword">do</span> full pourge<br><span class="hljs-title function_">if</span> <span class="hljs-params">(buf_get_modifued_ratio_pct &gt; <span class="hljs-number">70</span>%)</span> &#123;<br>    <span class="hljs-keyword">do</span> buffer pool flush <span class="hljs-number">100</span> dirty page<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    buffer pool flush <span class="hljs-number">10</span> dirty page<br>&#125;<br><span class="hljs-keyword">do</span> fuzzy checkpoint<br><span class="hljs-keyword">goto</span> loop<br><br><br><span class="hljs-type">void</span> master_thread()<br>&#123;<br><span class="hljs-type">int</span> innodb_io_capacity = <span class="hljs-number">200</span> ；<span class="hljs-comment">//表示磁盘IO吞吐量</span><br><span class="hljs-type">int</span> innodb_max_dirty_pages_pct = <span class="hljs-number">75</span> ；<span class="hljs-comment">//最大脏页百分比</span><br><span class="hljs-keyword">goto</span> loop;<br>loop:<br><span class="hljs-comment">//1秒循环</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = o; i&lt;<span class="hljs-number">10</span>; i++)<br>&#123;<br>thread_sleep(<span class="hljs-number">1</span>);<span class="hljs-comment">//innodb 优化，压力大时不总是等待1秒</span><br><span class="hljs-comment">//日志缓冲刷新到磁盘</span><br><span class="hljs-keyword">do</span> <span class="hljs-built_in">log</span> buffer flush to disk;<br><span class="hljs-comment">//如果磁盘压力小，合并插入缓冲</span><br><span class="hljs-keyword">if</span> ( last_one_second_ios &lt; innodb_io_capacity*<span class="hljs-number">5</span>%  )<br>&#123;<br><span class="hljs-keyword">do</span> merge at most innodb_io_capacity*<span class="hljs-number">5</span>% insert buffer;<br>&#125;<br><span class="hljs-comment">//判断脏页比例</span><br><span class="hljs-keyword">if</span> ( buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct )<br>&#123;<br><span class="hljs-keyword">do</span> buffer pool flush innodb_io_capacity*<span class="hljs-number">100</span>% dirty page;<br>&#125;<br><span class="hljs-comment">//如果开启自适应刷新，通过判断产生重做日志的速度来判断合适的刷新脏页数量</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> enable adaptive flush<br>&#123;<br><span class="hljs-keyword">do</span> buffer pool flush desired amount dirty page;<br>&#125;<br><span class="hljs-comment">//如果无用户活动，切换到 backgroud loop</span><br><span class="hljs-keyword">if</span> ( no user activity )<br>&#123;<br><span class="hljs-keyword">goto</span> backgroud loop;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//10秒循环</span><br><span class="hljs-comment">//如果磁盘压力小，刷新innodb_io_capacity*100%的脏页到磁盘</span><br><span class="hljs-keyword">if</span> ( last_ten_second_ios &lt; innodb_io_capacity )<br>&#123;<br><span class="hljs-keyword">do</span> buffer pool flush innodb_io_capacity*<span class="hljs-number">100</span>% dirty page; <br>&#125;<br><span class="hljs-comment">//合并插入缓冲</span><br><span class="hljs-keyword">do</span> merge at most innodb_io_capacity*<span class="hljs-number">5</span>% insert buffer;<br><span class="hljs-comment">//日志缓冲刷新到磁盘</span><br><span class="hljs-keyword">do</span> <span class="hljs-built_in">log</span> buffer flush to disk;<br><span class="hljs-comment">//删除无用undo页，每次最多删除20个undo页</span><br><span class="hljs-keyword">do</span> full purge;<br><span class="hljs-comment">//判断脏页比例</span><br><span class="hljs-keyword">if</span> ( buf_get_modified_ratio_pct &gt;<span class="hljs-number">70</span>% )<span class="hljs-comment">//---------</span><br>&#123;<br><span class="hljs-keyword">do</span> buffer pool flush innodb_io_capacity*<span class="hljs-number">100</span>% dirty page; <br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">do</span> buffer pool flush innodb_io_capacity*<span class="hljs-number">10</span>% dirty page;<br>&#125;<br><span class="hljs-comment">//产生一个模糊检查点，只是将最老日志序列号的页写入磁盘</span><br><span class="hljs-keyword">do</span> fuzzy checkpoint;<br><span class="hljs-keyword">goto</span> loop;<br><br><span class="hljs-comment">//backgroud</span><br>backgroud loop:<br><span class="hljs-comment">//删除无用undo页</span><br><span class="hljs-keyword">do</span> full purge;<br><span class="hljs-comment">//合并插入缓冲</span><br><span class="hljs-keyword">do</span> merge innodb_io_capacity*<span class="hljs-number">100</span>% insert buffer;<br><span class="hljs-comment">//不空闲跳回主循环，空闲则进入flush loop</span><br><span class="hljs-keyword">if</span> not idle<br>&#123;<br><span class="hljs-keyword">goto</span> loop;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-keyword">goto</span> flush loop;<br>&#125;<br><br><span class="hljs-comment">//flush loop</span><br>flush loop:<br><span class="hljs-comment">//不断刷新脏页到磁盘，直到脏页比例小于innodb_max_dirty_pages_pct，则进入suspend loop</span><br><span class="hljs-keyword">do</span> buffer pool flush innodb_io_capacity*<span class="hljs-number">100</span>% dirty page;<br>    <span class="hljs-keyword">while</span> ( buf_get_modified_ratio_pct &gt; innodb_max_dirty_pages_pct );<br><span class="hljs-keyword">goto</span> suspend loop;<br><br><span class="hljs-comment">//suspend loop</span><br>suspend loop:<br>suspend_thread();<br>waiting event;<br><span class="hljs-keyword">goto</span> loop;<br>&#125; <br></code></pre></td></tr></table></figure>
<p>循环切换是用 goto 来做的，这让一个单线程的执行流程有了协程一样的多任务跳转处理能力。</p>
<h4 id="io-thread">IO thread</h4>
<p>在 InnoDB 中大量使用 AIO 来处理 IO 写请求。</p>
<h4 id="purge-thread">purge thread</h4>
<p>purge 操作是从 master thread 里单独分离出来的一部分职能，专门处理 undo log。</p>
<h4 id="page-cleaner-thread">page cleaner thread</h4>
<p>定时将之前版本中的 dirty page refresh 的职责分离出来。</p>
<h3 id="内存">内存</h3>
<p>要懂得看内存要懂得看各种监控：</p>
<p><img src="MySQL%E7%94%A8%E6%88%B7%E7%BB%9F%E8%AE%A1.jpg" alt="MySQL用户统计"><br>
<img src="MySQL%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%9F%E8%AE%A1.jpg" alt="MySQL客户端统计"><br>
<img src="MySQL%E7%9B%91%E6%8E%A71.jpg" alt="MySQL监控1"><br>
<img src="MySQL%E7%9B%91%E6%8E%A72.jpg" alt="MySQL监控2"></p>
<p>如果有必要，要直接看 InnoDB 的状态<code>show engine innodb status</code></p>
<blockquote>
<h1>Type    Name    Status InnoDB</h1>
<h1>===================================== 2022-03-05 16:04:44 0x70000dda3000 INNODB MONITOR OUTPUT<br>
===================================== Per second averages calculated from the last 0 seconds<br>
----------------- BACKGROUND THREAD<br>
----------------- srv_master_thread loops: 6 srv_active, 0 srv_shutdown, 110008 srv_idle srv_master_thread log flush and writes:<br>
0<br>
---------- SEMAPHORES<br>
---------- OS WAIT ARRAY INFO: reservation count 2 OS WAIT ARRAY INFO: signal count 2 RW-shared spins 0, rounds 0, OS waits 0 RW-excl spins<br>
0, rounds 0, OS waits 0 RW-sx spins 0, rounds 0, OS waits 0 Spin<br>
rounds per wait: 0.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx<br>
------------ TRANSACTIONS<br>
------------ Trx id counter 6151 Purge done for trx’s n:o &lt; 6149 undo n:o &lt; 0 state: running but idle History list length 0 LIST OF<br>
TRANSACTIONS FOR EACH SESSION:<br>
—TRANSACTION 421658550605264, not started 0 lock struct(s), heap size 1128, 0 row lock(s)<br>
—TRANSACTION 421658550604472, not started 0 lock struct(s), heap size 1128, 0 row lock(s)<br>
—TRANSACTION 421658550603680, not started 0 lock struct(s), heap size 1128, 0 row lock(s)<br>
—TRANSACTION 421658550602888, not started 0 lock struct(s), heap size 1128, 0 row lock(s)<br>
—TRANSACTION 421658550602096, not started 0 lock struct(s), heap size 1128, 0 row lock(s)<br>
—TRANSACTION 421658550601304, not started 0 lock struct(s), heap size 1128, 0 row lock(s)<br>
-------- FILE I/O<br>
-------- I/O thread 0 state: waiting for i/o request (insert buffer thread) I/O thread 1 state: waiting for i/o request (log thread) I/O<br>
thread 2 state: waiting for i/o request (read thread) I/O thread 3<br>
state: waiting for i/o request (read thread) I/O thread 4 state:<br>
waiting for i/o request (read thread) I/O thread 5 state: waiting for<br>
i/o request (read thread) I/O thread 6 state: waiting for i/o request<br>
(write thread) I/O thread 7 state: waiting for i/o request (write<br>
thread) I/O thread 8 state: waiting for i/o request (write thread) I/O<br>
thread 9 state: waiting for i/o request (write thread) Pending normal<br>
aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,  ibuf aio reads:,<br>
log i/o’s:, sync i/o’s: Pending flushes (fsync) log: 0; buffer pool: 0<br>
937 OS file reads, 467 OS file writes, 58 OS fsyncs<br>
0.00 reads/s, 0 avg bytes/read, 0.00 writes/s, 0.00 fsyncs/s<br>
------------------------------------- INSERT BUFFER AND ADAPTIVE HASH INDEX<br>
------------------------------------- Ibuf: size 1, free list len 0, seg size 2, 0 merges merged operations:  insert 0, delete mark 0,<br>
delete 0 discarded operations:  insert 0, delete mark 0, delete 0 Hash<br>
table size 34679, node heap has 0 buffer(s) Hash table size 34679,<br>
node heap has 0 buffer(s) Hash table size 34679, node heap has 0<br>
buffer(s) Hash table size 34679, node heap has 0 buffer(s) Hash table<br>
size 34679, node heap has 0 buffer(s) Hash table size 34679, node heap<br>
has 0 buffer(s) Hash table size 34679, node heap has 2 buffer(s) Hash<br>
table size 34679, node heap has 6 buffer(s)<br>
0.00 hash searches/s, 0.00 non-hash searches/s<br>
— LOG<br>
— Log sequence number          19606903 Log buffer assigned up to    19606903 Log buffer completed up to   19606903 Log written up to<br>
19606903 Log flushed up to            19606903 Added dirty pages up to<br>
19606903 Pages flushed up to          19606903 Last checkpoint at<br>
19606903 23 log i/o’s done, 0.00 log i/o’s/second<br>
---------------------- BUFFER POOL AND MEMORY<br>
---------------------- Total large memory allocated 0 Dictionary memory allocated 390927 Buffer pool size   8192 # 注意：意味着总共有8192个页（通常是16k一页） Free buffers 0 # 注意：Free List 为 0<br>
7040 Database pages     1144 Old database pages 402 Modified db pages # 注意：缓冲池里面有7040个数据（库）页，这就是 LRU list 的总长度<br>
0 Pending reads      0 Pending writes: LRU 0, flush list 0, single<br>
page 0 Pages made young 20, not young 0 # 注意：Made Young 意味着从 LRU 的队尾淘汰了一页，加入 new 里。这里 Made Young 发生了 20 次。<br>
0.00 youngs/s, 0.00 non-youngs/s Pages read 914, created 233, written 351<br>
0.00 reads/s, 0.00 creates/s, 0.00 writes/s No buffer pool page gets since the last printout Pages read ahead 0.00/s, evicted without<br>
access 0.00/s, Random read ahead 0.00/s LRU len: 1144, unzip_LRU len:<br>
0 I/O sum[0]:cur[0], unzip sum[0]:cur[0]<br>
-------------- ROW OPERATIONS<br>
-------------- 0 queries inside InnoDB, 0 queries in queue 0 read views open inside InnoDB Process ID=153, Main thread ID=0x70000d0ec000<br>
, state=sleeping Number of rows inserted 16568, updated 0, deleted 0,<br>
read 16568<br>
0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s Number of system rows inserted 0, updated 315, deleted 0, read 6557<br>
0.00 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.00 reads/s<br>
---------------------------- END OF INNODB MONITOR OUTPUT</h1>
</blockquote>
<p>not young 0 意味着没有 made young 失败的情况，这通常意味着 innodb_old_blocks_time 这个 old block 最小时间为0。</p>
<p>这个统计只统计过去一段时间的状态（ Per second averages calculated from the last 0 seconds），而非当前状态。</p>
<p>大规模的查询（如归档）会导致 LRU 列表大规模刷新，一定程度上会让 buffer pool hit rate 指标下降（低于95%对性能的影响会非常显著）-可以一定程度上被 MRR （Multi-Range-Read）解决。</p>
<p>LRU len: 1144, unzip_LRU len: 0，意味着 16k的页有1144个，其中压缩页（2k、4k、8k）0个（LRU list 包含 unzip list）。</p>
<p><strong>History list length 意味着 undo log 的数量。</strong></p>
<h4 id="缓冲池">缓冲池</h4>
<p><code>innodb_buffer_pool_instances</code>可以控制缓冲池的实例数。</p>
<p>为了<strong>弥合 cpu 和磁盘的性能鸿沟</strong>，基于磁盘的数据库必然引入内存缓冲池，<strong>让页的读和写操作都快一点</strong>。</p>
<p>主要的内存缓冲池有：</p>
<ul>
<li>innodb_buffer_pool</li>
<li>redo_log_buffer</li>
<li>innodb_additional_mem_pool_size</li>
</ul>
<p>有了内存缓冲池，就允许出现脏页。把脏页刷新到磁盘上，是通过 checkpoint 机制实现的。</p>
<h4 id="lru-list-free-list-和-flush-list">LRU List、Free List 和 Flush List</h4>
<p>InnoDB 使用这三种 list，来调度不同的脏页。</p>
<p>所有的数据页，调度进内存，都要调度进 LRU List 里（调度进某个 midpoint）。所以，有时候查询数据会导致新页加载进内存，脏页刷盘，引发 checkpoint。</p>
<h5 id="lru-list">LRU List</h5>
<p>InnoDB 使用改进的 LRU 算法，<code>SHOW VARIABLES LIKE '%innodb_old_blocks_pct%'</code>可以看到新加载的页会被放到列表<strong>队尾</strong>的百分之几的位置（通常为37，也就是说，新页后都是老页，老页总共占据37%的比例），而不是队头，这个位置被称为 midpoint。</p>
<p>new list（真正的热数据占全部数据量的63%） -&gt; midpoint -&gt; old list</p>
<p>这种 midpoint 设计保证了：首次被触达 hot 数据不会导致其他热点数据页被淘汰。某些 ad-hoc的大规模查询的数据页也需要经过时间考验才会被提升到真正的热页上。</p>
<h5 id="free-list">Free list</h5>
<p>Free list 管理了最原始的页，LRU list 需要页的时候，先从 free list 取内存。取完以后，再做淘汰 old list，移动页到 new list 的操作。</p>
<h5 id="flush-list">Flush list</h5>
<h4 id="redo-log-buffer">redo log buffer</h4>
<p>这个 buffer 是 wal 写入磁盘之前的 buffer。注意 wal 的 buffer 刷新到磁盘，不是脏页的刷新到磁盘（checkpoint 实际上就是 dirty page refresh）。</p>
<p>通常情况下，每一秒钟这个 buffer 会被刷新到磁盘上（通过 page cleaner thread），只要用户每秒产生的事务量在这个缓冲大小之内即可。</p>
<p>总共有三种情况下会发生内容刷新：</p>
<ul>
<li>一秒定时</li>
<li>事务提交</li>
<li>buffer 的大小小于 1/2时</li>
</ul>
<p>这代表了几种策略：</p>
<ul>
<li>时间</li>
<li>空间阈值</li>
<li>持久化事件</li>
<li>轮询</li>
</ul>
<h4 id="additional-mem-pool">additional mem pool</h4>
<p>管理一些 buffer controll block。</p>
<h2 id="checkpoint-技术">checkpoint 技术</h2>
<p><img src="%E4%BA%8B%E5%8A%A1%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.jpg" alt="事务执行过程"></p>
<p>checkpoint 和 redo log buffer 都是 redo log 机制的一部分，现将全机制完整叙述如下：</p>
<ol>
<li>MySQL 为了性能，大部分的操作都需要在 buffer pool 里面执行。</li>
<li>但操作对于数据的修改却必须正确地持久化（保证 A 和 D）。</li>
<li>事务对于buffer pool 的数据页的修改，在提交之前，必须保证所有的日志都写入了 redo log，而且事务的提交要求 redolog 确切地从 redo log buffer（也是环状的）被完整地写入到 redo log file （这是环状的）里，这意味着 WAL 写完了。</li>
<li>表面上看起来，有了 redo log，连修改磁盘上的数据页也不需要了。因为 redo log 只要无限大，只要保证 redo log 被写入就行。但实际上资源并不是无限的，而且只使用 redo log 数据库的灾害恢复时长会无限长，所以 redo log 里蕴藏的修改应该尽力被刷新到磁盘上。</li>
<li>我们可以简单认为，buffer pool 的修改和 wal 的写入是同时的，wal 从 redo log buffer flush 到 disk 之后才能 commit 成功。checkpoint 意味着 buffer pool 的修改被同步到磁盘里。</li>
<li>checkpoint 保证，在灾难恢复时，过了 checkpoint 的 redo 日志才需要关注。这样可以减少宕机恢复时间。</li>
<li>重做日志不可能无限被使用（<strong>环状意味着有限</strong>），所以一旦要重用重做日志，必然带来强制的 checkpoint，导致脏页至少被刷新到 redo log 当前的位置。</li>
<li>**checkpoint 只做一件事，刷新脏页到某个 LSN 上。所有的 redo log 的操作在事务提交时都做完了。**checkpoint 是“脏页刷盘”的因，而不是果。</li>
</ol>
<p>标记 redolog 的位置方法是 LSN（log sequence number）。从 checkpoint 这个概念的数值来看，是根据 LSN 来定位哪些 redo log 对应的修改已经被同步到表空间里，但 <strong>checkpoint 不是持久化 journal/wal 的日志</strong>（这些日志实际上是 tx commit 的时候 flush redo log 的时候被持久化的，也没有把 redo log merge 到表空间的技术），是<strong>刷新脏页的技术</strong>（更新表空间主要依赖于脏页）！这个细微的差别和其他 WAL 的实现还是有差别的，这是 buffer pool 相关技术带来的特定结果！</p>
<p>有以下几种情况会触发 checkpoint：</p>
<ul>
<li>Master Thread 定时刷新脏页</li>
<li>LRU 脏页列表大小不够</li>
<li>redo log 大小不够（发生recycling）</li>
<li>脏页数量太多（超过一定的阈值）</li>
<li>数据库关闭时</li>
</ul>
<p>checkpoint 和 kafka 的 offset 的设计思路一直，都是基于对 sequence number 上维护一个游标，把已确认的操作序号和未确认的操作序号隔开。</p>
<h2 id="innodb-关键特性">innodb 关键特性</h2>
<h3 id="insert-buffer">Insert Buffer</h3>
<p>Insert Buffer 既是内存缓冲池的一部分，也是物理页的一部分，<strong>同时存在于两处</strong>。</p>
<p>比较容易造成顺序插入的两种索引形式：自增主键和时间。</p>
<p>Insert Buffer 的用意是<strong>为了提升非唯一的辅助索引的插入性能</strong>。注意，主键是不需要依靠change buffer的，这侧面也说明了一个可能的设计思路：<strong>主数据的修改可以直接修改 data page 和 index page，而不需要用到 change buffer</strong>，相当于引入一个辅助平衡树，避免了对主平衡树的修改。</p>
<p>对于这种索引，为了减少随机插入，InnoDB 在插入更新数据页的时候，会想办法校验<strong>缓冲池</strong>里有没有该<strong>数据页</strong>。如果有，则先插入缓冲池里的数据页；否则，在<strong>插入缓冲</strong>里插入一个特殊的记录，欺骗（mock）全流程，然后继续剩下的 buffer pool 操作。</p>
<p><strong>Insert Buffer 里的数据页和真正索引的数据页的合并，就是 Insert Buffer 合并。</strong></p>
<h4 id="change-buffer">Change buffer</h4>
<p>Change buffer 是高版本的 MySQL 引入的，虽然 InnoDB 的状态统计里依然频繁出现 Insert Buffer 的字眼，但其实现在 Change buffer 包括：Insert Buffer、Delete Buffer、Purge Buffer（不是 Udpate Buffer，不过它也管 Update 操作，update 在 MySQL 里其实是被表达为删除和新增两种操作的叠加），囊括了所有的 DML 类型。</p>
<p><a target="_blank" rel="noopener" href="http://mysql.taobao.org/monthly/2015/07/01/">InnoDB change buffer可以对三种类型的操作进行缓存：INSERT、DELETE-MARK 、DELETE操作，前两种对应用户线程操作，第三种则由purge操作触发。</a></p>
<p>这些 Buffer 的应对对象仍然是<strong>非唯一的辅助索引</strong>。</p>
<h4 id="insert-buffer-的实现">Insert Buffer 的实现</h4>
<p>全局有一个 Insert/Change Buffer b+树，管所有的表（这样这个数据结构的复杂度会非常高，架构上这样做的 trade off 到底是什么？），存放在 ibdata 中。<strong>这就是上面说的“物理页的一个组成部分”</strong>。</p>
<p>非唯一的辅助索引在插入到数据库中时，会构造一条记录，然后插入到这棵树中。<strong>当读写发生的是，只要需要读最终数据，都要触发 merging</strong>。这种索引的性能提升借助于不做唯一性检查。</p>
<p>这种缓冲树的设计，类似于 LSM tree 的前面的缓冲层。</p>
<p>辅助索引页在在 Insert/Change Buffer 中，是通过(space,page_no)来管理的，这个数据结构记录的是真正的表空间里真正的辅助索引记录所在的位置。</p>
<p>插入、删除和更新操作会并存于一棵B+树里，所以这些“缓冲记录”之间是存在相对顺序的，按照正确的顺序 replay 才能得到真正正确的辅助索引的值。</p>
<p>所以实际上大致上可以认为存在四个区域（以下部分是猜测，书中有歧义）：</p>
<ul>
<li>内存里：Change Buffer 的内存形态，Buffer Pool 的数据页、索引页的内存形态。</li>
<li>磁盘上：Change Buffer B+ 树（按照 MySQL 官方文档的说法，<strong>这个数据结构可以帮助 MySQL 度过重启，用冷存储度过重启，也是一种经典的设计思路</strong>），辅助索引表空间</li>
</ul>
<p>buffer 里有一般的 Buffer Pool 和 Change Buffer 两种两种形态，磁盘上只有一种 redo log，所以对页的修改可以被checkpoint从内存同步到磁盘上。按照 MySQL 的官方文档，merge 应该专指从 Change Buffer 合并修改到 Buffer Pool 的数据页上（Physically, the change buffer is part of the system tablespace, so that the index changes remain buffered across database restarts. The changes are only applied (merged) when the pages are brought into the buffer pool due to some other read operation.）。</p>
<h4 id="insert-buffer-的意义">Insert Buffer 的意义</h4>
<p>高性能存储引擎使用 Insert Buffer 来获取了一些 LSM-Tree 有的优点。</p>
<h3 id="两次写-doublewrite">两次写（doublewrite）</h3>
<p><img src="double-write-buffer%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg" alt="double-write-buffer架构图"></p>
<p>写入一个数据页不一定能够原子成功。有可能发生部分写失效（partial page write）。<strong>因为 redo log 是物理日志</strong>，所以强依赖于页的状态。</p>
<p>doublewrite 的意思是，重做发生时，需要先把页副本还原出特定的页，然后再 apply redo log。</p>
<p>innodb 在刷新脏页时，会先写入 double write buffer，然后双写到表空间里的 double write extent 里，最后再用 fsync 把脏页刷新到 ibd 数据文件里。</p>
<h3 id="自适应哈希索引-ahi">自适应哈希索引（AHI）</h3>
<p>innodb 会自动根据访问的频率和模式来自动地某些热点页建立哈希索引。</p>
<p>AHI 有一定的使用场景限制：</p>
<ul>
<li>自适应哈希索引只支持等值搜索</li>
<li>索引页的访问模式很像 JIT 要求统计的访问模式，按照次数确定是否是热点页，满足要求才生成相应的 AHI。</li>
</ul>
<h3 id="异步-io">异步 io</h3>
<p>这里的异步 io 指的是用户发起的一次 sync io 可能触发多个异步io，将多个结果 merge 起来一起返回。</p>
<p>native aio 需要操作系统的支持。可以在编译的时候通过引入 libaio 库一起编译解决。</p>
<h3 id="刷新邻接页-flush-neighbor-page">刷新邻接页（flush neighbor page）</h3>
<p>机械硬盘需要这个功能，固态硬盘不怎么需要。</p>
<h2 id="启动-关闭与恢复">启动、关闭与恢复</h2>
<p>默认的情况下，MySQL 会在关闭和重启时，把脏页刷新回磁盘。所以有时候 MySQL 重启的速度可能非常慢，因为数据库的 recover 或者 repair 操作被留到了重启时。</p>
<p>数据库出现任何的 corruption，都可以在重启时的 error log 里体现出来。如果出现了大表的 corruption，修复时间可能很长。有经验的用户可能会禁用重启时的自动修复（通过 <code>innodb_force_recovery</code>），自己手动修复被破坏的表。</p>
<h1>文件</h1>
<p><img src="InnoDBStructure.png" alt="InnoDBStructure"></p>
<h2 id="参数格式">参数格式</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">SET<br>|<br>| [ global | session ] system_var_name = <span class="hljs-built_in">expr</span><br>| [ @@global. | @@session. | @@] system_var_name = <span class="hljs-built_in">expr</span><br><br>SET @@GLOBAL.read_buffer_size=1048576;<br></code></pre></td></tr></table></figure>
<p>要注意有些参数不能被修改，<strong>或者只能在会话中更改</strong>。</p>
<h2 id="binlog-格式">binlog 格式</h2>
<p>现在默认的 binlog 格式是 row。这个格式对 READ COMMITTED 并发操作行较友好，不会丢失更新，也能兼容随机函数和触发器。</p>
<h2 id="表空间">表空间</h2>
<p><img src="InnoDB%E8%A1%A8%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%96%87%E4%BB%B6.png" alt="InnoDB表存储引擎文件"></p>
<p>InnodDB 允许多张表共用若干个共享表空间，也允许每张表一个表空间。</p>
<p>由于设置参数innodb_file_per_table=ON，因此产生了单独的.ibd表空间文件。需要注意的是，这些单独的表空间文件仅存储该表的数据、索引和插入缓冲 bitmap 等信息，其余信息还是存放在默认的表空间中。</p>
<h2 id="redo-log-file">redo log file</h2>
<p>每个InnoDB存储引擎至少有1个重做日志文件组（group），每个文件组下至少有2个重做日志文件，如默认的ib_logfile0、ib_logfile1。为了得到更高的可靠性，你可以设置多个镜像日志组（mirrored log groups），将不同的文件组放在不同的磁盘上。日志组中每个重做日志文件的大小一致，并以循环方式使用。InnoDB存储引擎先写重做日志文件1，当达到文件的最后时，会切换至重做日志文件2，当重做日志文件2也被写满时，会再切换到重做日志文件1中。</p>
<p>这也是一种有意思的 double buffer 设计。</p>
<p>一个拥有3个重做日志文件的重做日志文件组：</p>
<p><img src="%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E7%BB%84.png" alt="重做日志组"></p>
<p><img src="%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E5%86%99%E5%85%A5%E8%BF%87%E7%A8%8B.png" alt="重做日志写入过程"></p>
<p>每次写入一段重做日志只写512Byte，大小为一个扇区，<strong>不会出现部分写失败</strong>，所以此处无需类似双写的设计。</p>
<h1>表</h1>
<h2 id="总是存在主键">总是存在主键</h2>
<p>InnoDB 总会选择一个非空唯一列作为主键。把数据按照主键顺序存储的表，叫作索引组织表（index organized table），索引即数据，数据即索引。</p>
<h2 id="tablespace-的结构">tablespace 的结构</h2>
<p><img src="InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="InnoDB逻辑存储结构"></p>
<p>tablespace 下分为 段 segment、区 extent 和页 page。</p>
<p>注意，tablespace 的 segment 里有 rollback segment。</p>
<p><strong>共享表空间里存储了 undo log page，只有 full purge 可以回收。</strong></p>
<h2 id="行">行</h2>
<p>默认的行格式是 compact。这个大小可以在表的 ddl 的 ROW_FORMAT 里指定。</p>
<p><img src="compact%E8%A1%8C%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.png" alt="compact行记录格式"></p>
<p><code>hexdump -C -v mytest.ibd &gt; /home/zhoujy/mytest.txt</code>，找到 supremum 这一行。</p>
<p>左边的区是地址空间，每个地址空间间隔 16字节。<br>
中间的空间是内容，16个格子，每个格子是2个16进制数，即一个字节<br>
右边的空间是对内容的人类可读解释。</p>
<p>0000c070  73 75 70 72 65 6d 75 6d  03 02 02 01 00 00 00 10  |supremum…|<br>
0000c080  00 25 00 00 00 03 b9 00  00 00 00 02 49 01 82 00  |.%…I…|<br>
0000c090  00 01 4a 01 10 61 62 62  62 62 63 63 63 03 02 02  |…J…abbbbccc…|<br>
0000c0a0  01 00 00 00 18 00 23 00  00 00 03 b9 01 00 00 00  |…#…|<br>
0000c0b0  02 49 02 83 00 00 01 4b  01 10 61 65 65 65 65 66  |.I…K…aeeeef|<br>
0000c0c0  66 66 03 01 06 00 00 20  ff a6 00 00 00 03 b9 02  |ff… …|<br>
0000c0d0  00 00 00 02 49 03 84 00  00 01 4c 01 10 61 66 66  |…I…L…aff|<br>
0000c0e0  66 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |f…|</p>
<p>第一行数据:<br>
03 02 02 01 /<em>变长字段</em>/ ---- 表中4个字段类型为varchar，而且没有NULL数据，并且每一个字段君小于255。<br>
00 /<em>NULL标志位，第一行没有null的数据</em>/<br>
00 00 10 00 25 /<em>记录头信息,固定5个字节</em>/<br>
00 00 00 03 b9 00 /<em>RowID,固定6个字节,表没有主键</em>/<br>
00 00 00 02 49 01 /<em>事务ID,固定6个字节</em>/<br>
82 00 00 01 4a 01 10 /<em>回滚指针,固定7个字节</em>/<br>
61 62 62 62 62 63 63 63 /<em>列的数据</em>/</p>
<p>要找到 RowID，要先找到5字节的记录头，要找到记录头，要找到一字节的 null标志位，null标志位在变长字段列表之后，要知道表的变长字段列表，要先知道表的结构，这应该要去引用 .frm 文件了。这里的03 02 02 01 的意思是，第四个varchar 字段实际大小是4字节，第三个varchar 字段实际大小是2字节，第二个varchar 字段实际大小是2字节，第一个varchar 字段实际大小是1字节。</p>
<h2 id="溢出行问题">溢出行问题</h2>
<p><img src="%E8%A1%8C%E6%BA%A2%E5%87%BA%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8.png" alt="行溢出数据的存储"></p>
<p>有些记录的字段太长了，一页装不下（一页中必须至少装两条记录），会导致页溢出（off page），有些数据被放在其他页里。</p>
<p>新版的 Barracuda 格式包括：Compressed 和 Dynamic。</p>
<p><img src="Barracuda%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%BA%A2%E5%87%BA%E8%A1%8C.png" alt="Barracuda文件格式的溢出行"></p>
<h2 id="innodb-数据页结构">InnoDB 数据页结构</h2>
<p><img src="InnodDB%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84.png" alt="InnodDB存储引擎数据页结构"></p>
<p>InnoDB 管理数据库最小的磁盘单位是页。</p>
<ol>
<li>File Header（文件头）。</li>
<li>Page Header（页头）。</li>
<li>Infimun+Supremum Records。上确界和下确界，两条虚拟 record。</li>
<li>User Records（用户记录，即行记录）。</li>
<li>Free Space（空闲空间）。也是一个链表。到目前为止已经有3个链表，Buffer Pool、Change Buffer、数据页。</li>
<li>Page Directory（页目录）。</li>
<li>File Trailer（文件结尾信息）。它存了一些 checksum，可以通过它校验一个页是否 corrupt。</li>
</ol>
<p><img src="Infimum%E5%92%8CSupremumRecord.png" alt="Infimum和SupremumRecord"></p>
<h3 id="page-directory">Page Directory</h3>
<p>Page Directory（页目录）中存放了记录的相对位置（注意，这里存放的是页相对位置，而不是偏移量），有些时候这些记录指针称为Slots（槽）或者目录槽（Directory Slots）。与其他数据库系统不同的是，InnoDB并不是每个记录拥有一个槽，InnoDB存储引擎的槽是一个稀疏目录（sparse directory），即一个槽中可能属于（belong to）多个记录，最少属于4条记录，最多属于8条记录。</p>
<p>Slots中记录按照键顺序存放，这样可以利用二叉查找迅速找到记录的指针。假设我们有（‘i’，‘d’，‘c’，‘b’，‘e’，‘g’，‘l’，‘h’，‘f’，‘j’，‘k’，‘a’），同时假设一个槽中包含4条记录，则Slots中的记录可能是（‘a’，‘e’，‘i’）。</p>
<p>由于InnoDB存储引擎中Slots是稀疏目录，二叉查找的结果只是一个粗略的结果，所以InnoDB必须通过recorder header中的next_record来继续查找相关记录。同时，slots很好地解释了recorder header中的n_owned值的含义，即还有多少记录需要查找，因为这些记录并不包括在slots中。</p>
<p>需要牢记的是，B+树索引本身并不能找到具体的一条记录，B+树索引能找到只是该记录所在的页。数据库把页载入内存，然后通过Page Directory再进行二叉查找。只不过二叉查找的时间复杂度很低，同时内存中的查找很快，因此通常我们忽略了这部分查找所用的时间。</p>
<p>这里的 slot 类似 Redis 的 Slot（不知道 Redis 是否受这个设计启发）。</p>
<h2 id="字符集">字符集</h2>
<p>在当代 InnoDB 里，如果使用了多字节字符集，则 CHAR(N) 指的是字符数而不是字节数。</p>
<h2 id="约束">约束</h2>
<p>RDBMS 和 File System 之间的差别在于：RDBMS 支持格式、事务与约束（实体、参照、自定义）。</p>
<p>MySQL 支持：</p>
<ul>
<li>数据类型</li>
<li>外键</li>
<li>触发器</li>
<li>Default</li>
</ul>
<p>MySQL 不支持 Check 约束，但可以通过 ENUM 和 Set来解决部分需求-不过最好不要这样做。</p>
<h3 id="触发器">触发器</h3>
<p>最多可以对一个表建立 6 个触发器：</p>
<ul>
<li>Before：Insert/Update/Delete</li>
<li>After：Insert/Update/Delete</li>
</ul>
<h2 id="视图">视图</h2>
<p>一个被命名的续表，没有相应的物理存储（没有tablespace-ibdata）。</p>
<h3 id="物化视图">物化视图</h3>
<p>对普通表进行 join 得到有物理存储的视图表。</p>
<p>这种预计算的表的特点是只可以读不可以插入。</p>
<h2 id="分区表">分区表</h2>
<p>水平分区，将同一张表的不同记录分配到不同的物理文件中。<br>
垂直分区，将同一张表的不同列分配到不同的物理文件中。</p>
<p>要顺着数据增长的维度，设计切线。行是无限增长的，列是有穷增长的，切行不如切列。</p>
<p>开分区表的缺点之一是会让某些查询反而变慢-在某些查询不知不觉跨分区的时候。</p>
<h1>索引与算法</h1>
<p>不恰当的索引设置可以使 iostat 里的磁盘利用率高达100%。</p>
<p>InnoDB 支持的索引有：</p>
<ul>
<li>B+树</li>
<li>哈希索引</li>
<li>全文索引</li>
</ul>
<p>B+树的 B 不是代表 Binary，而是代表 Balance。</p>
<p>要澄清一个逻辑错误：聚集索引的连续，并不是在物理上连续的，而是在逻辑上连续的。<strong>只要页之间是指针相连的，逻辑上的连续加上数据和索引一起存储可以解决大部分顺序问题</strong>。</p>
<p><img src="B+%E6%A0%91%E7%B4%A2%E5%BC%95.png" alt="B+树索引"></p>
<p>聚簇索引的非叶子节点上有指向其他节点的 pointer，叶子节点本身也是一个双链表。辅助索引上记录的索引值有时候被称作 bookmark。</p>
<p><img src="%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E4%B8%8E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="辅助索引与聚集索引的关系"></p>
<p>按照本书的说法，在一个三层的辅助索引树上，找到主键需要3次IO，在找到主键后，再在三层的聚簇索引树上找到真正的记录还需要3次IO，一共6次IO。为什么不是四次呢？</p>
<h2 id="索引管理">索引管理</h2>
<p><img src="show-index-from-t.jpg" alt="show-index-from-t"></p>
<h2 id="fast-index-creation">Fast Index Creation</h2>
<p>MySQL5.5版本之前存在一个问题即对于索引的添加或者删除的这类DDL操作，MySQL的操作过程为：</p>
<ol>
<li>创建临时表，表结构为alter table新定义的结构。</li>
<li>把原表中的数据导入到临时表。</li>
<li>接着删除原表。</li>
<li>最后把临时表重名为原来的表名。</li>
</ol>
<p>如果通过上面的方式添加或者删除索引，需要很长的时间。</p>
<p>InnoDB1.0.x开始支持一种名为Fast Index Creation(快速索引创建)的索引创建方式----简称FIC</p>
<p>对于辅助索引的创建，InnoDB会对表加S锁。创建过程中不需要重建表。因此速度提高很多。删除索引操作就更简单了，InnoDB只需要更新内部视图，并将辅助索引的空间标记为可用，同时删除MySQL数据库内部视图上对该表的索引定义即可。</p>
<p>FIC在索引的创建过程中加了S锁，所以只能对表进行读操作，如果有大量的事务需要对目标表进行写操作，那么数据库的服务同样不可以使用，FIC方式只限定于辅助索引，对于主键的创建和删除同样需要重建一张表。</p>
<h2 id="online-schema-change-在线架构改变">Online Schema Change(在线架构改变)</h2>
<p>OSC 是最初的尝试的“在线”（事务的创建过程中，仍然有读写事务对标进行操作）该表的构思是 Facebook 的工程师落地的。</p>
<h2 id="online-ddl">Online DDL</h2>
<p>当代的 MySQL 有两个重要的版本，5.6 和 5.8（或者 8.0）。</p>
<p>5.6 开始 MySQL 自己内置 Online DDL。Online DDL 的其他工具还包括 Github 的 Ghost 或者 Percona percon tool kits。</p>
<h2 id="cardinality">Cardinality</h2>
<p>Cardinality 的统计是放在存储引擎层（InnoDB）的（而不是在 Server 层），即使是在存储引擎层里做统计，这个值也是 Sample 值，并不准。analyze table 可以修复一些不准的情况。</p>
<h2 id="索引选择">索引选择</h2>
<p>一般索引选择的顺序</p>
<ul>
<li>辅助索引覆盖且可排序</li>
<li>辅助索引覆盖</li>
<li>PK 无需回表</li>
<li>辅助索引回表</li>
</ul>
<p>很多时候 MySQL 甚至会全表扫描而不使用索引：</p>
<ul>
<li>range 扫描</li>
<li>join</li>
</ul>
<p>绝大多数情况下查询优化器的索引选择是准的，如果要选择索引，FORCE INDEX 而不是 USE INDEX。</p>
<h2 id="icp-优化">ICP 优化</h2>
<p><code>using index condition</code> ，可以减少在 Server 层过滤的开销。</p>
<h2 id="全文检索">全文检索</h2>
<p>Full-Text Search，在长文本里检索出任意的内容来。</p>
<h1>锁</h1>
<p>注意意向锁之间的兼容性。</p>
<h2 id="什么是锁">什么是锁</h2>
<p>必须先经过锁或者隔离，并发访问资源才是安全的操作。</p>
<p>MySQL 对 LRU 列表的操作都是需要锁的。</p>
<h2 id="lock-和-latch">Lock 和 Latch</h2>
<p>我们先讨论 Lock，对数据结构和事务而言，Lock 才是它们持有的东西，Latch 是线程持有的东西。</p>
<h2 id="innodb-里的锁">InnoDB 里的锁</h2>
<h3 id="锁的类型">锁的类型</h3>
<ul>
<li>X Lock</li>
<li>S Lock</li>
</ul>
<p>InnoDB 存储引擎支持多颗粒度（grannular）锁定。把上锁对象看作一棵树，加锁要先在粗颗粒度上加锁，任意一部分的锁等待，都会让事务操作阻塞。</p>
<p><img src="%E9%94%81%E7%9A%84%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.jpg" alt="锁的层次结构"></p>
<h3 id="非一致性锁定读">非一致性锁定读</h3>
<p><img src="%E9%9D%9E%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%81%E5%AE%9A%E8%AF%BB.jpg" alt="非一致性锁定读"></p>
<p>在 RC 下，非一致性锁定读总是读取行的最新快照版本。</p>
<h3 id="一致性读">一致性读</h3>
<p>就是当前读，仅就读而言，就是</p>
<ul>
<li><code>select lock in share mode</code></li>
<li><code>select for update</code></li>
</ul>
<h3 id="外键与锁">外键与锁</h3>
<p>Oracle 数据库不会自动添加外键索引，用户必须手动添加，否则会触发死锁，但 MySQL 不会。</p>
<h2 id="锁的算法">锁的算法</h2>
<ul>
<li>Record Lock</li>
<li>Gap-Lock</li>
<li>Next-Key-Lock</li>
</ul>
<p>范围查找非常危险，有一些很容被忽略的地方：</p>
<ul>
<li>对唯一索引而言，查找不到记录仍然会触发 Gap-Lock</li>
<li>对任意索引都会向左向右再伸展出 Gap-Lock，这样行插入总是能被挡住的-查找非常容易受 insert 和 update 影响，所以 Record Lock 主要挡 update，Gap-Lock 挡意外的 insert。</li>
<li>若唯一索引有多个列，查找仅查询多个唯一索引中的其中一个，这样的查询会变成 range 查询（explain 中的 type），不是 point 查询，很容易触发 Next-Key Lock。</li>
</ul>
<h2 id="解决-phantom-problem">解决 Phantom Problem</h2>
<p>这本书把不可重复读窄化为 Phantom Problem，把 Phantom Problem 窄化为看不到原本看不到的行。</p>
<p>通过查询层面实现唯一性检查：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">where</span> col<span class="hljs-operator">=</span>xxx lock <span class="hljs-keyword">in</span> share mode;<br># if <span class="hljs-keyword">not</span> found <span class="hljs-keyword">any</span> <span class="hljs-type">row</span>:<br># <span class="hljs-keyword">unique</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">insert</span> <span class="hljs-keyword">value</span><br><span class="hljs-keyword">insert into</span> <span class="hljs-keyword">table</span> <span class="hljs-keyword">values</span>(xxx);<br></code></pre></td></tr></table></figure>
<p>这种插入之前的检查可以保证插入的唯一性，比加 X 锁稍微友好一些，但可能在语句1和语句2之间出现一个间隙，如果有其他事务也求共享锁，则会发生死锁，不如直接加 x 锁。</p>
<h2 id="锁问题">锁问题</h2>
<p>脏页：缓冲池被修改但没有被持久化的页。</p>
<p>脏数据：事务对缓冲池中行记录的修改，并没有被提交。</p>
<p>如果读到了脏数据，即一个事务可以读到另外一个事务未提交的数据，违反了数据库的隔离性。</p>
<p>脏读发生的事务隔离级别是READ UNCOMMITTED，目前大部分数据库都至少设置为READ COMMITTED。InnoDB默认的隔离级别是READ REPEATABLE。</p>
<p>如果可以的话，应该在数据库层面解决丢失更新和各种脏读写的问题。</p>
<h2 id="阻塞">阻塞</h2>
<p>innodb 在很多情况下可以抛出异常，但遇到异常是应该提交事务还是回滚事务是需要专门配置的：</p>
<ul>
<li>innodb_lock_wait_timeout  等待时间到抛出异常</li>
<li>innodb_rollback_on_timeout 遇到超时是否回滚</li>
</ul>
<h2 id="死锁">死锁</h2>
<p>解决死锁最简单的方式就是把任何等待都转化为回滚（而不是等待），但这会降低并发事务完成数量。也可以通过等待超时再回滚的方式来处理（等待超时有可能是正在产生死锁还未检测出来，也可能没有遇到死锁，只是不想等超长操作完成了），这就是实践中大家选择的方案。</p>
<p>当前数据库普遍使用 wait-for-graph （基于锁的信息链表和事务等待链表构建）来进行死锁检测。</p>
<p><img src="%E4%BA%8B%E5%8A%A1%E9%93%BE%E8%A1%A8.png" alt="事务链表"><br>
<img src="%E7%AD%89%E5%BE%85%E5%9B%BE.png" alt="等待图"></p>
<p>大部分的情况下，InnoDB 对异常的处理方法都是可配的，但一旦它检测到死锁，存储引擎会立刻回滚一个事务。</p>
<h2 id="锁升级">锁升级</h2>
<p>Lock Escalation 是很多数据库需要考虑的情况。InnoDB 使用位图来管理锁。在 SQL Server里，大量加锁会增大开销，所以锁可能会升级（如用一个表锁代替1000个行锁），锁升级减少了管理锁的成本，但是降低了并发性。但 MySQL 里不存在这个问题。</p>
<h2 id="小结">小结</h2>
<p>一个高性能、高并发的数据库应用必须建立在充分理解锁的基础上。</p>
<h1>事务</h1>
<p>容易被忽略的经典定义：<strong>事务是通过一批操作，把数据库从一种一致性状态转换为另一种一致性状态</strong>。</p>
<p>文件系统 -格式化-&gt; MyISAM -transactional-&gt; InnoDB</p>
<h2 id="认识事务">认识事务</h2>
<p>不到特定隔离级别的事务，不能持久非易失存储的事务，都不算严格意义上的事务。</p>
<h3 id="事务的分类">事务的分类</h3>
<h4 id="扁平事务-flat-transactions">扁平事务（Flat Transactions）</h4>
<p><img src="%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1%E7%9A%84%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5.png" alt="扁平事务的三种情况"></p>
<p>扁平事务(Flat Transaction)是事务类型中最简单的一种,但在实际生产环境中,这可能是使用最为频繁的事务。在扁平事务中,所有操作都处于同一层次,其由 BEGIN WORK开始,由COMMIT WORK或ROLLBACK WORK结束,其间的操作是原子的,要么都执行,要么都回滚。因此扁平事务是应用程序成为原子操作的基本组成模块。</p>
<h4 id="带保存点的扁平事务-flat-transactions-with-savepoint">带保存点的扁平事务（Flat Transactions with Savepoint）</h4>
<p>扁平事务的限制是不能提交或回滚事务的某一部分，因此 “带有保存点的扁平事务” 弥补了扁平事务的不足，允许事务执行过程中回滚到同一事务中较早的一个状态，即某一保存点（savepoint）。扁平事务可以被认为是使用了 SHOW WORK 在事务开始时隐式创建了一个保存点的事务，回滚只能回滚到初始状态。</p>
<p><img src="%E5%B8%A6%E4%BF%9D%E5%AD%98%E7%82%B9%E7%9A%84%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1.png" alt="带保存点的扁平事务"></p>
<h4 id="链事务-chained-transactions">链事务（Chained Transactions）</h4>
<p><img src="%E9%93%BE%E5%BC%8F%E4%BA%8B%E5%8A%A1.png" alt="链式事务"></p>
<h4 id="嵌套事务-nested-transactions">嵌套事务（Nested Transactions）</h4>
<p>嵌套事务是一个层次结构框架，有一个顶层事务，控制着各个层次的事务，顶层事务之下嵌套的事务被称为子事务，子事务可以是嵌套事务，也可以是扁平事务；子事务可以提交也可有回滚，但是必须等到顶层事务提交之后才能生效。这是 JDBC 的常用抽象。</p>
<p><img src="%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1.png" alt="嵌套事务"></p>
<blockquote>
<p>Moss对嵌套事务的定义： （1）嵌套事务是由若干事务组成的一棵树，子树既可以是嵌套事务，也可以是扁平事务。<br>
（2）处在叶节点的事务是扁平事务。但是每个子事务从根到叶节点的距离可以是不同的。<br>
（3）位于根节点的事务称为顶层事务，其他事务称为子事务。事务的前驱（predecessor）称为父事务，事务的下一层称为儿子事务。<br>
（4）子事务既可以提交也可以回滚。但是它的提交操作并不马上生效，除非其父事务已经提交。因此可以推论出，任何子事物都在顶层事务提交后才真正的提交。<br>
（5）树中的任意一个事务的回滚会引起它的所有子事务一同回滚，故子事务仅保留A、C、I特性，不具有D的特性。</p>
<p>在Moss的理论中，高层的事务仅负责逻辑控制，叶子节点完成实际的工作。</p>
</blockquote>
<p><img src="%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BF%9D%E5%AD%98%E7%82%B9%E6%9D%A5%E6%A8%A1%E6%8B%9F%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1.png" alt="可以使用保存点来模拟嵌套事务"></p>
<h4 id="分布式事务-distributed-transactions">分布式事务（Distributed Transactions）</h4>
<blockquote>
<p>通常是一个在分布式环境下运行的扁平事务,因此需要根据数据所在位置访问网络中的不同节点。<br>
假设一个用户在ATM机进行银行的转账操作,例如持卡人从招商银行的储蓄卡转账10000元到工商银行的储蓄卡。在这种情况下,可以将ATM机视为节点A,招商银行的后台数据库视为节点B,工商银行的后台数据库视为C,这个转账的操作可分解为以下的步骤:</p>
<ol>
<li>节点A发出转账命令</li>
<li>节点B执行储蓄卡中的余额值减去10000</li>
<li>节点C执行储蓄卡中的余额值加上10000</li>
<li>节点A通知用户操作完成或者节点A通知用户操作失败。</li>
</ol>
<p>这里需要使用分布式事务,因为节点A不能通过调用一台数据库就完成任务。其需要访问网络中两个节点的数据库,而在每个节点的数据库执行的事务操作又都是扁平的。对于分布式事务,其同样需要满足ACID特性,要么都发生,要么都失效。对于上述的例子,如果2)、3)步中任何一个操作失败,都会导致整个分布式事务回滚。若非这样,结果会非常可怕。</p>
</blockquote>
<h3 id="小结">小结</h3>
<blockquote>
<p>对于InnoDB存储引擎来说，其支持扁平事务、带有保存点的事务、链事务、分布式事务。对于嵌套事务,其并不原生支持，因此，对有并行事务需求的用户来说MySQL数据库或InnoDB存储引擎就显得无能为力了。然而用户仍可以通过带有保存点的事务来模拟串行的嵌套事务。</p>
</blockquote>
<h2 id="事务的实现">事务的实现</h2>
<p>事务是由 redo 和 undo 两种日志实现的。有些人会认为 undo 是 redo 的过程，其实不然。redo 和 undo 都是恢复操作。redo恢复提交事务修改的页操作，undo 恢复行记录到特定的版本。</p>
<h3 id="redo-log">redo log</h3>
<p>重做日志一般在 InnoDB 种的写入都包括：写入 redo log buffer，写入操作系统缓存，fsync到磁盘这几步。redo log 用来保证事务的持久性、原子性，undo log 用来帮助事务回滚及 MVCC的功能。</p>
<p>它的地址空间在一个日志组（2到3个日志文件）里被循环使用，所以达到一定阈值后一定会触发 checkpoint。</p>
<p>redo log 基本上就是顺序写的，而undo log 是需要进行随机读写的（因为undo log 会存在于很多 undo page，而undo page是零散的）。</p>
<p>因为 MySQL 源码里打开重做日志文件并没有使用 O_DIRECT 选项，所以它的写入一定绕不开 fsync 问题。</p>
<p>redo log 的写入是在事务的执行过程中不间断发生的，binlog 是在事务提交那一瞬间作为内部事务的 commit 被写入的。</p>
<p><img src="%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%97%A5%E5%BF%97%E4%B8%8E%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E7%9A%84%E5%86%99%E5%85%A5%E6%97%B6%E9%97%B4%E7%82%B9%E4%B8%8D%E5%90%8C.png" alt="二进制日志与重做日志的写入时间点不同"></p>
<p>提高性能需要考虑两种日志都能支持组提交，在不同的复制策略下这个问题会非常复杂。见下方的组提交。事务的实现本来不需要考虑 binlog 的，但为了保持 binlog 和 redo log 的一致性，binlog 的写入和 redo log 的写入的关系被设计得非常紧凑。</p>
<h4 id="关于双-1-写入和事务提交的辨析">关于双 1 写入和事务提交的辨析</h4>
<p>如果 innodb_flush_log_at_trx_commit=2，则数据库宕机操作系统不宕机，仍有机会恢复数据库事务的操作结果。</p>
<p>有几种方法管理大量的插入事务：50万次插入只一次 commit，这样只调用一次 fsync。<br>
这样做的缺点是大事务：</p>
<ul>
<li>主从延迟高</li>
<li>RSeg 的总量居高不下</li>
<li>锁不释放</li>
</ul>
<h4 id="log-block-不是log-back">log block（不是log back）</h4>
<p>每个 log block 的长度为 512Byte，恰好等于一个扇区的单位长度，可以保证写入是原子的。</p>
<p><img src="%E9%87%8D%E5%81%9A%E6%97%A5%E5%BF%97%E7%BC%93%E5%AD%98%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="重做日志缓存的结构"></p>
<h4 id="恢复">恢复</h4>
<p>无论上次数据库是否正常关闭，InnoDB 在每次启动的时候都会尝试通过 redo log 恢复数据库。物理日志的恢复速度比逻辑日志都快，只要回复到上次的 CP（checkpoint 就行）。</p>
<p>不断重放 redo log，会得到 f(f(x)) = f(x)，redo log 是幂等的。</p>
<h3 id="undo-log">undo log</h3>
<p>undo 保证原子性和 mvcc。它的地址空间需要被 purge 线程消除。</p>
<p>undo log 是逻辑日志，只能把记录逻辑地恢复，页的物理结构还是会变，因为不同的事务操作同一页，早已把页写得面目全非了。</p>
<blockquote>
<p>我们的事务执行了一个INSERT<br>
10万条记录的SQL语句，这条语句可能会导致分配一个新的段，即表空间会增大。如果我们执行ROLLBACK时，会将插入的事务进行回滚，但是表空间的大小并不会因此而收缩。因此，当InnoDB存储引擎回滚时，它实际上做的是与先前相反的工作。对于每个INSERT，InnoDB存储引擎会完成一个DELETE；对于每个DELETE，InnoDB存储引擎会执行一个INSERT；对于每个UNDATE，InnoDB存储引擎会执行一个相反的UPDATE，将修改前的行放回去。</p>
</blockquote>
<p><strong>undo log 也会产生redo log，因为undo log也需要持久性的保护；事务在 undo log segment分配页并写入undo log的这个过程同样需要写入重做日志。</strong></p>
<h4 id="undo-log-日志格式">undo log 日志格式</h4>
<p><img src="%E6%8F%92%E5%85%A5%E6%97%A5%E5%BF%97undo-log%E6%A0%BC%E5%BC%8F.jpg" alt="插入日志undo-log格式"><br>
<img src="%E6%9B%B4%E6%96%B0%E6%97%A5%E5%BF%97undo-log%E6%A0%BC%E5%BC%8F.jpg" alt="更新日志undo-log格式"></p>
<h4 id="观察-undo-log">观察 undo log</h4>
<p>MySQL 没有其他数据库可用的数据字典来观察 undo 信息（InnoSQL有），但可以在information_schema里通过 INNODB_TRX_ROLLBACK_SEGMENT 和 INNODB_TRX_UNDO 表来查看回滚相关信息。</p>
<h4 id="purge">purge</h4>
<p><strong>当事务提交时</strong>, InnoDB存储引擎会做以下两件事情:</p>
<ul>
<li>将undo log放入列表中，以供之后的 purge操作。</li>
<li>判断 undo log 所在的页是否可以重用（比如，插入日志是从 insert_undo_list移动到insert_undo_cache），若可以分配给下个事务使用。</li>
</ul>
<p>这一段认知非常地重要：<strong>所以 MVCC 的其他事务读，实际上就是读当前的最新 buffer pool 里的数据页里的内容+这个已提交事务的 undo log 链表的内容</strong>。</p>
<p>InnoDB存储引擎有一个历史列表，它根据<strong>事务提交的顺序</strong>，将回滚日志进行链接。这个历史列<strong>表和 ReadView 的那个 undo log 列表（那个列表也只存了已提交的行版本）不太一样，是跨行而专门跟着事务提交顺序编排起来的</strong>。</p>
<p><img src="%E5%9B%9E%E6%BB%9A%E6%97%A5%E5%BF%97%E4%B8%8E%E5%8E%86%E5%8F%B2%E5%88%97%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB.jpg" alt="回滚日志与历史列表的关系"></p>
<p>在执行purge的过程中，InnoDB首先从历史表中找到第一个需要被清理的事务记录，再找到对应的回滚日志进行清理，清理之后，再在该回滚日志所在的页继续寻找是否存在可以被清理的记录，直到清理完页中所有可以被清理的记录。</p>
<p>InnoDB存储引擎这种先<strong>从history list中找undo log，然后再从undo page中找undo log</strong>的设计模式是为了避免大量的随机读取操作，从而提高purge的效率。这样做为了避免大量的随机读取操作，从而提高purge的效率。</p>
<h4 id="group-commit">group commit</h4>
<p>binary log group commit 的过程：</p>
<p><img src="blgc.jpg" alt="blgc"></p>
<h2 id="事务的隔离级别">事务的隔离级别</h2>
<p>大部分的 RDBMS 都没有提供真正的隔离性，最初或许是因为系统实现者没有真正理解这些问题。</p>
<p>事务隔离级别越低，事务请求的锁越少或保持锁的时间就越短（RC级别x锁不会加间隙锁，也不会做严格的事务id区别的快照读，只读当前最新版本的快照）。Jim Gray 在《Transaction Processing》里认为，可序列化不比 RR 性能差，甚至更好，所以 RR 也不会大幅提升性能-毕竟可序列化只是隐式地加上S/X锁而已，此时事务是 well-formed的，two-phased的。本书认为RR就是3°隔离（也就是可序列化）。</p>
<p>在 RC 级别，进行唯一性约束检查及外键约束需要 gap lock，这是 RC 唯一的例外。</p>
<h2 id="分布式事务">分布式事务</h2>
<h3 id="mysql-分布式事务">MySQL 分布式事务</h3>
<p>InnoDB 支持 XA 事务。此处的分布式允许多个独立的数据源（transactional resources）参与到一个全局的事务中。</p>
<p><img src="%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%A8%A1%E5%9E%8B.jpg" alt="分布式事务模型"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">import</span> java.sql.SQLException;<br><span class="hljs-keyword">import</span> java.sql.Statement;<br><br><br><span class="hljs-keyword">import</span> javax.sql.XAConnection;<br><span class="hljs-keyword">import</span> javax.transaction.xa.XAException;<br><span class="hljs-keyword">import</span> javax.transaction.xa.XAResource;<br><span class="hljs-keyword">import</span> javax.transaction.xa.Xid;<br><br><br><span class="hljs-keyword">import</span> com.mysql.jdbc.jdbc2.optional.MysqlXADataSource;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * MySQL数据库分布式事务</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 是否启用了XA事务的支持：SHOW VARIABLES LIKE &#x27;innodb_support_xa&#x27;;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 数据表account：</span><br><span class="hljs-comment"> * CREATE TABLE account (</span><br><span class="hljs-comment">user_id INT NOT NULL,</span><br><span class="hljs-comment">money INT NOT NULL DEFAULT 0,</span><br><span class="hljs-comment">PRIMARY KEY(`user_id`)</span><br><span class="hljs-comment">)ENGINE=INNODB</span><br><span class="hljs-comment">bank_shanghai.account数据：(1, 10000)</span><br><span class="hljs-comment">bank_beijing.account数据：(2, 0)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyXA</span> &#123;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">conn1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://192.168.0.200:3306/bank_shanghai&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">conn2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;jdbc:mysql://192.168.0.300:3306/bank_beijing&quot;</span>;<br><span class="hljs-type">MysqlXADataSource</span> <span class="hljs-variable">ds1</span> <span class="hljs-operator">=</span> getDataSource(conn1, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>);<br><span class="hljs-type">MysqlXADataSource</span> <span class="hljs-variable">ds2</span> <span class="hljs-operator">=</span> getDataSource(conn2, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>);<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-type">XAConnection</span> <span class="hljs-variable">xac1</span> <span class="hljs-operator">=</span> ds1.getXAConnection();<br><span class="hljs-type">XAResource</span> <span class="hljs-variable">xar1</span> <span class="hljs-operator">=</span> xac1.getXAResource();<br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt1</span> <span class="hljs-operator">=</span> xac1.getConnection().createStatement();<br><br><span class="hljs-type">XAConnection</span> <span class="hljs-variable">xac2</span> <span class="hljs-operator">=</span> ds2.getXAConnection();<br><span class="hljs-type">XAResource</span> <span class="hljs-variable">xar2</span> <span class="hljs-operator">=</span> xac2.getXAResource();<br><span class="hljs-type">Statement</span> <span class="hljs-variable">stmt2</span> <span class="hljs-operator">=</span> xac2.getConnection().createStatement();<br><br><span class="hljs-type">Xid</span> <span class="hljs-variable">xid1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyXid</span>(<span class="hljs-number">100</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">0x01</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">0x02</span>&#125;);<br><span class="hljs-type">Xid</span> <span class="hljs-variable">xid2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyXid</span>(<span class="hljs-number">100</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">0x11</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">0x12</span>&#125;);<br><br>xar1.start(xid1, XAResource.TMNOFLAGS);<br>stmt1.execute(<span class="hljs-string">&quot;update account set money = money-3000 where user_id = 1&quot;</span>);<br>xar1.end(xid1, XAResource.TMSUCCESS);<br><br>xar2.start(xid2, XAResource.TMNOFLAGS);<br>stmt2.execute(<span class="hljs-string">&quot;update account set money = money+3000 where user_id = 2&quot;</span>);<br>xar2.end(xid2, XAResource.TMSUCCESS);<br><br><span class="hljs-type">int</span> <span class="hljs-variable">ret2</span> <span class="hljs-operator">=</span> xar2.prepare(xid2);<br><span class="hljs-type">int</span> <span class="hljs-variable">ret1</span> <span class="hljs-operator">=</span> xar1.prepare(xid1);<br><span class="hljs-keyword">if</span> (ret1 == XAResource.XA_OK &amp;&amp; ret2 == XAResource.XA_OK) &#123;<br>xar1.commit(xid1, <span class="hljs-literal">false</span>);<br>xar2.commit(xid2, <span class="hljs-literal">false</span>);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (SQLException | XAException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> MysqlXADataSource <span class="hljs-title function_">getDataSource</span><span class="hljs-params">(String url, String user, String pwd)</span> &#123;<br><span class="hljs-type">MysqlXADataSource</span> <span class="hljs-variable">ds</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MysqlXADataSource</span>();<br>ds.setUrl(url);<br>ds.setUser(user);<br>ds.setPassword(pwd);<br><span class="hljs-keyword">return</span> ds;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyXid</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Xid</span> &#123;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> formatId;<br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] gtrid;<br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] bqual;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyXid</span><span class="hljs-params">(<span class="hljs-type">int</span> formatId, <span class="hljs-type">byte</span>[] gtrid, <span class="hljs-type">byte</span>[] bqual)</span> &#123;<br><span class="hljs-built_in">this</span>.formatId = formatId;<br><span class="hljs-built_in">this</span>.gtrid = gtrid;<br><span class="hljs-built_in">this</span>.bqual = bqual;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getBranchQualifier() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.bqual;<br>&#125;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getFormatId</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.formatId;<br>&#125;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">byte</span>[] getGlobalTransactionId() &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.gtrid;<br>&#125;<br><br>&#125;<br><br>&#125; <br></code></pre></td></tr></table></figure>
<h3 id="内部-xa-事务">内部 XA 事务</h3>
<p>MySQL 在服务层和 InnoDB 两层之间使用 XA 分布式事务来保证 binlog 和 redo log 的同步。</p>
<p>也会处理主从之间的一致性问题：</p>
<p><img src="%E5%86%85%E9%83%A8XA%E4%BA%8B%E5%8A%A1.png" alt="内部XA事务"></p>
<h2 id="不好的事务习惯">不好的事务习惯</h2>
<h3 id="在循环中提交事务">在循环中提交事务</h3>
<p>在循环中提交事务，存在如下问题：</p>
<ul>
<li>InnoDB默认会自动提交；</li>
<li>当发生错误时，数据库会停留在一个未知的位置；</li>
<li>降低性能。</li>
</ul>
<p>不论从何种角度出发，都不应该在一个循环中反复进行提交操作，不论是显式的提交还是隐式的提交。</p>
<h3 id="使用自动提交">使用自动提交</h3>
<p>自动提交与在循环中提交事务存在同样的问题，因为InnoDB默认视每一个操作为一个孤立的事务。</p>
<p>通过显式开启事务，或设置SET AUTOCOMMIT=0来禁用自动提交。</p>
<p>建议把事务的控制权限交给开发人员，他们必须了解自动提交可能带来的问题，以减少不必要的错误。</p>
<h3 id="使用自动回滚">使用自动回滚</h3>
<p>InnoDB支持通过定义一个HANDLER来进行自动事务的回滚操作。</p>
<p>Microsoft SQL Server数据库不仅会自动回滚当前的事务，还会抛出异常，开发人员可以捕获到这个异常。但MySQL数据库不会抛出异常。因此自动回滚产生的问题是，只知道发生了错误，但不知道错误的原因。这不利于定位问题。<br>
7.9 长事务</p>
<h3 id="长事务-long-lived-transactions-顾名思义-就是执行时间较长的事务">长事务（Long-Lived Transactions），顾名思义，就是执行时间较长的事务。</h3>
<p>长事务存在一个问题，在执行过程中，当数据库或操作系统、硬件等发生问题时，重新开始事务的代价变得不可接受，而且需要很长的时间回滚所有已经发生的变化。</p>
<p>对于长事务的问题，可以通过转化为小批量（mini batch）的事务来进行处理。当事务发生错误时，只需要回滚一部分数据，然后接着上次已完成的事务继续进行。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2021/03/28/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/">https://magicliang.github.io/2021/03/28/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a><a class="post-meta__tags" href="/tags/MySQL/">MySQL</a></div><div class="post-share"><div class="social-share" data-image="/2021/03/28/MySQL-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB-%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/InnoDBStructure.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/11/15/MariaDB-%E8%B0%83%E4%BC%98%E7%9B%B8%E5%85%B3/" title="MariaDB 调优相关"><img class="cover" src="/img/wall-paper-179.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-15</div><div class="info-item-2">MariaDB 调优相关</div></div><div class="info-2"><div class="info-item-1">本文主要摘译自这里。 MySQL 曾经有独立的公司。但那间公司后来被 Sun 微系统公司获取了。 Sun 微系统公司又被 Oracle 获取了。原 MySQL 开发者担心 MySQL 成为闭源软件，因此成立了一家SkySQL 公司维护开源的 MySQL 分支–MariaDB。 MariaDB 支持的存储引擎包括：  InnoDB/XtraDB 后者是前者的加强版，属于事务性存储引擎，也叫  ACID-compliant（ACID 遵从的）。XtraDB 是 Percona 开发的存储引擎，整体向下兼容。使用普通的 mysqldump 会耗尽 cpu（因为要把数据库转化成正经的 SQL 语句）。而 xtrabackup 在大库上的备份、还原、冗余都表现得更好（因为像 Oracle 一样是二进制备份吗？）。 TokuDB。另一个事务性存储引擎。以高压缩率著称（最高25倍压缩）。适合小空间存储大数据。 MyISAM。MySQL 上最古老的存储引擎。非事务性存储引擎，只支持表级锁，不支持 MVCC。 SphinxSE。非事务性存储引擎。这名字和古希腊猜谜语的怪兽，斯芬克斯一样。本以上是用...</div></div></div></a><a class="pagination-related" href="/2018/05/29/JPA-%E7%9A%84-id-%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/" title="JPA 的 id 生成策略"><img class="cover" src="/img/wall-paper-143.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-05-29</div><div class="info-item-2">JPA 的 id 生成策略</div></div><div class="info-2"><div class="info-item-1">JPA 有一个@GeneratedValue注解，有一个strategy attribute，如 @GeneratedValue(strategy = GenerationType.IDENTITY)。 常见的可选策略主要有IDENTITY和SEQUENCE。 GenerationType.IDENTITY 要求底层有一个 integer 或者 bigint 类型的自增列（ auto-incremented column)。自增列的赋值必须在插入操作之后发生，因为这个原因，Hibernate 无法进行各种优化（特别是 JDBC 的 batch 处理，一次 flush 操作会产生很多条insert 语句，分别执行）。如果事务回滚，自增列的值就会被丢弃。数据库在这个自增操作上有个高度优化的轻量级锁机制，性能非常棒。 MySQL 支持这种 id 生成策略， 使用 MySQL 应该尽量使用这个策略，即使它无法优化。 JPA 用它生成 id，会一条一条地插入新的 entity。 GenerationType.SEQUENCE 数据库有一个所谓的 sequence 对象，可以通过 selec...</div></div></div></a><a class="pagination-related" href="/2020/09/14/MySQL-%E7%9A%84%E9%85%8D%E7%BD%AE/" title="MySQL 的配置"><img class="cover" src="/img/wall-paper-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-14</div><div class="info-item-2">MySQL 的配置</div></div><div class="info-2"><div class="info-item-1">123456789101112131415161718-- 查看自动提交SELECT @@autocommit-- 查看全局隔离级别和会话隔离级别SELECT @@global.tx_isolation, @@tx_isolation;-- 查看引擎的事务状态，这里可以看出死锁日志，但需要  PROCESS privilege(s)show engine innodb status# 查看表详情show table status like &#x27;dept_emp&#x27;#  查看当前存储引擎默认的行格式SHOW VARIABLES LIKE &#x27;%innodb_default_row_format%&#x27;# 查看全部 binlog 文件show binary logs;# 查看最新的binlog，带有 positionshow master status; # 查看某个 binlog 的内容show binlog events in &#x27;binlog.000156&#x27;; </div></div></div></a><a class="pagination-related" href="/2021/03/11/MySQL-%E7%9A%84-MGR/" title="MySQL 的 MGR"><img class="cover" src="/img/wall-paper-9.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-11</div><div class="info-item-2">MySQL 的 MGR</div></div><div class="info-2"><div class="info-item-1">MySQL 高可用架构的历史 MySQL 自带的主从复制机制，本身并不能实现自动高可用。 早期使用开源组件来搭 MySQL 集群的方案，使用 MMHA。当代 MySQL 官方自己主推的方案是 MySQL cluster。这些老的方案，优先保证MySQL服务的持续可用，在异常切换情况下，可能出现主机上部分数据未能及时同步到从库，造成主从切换后数据丢失。但是包括金融支付在内的一些业务，对于数据库服务既要求持续可用、也要求数据强一致（可以在性能上做出一些让步）。 因此，当代的 MySQL 官方提供了组复制（MySQL Group Replication）的方案，构建了新一代的 MySQL 高可用强一致服务。 Master-Slave（MS）架构高可用概述 MS架构高可用基础 高可用MySQL是依赖复制（Replication）技术实现的，复制解决的基本问题就是，让一台数据库服务器的数据同步到其它服务器上。MySQL数据库的复制有如下三个步骤。   在主库上把数据更改记录到二进制日志（Binary Log）中（这些记录被称为二进制日志事件）。   备库将主库上的日志复制到自己的中继日志（...</div></div></div></a><a class="pagination-related" href="/2021/03/18/MySQL-%E5%8E%8B%E7%BC%A9/" title="MySQL 压缩"><img class="cover" src="/img/wall-paper-171.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-18</div><div class="info-item-2">MySQL 压缩</div></div><div class="info-2"><div class="info-item-1">压缩算法 Table Compression InnoDB存储引擎是按照索引组织表（index-organized table）的方式组织数据的，数据存储在B-tree索引（clustered index/primary key &amp; secondary index）中。Table Compression是针对整个表，和相关索引进行的，而不是单独的数据行。 B-tree页经常被更新，InnoDB会尽量减少B-tree节点的分裂（split），减少不必要的压缩和解压页。为此，InnoDB在每个B-tree页中都预留了未压缩的“modification log”空间，记录页的变更。对于update和insert的数据量较小时，会先写入“modification log”，不用立刻重构整个页。当“modification log”空间用完了，InnoDB解压该页，应用变更（apply），然后重新压缩。如果压缩失败，该B-tree叶节点就要进行分裂了。在写入量比较大的场景，比如某些OLTP应用，为了避免频繁压缩失败，InnoDB会在页中保留一些额外空间（padding），在“mod...</div></div></div></a><a class="pagination-related" href="/2021/12/10/MyBatis-%E5%85%B3%E9%94%AE%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90/" title="MyBatis 关键代码分析"><img class="cover" src="/img/wall-paper-40.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-10</div><div class="info-item-2">MyBatis 关键代码分析</div></div><div class="info-2"><div class="info-item-1">如何创建 SqlSession org.apache.ibatis.session.defaults.DefaultSqlSessionFactory 12345678910111213141516171819202122232425262728// 在应用程序中通过sqlSessionFactory获取一个SqlSession对象执行CRUD操作SqlSession sqlSession = sqlSessionFactory.openSession(true);// 在DefaultSqlSessionFactory中获取SqlSession对象@Overridepublic SqlSession openSession(boolean autoCommit) &#123;    return openSessionFromDataSource(configuration.getDefaultExecutorType(), null, autoCommit);&#125;// 通过MyBatis配置参数构建SqlSession对象private SqlSession open...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">MySQL 体系结构和存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E5%AE%9E%E4%BE%8B"><span class="toc-number">2.1.</span> <span class="toc-text">定义数据库和实例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">InnoDB 的存储引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#innodb-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E6%A6%82%E8%BF%B0"><span class="toc-number">3.1.</span> <span class="toc-text">InnoDB 存储引擎概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E7%BA%BF%E7%A8%8B%E5%8C%85%E6%8B%AC"><span class="toc-number">3.1.1.</span> <span class="toc-text">后台线程包括</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#master-thread"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">master thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#io-thread"><span class="toc-number">3.1.1.2.</span> <span class="toc-text">IO thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#purge-thread"><span class="toc-number">3.1.1.3.</span> <span class="toc-text">purge thread</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#page-cleaner-thread"><span class="toc-number">3.1.1.4.</span> <span class="toc-text">page cleaner thread</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">3.1.2.</span> <span class="toc-text">内存</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Type    Name    Status InnoDB</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 2022-03-05 16:04:44 0x70000dda3000 INNODB MONITOR OUTPUT
&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Per second averages calculated from the last 0 seconds
----------------- BACKGROUND THREAD
----------------- srv_master_thread loops: 6 srv_active, 0 srv_shutdown, 110008 srv_idle srv_master_thread log flush and writes:
0
---------- SEMAPHORES
---------- OS WAIT ARRAY INFO: reservation count 2 OS WAIT ARRAY INFO: signal count 2 RW-shared spins 0, rounds 0, OS waits 0 RW-excl spins
0, rounds 0, OS waits 0 RW-sx spins 0, rounds 0, OS waits 0 Spin
rounds per wait: 0.00 RW-shared, 0.00 RW-excl, 0.00 RW-sx
------------ TRANSACTIONS
------------ Trx id counter 6151 Purge done for trx’s n:o &lt; 6149 undo n:o &lt; 0 state: running but idle History list length 0 LIST OF
TRANSACTIONS FOR EACH SESSION:
—TRANSACTION 421658550605264, not started 0 lock struct(s), heap size 1128, 0 row lock(s)
—TRANSACTION 421658550604472, not started 0 lock struct(s), heap size 1128, 0 row lock(s)
—TRANSACTION 421658550603680, not started 0 lock struct(s), heap size 1128, 0 row lock(s)
—TRANSACTION 421658550602888, not started 0 lock struct(s), heap size 1128, 0 row lock(s)
—TRANSACTION 421658550602096, not started 0 lock struct(s), heap size 1128, 0 row lock(s)
—TRANSACTION 421658550601304, not started 0 lock struct(s), heap size 1128, 0 row lock(s)
-------- FILE I&#x2F;O
-------- I&#x2F;O thread 0 state: waiting for i&#x2F;o request (insert buffer thread) I&#x2F;O thread 1 state: waiting for i&#x2F;o request (log thread) I&#x2F;O
thread 2 state: waiting for i&#x2F;o request (read thread) I&#x2F;O thread 3
state: waiting for i&#x2F;o request (read thread) I&#x2F;O thread 4 state:
waiting for i&#x2F;o request (read thread) I&#x2F;O thread 5 state: waiting for
i&#x2F;o request (read thread) I&#x2F;O thread 6 state: waiting for i&#x2F;o request
(write thread) I&#x2F;O thread 7 state: waiting for i&#x2F;o request (write
thread) I&#x2F;O thread 8 state: waiting for i&#x2F;o request (write thread) I&#x2F;O
thread 9 state: waiting for i&#x2F;o request (write thread) Pending normal
aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,  ibuf aio reads:,
log i&#x2F;o’s:, sync i&#x2F;o’s: Pending flushes (fsync) log: 0; buffer pool: 0
937 OS file reads, 467 OS file writes, 58 OS fsyncs
0.00 reads&#x2F;s, 0 avg bytes&#x2F;read, 0.00 writes&#x2F;s, 0.00 fsyncs&#x2F;s
------------------------------------- INSERT BUFFER AND ADAPTIVE HASH INDEX
------------------------------------- Ibuf: size 1, free list len 0, seg size 2, 0 merges merged operations:  insert 0, delete mark 0,
delete 0 discarded operations:  insert 0, delete mark 0, delete 0 Hash
table size 34679, node heap has 0 buffer(s) Hash table size 34679,
node heap has 0 buffer(s) Hash table size 34679, node heap has 0
buffer(s) Hash table size 34679, node heap has 0 buffer(s) Hash table
size 34679, node heap has 0 buffer(s) Hash table size 34679, node heap
has 0 buffer(s) Hash table size 34679, node heap has 2 buffer(s) Hash
table size 34679, node heap has 6 buffer(s)
0.00 hash searches&#x2F;s, 0.00 non-hash searches&#x2F;s
— LOG
— Log sequence number          19606903 Log buffer assigned up to    19606903 Log buffer completed up to   19606903 Log written up to
19606903 Log flushed up to            19606903 Added dirty pages up to
19606903 Pages flushed up to          19606903 Last checkpoint at
19606903 23 log i&#x2F;o’s done, 0.00 log i&#x2F;o’s&#x2F;second
---------------------- BUFFER POOL AND MEMORY
---------------------- Total large memory allocated 0 Dictionary memory allocated 390927 Buffer pool size   8192 # 注意：意味着总共有8192个页（通常是16k一页） Free buffers 0 # 注意：Free List 为 0
7040 Database pages     1144 Old database pages 402 Modified db pages # 注意：缓冲池里面有7040个数据（库）页，这就是 LRU list 的总长度
0 Pending reads      0 Pending writes: LRU 0, flush list 0, single
page 0 Pages made young 20, not young 0 # 注意：Made Young 意味着从 LRU 的队尾淘汰了一页，加入 new 里。这里 Made Young 发生了 20 次。
0.00 youngs&#x2F;s, 0.00 non-youngs&#x2F;s Pages read 914, created 233, written 351
0.00 reads&#x2F;s, 0.00 creates&#x2F;s, 0.00 writes&#x2F;s No buffer pool page gets since the last printout Pages read ahead 0.00&#x2F;s, evicted without
access 0.00&#x2F;s, Random read ahead 0.00&#x2F;s LRU len: 1144, unzip_LRU len:
0 I&#x2F;O sum[0]:cur[0], unzip sum[0]:cur[0]
-------------- ROW OPERATIONS
-------------- 0 queries inside InnoDB, 0 queries in queue 0 read views open inside InnoDB Process ID&#x3D;153, Main thread ID&#x3D;0x70000d0ec000
, state&#x3D;sleeping Number of rows inserted 16568, updated 0, deleted 0,
read 16568
0.00 inserts&#x2F;s, 0.00 updates&#x2F;s, 0.00 deletes&#x2F;s, 0.00 reads&#x2F;s Number of system rows inserted 0, updated 315, deleted 0, read 6557
0.00 inserts&#x2F;s, 0.00 updates&#x2F;s, 0.00 deletes&#x2F;s, 0.00 reads&#x2F;s
---------------------------- END OF INNODB MONITOR OUTPUT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B1%A0"><span class="toc-number">5.1.</span> <span class="toc-text">缓冲池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lru-list-free-list-%E5%92%8C-flush-list"><span class="toc-number">5.2.</span> <span class="toc-text">LRU List、Free List 和 Flush List</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#lru-list"><span class="toc-number">5.2.1.</span> <span class="toc-text">LRU List</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#free-list"><span class="toc-number">5.2.2.</span> <span class="toc-text">Free list</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#flush-list"><span class="toc-number">5.2.3.</span> <span class="toc-text">Flush list</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#redo-log-buffer"><span class="toc-number">5.3.</span> <span class="toc-text">redo log buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#additional-mem-pool"><span class="toc-number">5.4.</span> <span class="toc-text">additional mem pool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#checkpoint-%E6%8A%80%E6%9C%AF"><span class="toc-number">5.5.</span> <span class="toc-text">checkpoint 技术</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#innodb-%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="toc-number">5.6.</span> <span class="toc-text">innodb 关键特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#insert-buffer"><span class="toc-number">5.6.1.</span> <span class="toc-text">Insert Buffer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#change-buffer"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">Change buffer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insert-buffer-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.6.1.2.</span> <span class="toc-text">Insert Buffer 的实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#insert-buffer-%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">5.6.1.3.</span> <span class="toc-text">Insert Buffer 的意义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E6%AC%A1%E5%86%99-doublewrite"><span class="toc-number">5.6.2.</span> <span class="toc-text">两次写（doublewrite）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95-ahi"><span class="toc-number">5.6.3.</span> <span class="toc-text">自适应哈希索引（AHI）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5-io"><span class="toc-number">5.6.4.</span> <span class="toc-text">异步 io</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%B7%E6%96%B0%E9%82%BB%E6%8E%A5%E9%A1%B5-flush-neighbor-page"><span class="toc-number">5.6.5.</span> <span class="toc-text">刷新邻接页（flush neighbor page）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%AF%E5%8A%A8-%E5%85%B3%E9%97%AD%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-number">5.7.</span> <span class="toc-text">启动、关闭与恢复</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">文件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.1.</span> <span class="toc-text">参数格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binlog-%E6%A0%BC%E5%BC%8F"><span class="toc-number">6.2.</span> <span class="toc-text">binlog 格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4"><span class="toc-number">6.3.</span> <span class="toc-text">表空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo-log-file"><span class="toc-number">6.4.</span> <span class="toc-text">redo log file</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E6%98%AF%E5%AD%98%E5%9C%A8%E4%B8%BB%E9%94%AE"><span class="toc-number">7.1.</span> <span class="toc-text">总是存在主键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tablespace-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">7.2.</span> <span class="toc-text">tablespace 的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C"><span class="toc-number">7.3.</span> <span class="toc-text">行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BA%A2%E5%87%BA%E8%A1%8C%E9%97%AE%E9%A2%98"><span class="toc-number">7.4.</span> <span class="toc-text">溢出行问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#innodb-%E6%95%B0%E6%8D%AE%E9%A1%B5%E7%BB%93%E6%9E%84"><span class="toc-number">7.5.</span> <span class="toc-text">InnoDB 数据页结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#page-directory"><span class="toc-number">7.5.1.</span> <span class="toc-text">Page Directory</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E9%9B%86"><span class="toc-number">7.6.</span> <span class="toc-text">字符集</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%A6%E6%9D%9F"><span class="toc-number">7.7.</span> <span class="toc-text">约束</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E5%99%A8"><span class="toc-number">7.7.1.</span> <span class="toc-text">触发器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">7.8.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E5%8C%96%E8%A7%86%E5%9B%BE"><span class="toc-number">7.8.1.</span> <span class="toc-text">物化视图</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA%E8%A1%A8"><span class="toc-number">7.9.</span> <span class="toc-text">分区表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">索引与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%AE%A1%E7%90%86"><span class="toc-number">8.1.</span> <span class="toc-text">索引管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fast-index-creation"><span class="toc-number">8.2.</span> <span class="toc-text">Fast Index Creation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#online-schema-change-%E5%9C%A8%E7%BA%BF%E6%9E%B6%E6%9E%84%E6%94%B9%E5%8F%98"><span class="toc-number">8.3.</span> <span class="toc-text">Online Schema Change(在线架构改变)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#online-ddl"><span class="toc-number">8.4.</span> <span class="toc-text">Online DDL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cardinality"><span class="toc-number">8.5.</span> <span class="toc-text">Cardinality</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%80%89%E6%8B%A9"><span class="toc-number">8.6.</span> <span class="toc-text">索引选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#icp-%E4%BC%98%E5%8C%96"><span class="toc-number">8.7.</span> <span class="toc-text">ICP 优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2"><span class="toc-number">8.8.</span> <span class="toc-text">全文检索</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81"><span class="toc-number">9.1.</span> <span class="toc-text">什么是锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lock-%E5%92%8C-latch"><span class="toc-number">9.2.</span> <span class="toc-text">Lock 和 Latch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#innodb-%E9%87%8C%E7%9A%84%E9%94%81"><span class="toc-number">9.3.</span> <span class="toc-text">InnoDB 里的锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%B1%BB%E5%9E%8B"><span class="toc-number">9.3.1.</span> <span class="toc-text">锁的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E4%B8%80%E8%87%B4%E6%80%A7%E9%94%81%E5%AE%9A%E8%AF%BB"><span class="toc-number">9.3.2.</span> <span class="toc-text">非一致性锁定读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%E8%AF%BB"><span class="toc-number">9.3.3.</span> <span class="toc-text">一致性读</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%94%AE%E4%B8%8E%E9%94%81"><span class="toc-number">9.3.4.</span> <span class="toc-text">外键与锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">9.4.</span> <span class="toc-text">锁的算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3-phantom-problem"><span class="toc-number">9.5.</span> <span class="toc-text">解决 Phantom Problem</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">9.6.</span> <span class="toc-text">锁问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E"><span class="toc-number">9.7.</span> <span class="toc-text">阻塞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">9.8.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7"><span class="toc-number">9.9.</span> <span class="toc-text">锁升级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">9.10.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.1.</span> <span class="toc-text">认识事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">10.1.1.</span> <span class="toc-text">事务的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1-flat-transactions"><span class="toc-number">10.1.1.1.</span> <span class="toc-text">扁平事务（Flat Transactions）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E4%BF%9D%E5%AD%98%E7%82%B9%E7%9A%84%E6%89%81%E5%B9%B3%E4%BA%8B%E5%8A%A1-flat-transactions-with-savepoint"><span class="toc-number">10.1.1.2.</span> <span class="toc-text">带保存点的扁平事务（Flat Transactions with Savepoint）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E4%BA%8B%E5%8A%A1-chained-transactions"><span class="toc-number">10.1.1.3.</span> <span class="toc-text">链事务（Chained Transactions）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%A5%97%E4%BA%8B%E5%8A%A1-nested-transactions"><span class="toc-number">10.1.1.4.</span> <span class="toc-text">嵌套事务（Nested Transactions）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-distributed-transactions"><span class="toc-number">10.1.1.5.</span> <span class="toc-text">分布式事务（Distributed Transactions）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">10.1.2.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">10.2.</span> <span class="toc-text">事务的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#redo-log"><span class="toc-number">10.2.1.</span> <span class="toc-text">redo log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%8F%8C-1-%E5%86%99%E5%85%A5%E5%92%8C%E4%BA%8B%E5%8A%A1%E6%8F%90%E4%BA%A4%E7%9A%84%E8%BE%A8%E6%9E%90"><span class="toc-number">10.2.1.1.</span> <span class="toc-text">关于双 1 写入和事务提交的辨析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#log-block-%E4%B8%8D%E6%98%AFlog-back"><span class="toc-number">10.2.1.2.</span> <span class="toc-text">log block（不是log back）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%81%A2%E5%A4%8D"><span class="toc-number">10.2.1.3.</span> <span class="toc-text">恢复</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undo-log"><span class="toc-number">10.2.2.</span> <span class="toc-text">undo log</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log-%E6%97%A5%E5%BF%97%E6%A0%BC%E5%BC%8F"><span class="toc-number">10.2.2.1.</span> <span class="toc-text">undo log 日志格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%82%E5%AF%9F-undo-log"><span class="toc-number">10.2.2.2.</span> <span class="toc-text">观察 undo log</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#purge"><span class="toc-number">10.2.2.3.</span> <span class="toc-text">purge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#group-commit"><span class="toc-number">10.2.2.4.</span> <span class="toc-text">group commit</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">10.3.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.4.</span> <span class="toc-text">分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.4.1.</span> <span class="toc-text">MySQL 分布式事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8-xa-%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.4.2.</span> <span class="toc-text">内部 XA 事务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E5%A5%BD%E7%9A%84%E4%BA%8B%E5%8A%A1%E4%B9%A0%E6%83%AF"><span class="toc-number">10.5.</span> <span class="toc-text">不好的事务习惯</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.5.1.</span> <span class="toc-text">在循环中提交事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E6%8F%90%E4%BA%A4"><span class="toc-number">10.5.2.</span> <span class="toc-text">使用自动提交</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%8A%A8%E5%9B%9E%E6%BB%9A"><span class="toc-number">10.5.3.</span> <span class="toc-text">使用自动回滚</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%BF%E4%BA%8B%E5%8A%A1-long-lived-transactions-%E9%A1%BE%E5%90%8D%E6%80%9D%E4%B9%89-%E5%B0%B1%E6%98%AF%E6%89%A7%E8%A1%8C%E6%97%B6%E9%97%B4%E8%BE%83%E9%95%BF%E7%9A%84%E4%BA%8B%E5%8A%A1"><span class="toc-number">10.5.4.</span> <span class="toc-text">长事务（Long-Lived Transactions），顾名思义，就是执行时间较长的事务。</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>