<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>如何画架构图 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="前言  有意义且具备一致性（coherence）的架构图有助于为不同的利益相关者（stakeholder）澄清（illustrate）事实，并达成共识-反之，图表杂乱无章。 有意义的图表胜过建模（建模指的是With modelling, you&#39;re building up a non-visual model of something (e.g. the software architectur">
<meta property="og:type" content="article">
<meta property="og:title" content="如何画架构图">
<meta property="og:url" content="https://magicliang.github.io/2021/05/07/%E5%A6%82%E4%BD%95%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="前言  有意义且具备一致性（coherence）的架构图有助于为不同的利益相关者（stakeholder）澄清（illustrate）事实，并达成共识-反之，图表杂乱无章。 有意义的图表胜过建模（建模指的是With modelling, you&#39;re building up a non-visual model of something (e.g. the software architectur">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2021/05/07/%E5%A6%82%E4%BD%95%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE/%E5%9C%BA%E6%99%AF%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E5%9B%BE.png">
<meta property="article:published_time" content="2021-05-07T12:39:55.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:32.401Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="系统架构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2021/05/07/%E5%A6%82%E4%BD%95%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE/%E5%9C%BA%E6%99%AF%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E5%9B%BE.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "如何画架构图",
  "url": "https://magicliang.github.io/2021/05/07/%E5%A6%82%E4%BD%95%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE/",
  "image": "https://magicliang.github.io/2021/05/07/%E5%A6%82%E4%BD%95%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE/%E5%9C%BA%E6%99%AF%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E5%9B%BE.png",
  "datePublished": "2021-05-07T12:39:55.000Z",
  "dateModified": "2025-10-22T08:01:32.401Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2021/05/07/%E5%A6%82%E4%BD%95%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '如何画架构图',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2021/05/07/%E5%A6%82%E4%BD%95%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE/%E5%9C%BA%E6%99%AF%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E5%9B%BE.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">如何画架构图</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">如何画架构图</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-05-07T12:39:55.000Z" title="Created 2021-05-07 20:39:55">2021-05-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:32.401Z" title="Updated 2025-10-22 16:01:32">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">4.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>13mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>前言</h1>
<ul>
<li>有意义且具备<strong>一致性（coherence）<strong>的架构图有助于为不同的</strong>利益相关者（stakeholder）澄清（illustrate）事实</strong>，并达成共识-反之，图表杂乱无章。</li>
<li>有意义的图表胜过建模（建模指的是<code>With modelling, you're building up a non-visual model of something (e.g. the software architecture of a software system), and then creating different views (e.g. diagrams) on top of that model. </code>），在架构沟通上，visualization 胜过千言万语。</li>
<li>一致性要求我们有足够好的指导原则，让我们知道标准的<strong>图元</strong>是什么。</li>
<li>“架构是一项复杂的工作，只使用单个图表来表示架构很容易造成莫名其妙的语义混乱”。</li>
<li>在同一个架构图里添加不同层级的抽象可能会导致冲突的出现，因为它们是从不同的角度描述问题的。</li>
<li>应该在架构图旁边加上图例（legend），沟通者应该懂得图元（key）是什么。key 和 legend 都是一种 explicit notion。</li>
<li>架构图越多就越难以理解，而且维护起来也很费劲。最直接的后果就是有可能出现碎片化（比如，通过两到三个架构图来描述同样的质量属性——性能、伸缩性等等——但每一个架构图都无法完整地描述它们）。在这种情况下，建议移除不能反映相关质量属性的架构图，或者把它们合并起来。</li>
</ul>
<h1>两类架构师规范</h1>
<h2 id="togaf">TOGAF</h2>
<p>The Open Group Architecture Framework</p>
<h2 id="archimate">ArchiMate</h2>
<p>ArchiMate，是一种整合多种架构的一种可视化业务分析模型语言，属于架构描述语言（ADL）它从业务、应用和技术三个层次（Layer），物件、行为和主体三个方面（Aspect）和产品、组织、流程、资讯、资料、应用、技术领域（Domain）来进行描述。ArchiMate是 The Open Group 发布的企业级标准。它是一种图形化描述语言，正好可以作为 TOGAF 图形工件的建模工具。</p>
<p>一个比较好的实现是 <a target="_blank" rel="noopener" href="https://www.archimatetool.com/">Archi</a>，其文档见<a href="docs">这里</a>。</p>
<h1>C4</h1>
<p>为什么会有 C4？因为每个团队都有自己的 confused mess of box and lines。</p>
<p>我们当然可以使用 UML 来体现包、组件和其他 stereotypes，但UML 不适合加上描述性文本（descriptive text）。</p>
<blockquote>
<p>The C4 model was created as a way to help software development teams<br>
describe and communicate software architecture, both during up-front<br>
design sessions and when retrospectively documenting an existing<br>
codebase. It’s a way to create maps of your code, at various levels of<br>
detail, in the same way you would use something like Google Maps to<br>
zoom in and out of an area you are interested in.</p>
<p>Although primarily aimed at software architects and developers, the C4<br>
model provides a way for software development teams to efficiently and<br>
effectively communicate their software architecture, at different<br>
levels of detail, telling different stories to different types of<br>
audience, when doing up front design or retrospectively documenting an<br>
existing codebase.</p>
<p>The C4 model consists of a hierarchical set of software architecture<br>
diagrams for context, containers, components, and code.</p>
</blockquote>
<blockquote>
<p>创建 C4 模型是为了帮助软件开发团队在前期设计会议和回顾性记录现有代码库时描述和交流软件架构。这是一种创建代码地图的方法，具有不同的详细程度，就像您使用 Google Maps 之类的工具放大和缩小您感兴趣的区域一样。<br>
尽管主要针对软件架构师和开发人员，但 C4 模型为软件开发团队提供了一种有效地交流他们的软件架构的方法，在进行前期设计或回顾时，以不同的细节级别，向不同类型的受众讲述不同的故事记录现有的代码库。<br>
C4 模型由一组分层的软件架构图组成，用于上下文、容器、组件和代码。</p>
</blockquote>
<p>C4 提倡“抽象为先”，<strong>由一系列抽象引出架构决策</strong>。它的设计模仿了谷歌地图，认为应该通过不同级别的 zoom-in 和 zoom-out 来获取不同层次的信息量。</p>
<p><code>Context -&gt; Container -&gt; Component -&gt; Code</code></p>
<p>Context 是把价值交付给用户（stakeholder）的最高级抽象。Context 里有多个 System。<br>
Container 指的是应用程序或者数据存储（<strong>这个词在软件工业里被滥用了</strong>）。代码在 Container 的边界里执行，数据在 Container 里存储。一个 Container 图就是把一个 System 展开，看到里面的多个 Container（<strong>每个 container 是一个 deployable 或者 runnable unit</strong>）。<br>
Component 指的是<strong>interface 背后</strong>被组织起来的一系列相关功能。<br>
代码是 Code Elements。</p>
<p><img src="c4-overview-1536x1152.png" alt="c4-overview-1536x1152"><br>
<img src="total-diagram.jpeg" alt="total-diagram"><br>
<img src="context-diagram.jpeg" alt="context-diagram"></p>
<p>值得注意的是 context 中的图元总共有 5 种，灰色的盒子是已存在系统的意思。</p>
<h2 id="context-diagram">Context Diagram</h2>
<blockquote>
<p>系统上下文图是绘制和记录软件系统的良好起点，允许您退后一步并查看大图。画一个图表，将您的系统显示为中心的一个盒子，周围是它的用户和与之交互的其他系统。</p>
<p>细节在这里并不重要，因为这是显示系统景观大图的缩小视图。重点应该放在人（演员、角色、画像等）和软件系统上，而不是技术、协议和其他低级细节。<strong>这是您可以向非技术人员展示的那种图表</strong>。</p>
<p><strong>范围</strong>：单个软件系统。</p>
<p><strong>主要元素</strong>：范围内的软件系统。<br>
<strong>支持元素</strong>：在范围内直接连接到软件系统的人员（例如用户、参与者、角色或角色）和软件系统（外部依赖项）。通常，这些其他软件系统位于您自己的软件系统的范围或边界之外，您对它们没有责任或所有权。</p>
<p><strong>目标受众</strong>：软件开发团队内外的每个人，包括技术人员和非技术人员。</p>
<p><strong>推荐给大多数团队</strong>：是的。</p>
</blockquote>
<p><img src="bigbankplc-SystemContext-with-enterprise-boundary-key.png" alt="context-图元"><br>
<img src="bigbankplc-SystemContext-with-enterprise-boundary.png" alt="有企业边界的-context-图例"></p>
<h2 id="container-diagram">Container Diagram</h2>
<blockquote>
<p>一旦您了解您的系统如何适应整个 IT 环境，下一步非常有用的是使用容器图放大系统边界。 “容器”类似于服务器端 Web<br>
应用程序、单页应用程序、桌面应用程序、移动应用程序、数据库架构、文件系统等。本质上，容器是一个可单独运行/可部署的单元（例如一个单独的进程空间)<br>
执行代码或存储数据。</p>
<p>容器图显示了软件架构的高级形状以及如何在其中分配职责。它还显示了主要的技术选择以及容器如何相互通信。这是一个简单的、专注于技术的高级图表，对软件开发人员和支持/运营人员都很有用。</p>
<p><strong>范围</strong>：单个软件系统。</p>
<p><strong>主要元素</strong>：软件系统范围内的容器。<br>
<strong>支持元素</strong>：直接连接到容器的人员和软件系统。</p>
<p><strong>目标受众</strong>：软件开发团队内外的技术人员；包括软件架构师、开发人员和运营/支持人员。</p>
<p><strong>推荐给大多数团队</strong>：是的。</p>
<p><strong>注意</strong>：此图没有说明部署方案、集群、复制、故障转移等。</p>
</blockquote>
<p>注意，container 相比 context 是把企业边界内的系统进行了下钻（drill down）。</p>
<p><img src="container-diagram.jpeg" alt="容器图"><br>
<img src="bigbankplc-Containers-key.png" alt="容器图图元"></p>
<p>接下来，您可以进一步放大和分解每个容器，以确定主要的结构构建块及其相互作用。</p>
<h2 id="component-diagram">Component Diagram</h2>
<p>组件图显示了容器是如何由多个“组件”组成的，每个组件是什么，它们的职责以及技术/实现细节。</p>
<blockquote>
<p><strong>范围</strong>：单个容器。</p>
<p><strong>主要元素</strong>：范围内容器内的组件。<br>
<strong>支持元素</strong>：容器（在范围内的软件系统内）加上直接连接到组件的人员和软件系统。</p>
<p><strong>目标受众</strong>：软件架构师和开发人员。</p>
<p><strong>推荐给大多数团队</strong>：不，仅在您认为组件图增加价值时才创建组件图，并考虑自动创建长期文档。</p>
</blockquote>
<p><img src="bigbankplc-Components.png" alt="组件图"><br>
<img src="bigbankplc-Components-key.png" alt="组件图元"></p>
<h2 id="code-diagram">Code Diagram</h2>
<blockquote>
<p>最后，您可以放大每个组件以显示它是如何作为代码实现的；使用 UML 类图、实体关系图或类似的。</p>
<p>这是一个可选的详细级别，通常可以通过 IDE 等工具按需提供。理想情况下，该图将使用工具（例如 IDE 或 UML<br>
建模工具）自动生成，您应该考虑仅显示那些允许您讲述想要讲述的故事的属性和方法。除了最重要或最复杂的组件外，不建议将这种详细程度用于任何其他组件。</p>
</blockquote>
<blockquote>
<p><strong>范围</strong>：单个组件。</p>
<p><strong>主要元素</strong>：范围内组件的代码元素（例如类、接口、对象、函数、数据库表等）。</p>
<p><strong>目标受众</strong>：软件架构师和开发人员。</p>
<p><strong>推荐给大多数团队</strong>：不，对于长期存在的文档，大多数 IDE 可以按需生成这种级别的详细信息。</p>
</blockquote>
<p><img src="code-diagram.jpeg" alt="代码图"></p>
<p>**我们画 c4 的视图的时候，重点关注 container 和 component 即可。**很多时候我们甚至不需要画出component。</p>
<p>c4 意味着 4 个层次的架构图，自顶向下。</p>
<blockquote>
<p>C4 模型没有预定义任何特定的符号，你在这些示例图中看到的是一个个简单的符号，适用于白板、纸张、便签、索引卡片和各种图表工具。你也可以使用 UML 作为符号，并适当使用包、组件和原型。无论你使用哪种符号，我都会建议让每个元素都包含名称、元素类型（即“人”、“软件系统”，“容器”或“组件”）、技术选型（如果有的话），以及一些描述性文字。在图表中包含如此多的文本可能看起来很不寻常，但这些附加文本有助于消除软件架构图中通常会出现的不明确的表示。</p>
</blockquote>
<p>图元素里至少要包括：名称、类型、描述和其他属性。<br>
线头至少包括：方向、多对多关系、动作（有时候包含宾语）。</p>
<h2 id="system-landscape-diagram">System Landscape diagram</h2>
<p><img src="bigbankplc-SystemLandscape.png" alt="系统景观图"></p>
<p>系统景观图的特点是，可以总览企业边界内的系统。注意企业边界给我们带来的各个系统的关联。</p>
<h2 id="dynamic-diagram">Dynamic diagram</h2>
<p><img src="bigbankplc-SignIn.png" alt="动态视图"></p>
<p>动态视图让我们看到在一个功能/用例/用户故事视角下，系统的组件和容器之间是如何交互的。画图时，不必拘泥于颗粒度在抽象上层次的统一。</p>
<h2 id="deployment-diagram">Deployment diagram</h2>
<p><img src="bigbankplc-LiveDeployment.png" alt="部署视图"></p>
<p>部署视图在视觉上突出了 IaaS 和 Paas 的存在，各种 boundaries 本质上就是划定 containers and deployment nodes。</p>
<h2 id="一些友善的建议">一些友善的建议</h2>
<h3 id="diagrams">Diagrams</h3>
<ul>
<li>每个图都应该有一个描述图类型和范围的标题（例如“我的软件系统的系统上下文图”）。</li>
<li>每个图表都应该有一个键/图例来解释所使用的符号（例如形状、颜色、边框样式、线型、箭头等）。</li>
<li>首字母缩略词和缩写词（业务/领域或技术）应为所有受众都能理解，或在图表键/图例中进行解释。</li>
</ul>
<h3 id="elements">Elements</h3>
<ul>
<li>应明确指定每个元素的类型（例如人员、软件系统、容器或组件）。</li>
<li>每个元素都应该有一个简短的描述，以提供关键职责的“概览”视图。</li>
<li>每个容器和组件都应该有明确指定的技术。</li>
</ul>
<h3 id="relationships">Relationships</h3>
<ul>
<li>每条线都应该代表一种单向关系。</li>
<li>每一行都应该有标签，标签与关系的方向和意图一致（例如依赖或数据流）。尝试使用标签尽可能具体，最好避免使用诸如“使用”之类的单词。</li>
<li>容器之间的关系（通常代表进程间通信）应该有明确标记的技术/协议。</li>
</ul>
<h1>4 + 1 视图</h1>
<p><a href="4+1-view-of-software-architecture.xmind">4+1-view-of-software-architecture.xmind</a><br>
<img src="4+1-view-of-software-architecture.png" alt="4+1-view-of-software architecture"></p>
<h1>漏斗图</h1>
<h1>Plant UML</h1>
<p><a target="_blank" rel="noopener" href="https://real-world-plantuml.com/?type=sequence">Real World PlantUML</a><br>
Plant UML本地使用扩展名 .puml。</p>
<p>使用 <a target="_blank" rel="noopener" href="http://www.plantuml.com/plantuml/uml/hP9BZzem4CVl-HHUr0ChBPj3sqkbIek0Tf5uK1v5FQ59F05NZfrw9l3rEmvXD-f3wg4dE_EV-VyyCtaYXi1rQPCxut9RQrGdvee-f6c0o-FHyAdEQiAGUyVe-37tPLfPSB5cGAojoTBHky4gXdRpMLe2CGO97KPI0SPXUAoYVtAdiP1FDPvydOwMYyq_WBYkG8Uthq0Zwg2GZ05LmJ3IZQVn73LweNnQBhR3_MIpd4_-AwY9mGN9bpXu_pgrMrSfk6DjeMtwT_axdE5lMaa_x84mdF7NyautQNmxjJET3RyjTzl3VhfzFimcdoUBSVy-ILQIu5q_9ZwetgWczYM6djnNw2kBYa_0oY5gLGMlwvn9n3VNJZ_s6a3lFdbPO9ygaEBDQXWzsWRZTNj2LKgACeun592trYpnlCLUDH26kiZikw2RKnS5bH7ZuMeQ_UEmulaCJbia1TOgsPqa4YdhZoRlsiNihjSuw-jCgiV0a05XT9gRF7Zo1QlDbrbZxQscsnWUb0yQWnASFFliJOvo5ZwKmCQxBgopAs4cQxJjlA-psX5Ij6z-FKc8UgD8Vt-M3-jhxysJrmYQqdr4HVa9dPPz_mG0">Web Server</a> 来绘制<a target="_blank" rel="noopener" href="https://github.com/plantuml-stdlib/C4-PlantUML#supported-diagram-types">自己的 C4 图</a>，相应的 <a target="_blank" rel="noopener" href="https://github.com/tupadr3/plantuml-icon-font-sprites">icons</a>。</p>
<p>注意边界：</p>
<ul>
<li>Boundary(alias, label, ?type, ?tags, $link)</li>
<li>Enterprise_Boundary(alias, label, ?tags, $link)</li>
<li>System_Boundary</li>
<li>Container_Boundary(alias, label, ?tags, $link) component 图应该使用这种边界</li>
</ul>
<p>tags 参考 github 例子，link 是真的让这个图表可以被点击的 link（只在 plantUml 的矢量图上可以点，没什么实际用处），所以这两个 attribute 一般是空白的。</p>
<p>一个<a target="_blank" rel="noopener" href="https://www.plantuml.com/plantuml/uml/j91FJy904CNl_HGByO29PG_gnPEaL2K1IW98F3LBEyYQ_RFkp4ByzcvjAYPSFEZrlJVpcpVtIC9Jq2hfILEfK0FR4pcyuzoBu_1LqZvi0uAlh24mDAoivau9qyoaIBMIMvxTf8j6Mi-cN0iay54gCsj8I0D-wFvfltRMWA5sVzAhOHTnR9m_Jx9Yllm5Y88JjRy-0MLqqrrCfEYy9C2ELyEXyV2Ryb3CLwDDlYnc-P-2lZHn1BGQqjlJrxfM_4qSHDlutDFuhig8Ffmz_SUvl3aEMp-PZbwAzQhSJ5PFvJH_pEVZmMMIB6B0ca4Jl6BzYS7WXQc0PG79Ql3zg2x0EWMCzeBODdmmsQMYUT6M-coi_7wJXg8u_hw_WlI9FQhF9iRuPlQYVq3Jb4eQeSMMcbIpP0Z3CVbHTP3zc33KoOnPrmNZX6RmnzZJM_uBxwMrk-E2QLz8sdE-vvpF_Tx3VMvUYbjVUshYuVByGzLGCe9cfiKxMC4R3-1Z2UeTv5OyznTSlk7MKw_NKlY9lNEJeidwSpuZYR8kgmgV5nGXA-KnNnupBJvJjJnMd7rfpWw-GtM8pZlei8BiFhAgC1f2oucaoHCR9_rIrWqX9xyIYaHJ_FSUAq7h8XXKuzx8m0Gy-Gtig0AEyTpJuFEFE1WNz9i3BaKHc6UjCvLrIJHmWCaND3LZY6nzkmRRPsYlXo6nBVWjoviSWLL1WmQqwi7L-pzR9V_aRM0xyA6EIWwCl-7vORSNbAzNjREvYhHQaBIG28QSCtLPfna7KokmJc6dwdUjrMYZuo9tHMQ6Yux9FlH6DNQuy7qOWovTwBvB0hGeP6bJqEKm67G-2SsmakN5Y0vB1czjapNstNW-_-GtJCj9N2sgchIGjfHfJjPlJmPM0nfjTgPmYF1hmkDFcx9Y2afsGzOqLIFTxF-SxGzdxMCY65sfeOlSNdX6tTd1jbyR1FtwmgNpZnkms-VOeajWtRinGs-C-blXHc1vfL_8WlBOK3Q40jaRemby-Wf74ovEHxKHJ4gH7MC0qRUzCzXnS6TX4DqPjI_d3JwHSloZQEqbsJVUzHIhauBplm2iGIkmzoX9ReAwj6a2funbGlf4J1MBQaehYB7UoYuOfUOLj3f-s_4Rzb8bAlYMMP9qiP10d-V_2Z-Gb8oHp_q5">风险landscape的例子</a>：<br>
<img src="%E9%A3%8E%E9%99%A9landscape.png" alt="风险landscape的例子"></p>
<h1>场景分层架构图</h1>
<p>这种架构图能够表达用例、场景、context、container 和 component，像 landscape view。</p>
<p><img src="%E5%9C%BA%E6%99%AF%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="场景分层架构图"><br>
<a href="%E5%9C%BA%E6%99%AF%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E5%9B%BE.drawio">场景分层架构图.drawio</a></p>
<h1>Runtime 图</h1>
<p><a href="Runtime%E5%9B%BE.drawio">Runtime图.drawio</a><br>
<img src="Runtime%E5%9B%BE.png" alt="Runtime图.png"></p>
<h1>数据处理系统</h1>
<p><img src="Flink-Kafka-TSDB-Grafana-stack.jpg" alt="Flink-Kafka-TSDB-Grafana-stack"><br>
<img src="Promethueus%E5%88%86%E9%9B%86%E7%BE%A4.jpg" alt="Promethueus分集群"></p>
<h1>保险架构图</h1>
<p><img src="%E6%9F%90%E7%B1%BB%E4%BF%9D%E9%99%A9%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="某类保险架构图"></p>
<h1>大数据架构图</h1>
<p><img src="Aeraki%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="Aeraki架构图"><br>
<img src="gRPC%E6%97%A0%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC%E6%9E%B6%E6%9E%84.png" alt="gRPC无代理服务网格架构"><br>
<img src="revision-tag.png" alt="revision-tag"><br>
<img src="operation-suggest.png" alt="operation-suggest"><br>
<img src="%E7%A6%BB%E7%BA%BF%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E6%9E%B6%E6%9E%84.png" alt="离线计算平台架构"></p>
<h1>服务治理架构图</h1>
<p><img src="SmartDNSProxy.png" alt="SmartDNSProxy"><br>
<img src="istio%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5.png" alt="istio关键概念"><br>
<img src="istio%E6%9E%B6%E6%9E%84%E5%9B%BE.png" alt="istio架构图"></p>
<h1>Visual Paradigm 的时序图</h1>
<p><a target="_blank" rel="noopener" href="https://online.visual-paradigm.com/diagrams/tutorials/sequence-diagram-tutorial/#return-message">Sequence Diagram Tutorial</a></p>
<h1>DB 架构</h1>
<p><a href="olap%E5%92%8Coltp.drawio">olap和oltp.drawio</a><br>
<img src="olap%E5%92%8Coltp.png" alt="olap和oltp"><br>
<a href="db%E5%AF%B9%E6%AF%94.drawio">db对比.drawio</a><br>
<img src="db%E5%AF%B9%E6%AF%94.png" alt="db对比.png"></p>
<h1>ELK</h1>
<p><img src="ELK-stack.png" alt="ELK-stack"><br>
<img src="ingest-pipeline-process.png" alt="ingest-pipeline-process"><br>
<img src="pipeline%E6%98%AF%E4%B8%80%E7%BB%84processor.png" alt="pipeline是一组processor"><br>
<a href="log-data-warehouse-arch.drawio">log-data-warehouse-arch.drawio</a><br>
<img src="log-data-warehouse-arch.png" alt="log-data-warehouse-arch.png"></p>
<h1>订单系统</h1>
<p><img src="%E7%BE%8E%E5%9B%A2%E5%A4%96%E5%8D%96%E8%AE%A2%E5%8D%95%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="美团外卖订单流程图"></p>
<h1>内存布局</h1>
<p><img src="JVM%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.jpeg" alt="JVM内存布局"></p>
<p>关于常量池的变化，可以参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1690589">《面试题系列第5篇：JDK的运行时常量池、字符串常量池、静态常量池，还傻傻分不清？》</a>。<br>
总而言之，常量池理论上都会被实现在方法区内，但方法区有时候在 JVM的内存区域里，有时候不在。字符串常量池有时候在方法区内实现，有时候在 managed heap 里实现，这些实现都遵循 JVM 规范。</p>
<h1>消息队列</h1>
<p><img src="kafka%E6%97%A5%E5%BF%97%E7%BB%93%E6%9E%84.png" alt="kafka日志结构"><br>
![rocketmq的消息发送原理][rocketmq的消息发送原理.awebp]</p>
<h1>Neflix 架构</h1>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/gu1-56UWW5InnG67zaeTNA">大佬手把手带你复刻 Netflix</a></p>
<p><img src="NetflixHLD%E6%9E%B6%E6%9E%84%E5%9B%BE.jpeg" alt="NetflixHLD架构图"><br>
<img src="%E5%9B%9E%E6%94%BE%E7%9A%84API%E5%BC%82%E6%AD%A5%E6%9E%B6%E6%9E%84.webp" alt="回放的API异步架构"></p>
<h1>阿里巴巴数据库</h1>
<p><img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9B%A2%E9%98%9F%E7%9A%84%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97.png" alt="阿里巴巴数据库团队的时间序列"><br>
<img src="%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E6%95%B0%E6%8D%AE%E5%BA%93%E6%99%BA%E8%83%BD%E5%8C%96%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF.png" alt="阿里巴巴数据库智能化的应用场景"><br>
<img src="%E7%9B%98%E5%8F%A4%E6%9E%B6%E6%9E%84.png" alt="盘古架构"><br>
<img src="%E5%85%A8%E9%93%BE%E8%B7%AF%E5%8E%8B%E6%B5%8B-%E6%8A%80%E6%9C%AF%E5%AE%9E%E7%8E%B0.png" alt="全链路压测-技术实现"><br>
<img src="x-db%E7%9A%84%E6%8A%80%E6%9C%AF%E4%B8%8E%E6%9E%B6%E6%9E%84%E7%90%86%E5%BF%B5.png" alt="x-db的技术与架构理念"></p>
<h1>阿里云飞天</h1>
<p><img src="%E7%A6%BB%E5%9C%A8%E7%BA%BF%E6%B7%B7%E5%B8%83.png" alt="离在线混布"><br>
<img src="%E7%A5%9E%E9%BE%99%E6%9E%B6%E6%9E%84.png" alt="神龙架构"><br>
<img src="%E4%BA%91%E7%BD%91%E8%9E%8D%E5%90%88.jpeg" alt="云网融合"></p>
<h1>知识图谱</h1>
<p><img src="%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E7%9A%84%E4%BD%93%E7%B3%BB.jpg" alt="知识图谱的体系"></p>
<h1>CSDN 架构图</h1>
<p><img src="csdn%E6%9E%B6%E6%9E%84%E5%88%86%E4%BA%AB.jpeg" alt="csdn架构分享"></p>
<h1>Nvidia</h1>
<p><img src="Nvidia-Research.jpg" alt="Nvidia-Research"></p>
<h1>Docker</h1>
<p><img src="docker-swarm-mode-topology.jpg" alt="docker-swarm-mode-topology"><br>
<img src="docker%E6%98%AF%E4%BE%9D%E8%B5%96cli%E7%9A%84%E6%9E%B6%E6%9E%84.jpg" alt="docker是依赖cli的架构"></p>
<h1>Skywalking</h1>
<p><img src="skywalking-architecture.png" alt="skywalking-architecture"></p>
<h1>InLong</h1>
<p><img src="inlong.png" alt="inlong"></p>
<h1>演进式架构</h1>
<p><img src="%E5%8C%85%E5%90%AB%E9%80%82%E5%BA%94%E5%BA%A6%E5%87%BD%E6%95%B0%E9%98%B6%E6%AE%B5%E7%9A%84%E9%83%A8%E7%BD%B2%E6%B5%81%E6%B0%B4%E7%BA%BF.png" alt="包含适应度函数阶段的部署流水线"><br>
<img src="%E5%9C%A8%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%AD%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C%E5%A4%9A%E4%B8%AA%E4%BB%BB%E5%8A%A1.png" alt="在流水线中并行执行多个任务"></p>
<h1>基于 Sketch 画图</h1>
<p><a target="_blank" rel="noopener" href="https://draveness.me/sketch-and-sketch/">技术文章配图指南</a></p>
<p><img src="%E5%88%86%E5%B8%83%E5%BC%8F%E6%9E%B6%E6%9E%84.png" alt="分布式架构"><br>
<img src="tcp-and-udp-packet-size.png" alt="tcp-and-udp-packet-size"><br>
<img src="GoContextTreeConstruction.webp" alt="GoContextTreeConstruction"><br>
<img src="HandleTableAndLRUCache.webp" alt="HandleTableAndLRUCache"><br>
<img src="Zookeeper.webp" alt="Zookeeper"><br>
<img src="Master-Workers-Architecture.webp" alt="Master-Workers-Architecture"><br>
<img src="LevelDBOrganized.webp" alt="LevelDBOrganized"></p>
<h1>Dubbo</h1>
<p><img src="dubbo-architecture.webp" alt="dubbo-architecture"></p>
<h1>tRPC</h1>
<p>插件工厂的整体实现思路是框架只定义插件的标准接口，并提供注册能力，不做具体实现。与外部服务互通，或者对接某个服务治理系统时，只需要开发对应的具体插件即可。</p>
<p>例如: 框架对多协议的支持，定义了统一的Codec，不同协议只需要按照Codec接口即可实现即可。</p>
<p><img src="codec.png" alt="codec"></p>
<p>例如: 框架对接不同名字服务系统，定义了统一的Registry和Selector抽象接口，对接不同的名字服务系统时只需要按照Registry和Selector接口即可实现即可。</p>
<p><img src="naming.png" alt="naming"></p>
<p>通过插件工厂的设计，可以带来以下的好处:</p>
<ul>
<li>对于框架侧: 框架只定义标准接口，没有任何插件实现，与具体平台完全解耦;</li>
<li>对于平台侧: 只需要按照框架插件标准接口即可实现插件，即可将平台的能力融入到框架中;</li>
<li>对于用户侧: 业务开发只需要通过配置进行使用，对用户透明;</li>
</ul>
<p><img src="trpc-architecture.png" alt="trpc-architecture"></p>
<p>总体架构由 “框架核心” 和 “插件” 两部分组成。 其中虚线框内为tRPC，中间的红色实线框为框架核心，蓝色框为插件部分。</p>
<p>框架核心又可以分三层:</p>
<ul>
<li>
<p>通信层: 负责数据的传输和协议的编解码，框架内置支持tcp、udp等通信协议，传输协议采用基于Protocol Buffers的tRPC协议来承载RPC调用，支持通过Codec插件来使用其它传输协议；</p>
</li>
<li>
<p>服务治理层: 负责将服务治理功能抽象成插件，通过调用插件和外部服务治理系统进行对接，实现服务发现、负载均衡、监控、调用链等功能；</p>
</li>
<li>
<p>调用层: 封装服务和服务代理实体，提供RPC调用接口，支持业务用同步、异步、单向以及流式调用等方式进行服务间调用；</p>
</li>
</ul>
<p>此外框架还提供了Admin管理接口，方便用户或者运营平台可以通过调用Admin接口对服务进行管理。 管理接口包括更新配置、查看版本、修改日志级别、查看框架运行时信息等功能，同时框架也支持用户自定义管理接口，以满足业务定制化需求。</p>
<p>插件则是框架核心和外部服务治理组件串联起来的桥梁，按功能大致分为下面几类插件:</p>
<ul>
<li>Codec: 提供协议编解码相关的接口，允许通过插件的方式来扩展业务协议、序列化方式、数据压缩方式等协议处理;</li>
<li>Naming：提供了服务注册(Registry)、服务发现(Selector)、负载均衡(LoadBalance)、熔断(CircuitBreaker)等能力封装，用于对接各种名字服务系统;</li>
<li>Config：提供了配置读取相关的接口，支持读取本地配置文件、远程配置中心配置等，允许插件式扩展支持不同格式的配置文件、不同的配置中心，支持reload、watch配置更新;</li>
<li>Metrics：提供了监控上报的能力，支持常见的单维上报，如Counter、Gauge等，也支持多维上报，允许通过扩展对接不同的监控系统;</li>
<li>Logging：提供了通用的日志采集接口，允许通过插件的方式来扩展日志实现，输出到远程;</li>
<li>Tracing：提供了分布式跟踪能力，允许通过插件的方式上报到调用链系统;</li>
<li>Telemetry：提供了采集和上报遥测数据的能力，是一个集成了链路追踪（Tracing）、监控上报（Metrics）、日志采集（Logging）三大功能的插件；</li>
<li></li>
</ul>
<p>具体插件实现时，一边需要按框架标准接口实现插件，注册到框架核心，并完成插件实例化；另一边具体插件还需要使用外部服务治理服务的SDK或API，实现如服务发现、负载均衡、监控、调用链等功能。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2021/05/07/%E5%A6%82%E4%BD%95%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE/">https://magicliang.github.io/2021/05/07/%E5%A6%82%E4%BD%95%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">系统架构</a></div><div class="post-share"><div class="social-share" data-image="/2021/05/07/%E5%A6%82%E4%BD%95%E7%94%BB%E6%9E%B6%E6%9E%84%E5%9B%BE/%E5%9C%BA%E6%99%AF%E5%88%86%E5%B1%82%E6%9E%B6%E6%9E%84%E5%9B%BE.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2018/01/30/%E5%87%A0%E7%A7%8D%E5%85%B1%E8%AF%86%E7%AE%97%E6%B3%95/" title="几种共识算法"><img class="cover" src="/img/wall-paper-131.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-01-30</div><div class="info-item-2">几种共识算法</div></div><div class="info-2"><div class="info-item-1">达成共识的英文原文是 come to consensus。达成共识以后，也未必代表数据是完全一致的（Raft 算法中 leader 发出 append log 的 commit 命令即算达成共识？但如果中途数据丢失，则还是会有子节点数据不一致）。 在分布式环境下，多个系统协同工作的效率，受制于系统交叉点的性能。在需要达成分布式共识的场景下，分布式共识算法在保证系统安全性的同时，限制了全系统横向扩展的性能提升。 根据环境的不同，可以应用不同的共识算法。 在完全互信的环境下-私有链、私有的分布式数据库，节点之间可以使用 Paxos 或者 Raft 这种 leader 相对固定的算法。 在有限互信的环境下-联盟链，可以使用 PBFT。PBFT 算法是依据确定性的投票（可能是漫长的投票，也可能进入死循环）达到确定性一致的算法。 在没有互信的情况下-公有链，可以使用 POW/POS/DPOS/POA。这类算法是基于概率得到正确的最终一致性，性能比 PBFT 要稍微好点。 最好的共识算法应该模块化，例如 Corda 中的 notary，Hyperledger fabric 中的 solo/k...</div></div></div></a><a class="pagination-related" href="/2018/04/02/%E4%B8%80%E4%B8%AA%E6%BB%9A%E5%8A%A8%E9%87%8D%E5%90%AF%E7%9A%84%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98%E9%97%AE%E9%A2%98/" title="一个滚动重启的状态保存问题"><img class="cover" src="/img/wall-paper-114.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-04-02</div><div class="info-item-2">一个滚动重启的状态保存问题</div></div><div class="info-2"><div class="info-item-1">很多时候滚动重启，都会导致状态丢失。比较好的设计方法是把服务本身设计成无状态的，然后在上游的服务上做好 failover，然后增加 standby server，让 sticky 数据 transmit 到 standby 机器上，让 request 失败以后可以自己由上游重传到 standby server。然后就可以滚动重启了。 这大部分场景下还要考虑幂等的问题。 这就看得出热配置热替换的重要性了。在大多数情况下，除了发布新的 feature 升级以外，都应该尽量用热配置来避免重启。 </div></div></div></a><a class="pagination-related" href="/2018/11/28/%E6%AD%A3%E4%BA%A4%E6%80%A7/" title="正交性"><img class="cover" src="/img/wall-paper-105.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-11-28</div><div class="info-item-2">正交性</div></div><div class="info-2"><div class="info-item-1">所谓正交性（orthogonal 意为正交的），就是设计的维度与其他维度完全隔离，一个正交的设计/值域设计，其变化绝不会受其他正交维度影响，也不会影响其他正交维度。 我们可以把 API 设计成正交的。这样 API 有独立变化的空间的。 我们可以把问题域切分清楚。问题域之间完全不相互干涉（注意跨问题域问题）。 我们可以把变量、字段、列设计成正交的。这样不同业务场景下，列之间的赋值不会相互覆盖。 </div></div></div></a><a class="pagination-related" href="/2019/08/30/%E3%80%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%81%A2%E5%A4%8D%E6%80%9D%E8%B7%AF%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《高可用恢复思路》笔记"><img class="cover" src="/img/wall-paper-71.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-08-30</div><div class="info-item-2">《高可用恢复思路》笔记</div></div><div class="info-2"><div class="info-item-1">遇到线上问题，经常陷入一个误区：一定要找到问题的根因（root cause）。但实际上对线上应用而言，最重要的是恢复可用性，所以在开发设计环境除了完成功能性需求以外，还需要加入非功能性设计的需求：  限流保护。抵挡来自突发流量冲垮整个集群。 降级保护，对调用的服务接口保持警惕，其各种因素导致不可用，可以对齐降级，从而确保核心功能可用。 削峰填谷（traffic shaping），不因突发数据来袭，造成任务消费陡增，造成调用系统的连串抖动。  这些基本的系统保护，是应对未来的各种突发不确定事件的高可用思考。 以上描述的是问题的应对机制设计，问题的发现机制，也需要结构化地考虑，体系化地建设：  发现机制，是我们的眼睛，也是基础。 监控主指标，需要找对业务的主要指标，常见的主指标一般是：RT（响应时间）、总量、成功量、失败量、成功率。 主指标有异常，还要有细分维度（即结果还可以内部 group by aggregation）。 快速恢复 根据监控快速寻找问题发生的方向和位置。 找对恢复的人、恢复的预案。 倾向于选择成本低的恢复手段。---- 并不是所有的恢复都用大招（熔断、限流），大招...</div></div></div></a><a class="pagination-related" href="/2019/09/05/%E3%80%8A%E5%BA%94%E7%94%A8%E6%9E%B6%E6%9E%84%E4%B9%8B%E9%81%93%E3%80%8B%E7%AC%94%E8%AE%B0/" title="《应用架构之道》笔记"><img class="cover" src="/img/wall-paper-93.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-05</div><div class="info-item-2">《应用架构之道》笔记</div></div><div class="info-2"><div class="info-item-1">架构师的职责 化繁为简。架构师是职责就是把复杂的问题简单化，使得其他人能够更好地在架构里工作。 架构师要努力训练自己的思维，用它去理解复杂的系统，通过合理的分解和抽象，做出合理的设计。 软件架构 软件架构是一个系统的草图。软件架构描述的对象是直接构成系统的抽象组件。各个组件的链接则明确和相对细致地描述组件之间的通信。  软件架构为软件系统提供了结构、行为和属性的高级抽象。，由构件的描述、构件的相互作用、指导构件集成的模式以及这些模式的约束组成。软件架构不仅显示了软件需求和软件结构之间的对应关系，而且指定了整个软件系统的组织和拓扑结构，提供了一些设计决策的基本原理。 软件架构的核心价值应该只围绕一个核心命题：控制复杂性。  软件架构分类  业务架构：由业务架构师负责，也可以称为业务领域专家、行业专家。业务架构属于顶层设计，其对业务的定义和划分会影响组织结构和技术架构。 应用架构：由应用架构师负责，他需要根据业务场景的需要，设计应用的层次结构，制定应用规范、定义接口和数据交互协议等。并尽量将应用的复杂度控制在一个可以接受的水平，从而在快速的支撑业务发展的同时，在保证系统的可用性和可维...</div></div></div></a><a class="pagination-related" href="/2019/09/26/%E6%9E%B6%E6%9E%84%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E7%AC%94%E8%AE%B0/" title="架构整洁之道笔记"><img class="cover" src="/img/wall-paper-98.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-26</div><div class="info-item-2">架构整洁之道笔记</div></div><div class="info-2"><div class="info-item-1">最早的《The Clean Architecture》诞生于 2012年，这个问题很早就被讨论清楚了。 思维导图：   注意，所有的接口都是在高层声明的：UseCase Input Port 和 UseCase Output port，所以高层可以实现高层的接口，低层也可以实现高层的接口。 注意，sofa的分层就是在一个横向的模块里声明了业务用例的接口和 core-model 的接口，这样源代码级的依赖都集中在抽象上：   Use Case Interactor 和 Presenter 应该是可测试的，而 Data Access Interface、View、ORM 应该是 humble object。所以一个应用的低层（外层）应该是被排除掉不做测试的。 附件下载： xmind 关于源代码中的依赖关系的一些澄清：  “使用”并不意味着“定义”，而只是引用  dashed outline 代表虚线框，也代表抽象。           </div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">两类架构师规范</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#togaf"><span class="toc-number">2.1.</span> <span class="toc-text">TOGAF</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#archimate"><span class="toc-number">2.2.</span> <span class="toc-text">ArchiMate</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">C4</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#context-diagram"><span class="toc-number">3.1.</span> <span class="toc-text">Context Diagram</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#container-diagram"><span class="toc-number">3.2.</span> <span class="toc-text">Container Diagram</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#component-diagram"><span class="toc-number">3.3.</span> <span class="toc-text">Component Diagram</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#code-diagram"><span class="toc-number">3.4.</span> <span class="toc-text">Code Diagram</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#system-landscape-diagram"><span class="toc-number">3.5.</span> <span class="toc-text">System Landscape diagram</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dynamic-diagram"><span class="toc-number">3.6.</span> <span class="toc-text">Dynamic diagram</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deployment-diagram"><span class="toc-number">3.7.</span> <span class="toc-text">Deployment diagram</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%8F%8B%E5%96%84%E7%9A%84%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.8.</span> <span class="toc-text">一些友善的建议</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#diagrams"><span class="toc-number">3.8.1.</span> <span class="toc-text">Diagrams</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#elements"><span class="toc-number">3.8.2.</span> <span class="toc-text">Elements</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#relationships"><span class="toc-number">3.8.3.</span> <span class="toc-text">Relationships</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">4 + 1 视图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">漏斗图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Plant UML</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">场景分层架构图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">Runtime 图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">数据处理系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">保险架构图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">大数据架构图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">服务治理架构图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">Visual Paradigm 的时序图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">DB 架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">ELK</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">订单系统</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">内存布局</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">18.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">19.</span> <span class="toc-text">Neflix 架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">20.</span> <span class="toc-text">阿里巴巴数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">21.</span> <span class="toc-text">阿里云飞天</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">22.</span> <span class="toc-text">知识图谱</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">23.</span> <span class="toc-text">CSDN 架构图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">24.</span> <span class="toc-text">Nvidia</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">25.</span> <span class="toc-text">Docker</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">26.</span> <span class="toc-text">Skywalking</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">27.</span> <span class="toc-text">InLong</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">28.</span> <span class="toc-text">演进式架构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">29.</span> <span class="toc-text">基于 Sketch 画图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">30.</span> <span class="toc-text">Dubbo</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">31.</span> <span class="toc-text">tRPC</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>