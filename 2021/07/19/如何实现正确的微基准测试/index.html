<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>如何实现正确的微基准测试 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="原问题 FROM：《How do I write a correct micro-benchmark in Java?》 Tips about writing micro benchmarks from the creators of Java HotSpot: Rule 0: Read a reputable paper on JVMs and micro-benchmarking. A goo">
<meta property="og:type" content="article">
<meta property="og:title" content="如何实现正确的微基准测试">
<meta property="og:url" content="https://magicliang.github.io/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="原问题 FROM：《How do I write a correct micro-benchmark in Java?》 Tips about writing micro benchmarks from the creators of Java HotSpot: Rule 0: Read a reputable paper on JVMs and micro-benchmarking. A goo">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-123.jpg">
<meta property="article:published_time" content="2021-07-19T07:20:11.000Z">
<meta property="article:modified_time" content="2026-01-24T07:32:07.428Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-123.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "如何实现正确的微基准测试",
  "url": "https://magicliang.github.io/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/",
  "image": "https://magicliang.github.io/img/wall-paper-123.jpg",
  "datePublished": "2021-07-19T07:20:11.000Z",
  "dateModified": "2026-01-24T07:32:07.428Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '如何实现正确的微基准测试',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-123.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">如何实现正确的微基准测试</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">如何实现正确的微基准测试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-07-19T07:20:11.000Z" title="Created 2021-07-19 15:20:11">2021-07-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T07:32:07.428Z" title="Updated 2026-01-24 15:32:07">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">3.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>16mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>原问题</h1>
<p>FROM：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/504103/how-do-i-write-a-correct-micro-benchmark-in-java">《How do I write a correct micro-benchmark in Java?》</a></p>
<p>Tips about writing micro benchmarks <a target="_blank" rel="noopener" href="https://wiki.openjdk.java.net/display/HotSpot/Main">from the creators of Java HotSpot</a>:</p>
<p>Rule 0: Read a reputable paper on JVMs and micro-benchmarking. A good one is <a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/java/library/j-jtp02225">Brian Goetz, 2005</a>. Do not expect too much from micro-benchmarks; they measure only a limited range of JVM performance characteristics.</p>
<p>Rule 1: Always include a warmup phase which runs your test kernel all the way through, enough to trigger all initializations and compilations before timing phase(s). (Fewer iterations is OK on the warmup phase. The rule of thumb is several tens of thousands of inner loop iterations.)</p>
<p>Rule 2: Always run with -XX:+PrintCompilation, -verbose:gc, etc., so you can verify that the compiler and other parts of the JVM are not doing unexpected work during your timing phase.</p>
<p>Rule 2.1: Print messages at the beginning and end of timing and warmup phases, so you can verify that there is no output from Rule 2 during the timing phase.</p>
<p>Rule 3: Be aware of the difference between -client and -server, and OSR and regular compilations. The -XX:+PrintCompilation flag reports OSR compilations with an at-sign to denote the non-initial entry point, for example: Trouble$1::run @ 2 (41 bytes). Prefer server to client, and regular to OSR, if you are after best performance.</p>
<p>Rule 4: Be aware of initialization effects. Do not print for the first time during your timing phase, since printing loads and initializes classes. Do not load new classes outside of the warmup phase (or final reporting phase), unless you are testing class loading specifically (and in that case load only the test classes). Rule 2 is your first line of defense against such effects.</p>
<p>Rule 5: Be aware of deoptimization and recompilation effects. Do not take any code path for the first time in the timing phase, because the compiler may junk and recompile the code, based on an earlier optimistic assumption that the path was not going to be used at all. Rule 2 is your first line of defense against such effects.</p>
<p>Rule 6: Use appropriate tools to read the compiler’s mind, and expect to be surprised by the code it produces. Inspect the code yourself before forming theories about what makes something faster or slower.</p>
<p>Rule 7: Reduce noise in your measurements. Run your benchmark on a quiet machine, and run it several times, discarding outliers. Use -Xbatch to serialize the compiler with the application, and consider setting -XX:CICompilerCount=1 to prevent the compiler from running in parallel with itself. Try your best to reduce GC overhead, set Xmx(large enough) equals Xms and use UseEpsilonGC if it is available.</p>
<p>Rule 8: Use a library for your benchmark as it is probably more efficient and was already debugged for this sole purpose. Such as JMH, <a target="_blank" rel="noopener" href="https://github.com/google/caliper">Caliper</a> or <a target="_blank" rel="noopener" href="http://cseweb.ucsd.edu/~wgg/JavaProf/javaprof.html">Bill and Paul’s Excellent UCSD Benchmarks for Java</a>.</p>
<p>规则 0：阅读有关 JVM 和微基准测试的知名论文。 <a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/java/library/j-jtp02225">Brian Goetz, 2005</a> 是一个很好的例子。不要对微基准期望过高；它们仅测量有限范围的 JVM 性能特征。</p>
<p>规则 1：始终包含一个预热阶段，它会一直运行您的测试内核，足以在计时阶段之前触发所有初始化和编译。 （预热阶段的迭代次数较少。经验法则是数万次内循环迭代。）<strong>几万次足以预热大部分东西</strong>。</p>
<p>规则 2：始终使用 -XX:+PrintCompilation、-verbose:gc 等运行，这样您就可以验证编译器和 JVM 的其他部分在您的计时阶段没有做预期之外的工作。<strong>如果做了它会打印出来</strong>。</p>
<p>规则 2.1：在计时和预热阶段的开始和结束时打印消息，以便您可以验证在计时阶段没有规则 2 的输出。<strong>如何做到呢，依靠 JMH 吧</strong>。</p>
<p>规则 3：注意<code>-client</code>和<code>-server</code>之间的区别，以及 OSR 和常规编译之间的区别。 <code>-XX:+PrintCompilation</code>标志用 at 符号报告 OSR 编译，以表示非初始入口点，例如：<code>Trouble$1::run@2（41 bytes）</code>。如果您追求最佳性能，则更喜欢服务器而不是客户端，并且更喜欢 OSR。<strong>我真的看得懂 OSR 的日志吗</strong>？</p>
<p>规则 4：注意初始化效果。不要在计时阶段第一次打印，因为打印会加载和初始化类。不要在预热阶段（或最终报告阶段）之外加载新类，除非您专门测试类加载（在这种情况下只加载测试类）。规则 2 是您抵御此类影响的第一道防线。<strong>类加载是一种容易被忽略的性能瓶颈，打印是另一种</strong>。</p>
<p>规则 5：注意反优化和重新编译的影响。不要在计时阶段才第一次使用任何代码路径，因为编译器可能会根据早先的乐观假设，即根本不会使用该路径，而重新编译代码。规则 2 是您抵御此类影响的第一道防线。</p>
<p>规则 6：使用适当的工具来读懂编译器的想法，并期望对它生成的代码感到惊讶。在形成关于什么使某事更快或更慢的理论之前，自己检查代码。<strong>不要以为自己懂编译器</strong>。</p>
<p>规则 7：减少测量中的噪声。在安静的机器上运行您的基准测试，并运行几次，丢弃异常值。使用 -Xbatch 将编译器与应用程序序列化，并考虑设置 -XX:CICompilerCount=1 以防止编译器与自身并行运行。尽量减少 GC 开销，设置 Xmx（足够大）等于 Xms 并在可用时使用 UseEpsilonGC。<strong>可以使用无操作垃圾收集器</strong>。</p>
<p>规则 8：为您的基准测试使用一个库，因为它可能更有效，并且已经为此目的进行了调试。例如 JMH、<a target="_blank" rel="noopener" href="https://github.com/google/caliper">Caliper</a> 或 <a target="_blank" rel="noopener" href="http://cseweb.ucsd.edu/~wgg/JavaProf/javaprof.html">Bill and Paul’s Better UCSD Benchmarks for Java</a>。</p>
<p>Also, never use System.currentTimeMillis() unless you are OK with + or - 15 ms accuracy, which is typical on most OS + JVM combinations.</p>
<p>不要使用 System.nanoTime() 和 System.currentTimeMillis() 这两个 api。但 System.nanoTime() 始终是单调钟，虽然不精确，总是向前的。</p>
<h1>样例工程</h1>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jmh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jmh-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-generator-annprocess --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jmh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 参考 https://github.com/openjdk/jmh/blob/master/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_03_States.java</span><br><span class="hljs-meta">@State(Scope.Benchmark)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonUtilBenchMark</span> &#123;<br><br>    <span class="hljs-meta">@State(Scope.Thread)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyState</span> &#123;<br>        <span class="hljs-comment">// 在每一个 Invocation 级别做一次 setup。参数随机化要这一步做</span><br>        <span class="hljs-meta">@Setup(Level.Invocation)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSetup</span><span class="hljs-params">()</span> &#123;<br>            Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">boundedRandomValue</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current().nextInt(-<span class="hljs-number">10000000</span>, <span class="hljs-number">10000000</span>);<br>                map.put(boundedRandomValue + <span class="hljs-string">&quot;&quot;</span>, boundedRandomValue + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>            mapStr = JsonUtils.toJson(map);<br>            System.out.println(<span class="hljs-string">&quot;Do Setup&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@TearDown(Level.Invocation)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doTearDown</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Do TearDown&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String mapStr;<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-meta">@BenchmarkMode(Mode.All)</span> <span class="hljs-comment">// 吞吐量、耗时、采样、冷启动这些模式都跑一遍</span><br>    <span class="hljs-meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureToObj</span><span class="hljs-params">(MyState state)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(JsonUtils.toObj(state.mapStr, Map.class));<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-meta">@BenchmarkMode(Mode.All)</span><br>    <span class="hljs-meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureToObj2</span><span class="hljs-params">(MyState state)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(JsonUtils.toObj2(state.mapStr, Map.class));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>        <span class="hljs-type">Options</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>()<br>                .include(JsonUtilBenchMark.class.getSimpleName())<br>                .threads(<span class="hljs-number">80</span>)<br>                <span class="hljs-comment">// 4 * 500 秒 = 33.3333333333 分(分钟)</span><br>                .warmupIterations(<span class="hljs-number">500</span>)<br>                <span class="hljs-comment">// 每个循环每个模式跑 1s，如果开 all mode，实际上要跑 4 * 50000 秒等于55.5555555556 时(小时)</span><br>                .measurementIterations(<span class="hljs-number">50000</span>)<br>                <span class="hljs-comment">// https://stackoverflow.com/questions/35046745/what-is-the-purpose-of-jmh-fork</span><br>                <span class="hljs-comment">// fork 是为了实现 JVM 级的隔离</span><br>                .measurementIterations(<span class="hljs-number">50000</span>)<br>                .forks(<span class="hljs-number">20</span>)<br>                .build();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opt).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>JMH 教程</h1>
<p>参考<a target="_blank" rel="noopener" href="https://hezhiqiang8909.gitbook.io/java/docs/javalib/jmh">《JMH 应用指南》</a>。</p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/9d8c81113a978540cc5793139">《基准测试神器 JMH —— 详解 36 个官方例子》</a></p>
<h2 id="基本概念">基本概念</h2>
<ul>
<li>Iteration - iteration 是 JMH 进行测试的最小单位，包含一组 invocations。</li>
<li>Invocation - 一次 benchmark 方法调用。</li>
<li>Operation - benchmark 方法中，被测量操作的执行。如果被测试的操作在 benchmark 方法中循环执行，可以使用@OperationsPerInvocation表明循环次数，使测试结果为单次 operation 的性能。</li>
<li>Warmup - 在实际进行 benchmark 前先进行预热。因为某个函数被调用多次之后，JIT 会对其进行编译，通过预热可以使测量结果更加接近真实情况。</li>
</ul>
<h2 id="api">API</h2>
<h3 id="benchmarkmode">@BenchmarkMode</h3>
<ul>
<li>Throughput - 整体吞吐量，例如“1 秒内可以执行多少次调用”。</li>
<li>AverageTime - 调用的平均时间，例如“每次调用平均耗时 xxx 毫秒”。</li>
<li>SampleTime - 随机取样，最后输出取样结果的分布，例如“99%的调用在 xxx 毫秒以内，99.99%的调用在 xxx 毫秒以内”</li>
<li>SingleShotTime - <strong>以上模式都是默认一次 iteration 是 1s</strong>，唯有 SingleShotTime 是只运行一次。往往同时把 warmup 次数设为 0，<strong>用于测试冷启动时的性能</strong>。</li>
<li>All - 所有模式</li>
</ul>
<h3 id="warmup">@Warmup</h3>
<p>上面我们提到了，进行基准测试前需要进行预热。一般我们前几次进行程序测试的时候都会比较慢， 所以要让程序进行几轮预热，保证测试的准确性。其中的参数 iterations 也就非常好理解了，就是预热轮数。<br>
为什么需要预热？因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译成为机器码从而提高执行速度。所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。</p>
<h3 id="measurement">@Measurement</h3>
<ul>
<li>iterations - 进行测试的轮次</li>
<li>time - 每轮进行的时长</li>
<li>timeUnit - 时长单位</li>
</ul>
<h3 id="threads">@Threads</h3>
<p>每个进程中的测试线程，这个非常好理解，根据具体情况选择，一般为 cpu 乘以 2。</p>
<h3 id="fork">@Fork</h3>
<p>进行 fork 的次数。如果 fork 数是 2 的话，则 JMH 会 fork 出两个进程来进行测试。</p>
<h3 id="outputtimeunit">@OutputTimeUnit</h3>
<p>这个比较简单了，基准测试结果的时间类型。一般选择秒、毫秒、微秒。</p>
<h3 id="benchmark">@Benchmark</h3>
<p>方法级注解，表示该方法是需要进行 benchmark 的对象，用法和 JUnit 的 @Test 类似。</p>
<h3 id="param">@Param</h3>
<p>属性级注解，@Param 可以用来指定某项参数的多种情况。特别适合用来测试一个函数在不同的参数输入的情况下的性能。</p>
<h3 id="setup">@Setup</h3>
<p>方法级注解，这个注解的作用就是我们需要在测试之前进行一些准备工作，比如对一些数据的初始化之类的。我们可以在每一次 Invocation 以前做一次 Setup。</p>
<h3 id="teardown">@TearDown</h3>
<p>方法级注解，这个注解的作用就是我们需要在测试之后进行一些结束工作，比如关闭线程池，数据库连接等的，主要用于资源的回收等。这个东西需要很慎重。</p>
<h3 id="state">@State</h3>
<p>当使用 @Setup 参数的时候，必须在类上加这个参数，不然会提示无法运行。<br>
State 用于声明某个类是一个“状态”，然后接受一个 Scope 参数用来表示该状态的共享范围。 因为很多 benchmark 会需要一些表示状态的类，JMH 允许你把这些类以依赖注入的方式注入到 benchmark 函数里。Scope 主要分为三种。</p>
<ul>
<li>Thread - 该状态为每个线程独享。</li>
<li>Group - 该状态为同一个组里面所有线程共享。</li>
<li>Benchmark - 该状态在所有线程间共享。</li>
</ul>
<h2 id="解读输出报告">解读输出报告</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs bash">255195.938 ±(99.9%) 48484.059 ns/op<br><br><br>Result <span class="hljs-string">&quot;类名.方法名&quot;</span>:<br>  N = 20<br>  mean = 324719.516 ±(99.9%) 302945.897 ns/op<br><br>  Histogram, ns/op:<br>    [      0.000,  125000.000) = 0 <br>    <span class="hljs-comment"># 有 14 个 iteration 在 125 微秒中执行完成</span><br>    [ 125000.000,  250000.000) = 14 <br>    [ 250000.000,  375000.000) = 5 <br>    [ 375000.000,  500000.000) = 0 <br>    [ 500000.000,  625000.000) = 0 <br>    [ 625000.000,  750000.000) = 0 <br>    [ 750000.000,  875000.000) = 0 <br>    [ 875000.000, 1000000.000) = 0 <br>    [1000000.000, 1125000.000) = 0 <br>    [1125000.000, 1250000.000) = 0 <br>    [1250000.000, 1375000.000) = 0 <br>    [1375000.000, 1500000.000) = 0 <br>    [1500000.000, 1625000.000) = 0 <br>    [1625000.000, 1750000.000) = 0 <br>    <span class="hljs-comment"># 有一个 iteration 在1.75 毫秒内执行完成</span><br>    [1750000.000, 1875000.000) = 1 <br><br> <span class="hljs-comment"># 有若干个点在这些 p(50.0000)分位被执行出来。</span><br>  Percentiles, ns/op:<br>      p(0.0000) = 224220.638 ns/op<br>     p(50.0000) = 237448.319 ns/op<br>     p(90.0000) = 331986.035 ns/op<br>     p(95.0000) = 1728070.972 ns/op<br>     p(99.0000) = 1801399.338 ns/op<br>     p(99.9000) = 1801399.338 ns/op<br>     p(99.9900) = 1801399.338 ns/op<br>     p(99.9990) = 1801399.338 ns/op<br>     p(99.9999) = 1801399.338 ns/op<br>    p(100.0000) = 1801399.338 ns/op<br><br><span class="hljs-comment"># 总共花了 4 分 46 秒执行基准测试</span><br><span class="hljs-comment"># Run complete. Total time: 00:04:46</span><br><br>Benchmark                                                                        Mode      Cnt       Score     Error   Units<br>RiskOutServiceImplBenchMark.measureJson                                         thrpt       20       0.057 ±   0.008  ops/us<br>RiskOutServiceImplBenchMark.measureMessageFormat                                thrpt       20       0.057 ±   0.009  ops/us<br>RiskOutServiceImplBenchMark.measureOrigin                                       thrpt       20       0.066 ±   0.007  ops/us<br><span class="hljs-comment"># 注意，在 avg time 模式下，我们会发现 avg 都很高，主要是因为 tp 的长尾线拉高了 avg</span><br>RiskOutServiceImplBenchMark.measureJson                                          avgt       20    1420.907 ± 176.300   us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat                                 avgt       20    1191.810 ± 142.301   us/op<br>RiskOutServiceImplBenchMark.measureOrigin                                        avgt       20    1170.264 ± 119.390   us/op<br><span class="hljs-comment"># 在采样模式下看分位线</span><br>RiskOutServiceImplBenchMark.measureJson                                        sample  1420574    1175.533 ±  17.038   us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.00                      sample               38.976             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.50                      sample               78.720             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.90                      sample              144.640             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.95                      sample              831.488             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.99                      sample            34537.472             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.999                     sample            65142.784             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.9999                    sample           100524.687             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p1.00                      sample           249823.232             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat                               sample  1490803    1109.570 ±  18.395   us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.00    sample               37.440             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.50    sample               74.624             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.90    sample              115.072             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.95    sample              376.730             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.99    sample            40566.784             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.999   sample            78118.912             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.9999  sample           123590.358             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p1.00    sample           216268.800             us/op<br>RiskOutServiceImplBenchMark.measureOrigin                                      sample  1426009    1184.753 ±  20.095   us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.00                  sample               36.480             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.50                  sample               73.088             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.90                  sample              114.816             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.95                  sample              376.320             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.99                  sample            38666.240             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.999                 sample            90570.752             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.9999                sample           148111.360             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p1.00                  sample           318767.104             us/op<br><span class="hljs-comment"># 下面是冷启动的分数，冷启动时单个操作 525 微秒，高于 5p50，但低于 tp 99</span><br>RiskOutServiceImplBenchMark.measureJson                                            ss       20     525.691 ± 294.527   us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat                                   ss       20     489.662 ± 514.746   us/op<br>RiskOutServiceImplBenchMark.measureOrigin                                          ss       20     341.841 ± 215.144   us/op<br></code></pre></td></tr></table></figure>
<p>注意标准差： STDEV 基于样本估算标准偏差。标准偏差反映数值相对于平均值(mean) 的离散程度。</p>
<ul>
<li>ops/us - operations (benchmark method executions) per microsecond</li>
<li>Cnt - total number of trials (forks*iterations)</li>
<li>Score - benchmark result</li>
<li>Error - standard error value. Means how much different trials results differ<br>
Also:</li>
<li>thrpt - Throughput mode (how much full benchmark method executions were made in a trial)</li>
<li>avgt - Average Time mode (how much measuring units took benchmark method execution on average)</li>
</ul>
<p>有兴趣还可以试试这两个网站：<br>
<a target="_blank" rel="noopener" href="http://deepoove.com/jmh-visual-chart/">JMH Visual Chart</a><br>
<a target="_blank" rel="noopener" href="https://jmh.morethan.io/">JMH Visualizer</a></p>
<p>另外一种解释，参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/cndmss/article/details/93771981">《使用JMH进行基准性能测试》</a>：</p>
<p><strong>数字只能告诉我们 what，通常不能告诉我们 when、where、how 和 why。搞懂 why 是人的工作</strong>：</p>
<blockquote>
<p>REMEMBER: The numbers below are just data. To gain reusable insights,<br>
you need to follow up on why the numbers are the way they are. Use<br>
profilers (see -prof, -lprof), design factorial experiments, perform<br>
baseline and negative tests that provide experimental control, make<br>
sure the benchmarking environment is safe on JVM/OS/HW level, ask for<br>
reviews from the domain experts. Do not assume the numbers tell you<br>
what you want them to tell.</p>
<p>记住：下面的数字只是数据。要获得可重复使用的见解，您需要跟进 为什么数字是这样的。使用分析器（参见 -prof、-lprof），设计因子<br>
实验，执行提供实验控制的基线和负面测试，确保 基准测试环境在 JVM/OS/HW 级别是安全的，请咨询领域专家。<br>
不要假设数字告诉您您希望他们告诉您的内容。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">块</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">参数信息（1-10行）</td>
<td style="text-align:center">1：jmh版本<br>2：jvm版本信息<br>3：jvm程序（jdk安装路径）<br>4：jvm参数配置<br>5：预热参数：预热次数、每次持续时间<br>6：测试参数：测试次数、每次持续时间<br>7：每次测试迭代超时时间<br>8：每个测试进程的测试线程数<br>9: 测试的模式<br>10:测试的方法</td>
</tr>
<tr>
<td style="text-align:center">测试过程（12-75行）</td>
<td style="text-align:center">12-23：第1次fork测试 （fork可以理解为1个独立的进程）<br>12：测试完成进度，预计剩余需要时间<br>13：当前第几次fork<br>14-18：预热执行，每次预热执行耗时<br>19-23：正式测试执行，每次测试执行耗时<br>25-36：第2次fork测试<br>38-49：第3次fork测试<br>51-62：第4次fork测试<br>64-75：第5次fork测试</td>
</tr>
<tr>
<td style="text-align:center">测试结果（78-95行）</td>
<td style="text-align:center">78-81：测试结果，包括测试的方法、平均耗时[平局耗时的比例]、最大最小 耗时、测试结果数据离散度（stdev）等<br>84：测试总耗时<br>86-90：对测试结果的解释<br>92-93：测试结论{测试的方法、测试类型（Mode）、测试总次数(Cnt)、测试结果(Score)、误差(Error)、单位(Units)}<br>95：结束</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/">https://magicliang.github.io/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-123.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-17.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-141.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-159.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">卡表和 RSet 问题定义：为什么需要跨区域引用记录 JVM 垃圾收集器的核心工作之一是确定 live set——哪些对象仍然存活、不可回收。确定 live set 的标准做法是从 GC Roots（栈帧中的局部变量、静态字段等）出发，沿引用链遍历所有可达对象。 问题在于：当堆被划分为多个区域（代、Region）并且只回收其中一部分时，如何高效地找到从&quot;不回收区域&quot;指向&quot;回收区域&quot;的引用？ 以 Young GC 为例：只回收新生代，但老年代中可能持有指向新生代对象的引用。如果不处理这些跨代引用，就会错误地回收仍被老年代引用的新生代对象。最朴素的做法是扫描整个老年代来找出这些引用——但老年代通常远大于新生代，这样做的代价过高，违背了分代收集&quot;只回收一部分堆&quot;的初衷。 卡表（Card Table）和 RSet（Remembered Set）正是为解决这个问题而设计的辅助数据结构。二者的关系并非互相替代，而是层次不同、协作互补：卡表是底层的脏标记机制，RSet 是建立在卡表之上的更高层索引结构。 核心概念速览 在深入细节之前，...</div></div></div></a><a class="pagination-related" href="/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" title="重述双亲委派模型"><img class="cover" src="/img/wall-paper-16.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-05</div><div class="info-item-2">重述双亲委派模型</div></div><div class="info-2"><div class="info-item-1">何时加载类 根据 Java 语言规范（JLS §12.4），类或接口在首次主动使用时才会被初始化。主动使用包括以下情况：  遇到 new、getstatic、putstatic、invokestatic 等字节码指令时。这些指令分别对应创建对象实例、读取或设置静态字段、调用静态方法。 对类进行反射调用时，如 Class.forName() 或 Method.invoke()。 初始化某个类的子类时，父类会先被初始化（但父类接口不会）。 虚拟机启动时会先加载设置的主类，即包含 main() 方法的类。 使用 java.lang.invoke 包的动态语言支持特性时，如 MethodHandle 调用。  需要注意的是，被动引用（如通过数组引用、常量引用、访问子类的静态字段等）不会触发类初始化。 从 Java 到 cpp 源码分析 双亲委派模型的工作流程 双亲委派模型的核心逻辑在 java.lang.ClassLoader.loadClass(String name, boolean resolve) 方法中： 123456789101112131415161718192021222...</div></div></div></a><a class="pagination-related" href="/2020/03/08/JMX-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9/" title="JMX 深度历险"><img class="cover" src="/img/wall-paper-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-08</div><div class="info-item-2">JMX 深度历险</div></div><div class="info-2"><div class="info-item-1">JMX 常见指标 JVM 指标 系统指标    System 相关指标 描述     system.load.average 系统load，如果是docker，此指标收集的物理机的load   cpu.system.load.percent 系统所有进程占用cpu的百分比   cpu.jvm.load.percent jvm占用cpu的百分比   system.process.used.phyical.memory 系统使用的物理内存   system.process.used.swap.size 系统使用的swap内存    JVM 内存指标    JVM相关指标 描述     jvm.gc.count GC的次数   jvm.gc.time GC的时间，单位毫秒   jvm.younggc.count 年轻代GC的次数 ，包括的GC算法（Copy，ParNew，PS Scavenge，G1 Young Generation）   jvm.younggc.time 年轻代GC的时间，单位毫秒   jvm.fullgc.count 年老代GC的次数，包括的GC算法   jvm.f...</div></div></div></a><a class="pagination-related" href="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" title="现代垃圾收集器"><img class="cover" src="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-27</div><div class="info-item-2">现代垃圾收集器</div></div><div class="info-2"><div class="info-item-1">所有的垃圾收集器，都基于弱分代假设。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优。 有几个常用原则：  减少临时对象，尽量复用内存。 使用对象池。 主动提前释放对象。 主动 gc。 好的代码比 tuning 更重要。 选 gc 算法比 tuning 参数重要，tuning 参数是最后一步。  其他情况，可以通过 tuning garbage collector 来解决。 操作系统的影响  SWAP 可能会显著增加 GC 时间，因为被换出的堆还要被换入。  美团的实践 参考：  《从实际案例聊聊Java应用的GC优化》 《Java中9种常见的CMS GC问题分析与解决》   Minor GC Major GC Full GC  垃圾收集器分类    可以看到一个现象：在大部分时候，g1 比 CMS 快，但极端的百分位里，CMS 比 g1 快。 出处见这里。 常用工具 命令行终端   标准终端类：jps、jinfo、jstat、jstack、jmap 功能整合类：jcm...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">原问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">样例工程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">JMH 教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api"><span class="toc-number">3.2.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#benchmarkmode"><span class="toc-number">3.2.1.</span> <span class="toc-text">@BenchmarkMode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#warmup"><span class="toc-number">3.2.2.</span> <span class="toc-text">@Warmup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#measurement"><span class="toc-number">3.2.3.</span> <span class="toc-text">@Measurement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threads"><span class="toc-number">3.2.4.</span> <span class="toc-text">@Threads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">3.2.5.</span> <span class="toc-text">@Fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outputtimeunit"><span class="toc-number">3.2.6.</span> <span class="toc-text">@OutputTimeUnit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#benchmark"><span class="toc-number">3.2.7.</span> <span class="toc-text">@Benchmark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#param"><span class="toc-number">3.2.8.</span> <span class="toc-text">@Param</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup"><span class="toc-number">3.2.9.</span> <span class="toc-text">@Setup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#teardown"><span class="toc-number">3.2.10.</span> <span class="toc-text">@TearDown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state"><span class="toc-number">3.2.11.</span> <span class="toc-text">@State</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E8%AF%BB%E8%BE%93%E5%87%BA%E6%8A%A5%E5%91%8A"><span class="toc-number">3.3.</span> <span class="toc-text">解读输出报告</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>