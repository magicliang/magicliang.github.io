<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>如何实现正确的微基准测试 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="原问题 FROM：《How do I write a correct micro-benchmark in Java?》 Tips about writing micro benchmarks from the creators of Java HotSpot: Rule 0: Read a reputable paper on JVMs and micro-benchmarking. A goo">
<meta property="og:type" content="article">
<meta property="og:title" content="如何实现正确的微基准测试">
<meta property="og:url" content="https://magicliang.github.io/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="原问题 FROM：《How do I write a correct micro-benchmark in Java?》 Tips about writing micro benchmarks from the creators of Java HotSpot: Rule 0: Read a reputable paper on JVMs and micro-benchmarking. A goo">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-96.jpg">
<meta property="article:published_time" content="2021-07-19T07:20:11.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:32.504Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-96.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "如何实现正确的微基准测试",
  "url": "https://magicliang.github.io/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/",
  "image": "https://magicliang.github.io/img/wall-paper-96.jpg",
  "datePublished": "2021-07-19T07:20:11.000Z",
  "dateModified": "2025-10-22T08:01:32.504Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '如何实现正确的微基准测试',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-96.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">如何实现正确的微基准测试</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">如何实现正确的微基准测试</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-07-19T07:20:11.000Z" title="Created 2021-07-19 15:20:11">2021-07-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:32.504Z" title="Updated 2025-10-22 16:01:32">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">3.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>16mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>原问题</h1>
<p>FROM：<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/504103/how-do-i-write-a-correct-micro-benchmark-in-java">《How do I write a correct micro-benchmark in Java?》</a></p>
<p>Tips about writing micro benchmarks <a target="_blank" rel="noopener" href="https://wiki.openjdk.java.net/display/HotSpot/Main">from the creators of Java HotSpot</a>:</p>
<p>Rule 0: Read a reputable paper on JVMs and micro-benchmarking. A good one is <a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/java/library/j-jtp02225">Brian Goetz, 2005</a>. Do not expect too much from micro-benchmarks; they measure only a limited range of JVM performance characteristics.</p>
<p>Rule 1: Always include a warmup phase which runs your test kernel all the way through, enough to trigger all initializations and compilations before timing phase(s). (Fewer iterations is OK on the warmup phase. The rule of thumb is several tens of thousands of inner loop iterations.)</p>
<p>Rule 2: Always run with -XX:+PrintCompilation, -verbose:gc, etc., so you can verify that the compiler and other parts of the JVM are not doing unexpected work during your timing phase.</p>
<p>Rule 2.1: Print messages at the beginning and end of timing and warmup phases, so you can verify that there is no output from Rule 2 during the timing phase.</p>
<p>Rule 3: Be aware of the difference between -client and -server, and OSR and regular compilations. The -XX:+PrintCompilation flag reports OSR compilations with an at-sign to denote the non-initial entry point, for example: Trouble$1::run @ 2 (41 bytes). Prefer server to client, and regular to OSR, if you are after best performance.</p>
<p>Rule 4: Be aware of initialization effects. Do not print for the first time during your timing phase, since printing loads and initializes classes. Do not load new classes outside of the warmup phase (or final reporting phase), unless you are testing class loading specifically (and in that case load only the test classes). Rule 2 is your first line of defense against such effects.</p>
<p>Rule 5: Be aware of deoptimization and recompilation effects. Do not take any code path for the first time in the timing phase, because the compiler may junk and recompile the code, based on an earlier optimistic assumption that the path was not going to be used at all. Rule 2 is your first line of defense against such effects.</p>
<p>Rule 6: Use appropriate tools to read the compiler’s mind, and expect to be surprised by the code it produces. Inspect the code yourself before forming theories about what makes something faster or slower.</p>
<p>Rule 7: Reduce noise in your measurements. Run your benchmark on a quiet machine, and run it several times, discarding outliers. Use -Xbatch to serialize the compiler with the application, and consider setting -XX:CICompilerCount=1 to prevent the compiler from running in parallel with itself. Try your best to reduce GC overhead, set Xmx(large enough) equals Xms and use UseEpsilonGC if it is available.</p>
<p>Rule 8: Use a library for your benchmark as it is probably more efficient and was already debugged for this sole purpose. Such as JMH, <a target="_blank" rel="noopener" href="https://github.com/google/caliper">Caliper</a> or <a target="_blank" rel="noopener" href="http://cseweb.ucsd.edu/~wgg/JavaProf/javaprof.html">Bill and Paul’s Excellent UCSD Benchmarks for Java</a>.</p>
<p>规则 0：阅读有关 JVM 和微基准测试的知名论文。 <a target="_blank" rel="noopener" href="http://www.ibm.com/developerworks/java/library/j-jtp02225">Brian Goetz, 2005</a> 是一个很好的例子。不要对微基准期望过高；它们仅测量有限范围的 JVM 性能特征。</p>
<p>规则 1：始终包含一个预热阶段，它会一直运行您的测试内核，足以在计时阶段之前触发所有初始化和编译。 （预热阶段的迭代次数较少。经验法则是数万次内循环迭代。）<strong>几万次足以预热大部分东西</strong>。</p>
<p>规则 2：始终使用 -XX:+PrintCompilation、-verbose:gc 等运行，这样您就可以验证编译器和 JVM 的其他部分在您的计时阶段没有做预期之外的工作。<strong>如果做了它会打印出来</strong>。</p>
<p>规则 2.1：在计时和预热阶段的开始和结束时打印消息，以便您可以验证在计时阶段没有规则 2 的输出。<strong>如何做到呢，依靠 JMH 吧</strong>。</p>
<p>规则 3：注意<code>-client</code>和<code>-server</code>之间的区别，以及 OSR 和常规编译之间的区别。 <code>-XX:+PrintCompilation</code>标志用 at 符号报告 OSR 编译，以表示非初始入口点，例如：<code>Trouble$1::run@2（41 bytes）</code>。如果您追求最佳性能，则更喜欢服务器而不是客户端，并且更喜欢 OSR。<strong>我真的看得懂 OSR 的日志吗</strong>？</p>
<p>规则 4：注意初始化效果。不要在计时阶段第一次打印，因为打印会加载和初始化类。不要在预热阶段（或最终报告阶段）之外加载新类，除非您专门测试类加载（在这种情况下只加载测试类）。规则 2 是您抵御此类影响的第一道防线。<strong>类加载是一种容易被忽略的性能瓶颈，打印是另一种</strong>。</p>
<p>规则 5：注意反优化和重新编译的影响。不要在计时阶段才第一次使用任何代码路径，因为编译器可能会根据早先的乐观假设，即根本不会使用该路径，而重新编译代码。规则 2 是您抵御此类影响的第一道防线。</p>
<p>规则 6：使用适当的工具来读懂编译器的想法，并期望对它生成的代码感到惊讶。在形成关于什么使某事更快或更慢的理论之前，自己检查代码。<strong>不要以为自己懂编译器</strong>。</p>
<p>规则 7：减少测量中的噪声。在安静的机器上运行您的基准测试，并运行几次，丢弃异常值。使用 -Xbatch 将编译器与应用程序序列化，并考虑设置 -XX:CICompilerCount=1 以防止编译器与自身并行运行。尽量减少 GC 开销，设置 Xmx（足够大）等于 Xms 并在可用时使用 UseEpsilonGC。<strong>可以使用无操作垃圾收集器</strong>。</p>
<p>规则 8：为您的基准测试使用一个库，因为它可能更有效，并且已经为此目的进行了调试。例如 JMH、<a target="_blank" rel="noopener" href="https://github.com/google/caliper">Caliper</a> 或 <a target="_blank" rel="noopener" href="http://cseweb.ucsd.edu/~wgg/JavaProf/javaprof.html">Bill and Paul’s Better UCSD Benchmarks for Java</a>。</p>
<p>Also, never use System.currentTimeMillis() unless you are OK with + or - 15 ms accuracy, which is typical on most OS + JVM combinations.</p>
<p>不要使用 System.nanoTime() 和 System.currentTimeMillis() 这两个 api。但 System.nanoTime() 始终是单调钟，虽然不精确，总是向前的。</p>
<h1>样例工程</h1>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jmh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jmh-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.openjdk.jmh/jmh-generator-annprocess --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.openjdk.jmh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jmh-generator-annprocess<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.33<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 参考 https://github.com/openjdk/jmh/blob/master/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_03_States.java</span><br><span class="hljs-meta">@State(Scope.Benchmark)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonUtilBenchMark</span> &#123;<br><br>    <span class="hljs-meta">@State(Scope.Thread)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyState</span> &#123;<br>        <span class="hljs-comment">// 在每一个 Invocation 级别做一次 setup。参数随机化要这一步做</span><br>        <span class="hljs-meta">@Setup(Level.Invocation)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSetup</span><span class="hljs-params">()</span> &#123;<br>            Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1024</span>; i++) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">boundedRandomValue</span> <span class="hljs-operator">=</span> ThreadLocalRandom.current().nextInt(-<span class="hljs-number">10000000</span>, <span class="hljs-number">10000000</span>);<br>                map.put(boundedRandomValue + <span class="hljs-string">&quot;&quot;</span>, boundedRandomValue + <span class="hljs-number">1</span> + <span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>            mapStr = JsonUtils.toJson(map);<br>            System.out.println(<span class="hljs-string">&quot;Do Setup&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-meta">@TearDown(Level.Invocation)</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doTearDown</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;Do TearDown&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> String mapStr;<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-meta">@BenchmarkMode(Mode.All)</span> <span class="hljs-comment">// 吞吐量、耗时、采样、冷启动这些模式都跑一遍</span><br>    <span class="hljs-meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureToObj</span><span class="hljs-params">(MyState state)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(JsonUtils.toObj(state.mapStr, Map.class));<br>    &#125;<br><br>    <span class="hljs-meta">@Benchmark</span><br>    <span class="hljs-meta">@BenchmarkMode(Mode.All)</span><br>    <span class="hljs-meta">@OutputTimeUnit(TimeUnit.NANOSECONDS)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">measureToObj2</span><span class="hljs-params">(MyState state)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        System.out.println(JsonUtils.toObj2(state.mapStr, Map.class));<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> RunnerException &#123;<br>        <span class="hljs-type">Options</span> <span class="hljs-variable">opt</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OptionsBuilder</span>()<br>                .include(JsonUtilBenchMark.class.getSimpleName())<br>                .threads(<span class="hljs-number">80</span>)<br>                <span class="hljs-comment">// 4 * 500 秒 = 33.3333333333 分(分钟)</span><br>                .warmupIterations(<span class="hljs-number">500</span>)<br>                <span class="hljs-comment">// 每个循环每个模式跑 1s，如果开 all mode，实际上要跑 4 * 50000 秒等于55.5555555556 时(小时)</span><br>                .measurementIterations(<span class="hljs-number">50000</span>)<br>                <span class="hljs-comment">// https://stackoverflow.com/questions/35046745/what-is-the-purpose-of-jmh-fork</span><br>                <span class="hljs-comment">// fork 是为了实现 JVM 级的隔离</span><br>                .measurementIterations(<span class="hljs-number">50000</span>)<br>                .forks(<span class="hljs-number">20</span>)<br>                .build();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runner</span>(opt).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>JMH 教程</h1>
<p>参考<a target="_blank" rel="noopener" href="https://hezhiqiang8909.gitbook.io/java/docs/javalib/jmh">《JMH 应用指南》</a>。</p>
<p><a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/9d8c81113a978540cc5793139">《基准测试神器 JMH —— 详解 36 个官方例子》</a></p>
<h2 id="基本概念">基本概念</h2>
<ul>
<li>Iteration - iteration 是 JMH 进行测试的最小单位，包含一组 invocations。</li>
<li>Invocation - 一次 benchmark 方法调用。</li>
<li>Operation - benchmark 方法中，被测量操作的执行。如果被测试的操作在 benchmark 方法中循环执行，可以使用@OperationsPerInvocation表明循环次数，使测试结果为单次 operation 的性能。</li>
<li>Warmup - 在实际进行 benchmark 前先进行预热。因为某个函数被调用多次之后，JIT 会对其进行编译，通过预热可以使测量结果更加接近真实情况。</li>
</ul>
<h2 id="api">API</h2>
<h3 id="benchmarkmode">@BenchmarkMode</h3>
<ul>
<li>Throughput - 整体吞吐量，例如“1 秒内可以执行多少次调用”。</li>
<li>AverageTime - 调用的平均时间，例如“每次调用平均耗时 xxx 毫秒”。</li>
<li>SampleTime - 随机取样，最后输出取样结果的分布，例如“99%的调用在 xxx 毫秒以内，99.99%的调用在 xxx 毫秒以内”</li>
<li>SingleShotTime - <strong>以上模式都是默认一次 iteration 是 1s</strong>，唯有 SingleShotTime 是只运行一次。往往同时把 warmup 次数设为 0，<strong>用于测试冷启动时的性能</strong>。</li>
<li>All - 所有模式</li>
</ul>
<h3 id="warmup">@Warmup</h3>
<p>上面我们提到了，进行基准测试前需要进行预热。一般我们前几次进行程序测试的时候都会比较慢， 所以要让程序进行几轮预热，保证测试的准确性。其中的参数 iterations 也就非常好理解了，就是预热轮数。<br>
为什么需要预热？因为 JVM 的 JIT 机制的存在，如果某个函数被调用多次之后，JVM 会尝试将其编译成为机器码从而提高执行速度。所以为了让 benchmark 的结果更加接近真实情况就需要进行预热。</p>
<h3 id="measurement">@Measurement</h3>
<ul>
<li>iterations - 进行测试的轮次</li>
<li>time - 每轮进行的时长</li>
<li>timeUnit - 时长单位</li>
</ul>
<h3 id="threads">@Threads</h3>
<p>每个进程中的测试线程，这个非常好理解，根据具体情况选择，一般为 cpu 乘以 2。</p>
<h3 id="fork">@Fork</h3>
<p>进行 fork 的次数。如果 fork 数是 2 的话，则 JMH 会 fork 出两个进程来进行测试。</p>
<h3 id="outputtimeunit">@OutputTimeUnit</h3>
<p>这个比较简单了，基准测试结果的时间类型。一般选择秒、毫秒、微秒。</p>
<h3 id="benchmark">@Benchmark</h3>
<p>方法级注解，表示该方法是需要进行 benchmark 的对象，用法和 JUnit 的 @Test 类似。</p>
<h3 id="param">@Param</h3>
<p>属性级注解，@Param 可以用来指定某项参数的多种情况。特别适合用来测试一个函数在不同的参数输入的情况下的性能。</p>
<h3 id="setup">@Setup</h3>
<p>方法级注解，这个注解的作用就是我们需要在测试之前进行一些准备工作，比如对一些数据的初始化之类的。我们可以在每一次 Invocation 以前做一次 Setup。</p>
<h3 id="teardown">@TearDown</h3>
<p>方法级注解，这个注解的作用就是我们需要在测试之后进行一些结束工作，比如关闭线程池，数据库连接等的，主要用于资源的回收等。这个东西需要很慎重。</p>
<h3 id="state">@State</h3>
<p>当使用 @Setup 参数的时候，必须在类上加这个参数，不然会提示无法运行。<br>
State 用于声明某个类是一个“状态”，然后接受一个 Scope 参数用来表示该状态的共享范围。 因为很多 benchmark 会需要一些表示状态的类，JMH 允许你把这些类以依赖注入的方式注入到 benchmark 函数里。Scope 主要分为三种。</p>
<ul>
<li>Thread - 该状态为每个线程独享。</li>
<li>Group - 该状态为同一个组里面所有线程共享。</li>
<li>Benchmark - 该状态在所有线程间共享。</li>
</ul>
<h2 id="解读输出报告">解读输出报告</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs bash">255195.938 ±(99.9%) 48484.059 ns/op<br><br><br>Result <span class="hljs-string">&quot;类名.方法名&quot;</span>:<br>  N = 20<br>  mean = 324719.516 ±(99.9%) 302945.897 ns/op<br><br>  Histogram, ns/op:<br>    [      0.000,  125000.000) = 0 <br>    <span class="hljs-comment"># 有 14 个 iteration 在 125 微秒中执行完成</span><br>    [ 125000.000,  250000.000) = 14 <br>    [ 250000.000,  375000.000) = 5 <br>    [ 375000.000,  500000.000) = 0 <br>    [ 500000.000,  625000.000) = 0 <br>    [ 625000.000,  750000.000) = 0 <br>    [ 750000.000,  875000.000) = 0 <br>    [ 875000.000, 1000000.000) = 0 <br>    [1000000.000, 1125000.000) = 0 <br>    [1125000.000, 1250000.000) = 0 <br>    [1250000.000, 1375000.000) = 0 <br>    [1375000.000, 1500000.000) = 0 <br>    [1500000.000, 1625000.000) = 0 <br>    [1625000.000, 1750000.000) = 0 <br>    <span class="hljs-comment"># 有一个 iteration 在1.75 毫秒内执行完成</span><br>    [1750000.000, 1875000.000) = 1 <br><br> <span class="hljs-comment"># 有若干个点在这些 p(50.0000)分位被执行出来。</span><br>  Percentiles, ns/op:<br>      p(0.0000) = 224220.638 ns/op<br>     p(50.0000) = 237448.319 ns/op<br>     p(90.0000) = 331986.035 ns/op<br>     p(95.0000) = 1728070.972 ns/op<br>     p(99.0000) = 1801399.338 ns/op<br>     p(99.9000) = 1801399.338 ns/op<br>     p(99.9900) = 1801399.338 ns/op<br>     p(99.9990) = 1801399.338 ns/op<br>     p(99.9999) = 1801399.338 ns/op<br>    p(100.0000) = 1801399.338 ns/op<br><br><span class="hljs-comment"># 总共花了 4 分 46 秒执行基准测试</span><br><span class="hljs-comment"># Run complete. Total time: 00:04:46</span><br><br>Benchmark                                                                        Mode      Cnt       Score     Error   Units<br>RiskOutServiceImplBenchMark.measureJson                                         thrpt       20       0.057 ±   0.008  ops/us<br>RiskOutServiceImplBenchMark.measureMessageFormat                                thrpt       20       0.057 ±   0.009  ops/us<br>RiskOutServiceImplBenchMark.measureOrigin                                       thrpt       20       0.066 ±   0.007  ops/us<br><span class="hljs-comment"># 注意，在 avg time 模式下，我们会发现 avg 都很高，主要是因为 tp 的长尾线拉高了 avg</span><br>RiskOutServiceImplBenchMark.measureJson                                          avgt       20    1420.907 ± 176.300   us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat                                 avgt       20    1191.810 ± 142.301   us/op<br>RiskOutServiceImplBenchMark.measureOrigin                                        avgt       20    1170.264 ± 119.390   us/op<br><span class="hljs-comment"># 在采样模式下看分位线</span><br>RiskOutServiceImplBenchMark.measureJson                                        sample  1420574    1175.533 ±  17.038   us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.00                      sample               38.976             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.50                      sample               78.720             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.90                      sample              144.640             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.95                      sample              831.488             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.99                      sample            34537.472             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.999                     sample            65142.784             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p0.9999                    sample           100524.687             us/op<br>RiskOutServiceImplBenchMark.measureJson:measureJson·p1.00                      sample           249823.232             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat                               sample  1490803    1109.570 ±  18.395   us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.00    sample               37.440             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.50    sample               74.624             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.90    sample              115.072             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.95    sample              376.730             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.99    sample            40566.784             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.999   sample            78118.912             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p0.9999  sample           123590.358             us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat:measureMessageFormat·p1.00    sample           216268.800             us/op<br>RiskOutServiceImplBenchMark.measureOrigin                                      sample  1426009    1184.753 ±  20.095   us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.00                  sample               36.480             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.50                  sample               73.088             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.90                  sample              114.816             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.95                  sample              376.320             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.99                  sample            38666.240             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.999                 sample            90570.752             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p0.9999                sample           148111.360             us/op<br>RiskOutServiceImplBenchMark.measureOrigin:measureOrigin·p1.00                  sample           318767.104             us/op<br><span class="hljs-comment"># 下面是冷启动的分数，冷启动时单个操作 525 微秒，高于 5p50，但低于 tp 99</span><br>RiskOutServiceImplBenchMark.measureJson                                            ss       20     525.691 ± 294.527   us/op<br>RiskOutServiceImplBenchMark.measureMessageFormat                                   ss       20     489.662 ± 514.746   us/op<br>RiskOutServiceImplBenchMark.measureOrigin                                          ss       20     341.841 ± 215.144   us/op<br></code></pre></td></tr></table></figure>
<p>注意标准差： STDEV 基于样本估算标准偏差。标准偏差反映数值相对于平均值(mean) 的离散程度。</p>
<ul>
<li>ops/us - operations (benchmark method executions) per microsecond</li>
<li>Cnt - total number of trials (forks*iterations)</li>
<li>Score - benchmark result</li>
<li>Error - standard error value. Means how much different trials results differ<br>
Also:</li>
<li>thrpt - Throughput mode (how much full benchmark method executions were made in a trial)</li>
<li>avgt - Average Time mode (how much measuring units took benchmark method execution on average)</li>
</ul>
<p>有兴趣还可以试试这两个网站：<br>
<a target="_blank" rel="noopener" href="http://deepoove.com/jmh-visual-chart/">JMH Visual Chart</a><br>
<a target="_blank" rel="noopener" href="https://jmh.morethan.io/">JMH Visualizer</a></p>
<p>另外一种解释，参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/cndmss/article/details/93771981">《使用JMH进行基准性能测试》</a>：</p>
<p><strong>数字只能告诉我们 what，通常不能告诉我们 when、where、how 和 why。搞懂 why 是人的工作</strong>：</p>
<blockquote>
<p>REMEMBER: The numbers below are just data. To gain reusable insights,<br>
you need to follow up on why the numbers are the way they are. Use<br>
profilers (see -prof, -lprof), design factorial experiments, perform<br>
baseline and negative tests that provide experimental control, make<br>
sure the benchmarking environment is safe on JVM/OS/HW level, ask for<br>
reviews from the domain experts. Do not assume the numbers tell you<br>
what you want them to tell.</p>
<p>记住：下面的数字只是数据。要获得可重复使用的见解，您需要跟进 为什么数字是这样的。使用分析器（参见 -prof、-lprof），设计因子<br>
实验，执行提供实验控制的基线和负面测试，确保 基准测试环境在 JVM/OS/HW 级别是安全的，请咨询领域专家。<br>
不要假设数字告诉您您希望他们告诉您的内容。</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">块</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">参数信息（1-10行）</td>
<td style="text-align:center">1：jmh版本<br>2：jvm版本信息<br>3：jvm程序（jdk安装路径）<br>4：jvm参数配置<br>5：预热参数：预热次数、每次持续时间<br>6：测试参数：测试次数、每次持续时间<br>7：每次测试迭代超时时间<br>8：每个测试进程的测试线程数<br>9: 测试的模式<br>10:测试的方法</td>
</tr>
<tr>
<td style="text-align:center">测试过程（12-75行）</td>
<td style="text-align:center">12-23：第1次fork测试 （fork可以理解为1个独立的进程）<br>12：测试完成进度，预计剩余需要时间<br>13：当前第几次fork<br>14-18：预热执行，每次预热执行耗时<br>19-23：正式测试执行，每次测试执行耗时<br>25-36：第2次fork测试<br>38-49：第3次fork测试<br>51-62：第4次fork测试<br>64-75：第5次fork测试</td>
</tr>
<tr>
<td style="text-align:center">测试结果（78-95行）</td>
<td style="text-align:center">78-81：测试结果，包括测试的方法、平均耗时[平局耗时的比例]、最大最小 耗时、测试结果数据离散度（stdev）等<br>84：测试总耗时<br>86-90：对测试结果的解释<br>92-93：测试结论{测试的方法、测试类型（Mode）、测试总次数(Cnt)、测试结果(Score)、误差(Error)、单位(Units)}<br>95：结束</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/">https://magicliang.github.io/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-96.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-140.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a><a class="pagination-related" href="/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/img/wall-paper-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-10</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1">线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级： 线程安全的分类 不可变 不可变的数据，都是线程安全的。不可变的对象引用，加上所有field都是不可变的。如果有得选，尽量连方法都是final的。 绝对线程安全 Vector不是线程安全的。它也会出现并发修改时 Out of Range 的异常（注意，不是 ConcurrentModification 的异常）。 相对线程安全 需要保证对这个对象的单独操作是线程安全的，在调用的时候不需要加上额外的保障措施。对于特定顺序的连续操作，就需要额外的同步来保证调用的正确性了。 线程兼容 可以通过特殊手段做到线程安全的普通类，绝大部分类都属于相对线程安全的。 线程对立 线程对立，是不管调用端是否采取了同步措施，都无法在多线程环境中使用的代码。常见的线程对立的操作还有 suspend()，resume()， System....</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-143.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">上下文 卡表和 RSet（Remember Set），是 JVM 为了解决分代收集时，live set 扫描需要穿梭到不同的代的时候的效率问题。 使用缓存表来提高查询效率，是化顺序查找为部分随机查找的一种常用的设计思路。 例如，在传统的计算机体系结构中，当我们把内存分成页以后，会有一个页表，页表又会有一个快表，作为一个中间缓存项，来帮助我们查找我们需要使用的页表项（table entry）。 JVM 在进行垃圾收集的时候，有一项非常重要的工作就是确定这一次垃圾收集的对象到底有多少个，即确定 live set 的范围。 对于新生代垃圾收集器而言，这个问题又有其特殊之处。根据 JVM 的弱分代收集假设（weak generational hypothesis）的存在，每次垃圾收集的时候，新生代的扫描范围可能很大，但新生代的 live set 不应该太大。card table/Remember Set 的设计目的，就是尽量减少无用的垃圾扫描范围，使用类似操作系统或者数据库的脏页表的形式，来做类似快表的查询。 卡表（card table）  卡表是 CMS 的解决方案。 卡表通常在 JV...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a><a class="pagination-related" href="/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" title="重述双亲委派模型"><img class="cover" src="/img/wall-paper-105.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-05</div><div class="info-item-2">重述双亲委派模型</div></div><div class="info-2"><div class="info-item-1">何时加载类  遇到 new、getstatic、putstatic 等指令时。 对类进行反射调用的时候。 初始化某个类的子类的时候。 虚拟机启动时会先加载设置的程序主类。 使用 dynamic 动态语言支持等相关特性时。  从 Java 到 cpp 源码分析  JVM 默认用于加载用户程序的ClassLoader为AppClassLoader，不过无论是什么ClassLoader，它的根父类都是java.lang.ClassLoader。在上面那个例子中，loadClass（）方法最终会调用到ClassLoader.definClass1（）中，这是一个 Native 方法。  12static native Class&lt;?&gt; defineClass1(ClassLoader loader, String name, byte[] b, int off, int len,                                        ProtectionDomain pd, String source);   definClass1（）对应的 JNI ...</div></div></div></a><a class="pagination-related" href="/2020/03/08/JMX-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9/" title="JMX 深度历险"><img class="cover" src="/img/wall-paper-170.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-08</div><div class="info-item-2">JMX 深度历险</div></div><div class="info-2"><div class="info-item-1">JMX 常见指标 JVM 指标 系统指标    System 相关指标 描述     system.load.average 系统load，如果是docker，此指标收集的物理机的load   cpu.system.load.percent 系统所有进程占用cpu的百分比   cpu.jvm.load.percent jvm占用cpu的百分比   system.process.used.phyical.memory 系统使用的物理内存   system.process.used.swap.size 系统使用的swap内存    JVM 内存指标    JVM相关指标 描述     jvm.gc.count GC的次数   jvm.gc.time GC的时间，单位毫秒   jvm.younggc.count 年轻代GC的次数 ，包括的GC算法（Copy，ParNew，PS Scavenge，G1 Young Generation）   jvm.younggc.time 年轻代GC的时间，单位毫秒   jvm.fullgc.count 年老代GC的次数，包括的GC算法   jvm.f...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">原问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">样例工程</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">JMH 教程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">3.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api"><span class="toc-number">3.2.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#benchmarkmode"><span class="toc-number">3.2.1.</span> <span class="toc-text">@BenchmarkMode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#warmup"><span class="toc-number">3.2.2.</span> <span class="toc-text">@Warmup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#measurement"><span class="toc-number">3.2.3.</span> <span class="toc-text">@Measurement</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threads"><span class="toc-number">3.2.4.</span> <span class="toc-text">@Threads</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fork"><span class="toc-number">3.2.5.</span> <span class="toc-text">@Fork</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#outputtimeunit"><span class="toc-number">3.2.6.</span> <span class="toc-text">@OutputTimeUnit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#benchmark"><span class="toc-number">3.2.7.</span> <span class="toc-text">@Benchmark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#param"><span class="toc-number">3.2.8.</span> <span class="toc-text">@Param</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setup"><span class="toc-number">3.2.9.</span> <span class="toc-text">@Setup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#teardown"><span class="toc-number">3.2.10.</span> <span class="toc-text">@TearDown</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state"><span class="toc-number">3.2.11.</span> <span class="toc-text">@State</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E8%AF%BB%E8%BE%93%E5%87%BA%E6%8A%A5%E5%91%8A"><span class="toc-number">3.3.</span> <span class="toc-text">解读输出报告</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>