<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 并发编程笔记 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="写在前面的话 并发编程最早的实践都在操作系统里。 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程，我们应当学习管程，进而了解标准的并发模型。  juc.xmind Java 线程状态  线程状态列举 NEW 没有启动过的线程。 RUNNABLE  正在执行的线程。 可以被执行但没有拿到处理器资源。  BLOCKED blocke">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 并发编程笔记">
<meta property="og:url" content="https://magicliang.github.io/2021/10/07/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="写在前面的话 并发编程最早的实践都在操作系统里。 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程，我们应当学习管程，进而了解标准的并发模型。  juc.xmind Java 线程状态  线程状态列举 NEW 没有启动过的线程。 RUNNABLE  正在执行的线程。 可以被执行但没有拿到处理器资源。  BLOCKED blocke">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2021/10/07/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png">
<meta property="article:published_time" content="2021-10-07T08:40:11.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:32.517Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2021/10/07/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 并发编程笔记",
  "url": "https://magicliang.github.io/2021/10/07/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
  "image": "https://magicliang.github.io/2021/10/07/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png",
  "datePublished": "2021-10-07T08:40:11.000Z",
  "dateModified": "2025-10-22T08:01:32.517Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2021/10/07/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 并发编程笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2021/10/07/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 并发编程笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java 并发编程笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2021-10-07T08:40:11.000Z" title="Created 2021-10-07 16:40:11">2021-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:32.517Z" title="Updated 2025-10-22 16:01:32">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">36.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>150mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>写在前面的话</h1>
<p>并发编程最早的实践都在操作系统里。</p>
<p>理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程，我们应当学习管程，进而了解标准的并发模型。</p>
<p><img src="juc.png" alt="juc.png"><br>
<a href="juc.xmind">juc.xmind</a></p>
<h1>Java 线程状态</h1>
<p><img src="java-thread-state.png" alt="java-thread-state.png"></p>
<h2 id="线程状态列举">线程状态列举</h2>
<h3 id="new">NEW</h3>
<p>没有启动过的线程。</p>
<h3 id="runnable">RUNNABLE</h3>
<ol>
<li>正在执行的线程。</li>
<li>可以被执行但没有拿到处理器资源。</li>
</ol>
<h3 id="blocked">BLOCKED</h3>
<p>blocked 其实是 blocked waiting。<br>
1 等待 monitor，进入 synchronized method/block<br>
2 或者等 wait()/await()以后再次进入 synchronized method/block（注意这一点，解除 wait 以后以后不是直接 runnable，而是进入 blocked，但这一步非常短暂，几乎不可能用程序观察到）。</p>
<h3 id="waiting">WAITING</h3>
<p>在调用这三种不计时方法以后，线程进入 waiting 态：</p>
<ul>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.park 我们经常在文档里看到的 thread lies dormant 就是被这个方法处理过的结果</li>
</ul>
<p>waiting 意味着一个线程在等待另一个线程做出某种 action。wait 在等其他对象 notify 和 notifyAll，join 在等其他线程终结。</p>
<p>如：<br>
<code>java.util.concurrent.LinkedBlockingQueue.take -&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await -&gt; java.util.concurrent.locks.LockSupport.park</code></p>
<p>Reentrantlock 的 lock 接口的栈帧则是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sun<span class="hljs-selector-class">.misc</span><span class="hljs-selector-class">.Unsafe</span><span class="hljs-selector-class">.park</span> 行: 不可用 <span class="hljs-selector-attr">[本地方法]</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.LockSupport</span><span class="hljs-selector-class">.park</span> 行: <span class="hljs-number">175</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.parkAndCheckInterrupt</span> 行: <span class="hljs-number">836</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquireQueued</span> 行: <span class="hljs-number">870</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquire</span> 行: <span class="hljs-number">1199</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span><span class="hljs-selector-class">.lock</span> 行: <span class="hljs-number">209</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.ReentrantLock</span><span class="hljs-selector-class">.lock</span> 行: <span class="hljs-number">285</span> <br></code></pre></td></tr></table></figure>
<p>jstack 总会告诉我们 waiting 的位置，比如等待某个 Condition 的 await 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;t1 before lock&quot;</span>);<br>            lock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 此时 t1 是 Runnable</span><br>                queue.put(<span class="hljs-number">1</span>); <span class="hljs-comment">// 此时刺激主线程开始读 t2</span><br>                System.out.println(<span class="hljs-string">&quot;t1 begin to sleep&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">1000000L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;t1 prepare to release lock&quot;</span>);<br>            lock.unlock();<br>            System.out.println(<span class="hljs-string">&quot;t1 release lock&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;t2 before lock&quot;</span>);<br>            <span class="hljs-comment">// 此时 t2 可能被 t1 阻塞，进入 waiting 状态</span><br>            lock.lock();<br>            System.out.println(<span class="hljs-string">&quot;t2 prepare to release lock&quot;</span>);<br>            lock.unlock();<br>            System.out.println(<span class="hljs-string">&quot;t2 release lock&quot;</span>);<br>        &#125;);<br>        t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>        t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>        t1.start();<br>        t2.start();<br>        <span class="hljs-comment">// 此时主线程在等待一个信号来刺激自己往下走</span><br>        queue.take();<br>        <span class="hljs-comment">// 往下走的目的就是校验 t2 的状态</span><br>        <span class="hljs-keyword">while</span> (t2.isAlive()) &#123;<br>            System.out.println(t2.getState());<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>对这个程序进行 thread dump，可以看出 ReentrantLock 就是依赖于 park 导致的 waiting：</p>
<p><img src="parking%E5%8D%B3waiting.png" alt="parking即waiting.png"><br>
<img src="sleeping%E5%8D%B3timed-waiting.png" alt="sleeping即timed-waiting.png"></p>
<p>如果使用 synchronized，则会显示 object monitor：</p>
<p><img src="object-monitor.png" alt="object-monitor.png"></p>
<p>所以 waiting 可能是在条件变量上等待，也可能是在 synchronizer 本身上等待，不可一概而论。</p>
<p>按照 jvisualvm 的分类方法，线程还可以分为：</p>
<ul>
<li>等待</li>
<li>驻留（park）</li>
<li>监视（monitor）</li>
</ul>
<h3 id="timed-waiting">TIMED_WAITING</h3>
<p>调用了计时方法，等待时间结束后才或者被其他唤醒方法唤醒结束等待。</p>
<p>Thread.sleep<br>
Object.wait<br>
Thread.join<br>
LockSupport#parkNanos<br>
LockSupport.parkUntil</p>
<p>如：</p>
<p><code>java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take -&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos -&gt; java.util.concurrent.locks.LockSupport.parkNanos -&gt; sun.misc.Unsafe.park</code></p>
<p>除了 sleep 以外，jstack 总会告诉我们 time_waiting 的位置，比如等待某个 Condition 的 await 操作。</p>
<h3 id="terminated">TERMINATED</h3>
<p>终结的线程，执行已经结束了。</p>
<p>中断退出也是一种结束。</p>
<h3 id="几种线程状态的对比">几种线程状态的对比</h3>
<ol>
<li>blocked：线程想要获取锁进入临界区之前，会求锁，求不到锁会进入 wait_set，然后放弃 cpu。高并发时 blocked 会增多。</li>
<li>工作线程池开始伸缩，扩容的时候：jvm.thread.waiting.count 的数量会变少，这意味着等待从 blockingQueue 里面 take 任务而阻塞的工作线程在变少。</li>
<li>工作吞吐变多，而调用下游的工作线程在阻塞的时候，jvm.thread.time_waiting.count 会变多，因为 rpc 框架自带超时，而这些超时是会让工作线程进行计时等待的。</li>
<li>流量变大的时候，2 和 3 可能同时发生。</li>
</ol>
<h2 id="特别的切换方法">特别的切换方法</h2>
<h3 id="locksupport-park">LockSupport.park</h3>
<p>condition 的 await 底层调用的是 LockSupport.park。这个方法的参数是一个用作 monitor 的对象，会被设置到 Object 的特定 Offset 上。</p>
<p>park 只能带来 waiting。所以 sync 和 conditionObject 其实都让 thread waiting ，只不过代表 thread 的 node 处在的队列不一样而已。</p>
<h3 id="wait">wait</h3>
<p>这个方法是对 object 用的。<br>
从 wait 中醒来会有伪唤醒的 case，所以醒来的时候一定要先检查唤醒条件是否已经得到满足。原理见<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/271521213">《为什么条件锁会产生虚假唤醒现象（spurious wakeup）？》</a></p>
<h3 id="join">join</h3>
<h1>JMM</h1>
<h2 id="volatile">Volatile</h2>
<p><img src="volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="volatile的可见性影响.png"></p>
<h1>JUC</h1>
<p><img src="juc-class-diagram.png" alt="juc-class-diagram.png"></p>
<h2 id="总体设计原则">总体设计原则</h2>
<ul>
<li>Doug Lea 特别热衷于使用顺序状态来表达初始、中间态和终态，往往使用 &lt;= 中间态当作初始态，&gt;= 中间态当作完成态（包括 normal 和 exceptional）。</li>
<li>有一些变量内存不安全，强依赖于 happen-before relation 的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14432400/why-outcome-object-in-futuretask-is-non-volatile">巧妙实现</a>，也需要参考<a href="##Volatile">Volatile</a>。</li>
<li>Doug Lea 不喜欢写大括号。</li>
<li>对于所有的计时等待而言，0 意味着无限等待。</li>
<li>链表的特性：
<ul>
<li>在初始时，链表总是先初始化 head，cas 成功，然后用 head 赋值给 tail，使其最初相等，但读值的时候顺序是反过来的-利用了 volatile 的内存屏障的特性。</li>
<li>只要有一个 cas 操作成功，包裹住剩下的 volatile 写都不需要再做 cas。所以通常对 AQS 自身的全局状态的 cas 是和链表自身状态的 link/unlink 操作是分开的。</li>
<li>所有要被 cas 的链表元素/aqs state，在局部代码运行前，要被先用局部变量存储起来，写在 block 的最开始。这样做可以提高复用性，减少多次对 volatile 变量的求值，避免对缓存机制的扰乱，也保证了变量的线程封闭性。在全局也有一些 global state。</li>
</ul>
</li>
<li>有副作用的方法，副作用包括修改全局变量、park、unpark、修改中断位，返回值通常是主要操作的成败。有时候用 int 代表多种返回值。</li>
</ul>
<h2 id="unsafe-的应用">Unsafe 的应用</h2>
<p>JUC 强依赖于 Unsafe，它提供了硬件级别的 CAS 原子操作。在 X86 上，这个 CAS 操作依赖于 cmpxchg 指令，会锁定总线。所以仍然会产生一些硬件锁。</p>
<p>通常 Unsafe 的使用模式是<code>compareAndSwapXXX</code>，一个典型的函数是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object obj, <span class="hljs-type">long</span> offset, Object expect, Object update)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>obj是我们要操作的目标对象</li>
<li>offset表示了目标对象中，对应的属性的内存偏移量</li>
<li>expect是进行比较的原值</li>
<li>update是拟写入的新值</li>
</ul>
<h3 id="获取-field">获取 field</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; k = FutureTask.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">stateField</span> <span class="hljs-operator">=</span> k.getDeclaredField(<span class="hljs-string">&quot;state&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>进而获取 field 的偏移：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">objectFieldOffset</span><span class="hljs-params">(Field field)</span>;<br></code></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">tailOffset = unsafe.objectFieldOffset<br>            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;tail&quot;</span>));<br></code></pre></td></tr></table></figure>
<p>然后就可以做类似的 cas 操作了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetTail</span><span class="hljs-params">(Node expect, Node update)</span> &#123;<br>     <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(<span class="hljs-built_in">this</span>, tailOffset, expect, update);<br> &#125;<br></code></pre></td></tr></table></figure>
<p>很多 AtomicXXX 原子类，底层都依赖于 Unsafe 的 CAS offset、old value、new value操作。</p>
<h3 id="increaseandget-与-getandincrease">increaseAndGet 与 getAndIncrease</h3>
<p>所有的 increaseAndGet 都是由 getAndIncrease 支撑起来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// OpenJDK 8</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Objet obj, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>       v = getIntVolatile(o, offset);<br>    <span class="hljs-comment">// 整个“比较+更新”操作封装在 compareAndSwapInt() 中，在 JNI 里是借助于一个 CPU 指令（cmpxchg）完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。   </span><br>    &#125; <span class="hljs-keyword">while</span> (!compareAndSwapInt(obj, v, v + delta))<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>CAS 有三大问题：</p>
<blockquote>
<ul>
<li>ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
<ul>
<li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li>
</ul>
</li>
<li>循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。</li>
<li>只能保证一个共享变量的原子操作。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
<ul>
<li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="自旋锁">自旋锁</h3>
<blockquote>
<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
</blockquote>
<p><img src="%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E9%9D%9E%E8%87%AA%E6%97%8B%E9%94%81.png" alt="自旋锁与非自旋锁"></p>
<blockquote>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK<br>
6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
</blockquote>
<p>在自旋锁中另有三种常见的锁形式：TicketLock、<a target="_blank" rel="noopener" href="https://coderbee.net/index.php/concurrent/20131115/577">CLHlock和MCSlock</a>。这是很多 Lock Free 数据结构的基础。但 CLH 改成双端队列和引入 Park 以后，也可以实现 blocking lock。</p>
<p><img src="%E5%9B%9B%E7%A7%8D%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%80%9D%E8%B7%AF.png" alt="四种锁升级的思路"></p>
<p>具体的解释先统一存储在<a href="https://magicliang.github.io/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">《线程安全与锁优化》</a>。</p>
<h2 id="函数式接口">函数式接口</h2>
<h3 id="区别-runnable-和-callable">区别 Runnable 和 Callable</h3>
<p>Runnable 本身是不抛出异常的，但 Callable  本身耗时比较长，而且还会抛出异常（这个设计会最终导致我们进行函数式编程的时候，有时候我们需要在 Runnable 内部处理异常，有时候我们要在 Callable 外处理异常）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="synchronized-的状态">synchronized 的状态</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">sync1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 制造一个内外部死锁，让 t1 内部锁死在这里</span><br>、           <span class="hljs-keyword">synchronized</span> (sync1) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">20L</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;I am going to die，current state：&quot;</span> + Thread.currentThread().getState() );<br>            &#125;<br>        &#125;);<br>        t1.setName(<span class="hljs-string">&quot;TTTTTT1&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (sync1) &#123;<br>            t1.start();<br>            Thread.sleep(<span class="hljs-number">2000L</span>);<br>            System.out.println(<span class="hljs-string">&quot;t1 state1：&quot;</span> + t1.getState());<br>            <span class="hljs-comment">// waiting for jmx client to attach on it</span><br>            Thread.sleep(<span class="hljs-number">30000L</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;unsyncrhonized&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;t1 state2：&quot;</span> + t1.getState());<br>        Thread.sleep(<span class="hljs-number">500000L</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="jvisualvm%E8%A7%82%E5%AF%9F%E5%88%B0monitored%E6%80%81.png" alt="jvisualvm观察到monitored态"><br>
<img src="jmc%E5%BE%97%E5%88%B0blocked%E6%80%81.png" alt="jmc得到blocked态"></p>
<p>JVisualVM 会专门把 block 当做 monitorered 态。</p>
<h2 id="locksupport">LockSupport</h2>
<p>这个类型是为了提供阻塞元语，这样可以创造以锁为代表的 synchronization classes。</p>
<p>使用一个 park，如果有 permit，则立刻返回，否则阻塞；使用一个 unpark 会让 permit available。permit 最多有一个，这点和 semaphore 不一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">sync1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 在这一步以后，线程进入 waiting 的 state</span><br>            <span class="hljs-comment">// park 和 unpark 只能内外部调用，不能在一个线程内对称调用，而且 park 的参数是 sync，unpark 的参数是线程</span><br>            LockSupport.park(sync1);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">20L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// RUNNABLE</span><br>            System.out.println(<span class="hljs-string">&quot;I am going to die，current state：&quot;</span> + Thread.currentThread().getState() );<br>        &#125;);<br>        t1.setName(<span class="hljs-string">&quot;TTTTTT1&quot;</span>);<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">2000L</span>);<br>        <span class="hljs-comment">//  t1 state1：WAITING</span><br>        System.out.println(<span class="hljs-string">&quot;t1 state1：&quot;</span> + t1.getState());<br>        <span class="hljs-comment">// waiting for jmx client to attach on it</span><br>        Thread.sleep(<span class="hljs-number">30000L</span>);<br>        <span class="hljs-comment">// 这个unpark并不会立刻让 t1 进入runnable</span><br>        LockSupport.unpark(t1);<br>        System.out.println(<span class="hljs-string">&quot;unpark&quot;</span>);<br>        <span class="hljs-comment">// t1 state1：WAITING/TIMED_WAITING/RUNNABLE/TERMINATED </span><br>        System.out.println(<span class="hljs-string">&quot;t1 state2：&quot;</span> + t1.getState());<br>        Thread.sleep(<span class="hljs-number">500000L</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="JVisualVM%E7%9A%84%E9%A9%BB%E7%95%99%E7%8A%B6%E6%80%81.png" alt="JVisualVM的驻留状态"><br>
<img src="JMC%E7%9C%8Bwaiting%E7%8A%B6%E6%80%81.jpeg" alt="JMC看waiting状态"></p>
<p>注意，只有 jvisualvm会有“驻留”这个状态，jmc和jconsole都是直接进入标准的 waiting 状态。目前使用基于aqs 的lock 和 await 语义都会导致waiting，这会和 Object waiting 产生混淆。JVisualVM 似乎能够把 object waiting 和 park 驻留导致的 waiting 专门区别开来。</p>
<h2 id="内存一致性效应-memory-consistency-effects">内存一致性效应（Memory consistency effects）</h2>
<p>哪一种 action happen-before 哪一种action？</p>
<p>通常是 action prior to some release opertion happen-before action following acquire operation。</p>
<p>比如 Semaphore 的 memory consistency effect：Actions in a thread prior to calling a “release” method such as release() happen-before actions following a successful “acquire” method such as acquire() in another thread.</p>
<h2 id="主流锁">主流锁</h2>
<p><img src="Java%E7%9A%84%E4%B8%BB%E6%B5%81%E9%94%81.png" alt="Java的主流锁"></p>
<h3 id="悲观锁与乐观锁">悲观锁与乐观锁</h3>
<p><img src="%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81.png" alt="乐观锁与悲观锁"></p>
<ul>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<h2 id="aqs-abstractqueuedsynchronizer">AQS（AbstractQueuedSynchronizer）</h2>
<p>JUC 有个 locks 包，所有的锁和基于锁的并发基础设施都在这个包里隐藏。这些数据结构被称为同步器，而同步器本身是为了并发安全而存在的（相应地应该也存在原子化的解决方案、隔离的解决方案，我们改天再探讨）。AQS 是为了实现同步器而设计的<strong>框架</strong>，作为 <strong>basis</strong> of a synchronizer（同步器的依据），它提供了 queuing and blocking mechanic。</p>
<blockquote>
<p>AQS虽然被定义为抽象类，但事实上它并不包含任何抽象方法。这是因为AQS是被设计来支持多种用途的，如果定义抽象方法，则子类在继承时必须要覆写所有的抽象方法，这显然是不合理的。所以AQS将一些需要子类覆写的方法都设计成protect方法，将其默认实现为抛出UnsupportedOperationException异常。如果子类使用到这些方法，但是没有覆写，则会抛出异常；如果子类没有使用到这些方法，则不需要做任何操作。</p>
</blockquote>
<p>全部使用 protected 方法也是抽象类的设计方法之一。</p>
<p>AQS 并不是最初的基类，它能够被 Thread Own 这个特性，来自于 AbstractOwnableSynchronizer。它对 Own 的表达方式在于保存一个线程句柄-exclusiveOwnerThread。和锁（Monitor）的markword里保留一个对象头的设计思路是很相似的。</p>
<p>AQS 提供两种模式：</p>
<ul>
<li>独占 exclusive（这是<strong>缺省模式</strong>）：当以独占模式获取时，尝试通过其他线程获取不能成功。<code>When acquired in exclusive mode, attempted acquires by other threads cannot succeed.</code></li>
<li>共享 share：共享模式通常会成功，但实际上不一定。<code>Shared mode acquires by multiple threads may (but need not) succeed.</code>这和其他提供共享锁机制的软件实现（如 MySQL）还是不一样的。当共享模式获取成功时，下一个等待线程（如果存在）也必须确定它是否也可以获取-<strong>也就是说阻塞是决定后的结果</strong>。 <code>when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as well.</code></li>
</ul>
<p><strong>重要</strong>：<strong>在不同模式下等待的线程共享相同的FIFO队列</strong>（互斥和共享模式都需要addWaiter）。实现子类只支持这些模式之一，但是两者都可以在ReadWriteLock中发挥作用（所以同一个 FIFO 队列是实现读写锁混合的基石） 。仅支持独占或仅共享模式的子类不需要定义支持未使用模式的方法。</p>
<p>在四大 try 方法中，tryAcquire()，tryRelease()，tryReleaseShared() 都返回 boolean，只有 tryAcquireShared() 返回数字。</p>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">《一行一行源码分析清楚AbstractQueuedSynchronizer》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016058789">《Java多线程》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">《从ReentrantLock的实现看AQS的原理及应用》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">《不可不说的Java“锁”事》</a></li>
<li><a target="_blank" rel="noopener" href="http://itmyhome.com/java-api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#nested_class_summary">《官方文档的中文翻译》</a></li>
</ol>
<h3 id="aqs-的设计原则">AQS 的设计原则</h3>
<ul>
<li>Node 代表线程。atomic int state 代表锁状态（初始值为0），也就是并发理论里经常提到的临界资源本身，FIFO queue （分为 sync queue 和 wait queue ）是它的同步逻辑的基石（bias）。</li>
<li>依赖状态、队列和 CAS 操作来完成对同步机制的实现。
<ul>
<li>如果要涉及到出入队，操作的顺序大致上是：cas node wait status、sync queue 节点之间的enq 和 deque、管理 aqs 的状态（tryAcquir/tryRelease）。</li>
<li>AQS 自身的状态代表着锁的状态，这些状态都是 transient volatile 的，重点关注锁是被<strong>acquired 还是 released</strong> 。<strong>锁操作的实质就是对状态的维护</strong>。这其中又大量使用 CAS 操作，<strong>CAS操作是最轻量的并发处理动作</strong>。cas 会把操作分隔出两个部分：cas 以前做拥有权限的 if 比对，cas以后做其他成员-如在 AQS 里，主要是 exclusiveOwnerThread 的设值操作，这样就形成了原子性。
<ul>
<li><strong>CAS操作保证了同一个时刻，只有一个线程能修改成功</strong>，从而保证了线程安全，CAS操作基本是由Unsafe工具类的compareAndSwapXXX来实现的；CAS采用的是乐观锁的思想，<strong>因此常常伴随着自旋</strong>，如果发现当前无法成功地执行CAS，则不断重试，直到成功为止，自旋的的表现形式通常是一个<strong>死循环for(;;)</strong>。if 条件写得非常复杂，不易于拆解，而且有些 if 的约束是隐藏在内部的 cas 和自旋里的。有非常多的带有 side-effect 的 action，最终返回一个 boolean，可以被连续地 &amp;&amp; 在一个大括号里。大括号里把某个值设置为 true，意味着把最后一个 action 的返回值带出去。
<ul>
<li>加锁主要比对 state</li>
<li>解锁主要比对 owner thread</li>
<li>通过监控 API 可以查看：是否持有锁、是否有 contend、waitQueue的内容、syncQueue的内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Node 组成的链表代表了所有与锁相关的线程，我们有 sync queue 和 wait queue。
<ul>
<li>在 sync queue 里，头节点代表了拥有锁的线程，而链表的其他部分意味着阻塞队列（所以头指针可以是一个蓝色的node，而阻塞队列是一系列绿色的链表节点）
<ul>
<li>。队列遵循 FIFO 的原则（入队顺序为加锁顺序，从尾部入队），因此能够实现公平锁。
<ul>
<li>原始的<code>acquire</code>要求在队列里的 node，必须 predecessor 为 head 才能<code>tryAcquire</code>，这就实现了先进先出。</li>
<li><strong>公平锁意味着在<code>tryAcquire</code>实现的时候，要看看有没有 queued predecessor（表现为<code>hasQueuedPredeccesor()</code>（而不是<code>predecessor()</code>）方法返回 false，即这个节点）才能够 cas state，进而获取锁</strong>）。</li>
<li><strong>能够实现非公平锁是能够实现公平锁的基础</strong>。非公平锁在 tryAcquireLock 的 casState 之前，没有多余的 hasQueuedPredeccesor() 检查，所以公平锁是非公平锁画蛇添足的结果，非公平锁在 acquire 前面还套了一个很强的短路操作，在入队以前就猛抢，即很多人常说的插队。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Node 的 waitStatus 代表着线程-<strong>锁的等待状态（而不是锁的获取状态）</strong> ，如线程是否取消争抢线程的锁。AQS 内部大量使用 compareAndSetWaitStatus 来变更每个 node 和它的 predecessor 的状态
<ul>
<li>后节点是否在 sync queue 里 acquireQueued 里阻塞，要看前驱节点 ws。是否在 wait queue 里，要看本节点 ws。</li>
<li>通常是由后节点来更新前节点的 ws，自身的 ws 也会在某些情况下被自己的线程更新：
<ul>
<li>每一个 node 在 sync queue 和 wait queue 之间互换是要求在 0 和 CONDITION 之间互换的，在由本线程对本节点使用的。</li>
<li>每一个 node 被取消（主要是 acquireQueued 里发现了 failed）的时候会变成 CANCELLED，不管是自身求锁的时候发现被取消，还是被后继节点取消，或者被 signal 的流程取消。</li>
<li>每一个 node 会因为 next 的入队变成 SIGNAL。</li>
</ul>
</li>
</ul>
</li>
<li>Node 本身也有 next 和 prev，通常对 prev 的重新赋值可以直接用 =，但对 next 的赋值需要做 cas。有时候 set next 还需要考虑 next 自己的 ws。</li>
<li>线程自身还有 state，如 new、runnable 等。</li>
<li>所有的“同步属性”，都是某个类内部的非公开内部帮助类（如 ReentrantLock 内部的 abstract static class Sync）。</li>
<li>aqs 不实现任何 synchronization interface，其他同步器或者具体锁真正需要做的是**使用<code>acquireInterruptibly</code>等方法。**就锁的获取操作而言，子类必须重写<code>tryAcquire</code>方法。</li>
<li>各种 Sync 的标准格式应该是<code>Subclasses should be defined as non-public internal helper classes（非公共内部助手类） that are used to implement the synchronization properties of their enclosing class（封闭类）</code>。</li>
<li>序列化模式：此类的序列化仅存储底层原子整数维持状态，因此反序列化对象具有空线程队列（实现方法是，让链表的各种节点都被设置成<code>transient</code> 的）。 需要可序列化的典型子类将定义一个<code>readObject</code>方法，可以将其恢复为<code>readObject</code>时的已知初始状态。所有的状态都是 atomic 的，这些状态可以被序列化（有一些特定的成员变量被刻意设计成 transient的，如ownerThread），但 queue  通常不能直接被序列化，需要序列化器实现<code>readObject</code>方法才行。</li>
</ul>
<h4 id="简要记忆">简要记忆</h4>
<ol>
<li>互斥：改双入尾，放双出头</li>
<li>共享：初始设态，非0入尾，扣减出队，解放总是全解放。</li>
</ol>
<h3 id="aqs的五层结构">AQS的五层结构</h3>
<p><img src="AQS%E7%9A%84%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="AQS的五层结构"></p>
<blockquote>
<p>上图中有颜色的为Method，无颜色的为Attribution。</p>
<p>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</p>
<p>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</p>
</blockquote>
<h3 id="clh-queue">CLH queue</h3>
<p>CLH 是一种 lock queue，normally used for spinlocks，but here used for blocking synchronizers。</p>
<p>这个 ADT 的 basic tatic 是<code>holding some of the control information about a thread in the predecessor of its node</code>。即本节点是否需要被 SIGNAL（parked - signaled- unparked），是由前一个节点决定的。</p>
<p>A “status” field in each node keeps track of whether a thread should block.</p>
<p>一个 node 是不是需要 block 需要由 status field 决定。实际上一个 field 的 status 为 SIGNAL 必然导致它的 successor parked（形成 blocked）。</p>
<p>A node is signalled when its predecessor releases.</p>
<p>release 里会附带一个 unparked successor 操作，而第一个 acquire 的入队会让出队自动进入一个 for-loop，不断 tryAcquire。</p>
<p>The status field does NOT control whether threads are granted locks etc though.</p>
<p>线程求锁就是它成为队头，队头的 thread 本身为 null。真正 hold thread 的地方只剩下 exclusiveOwnerThread。</p>
<p>入队是作尾，出队是作头。被唤醒不一定得到锁-如果不是公平锁的话。</p>
<p>The “prev” links (not used in original CLH locks), are mainly needed to handle cancellation. If a node is cancelled, its successor is (normally) relinked to a non-cancelled predecessor.</p>
<p>prev 让这个链表变成双向的，主要是为了让 cancelled 的node 的 next 找到新的 predecessor。</p>
<p>next 的用意是为了让 a predecessor signals the next node to wake up by traversing next link to determine which thread it is. next 是可能有争议的，CLH 的算法的用意是在一个节点的 successor 看起来是 null 的时候，对 tail 进行回溯检查-见 unparkSuccessor 里面寻找 null 的方法，这是基于 tail 是 atomically updated 的假定。</p>
<p>CLH 的 head 最初就是 dummy 的，node 被设置为 head 的时候也会变成 dummy 的。</p>
<p>Threads waiting on Conditions use the same nodes, but use an additional link. Conditions only need to link nodes in simple (non-concurrent) linked queues because they are only accessed when exclusively held.  Upon await, a node is inserted into a condition queue.  Upon signal, the node is transferred to the main queue.  A special value of status field is used to mark which queue a node is on.</p>
<p>condition 有一个单独的 condition queue，和 main queue 使用同一批节点，但使用 additional link。</p>
<p><img src="CLH%E5%8F%98%E4%BD%93%E9%98%9F%E5%88%97.png" alt="CLH变体队列"></p>
<h3 id="互斥框架的标准伪代码">互斥框架的标准伪代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 所以 tryAcquire 可以用非阻塞实现阻塞，tryAcquire 是一切 aqs 操作的灵魂</span><br><span class="hljs-comment">// 1. 试获取（改 state 和ownerThread）2. 入队</span><br>Acquire:<br>     <span class="hljs-comment">// 自旋带来阻塞，没有 sleep，这里就没有引入 clh 的 block</span><br>     <span class="hljs-keyword">while</span> (!tryAcquire(arg)) &#123;<br>        enqueue thread <span class="hljs-keyword">if</span> it is not already queued;<br>        possibly block current thread;<span class="hljs-comment">// 可以 block 也可以不 block，要看入队以后第二次 tryAcquire 的结果，以及 predecessor 的 waitStatus</span><br>     &#125;<br><br> Release:<br>    <span class="hljs-comment">// 1.试释放（改 state 和ownerThread）2. 尝试唤醒 successor，不需要出队，因为作为头部就已经算是出队了</span><br>     <span class="hljs-keyword">if</span> (tryRelease(arg))<br>        <span class="hljs-comment">// 尝试唤醒，这里的伪代码实际上漏掉了实现中存在的 unpark</span><br>        unblock the first queued thread;<br><br><span class="hljs-comment">// 锁的调用模式：</span><br>somelock.lock()<br><br><span class="hljs-comment">// 有的 lock 会有 sync.lock() 的设计（如 ReentrantLock 的 UnfairSync），通过这一层再 delegate 到 acquire，lock 里面会有一个短路的 tryAcquire 操作。这足以证明 tryAcquire 不一定和 CLH 机制有关</span><br>sync.acquire(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<h3 id="node-的实现">Node 的实现</h3>
<p><img src="Node%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="Node的结构"></p>
<p>构造器，一个是需要 waitStatus，一个需要 nextWaiter，但都需要 Thread。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Link to the successor node that the current node/thread</span><br><span class="hljs-comment"> * unparks upon release. Assigned during enqueuing, adjusted</span><br><span class="hljs-comment"> * when bypassing cancelled predecessors, and nulled out (for</span><br><span class="hljs-comment"> * sake of GC) when dequeued.  The enq operation does not</span><br><span class="hljs-comment"> * assign next field of a predecessor until after attachment,</span><br><span class="hljs-comment"> * so seeing a null next field does not necessarily mean that</span><br><span class="hljs-comment"> * node is at end of queue. However, if a next field appears</span><br><span class="hljs-comment"> * to be null, we can scan prev&#x27;s from the tail to</span><br><span class="hljs-comment"> * double-check.  The next field of cancelled nodes is set to</span><br><span class="hljs-comment"> * point to the node itself instead of null, to make life</span><br><span class="hljs-comment"> * easier for isOnSyncQueue.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> Node next;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Link to predecessor node that current node/thread relies on</span><br><span class="hljs-comment"> * for checking waitStatus. Assigned during enqueuing, and nulled</span><br><span class="hljs-comment"> * out (for sake of GC) only upon dequeuing.  Also, upon</span><br><span class="hljs-comment"> * cancellation of a predecessor, we short-circuit while</span><br><span class="hljs-comment"> * finding a non-cancelled one, which will always exist</span><br><span class="hljs-comment"> * because the head node is never cancelled: A node becomes</span><br><span class="hljs-comment"> * head only as a result of successful acquire. A</span><br><span class="hljs-comment"> * cancelled thread never succeeds in acquiring, and a thread only</span><br><span class="hljs-comment"> * cancels itself, not any other node.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> Node prev;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Link to the successor node that the current node/thread</span><br><span class="hljs-comment"> * unparks upon release. Assigned during enqueuing, adjusted</span><br><span class="hljs-comment"> * when bypassing cancelled predecessors, and nulled out (for</span><br><span class="hljs-comment"> * sake of GC) when dequeued.  The enq operation does not</span><br><span class="hljs-comment"> * assign next field of a predecessor until after attachment,</span><br><span class="hljs-comment"> * so seeing a null next field does not necessarily mean that</span><br><span class="hljs-comment"> * node is at end of queue. However, if a next field appears</span><br><span class="hljs-comment"> * to be null, we can scan prev&#x27;s from the tail to</span><br><span class="hljs-comment"> * double-check.  The next field of cancelled nodes is set to</span><br><span class="hljs-comment"> * point to the node itself instead of null, to make life</span><br><span class="hljs-comment"> * easier for isOnSyncQueue.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> Node next;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Marker to indicate a node is waiting in shared mode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Marker to indicate a node is waiting in exclusive mode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br>&#125;<br><span class="hljs-comment">// SHARED 和 EXCLUSIVE 其实是用来指向 nextWaiter 的，这里隐含一个假设，非互斥获锁的前提下不需要使用条件变量，缺省情况下 EXCLUSIVE 才是 null</span><br>Node(Thread thread, Node mode) &#123;     <span class="hljs-comment">// Used by addWaiter</span><br>    <span class="hljs-built_in">this</span>.nextWaiter = mode;<br>    <span class="hljs-built_in">this</span>.thread = thread;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="锁">锁</h3>
<h4 id="加锁">加锁</h4>
<p>求锁的过程里，得到锁的线程会被记录在 aqs 的成员里，而得不到锁的线程会把 aqs 作为 blocker 记在自己的对象里。</p>
<h5 id="clh-主框架">CLH 主框架</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 走完第一步走第二步，第一步求锁成功改状态和线程-这是被包裹在一个原子操作里的，如果不成功走到第二步，让 acquire 这个操作入队，用 node 来管理线程。</span><br><span class="hljs-comment"> * 这一步就实现了通过 cas 把前条件和后操作分隔开来，acquireQueued 本身是阻塞的，出来才会需要做 selfInterrupt 的重置</span><br><span class="hljs-comment"> * Node.EXCLUSIVE 是一个 null，而 Share 是一个平凡的 empty Node 单例，所以先实现出来的 condition queue（而不是 CLH queue）是 exclusive 的</span><br><span class="hljs-comment"> */</span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;<br>    <span class="hljs-comment">// 这个 selfInterrupt 是唤醒以后使用的。入队是在 addWaiter 做的，自旋-唤醒-检查能否 tryAcquire 出队 - 继续 park 是在 acquireQueued 里做的</span><br>    selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>acquire 最复杂，aqs 自己实现了，最好不要覆写，所以一般设计 sync 都是从外部和 tryAcquire 入手（重点：tryAcquire 是非 CLH queue 的部分，只是对 state 和 ownerThread 的原子操作，易于覆写。而 CLH 队列的出队入队是 AQS 自身的标准套路，不需要覆写，覆写会造成破坏）。在 AQS 里，tryAcquire 默认的实现是空。</p>
<p>阻塞主要靠的是 tryAcquire(1) 以后的入队操作。</p>
<h6 id="tryacquire">tryAcquire</h6>
<p>tryAcquire 通常是交给具体的lock实现的：cas 本身的 state，修改 ownerThread 是在这一层做的。甲骨文推荐的一个特别简单的实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == arg;<br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 这两步无锁放在一起，也算原子了，因为只有一个线程的 cas能走进来，不考虑线程中断的问题</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, arg)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个实现过于简单，以至于忽略了一个简单的问题，那就是，为什么这里没有累加呢？因为累加就要加上一个判定 volatile currentOwnerThread 是否等于 currentThread 的问题。所以问题又变成为什么没有对 currentOwnerThread 的检查呢？所以 ReentrantLock 的实现里是会针对互斥 owner 提出判断分支的。</p>
<h6 id="addwaiter">addWaiter</h6>
<p>这是一个 aqs 自身的成员方法，会生成一个节点，加入到自身的队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 每一个node 天然出现的时候，自己的 next 都是 mode 参数本身，tail 的next 是 mode</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// 最快入队的方法是在把新节点的 pred 设置成队尾，所以 FIFO 的 I 指的是对 tail 的追加</span><br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-comment">// 如果存在队尾-此时这不是一个空链表，否则必定走入一个 enq</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 先设置 node 的 prev，在并发入队时，会有多个 node 的 prev 设置为 pred</span><br>        node.prev = pred;<br>        <span class="hljs-comment">// 这一步的实现，是把当前 aqs 的 tail 节点设置为新的 node，之前的 tail 的 prev 本身是不变的</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            <span class="hljs-comment">// 然后把老 tail 的 next 设置为本 node，只有成功通过 cas 的 node 能够得到 pred 的next，其他节点还维持错误的 prev</span><br>            pred.next = node;<br>            <span class="hljs-comment">// 然后就可以从快路线返回了，此处返回的是 node 本身</span><br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 进入这里的 node 的 prev 还是错的，在这一步返回的 node 是 alreadyLinked 了的，注意，这个方法返回的不是node本身，而是它的前驱</span><br>    enq(node);<br>    <span class="hljs-comment">// 然后就算入队成功，可以返回了</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在外面虽然有一个 enqued 的操作，但实质上对 tail 的修改-也就是入队，是被收敛到 enq(node) 这个方法调用里的，这一个 addWaiter 方法里完成了全部的入队操作。</p>
<h6 id="enq">enq</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node to insert</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> node&#x27;s predecessor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-comment">// 无限循环，直到能够返回一个 t 为止，enq 的存在是为了实现一个多线程 for 循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 因为 tail 为空 head 必为空，所以此处用局部变量来节省性能，使用链表的基本法则之一是，在一轮操作里会被修改的变量，要被提前存起来</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-comment">// 在 for 循环里，只会进入这一步一次</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-comment">// 设计一个空的队头，然后把本 aqs 的 head 设置为 tail。注意，这个链表的第二个节点可能是抢不到锁的，但执行 enq 的时候，实际上前一个节点已经把锁释放了，所以此处可能遇到一个无头队列，如果无头，则初始化 tail 和 head</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                <span class="hljs-comment">// 这里隐藏一个设定，就是 head 和 tail 只要有一个为空，就全部为空。上一个 cas已经卡住其他操作，这里的操作就不用 cas，直接 set 即可</span><br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这一段代码就是外部代码的一部分，只不过移到一个 for loop 里来，这一段是无 sleep 和无 park 的自旋 + 一个初始化链表的操作</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>            <span class="hljs-comment">// 如果 cas 失败，则下一轮的 node.prev 会被覆写</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="acquirequeued">acquireQueued</h6>
<p>这个方法提供了一个内部的自旋和 park 和从 unpark 中醒来的全部流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Acquires in exclusive uninterruptible mode for thread already in</span><br><span class="hljs-comment">     * queue. Used by condition wait methods as well as acquire.</span><br><span class="hljs-comment">     * 我们可以先姑且认为，这个方法是一个极度特殊版本的 acquire。</span><br><span class="hljs-comment">     * 是在互斥且不可中断模式下（与之相对地是 doAcquireShared，本方法也可以被叫做 doAcquireExclusive）</span><br><span class="hljs-comment">     * share 和 interruptibly 是两个维度</span><br><span class="hljs-comment">     * 每一个节点进入queue的顺序是这样的：</span><br><span class="hljs-comment">     * 1. 先看看自己是不是 head 后的第一个node（此处不分公平锁还是不公平锁）或者尝试获取锁（此处可能是为了预防并发，这意味着 pred 可能是被污染的），如果是的话，带着 interrupted 返回</span><br><span class="hljs-comment">     * 2. 检查 pred 的状态 ws：</span><br><span class="hljs-comment">     *    2.1  ws 此时是 SIGNAL，意味着上次已经设值过了，此节点需要做的就是 park，等待进入下一循环，如果下次循环还是求不到锁，前节点的 SIGNAL不变，总是能够不断地被 park，unpark。在此直接返回</span><br><span class="hljs-comment">     *    2.2 如果 ws 此时是 CANCELLED，寻找一个新的 pred（做 pred 收窄），但不去碰新 pred 的状态</span><br><span class="hljs-comment">     *    2.3 尝试把它设置为 SIGNAL</span><br><span class="hljs-comment">     *    2.4  2.2 和 2.3 会直接导致 false 退出，然后进入下一轮的求锁循环，下一轮循环开始时，pred 的节点终究会是 SIGNAL，然后就可以 park 了</span><br><span class="hljs-comment">     * 所以 CLH queue 本质上是1 入队，2 获锁，3 检查 pred，park等唤醒 唤醒检查 interrputed 或者设置 pred 但不park，4 再进入 for 循环尝试2获锁（还没有 release），一旦获取锁就带着 interrupted 离开自旋的一种结构</span><br><span class="hljs-comment">     * 所有的 bloking queue 的轮询等待，都在这里通过 for loop park 来实现</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arg the acquire argument 这个参数主要是递归调用 tryAcquire 时用的</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if interrupted while waiting</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-comment">// 一开始会预设失败</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 一开始会预设未被中断</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 阻塞由两部分组成，一部分是这里的 for 循环，一部分是下面的检查 park</span><br>            <span class="hljs-comment">// 每次进入第一部分都先尝试获锁</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-comment">// node 在循环里是不会变的，每个循环里都只取 node 的前置</span><br>                <span class="hljs-comment">// 注意，阻塞队列不包含 head 节点，head 一般指的是占有锁的线程，head 后面的才称为阻塞队列。这个方法在需要 npe 检查的时候会代替成员指针拿出来用</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-comment">// 如果它的前驱为 head-就是获取锁的当前线程（前驱为 head，意味着本 node 前面已经没有节点了，也就意味着这是出队方法），则尝试获取锁-acquireQueued 外部是由 tryAcquire 开头的，自己也是由 tryAcquire 结尾</span><br>                <span class="hljs-comment">// 历史上第一个 head 其实是一个空 node（根据懒加载原理），如果本 node 后入队发现自己是阻塞队列的第一个节点，则还要再尝试 tryAcquire 一下</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    <span class="hljs-comment">// 如果获锁成功，则把本节点设置为头，头就是这样被替代的，头就意味着出队的线程。            </span><br>                    setHead(node);<br>                    <span class="hljs-comment">// 此时本 node（也就是 head）不一定是 tail，因为在这个 for 循环里，可能有其它线程 link 过本 node 了</span><br>                    <span class="hljs-comment">// 但 p 本身是“前一个 head”，新老交替的结果就是把 p 和 node 做一个 unlink</span><br>                    <span class="hljs-comment">// 这两步把 head 做了一个出队</span><br>，                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// interrupted 为true 或者 false 都可能退出这个队列，这一步是一定会跑到的，而 interrupted 可能被上一轮循环的尾部给修改了</span><br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-comment">// 如果在上面一步没有返回，则没有产生收窄出队的效应。在这一步就会产生判定是不是要 park 以及实际 park 操作了</span><br>                <span class="hljs-comment">// 第一个条件检查状态机，看看是不是 shouldPark</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) <br>                    <span class="hljs-comment">// 第二个条件用 park 来实现阻塞，这个 park 就是 waiting queue 的实质了</span><br>                    &amp;&amp; parkAndCheckInterrupt())<br>                    <span class="hljs-comment">// 理论上被中断唤醒以后会进入这里，重新设计中断位（因为底层清了，这里有些多此一举），否则也可能 interrupted 为 false 退出这里</span><br>                    <span class="hljs-comment">// 这一步是可能被跑到，但大部分时候跑不到的</span><br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                <span class="hljs-comment">// 注意，这里是在 for循环之外的一个兜底措施，上面的 for循环本身只有求到锁以后的 return 退出方法，这里是为了预防异常，在求锁过程中遇到异常，要直接清掉这个节点，这意味着这个 node 在 acquire 操作下无法进入正常的状态</span><br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的复杂之处在于，理解 pred/next 的复杂性，和 waitStatus 对 AQS 工作流程的间接影响。</p>
<p><img src="acquireQueued%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="acquireQueued的实现"></p>
<h6 id="sethead">setHead</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets head of queue to be node, thus dequeuing. Called only by</span><br><span class="hljs-comment"> * acquire methods.  Also nulls out unused fields for sake of GC</span><br><span class="hljs-comment"> * and to suppress unnecessary signals and traversals.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHead</span><span class="hljs-params">(Node node)</span> &#123;<br>    head = node;<br>    <span class="hljs-comment">// 在这里只从 node 视角进行操作，node.prev.next 的 unlink 操作留给外部的 node.prev 自己做</span><br>    <span class="hljs-comment">// 获取锁以后，算是出了 waiting-set 了，本 node 只是给 aqs 管理队列用，所以解除了对 thread 的引用，防止 thread 不能被回收</span><br>    <span class="hljs-comment">// 这个 node hold thread 和 status 都不算让 thread hold lock，node as head 算是让 thread 加了锁</span><br>    node.thread = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// head 不应该有 prev 的，因为这不是循环链表</span><br>    node.prev = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的关注点是：node 是dummy 的，要清空自身状态。</p>
<h6 id="shouldparkafterfailedacquire">shouldParkAfterFailedAcquire</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Checks and updates status for a node that failed to acquire.</span><br><span class="hljs-comment"> * Returns true if thread should block. This is the main signal</span><br><span class="hljs-comment"> * control in all acquire loops.  Requires that pred == node.prev.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pred node&#x27;s predecessor holding status</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if thread should block</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-comment">// 这个状态机很有意思，这意味着我们的每一个 node 的实际状态是应该由前一个node（即 pred）来决定的</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-comment">// 前一个节点的 SIGNAL 状态，意味着后一个线程的 unpark。</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * This node has already set status asking a release</span><br><span class="hljs-comment">         * to signal it, so it can safely park.</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-comment">// 被 signal 以后反而会触发 park。这里的 signal 指的是 asking a release to signal it，通过 park 来等 unpark 来进入下一个循环的入口</span><br>         <span class="hljs-comment">// 通常我们要进入队列就是要 park 的。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 这里的大于零此时专指 CANCELLED，以后 cancelled 类的状态都必须大于零（反过来也一样）</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">         * indicate retry.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 链表自动做一个小的收窄，所有的 cancelled 线程要排出本链表，这里是自动把本 node 的prev跳了一下，为什么不会有并发问题安全问题还是不太容易看明白</span><br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 缩进玩</span><br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 这里引入了一个对状态机的隐式推导，可读性不太好。作者断言，此处要么是 0，要么是 PROPAGATE。CONDITION 也就是 -2 不会进入这个方法，因为 CONDITION 在另一个队伍里</span><br><span class="hljs-comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">         * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">         * 此时我们需要一个 signal，但还不需要 park</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-comment">// 否则尝试将 pred 的status 置为 SIGNAL，这样下一轮循环的时候，就可以进入 park，然后等 unpark了</span><br>         <span class="hljs-comment">// 也就意味着，这个 CLH 里的队列的每个 node 都天然需要自己的前驱是 SIGNAL 才正常。最初入队的 thread addWaiter 的时候会初始化一个 dummy head，然后进入这里，把这个 head 设置为 Node.SIGNAL。然后下一轮循环进到这里来，会从上面的 return true 那里出去。等于每一个节点是由它的后继节点的 acquiredQueued() 的第一次 for loop 设置为 SIGNAL 的。</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-comment">// 本次检查先不park，不 park 则外部可能就直接进入下一轮循环，尝试抢锁，失败再看要不要 park</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个配置告诉我们几个已知事实：每个节点的 waitStatus 状态，在主流程里是由后面的排队的 next 的入队来触发变化的。</p>
<p><img src="shouldParkAfterFailedAcquire.png" alt="shouldParkAfterFailedAcquire"></p>
<h6 id="parkandcheckinterrupt">parkAndCheckInterrupt</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 入队和每次 for 循环被唤醒抢不到锁，然后又需要 park，就会进入本方法 park 一次</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>这里需要关注的是this 作为 blocker 参数。</p>
<h6 id="cancelacquire">cancelAcquire</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Cancels an ongoing attempt to acquire.</span><br><span class="hljs-comment"> * 1. 设置本节点内部状态：status 和 thread</span><br><span class="hljs-comment"> * 2. 把本节点的前后节点做好 unsplice，意味着对出队做好准备</span><br><span class="hljs-comment"> * 3. 把本节点从 aqs 的视图里去掉，这里使用了一个二分法：区分是队尾和不是队尾</span><br><span class="hljs-comment"> * 4. 在这个方法里面我们有一个很重要的认知迭代：signal、cancel 和各式各样的 acquire 是存在 race condition 的，对于 ws、queue的头和尾都是需要 cas的。</span><br><span class="hljs-comment"> * 5. 尽量先找 pred，动力从 pred 来</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// Ignore if node doesn&#x27;t exist</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 清空本 node</span><br>    node.thread = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// Skip cancelled predecessors。因为 enq 效应存在，node.prev 不会为 null</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;<br>    <span class="hljs-comment">// 在这里也在做一个 prev 的覆盖，只管本废弃节点的 prev 即可，这里可能会存在一个并发问题，如果 pred 的 prev 本身同时也在修改，则 node.prev 会跟着这个 prev 修改变动。这种“越过”操作的本质是废弃不当的 prev，至于 pred.prev 是不是正常，那另当别论</span><br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)<br>        node.prev = pred = pred.prev;<br><br>    <span class="hljs-comment">// predNext is the apparent node to unsplice. CASes below will</span><br>    <span class="hljs-comment">// fail if not, in which case, we lost race vs another cancel</span><br>    <span class="hljs-comment">// or signal, so no further action is necessary.</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;<br><br>    <span class="hljs-comment">// Can use unconditional write instead of CAS here.</span><br>    <span class="hljs-comment">// After this atomic step, other Nodes can skip past us.</span><br>    <span class="hljs-comment">// Before, we are free of interference from other threads.</span><br>    node.waitStatus = Node.CANCELLED;<br><br>    <span class="hljs-comment">// 在这里只做一个逻辑二分，只解决是不是队尾的问题，不区分队中和队头，如果是队尾则不用管 node next</span><br>    <span class="hljs-comment">// If we are the tail, remove ourselves.</span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<br>        <span class="hljs-comment">// 尾节点不需要 next，直接清空，因为中间节点实际上都是 cancelled 的节点</span><br>        compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果要处理 next，也有两种思路：把 pred 的next link 和 本 node 的 next 连起来，或者直接unpark node 的 next，总之本 node 的 next 得到了很好的处理</span><br>        <span class="hljs-comment">// If successor needs signal, try to set pred&#x27;s next-link</span><br>        <span class="hljs-comment">// so it will get one. Otherwise wake it up to propagate.</span><br>        <span class="hljs-type">int</span> ws;<br>        <br>        <span class="hljs-comment">// pred 的节点自身是 SIGNAL 和 cas 成 SIGNAL 是等效的，这是 Doug Lea 的习惯</span><br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;<br>            ((ws = pred.waitStatus) == Node.SIGNAL ||<br>             (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;<br>            pred.thread != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;<br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// prev 是不怕有并发安全问题的，但 next 一定要使用 compareAndSetNext，也就是说 prev 寻址出错不要紧，但 next 寻址出错要紧，这是容易被忽略的</span><br>                compareAndSetNext(pred, predNext, next);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 不属于上面的情况，即 pread 是头或者 pred 的状态不为 signal（即使在 cas 设置过后）或者 pred 的线程为空，则对 succesor 进行 unpark 操作，所以 succesor unpark 不是常态</span><br>            unparkSuccessor(node);<br>        &#125;<br>        <span class="hljs-comment">// 清除完 prev，最后再清除 next，即本方法主要是对 next 负责，不对 pred 负责</span><br>        node.next = node; <span class="hljs-comment">// help GC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>队尾和不是队尾的流程太复杂了，要仔细看。</p>
<p><img src="cancelledAcquire-%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%98%AF%E5%B0%BE%E8%8A%82%E7%82%B9.png" alt="cancelledAcquire-当前节点是尾节点"><br>
<img src="cancellAcquire-%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%98%AFhead%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9.png" alt="cancellAcquire-当前节点是head的后继节点"><br>
<img src="cancellAcquire-%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%98%AF%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.png" alt="cancellAcquire-当前节点是中间节点"></p>
<h5 id="公平锁与非公平锁">公平锁与非公平锁</h5>
<p><img src="%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%B5%81%E7%A8%8B1.png" alt="非公平锁流程1"><br>
<img src="%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%B5%81%E7%A8%8B2.png" alt="非公平锁流程2"></p>
<p>ReentrantLock 的 sync 的 lock 方法是抽象的，对公平锁和非公平锁来讲都是一个壳方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.lock();<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">// state == 0 此时此刻没有线程持有锁</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span><br>        <span class="hljs-comment">// 看看有没有前置的排队节点，这是 cas 前条件。这也是公平的</span><br>        <span class="hljs-comment">// 这个嵌套条件判断没有和外面的条件判断放在一起，算是一个可读性更好的表达。在这里我们要注意，很多场合会同时出现 pred 和 prev，把这两个词分开就不会出现 prev.prev 的读写问题了</span><br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>            <span class="hljs-comment">// 如果没有线程在等待，那就用CAS尝试一下（注意这里有一个并发处理问题），成功了就获取到锁了</span><br>            <span class="hljs-comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span><br>            <span class="hljs-comment">// 因为刚刚还没人的，我判断过了</span><br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            <span class="hljs-comment">// 这是 cas 后操作</span><br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>      <span class="hljs-comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span><br>    <span class="hljs-comment">// 这里不存在并发问题</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-comment">// 这里告诉我们，子类也可能传入错误的 acquire，这里要做防御性编程。这里允许等于0，这就要求 release 的时候要注意 release 操作的对称性</span><br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果到这里，说明前面的 if 和 else if 都没有返回 true，说明没有获取到锁，直接返回 false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意 FairSync 和 NoneFairSync 的区别一部分在 tryAcquire，acquire 的标准实现在 AQS 里是不需要实现的。</p>
<h4 id="解锁">解锁</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这一段代码是 ReentrantLock 里的，解锁也是一个抽象方法，跨公平锁和非公平锁</span><br><span class="hljs-comment"> * Attempts to release this lock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;If the current thread is the holder of this lock then the hold</span><br><span class="hljs-comment"> * count is decremented.  If the hold count is now zero then the lock</span><br><span class="hljs-comment"> * is released.  If the current thread is not the holder of this</span><br><span class="hljs-comment"> * lock then &#123;<span class="hljs-doctag">@link</span> IllegalMonitorStateException&#125; is thrown.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if the current thread does not hold this lock</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>解锁也依赖于壳方法。</p>
<h5 id="release">release</h5>
<p>release 也分双重，需要复写的只有 tryRelease，管理状态用这个方法不管公平不公平，统一 tryRelease + unparkSuccessor head</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span><br><span class="hljs-comment"> * more threads if &#123;<span class="hljs-doctag">@link</span> #tryRelease&#125; returns true.</span><br><span class="hljs-comment"> * This method can be used to implement method &#123;<span class="hljs-doctag">@link</span> Lock#unlock&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arg the release argument.  This value is conveyed to</span><br><span class="hljs-comment"> *        &#123;<span class="hljs-doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span><br><span class="hljs-comment"> *        can represent anything you like.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the value returned from &#123;<span class="hljs-doctag">@link</span> #tryRelease&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 这里的 tryRelease 的返回结果是是否完全释放的意思</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 这里的 != 0 就是 SIGNAl 的意思</span><br>        <span class="hljs-comment">// 只要/只有完全释放了 state 才唤醒 h 的继任者</span><br>        <span class="hljs-comment">// ws &gt; 0，h 取消了；ws &lt; 0，要么是 PROPAGATE，要么是 SIGNAL，从语义上来讲后继节点就是一个阻塞态。换言之，如果head是初始节点，则不需要 unpark 后继</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="tryrelease">tryRelease</h6>
<p>tryRelease 的返回值是值得关注的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-comment">// 减少可重入次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-comment">// 当前线程不是持有锁的线程，抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">// free 的意思是完全释放锁，不管 true/false，state 总是会被扣减掉的</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只有完全释放锁，才算 free，进入只执行一次的 post-free 流程。</p>
<h6 id="unparksuccessor">unparkSuccessor</h6>
<p>这个方法在 release 或者某个 node cancelled 的时候会被调用这个方法的难度在于，如何决定 successor。那些 timeout 的就不要了有时候 unparkSuccessor 的对象是 head，有时候是任意节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">         * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">         * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>        <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 把本 node 设置为非状态机的初始态</span><br>            compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Thread to unpark is held in successor, which is normally</span><br><span class="hljs-comment">         * just the next node.  But if cancelled or apparently null,</span><br><span class="hljs-comment">         * traverse backwards from tail to find the actual</span><br><span class="hljs-comment">         * non-cancelled successor.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>            s = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 从尾部开始遍历，直到要 unpark 的节点是尾部的第一个 waitStatus 为负数的 node</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>                <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                    s = t;<br>        &#125;<br>        <span class="hljs-comment">// 找到即唤醒它</span><br>        <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">// node 里持有 thread 的用意就是让外围的 lockSupport 来引用和 unpark</span><br>            LockSupport.unpark(s.thread);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="独占与共享">独占与共享</h4>
<p><img src="%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F.png" alt="独占模式与共享模式"></p>
<h3 id="条件">条件</h3>
<p>从 Doug Lea 的原始设计思路来讲，一个 Condition 是要引出一组多线程共用的 wait-set。它和锁的抽象实现了arbitrary lock 和 condition implementaion 的正交组合。</p>
<p>Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods. 在原始的 Java 锁机制里面，synchronized 被叫作 synchronized methods，而 condition 被叫作 monitor methods。</p>
<p>条件有很多种叫法，可以叫作 condition queue，也可以叫作 condition variable。一个线程的使用语序总是先 wait，然后再由外部 notify，又内外协同来实现对执行上下文的切换。</p>
<p>这种状态必须被锁保护，否则就会触发 IllegateMonitorStateException。这会导致 ConditionObject 的实现总是一个 lock implementation 的 inner class，相互持有引用。A Condition instance is intrinsically bound to a lock。</p>
<p>有一个 key property 就是，Condition 会  atomically releases the associated lock and suspends the current thread，也就是说 Thread 会从一种 waiting 切换到另一种 waiting。但是锁没了。恰如  Java 语言规范力图描述的那样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个程序的意义告诉我们：如果两个条件变量是互斥的-即不同时为真，则可以实现环形的 wait 和 notify（即相互阻塞），而不会产生死锁</span><br> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedBuffer</span> &#123;<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span>  <span class="hljs-operator">=</span> lock.newCondition(); <br>     <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition(); <br>  <br>     <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>     <span class="hljs-type">int</span> putptr, takeptr, count;<br>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object x)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       lock.lock();<br>       <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">while</span> (count == items.length)<br>           notFull.await();<br>         items[putptr] = x;<br>         <span class="hljs-keyword">if</span> (++putptr == items.length) putptr = <span class="hljs-number">0</span>;<br>         ++count;<br>         notEmpty.signal();<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<br>       &#125;<br>     &#125;<br>  <br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       lock.lock();<br>       <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>           notEmpty.await();<br>         <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> items[takeptr];<br>         <span class="hljs-keyword">if</span> (++takeptr == items.length) takeptr = <span class="hljs-number">0</span>;<br>         --count;<br>         notFull.signal();<br>         <span class="hljs-keyword">return</span> x;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<br>       &#125;<br>     &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>理论上来讲，condition 能够提供某些原生 notify 不支持的行为，如：</p>
<ol>
<li>guaranteed ordering for notifications</li>
<li>not requiring a lock to be held when performing notifications</li>
</ol>
<p>往下我们会看到，这些可选的 notification feature 的实现，严重依赖于类似 Reentrantlock 里标准的 isHeldExclusive 的实现。</p>
<p>Condition 对象原生的 monitor 相关方法仍然是可以被使用的，只不过最好不要拿来用，因为它会搞混你对条件队列的理解。</p>
<p>因为 spurious wakeup 的存在，所以 condition 的 waiting 一定要在一个 loop 里面执行。当然，一个狭义的实现也可以不允许 spurious wakeup 的存在，这就会要求不遵循 platform 的默认模式。</p>
<p>条件等待有三种形式：</p>
<ol>
<li>interruptible waiting  会抛出中断异常</li>
<li>non-interruptible waiting 不会抛出中断异常</li>
<li>timed waiting</li>
</ol>
<p>不管采用哪种形式，从 await 中返回过来，这个线程要 guaranteed to hold this lock。</p>
<p>另外，在 Java 的设计里面，凡是抛出 InterruptedException，<a href="#aqs-%E4%B8%8E%E4%B8%AD%E6%96%AD">必定清空 interrupted state</a>。</p>
<h4 id="条件对象">条件对象</h4>
<p>条件对象仍然管理 Node，而且也是用头和尾的形式，不过这次的链表是个单链表。一般的 Lock 是用 Sync 来管理 lock，sync 作为 AQS 自己维护 node，用 ConditionObject 来管理condition，ConditionObject 自己管理 Node。照理来讲一个 lock 可以产生多个 condition object 线程可以通过 await 操作，进入多个队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;<br>        <span class="hljs-comment">// 条件队列的第一个节点</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br>        <span class="hljs-comment">// 条件队列的最后一个节点</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97.png" alt="条件队列"></p>
<p>我们可以看到，Node 仍然是AQS 的 node，但它们的 ws 是 Node.CONDITION。</p>
<h5 id="总结">总结</h5>
<p>大部分的换状态，放锁，部分的中断回再换状态回 sync queue，重新获锁，检查中断的流程都是在 await 中完成的；而 signal 中完成的只是主动的 transferForSignal，完成主动的 换状态回 sync queue 操作，和部分的唤醒。</p>
<h5 id="await">await</h5>
<ol>
<li>检查是否需要抛出中断异常。</li>
<li>在调用 await 相关方法的时候，线程先进入 wait queue。此时线程也不在 sync queue里了，因为获取锁才可以 await，获取锁的时候它已经是 sync queue 的 head 了。</li>
<li>调用 fullyRelease 方法，释放锁并把锁释放前的状态取出来。</li>
<li>在 wait queue 的自旋里检查 isOnSyncQueue。如果没有在同步队列里，自己 park，park 的 blocker 是 ConditionObject。每次从 park 中唤醒有两种可能：被 signal 内置的 unpark 唤醒，或者被中断唤醒。线程检查自己是不是被中断唤醒的，如果是被中断唤醒的，则自己 transfer 到 sync queue 里，设置 interrupt mode 然后退出；否则，它是被 signal 唤醒的，此时已经在 sync queue里了。自旋到下一阶段也会退出。</li>
<li>进入 wait queue 会把 ws 置为 condition，而进入 sync queue 则置为 0（等待 next 置为 SIGNAL），然后做好前后节点的 link。</li>
<li>调用 acquireQueued，引出在 sync queue 里的 park （park 的 blocker 是 AQS 自己）和自旋。</li>
<li>从 acquireQueued 返回真则本线程又是从中断中返回的，要确认上一步的 interrupt mode 是不是指示我们抛出异常，如果是则 interrupt mode 不变，否则设置 interrupt mode 为重新设置中断位。</li>
<li>看看本 node 的 next waiter 是不是 null，是的话 unlinkCancelledWaiters。</li>
<li>根据 interrupt mode 来让线程选择一种方式来设置自己的中断位。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock1.newCondition();<br><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; &#123;<br>            lock1.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                condition.await();<br>                System.out.println(<span class="hljs-string">&quot;i am awaken&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock1.unlock();<br>            &#125;<br>        &#125;);<br>        t1.setName(<span class="hljs-string">&quot;TTTTT1&quot;</span>);<br>        t1.start();<br>        t1.interrupt();<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个方法值得一看的地方是，如果一个方法是长时间的阻塞的，它是不是对外声明自己要响应中断，如果要响应中断，则中断是无时无刻在发生的，它要怎么在多个地方响应中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            <span class="hljs-comment">// 如果开始 await 之前线程已经被中断了，则直接显式地抛出异常。这里有一个 juc 的习惯，只要抛出异常必定清空中断位，反之亦然</span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            <span class="hljs-comment">// 先入 wait queue 队伍</span><br>            <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>            <span class="hljs-comment">// 然后彻底释放锁，注意，此时其实线程也不在 sync queue里了，代表它的是头节点，所以这里只要清理 aqs 的state就行了，为了预防万一，我们先留存 savedState</span><br>            <span class="hljs-comment">// 这个设计是先冗余入队，然后再释放锁。这个方法表面上看起来没有做 isHeldExclusive 的检查，实际上在 tryRelease 的内部就会有，因为 tryRelease 是可选实现的，甚至 isHeldExclusive 也是可选实现的，所以条件在锁内被持有的设计规范是可以被破坏掉的</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>            <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-comment">// 这里的 syncQueue 就是 CLH queue 里面非头的部分了，在这里就是自己 park，然后自旋</span><br>           <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>                <span class="hljs-comment">// 注意，这里的 park 使用的 blocker 是 ConditionObject</span><br>                LockSupport.park(<span class="hljs-built_in">this</span>);<br>                <span class="hljs-comment">// 一旦从 unpark 中醒来，要做几件事，首先检查中断，如果中断，则由 await 来做 transfer queue的操作，走 park 内部的 transfer 流程（把 node 的节点置回0，然后 enq node，算是完成了 queue 之间的 transfer），如果走完就会从这里面 break，但如果不发生中断，而产生了 signal，signal 内部也会完成 enq，让 isOnSyncQueue 检测到自动退出而不是 break 退出</span><br>                <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>                    <span class="hljs-comment">// 如果因中断退出，而不是 signal 退出，直接 break，不再校验是否在 SyncQueue</span><br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// enq 完就进入 CLH 的 park了，savedState 保证归还的锁的累积数量仍然不变。当然，此处也不一定会触发 park，如果此时锁被完全 release 的话，可以直接求锁成功</span><br>            <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)       <br>                <span class="hljs-comment">// 这里要理解一个两次中断的事实：acquireQueued 中返回true，也意味着发生了中断，但这种中断必然发生在 signal 之后，如果前面发生过一次 wait 的中断，则此处就不重设中断位，否则此处要设置模式</span><br>                interruptMode = REINTERRUPT;<br>            <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>                unlinkCancelledWaiters();<br>            <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// 抛出异常或者自置中断位，也就是说，如果发生过基于 park 的中断，内部没有做过中断重设，此处需要做，这和 acquire 内部还要调用一次 selfInterrupt 是异曲同工的。park 和 interrupt 的关系就是这么复杂</span><br>                reportInterruptAfterWait(interruptMode);<br>        &#125;<br></code></pre></td></tr></table></figure>
<h6 id="addconditionwaiter">addConditionWaiter</h6>
<p>这个方法的主要逻辑就是让本线程产生一个代表节点，然后入队：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;<br>       <span class="hljs-comment">// 在需要检查状态时，链表的 cancelled 节点总要被清掉</span><br>       <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>       <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>           unlinkCancelledWaiters();<br>           t = lastWaiter;<br>       &#125;<br>       <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br>       <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>           firstWaiter = node;<br>       <span class="hljs-keyword">else</span><br>           t.nextWaiter = node;<br>       lastWaiter = node;<br>       <span class="hljs-keyword">return</span> node;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h6 id="fullyrelease">fullyRelease</h6>
<p>这个方法依赖于 release 的实现，也会返回 savedState。但如果 release 失败太复杂了，作者在这里选择了直接抛出异常，令人意外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (release(savedState)) &#123;<br>            failed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> savedState;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            node.waitStatus = Node.CANCELLED;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="unlinkcancelledwaiters">unlinkCancelledWaiters</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlinkCancelledWaiters</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">trail</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> t.nextWaiter;<br>        <span class="hljs-comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span><br>        <span class="hljs-keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;<br>            t.nextWaiter = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (trail == <span class="hljs-literal">null</span>)<br>                firstWaiter = next;<br>            <span class="hljs-keyword">else</span><br>                trail.nextWaiter = next;<br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>                lastWaiter = trail;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            trail = t;<br>        t = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="isonsyncqueue">isOnSyncQueue</h6>
<p>检查这个 node 是否已经在 sync queue 里了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOnSyncQueue</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>) <span class="hljs-comment">// If has successor, it must be on queue</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * node.prev can be non-null, but not yet on queue because</span><br><span class="hljs-comment">     * the CAS to place it on queue can fail. So we have to</span><br><span class="hljs-comment">     * traverse from tail to make sure it actually made it.  It</span><br><span class="hljs-comment">     * will always be near the tail in calls to this method, and</span><br><span class="hljs-comment">     * unless the CAS failed (which is unlikely), it will be</span><br><span class="hljs-comment">     * there, so we hardly ever traverse much.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> findNodeFromTail(node);<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="isonsyncqueue">isOnSyncQueue</h6>
<p>如果中断，则做 queue transfer，如果不中断则返回 0，这里使用了内部类能够引用外部方法的闭包性质，可以用 enq 方法自动找到尾部。</p>
<p>这个方法的动词使用了现在进行时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">// 不发生中断返回 0 最好，如果发生中断则要自己做 enq，而且根据 transfer 的结果告知外部是该抛出异常，还是自己重新设置中断位</span><br>        <span class="hljs-keyword">return</span> Thread.interrupted() ?<br>            (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :<br>            <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h6 id="transferaftercancelledwait">transferAfterCancelledWait</h6>
<p>这个方法是 await 内部的 transfer 方法之一（另一个在 signal 里）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法是给中断 CancelledWait 用的</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferAfterCancelledWait</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-comment">// 如果改变 ws成功，则应该抛出中断异常</span><br>        <span class="hljs-keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>)) &#123;<br>            enq(node);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 上面失败就意味着发生了一个 race condition，如果是 signal 赢了，则实际上不应该抛出异常</span><br><span class="hljs-comment">         * If we lost out to a signal(), then we can&#x27;t proceed</span><br><span class="hljs-comment">         * until it finishes its enq().  Cancelling during an</span><br><span class="hljs-comment">         * incomplete transfer is both rare and transient, so just</span><br><span class="hljs-comment">         * spin.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node))<br>            Thread.<span class="hljs-keyword">yield</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h6 id="reportinterruptafterwait">reportInterruptAfterWait</h6>
<p>使用一个常量作为 flag，就完成了从中断-flag-重新还原中断的全流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-type">int</span> interruptMode)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)<br>            selfInterrupt();<br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="signal">signal</h5>
<ol>
<li>检查 isHeldExclusively。</li>
<li>选一个非空的 firstWaiter，进行 signal。因为 ConditionObject 本身是跨多线程共享的，所以这会随机选取第一个 node 进行信号唤醒，把它从 CONDITION 置为 0，如果失败则返回 false。与之相对的，signalAll 是用 firstWaiter 开始，按顺序唤醒整个链表。<strong>AQS 的随机性在于不知道链表的顺序是怎样的，但对于 FIFO 的出队是不随机的</strong>。</li>
<li>enq node。</li>
<li>把前驱 cas 设置成 SIGNAL 失败或者前驱节点已经取消，尝试直接 unpark 这个 node。然后就让 await 方法的 isOnSyncQueue 走剩下的流程。</li>
<li>返回操作为 true。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注意看这个方法，只要 isHeldExclusively 不正常，则这个方法会抛出 IllegalMonitorStateException</span><br><span class="hljs-comment"> * Moves the longest-waiting thread, if one exists, from the</span><br><span class="hljs-comment"> * wait queue for this condition to the wait queue for the</span><br><span class="hljs-comment"> * owning lock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="hljs-doctag">@link</span> #isHeldExclusively&#125;</span><br><span class="hljs-comment"> *         returns &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 检查是不是在锁的控制范围内</span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-comment">// 只取非空 first 作为 doSignal 对象</span><br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>        doSignal(first);<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="dosignal">doSignal</h6>
<p>只有 signal 一个非零和非 cancelled 的 node 成功才会从循环中停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * Removes and transfers nodes until hit non-cancelled one or</span><br><span class="hljs-comment">         * null. Split out from signal in part to encourage compilers</span><br><span class="hljs-comment">         * to inline the case of no waiters.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> first (non-null) the first node on condition queue</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 首先用 frist.next 来顶掉 firstwaiter，如果 first.next 为空，则清空本队列</span><br>                <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>                    lastWaiter = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// unlink first 到 next waiter 的联系</span><br>                first.nextWaiter = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 如果 transferForSignal 成功，循环中止，否则必定是 node 被 cancelled 了，这时候要把 firstWaiter 赋值回 first，看看是不是还能找到 non-null 继续循环</span><br>            &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>                     (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>        &#125;<br>```    <br><br>###### transferForSignal<br><br>这个方法的主要目的是为了完成往 sync queue 的转移只要求 cas node 的状态为 <span class="hljs-number">0</span> 和对它进行 enq 只有在极端情况下才会做立即 unpark：AQS 有个设计，在 cancel 一个 node 以后，或者 一个 node 不正常了以后，会立刻 unpark 它的  successor 如果这个 unpark 没有被执行，unlock 的时候还会带有一个 unpark 来刺激 lock。<br><br>```java   <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br>    <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * If cannot change waitStatus, the node has been cancelled.</span><br><span class="hljs-comment">         * 假定，condition queue中的节点一定是 CONDITION，不会再变</span><br><span class="hljs-comment">         * 这是本方法第一次试图 cas 改变一个 node，其实此时如果失败，意味着本节点是 cancelled 的，应该返回 false</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="hljs-comment">         * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="hljs-comment">         * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="hljs-comment">         * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>        <span class="hljs-comment">// 如果前驱节点已取消，本 node 应该直接 unpark；或者前驱节点不能设置为 SIGNAL-此处不需要等到下轮循环再设置了，要把本 node 做一个 unpark，交给 await中的循环处理。</span><br>        <span class="hljs-comment">// 什么情况下 compareAndSetWaitStatus 会失败呢？p 是前驱节点的意思，p 被人动过，这也就意味着此处的 cas已经无意义了</span><br>        <span class="hljs-comment">// 这是第二个地方用 cas 检查 node 的前驱，如果失败，通过 unpark 让 acquiredQueued 来试图收窄链表</span><br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>            <span class="hljs-comment">// 注意，node.thread 已经在await 的循环里 park了，此处的 enq 帮那个循环省略了从中断中 enq 的动作，它会在 await 方法里进入 acquireQueued，再尝试求锁解锁，这种直接唤醒重新入队的方法，被作者称作 resync。</span><br>            LockSupport.unpark(node.thread);<br>        <span class="hljs-comment">// 但如果不 unpark，直接返回，则对于 node.thread 的 unpark 需要等到 unlock 底层的 release</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>关于 signal + unlock 带来的获锁，可以参考这个实验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConditionProcedure</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br><br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>        <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">controlFlag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            System.out.println(<span class="hljs-string">&quot;内线程先求锁&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (!controlFlag.get()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;check input failed, begin to await，准备释放锁&quot;</span>);<br>                        <span class="hljs-comment">// 在这一行里，内线程 fullyRelease 了 lock</span><br>                        condition.await();<br>                        <span class="hljs-comment">// 在这一行里，内线程重新拿回了 lock</span><br>                        System.out.println(<span class="hljs-string">&quot;signaled, begin to check input，重新得回锁&quot;</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>                System.out.println(<span class="hljs-string">&quot;isInterrupted: &quot;</span> + Thread.currentThread().isInterrupted());<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;);<br>        t1.setName(<span class="hljs-string">&quot;test-thread1&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">// 造成一种内线程先拿到锁，但释放后进入 wait queue 的情况</span><br>        Thread.sleep(<span class="hljs-number">1000L</span>);<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 在 idea 里暂时无法使用 prompt input，所以现阶段就用倒数计时来触发锁定</span><br><span class="hljs-comment">//            Scanner command = new Scanner(System.in);</span><br><span class="hljs-comment">//            System.out.println(&quot;Enter command: &quot;);</span><br><span class="hljs-comment">//            boolean running = true;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//            while(running)&#123;</span><br><span class="hljs-comment">//                switch(command.nextLine())&#123;</span><br><span class="hljs-comment">//                    case &quot;signal&quot;:</span><br><span class="hljs-comment">//                        System.out.println(&quot;Machine started!&quot;);</span><br><span class="hljs-comment">//                        running = false;</span><br><span class="hljs-comment">//                        break;</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//            command.close();</span><br><br>            controlFlag.set(<span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">// 这里会让内线程准备求锁</span><br>            System.out.println(<span class="hljs-string">&quot;让内线程准备求锁&quot;</span>);<br>            <span class="hljs-comment">// 要在锁里面执行 signal，其内部针对极端情况会触发 unpark，但那个unpark 只能触发 resync 入队用，如果本线程没有释放锁，则内线程求不到锁，会进入第二次 park</span><br>            condition.signal();<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 在这行彻底执行完的一瞬间，内线程求锁完，才能从 await 中退出，这会导致 unpark，await 内部至少会有一次 unpark 醒来，到时候无人争抢锁的话，会直接重新回到获锁（acquired）状态</span><br>            System.out.println(<span class="hljs-string">&quot;释放本线程的锁，下一瞬间内线程就会求到锁&quot;</span>);<br>            lock.unlock();<br>        &#125;<br><br>        Thread.sleep(<span class="hljs-number">15000L</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="aqs-与中断">AQS 与中断</h3>
<h4 id="两种中断模式">两种中断模式</h4>
<p>在 AQS 内部，把这两种中断模式归类为：</p>
<ul>
<li>REINTERRUPT：Mode meaning to reinterrupt on exit from wait，模式保留中断状态，让上层代码能感知到中断的发生：
<ul>
<li>这样做的好处是：
<ul>
<li>保持中断状态的完整性</li>
<li>允许上层代码检测到中断并作出相应处理</li>
<li>符合Java的中断机制设计理念：中断是一种协作机制，应该传播给调用链</li>
</ul>
</li>
<li>如果不恢复中断状态：
<ul>
<li>上层代码将无法感知到中断发生</li>
<li>可能会影响依赖中断状态的取消操作</li>
<li>违反了线程中断的传播机制</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 等待操作</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// 重新设置中断标志</span><br>    Thread.currentThread().interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>THROW_IE：Mode meaning to throw InterruptedException on exit from wait，通过异常直接通知上层代码中断的发生</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例处理方式</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 等待操作</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// 直接抛出异常</span><br>    <span class="hljs-keyword">throw</span> e;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="检测中断的标准方法">检测中断的标准方法</h4>
<p><strong>在阻塞方法里 catch InterruptedException/ClosedByInterruptException 和非阻塞流程轮询检查线程的中断状态</strong>是响应中断的方法：</p>
<ul>
<li>能检测到中断就是发生过中断</li>
<li>而不能检测到中断可能意味着中断位被重置了，用异常表达了中断-所以捕获了异常就需要重新中断。</li>
</ul>
<h4 id="非锁的计时waiting方法">非锁的计时waiting方法。</h4>
<p>Java 自带的内置长时间停顿方法有以下：</p>
<ul>
<li>Object：wait()、wait(long)、wait(long, int)，被中断的时候会抛出 <strong>InterruptedException</strong>，而且会<strong>清空</strong>中断位</li>
<li>Thread：join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)，被中断的时候会抛出 <strong>InterruptedException</strong>，而且会<strong>清空</strong>中断位</li>
<li>实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等，被中断的时候会抛出 <strong>ClosedByInterruptException</strong>，而且会<strong>设置</strong>中断位</li>
<li>Selector 中的 select 方法，被中断的时候会<strong>立即返回</strong>，而且会<strong>设置</strong>中断位</li>
</ul>
<h4 id="locksupport-park-的行为">LockSupport.park 的行为</h4>
<p>LockSupport.park 会响应中断-<strong>醒来</strong>，但通常会被java类库作者的自旋重新带进下一个 LockSupport.park ，但<strong>不会重置中断状态</strong>（对线程进行中断检查会得到  true，线程被 interrupt()的结果<strong>完全不会被 LockSupport.park 影响</strong>）。</p>
<h4 id="lock-与中断">lock 与中断</h4>
<p>AQS 在设计的时候，会设计普通 lock，lockInterruptibly() 的版本。在条件上，会设计 await 和 awaitUninterruptibly()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.lock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>普通 lock 是不会响应中断的阻塞操作的-对卡在 lock 上的线程进行 interrupt，在线程内部什么都不会发生。</p>
<p>在下面的实验里，我们从主线程，不断地中断另一个线程，另一个线程没有抛出异常，只有求到锁才从中断中返回，而且重置（reset，而不是 clear）了中断位，<strong>仿佛只有最后退出线程的那一刻，线程才被中断了</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个实验的问题是，无法复现求锁的子线程从被中断状态下退出的场景</span><br><span class="hljs-comment"> * 是不是只有从 os 层面干预线程，才能触发这一点？</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException 中断异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLockProcedure</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch1.await();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            System.out.println(<span class="hljs-string">&quot;isInterrupted: &quot;</span> + Thread.currentThread().isInterrupted());<br>        &#125;<br><br>        <span class="hljs-comment">// 用 while 而不是 sleep，这样就不怕 interrupt 被阻塞 api 抛出异常来响应了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            j += i;<br>        &#125;<br>        <span class="hljs-comment">// 返回累加结果，这样不会被死代码优化：704982704</span><br>        System.out.println(j);<br>        <span class="hljs-comment">// 在lock 内部可能检测不到这个中断，需要外部频繁中断为好</span><br>        Thread.currentThread().interrupt();<br><br>        <span class="hljs-comment">// 让系统在这个地方卡住，然后用 debugger 观察本线程的状态</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(String.format(<span class="hljs-string">&quot;from inside Thread.currentThread().getState(): %s, Thread&quot;</span><br>                            + <span class="hljs-string">&quot;.currentThread().isInterrupted(): %s&quot;</span>,<br>                    Thread.currentThread().getState(), Thread.currentThread().isInterrupted()));<br>            System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;test-thread1&quot;</span>);<br>    t1.start();<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>        countDownLatch1.countDown();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 休眠一段时间，让t1开始求锁，然后再解锁</span><br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>        &#125;<br>        <span class="hljs-comment">// 中断一千次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-comment">// 在这里频繁中断，如果t1内部这时候还在 sleep 就会抛出异常，所以t1内部只能循环</span><br>            t1.interrupt();<br>            StackTraceElement[] stackTrace = t1.getStackTrace();<br>            <span class="hljs-comment">// 只输出前两行堆栈信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">stackInfo</span> <span class="hljs-operator">=</span> stackTrace.length &gt;= <span class="hljs-number">2</span><br>                    ? stackTrace[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;\n&quot;</span> + stackTrace[<span class="hljs-number">1</span>]<br>                    : stackTrace.length == <span class="hljs-number">1</span> ? stackTrace[<span class="hljs-number">0</span>].toString() : <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-comment">// 我们不断检验线程状态，会得到结论：lock 内部是基于 park 的，中断不会清除让 lock 退出，中断可能会短暂让线程进入中断状态（只能在锁的外部短暂观察到），但是 lock</span><br>            <span class="hljs-comment">// 的自旋模式会让锁回到未中断状态-只有从锁里出来，才能在本线程内部看到正确的中断状态</span><br>            System.out.println(String.format(<span class="hljs-string">&quot;t1.getState(): %s, t1.isInterrupted(): %s, stackInfo: %s&quot;</span>,<br>                    t1.getState(), t1.isInterrupted(), stackInfo));<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">10000L</span>);<br>        lock.unlock();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="hljs-comment">         *         boolean failed = true;</span><br><span class="hljs-comment">         *         try &#123;</span><br><span class="hljs-comment">         *             boolean interrupted = false;</span><br><span class="hljs-comment">         *             for (;;) &#123;</span><br><span class="hljs-comment">         *                 final Node p = node.predecessor();</span><br><span class="hljs-comment">         *                 if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="hljs-comment">         *                     setHead(node);</span><br><span class="hljs-comment">         *                     p.next = null; // help GC</span><br><span class="hljs-comment">         *                     failed = false;</span><br><span class="hljs-comment">         *                     // 不管是否中断，都从这里 return</span><br><span class="hljs-comment">         *                     return interrupted;</span><br><span class="hljs-comment">         *                 &#125;</span><br><span class="hljs-comment">         *                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="hljs-comment">         *                     parkAndCheckInterrupt())</span><br><span class="hljs-comment">         *                      // 如果中断则跑到这，不然得到锁就保持 interrupted = false，然后从上面 return</span><br><span class="hljs-comment">         *                     interrupted = true;</span><br><span class="hljs-comment">         *             &#125;</span><br><span class="hljs-comment">         *         &#125; finally &#123;</span><br><span class="hljs-comment">         *             if (failed)</span><br><span class="hljs-comment">         *                 cancelAcquire(node);</span><br><span class="hljs-comment">         *         &#125;</span><br><span class="hljs-comment">         *     &#125;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *     public final void acquire(int arg) &#123;</span><br><span class="hljs-comment">         *         if (!tryAcquire(arg) &amp;&amp;</span><br><span class="hljs-comment">         *             acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="hljs-comment">         *             // 如果 acquireQueued 方法返回true，断点到这一行</span><br><span class="hljs-comment">         *             // 如果 while interrupt 循环足够多，是可以从这一步跑出去的</span><br><span class="hljs-comment">         *             selfInterrupt();</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *             // 否则断点到这一行即不做 selfInterrupt</span><br><span class="hljs-comment">         *     &#125;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *    private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="hljs-comment">         *         LockSupport.park(this);</span><br><span class="hljs-comment">         *         // 这是一个清理线程状态的 testMethod()</span><br><span class="hljs-comment">         *         return Thread.interrupted();</span><br><span class="hljs-comment">         *     &#125;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>    t1.join();<br>    Thread.sleep(<span class="hljs-number">10000L</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们不断检验线程状态，会得到结论：lock 内部是基于 park 的，中断不会清除让 lock 退出，中断可能会短暂让线程进入中断状态（只能在锁的外部短暂观察到），但是 lock  的自旋模式会让锁回到未中断状态-只有从锁里出来，才能在本线程内部看到正确的中断状态</p>
<p>这是 park 隐晦地把响应中断的职责外放给使用者的一种设计。如果我们真的关心线程在跑到外部的时候是否还是从中断路径中出现，我们可以使用 lockInterruptibly + 检查异常，或者使用普通 lock + 检查中断位。</p>
<p>从总体来讲，lock 作为一个外部操作是不用抛出中断异常的方式来退出的，从lock 中正常退出往下走是用户可以接受的结果。中断位被隐藏得比较隐晦。</p>
<p>await 操作如果遇到异常，到底退出还是不退出呢？如果像 park 一样退出，则用户必须写类似 aqs 之类的代码才能检查中断位，而且有时候中断的真实目的并不是让一个线程苏醒，而是真的把后续的流程阻断掉（如果不中断掉，因为自旋的存在，线程只会再一次进入 park 的状态），从这个视角来看，抛出异常学 sleep 和 wait更合理。</p>
<h4 id="内部方法">内部方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 最底层的方法</span><br><span class="hljs-comment"> * Tests if some Thread has been interrupted.  The interrupted state</span><br><span class="hljs-comment"> * is reset or not based on the value of ClearInterrupted that is</span><br><span class="hljs-comment"> * passed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterrupted</span><span class="hljs-params">(<span class="hljs-type">boolean</span> ClearInterrupted)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安全方法-纯粹的读方法：不 clear 中断位的检查</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterrupted</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> isInterrupted(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 危险方法-不纯粹的读方法：名为中断，其实是 clear 中断位的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interrupted</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> currentThread().isInterrupted(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Interrupts this thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; Unless the current thread is interrupting itself, which is</span><br><span class="hljs-comment"> * always permitted, the &#123;<span class="hljs-doctag">@link</span> #checkAccess() checkAccess&#125; method</span><br><span class="hljs-comment"> * of this thread is invoked, which may cause a &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * SecurityException&#125; to be thrown.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If this thread is blocked in an invocation of the &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * Object#wait() wait()&#125;, &#123;<span class="hljs-doctag">@link</span> Object#wait(long) wait(long)&#125;, or &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;<span class="hljs-doctag">@link</span> Object&#125;</span><br><span class="hljs-comment"> * class, or of the &#123;<span class="hljs-doctag">@link</span> #join()&#125;, &#123;<span class="hljs-doctag">@link</span> #join(long)&#125;, &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * #join(long, int)&#125;, &#123;<span class="hljs-doctag">@link</span> #sleep(long)&#125;, or &#123;<span class="hljs-doctag">@link</span> #sleep(long, int)&#125;,</span><br><span class="hljs-comment"> * methods of this class, then its interrupt status will be cleared and it</span><br><span class="hljs-comment"> * will receive an &#123;<span class="hljs-doctag">@link</span> InterruptedException&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span><br><span class="hljs-comment"> * then the channel will be closed, the thread&#x27;s interrupt</span><br><span class="hljs-comment"> * status will be set, and the thread will receive a &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * java.nio.channels.ClosedByInterruptException&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If this thread is blocked in a &#123;<span class="hljs-doctag">@link</span> java.nio.channels.Selector&#125;</span><br><span class="hljs-comment"> * then the thread&#x27;s interrupt status will be set and it will return</span><br><span class="hljs-comment"> * immediately from the selection operation, possibly with a non-zero</span><br><span class="hljs-comment"> * value, just as if the selector&#x27;s &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If none of the previous conditions hold then this thread&#x27;s interrupt</span><br><span class="hljs-comment"> * status will be set. &lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  SecurityException</span><br><span class="hljs-comment"> *          if the current thread cannot modify this thread</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@revised</span> 6.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@spec</span> JSR-51</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> != Thread.currentThread())<br>        <span class="hljs-comment">// 只允许中断自己，否则抛出异常</span><br>        checkAccess();<br><br>    <span class="hljs-keyword">synchronized</span> (blockerLock) &#123;<br>        <span class="hljs-type">Interruptible</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> blocker;<br>        <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Just to set the interrupt flag</span><br>            interrupt0();           <br>            <span class="hljs-comment">// 当前线程阻塞或者非阻塞</span><br>            b.interrupt(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    interrupt0();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="countdownlatch">CountDownLatch</h2>
<p><img src="countDownLatch.png" alt="countDownLatch"></p>
<p>CountDownLatch 是一个 one-shot phenomenon，它的 state 是不能被复用的。</p>
<p>这个类的功能底层依赖于自身的 sync 的两个实现：</p>
<ul>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
</ul>
<p>其他都是框架编织的结果。这两个方法告诉我们，try 方法不需要考虑 interruptibly/uninterruptibly。</p>
<p>在大型项目里，测试异步用例的时候经常使用如下模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testScheduleTimeoutShouldNotRunBeforeDelay</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashedWheelTimer</span>();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Timeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> timer.newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            fail(<span class="hljs-string">&quot;This should not have run&quot;</span>);<br>            barrier.countDown();<br>        &#125;<br>    &#125;, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    assertFalse(barrier.await(<span class="hljs-number">3</span>, TimeUnit.SECONDS));<br>    assertFalse(timeout.isExpired(), <span class="hljs-string">&quot;timer should not expire&quot;</span>);<br>    timer.stop();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="初始化">初始化</h3>
<p>自身构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>       <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br>       <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>同步构造器只依赖于 setState：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Sync(<span class="hljs-type">int</span> count) &#123;<br>        <span class="hljs-comment">// 这样就 state == count 了</span><br>        setState(count);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>sync 在共享模式和互斥模式下有很重大的区别，就是 state 在互斥模式下维护的是同一个线程求锁的次数，在共享模式下维护的是共有多少个线程持有这把锁。</p>
<h3 id="await">await</h3>
<p>在 CountDownLatch 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的隐式逻辑是：sync 内部的 state 为0则此方法可以返回，阻塞发生在改为0之前。普通的 acquire 是修改 state 成功返回，阻塞发生在获取修改 state 的权限之前，这里产生了比较大的语义差别。</p>
<h4 id="acquiresharedinterruptibly">acquireSharedInterruptibly</h4>
<p>在 AQS 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Acquires in shared mode, aborting if interrupted.  Implemented</span><br><span class="hljs-comment"> * by first checking interrupt status, then invoking at least once</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #tryAcquireShared&#125;, returning on success.  Otherwise the</span><br><span class="hljs-comment"> * thread is queued, possibly repeatedly blocking and unblocking,</span><br><span class="hljs-comment"> * invoking &#123;<span class="hljs-doctag">@link</span> #tryAcquireShared&#125; until success or the thread</span><br><span class="hljs-comment"> * is interrupted.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arg the acquire argument.</span><br><span class="hljs-comment"> * This value is conveyed to &#123;<span class="hljs-doctag">@link</span> #tryAcquireShared&#125; but is</span><br><span class="hljs-comment"> * otherwise uninterpreted and can represent anything</span><br><span class="hljs-comment"> * you like.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException if the current thread is interrupted</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <br>    <span class="hljs-comment">// 这里小于0意味着 state 还是保持在 sync 的 state 非0的状态，才可以进入 doAcquireSharedInterruptibly 阻塞；否则就是已经被扣减到头了，就直接返回了，这会导致上层的 await 直接返回，这就是很多的事后 await 会直接返回的原理。这种</span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireSharedInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="CountDownLatch%E5%85%A5%E9%98%9F1.png" alt="CountDownLatch入队1"></p>
<p>在互斥类的 acquire 里面，只有 state 不为0（已被其他线程获取锁）会导致入队。在共享类的 acquire 里，只要 state 不为 0，也入队，反复自旋，直到 state 为 0 才导致出队，让 await 降为0。</p>
<p><img src="CountDownLatch%E5%85%A5%E9%98%9F2.png" alt="CountDownLatch入队2"><br>
<img src="CountDownLatch%E5%85%A5%E9%98%9F3.png" alt="CountDownLatch入队3"></p>
<h4 id="tryacquireshared">tryAcquireShared</h4>
<p>在自定义 sync 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-comment">// 在 CountDownLatch 的sync 里 acquires 是无用的，但在其他 sync 里就可以有用</span><br>    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只有当 state == 0 的时候，这个方法才会返回 1，否则返回-1。这和普通的 tryAcquire 返回 boolean 有很大差别。</p>
<p><code>acquireSharedInterruptibly(arg)</code> -&gt; <code>tryAcquireShared(arg) 只做判断</code> -&gt; <code>doAcquireSharedInterruptibly(arg) 产生阻塞</code>，AQS 的框架隐藏在<code>doAcquireSharedInterruptibly</code>里：</p>
<h4 id="doacquiresharedinterruptibly">doAcquireSharedInterruptibly</h4>
<p>这个方法很像 acquireQueued，出队的条件是 state 变为 0，而不是得到了修改 state 的机会</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 共享模式也入队，这里让每个入队的节点都带有同一个 nextWaiter</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 入队也要自旋</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 只有快要出队的节点可以这样做</span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-comment">// tryAcquireShared &gt; 0 意味着此时 aqs 没动过，或者被还原了，此时就可以考虑出队，最终让上层的 await 返回了</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 只要共享状态降为0即可以出队</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// 然后返回，让更上层返回</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-comment">// 这个方法是 interruptibly 的版本，所以遇到中断应该抛出中断异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="setheadandpropagate">setHeadAndPropagate</h4>
<p>这个方法 propagate 是很难理解的，doShare 是它试图 propagate 的东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// Record old head for check below</span><br>    setHead(node);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Try to signal next queued node if:</span><br><span class="hljs-comment">     *   Propagation was indicated by caller,</span><br><span class="hljs-comment">     *     or was recorded (as h.waitStatus either before</span><br><span class="hljs-comment">     *     or after setHead) by a previous operation</span><br><span class="hljs-comment">     *     (note: this uses sign-check of waitStatus because</span><br><span class="hljs-comment">     *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="hljs-comment">     * and</span><br><span class="hljs-comment">     *   The next node is waiting in shared mode,</span><br><span class="hljs-comment">     *     or we don&#x27;t know, because it appears null</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The conservatism in both of these checks may cause</span><br><span class="hljs-comment">     * unnecessary wake-ups, but only when there are multiple</span><br><span class="hljs-comment">     * racing acquires/releases, so most need signals now or soon</span><br><span class="hljs-comment">     * anyway.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-comment">// shared mode 的模式在此处生效产生了一个和普通的 setHead 不同的效应，它会产生一个 doReleaseShared</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())<br>            doReleaseShared();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="doreleaseshared">doReleaseShared</h4>
<p>这个方法特别难，普通 tryRelease 是改动 aqs 的自身状态，但 doReleaseShared 依赖于 tryReleaseShared 的返回结果，只专心处理从 head 开始的 ws 问题，然后对 head 的后继进行 unpark。这个节点会让所有卡在 countDownLatch 的计时条件上的线程都越过门槛本身。因为 tryReleaseShared 已经把 state 扣减为0，此处做的主要是 unpark + 改 ws，doAcquireSharedInterruptibly 那里就会自己直接返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Ensure that a release propagates, even if there are other</span><br><span class="hljs-comment">     * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="hljs-comment">     * way of trying to unparkSuccessor of head if it needs</span><br><span class="hljs-comment">     * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="hljs-comment">     * ensure that upon release, propagation continues.</span><br><span class="hljs-comment">     * Additionally, we must loop in case a new node is added</span><br><span class="hljs-comment">     * while we are doing this. Also, unlike other uses of</span><br><span class="hljs-comment">     * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="hljs-comment">     * fails, if so rechecking.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 1. h == null: 说明阻塞队列为空</span><br>        <span class="hljs-comment">// 2. h == tail: 说明头节点可能是刚刚初始化的头节点，</span><br>        <span class="hljs-comment">// 或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了</span><br>        <span class="hljs-comment">// 所以这两种情况不需要进行唤醒后继节点</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-comment">// head 如果能够被从 SIGNAL 设为 0，则 unpark head 的下一个节点，否则循环 recheck</span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>               <span class="hljs-comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-comment">// head 如果已经是 0，则把它设置为 PROPAGATE</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="countdown">countDown</h3>
<p><img src="CountDownLatch%E9%87%8A%E6%94%BE.png" alt="CountDownLatch释放"></p>
<p><code>countDown()</code> -&gt; releaseShared(1) -&gt; tryRleaseShare(1) -&gt; doReleaseShare();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 每次 countDown 都等于一次共享释放1</span><br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="releaseshared">releaseShared</h4>
<p>这里在完全退出的分支里，再次主动调用了 doReleaseShared</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 如果已经 state 为0，则直接返回；如果扣减不到0，也直接返回；如果扣减到0了，则执行 doReleaseShared</span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="tryreleaseshared">tryReleaseShared</h4>
<p>这个方法的返回值很有意思：true 意味着允许一个 acquire（不管是共享式还是互斥式的）得到一个 permit-是否要进入一个最终退出动作，这个动作只执行一次。否则，返回 false可能含有2个含义，已被扣减完，应该进入退出后状态；或者意味着先扣减得到中间态的 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>      <span class="hljs-comment">// Decrement count; signal when transition to zero</span><br>      <span class="hljs-comment">// 在 try release 系列里，这是唯一一个有自旋的</span><br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>          <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          <span class="hljs-comment">// 这里直接做了减1，而不是减 releases</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>              <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<h2 id="cyclicbarrier">CyclicBarrier</h2>
<p>cyclic 既有周期的意思，也有循环的意思。</p>
<p><img src="cyclicbarrier-1.png" alt="cyclicbarrier-1"><br>
<img src="cyclicbarrier-2.png" alt="cyclicbarrier-2"></p>
<blockquote>
<p>CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS<br>
的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p>
</blockquote>
<p>这个类是一个很简单的交替地使用一个内置了 Lock 和 Condition 来维护一个 barrier waiting count 的实现。</p>
<h3 id="和countdownlatch-的区别">和CountDownLatch 的区别</h3>
<ol>
<li>CyclicBarrier 使用互斥而不是共享机制来实现多线程协同，共享状态是由 party 生成的 count。CyclicBarrier 依托 Condition。</li>
<li>而 CountDownLatch 通过共享而不是互斥来实现多线程协同，共享状态是 AQS 的 state。而 CountDownLatch 有自己的 sync。</li>
<li>CyclicBarrier 只需要每个内线程做完自己的事自动<strong>await</strong>，不需要 signal，到齐了自动就通过；CountDownLatch 让内线程<strong>countDown</strong>。CyclicBarrier 外线程等待这个到齐结果 join 所有内线程； CountDownLatch 对 latch 进行 <strong>await</strong>。</li>
</ol>
<h3 id="作者的官方示例">作者的官方示例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solver</span> &#123;<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N;<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">float</span>[][] data;<br>   <span class="hljs-keyword">final</span> CyclicBarrier barrier;<br><br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>     <span class="hljs-type">int</span> myRow;<br>     Worker(<span class="hljs-type">int</span> row) &#123; myRow = row; &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">while</span> (!done()) &#123;<br>         processRow(myRow);<br><br>         <span class="hljs-keyword">try</span> &#123;<br>           barrier.await();<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>           <span class="hljs-keyword">return</span>;<br>         &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException ex) &#123;<br>           <span class="hljs-keyword">return</span>;<br>         &#125;<br>       &#125;<br>     &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solver</span><span class="hljs-params">(<span class="hljs-type">float</span>[][] matrix)</span> &#123;<br>     data = matrix;<br>     N = matrix.length;<br>     <span class="hljs-type">Runnable</span> <span class="hljs-variable">barrierAction</span> <span class="hljs-operator">=</span><br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; mergeRows(...); &#125;&#125;;<br>     barrier = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(N, barrierAction);<br><br>     List&lt;Thread&gt; threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Thread&gt;(N);<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(i));<br>       threads.add(thread);<br>       thread.start();<br>     &#125;<br><br>     <span class="hljs-comment">// wait until done</span><br>     <span class="hljs-keyword">for</span> (Thread thread : threads)<br>       thread.join();<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>在 Spring 里拿他来做测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pubSubLostConnectionTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>);<br>    channel.subscribe(message -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            latch.await(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">this</span>.channel.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericMessage</span>&lt;&gt;(<span class="hljs-string">&quot;foo&quot;</span>));<br>    latch.await(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    latch.reset();<br>    <span class="hljs-type">BlockingQueueConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> (BlockingQueueConsumer) TestUtils.getPropertyValue(<span class="hljs-built_in">this</span>.channel,<br>            <span class="hljs-string">&quot;container.consumers&quot;</span>, Set.class).iterator().next();<br>    connectionFactory.destroy();<br>    waitForNewConsumer(<span class="hljs-built_in">this</span>.channel, consumer);<br>    <span class="hljs-built_in">this</span>.channel.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericMessage</span>&lt;&gt;(<span class="hljs-string">&quot;bar&quot;</span>));<br>    latch.await(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    <span class="hljs-built_in">this</span>.channel.destroy();<br>    <span class="hljs-built_in">this</span>.pubSubWithEP.destroy();<br>    <span class="hljs-built_in">this</span>.withEP.destroy();<br>    <span class="hljs-built_in">this</span>.pollableWithEP.destroy();<br>    assertThat(TestUtils.getPropertyValue(connectionFactory, <span class="hljs-string">&quot;connectionListener.delegates&quot;</span>, Collection.class)<br>            .size()).isEqualTo(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有些地方还会有工具方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitAtBarrier</span><span class="hljs-params">(String barrierName, Map&lt;String, CyclicBarrier&gt; barriers)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        barriers.get(barrierName).await(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(<span class="hljs-string">&quot;Test didn&#x27;t complete: &quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="成员拆解">成员拆解</h3>
<p>首先，非 generation 的部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/** The lock for guarding barrier entry */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-comment">// 触动开关</span><br><span class="hljs-comment">/** Condition to wait on until tripped */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br><span class="hljs-comment">/** The number of parties */</span><br><span class="hljs-comment">// 这个数字不可扣减</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> parties;<br><br><span class="hljs-comment">/* The command to run when tripped */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable barrierCommand;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个数字可以扣减</span><br><span class="hljs-comment"> * Number of parties still waiting. Counts down from parties to 0</span><br><span class="hljs-comment"> * on each generation.  It is reset to parties on each new</span><br><span class="hljs-comment"> * generation or when broken.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br></code></pre></td></tr></table></figure>
<p>其次，generation 的部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Each use of the barrier is represented as a generation instance.</span><br><span class="hljs-comment">   * The generation changes whenever the barrier is tripped, or</span><br><span class="hljs-comment">   * is reset. There can be many generations associated with threads</span><br><span class="hljs-comment">   * using the barrier - due to the non-deterministic way the lock</span><br><span class="hljs-comment">   * may be allocated to waiting threads - but only one of these</span><br><span class="hljs-comment">   * can be active at a time (the one to which &#123;<span class="hljs-doctag">@code</span> count&#125; applies)</span><br><span class="hljs-comment">   * and all the rest are either broken or tripped.</span><br><span class="hljs-comment">   * There need not be an active generation if there has been a break</span><br><span class="hljs-comment">   * but no subsequent reset.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generation</span> &#123;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">broken</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <br>    <span class="hljs-comment">/** The current generation */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">generation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();<br></code></pre></td></tr></table></figure>
<h3 id="构造器">构造器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a new &#123;<span class="hljs-doctag">@code</span> CyclicBarrier&#125; that will trip when the</span><br><span class="hljs-comment"> * given number of parties (threads) are waiting upon it, and which</span><br><span class="hljs-comment"> * will execute the given barrier action when the barrier is tripped,</span><br><span class="hljs-comment"> * performed by the last thread entering the barrier.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> parties the number of threads that must invoke &#123;<span class="hljs-doctag">@link</span> #await&#125;</span><br><span class="hljs-comment"> *        before the barrier is tripped</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> barrierAction the command to execute when the barrier is</span><br><span class="hljs-comment"> *        tripped, or &#123;<span class="hljs-doctag">@code</span> null&#125; if there is no action</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if &#123;<span class="hljs-doctag">@code</span> parties&#125; is less than 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;<br>    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.parties = parties;<br>    <span class="hljs-built_in">this</span>.count = parties;<br>    <span class="hljs-built_in">this</span>.barrierCommand = barrierAction;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a new &#123;<span class="hljs-doctag">@code</span> CyclicBarrier&#125; that will trip when the</span><br><span class="hljs-comment"> * given number of parties (threads) are waiting upon it, and</span><br><span class="hljs-comment"> * does not perform a predefined action when the barrier is tripped.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> parties the number of threads that must invoke &#123;<span class="hljs-doctag">@link</span> #await&#125;</span><br><span class="hljs-comment"> *        before the barrier is tripped</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if &#123;<span class="hljs-doctag">@code</span> parties&#125; is less than 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties)</span> &#123;<br>    <span class="hljs-built_in">this</span>(parties, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="await">await</h3>
<p>这个方法既会返回，也会抛出异常。</p>
<p>它的返回值是：the arrival index of the current thread, where index getParties() - 1 indicates the first to arrive and zero indicates the last to arrive。也就是说，如果有5个线程在等，await == 4 意味着第一个返回，await == 0 意味着最后一个返回。然后可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里的 await 是支持 happen-before 语义的，在 await 返回的那一刻即返回</span><br><span class="hljs-keyword">if</span> (barrier.await() == <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-comment">// log the completion of this iteration</span><br> &#125;<br></code></pre></td></tr></table></figure>
<p>它有一个核心的方法，这个方法把所有的非计时转化为计时- ConditionObject 内部不是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">return</span> dowait(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>       &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>           <span class="hljs-comment">// 针对有签名但不处理的异常，我们包装为 error</span><br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(toe); <span class="hljs-comment">// cannot happen</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>所以我们有了计时的等待方法总能得到非计时的实现。</p>
<h3 id="dowait">dowait</h3>
<p>有4种方法可退出：<br>
- last thread arrives<br>
- 中断发生在任意一个等待线程，抛出 InterruptedException（自己被中断）或者 BrokenBarrierException （其他线程被中断）<br>
- 超时发生，抛出 BrokenBarrierException<br>
- 触发了 reset，抛出 BrokenBarrierException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException,<br>               TimeoutException &#123;<br>        <span class="hljs-comment">// 这个内部框架在维护状态的时候，都是使用标准的 lock-check-await 的模式</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 把当前的 generation 取出来</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> generation;<br><br>            <span class="hljs-comment">// 这个方法的前置检查抛出 generation 异常，作为栅栏破坏的响应，而不处理栅栏</span><br>            <span class="hljs-keyword">if</span> (g.broken)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br><br>            <span class="hljs-comment">// 一个线程检查出中断，要把其他线程破坏。所以被中断的线程是中断异常，被破坏的线程是破坏异常。中断线程可以处理栅栏。</span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>                breakBarrier();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125;<br>            <br>            <span class="hljs-comment">// 在进行等待以前对 count 做共享减法，这个共享写的顺序能够体现在 index 里</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> --count;<br>            <br>            <span class="hljs-comment">// index 等于 0 是一个特定的事件，是最后一个线程才会触发的分支，这引出了一种写法，最后返回的分支写在等待的开头</span><br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// tripped</span><br>                <span class="hljs-comment">// 维护一个 ranAction 状态</span><br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">ranAction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> barrierCommand;<br>                    <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>)<br>                        command.run();<br>                    ranAction = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-comment">// 由最后一个线程驱动下一个 generation，理论上下一轮的 await 可以在这个时刻运行了。返回线程可以处理栅栏。</span><br>                    nextGeneration();<br>                    <span class="hljs-comment">// 这里的 return 是唯一的“无害动作”，如果这里插入任何维护状态的代码，下面的 breakBarrier 再破坏状态，可能会导致下一代的 wait 动作被集体破坏</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 如果 ranAction 状态不正常，则还是要破坏栅栏</span><br>                    <span class="hljs-keyword">if</span> (!ranAction)<br>                        breakBarrier();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 非 last 动作，则只有3种方式返回</span><br>            <span class="hljs-comment">// loop until tripped, broken, interrupted, or timed out</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 区分计时和非计时的等待，然后在自旋里工作</span><br>                    <span class="hljs-keyword">if</span> (!timed)<br>                        trip.await();<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)<br>                        <span class="hljs-comment">// an estimate of the nanosTimeout value minus the time spent waiting upon return from this method. A positive value may be used as the argument to a subsequent call to this method to finish waiting out the desired time. A value less than or equal to zero indicates that no time remains.</span><br>                        <span class="hljs-comment">// 这个 nanos 可能成为负数，为我们超时异常提供了依据</span><br>                        nanos = trip.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                    <span class="hljs-comment">// 如果此时本代仍然是同一代，则尝试破坏栅栏（这是为了让同一代里 breakBarrier 式退出 exactly once）</span><br>                    <span class="hljs-keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;<br>                        breakBarrier();<br>                        <span class="hljs-keyword">throw</span> ie;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 如果不需要我们破坏动作，根据标准协议，收到 InterruptedException 我们也要中断线程，作为响应。</span><br>                        <span class="hljs-comment">// 我们要理解一个巨大的差别：在当代的中断我们是要忠实地履行方法签名的行为，抛出异常，不在当代则静默地中断自己</span><br>                        <span class="hljs-comment">// We&#x27;re about to finish waiting even if we had not</span><br>                        <span class="hljs-comment">// been interrupted, so this interrupt is deemed to</span><br>                        <span class="hljs-comment">// &quot;belong&quot; to subsequent execution.</span><br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;<br>                <br>                <span class="hljs-comment">// await 的正常返回带来的后置检查，这里的 g是当前代数</span><br>                <span class="hljs-keyword">if</span> (g.broken)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br>                <br>                <span class="hljs-comment">// 如果代数换了，就返回当前的次序，不管超时了（无意义）。只要�发生过nextGeneration，发生代切换，此处才得到许可可以出去，这又潜在要求 nextGeneration 执行替换一定发生在 signallAll 之前。但 nextGeneration 的实现却是先 signallAll 再替换 nextGeneration 的</span><br>                <span class="hljs-keyword">if</span> (g != generation)<br>                    <span class="hljs-comment">// 在这里编译器居然能保证 return 总是不漏，怎么做到的呢？</span><br>                    <span class="hljs-keyword">return</span> index;<br>                <br>                <span class="hljs-comment">//  如果排队中出现了超时，此时要处理一下</span><br>                <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                    breakBarrier();<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的等待是由 await 类操作决定的，它的唤醒操作必然来自 signal 类操作，而这两类操作被隐藏在正常退出和异常退出里。</p>
<h3 id="异常退出-breakbarrier">异常退出 breakBarrier</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breakBarrier</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 把当前的代破坏</span><br>       generation.broken = <span class="hljs-literal">true</span>;<br>       <span class="hljs-comment">// 把 count 复原为 parties</span><br>       count = parties;<br>       trip.signalAll();<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>异常退出是设置完状态再 signalAll。</p>
<h3 id="正常退出-nextgeneration">正常退出 nextGeneration</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextGeneration</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// signal completion of last generation</span><br>      trip.signalAll();<br>      <span class="hljs-comment">// set up next generation</span><br>      count = parties;<br>      generation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>异常退出是 signalAll 完再设置完状态。</p>
<h3 id="重置-reset">重置 reset</h3>
<p>等于先破坏栅栏再重置栅栏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Resets the barrier to its initial state.  If any parties are</span><br><span class="hljs-comment"> * currently waiting at the barrier, they will return with a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> BrokenBarrierException&#125;. Note that resets &lt;em&gt;after&lt;/em&gt;</span><br><span class="hljs-comment"> * a breakage has occurred for other reasons can be complicated to</span><br><span class="hljs-comment"> * carry out; threads need to re-synchronize in some other way,</span><br><span class="hljs-comment"> * and choose one to perform the reset.  It may be preferable to</span><br><span class="hljs-comment"> * instead create a new barrier for subsequent use.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 老线程要通过闭包里闭合的局部变量理解 break</span><br>        breakBarrier();   <span class="hljs-comment">// break the current generation</span><br>        <span class="hljs-comment">// 新线程使用隔离的 generation</span><br>        nextGeneration(); <span class="hljs-comment">// start a new generation</span><br>        <span class="hljs-comment">// reset 意味着 count 再次等于 parties</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="统计方法">统计方法</h3>
<h4 id="isbroken">isBroken</h4>
<p>这个方法实现了准确读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBroken</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> generation.broken;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="getnumberwaiting">getNumberWaiting</h4>
<p>这个方法也实现了准确读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the number of parties currently waiting at the barrier.</span><br><span class="hljs-comment"> * This method is primarily useful for debugging and assertions.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the number of parties currently blocked in &#123;<span class="hljs-doctag">@link</span> #await&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumberWaiting</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> parties - count;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="semaphore">Semaphore</h2>
<p>Semaphore 使用数字维护一个共享状态池，使用共享加解锁的思路来修改 state。</p>
<blockquote>
<p>创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用<br>
acquire 的时候，执行 state = state - 1，release 的时候执行 state = state +<br>
1，当然，acquire  的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p>
</blockquote>
<p>需要仔细设计的怎么阻塞与唤醒。</p>
<h3 id="官方示例">官方示例</h3>
<p>作者认为这是一个 permit pool。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_AVAILABLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(MAX_AVAILABLE, <span class="hljs-literal">true</span>);<br><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getItem</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     available.acquire();<br>     <span class="hljs-keyword">return</span> getNextAvailableItem();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putItem</span><span class="hljs-params">(Object x)</span> &#123;<br>     <span class="hljs-keyword">if</span> (markAsUnused(x))<br>       available.release();<br>   &#125;<br><br>   <span class="hljs-comment">// Not a particularly efficient data structure; just for demo</span><br><br>   <span class="hljs-keyword">protected</span> Object[] items = ... whatever kinds of items being managed<br>   <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[MAX_AVAILABLE];<br><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title function_">getNextAvailableItem</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;<br>       <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>          used[i] = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">return</span> items[i];<br>       &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// not reached</span><br>   &#125;<br><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markAsUnused</span><span class="hljs-params">(Object item)</span> &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;<br>       <span class="hljs-keyword">if</span> (item == items[i]) &#123;<br>          <span class="hljs-keyword">if</span> (used[i]) &#123;<br>            used[i] = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例里对称很重要，在 op 以前就要 acquire permit，在 op 成功以后才 release permit。它的 state 恰好不是以互斥的方式 accumulated 的，是以共享的方式 accumulated 的。</p>
<p>mutex = binary semaphore = nonreentrant exclusive lock</p>
<p>这种锁是不计较 owner 的，在死锁恢复场景下尤其有用。比如有个线程 a 拿走了一个 permit 没有还，其他线程可以通过把自己的 permit 归还，来暂时制造流动性。</p>
<p>照理来讲，没有 IllegateMonitorStateException 的约束，多 release 也是有可能的，不一定需要严格按照 acquire 时线程得到的 permit进行归还。所以，CountDownLatch 和 CyclicBarrier 的state 是固定大小的，Semaphore不是。</p>
<h3 id="构造器">构造器</h3>
<p>因为信号量也是不易察觉的“类锁”的方案，所以它也有公平和非公平的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(<span class="hljs-keyword">permits</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不公平抢锁可以减少调度，被称作 barging；公平抢锁可以减少饥饿。</p>
<h3 id="获取资源：四大-acquire-方法">获取资源：四大 acquire 方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>    sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">permits</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    sync.acquireSharedInterruptibly(<span class="hljs-keyword">permits</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">permits</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    sync.acquireShared(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有可中断和不可中断两大类 API，也有无参数和固定参数两大 API，不过 API 命名的习惯没有得到遵循，默认的 Semaphore 的方法是响应中断的。</p>
<h4 id="acquireshared">acquireShared</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法很像 CountDownLatch 的 await，但少了检查中断的一部分。其中 doAcquireShared 和 CountDownLatch 一样都使用的 AQS 的原生实现。</p>
<h4 id="tryacquireshared">tryAcquireShared</h4>
<h5 id="公平">公平</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (hasQueuedPredecessors())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>共享池模式使用 -1 和 1 来控制是否 doAcquireShare，所以这里返回 -1 意味着要入队，返回负数的 remaining 也是需要入队的。如果是正数则可以尝试 cas 一下。</p>
<h5 id="非公平">非公平</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>         <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>     &#125;<br> <br> <span class="hljs-comment">// 在父类里</span><br> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>         <span class="hljs-keyword">for</span> (;;) &#123;<br>             <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>             <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>             <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>                 compareAndSetState(available, remaining))<br>                 <span class="hljs-keyword">return</span> remaining;<br>         &#125;<br>     &#125;<br></code></pre></td></tr></table></figure>
<p>公平和非公平的差别只在 hasQueuedPredecessors 的调用结果里。</p>
<h3 id="释放资源">释放资源</h3>
<p>不管用什么方式获取，释放总是用同一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>releaseShared 和 doReleaseShared 仍然共用 AQS 的缺省实现，只有 tryReleaseShared 是使用 sync 实现。</p>
<h4 id="tryreleaseshared">tryReleaseShared</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>        <span class="hljs-comment">// 溢出，当然，我们一般也不会用这么大的数</span><br>        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>获取当前的 state，按照 releases 来做加法。</p>
<h2 id="线程池">线程池</h2>
<blockquote>
<p>Pooling is the grouping together of resources (assets, equipment,<br>
personnel, effort, etc.) for the purposes of maximizing advantage or<br>
minimizing risk to the users. The term is used in finance, computing<br>
and equipment management.——wikipedia</p>
<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p>
<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p>
<p>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection<br>
Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池(Object<br>
Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</p>
</blockquote>
<p>Doug Lea 对线程池的期待有：</p>
<ol>
<li>改善性能。</li>
<li>有界地利用资源（多次强调 bounds）。</li>
<li>提供统计。</li>
</ol>
<h3 id="线程池继承体系">线程池继承体系</h3>
<p><img src="ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="ThreadPoolExecutorUML类图.png"></p>
<h4 id="executor-接口">Executor 接口</h4>
<p>将任务提交和任务执行进行解耦（<strong>decoupling the execution mechanic</strong>）。用户无需关注如何创建线程，如何调度线程（scheduling）来执行任务，用户只需提供 Runnable 对象，将任务的运行逻辑提交到执行器(Executor)中，由 Executor 框架完成线程的调配和任务的执行部分。</p>
<p>JUC 里所有的解耦设计都不一定是异步的，它只是<strong>解耦</strong>，所以执行器本身也是可以同步执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable r)</span> &#123;<br>     r.run();<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>一般而言可以认为，executor 会 spawns a new thread for each task.</p>
<h4 id="executorservice-接口">ExecutorService 接口</h4>
<p>增加了一些能力：</p>
<p>扩充执行任务的能力，补充可以为一个或一批异步任务<strong>生成 Future 的方法</strong>（）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task)<br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br></code></pre></td></tr></table></figure>
<p>提供了管控线程池的方法，比如停止线程池的运行。</p>
<p>shutdown 拒绝接收任务，触发 rejection policy。<br>
shutdownNow 除了 shutdown 的功能以外，还会强制触发线程中断。</p>
<p>Memory consistency effects：future.get 满足 JSL 定义的 Memory consistency properties，也就是 happens before relation。</p>
<p>理解 happens before relation 一定不要按照硬件的工作方式来理解（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/67472344/java-volatile-and-final-volatile-as-flushing-all-memory-content">Flushing model is fundamentally flawed (it is just not how hardware works)</a>），最好从 JLS 的规范出发：</p>
<h4 id="abstractexecutorservice">AbstractExecutorService</h4>
<p>将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法即可。</p>
<h5 id="threadpoolexecutor">ThreadPoolExecutor</h5>
<p>将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<p><img src="ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="ThreadPoolExecutor运行流程.png"></p>
<h5 id="forkjoinpool">ForkJoinPool</h5>
<p>这个线程池本身就是一个复杂框架，为 Jdk 其他组件提供 yet another executor alternative。</p>
<p>这个框架有个特点：</p>
<ol>
<li>产生的线程默认是守护线程。</li>
<li>产生的线程会自动收缩-不存在空转的 core thread 问题。</li>
<li>公共线程池的名字一般叫“ForkJoinPool.commonPool-worker-1”。</li>
</ol>
<p>这里就要讨论到一个很多人忽略的问题：我们如何决定何时使用守护类线程。这类线程可以用来执行一些：</p>
<ol>
<li>临时执行的任务，这些任务之间如果存在父子关系更好。</li>
<li>后台监控类任务。</li>
<li>某些与 io 解耦的计算任务。</li>
</ol>
<p>也就是说，这类线程池（包括守护线程本身）决不能用来执行工作逻辑，不然：</p>
<ol>
<li>工作线程池会在 JVM 关闭时被无声无息地杀死。</li>
<li>当其他非守护线程都结束后，这些守护线程的存在反而是 JVM 进入关闭态的理由。</li>
<li>典型的工作线程池就是 IO 线程池，和与他们绑定的计算线程池。</li>
</ol>
<p>初始化这类线程池有一些简单的工厂方法，比原始构造器更加可用：  <code>Executors.newWorkStealingPool(int parallelism)</code>。</p>
<h4 id="the-executors">The Executors</h4>
<blockquote>
<p>provides convenient factory methods for these Executors.</p>
</blockquote>
<h3 id="线程池如何维护自身状态">线程池如何维护自身状态</h3>
<p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>
<p>ctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，<strong>不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况</strong>。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。<strong>这里都使用的是位运算的方式，相比于基本运算，速度也会快很多</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 29</span><br>        System.out.println(COUNT_BITS);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">shifted</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 1 与 29 个 0，所以左移意味着补 0，左移一位意味着补 1 个 0，左移 29 位意味着补 29 个 0，最后得到 30 位数：100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(shifted));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> shifted - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 29个 1：11111111111111111111111111111</span><br>        System.out.println(Integer.toBinaryString(CAPACITY));<br>        <span class="hljs-comment">// 高 3 位为 1，低 29 位为 0：11100000000000000000000000000000，和 CAPACITY 低 29 位为 1，高 3 位为 0 恰好相反</span><br>        System.out.println(Integer.toBinaryString(~CAPACITY));<br>        System.out.println(Integer.toBinaryString(~CAPACITY));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// -1 意味着 32 个 1：11111111111111111111111111111111</span><br>        System.out.println(Integer.toBinaryString(-<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 3 个 1 和 29 个 0：11100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(RUNNING));<br>        <br>        <span class="hljs-comment">// 重点：从后方补 0 的算法，可以把 state 的基准位从低位移到高位，这样大数的一部分就可以拿来表示有限状态了</span><br>        <br>        <span class="hljs-comment">// 0 不管位移多少位都是 0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br>        System.out.println(Integer.toBinaryString(SHUTDOWN));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 1 和 29 个 0：100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(STOP));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 10 和 29 个 0：1000000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(TIDYING));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 11 和 29 个 0：1100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(TERMINATED));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> getCapacity();<br>        <span class="hljs-comment">// 把 CAPACITY 的补码按位与，这样高 32 位就可以被取出来</span><br>        <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; <br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> getCapacity();<br>        <span class="hljs-comment">// 低 32 位本身就是 workCount，这个 workCount 可以容纳很大的数</span><br>        <span class="hljs-keyword">return</span> c &amp; CAPACITY; <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123;<br>        <span class="hljs-keyword">return</span> rs | wc; <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCapacity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">shifted</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> shifted - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> CAPACITY;<br>    &#125;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">运行状态</th>
<th style="text-align:center">状态描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RUNNING</td>
<td style="text-align:center">能接受新提交的任务，并且也能处理阻塞队列中的任务。</td>
</tr>
<tr>
<td style="text-align:center">SHUTDOWN</td>
<td style="text-align:center">关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。</td>
</tr>
<tr>
<td style="text-align:center">STOP</td>
<td style="text-align:center">不能接受新任务，【也不处理队列中的任务，会中断正在处理任务的线程。】增加了两条措施，是一个更严厉的状态，理论上只要线程被中断完，线程池就可以走向关闭</td>
</tr>
<tr>
<td style="text-align:center">TIDYING</td>
<td style="text-align:center">所有的任务都已终止了，workerCount (有效线程数) 为0，这个状态的意思不是整理中，而是整理完了。</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td style="text-align:center">在terminated() 方法执行完后进入该状态。</td>
</tr>
</tbody>
</table>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程池生命周期.png"></p>
<p>其中 running 既是初始态，也是中间态，所以才有<code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</code>作为初始化块的一部分。</p>
<h4 id="尝试关闭线程池">尝试关闭线程池</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Transitions to TERMINATED state if either (SHUTDOWN and pool</span><br><span class="hljs-comment">    * and queue empty) or (STOP and pool empty).  If otherwise</span><br><span class="hljs-comment">    * eligible to terminate but workerCount is nonzero, interrupts an</span><br><span class="hljs-comment">    * idle worker to ensure that shutdown signals propagate. This</span><br><span class="hljs-comment">    * method must be called following any action that might make</span><br><span class="hljs-comment">    * termination possible -- reducing worker count or removing tasks</span><br><span class="hljs-comment">    * from the queue during shutdown. The method is non-private to</span><br><span class="hljs-comment">    * allow access from ScheduledThreadPoolExecutor.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 注意这里有个自旋</span><br>       <span class="hljs-keyword">for</span> (;;) &#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>           <span class="hljs-comment">//  尝试把把本线程池的状态改成 TIDYING -&gt; TERMINATED，所以正在 running、正在 shutdown 但队列未空、已经高于 TIDYING 都直接返回</span><br>           <span class="hljs-keyword">if</span> (isRunning(c) ||<br>               runStateAtLeast(c, TIDYING) ||<br>               (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>               <span class="hljs-keyword">return</span>;<br>           <span class="hljs-comment">// 只要 wc&gt;0，就关闭并只关闭一个空闲线程（看起来这里是假设本方法通常是由线程退出来触发的，所以此处能够关掉一个就直接退出）</span><br>           <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>               interruptIdleWorkers(ONLY_ONE);<br>               <span class="hljs-keyword">return</span>;<br>           &#125;<br>           <br>           <span class="hljs-comment">// 如果一个 worker 都没有了，就真的关闭本线程池</span><br>           <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>           mainLock.lock();<br>           <span class="hljs-keyword">try</span> &#123;<br>               <span class="hljs-comment">// 这个地方做了一个多余操作，把 TIDYING 做一个 ctlOf 转化            // 先置为 TIDYING</span><br>               <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                   <span class="hljs-keyword">try</span> &#123;<br>                       <span class="hljs-comment">// 通常是一个空钩子方法，这两个状态之间就差了一个钩子设计</span><br>                       terminated();<br>                   &#125; <span class="hljs-keyword">finally</span> &#123;<br>                       <span class="hljs-comment">// 再设置为 TERMINATED</span><br>                       ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                       <span class="hljs-comment">// 已关闭才做 signalAll()</span><br>                       termination.signalAll();<br>                   &#125;<br>                   <span class="hljs-keyword">return</span>;<br>               &#125;<br>           &#125; <span class="hljs-keyword">finally</span> &#123;<br>               mainLock.unlock();<br>           &#125;<br>           <span class="hljs-comment">// else retry on failed CAS</span><br>           <span class="hljs-comment">// 这里失败，下次再从外部进入 TIDYING -&gt; TERMINATED 的循环</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h3 id="线程池如何管理任务">线程池如何管理任务</h3>
<p>每个线程池的 Worker 管理的实质上是 FutureTask，它既是<code>Callable</code>（确切地说，wrap Callable），也是<code>Future</code>（一个最完美的任务是一个<code>RunnableFuture&lt;V&gt;</code>，用成员变量来帮助 <code>Runnable</code>来保存一个<code>Callable</code>的返回值，以供<code>Future</code>使用）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个可以取消的计算。</span><br><span class="hljs-comment">// 基本上只能完成一次，除非执行 runAndReset，执行完成不能再 cancel</span><br><span class="hljs-comment">// 只有计算执行完成 get 才可以获取结果，之前必然阻塞</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A cancellable asynchronous computation.  This class provides a base</span><br><span class="hljs-comment"> * implementation of &#123;<span class="hljs-doctag">@link</span> Future&#125;, with methods to start and cancel</span><br><span class="hljs-comment"> * a computation, query to see if the computation is complete, and</span><br><span class="hljs-comment"> * retrieve the result of the computation.  The result can only be</span><br><span class="hljs-comment"> * retrieved when the computation has completed; the &#123;<span class="hljs-doctag">@code</span> get&#125;</span><br><span class="hljs-comment"> * methods will block if the computation has not yet completed.  Once</span><br><span class="hljs-comment"> * the computation has completed, the computation cannot be restarted</span><br><span class="hljs-comment"> * or cancelled (unless the computation is invoked using</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #runAndReset&#125;).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;A &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; can be used to wrap a &#123;<span class="hljs-doctag">@link</span> Callable&#125; or</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Runnable&#125; object.  Because &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; implements</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> Runnable&#125;, a &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; can be submitted to an</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Executor&#125; for execution.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;In addition to serving as a standalone class, this class provides</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> protected&#125; functionality that may be useful when creating</span><br><span class="hljs-comment"> * customized task classes.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Doug Lea</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;V&gt; The result type returned by this FutureTask&#x27;s &#123;<span class="hljs-doctag">@code</span> get&#125; methods</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>线程池使用一个把 Runnable 转变为 Callable 的适配器（Callable 转 Runnable 理论上也是容易做到的，但应该没有必要转换），来兼容把 Runnable 传进 submit 的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 把 runnable 和一个勉强的 result 包装成一个 callable，分三步</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>        <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>        <span class="hljs-built_in">this</span>.state = NEW;       <span class="hljs-comment">// ensure visibility of callable</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="hljs-title function_">callable</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt;(task, result);<br>    &#125;<br>    <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">final</span> Runnable task;<br>        <span class="hljs-keyword">final</span> T result;<br>        RunnableAdapter(Runnable task, T result) &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>            <span class="hljs-built_in">this</span>.result = result;<br>        &#125;<br>        <span class="hljs-comment">// 注意，这个 call() 是不抛出异常的，所以对 Java 而言，子类的签名里可以不继续抛出父类声明的异常，</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>            task.run();<br>            <span class="hljs-comment">// 组合逻辑在这一层</span><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>FutureTask 实现了 RunnableFuture，它本质上是一个携带 Runnable 和 state 的任务。</p>
<p>首先看它的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The run state of this task, initially NEW.  The run state</span><br><span class="hljs-comment">     * transitions to a terminal state only in methods set,</span><br><span class="hljs-comment">     * setException, and cancel.  During completion, state may take on</span><br><span class="hljs-comment">     * transient values of COMPLETING (while outcome is being set) or</span><br><span class="hljs-comment">     * INTERRUPTING (only while interrupting the runner to satisfy a</span><br><span class="hljs-comment">     * cancel(true)). Transitions from these intermediate to final</span><br><span class="hljs-comment">     * states use cheaper ordered/lazy writes because values are unique</span><br><span class="hljs-comment">     * and cannot be further modified.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Possible state transitions:</span><br><span class="hljs-comment">     * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="hljs-comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="hljs-comment">     * NEW -&gt; CANCELLED</span><br><span class="hljs-comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>值得一提的是，任务的中间状态是一个瞬态，它非常的短暂。而且任务的中间态并不代表任务正在执行，而是任务已经执行完了，正在设置最终的返回结果，所以可以这么说：<br>
只要state不处于 NEW 状态，就说明任务已经执行完毕。<br>
注意，<strong>这里的执行完毕是指传入的Callable对象的call方法执行完毕</strong>，<strong>或者抛出了异常</strong>。所以这里的COMPLETING的名字显得有点迷惑性，它并不意味着任务正在执行中，而意味着call方法已经执行完毕，正在设置任务执行的结果。</p>
</blockquote>
<p>换言之，只有 NEW 状态才是 cancellable 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Doug Lea 本身比较喜欢使用普通整数来制造状态机</span><br><span class="hljs-comment">// COMPLETING 和 INTERRUPTING 是 set state 和取消任务的中间态</span><br><br>    <br>    <span class="hljs-comment">/** The underlying callable; nulled out after running */</span><br>    <span class="hljs-keyword">private</span> Callable&lt;V&gt; callable;<br>    <br>    <span class="hljs-comment">// 异常和输出使用同一个 outcome，所以 outcome 不能是泛型，必须是 object</span><br>    <span class="hljs-comment">// 它是非 volatile 的，需要巧妙利用 state 读写</span><br>    <span class="hljs-comment">/** The result to return or exception to throw from get() */</span><br>    <span class="hljs-keyword">private</span> Object outcome; <span class="hljs-comment">// non-volatile, protected by state reads/writes</span><br>    <br>    <span class="hljs-comment">/** The thread running the callable; CASed during run() */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread runner;<br>    <br>    <span class="hljs-comment">/** Treiber stack of waiting threads */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WaitNode waiters;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.callable = callable;<br>    <span class="hljs-comment">// ensure visibility of callable</span><br>    <span class="hljs-built_in">this</span>.state = NEW;       <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>            <span class="hljs-comment">// 把 volatile 变量写在写语句的最后，写在读语句的最前面，类似 monitorEnter 和 monitorExit 的语义，可以保证可见性</span><br>    <span class="hljs-comment">// ensure visibility of callable</span><br>    <span class="hljs-built_in">this</span>.state = NEW;       <br>&#125;<br></code></pre></td></tr></table></figure>
<p>它的状态管理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state &gt;= CANCELLED;<br>    &#125;<br>    <span class="hljs-comment">// 只要不是 NEW 就是完成了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state != NEW;<br>    &#125;<br><br>    <br>    <span class="hljs-comment">// 移除并通知所有等待线程，</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Removes and signals all waiting threads, invokes done(), and</span><br><span class="hljs-comment">     * nulls out callable.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishCompletion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// assert state &gt; COMPLETING;</span><br>        <span class="hljs-comment">// 漂亮的声明和比对写法</span><br>        <span class="hljs-keyword">for</span> (WaitNode q; (q = waiters) != <span class="hljs-literal">null</span>;) &#123;<br>            <span class="hljs-comment">// 在 for 循环里用 cas 把 waiter 置空</span><br>            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q, <span class="hljs-literal">null</span>)) &#123;        <br>                <span class="hljs-comment">// 在内层循环里把当前线程和 futureTask 的关系移除，并且</span><br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    <span class="hljs-comment">// 在这个内存循环里面，要做的就是一个个遍历链表的 next，unpark 掉它们，并且 help gc</span><br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q.thread;<br>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                        q.thread = <span class="hljs-literal">null</span>;<br>                        LockSupport.unpark(t);<br>                    &#125;<br>                    <span class="hljs-type">WaitNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> q.next;<br>                    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>                        <span class="hljs-keyword">break</span>;<br>                    q.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// unlink to help gc</span><br>                    q = next;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        done();<br>        <span class="hljs-comment">// 此处就是上面的 nulled 的意思了，任务进入终态以后 callable 也可以被回收</span><br>        callable = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// to reduce footprint</span><br>    &#125;<br>    <br><span class="hljs-comment">// 通过使 permit 变成 available 的方式，使这个线程从 blocked 状态变成非 blocked 状态，或者下次调用 park 的时候非阻塞。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>            UNSAFE.unpark(thread);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>实际被工作线程调度的 run 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 如果不等于 new 或者 cas 把线程绑定到本 future task 上，就直接退出，这其实是一种幂等</span><br>       <span class="hljs-comment">// runner 的获取是从上下文里获得的</span><br>       <span class="hljs-keyword">if</span> (state != NEW ||<br>           !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                        <span class="hljs-literal">null</span>, Thread.currentThread()))<br>           <span class="hljs-keyword">return</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           Callable&lt;V&gt; c = callable;<br>           <span class="hljs-comment">// 只有状态和 callable 完备才能把值设进来</span><br>           <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>               V result;<br>               <span class="hljs-type">boolean</span> ran;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   result = c.call();<br>                   ran = <span class="hljs-literal">true</span>;<br>               &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                   result = <span class="hljs-literal">null</span>;<br>                   ran = <span class="hljs-literal">false</span>;<br>                   <span class="hljs-comment">// 如果 run 出异常，就进入 setException 终态方法</span><br>                   setException(ex);<br>               &#125;<br>               <span class="hljs-keyword">if</span> (ran)<br>                   <span class="hljs-comment">// 否则，set result，走入另一种终态</span><br>                   set(result);<br>           &#125;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-comment">// runner must be non-null until state is settled to</span><br>           <span class="hljs-comment">// prevent concurrent calls to run()</span><br>           <span class="hljs-comment">// 执行完要把 runner 置空，这样上面那个 cas 对其他线程而言就会失败</span><br>           runner = <span class="hljs-literal">null</span>;<br>           <span class="hljs-comment">// state must be re-read after nulling runner to prevent</span><br>           <span class="hljs-comment">// leaked interrupts</span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>           <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>               <span class="hljs-comment">// 可能有其他线程在 interrupting，在这里实现一套等待到  interrupted 的自旋 yield</span><br>               handlePossibleCancellationInterrupt(s);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>run 有一个重跑版本，这个版本会重复执行，但不会影响 get 的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Executes the computation without setting its result, and then</span><br><span class="hljs-comment"> * resets this future to initial state, failing to do so if the</span><br><span class="hljs-comment"> * computation encounters an exception or is cancelled.  This is</span><br><span class="hljs-comment"> * designed for use with tasks that intrinsically execute more</span><br><span class="hljs-comment"> * than once.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if successfully run and reset</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runAndReset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (state != NEW ||<br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                     <span class="hljs-literal">null</span>, Thread.currentThread()))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ran</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Callable&lt;V&gt; c = callable;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; s == NEW) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                c.call(); <span class="hljs-comment">// don&#x27;t set result</span><br>                ran = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                setException(ex);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// runner must be non-null until state is settled to</span><br>        <span class="hljs-comment">// prevent concurrent calls to run()</span><br>        runner = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// state must be re-read after nulling runner to prevent</span><br>        <span class="hljs-comment">// leaked interrupts</span><br>        s = state;<br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>            handlePossibleCancellationInterrupt(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ran &amp;&amp; s == NEW;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 FutureTask 里有三类终态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V v)</span> &#123;<br>    <span class="hljs-comment">// 在两个 CAS 操作之间夹逼一个 outcome</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>        outcome = v;<br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, NORMAL); <span class="hljs-comment">// final state</span><br>        finishCompletion();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 几乎等同于 set，但夹逼的是把 Throwable 设进 outcome 里面</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setException</span><span class="hljs-params">(Throwable t)</span> &#123;<br>        <span class="hljs-comment">// 注意这里只能把 callable 内部的异常设置进 outcome 里面，如果本服务发生了 interrupt，则这里必然失败</span><br>        <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>            outcome = t;<br>            UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="hljs-comment">// final state</span><br>            finishCompletion();<br>        &#125;<br>    &#125;<br>    <br>    <br><span class="hljs-comment">// 从这个方法可以看出，中断也是 cancel 的一种</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br>        <span class="hljs-comment">// 在一个布尔表达式里面表达顺序结构</span><br>        <span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp;<br>              UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW,<br>                  mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br>            <span class="hljs-comment">// 只能从 new 迁移到 INTERRUPTING 或者 CANCELLED，只要 cas 不成功，就返回 false。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// in case call to interrupt throws exception</span><br>            <span class="hljs-comment">// 如果取消带有中断标志</span><br>            <span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;<br>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>                        <span class="hljs-comment">// 强制中断这个线程</span><br>                        t.interrupt();<br>                &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// final state</span><br>                    <span class="hljs-comment">// 不使用 cas，把本应用的状态设为已中断</span><br>                    UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, INTERRUPTED);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 所有的终态操作都有的一个操作</span><br>            finishCompletion();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>如果程序进入终态，则 get 终于可以得到合理的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>        <span class="hljs-comment">// 比对状态</span><br>        <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>            <span class="hljs-comment">// 进入计时的 awaitDone 流程，这里的计时结果是带有状态的，0L 意味着无限计时</span><br>            s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>        <span class="hljs-comment">// 进入 report 流程</span><br>        <span class="hljs-keyword">return</span> report(s);<br>    &#125;<br>   <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>        <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>        <span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>            (s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>        <span class="hljs-keyword">return</span> report(s);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>其中等待流程见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Awaits completion or aborts on interrupt or timeout.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timed true if use timed waits</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nanos time to wait, if timed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> state upon completion</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;<br>        <span class="hljs-type">WaitNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 这里通过自旋来实现计时等待</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 如果本线程被中断，则释放所有的 get 线程，然后抛出一个中断异常，这里引入了一个经典的设计模式，在 waiting  状态内发生 interrupt 的地方，响应中断的方式是清空中断位（而不是简单地 swap），并抛出中断异常</span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>                <span class="hljs-comment">// 如果中断了（不正常退出），清空 waiter</span><br>                removeWaiter(q);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>            <span class="hljs-comment">// 进入终态，返回 s</span><br>            <span class="hljs-keyword">if</span> (s &gt; COMPLETING) &#123;<br>                <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 清空等待栈的线程，waitnode 可以功成身退了，但只清空当前的 q 的 thread，并不做完整的 removeWaiter</span><br>                    q.thread = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">return</span> s;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == COMPLETING) <span class="hljs-comment">// cannot time out yet</span><br>                <span class="hljs-comment">// no-op</span><br>                Thread.<span class="hljs-keyword">yield</span>();<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">// 这里生成了一个 waitnode，注意，这里的调用栈是等待线程 get -&gt; awaitDone()，所以此处会捕获get 线程进 waitnode 里，在本循环里产生了第一个 q 的节点。</span><br>                q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();<br>                <span class="hljs-comment">// 一般第一轮循环q 总是为 null 的，只有第二轮进入这个地方的，才会进入这个分支，而且这里可能会失败，如果失败也，这时候就会把</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)<br>                <span class="hljs-comment">// 如果 q 不为空，且没有入队，则首先把当前的 waiters 放到当前的 q.next 里，然后把 q 放到本类型的 waiters 里（用新 q 代替老 waiter）</span><br>                queued = UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                                                     q.next = waiters, q);<br>            <span class="hljs-comment">// 前面两轮循环都走过了（前面两轮必须使 q 不为空，queued变成 true，才进入接下来的循环），接下来就进入 park 或者 parkNanos，看看会不会再被唤醒了</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;<br>                nanos = deadline - System.nanoTime();<br>                <span class="hljs-comment">// 如果超时了（bu），清空 waiter</span><br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                    removeWaiter(q);<br>                    <span class="hljs-keyword">return</span> state;<br>                &#125;<br>                <span class="hljs-comment">// 如果没有超时，本线程先驻留一下，驻留完进入下一个循环</span><br>                LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-comment">// 否则，无限驻留，直到下一个循环。下一个循环必须由 finishCompletion 里的 LockSupport.unpark(t); 触发</span><br>                LockSupport.park(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Simple linked list nodes to record waiting threads in a Treiber</span><br><span class="hljs-comment">     * stack.  See other classes such as Phaser and SynchronousQueue</span><br><span class="hljs-comment">     * for more detailed explanation.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span> &#123;<br>        <span class="hljs-keyword">volatile</span> Thread thread;<br>        <span class="hljs-keyword">volatile</span> WaitNode next;<br>        WaitNode() &#123; thread = Thread.currentThread(); &#125;<br>    &#125;<br>    <br><span class="hljs-comment">// 解掉链表，help gc</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Tries to unlink a timed-out or interrupted wait node to avoid</span><br><span class="hljs-comment">     * accumulating garbage.  Internal nodes are simply unspliced</span><br><span class="hljs-comment">     * without CAS since it is harmless if they are traversed anyway</span><br><span class="hljs-comment">     * by releasers.  To avoid effects of unsplicing from already</span><br><span class="hljs-comment">     * removed nodes, the list is retraversed in case of an apparent</span><br><span class="hljs-comment">     * race.  This is slow when there are a lot of nodes, but we don&#x27;t</span><br><span class="hljs-comment">     * expect lists to be long enough to outweigh higher-overhead</span><br><span class="hljs-comment">     * schemes.</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeWaiter</span><span class="hljs-params">(WaitNode node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            node.thread = <span class="hljs-literal">null</span>;<br>            retry:<br>            <span class="hljs-keyword">for</span> (;;) &#123;          <span class="hljs-comment">// restart on removeWaiter race</span><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">WaitNode</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, q = waiters, s; q != <span class="hljs-literal">null</span>; q = s) &#123;<br>                    s = q.next;<br>                    <span class="hljs-keyword">if</span> (q.thread != <span class="hljs-literal">null</span>)<br>                        pred = q;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>                        pred.next = s;<br>                        <span class="hljs-keyword">if</span> (pred.thread == <span class="hljs-literal">null</span>) <span class="hljs-comment">// check for race</span><br>                            <span class="hljs-keyword">continue</span> retry;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                                                          q, s))<br>                        <span class="hljs-keyword">continue</span> retry;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>然后就把outcome 通过 report 传出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里使用 object 转 v，必然带来 warning</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;<br>        <span class="hljs-keyword">if</span> (s == NORMAL)<br>            <span class="hljs-keyword">return</span> (V)x;<br>        <span class="hljs-keyword">if</span> (s &gt;= CANCELLED)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable)x);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="任务执行">任务执行</h4>
<h5 id="提交任务调度">提交任务调度</h5>
<ol>
<li>首先检测线程池运行状态，如果不是RUNNING，则直接拒绝，线程池要保证在RUNNING的状态下执行任务。</li>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p><img src="%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png" alt="任务调度流程.png"></p>
<h5 id="任务缓冲">任务缓冲</h5>
<p>任务缓冲模块是线程池能够管理任务的核心部分。<strong>线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦</strong>，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是**（阻塞的本质即为此）：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。**阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="阻塞队列的工作原理.png"></p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ArrayBlockingQueue</td>
<td style="text-align:center">一个用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序。<strong>支持公平锁和非公平锁</strong>。</td>
</tr>
<tr>
<td style="text-align:center">DelayQueue</td>
<td style="text-align:center">一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。</td>
</tr>
<tr>
<td style="text-align:center">LinkedBlockingDeque</td>
<td style="text-align:center">一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，<strong>可以将锁的竞争最多降到一半</strong>。</td>
</tr>
<tr>
<td style="text-align:center">LinkedBlockingQueue</td>
<td style="text-align:center">一个由链表结构组成的有界队列，此队列按照先进先出(FIFO)的原则对元素进行排序。此队列的默认长度为Integer.MAX_VALUE，<strong>所以默认创建的该队列有容量危险</strong>。</td>
</tr>
<tr>
<td style="text-align:center">LinkedTransferQueue</td>
<td style="text-align:center">一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</td>
</tr>
<tr>
<td style="text-align:center">PriorityBlockingQueue</td>
<td style="text-align:center">一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</td>
</tr>
<tr>
<td style="text-align:center">SynchronousQueue</td>
<td style="text-align:center">一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，<strong>线程空闲了60秒后会被回收</strong>。</td>
</tr>
</tbody>
</table>
<h5 id="任务申请">任务申请</h5>
<blockquote>
<p>任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
</blockquote>
<p>任务的执行主要有 submit-&gt;execute，submit 的主要逻辑是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>execute 的主要逻辑是：</p>
<p><img src="Worker%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.png" alt="Worker执行任务.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// 这个方法体现了线程池的任务调度策略的顶层设计：先 core 后 queue 后非 core 的设计思路。不过，这里面的 queue 的使用方案需要考虑线程池的状态。</span><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Executes the given task sometime in the future.  The task</span><br><span class="hljs-comment">     * may execute in a new thread or in an existing pooled thread.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * If the task cannot be submitted for execution, either because this</span><br><span class="hljs-comment">     * executor has been shutdown or because its capacity has been reached,</span><br><span class="hljs-comment">     * the task is handled by the current &#123;<span class="hljs-doctag">@code</span> RejectedExecutionHandler&#125;.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> command the task to execute</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> RejectedExecutionException at discretion of</span><br><span class="hljs-comment">     *         &#123;<span class="hljs-doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span><br><span class="hljs-comment">     *         cannot be accepted for execution</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NullPointerException if &#123;<span class="hljs-doctag">@code</span> command&#125; is null</span><br><span class="hljs-comment">     */</span><br>execute(Runnable command) &#123;<br>        <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Proceed in 3 steps:</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="hljs-comment">         * start a new thread with the given command as its first</span><br><span class="hljs-comment">         * task.  The call to addWorker atomically checks runState and</span><br><span class="hljs-comment">         * workerCount, and so prevents false alarms that would add</span><br><span class="hljs-comment">         * threads when it shouldn&#x27;t, by returning false.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 2. If a task can be successfully queued, then we still need</span><br><span class="hljs-comment">         * to double-check whether we should have added a thread</span><br><span class="hljs-comment">         * (because existing ones died since last checking) or that</span><br><span class="hljs-comment">         * the pool shut down since entry into this method. So we</span><br><span class="hljs-comment">         * recheck state and if necessary roll back the enqueuing if</span><br><span class="hljs-comment">         * stopped, or start a new thread if there are none.</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 3. If we cannot queue task, then we try to add a new</span><br><span class="hljs-comment">         * thread.  If it fails, we know we are shut down or saturated</span><br><span class="hljs-comment">         * and so reject the task.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>            <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>                <span class="hljs-keyword">return</span>;<br>            c = ctl.get();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>            <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>                reject(command);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>                addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>            reject(command);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这需要用到<a href="#%E5%B0%9D%E8%AF%95%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B">尝试增加线程</a></p>
<h3 id="线程池如何管理线程">线程池如何管理线程</h3>
<p>核心线程的 idle 不影响核心线程的创建；非核心线程的 idle time 会导致它们退出。</p>
<h4 id="尝试增加线程">尝试增加线程</h4>
<p>注意 addWorker 只是 execute 的一个子分支而已。</p>
<p><img src="%E7%94%B3%E8%AF%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="申请线程执行流程图.png"></p>
<p>Worker 可以被认为是线程和锁的结合体，它的使命就是不断地把 runnable 从缓冲队列里拿出来，放在自己的 thread 里执行，其中关键的方法是 addWorker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Checks if a new worker can be added with respect to current</span><br><span class="hljs-comment">     * pool state and the given bound (either core or maximum). If so,</span><br><span class="hljs-comment">     * the worker count is adjusted accordingly, and, if possible, a</span><br><span class="hljs-comment">     * new worker is created and started, running firstTask as its</span><br><span class="hljs-comment">     * first task. This method returns false if the pool is stopped or</span><br><span class="hljs-comment">     * eligible to shut down. It also returns false if the thread</span><br><span class="hljs-comment">     * factory fails to create a thread when asked.  If the thread</span><br><span class="hljs-comment">     * creation fails, either due to the thread factory returning</span><br><span class="hljs-comment">     * null, or due to an exception (typically OutOfMemoryError in</span><br><span class="hljs-comment">     * Thread.start()), we roll back cleanly.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> firstTask the task the new thread should run first (or</span><br><span class="hljs-comment">     * null if none). Workers are created with an initial first task</span><br><span class="hljs-comment">     * (in method execute()) to bypass queuing when there are fewer</span><br><span class="hljs-comment">     * than corePoolSize threads (in which case we always start one),</span><br><span class="hljs-comment">     * or when the queue is full (in which case we must bypass queue).</span><br><span class="hljs-comment">     * Initially idle threads are usually created via</span><br><span class="hljs-comment">     * prestartCoreThread or to replace other dying workers.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> core if true use corePoolSize as bound, else</span><br><span class="hljs-comment">     * maximumPoolSize. (A boolean indicator is used here rather than a</span><br><span class="hljs-comment">     * value to ensure reads of fresh values after checking other pool</span><br><span class="hljs-comment">     * state).</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> true if successful</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>        <span class="hljs-comment">// retry 是外部自旋的标签。大自旋保证 rs 是稳定的，小自旋保证 wc 是稳定的，在双自旋里面保证 wc 的修改成功</span><br>        retry:<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>            <span class="hljs-comment">// 获取运行时状态</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>            <br>            <span class="hljs-comment">// 如果线程池关闭了，或者不是worker 的 firstTask 为空，但 workQueue 不空</span><br>            <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>            <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>                ! (rs == SHUTDOWN &amp;&amp;<br>                   firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>                   ! workQueue.isEmpty()))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 内层自旋</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>                <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                    <span class="hljs-comment">// 其实 worker 里并没有 core 与否的属性，core 主要看比对哪个 PoolSize</span><br>                    wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// 如果这次一个原子性地增加 WorkerCount 成功，则退出大自旋；否则还是在大自旋里做 cas 增加 workerCount</span><br>                <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                    <span class="hljs-keyword">break</span> retry;<br>                <span class="hljs-comment">// 否则失败有两种可能：rc 变了，或者 wc 变了。看看当前 runState 是否还是大自旋的 runState</span><br>                c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>                <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                    <span class="hljs-comment">// 如果不是则返回大自旋</span><br>                    <span class="hljs-keyword">continue</span> retry;<br>                <span class="hljs-comment">// 如果是则 runState 不变，只是 wc 变了，在小自旋里重新获取 wc 即可</span><br>                <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 在上层的 ctl 的修改是通过自旋来做的，不加锁，但下层就必须加锁了。这个设计实际上让 ctl 的修改和 worker 的修改解耦，实现了某种“最终一致”</span><br>        <br>        <span class="hljs-comment">// worker 的创建和添加是两个状态</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 外部传进来的 firstTask 可能为空，这里照样传进去</span><br>            w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>            <span class="hljs-comment">// 在 Worker 构造器的内部携带的线程工厂创建的 thread 也可能为空</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 凡是修改线程池的 bookkeeping 操作，包含状态之外（比如 worker）的成员复杂流程修改的时候，都需要加锁</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>                mainLock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// Recheck while holding lock.</span><br>                    <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                    <span class="hljs-comment">// shut down before lock acquired.</span><br>                    <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                    <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                        <span class="hljs-comment">// Tests if this thread is alive. A thread is alive if it has been started and has not yet died.</span><br>                        <span class="hljs-comment">// 这个方法本身是为了启动新线程，如果线程工厂不是启动新线程而是像线程池一样复用线程的话，线程就是 alive 的了（注意这个状态和线程的 status 还不一样），这时候线程池 addWorker 会失败</span><br>                        <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable                   </span><br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                        workers.add(w);<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                        <span class="hljs-comment">// 更新簿记值</span><br>                        <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                            largestPoolSize = s;<br>                        workerAdded = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    mainLock.unlock();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                    <span class="hljs-comment">// 此时才开始线程</span><br>                    t.start();<br>                    workerStarted = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (! workerStarted)<br>                addWorkerFailed(w);<br>        &#125;<br>        <span class="hljs-keyword">return</span> workerStarted;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Rolls back the worker thread creation.</span><br><span class="hljs-comment">     * - removes worker from workers, if present</span><br><span class="hljs-comment">     * - decrements worker count</span><br><span class="hljs-comment">     * - rechecks for termination, in case the existence of this</span><br><span class="hljs-comment">     *   worker was holding up termination</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)<br>                workers.remove(w);<br>            decrementWorkerCount();<br>            <span class="hljs-comment">// 增加线程失败，会导致线程池终结</span><br>            tryTerminate();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Decrements the workerCount field of ctl. This is called only on</span><br><span class="hljs-comment">     * abrupt termination of a thread (see processWorkerExit). Other</span><br><span class="hljs-comment">     * decrements are performed within getTask.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrementWorkerCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 减 worker count 的操作必须自旋到成功，这种小成员的自旋修改不需要 sleep！</span><br>        <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));<br>    &#125;<br>    <br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndIncrementWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect)</span> &#123;<br>        <span class="hljs-comment">// 因为 wc 在 32 位整数的低位，所以直接对 expect + 1 即可。</span><br>        <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect + <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="线程执行">线程执行</h4>
<p><img src="%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png" alt="执行任务流程.png"></p>
<p>线程的执行强依赖于 worker 本身的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// worker 本身并不严重依赖自己的状态，所以不像线程池一样拥有一个 runState，但它持有一个 state，能够表达自身的锁状态。所以它自身拥有 -1、0、1 三种状态</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Class Worker mainly maintains interrupt control state for</span><br><span class="hljs-comment">     * threads running tasks, along with other minor bookkeeping.</span><br><span class="hljs-comment">     * This class opportunistically extends AbstractQueuedSynchronizer</span><br><span class="hljs-comment">     * to simplify acquiring and releasing a lock surrounding each</span><br><span class="hljs-comment">     * task execution.  This protects against interrupts that are</span><br><span class="hljs-comment">     * intended to wake up a worker thread waiting for a task from</span><br><span class="hljs-comment">     * instead interrupting a task being run.  We implement a simple</span><br><span class="hljs-comment">     * non-reentrant mutual exclusion lock rather than use</span><br><span class="hljs-comment">     * ReentrantLock because we do not want worker tasks to be able to</span><br><span class="hljs-comment">     * reacquire the lock when they invoke pool control methods like</span><br><span class="hljs-comment">     * setCorePoolSize.  Additionally, to suppress interrupts until</span><br><span class="hljs-comment">     * the thread actually starts running tasks, we initialize lock</span><br><span class="hljs-comment">     * state to a negative value, and clear it upon start (in</span><br><span class="hljs-comment">     * runWorker).</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span><br>        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><br>    &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * This class will never be serialized, but we provide a</span><br><span class="hljs-comment">         * serialVersionUID to suppress a javac warning.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6138294804551838833L</span>;<br><br>        <span class="hljs-comment">/** Thread this worker is running in.  Null if factory fails. */</span><br>        <span class="hljs-keyword">final</span> Thread thread;<br>        <span class="hljs-comment">/** Initial task to run.  Possibly null. */</span><br>        Runnable firstTask;<br>        <span class="hljs-comment">/** Per-thread task counter */</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Creates with given first task and thread from ThreadFactory.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> firstTask the first task (null if none)</span><br><span class="hljs-comment">         */</span><br>        Worker(Runnable firstTask) &#123;<br>            <span class="hljs-comment">// inhibit == prohibit，就是禁止中断的意思，中断前也要求锁</span><br>            setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>            <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>            <span class="hljs-comment">// 这个方法是调用的线程池的 factory，</span><br>            <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>        &#125;<br><br>        <span class="hljs-comment">/** Delegates main run loop to outer runWorker  */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 这个方法是线程池里的方法，这样交互委托可以实现上下文的 merge，以当前的线程去读外部的上下文</span><br>            runWorker(<span class="hljs-built_in">this</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// Lock methods</span><br>        <span class="hljs-comment">// 0 代表常态无锁</span><br>        <span class="hljs-comment">// 1 代表常态加锁</span><br>        <span class="hljs-comment">// The value 0 represents the unlocked state.</span><br>        <span class="hljs-comment">// The value 1 represents the locked state.</span><br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 启动的时候使用的-1 是一种“启动时才能使用的锁”，这里也包含进来了</span><br>            <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// aqs 最关键的加锁方法，锁的标记位可以自定义</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>            <span class="hljs-comment">// 这里体现了经典的设计模式，先 cas 把标记位加上去，然后绑定线程。这里要求线程安全的写只有锁的 cas，线程的归属却不是线程安全的</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>            <span class="hljs-comment">// 恰好和上一个方法反过来</span><br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            <span class="hljs-comment">// 强制解锁，无 cas</span><br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>        &#123; acquire(<span class="hljs-number">1</span>); &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>      &#123; release(<span class="hljs-number">1</span>); &#125;<br>        <span class="hljs-comment">// 锁只支持互斥锁定模式，不支持共享锁定模式</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br>        <br>        <span class="hljs-comment">// 提供一种中断 worker（包括内部线程）的工作模式</span><br>        <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;<br>            Thread t;<br>            <span class="hljs-comment">// -1 和 1 不允许中断</span><br>            <span class="hljs-comment">// 在一个括号里实现了漂亮的取数操作</span><br>            <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp;<br>            <span class="hljs-comment">// 线程没有被中断的时候可以被中断</span><br>            !t.isInterrupted()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    t.interrupt();<br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>在一个工作线程里，worker delegate 调用给线程池的 runWorker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Main worker run loop.  Repeatedly gets tasks from queue and</span><br><span class="hljs-comment">     * executes them, while coping with a number of issues:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 1. We may start out with an initial task, in which case we</span><br><span class="hljs-comment">     * don&#x27;t need to get the first one. Otherwise, as long as pool is</span><br><span class="hljs-comment">     * running, we get tasks from getTask. If it returns null then the</span><br><span class="hljs-comment">     * worker exits due to changed pool state or configuration</span><br><span class="hljs-comment">     * parameters.  Other exits result from exception throws in</span><br><span class="hljs-comment">     * external code, in which case completedAbruptly holds, which</span><br><span class="hljs-comment">     * usually leads processWorkerExit to replace this thread.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. Before running any task, the lock is acquired to prevent</span><br><span class="hljs-comment">     * other pool interrupts while the task is executing, and then we</span><br><span class="hljs-comment">     * ensure that unless pool is stopping, this thread does not have</span><br><span class="hljs-comment">     * its interrupt set.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. Each task run is preceded by a call to beforeExecute, which</span><br><span class="hljs-comment">     * might throw an exception, in which case we cause thread to die</span><br><span class="hljs-comment">     * (breaking loop with completedAbruptly true) without processing</span><br><span class="hljs-comment">     * the task.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 4. Assuming beforeExecute completes normally, we run the task,</span><br><span class="hljs-comment">     * gathering any of its thrown exceptions to send to afterExecute.</span><br><span class="hljs-comment">     * We separately handle RuntimeException, Error (both of which the</span><br><span class="hljs-comment">     * specs guarantee that we trap) and arbitrary Throwables.</span><br><span class="hljs-comment">     * Because we cannot rethrow Throwables within Runnable.run, we</span><br><span class="hljs-comment">     * wrap them within Errors on the way out (to the thread&#x27;s</span><br><span class="hljs-comment">     * UncaughtExceptionHandler).  Any thrown exception also</span><br><span class="hljs-comment">     * conservatively causes thread to die.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 5. After task.run completes, we call afterExecute, which may</span><br><span class="hljs-comment">     * also throw an exception, which will also cause thread to</span><br><span class="hljs-comment">     * die. According to JLS Sec 14.20, this exception is the one that</span><br><span class="hljs-comment">     * will be in effect even if task.run throws.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The net effect of the exception mechanics is that afterExecute</span><br><span class="hljs-comment">     * and the thread&#x27;s UncaughtExceptionHandler have as accurate</span><br><span class="hljs-comment">     * information as we can provide about any problems encountered by</span><br><span class="hljs-comment">     * user code.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>        <span class="hljs-comment">// 这里为什么不使用 worker 里面的线程呢？</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-comment">// 做一个置换/置空操作</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>        w.firstTask = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 在对象初始化的时候触发了加锁，在线程启动的时候触发了解锁。线程池的 shutdown 方法本身会 interrupt worker，这里不允许在锁周期里面 interrupt worker</span><br>        w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>        <span class="hljs-comment">// 突然完成默认为真</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// getTask 里封装了复杂的取任务流程，这里在一个表达式里面实现了漂亮的取任务操作</span><br>            <span class="hljs-comment">// 本线程只有在 getTask 取不到的时候才退出</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 只在 run 一个 task 的时候锁定自己一次，不可重入</span><br>                w.lock();<br>                <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>                <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>                <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>                <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>                <span class="hljs-comment">// 如果线程池本身已经进入停止及以后状态，则直接求 工作线程的中断状态。否则，做一轮线程的中断，再求线程池状态（中断居然会影响线程池的状态，很奇怪？），再求工作线程的中断状态。这里有一个比较炫技的地方，wt 和 currentThread 都是当前线程，但偏偏不使用 wt 里的线程        </span><br>                <span class="hljs-comment">// 这里的思想是：不能由命令触发中断，必须由状态触发中断</span><br>                <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                    <span class="hljs-comment">// 或者</span><br>                     (Thread.interrupted() &amp;&amp;<br>                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                    !wt.isInterrupted())<br>                    <span class="hljs-comment">// 遇到这些情况，就要中断 wt，在这里。所以内部线程是由 getTask 内部的流程中断的，然后才去执行下面的 run，看看下面的 run 会不会响应</span><br>                    wt.interrupt();<br>                <span class="hljs-comment">// 线程的中断也不会影响接下来的 task.run()</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 通常这个方法是空方法</span><br>                    beforeExecute(wt, task);<br>                    <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// runnable.run()</span><br>                        task.run();<br>                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                        <span class="hljs-comment">// 有这样的写法就意味着要在 finally 留存 thrown</span><br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-comment">// thrown 是给 afterExecute 准备的</span><br>                        afterExecute(task, thrown);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                    w.completedTasks++;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 只有在 getTask 取不到的时候退出，这个值才是false，其他时候都算是“突然退出”</span><br>            completedAbruptly = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            processWorkerExit(w, completedAbruptly);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 阻塞式获取任务。</span><br>    <span class="hljs-comment">// 遇到异常情况给上游的返回值是 null：</span><br>    <span class="hljs-comment">// 1. 有超过maximumPoolSize 的线程数，这时候返回 null 会导致它退出。</span><br>    <span class="hljs-comment">// 2. 线程池 stopped 了（由 shutdownNow 来触发，比 shutdown 更严厉），这时候线程池也会用 null 的方式指示线程有序退出</span><br>    <span class="hljs-comment">// 3. 线程池 shutdown，且队列为空（其实光是本条件就可以返回 null，只是如果线程池还在工作中，队列应该让 getTask 的线程阻塞等待）</span><br>    <span class="hljs-comment">// 4. 线程超时。真正的超时实际上有两种：线程数超过 core 且超时，连 core 都允许超时且超时</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Performs blocking or timed wait for a task, depending on</span><br><span class="hljs-comment">     * current configuration settings, or returns null if this worker</span><br><span class="hljs-comment">     * must exit because of any of:</span><br><span class="hljs-comment">     * 1. There are more than maximumPoolSize workers (due to</span><br><span class="hljs-comment">     *    a call to setMaximumPoolSize).</span><br><span class="hljs-comment">     * 2. The pool is stopped.</span><br><span class="hljs-comment">     * 3. The pool is shutdown and the queue is empty.</span><br><span class="hljs-comment">     * 4. This worker timed out waiting for a task, and timed-out</span><br><span class="hljs-comment">     *    workers are subject to termination (that is,</span><br><span class="hljs-comment">     *    &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span><br><span class="hljs-comment">     *    both before and after the timed wait, and if the queue is</span><br><span class="hljs-comment">     *    non-empty, this worker is not the last thread in the pool.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> task, or null if the worker must exit, in which case</span><br><span class="hljs-comment">     *         workerCount is decremented</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>        <span class="hljs-comment">// 在自旋里面</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>            <br>            <span class="hljs-comment">// 第一类情况返回 null</span><br>            <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>            <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>                decrementWorkerCount();<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;<br><br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>            <span class="hljs-comment">// Are workers subject to culling? 是否要强制减少线程数？是的话就要引入计时了</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>            <span class="hljs-comment">// 超时返回 null 的场景，但注意这里要能减掉一个线程才能返回 null。</span><br>            <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>                &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>                <span class="hljs-comment">// 减线程数目（不一定成功，如 wc == 0 也可能进入这个语句块）</span><br>                <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 不能减线程则 cas 失败，进入大循环里继续</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                    workQueue.take();<br>                <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> r;<br>                timedOut = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>                timedOut = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="回收线程">回收线程</h4>
<blockquote>
<p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反映线程现在的执行状态。</p>
<p>1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。<br>
2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p>
</blockquote>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="线程池回收线程的过程.png"><br>
<img src="%E7%BA%BF%E7%A8%8B%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B.png" alt="线程销毁流程.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// 处理一些关闭和簿记工作：</span><br>    <span class="hljs-comment">// 1. 只能被从 worker 线程里调用，也就是说只能在 runWorker 方法里被调用</span><br>    <span class="hljs-comment">// 2. 先尝试把 workerCount 减一</span><br>    <span class="hljs-comment">// 3. 把 worker 从工作集里移除</span><br>    <span class="hljs-comment">// 4. 尝试终结线程池</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Performs cleanup and bookkeeping for a dying worker. Called</span><br><span class="hljs-comment">     * only from worker threads. Unless completedAbruptly is set,</span><br><span class="hljs-comment">     * assumes that workerCount has already been adjusted to account</span><br><span class="hljs-comment">     * for exit.  This method removes thread from worker set, and</span><br><span class="hljs-comment">     * possibly terminates the pool or replaces the worker if either</span><br><span class="hljs-comment">     * it exited due to user task exception or if fewer than</span><br><span class="hljs-comment">     * corePoolSize workers are running or queue is non-empty but</span><br><span class="hljs-comment">     * there are no workers.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> completedAbruptly if the worker died due to user exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;<br>        <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>            <span class="hljs-comment">// 只要能够成功减一就行了</span><br>            decrementWorkerCount();<br>        <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 不管怎样退出，都把 worker 的完成任务数加总到线程池的总数里</span><br>            completedTaskCount += w.completedTasks;<br>            <span class="hljs-comment">// 移除本 worker</span><br>            workers.remove(w);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// 每个 worker 终结都尝试终结线程池</span><br>        tryTerminate(); <br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 如果线程池没有真的被真的关闭，可以加减线程池里的线程</span><br>        <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>            <span class="hljs-comment">// 如果线程池正常关闭</span><br>            <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>                <span class="hljs-comment">// allowCoreThreadTimeOut 通常为 false，所以线程池的最小值应该是 corePoolSize，否则核心线程数可以归零</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>                <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                    <span class="hljs-comment">// 如果缓冲队列不空，则最小线程数需要维持在 1</span><br>                    min = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                    <span class="hljs-comment">// 如果当前工作线程数大于等于 min，则直接退出</span><br>                    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>            &#125;<br>            <span class="hljs-comment">// 反之则认为工作线程数小于 min，需要增加非核心线程（增加非核心线程实际上也是在增加核心线程），这里的设计思想是任何一个线程退出都应该增加一个线程，所以就当作非核心线程增加了</span><br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 这个方法在线程退出时只关闭一个【空闲线程】，但在线程池关闭等场景下，会关闭所有的空闲线程，这样线程池最终就关闭了-因为每个worker 退出的时候最少都会关闭一个空闲线程，全局的线程最终得以全部关闭。但线程池的核心参数如 keepAliveTime、corePoolSize、maximumPoolSize 有变化的时候，都会触发全部空闲线程关闭</span><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Interrupts threads that might be waiting for tasks (as</span><br><span class="hljs-comment">     * indicated by not being locked) so they can check for</span><br><span class="hljs-comment">     * termination or configuration changes. Ignores</span><br><span class="hljs-comment">     * SecurityExceptions (in which case some threads may remain</span><br><span class="hljs-comment">     * uninterrupted).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> onlyOne If true, interrupt at most one worker. This is</span><br><span class="hljs-comment">     * called only from tryTerminate when termination is otherwise</span><br><span class="hljs-comment">     * enabled but there are still other workers.  In this case, at</span><br><span class="hljs-comment">     * most one waiting worker is interrupted to propagate shutdown</span><br><span class="hljs-comment">     * signals in case all threads are currently waiting.</span><br><span class="hljs-comment">     * Interrupting any arbitrary thread ensures that newly arriving</span><br><span class="hljs-comment">     * workers since shutdown began will also eventually exit.</span><br><span class="hljs-comment">     * To guarantee eventual termination, it suffices to always</span><br><span class="hljs-comment">     * interrupt only one idle worker, but shutdown() interrupts all</span><br><span class="hljs-comment">     * idle workers so that redundant workers exit promptly, not</span><br><span class="hljs-comment">     * waiting for a straggler task to finish.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>                <span class="hljs-comment">// 能够被关闭的线程是一个能够拿到内部锁的线程</span><br>                <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 中断，这个线程内部的工作线程能不能响应看 runnable 内部的实现了</span><br>                        t.interrupt();<br>                    &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        w.unlock();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (onlyOne)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="线程池使用中可能遇到的问题">线程池使用中可能遇到的问题</h3>
<p>线程池的调参有几个难点：</p>
<ol>
<li>如果核心线程数过小，则吞吐可能不够，遇到流量矛刺可能导致 RejectExecutionException；但值得警惕的是，如果核心线程数很大，可能导致频繁的上下文切换和过多的资源消耗（不管是 cpu 时间片还是操作系统的内核线程）。</li>
<li>如果队列过长，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。</li>
</ol>
<p>那么，如何计算这些参数呢？<br>
有一个基本的原则是：</p>
<ol>
<li>计算密集型的线程数本身应该尽量贴进 cpu 核数。</li>
<li>io 密集型的线程数要注意伸缩，要配合阻塞队列使用，要有承受拒绝失败的的准备。</li>
</ol>
<p>我们常见的计算方式主要来自于《Java并发编程实战》：</p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="线程池计算公式.png"></p>
<p>现实中可选的线程数计算公式最好是取一个并发 qps 数和 cpu 数的折中。通常可以认为 单任务的 rt/1ms 可以得到单一线程的吞吐数，qps 除以吞吐数可以得到 qps 相应的线程数，但这个方案没有考虑cpu 核数和上下文切换的问题。所以这样算出来的线程数的实际 qps 表现应该低于理论 qps，但可以通过估算和压测不断让理论值逼近实际值。</p>
<h3 id="线程池的可替换方案">线程池的可替换方案</h3>
<p>其他可替代方案，都不如线程池的调优方案成熟（<strong>在可以使用新技术的前提下，我们是否还有调优旧方案的魄力呢？</strong>）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">优势</th>
<th style="text-align:center">劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Disruptor框架</td>
<td style="text-align:center">线程池内部是通过一个工作队列去维护任务的执行的，它有一个根本性的缺陷：连续争用问题。也就是多个线程在申请任务时，为了合理地分配任务要付出锁资源，对比快速的任务执行来说，这部分申请的损耗是巨大的。高性能进程间消息库LMAX使用了一个叫作环形缓冲的数据结构，用这种这个特殊的数据结构替代队列，将会避免申请任务时出现的连续争用状况。</td>
<td style="text-align:center">避免连续争用，性能更佳</td>
<td style="text-align:center">缺乏线程管理的能力，使用场景较少</td>
</tr>
<tr>
<td style="text-align:center">协程框架</td>
<td style="text-align:center">协程是一种用户态的轻量级线程，其拥有自己的寄存器上下文和栈，当调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。这种切换上下文的方式要小于线程的开销。在瓶颈侧重IO的情况，使用协程获得并发性要优于使用线程。</td>
<td style="text-align:center">侧重IO情况时，性能更佳。与多线程策略无冲突，可结合使用</td>
<td style="text-align:center">在Java中缺乏成熟的应用</td>
</tr>
<tr>
<td style="text-align:center">Actor框架</td>
<td style="text-align:center">Actor模型通过维护多个Actor去处理并发的任务，它放弃了直接使用线程去获取并发性，而是自己定义了一系列系统组件应该如何动作和交互的通用规则，不需要开发者直接使用线程。通过在原生的线程或协程的级别上做了更高层次的封装，只需要开发者关心每个Actor的逻辑即可实现并发操作。由于避免了直接使用锁，很大程度解决了传统并发编程模式下大量依赖悲观锁导致的资源竞争情况。</td>
<td style="text-align:center">无锁策略，性能更佳，避免直接使用线程，安全性更高</td>
<td style="text-align:center">在Java中缺乏成熟的应用，内部复杂，难以排查和调试</td>
</tr>
</tbody>
</table>
<p>缺乏管控能力就不适合调优。</p>
<h3 id="最终解决方案">最终解决方案</h3>
<p>通过监控线程池负载，制定告警策略：</p>
<ol>
<li>线程池活跃度 = activeCount/maximumPoolSize。看看这个值是不是趋近于 1。</li>
<li>监控队列的capacity 和 size 的比例。</li>
<li>监控 RejectExecutionException 的出现。</li>
</ol>
<p>加引入线程池动态管控能力，基于告警制定 sop，确定是否要动态调节线程数和拒绝策略。</p>
<p>如果还是解决不了问题，需要考虑全局动态扩容的方案。</p>
<h2 id="线程组">线程组</h2>
<p>线程组提供一个“集合”，开源把一群线程归于一处，可以批量 interrupt/stop/suspend。<br>
但这个方案是很危险的，使用线程池和并发安全的 Collection 都可以管理好线程。</p>
<h2 id="completionstage">CompletionStage</h2>
<p>这是定义“可能是”异步计算的一个阶段，可能被其他阶段触发，也可以触发其他阶段。它是 CompletableFuture 的父接口。</p>
<p>它有一个特点，大量非 void 方法返回值都是 CompletionStage 类型，这样既允许 builder 模式，也允许各种 transformation 模式。</p>
<h1>小技巧</h1>
<h2 id="如何处理任务超时问题">如何处理任务超时问题</h2>
<h3 id="方法1：使用-futuretask-的实现">方法1：使用 FutureTask 的实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;Map&lt;String, Object&gt;&gt; future = executor.submit(() -&gt; getFeatures(context, zeusSceneId));<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 穷人版超时：最简单的超时不是使用 circuit breaker，而是使用 FutureTask 的缺省超时实现，这个方案取不到值的时候底层会返回 TimeoutException，只要捕获这个超时就可以走入 fallback 逻辑</span><br>                features.putAll(future.get(paramCollectTimeout, TimeUnit.MILLISECONDS));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;<br>                <span class="hljs-comment">// fallback logic</span><br>            &#125;<br>            <br><span class="hljs-comment">// 其中 FutureTask 的实现是：</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>        <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>        <span class="hljs-comment">// 等待结束后抛出异常而不是空指针，否则调用 report 方法</span><br>        <span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>            (s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>        <span class="hljs-keyword">return</span> report(s);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法2：使用条件变量">方法2：使用条件变量</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发出调用</span><br> condition.await<br><span class="hljs-comment">// 非阻塞地调用 isDone 方法，抛出异常或取值</span><br><span class="hljs-comment">// 这是方法1 的泛化实现</span><br></code></pre></td></tr></table></figure>
<h3 id="方法3：使用-countdownlatch-cyclicbarrier">方法3：使用 countDownLatch/CyclicBarrier</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发出调用</span><br>无锁的 await<br><span class="hljs-comment">// 非阻塞地调用 isDone 方法，抛出异常或取值，但要注意其他线程对 done 状态的维护</span><br></code></pre></td></tr></table></figure>
<p>这个方法不需要依赖于 ReentrantLock，是通过纯 AQS 实现的，见 CountDownLatch 源码。</p>
<h3 id="自定义线程池实现自定义中断">自定义线程池实现自定义中断</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">待补充<br></code></pre></td></tr></table></figure>
<p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">《一行一行源码分析清楚AbstractQueuedSynchronizer》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《Java线程池实现原理及其在美团业务中的实践》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016058789">《Keep Coding》</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2021/10/07/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">https://magicliang.github.io/2021/10/07/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/2021/10/07/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-117.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a><a class="pagination-related" href="/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/img/wall-paper-175.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-10</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1">线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级： 线程安全的分类 不可变 不可变的数据，都是线程安全的。不可变的对象引用，加上所有field都是不可变的。如果有得选，尽量连方法都是final的。 绝对线程安全 Vector不是线程安全的。它也会出现并发修改时 Out of Range 的异常（注意，不是 ConcurrentModification 的异常）。 相对线程安全 需要保证对这个对象的单独操作是线程安全的，在调用的时候不需要加上额外的保障措施。对于特定顺序的连续操作，就需要额外的同步来保证调用的正确性了。 线程兼容 可以通过特殊手段做到线程安全的普通类，绝大部分类都属于相对线程安全的。 线程对立 线程对立，是不管调用端是否采取了同步措施，都无法在多线程环境中使用的代码。常见的线程对立的操作还有 suspend()，resume()， System....</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-114.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">上下文 卡表和 RSet（Remember Set），是 JVM 为了解决分代收集时，live set 扫描需要穿梭到不同的代的时候的效率问题。 使用缓存表来提高查询效率，是化顺序查找为部分随机查找的一种常用的设计思路。 例如，在传统的计算机体系结构中，当我们把内存分成页以后，会有一个页表，页表又会有一个快表，作为一个中间缓存项，来帮助我们查找我们需要使用的页表项（table entry）。 JVM 在进行垃圾收集的时候，有一项非常重要的工作就是确定这一次垃圾收集的对象到底有多少个，即确定 live set 的范围。 对于新生代垃圾收集器而言，这个问题又有其特殊之处。根据 JVM 的弱分代收集假设（weak generational hypothesis）的存在，每次垃圾收集的时候，新生代的扫描范围可能很大，但新生代的 live set 不应该太大。card table/Remember Set 的设计目的，就是尽量减少无用的垃圾扫描范围，使用类似操作系统或者数据库的脏页表的形式，来做类似快表的查询。 卡表（card table）  卡表是 CMS 的解决方案。 卡表通常在 JV...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-144.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a><a class="pagination-related" href="/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" title="重述双亲委派模型"><img class="cover" src="/img/wall-paper-168.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-05</div><div class="info-item-2">重述双亲委派模型</div></div><div class="info-2"><div class="info-item-1">何时加载类  遇到 new、getstatic、putstatic 等指令时。 对类进行反射调用的时候。 初始化某个类的子类的时候。 虚拟机启动时会先加载设置的程序主类。 使用 dynamic 动态语言支持等相关特性时。  从 Java 到 cpp 源码分析  JVM 默认用于加载用户程序的ClassLoader为AppClassLoader，不过无论是什么ClassLoader，它的根父类都是java.lang.ClassLoader。在上面那个例子中，loadClass（）方法最终会调用到ClassLoader.definClass1（）中，这是一个 Native 方法。  12static native Class&lt;?&gt; defineClass1(ClassLoader loader, String name, byte[] b, int off, int len,                                        ProtectionDomain pd, String source);   definClass1（）对应的 JNI ...</div></div></div></a><a class="pagination-related" href="/2020/03/08/JMX-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9/" title="JMX 深度历险"><img class="cover" src="/img/wall-paper-57.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-08</div><div class="info-item-2">JMX 深度历险</div></div><div class="info-2"><div class="info-item-1">JMX 常见指标 JVM 指标 系统指标    System 相关指标 描述     system.load.average 系统load，如果是docker，此指标收集的物理机的load   cpu.system.load.percent 系统所有进程占用cpu的百分比   cpu.jvm.load.percent jvm占用cpu的百分比   system.process.used.phyical.memory 系统使用的物理内存   system.process.used.swap.size 系统使用的swap内存    JVM 内存指标    JVM相关指标 描述     jvm.gc.count GC的次数   jvm.gc.time GC的时间，单位毫秒   jvm.younggc.count 年轻代GC的次数 ，包括的GC算法（Copy，ParNew，PS Scavenge，G1 Young Generation）   jvm.younggc.time 年轻代GC的时间，单位毫秒   jvm.fullgc.count 年老代GC的次数，包括的GC算法   jvm.f...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">写在前面的话</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Java 线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%97%E4%B8%BE"><span class="toc-number">2.1.</span> <span class="toc-text">线程状态列举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">2.1.1.</span> <span class="toc-text">NEW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runnable"><span class="toc-number">2.1.2.</span> <span class="toc-text">RUNNABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocked"><span class="toc-number">2.1.3.</span> <span class="toc-text">BLOCKED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waiting"><span class="toc-number">2.1.4.</span> <span class="toc-text">WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timed-waiting"><span class="toc-number">2.1.5.</span> <span class="toc-text">TIMED_WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#terminated"><span class="toc-number">2.1.6.</span> <span class="toc-text">TERMINATED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.7.</span> <span class="toc-text">几种线程状态的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E7%9A%84%E5%88%87%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.</span> <span class="toc-text">特别的切换方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#locksupport-park"><span class="toc-number">2.2.1.</span> <span class="toc-text">LockSupport.park</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-number">2.2.2.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">2.2.3.</span> <span class="toc-text">join</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">3.1.</span> <span class="toc-text">Volatile</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.1.</span> <span class="toc-text">总体设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">Unsafe 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-field"><span class="toc-number">4.2.1.</span> <span class="toc-text">获取 field</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#increaseandget-%E4%B8%8E-getandincrease"><span class="toc-number">4.2.2.</span> <span class="toc-text">increaseAndGet 与 getAndIncrease</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">4.2.3.</span> <span class="toc-text">自旋锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.</span> <span class="toc-text">函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-runnable-%E5%92%8C-callable"><span class="toc-number">4.3.1.</span> <span class="toc-text">区别 Runnable 和 Callable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.4.</span> <span class="toc-text">synchronized 的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#locksupport"><span class="toc-number">4.5.</span> <span class="toc-text">LockSupport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%95%88%E5%BA%94-memory-consistency-effects"><span class="toc-number">4.6.</span> <span class="toc-text">内存一致性效应（Memory consistency effects）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E9%94%81"><span class="toc-number">4.7.</span> <span class="toc-text">主流锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">4.7.1.</span> <span class="toc-text">悲观锁与乐观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aqs-abstractqueuedsynchronizer"><span class="toc-number">4.8.</span> <span class="toc-text">AQS（AbstractQueuedSynchronizer）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.8.1.</span> <span class="toc-text">AQS 的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BF%86"><span class="toc-number">4.8.1.1.</span> <span class="toc-text">简要记忆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs%E7%9A%84%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">4.8.2.</span> <span class="toc-text">AQS的五层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clh-queue"><span class="toc-number">4.8.3.</span> <span class="toc-text">CLH queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%87%E5%87%86%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">4.8.4.</span> <span class="toc-text">互斥框架的标准伪代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.8.5.</span> <span class="toc-text">Node 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.8.6.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81"><span class="toc-number">4.8.6.1.</span> <span class="toc-text">加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#clh-%E4%B8%BB%E6%A1%86%E6%9E%B6"><span class="toc-number">4.8.6.1.1.</span> <span class="toc-text">CLH 主框架</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#tryacquire"><span class="toc-number">4.8.6.1.1.1.</span> <span class="toc-text">tryAcquire</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#addwaiter"><span class="toc-number">4.8.6.1.1.2.</span> <span class="toc-text">addWaiter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#enq"><span class="toc-number">4.8.6.1.1.3.</span> <span class="toc-text">enq</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#acquirequeued"><span class="toc-number">4.8.6.1.1.4.</span> <span class="toc-text">acquireQueued</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sethead"><span class="toc-number">4.8.6.1.1.5.</span> <span class="toc-text">setHead</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#shouldparkafterfailedacquire"><span class="toc-number">4.8.6.1.1.6.</span> <span class="toc-text">shouldParkAfterFailedAcquire</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#parkandcheckinterrupt"><span class="toc-number">4.8.6.1.1.7.</span> <span class="toc-text">parkAndCheckInterrupt</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#cancelacquire"><span class="toc-number">4.8.6.1.1.8.</span> <span class="toc-text">cancelAcquire</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">4.8.6.1.2.</span> <span class="toc-text">公平锁与非公平锁</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%94%81"><span class="toc-number">4.8.6.2.</span> <span class="toc-text">解锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#release"><span class="toc-number">4.8.6.2.1.</span> <span class="toc-text">release</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#tryrelease"><span class="toc-number">4.8.6.2.1.1.</span> <span class="toc-text">tryRelease</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#unparksuccessor"><span class="toc-number">4.8.6.2.1.2.</span> <span class="toc-text">unparkSuccessor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E4%B8%8E%E5%85%B1%E4%BA%AB"><span class="toc-number">4.8.6.3.</span> <span class="toc-text">独占与共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.8.7.</span> <span class="toc-text">条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.8.7.1.</span> <span class="toc-text">条件对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.8.7.1.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#await"><span class="toc-number">4.8.7.1.2.</span> <span class="toc-text">await</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#addconditionwaiter"><span class="toc-number">4.8.7.1.2.1.</span> <span class="toc-text">addConditionWaiter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#fullyrelease"><span class="toc-number">4.8.7.1.2.2.</span> <span class="toc-text">fullyRelease</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#unlinkcancelledwaiters"><span class="toc-number">4.8.7.1.2.3.</span> <span class="toc-text">unlinkCancelledWaiters</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#isonsyncqueue"><span class="toc-number">4.8.7.1.2.4.</span> <span class="toc-text">isOnSyncQueue</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#isonsyncqueue"><span class="toc-number">4.8.7.1.2.5.</span> <span class="toc-text">isOnSyncQueue</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#transferaftercancelledwait"><span class="toc-number">4.8.7.1.2.6.</span> <span class="toc-text">transferAfterCancelledWait</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#reportinterruptafterwait"><span class="toc-number">4.8.7.1.2.7.</span> <span class="toc-text">reportInterruptAfterWait</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#signal"><span class="toc-number">4.8.7.1.3.</span> <span class="toc-text">signal</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#dosignal"><span class="toc-number">4.8.7.1.3.1.</span> <span class="toc-text">doSignal</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-number">4.8.8.</span> <span class="toc-text">AQS 与中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E4%B8%AD%E6%96%AD%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.8.8.1.</span> <span class="toc-text">两种中断模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E4%B8%AD%E6%96%AD%E7%9A%84%E6%A0%87%E5%87%86%E6%96%B9%E6%B3%95"><span class="toc-number">4.8.8.2.</span> <span class="toc-text">检测中断的标准方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%94%81%E7%9A%84%E8%AE%A1%E6%97%B6waiting%E6%96%B9%E6%B3%95"><span class="toc-number">4.8.8.3.</span> <span class="toc-text">非锁的计时waiting方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#locksupport-park-%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">4.8.8.4.</span> <span class="toc-text">LockSupport.park 的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-number">4.8.8.5.</span> <span class="toc-text">lock 与中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.8.8.6.</span> <span class="toc-text">内部方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#countdownlatch"><span class="toc-number">4.9.</span> <span class="toc-text">CountDownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.9.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await"><span class="toc-number">4.9.2.</span> <span class="toc-text">await</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#acquiresharedinterruptibly"><span class="toc-number">4.9.2.1.</span> <span class="toc-text">acquireSharedInterruptibly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryacquireshared"><span class="toc-number">4.9.2.2.</span> <span class="toc-text">tryAcquireShared</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doacquiresharedinterruptibly"><span class="toc-number">4.9.2.3.</span> <span class="toc-text">doAcquireSharedInterruptibly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setheadandpropagate"><span class="toc-number">4.9.2.4.</span> <span class="toc-text">setHeadAndPropagate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doreleaseshared"><span class="toc-number">4.9.2.5.</span> <span class="toc-text">doReleaseShared</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#countdown"><span class="toc-number">4.9.3.</span> <span class="toc-text">countDown</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#releaseshared"><span class="toc-number">4.9.3.1.</span> <span class="toc-text">releaseShared</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryreleaseshared"><span class="toc-number">4.9.3.2.</span> <span class="toc-text">tryReleaseShared</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cyclicbarrier"><span class="toc-number">4.10.</span> <span class="toc-text">CyclicBarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8Ccountdownlatch-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.10.1.</span> <span class="toc-text">和CountDownLatch 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E8%80%85%E7%9A%84%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.10.2.</span> <span class="toc-text">作者的官方示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%8B%86%E8%A7%A3"><span class="toc-number">4.10.3.</span> <span class="toc-text">成员拆解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.10.4.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await"><span class="toc-number">4.10.5.</span> <span class="toc-text">await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dowait"><span class="toc-number">4.10.6.</span> <span class="toc-text">dowait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA-breakbarrier"><span class="toc-number">4.10.7.</span> <span class="toc-text">异常退出 breakBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E9%80%80%E5%87%BA-nextgeneration"><span class="toc-number">4.10.8.</span> <span class="toc-text">正常退出 nextGeneration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE-reset"><span class="toc-number">4.10.9.</span> <span class="toc-text">重置 reset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">4.10.10.</span> <span class="toc-text">统计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#isbroken"><span class="toc-number">4.10.10.1.</span> <span class="toc-text">isBroken</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getnumberwaiting"><span class="toc-number">4.10.10.2.</span> <span class="toc-text">getNumberWaiting</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#semaphore"><span class="toc-number">4.11.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.11.1.</span> <span class="toc-text">官方示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.11.2.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90%EF%BC%9A%E5%9B%9B%E5%A4%A7-acquire-%E6%96%B9%E6%B3%95"><span class="toc-number">4.11.3.</span> <span class="toc-text">获取资源：四大 acquire 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#acquireshared"><span class="toc-number">4.11.3.1.</span> <span class="toc-text">acquireShared</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryacquireshared"><span class="toc-number">4.11.3.2.</span> <span class="toc-text">tryAcquireShared</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3"><span class="toc-number">4.11.3.2.1.</span> <span class="toc-text">公平</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3"><span class="toc-number">4.11.3.2.2.</span> <span class="toc-text">非公平</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">4.11.4.</span> <span class="toc-text">释放资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tryreleaseshared"><span class="toc-number">4.11.4.1.</span> <span class="toc-text">tryReleaseShared</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.12.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">4.12.1.</span> <span class="toc-text">线程池继承体系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#executor-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.12.1.1.</span> <span class="toc-text">Executor 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#executorservice-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.12.1.2.</span> <span class="toc-text">ExecutorService 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abstractexecutorservice"><span class="toc-number">4.12.1.3.</span> <span class="toc-text">AbstractExecutorService</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#threadpoolexecutor"><span class="toc-number">4.12.1.3.1.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#forkjoinpool"><span class="toc-number">4.12.1.3.2.</span> <span class="toc-text">ForkJoinPool</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#the-executors"><span class="toc-number">4.12.1.4.</span> <span class="toc-text">The Executors</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8A%A4%E8%87%AA%E8%BA%AB%E7%8A%B6%E6%80%81"><span class="toc-number">4.12.2.</span> <span class="toc-text">线程池如何维护自身状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.12.2.1.</span> <span class="toc-text">尝试关闭线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.12.3.</span> <span class="toc-text">线程池如何管理任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">4.12.3.1.</span> <span class="toc-text">任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">4.12.3.1.1.</span> <span class="toc-text">提交任务调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%BC%93%E5%86%B2"><span class="toc-number">4.12.3.1.2.</span> <span class="toc-text">任务缓冲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%94%B3%E8%AF%B7"><span class="toc-number">4.12.3.1.3.</span> <span class="toc-text">任务申请</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.12.4.</span> <span class="toc-text">线程池如何管理线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.12.4.1.</span> <span class="toc-text">尝试增加线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="toc-number">4.12.4.2.</span> <span class="toc-text">线程执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.12.4.3.</span> <span class="toc-text">回收线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.12.5.</span> <span class="toc-text">线程池使用中可能遇到的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88"><span class="toc-number">4.12.6.</span> <span class="toc-text">线程池的可替换方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.12.7.</span> <span class="toc-text">最终解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-number">4.13.</span> <span class="toc-text">线程组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completionstage"><span class="toc-number">4.14.</span> <span class="toc-text">CompletionStage</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">如何处理任务超时问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E4%BD%BF%E7%94%A8-futuretask-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">方法1：使用 FutureTask 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">方法2：使用条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E4%BD%BF%E7%94%A8-countdownlatch-cyclicbarrier"><span class="toc-number">5.1.3.</span> <span class="toc-text">方法3：使用 countDownLatch&#x2F;CyclicBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E6%96%AD"><span class="toc-number">5.1.4.</span> <span class="toc-text">自定义线程池实现自定义中断</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>