<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>高级算法设计和分析技术 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="思维导图 常见算法题 常见算法题.xmind 常用数学公式    公式 名称 说明     ∑i&#x3D;1ni&#x3D;n(n+1)2\sum\limits_{i&#x3D;1}^{n}i&#x3D;\frac{n(n+1)}{2}i&#x3D;1∑n​i&#x3D;2n(n+1)​ 等差数列和 1+2+3+…+n   ∑i&#x3D;1n(2i−1)&#x3D;n2\sum\limits_{i&#x3D;1}^{n}(2i-1)&#x3D;n^{2}i&#x3D;1∑n​(2i−1)&#x3D;n2 奇数和">
<meta property="og:type" content="article">
<meta property="og:title" content="高级算法设计和分析技术">
<meta property="og:url" content="https://magicliang.github.io/2024/10/07/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="思维导图 常见算法题 常见算法题.xmind 常用数学公式    公式 名称 说明     ∑i&#x3D;1ni&#x3D;n(n+1)2\sum\limits_{i&#x3D;1}^{n}i&#x3D;\frac{n(n+1)}{2}i&#x3D;1∑n​i&#x3D;2n(n+1)​ 等差数列和 1+2+3+…+n   ∑i&#x3D;1n(2i−1)&#x3D;n2\sum\limits_{i&#x3D;1}^{n}(2i-1)&#x3D;n^{2}i&#x3D;1∑n​(2i−1)&#x3D;n2 奇数和">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2024/10/07/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/cover.jpg">
<meta property="article:published_time" content="2024-10-07T11:42:09.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:32.967Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2024/10/07/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/cover.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "高级算法设计和分析技术",
  "url": "https://magicliang.github.io/2024/10/07/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/",
  "image": "https://magicliang.github.io/2024/10/07/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/cover.jpg",
  "datePublished": "2024-10-07T11:42:09.000Z",
  "dateModified": "2025-10-22T08:01:32.967Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2024/10/07/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高级算法设计和分析技术',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2024/10/07/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/cover.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">高级算法设计和分析技术</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">高级算法设计和分析技术</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2024-10-07T11:42:09.000Z" title="Created 2024-10-07 19:42:09">2024-10-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:32.967Z" title="Updated 2025-10-22 16:01:32">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">9.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>39mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>思维导图</h1>
<p><a href="%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98.png">常见算法题</a><br>
<a href="%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E9%A2%98.xmind">常见算法题.xmind</a></p>
<h1>常用数学公式</h1>
<table>
<thead>
<tr>
<th style="text-align:left">公式</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>i</mi><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^{n}i=\frac{n(n+1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></td>
<td style="text-align:left">等差数列和</td>
<td style="text-align:left">1+2+3+…+n</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mo stretchy="false">(</mo><mn>2</mn><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mo>=</mo><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^{n}(2i-1)=n^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:left">奇数和</td>
<td style="text-align:left">1+3+5+…+(2n-1)</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msup><mi>i</mi><mn>2</mn></msup><mo>=</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>6</mn></mfrac></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^{n}i^{2}=\frac{n(n+1)(2n+1)}{6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">6</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span><span class="mopen mtight">(</span><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></td>
<td style="text-align:left">平方和</td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>1</mn><mn>2</mn></msup><mo>+</mo><msup><mn>2</mn><mn>2</mn></msup><mo>+</mo><msup><mn>3</mn><mn>2</mn></msup><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><msup><mi>n</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">1^{2}+2^{2}+3^{2}+...+n^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">1</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msup><mi>i</mi><mn>3</mn></msup><mo>=</mo><msup><mrow><mo fence="true">(</mo><mfrac><mrow><mi>n</mi><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac><mo fence="true">)</mo></mrow><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^{n}i^{3}=\left(\frac{n(n+1)}{2}\right)^{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.004028em;vertical-align:-0.65002em;"></span><span class="minner"><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size2">(</span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size2">)</span></span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:1.3540079999999999em;"><span style="top:-3.6029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:left">立方和</td>
<td style="text-align:left">等于平方和的平方</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msup><mi>r</mi><mi>i</mi></msup><mo>=</mo><mfrac><mrow><mn>1</mn><mo>−</mo><msup><mi>r</mi><mi>n</mi></msup></mrow><mrow><mn>1</mn><mo>−</mo><mi>r</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">\sum\limits_{i=0}^{n-1}r^{i}=\frac{1-r^{n}}{1-r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.478782em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5011130000000001em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.314311em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.91098em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7385428571428572em;"><span style="top:-2.931em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></td>
<td style="text-align:left">等比数列和</td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi><mo mathvariant="normal">≠</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">r\neq1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel"><span class="mrel"><span class="mord"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.69444em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="rlap"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="inner"><span class="mrel"></span></span><span class="fix"></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span></span><span class="mrel">=</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msup><mn>2</mn><mi>i</mi></msup><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\sum\limits_{i=0}^{n-1}2^{i}=2^{n}-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.478782em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.5011130000000001em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
<td style="text-align:left">2的幂和</td>
<td style="text-align:left">特殊等比</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>log</mi><mo>⁡</mo><mi>i</mi><mo>=</mo><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^{n}\log i=\log(n!)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:left">对数和</td>
<td style="text-align:left">常用于分析复杂度</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mfrac><mn>1</mn><mi>i</mi></mfrac><mo>≈</mo><mi>ln</mi><mo>⁡</mo><mi>n</mi><mo>+</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">\sum\limits_{i=1}^{n}\frac{1}{i}\approx\ln n+\gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.329066em;vertical-align:-0.9776689999999999em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3513970000000004em;"><span style="top:-2.122331em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.0000050000000003em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop op-symbol small-op">∑</span></span></span><span style="top:-3.950005em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9776689999999999em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span></td>
<td style="text-align:left">调和级数</td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>γ</mi><mo>≈</mo><mn>0.577</mn></mrow><annotation encoding="application/x-tex">\gamma\approx 0.577</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6775599999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">5</span><span class="mord">7</span><span class="mord">7</span></span></span></span>欧拉常数</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">公式</th>
<th style="text-align:left">名称</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mo stretchy="false">!</mo><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>i</mi></mrow><annotation encoding="application/x-tex">n! = \prod_{i=1}^{n} i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span></span></span></span></td>
<td style="text-align:left">阶乘</td>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>×</mo><mn>2</mn><mo>×</mo><mn>3</mn><mo>×</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>×</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">1 \times 2 \times 3 \times ... \times n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mi>n</mi></msup><mo>=</mo><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>a</mi></mrow><annotation encoding="application/x-tex">a^{n} = \prod_{i=1}^{n} a</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">a</span></span></span></span></td>
<td style="text-align:left">幂</td>
<td style="text-align:left">a 连乘 n 次</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msubsup><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>r</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\prod_{i=0}^{n-1} (x - r_{i})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.253718em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.954008em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathdefault">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td style="text-align:left">多项式因式分解</td>
<td style="text-align:left">韦达定理基础</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∏</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msup><mi>i</mi><mi>i</mi></msup></mrow><annotation encoding="application/x-tex">\prod_{i=1}^{n} i^{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.124374em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∏</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.824664em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span></span></span></span></span></span></span></span></td>
<td style="text-align:left">超级阶乘</td>
<td style="text-align:left">不常用但有趣</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:left">公式</th>
<th style="text-align:left">应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mo>⋯</mo><mo>+</mo><mi>k</mi><mo>=</mo><mfrac><mrow><mi>k</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">1 + 2 + \dots + k = \frac{k(k + 1)}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.355em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.01em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.485em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mopen mtight">(</span><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></td>
<td style="text-align:left">硬币排列问题、判断三角数</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mi>r</mi><mo>+</mo><msup><mi>r</mi><mn>2</mn></msup><mo>+</mo><mo>⋯</mo><mo>=</mo><mfrac><mn>1</mn><mrow><mn>1</mn><mo>−</mo><mi>r</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">1 + r + r^{2} + \dots = \frac{1}{1 - r}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight" style="margin-right:0.02778em;">r</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> (对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∣</mo><mi>r</mi><mo>∣</mo><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">\mid r \mid &lt; 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>)</td>
<td style="text-align:left">概率计算、几何分布</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>log</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">!</mo><mo stretchy="false">)</mo><mo>≈</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo>−</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">\log(n!) \approx n\log n - n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">!</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></td>
<td style="text-align:left">分析快速排序等算法的时间复杂度</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo>+</mo><mfrac><mn>1</mn><mn>2</mn></mfrac><mo>+</mo><mfrac><mn>1</mn><mn>3</mn></mfrac><mo>+</mo><mo>⋯</mo><mo>+</mo><mfrac><mn>1</mn><mi>n</mi></mfrac><mo>=</mo><msub><mi>H</mi><mi>n</mi></msub><mo>≈</mo><mi>ln</mi><mo>⁡</mo><mi>n</mi><mo>+</mo><mi>γ</mi></mrow><annotation encoding="application/x-tex">1 + \frac{1}{2} + \frac{1}{3} + \dots + \frac{1}{n} = H_{n} \approx \ln n + \gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">3</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.190108em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.08125em;">H</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.08125em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mop">ln</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05556em;">γ</span></span></span></span></td>
<td style="text-align:left">分析堆排序中建堆操作的时间复杂度</td>
</tr>
<tr>
<td style="text-align:left"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mn>0</mn></msup><mo>+</mo><msup><mn>2</mn><mn>1</mn></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msup><mn>2</mn><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>=</mo><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^{0} + 2^{1} + \dots + 2^{n - 1} = 2^{n} - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></td>
<td style="text-align:left">计算完全二叉树的节点总数、位运算操作</td>
</tr>
</tbody>
</table>
<h1>递归树分析法与算法复杂度速查表</h1>
<h2 id="算法复杂度总览">算法复杂度总览</h2>
<table>
<thead>
<tr>
<th>算法类别</th>
<th>经典算法</th>
<th>递归树分析（递归实现）</th>
<th>非递归实现</th>
<th>应用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>基础遍历算法</strong></td>
<td>二叉树前/中/后序</td>
<td><strong>树高 h</strong>：O(n)~O(log n)<br><strong>每层成本 C</strong>：O(1)<br><strong>总复杂度</strong>：O(n)</td>
<td><strong>时间复杂度</strong>：O(n)<br><strong>空间复杂度</strong>：O(h)<br><strong>实现</strong>：显式栈模拟</td>
<td>树结构访问、序列化</td>
</tr>
<tr>
<td><strong>分治算法</strong></td>
<td>归并排序</td>
<td><strong>树高 h</strong>：O(log n)<br><strong>每层成本 C</strong>：O(n)<br><strong>总复杂度</strong>：O(n log n)</td>
<td><strong>时间复杂度</strong>：O(n log n)<br><strong>空间复杂度</strong>：O(n)<br><strong>实现</strong>：迭代合并子数组</td>
<td>排序、外部排序</td>
</tr>
<tr>
<td></td>
<td>快速排序</td>
<td><strong>树高 h</strong>：O(log n)~O(n)<br><strong>每层成本 C</strong>：O(n)<br><strong>总复杂度</strong>：O(n log n)</td>
<td><strong>时间复杂度</strong>：O(n log n)<br><strong>空间复杂度</strong>：O(log n)<br><strong>实现</strong>：栈存储子区间边界</td>
<td>内存排序、TopK问题</td>
</tr>
<tr>
<td><strong>搜索算法</strong></td>
<td>二分查找</td>
<td><strong>树高 h</strong>：O(log n)<br><strong>每层成本 C</strong>：O(1)<br><strong>总复杂度</strong>：O(log n)</td>
<td><strong>时间复杂度</strong>：O(log n)<br><strong>空间复杂度</strong>：O(1)<br><strong>实现</strong>：循环更新左右指针</td>
<td>有序数据检索</td>
</tr>
<tr>
<td></td>
<td>DFS（图遍历）</td>
<td><strong>树高 h</strong>：O(|V|)<br><strong>每层成本 C</strong>：O(1)<br><strong>总复杂度</strong>：O(|V| + |E|)</td>
<td><strong>时间复杂度</strong>：O(|V| + |E|)<br><strong>空间复杂度</strong>：O(|V|)<br><strong>实现</strong>：显式栈存储节点</td>
<td>连通性检测、拓扑排序</td>
</tr>
<tr>
<td></td>
<td>BFS（图遍历）</td>
<td><strong>树高 h</strong>：O(|V|)<br><strong>每层成本 C</strong>：O(1)<br><strong>总复杂度</strong>：O(|V| + |E|)</td>
<td><strong>时间复杂度</strong>：O(|V| + |E|)<br><strong>空间复杂度</strong>：O(|V|)<br><strong>实现</strong>：队列管理访问顺序</td>
<td>最短路径（未加权图）</td>
</tr>
<tr>
<td><strong>DP与高级结构</strong></td>
<td>斐波那契数列</td>
<td><strong>树高 h</strong>：O(n)<br><strong>每层成本 C</strong>：O(1)<br><strong>总复杂度</strong>：O(2ⁿ)</td>
<td><strong>时间复杂度</strong>：O(n)<br><strong>空间复杂度</strong>：O(1)<br><strong>实现</strong>：滚动数组更新</td>
<td>状态转移、数学问题</td>
</tr>
<tr>
<td></td>
<td>堆排序</td>
<td><strong>树高 h</strong>：O(log n)<br><strong>每层成本 C</strong>：O(log n)<br><strong>总复杂度</strong>：O(n log n)</td>
<td><strong>时间复杂度</strong>：O(n log n)<br><strong>空间复杂度</strong>：O(1)<br><strong>实现</strong>：循环下沉+交换</td>
<td>优先级队列、流式数据排序</td>
</tr>
<tr>
<td></td>
<td>并查集（路径压缩）</td>
<td><strong>树高 h</strong>：O(α(n))<br><strong>每层成本 C</strong>：O(1)<br><strong>总复杂度</strong>：O(α(n))</td>
<td><strong>时间复杂度</strong>：O(α(n))<br><strong>空间复杂度</strong>：O(n)<br><strong>实现</strong>：迭代路径压缩</td>
<td>连通分量、动态连接问题</td>
</tr>
</tbody>
</table>
<p>Big O 标记代表一个函数的集合。记忆化搜索实际上稍微比DP慢，但是它们仍然在一个集合里，所以可以认为它们时间复杂度一样。</p>
<p>通常我们研究算法的复杂度 big O 记法是研究算法的最坏复杂度，而研究数据结构 API 的复杂度，则研究其平均复杂度，这就是为什么哈希表的API操作经过摊还以后，得到 O(1) 的复杂度。</p>
<p>递归算法的时间复杂度 = 递归的次数 x 函数本身的时间复杂度</p>
<p>递归算法的空间复杂度 = 递归堆栈的深度 + 算法申请的存储空间</p>
<p>或者再说得直观一点：</p>
<p>递归算法的时间复杂度 = 递归树的节点个数 x 每个节点的时间复杂度</p>
<p>递归算法的空间复杂度 = 递归树的高度 + 算法申请的存储空间</p>
<p>非递归算法中嵌套循环的复杂度依然可能是线性的：</p>
<p>而指针移动类的算法时间复杂度往往是两层 while 循环化简为 O(n)-因为内层的循环实际上是重复的时间条件。</p>
<h2 id="递归树分析核心方法论总结">递归树分析核心方法论总结</h2>
<h3 id="1-树高-h-确定">1. 树高（h）确定</h3>
<ul>
<li><strong>分治算法</strong>：h = 分支数（b）对规模（n）的对数，即 <code>h = log_b n</code>（如归并排序 b=2）</li>
<li><strong>遍历算法</strong>：h = 数据结构深度（如二叉树高度 O(log n)~O(n)）</li>
<li><strong>DP/搜索</strong>：h = 状态转移步数（如斐波那契 h=n）</li>
</ul>
<h3 id="2-每层成本-c-计算">2. 每层成本（C）计算</h3>
<ul>
<li><strong>固定成本</strong>：每节点操作恒定（如二分查找 C=O(1)）</li>
<li><strong>线性成本</strong>：每层操作数与层规模正比（如归并排序每层合并 O(n)）</li>
<li><strong>递减成本</strong>：子问题规模逐层衰减（如快排每层分区 O(n) → O(n/2)）</li>
</ul>
<h3 id="3-总复杂度公式">3. 总复杂度公式</h3>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><munderover><mo>∑</mo><mrow><mtext>layer</mtext><mo>=</mo><mn>0</mn></mrow><mi>h</mi></munderover><msub><mi>C</mi><mtext>layer</mtext></msub></mrow><annotation encoding="application/x-tex">T(n) = \sum_{\text{layer}=0}^{h} C_{\text{layer}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.274334em;vertical-align:-1.438221em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.836113em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">layer</span></span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.300005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.438221em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">layer</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p>
<ul>
<li><strong>均匀分层</strong>：若每层 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mtext>layer</mtext></msub><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C_{\text{layer}} = O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">layer</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span> 且 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">h = O(\log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>，则 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n) = O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>（如归并排序）</li>
<li><strong>几何级数</strong>：若 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mtext>layer</mtext></msub><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>r</mi><mi>k</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">C_{\text{layer}} = O(r^k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">layer</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>（r为衰减比），则总复杂度由首项或末项主导（如快排平均 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>）</li>
</ul>
<p>如果将回溯算法的执行过程想象成一棵决策树，我们可以观察到这棵树通常是k叉树的形式，类似于有放回的抽球过程。在这种模型下，k叉树的高度通常等于问题的规模n，因为每个原始问题的元素（或每个决策步骤）都需要进行一次抉择。基于这种简化的模型，算法的时间复杂度上界可以粗略估计为指数级的 O(k^n)。</p>
<p>以换零钱问题为例：假设要兑换11元，且有5种不同面值的货币可供选择。在最简化的情况下，可以将问题建模为：对于需要兑换的总金额（11元），每1元都面临5种货币选择。这样就形成了一个高度为11、分支因子为5的决策树，基于这种粗略模型，时间复杂度的上界估计为 O(5^11) - O(k^n)。</p>
<p>类似的分析方法也适用于其他DFS（深度优先搜索）算法。需要注意的是，这种分析给出的是算法复杂度的上界估计，实际实现中往往存在剪枝、重叠子问题等优化空间，使得实际性能可能远优于这个理论上界。</p>
<p>而一旦引入记忆法，去除了重复问题，所有要解决的问题的数就不是重复分散在树里面了，而可以理解为一个链表，也就是复杂度的算法变成：</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel">  递归的次数 x 函数本身的时间复杂度<br>= 递归树节点个数 x 每个节点的时间复杂度<br>= 状态个数 x 计算每个状态的时间复杂度<br>= 子问题个数 x 解决每个子问题的时间复杂度<br>= O(<span class="hljs-built_in">N</span>) * O(K)<br>= O(NK)<br></code></pre></td></tr></table></figure>
<p>dp化不会比记忆化搜索时间复杂度更快，也是O(NK)。</p>
<p>暴力全排列（arrangement）的复杂度是 O(n!)，暴力子集枚举的复杂度是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>k</mi><mi>n</mi></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(k^n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>。可以认为000的全二进制组合就是一个典型的“子集枚举”问题-每个元素全部投入成为乘法原理的一部分。</p>
<h3 id="4-非递归优化关键">4. 非递归优化关键</h3>
<ul>
<li><strong>栈/队列替代</strong>：用显式栈避免递归调用栈溢出（如二叉树遍历）</li>
<li><strong>尾递归消除</strong>：转换为迭代减少空间（如二分查找）</li>
<li><strong>迭代DP</strong>：自底向上计算避免重复子问题（如斐波那契）</li>
</ul>
<h1>主方法 &amp; 性能思维速记</h1>
<h2 id="主方法-master-method">主方法 Master Method</h2>
<table>
<thead>
<tr>
<th>递推式</th>
<th>条件</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>a</mi><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo stretchy="false">)</mo><mo>+</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=aT(n/b)+f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>b</mi></msub><mi>a</mi><mo>−</mo><mi>ε</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)=O(n^{\log_b a-\varepsilon})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">ε</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>b</mi></msub><mi>a</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Theta(n^{\log_b a})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>b</mi></msub><mi>a</mi></mrow></msup><msup><mo><mi>log</mi><mo>⁡</mo></mo><mi>k</mi></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)=\Theta(n^{\log_b a}\log^k n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1834479999999998em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9334479999999998em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>b</mi></msub><mi>a</mi></mrow></msup><msup><mo><mi>log</mi><mo>⁡</mo></mo><mrow><mi>k</mi><mo>+</mo><mn>1</mn></mrow></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Theta(n^{\log_b a}\log^{k+1} n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.1834479999999998em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9334479999999998em;"><span style="top:-3.14734em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span></td>
</tr>
<tr>
<td></td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Ω</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mrow><msub><mo><mi>log</mi><mo>⁡</mo></mo><mi>b</mi></msub><mi>a</mi><mo>+</mo><mi>ε</mi></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n)=\Omega(n^{\log_b a+\varepsilon})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord">Ω</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mop mtight"><span class="mop mtight"><span class="mtight">l</span><span class="mtight">o</span><span class="mtight" style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.23015999999999992em;"><span style="top:-2.2341314285714287em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">b</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.26586857142857145em;"><span></span></span></span></span></span></span><span class="mspace mtight" style="margin-right:0.19516666666666668em;"></span><span class="mord mathdefault mtight">a</span><span class="mbin mtight">+</span><span class="mord mathdefault mtight">ε</span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 且正则*</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>T</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><mi mathvariant="normal">Θ</mi><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">T(n)=\Theta(f(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">Θ</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></td>
</tr>
</tbody>
</table>
<p>正则条件：存在常数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mo>&lt;</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c&lt;1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 使得对充分大的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span> 有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>a</mi><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mi mathvariant="normal">/</mi><mi>b</mi><mo stretchy="false">)</mo><mo>≤</mo><mi>c</mi><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">a f(n/b)\leq c f(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord">/</span><span class="mord mathdefault">b</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>。</p>
<h3 id="1-1-三步口诀">1.1 三步口诀</h3>
<ol>
<li>算指数 log_b a</li>
<li>把 f(n) 跟它比“大小”</li>
<li>落入 Case 1 / 2 / 3 → 读出答案</li>
</ol>
<h3 id="常见案例">常见案例</h3>
<table>
<thead>
<tr>
<th>算法</th>
<th>a</th>
<th>b</th>
<th>f(n)</th>
<th>主方法结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>归并排序</td>
<td>2</td>
<td>2</td>
<td>Θ(n)</td>
<td>Θ(n log n)</td>
</tr>
<tr>
<td>快速排序(平均)</td>
<td>2</td>
<td>2</td>
<td>Θ(n)</td>
<td>Θ(n log n)</td>
</tr>
<tr>
<td>二叉查找</td>
<td>1</td>
<td>2</td>
<td>Θ(1)</td>
<td>Θ(log n)</td>
</tr>
<tr>
<td>线段树查询</td>
<td>2</td>
<td>2</td>
<td>Θ(1)</td>
<td>Θ(log n)</td>
</tr>
</tbody>
</table>
<h2 id="2-估算-f-n-的三步诊断法">2. 估算 f(n) 的三步诊断法</h2>
<ol>
<li>写骨架伪代码（Split / Work / Merge）</li>
<li>画递归树最后一英里：</li>
</ol>
<blockquote>
<p>叶子总量 vs 上层总量 速查表</p>
</blockquote>
<ol start="3">
<li>微基准钉常数：JMH / 计时器测 c_split, c_merge</li>
</ol>
<p>口诀：</p>
<blockquote>
<p>“先画骨架，再看叶子，最后拿尺子量常数。”</p>
</blockquote>
<h2 id="叶子复杂度来源">叶子复杂度来源</h2>
<table>
<thead>
<tr>
<th>叶子动作</th>
<th>复杂度</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>一条指令</td>
<td>Θ(1)</td>
<td>线段树单点访问</td>
</tr>
<tr>
<td>线性扫描</td>
<td>Θ(k)</td>
<td>快排小数组插排</td>
</tr>
<tr>
<td>继续分治</td>
<td>Θ(k log k)</td>
<td>TimSort 小片段</td>
</tr>
</tbody>
</table>
<h2 id="平摊分析-amortized-analysis">平摊分析 Amortized Analysis</h2>
<p>把一次“天价操作”平摊到整个序列：</p>
<blockquote>
<p>总成本 ÷ 操作次数 = 平摊代价</p>
</blockquote>
<p>三种套路</p>
<ul>
<li>聚合 T_total / n</li>
<li>会计 预付“信用”</li>
<li>势能 Φ 函数记账</li>
</ul>
<h2 id="多项式-vs-非多项式">多项式 vs 非多项式</h2>
<table>
<thead>
<tr>
<th>类别</th>
<th>形式</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td>多项式</td>
<td><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>n</mi><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">n^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span> (k 常数)</td>
<td>O(n² log n)</td>
</tr>
<tr>
<td>非多项式</td>
<td>指数/阶乘/超多项式</td>
<td>O(2ⁿ), O(n!)</td>
</tr>
</tbody>
</table>
<h2 id="性能维度六层面">性能维度六层面</h2>
<table>
<thead>
<tr>
<th>维度</th>
<th>问题</th>
<th>算法</th>
<th>系统结构</th>
<th>代码</th>
<th>系统软件</th>
<th>硬件</th>
</tr>
</thead>
<tbody>
<tr>
<td>运行时间</td>
<td>问题规模</td>
<td>复杂度</td>
<td>并行</td>
<td>热点优化</td>
<td>JIT</td>
<td>更高主频</td>
</tr>
<tr>
<td>可靠性</td>
<td>需求</td>
<td>幂等重试</td>
<td>主备</td>
<td>RAII</td>
<td>看门狗</td>
<td>ECC</td>
</tr>
<tr>
<td>安全性</td>
<td>最小权限</td>
<td>加密</td>
<td>网络分区</td>
<td>静态分析</td>
<td>SELinux</td>
<td>TPM</td>
</tr>
</tbody>
</table>
<h1>排序算法对比表</h1>
<table>
<thead>
<tr>
<th>算法分类</th>
<th>算法名称</th>
<th>最佳时间复杂度</th>
<th>平均时间复杂度</th>
<th>最差时间复杂度</th>
<th>空间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>遍历排序 O(n²)</strong></td>
<td>选择排序</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
</tr>
<tr>
<td></td>
<td>冒泡排序</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
</tr>
<tr>
<td></td>
<td>插入排序</td>
<td>O(n)</td>
<td>O(n²)</td>
<td>O(n²)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>分治排序</strong></td>
<td>快速排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n²)</td>
<td>O(log n)</td>
</tr>
<tr>
<td></td>
<td>归并排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n)</td>
</tr>
<tr>
<td></td>
<td>堆排序</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(n log n)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>线性排序 O(n)</strong></td>
<td>桶排序</td>
<td>O(n + k)</td>
<td>O(n + k)</td>
<td>O(n²)</td>
<td>O(n + k)</td>
</tr>
<tr>
<td></td>
<td>计数排序</td>
<td>O(n + m)</td>
<td>O(n + m)</td>
<td>O(n + m)</td>
<td>O(n + m)</td>
</tr>
<tr>
<td></td>
<td>基数排序</td>
<td>O(n k)</td>
<td>O(n k)</td>
<td>O(n k)</td>
<td>O(n + b)</td>
</tr>
</tbody>
</table>
<h2 id="参数说明">参数说明</h2>
<ul>
<li><strong>n</strong>: 数据量大小</li>
<li><strong>k</strong> (桶排序): 桶数量</li>
<li><strong>m</strong> (计数排序): 数据范围</li>
<li><strong>k</strong> (基数排序): 最大位数</li>
<li><strong>b</strong> (基数排序): 数据进制</li>
</ul>
<h2 id="性能评价">性能评价</h2>
<table>
<thead>
<tr>
<th>指标</th>
<th>评价标准</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>时间复杂度</strong></td>
<td>优: O(n log n) / O(n) → 中: O(n k) → 差: O(n²)</td>
</tr>
<tr>
<td><strong>空间复杂度</strong></td>
<td>优: O(1) → 中: O(log n) / O(n) → 差: O(n + k)</td>
</tr>
</tbody>
</table>
<h1>CLRS 算法学习顺序与递进关系</h1>
<pre><code class="hljs mermaid">%% CLRS 算法学习顺序与递进关系（包含排序算法详细步骤）
flowchart TD
    subgraph 数学&amp;编程基础
        A[离散数学] --&gt; B[大O/Θ/Ω 记号]
        B --&gt; C[概率基础]
    end

    subgraph 基础数据结构
        C --&gt; D1[数组/链表/栈/队列]
        D1 --&gt; D2[哈希表]
        D2 --&gt; D3[二叉查找树 BST]
        D3 --&gt; D4[红黑树 / AVL]
    end

    subgraph 排序与分治
        D1 --&gt; E1[插入/选择/冒泡排序]
        D1 --&gt; E2[归并排序]
        E2 --&gt; E3[快速排序]
        E2 -.-&gt;|可选| E4[随机化快速排序]
        C --&gt; E4
        E1 -.-&gt;|提供复杂度对照组| E3
        E1 -.-&gt;|展示原地重排细节| E3
        E1 -.-&gt;|对比增量 vs 分治| E3

        %% 插入排序详细步骤
        subgraph 插入排序步骤
            IS1[开始：i=1] --&gt; IS2[取出 arr_i 作为 key]
            IS2 --&gt; IS3[j = i-1，向左扫描]
            IS3 --&gt; IS4&#123;arr_j &gt; key?&#125;
            IS4 --&gt;|是| IS5[arr_j+1 = arr_j&lt;br/&gt;j--]
            IS5 --&gt; IS6&#123;j &gt;= 0?&#125;
            IS6 --&gt;|是| IS4
            IS6 --&gt;|否| IS7[arr_j+1 = key]
            IS4 --&gt;|否| IS7
            IS7 --&gt; IS8[i++]
            IS8 --&gt; IS9&#123;i &lt; n?&#125;
            IS9 --&gt;|是| IS2
            IS9 --&gt;|否| IS10[排序完成]
        end

        %% 归并排序详细步骤
        subgraph 归并排序步骤
            MS1[开始：mergeSort arr, 0, n-1] --&gt; MS2&#123;left &lt; right?&#125;
            MS2 --&gt;|否| MS3[返回]
            MS2 --&gt;|是| MS4[mid = left+right/2]
            MS4 --&gt; MS5[递归：mergeSort arr, left, mid]
            MS5 --&gt; MS6[递归：mergeSort arr, mid+1, right]
            MS6 --&gt; MS7[merge arr, left, mid, right]
            MS7 --&gt; MS8[创建临时数组 L, R]
            MS8 --&gt; MS9[复制数据到 L 和 R]
            MS9 --&gt; MS10[双指针合并：i=0, j=0, k=left]
            MS10 --&gt; MS11&#123;L_i &lt;= R_j?&#125;
            MS11 --&gt;|是| MS12[arr_k = L_i, i++]
            MS11 --&gt;|否| MS13[arr_k = R_j, j++]
            MS12 --&gt; MS14[k++]
            MS13 --&gt; MS14
            MS14 --&gt; MS15&#123;还有剩余元素?&#125;
            MS15 --&gt;|是| MS11
            MS15 --&gt;|否| MS16[复制剩余元素]
            MS16 --&gt; MS17[合并完成]
        end

        %% 快速排序详细步骤
        subgraph 快速排序步骤
            QS1[开始：quickSort arr, low, high] --&gt; QS2&#123;low &lt; high?&#125;
            QS2 --&gt;|否| QS3[返回]
            QS2 --&gt;|是| QS4[pi = partition arr, low, high]
            QS4 --&gt; QS5[递归：quickSort arr, low, pi-1]
            QS5 --&gt; QS6[递归：quickSort arr, pi+1, high]
            QS6 --&gt; QS7[分区过程：pivot = arr_high]
            QS7 --&gt; QS8[i = low-1，双指针扫描]
            QS8 --&gt; QS9[j 从 low 到 high-1]
            QS9 --&gt; QS10&#123;arr_j &lt;= pivot?&#125;
            QS10 --&gt;|是| QS11[i++, swap arr_i, arr_j]
            QS10 --&gt;|否| QS12[j++]
            QS11 --&gt; QS12
            QS12 --&gt; QS13&#123;j &lt; high?&#125;
            QS13 --&gt;|是| QS10
            QS13 --&gt;|否| QS14[swap arr_i+1, arr_high]
            QS14 --&gt; QS15[return i+1]
        end

        %% 随机化快速排序步骤## 标题 ##
        subgraph 随机化快排步骤
            RQS1[开始：randomizedQuickSort] --&gt; RQS2&#123;low &lt; high?&#125;
            RQS2 --&gt;|否| RQS3[返回]
            RQS2 --&gt;|是| RQS4[随机选择 pivot 索引]
            RQS4 --&gt; RQS5[random_index = random low, high]
            RQS5 --&gt; RQS6[swap arr_random_index, arr_high]
            RQS6 --&gt; RQS7[调用标准 partition 过程]
            RQS7 --&gt; RQS8[pi = partition arr, low, high]
            RQS8 --&gt; RQS9[递归左半部分]
            RQS9 --&gt; RQS10[递归右半部分]
            RQS10 --&gt; RQS11[期望时间复杂度：O n log n]
        end

        E1 -.-&gt; 插入排序步骤
        E2 -.-&gt; 归并排序步骤
        E3 -.-&gt; 快速排序步骤
        E4 -.-&gt; 随机化快排步骤
    end

    %% 主方法节点
    subgraph 复杂度工具箱
        B --&gt; MM[&quot;Master Method&lt;br/&gt;主方法&lt;br/&gt;T_n=a·T_n/b+f_n&quot;]
    end
    MM -.-&gt;|Case 2: Θ n log n| E2
    MM -.-&gt;|Case 1: Θ n log n 平均| E3
    MM -.-&gt;|Case 1: Θ n log n 期望| E4

    subgraph 高级数据结构
        D4 --&gt; F1[B-树]
        D4 --&gt; F2[区间树/线段树]
        D4 --&gt; F3[并查集 Disjoint-set]
        F3 --&gt; F4[图最小生成树 Kruskal]
    end

    subgraph 图论
        D1 --&gt; G1[图的表示：邻接表/矩阵]
        G1 --&gt; G2[BFS &amp; DFS]
        G2 --&gt; G3[拓扑排序]
        G2 --&gt; G4[强连通分量 SCC]
        G2 --&gt; G5[最短路径：Dijkstra]
        G2 --&gt; G6[最短路径：Bellman-Ford]
        G2 --&gt; G7[最小生成树 Prim]
        G5 --&gt; G8[所有点对最短路径：Floyd-Warshall]
        G6 --&gt; G9[差分约束系统]
    end

    subgraph 动态规划
        E2 -.-&gt;|分治思想| H1[一维 DP：钢条切割/背包]
        H1 --&gt; H2[二维 DP：LCS/编辑距离]
        H2 --&gt; H3[区间 DP：矩阵链乘法]
        H3 --&gt; H4[树形 DP：最优二叉搜索树]
    end

    subgraph 贪心
        E3 --&gt; I1[活动选择问题]
        I1 --&gt; I2[霍夫曼编码]
        I2 --&gt; I3[最小生成树 Prim/Kruskal 贪心视角]
    end

    subgraph 摊还分析
        D4 --&gt; J1[栈操作 &amp; 二进制计数器]
        J1 --&gt; J2[动态表扩张/收缩]
        J2 --&gt; J3[斐波那契堆]
    end

    subgraph 高级算法
        G5 --&gt; K1[A* 搜索]
        G2 --&gt; K2[网络流：Ford-Fulkerson]
        K2 --&gt; K3[最大流：Edmonds-Karp]
        K3 --&gt; K4[最小费用最大流]
        H4 --&gt; K5[字符串匹配：KMP]
        K5 --&gt; K6[后缀数组/后缀树]
    end

    subgraph 复杂度理论
        B --&gt; L1[P vs NP]
        L1 --&gt; L2[NP-完全性：SAT, 3-CNF]
        L2 --&gt; L3[近似算法：顶点覆盖, TSP]
        L2 --&gt; L4[随机化算法：Miller-Rabin 素性测试]
        C --&gt; L4
    end

    %% 样式定义
    style A fill:#ffe6cc
    style B fill:#ffe6cc
    style C fill:#ffe6cc
    style L1 fill:#f9f
    style L2 fill:#f9f
    style L3 fill:#f9f
    style L4 fill:#f9f
    style MM fill:#e6f7ff,stroke:#007acc
    
    %% 排序算法步骤样式
    style 插入排序步骤 fill:#f0f8f0,stroke:#28a745
    style 归并排序步骤 fill:#f0f4ff,stroke:#007bff
    style 快速排序步骤 fill:#fff5f0,stroke:#fd7e14
    style 随机化快排步骤 fill:#f8f0ff,stroke:#6f42c1
    
    %% 关键节点样式
    style IS10 fill:#d4edda,stroke:#155724
    style MS17 fill:#d1ecf1,stroke:#0c5460
    style QS15 fill:#f8d7da,stroke:#721c24
    style RQS11 fill:#e2e3f1,stroke:#383d41</code></pre>
<p>快速排序厉害的地方在于一趟扫描让两批数据位于正确的地方，而不只是一个数据位于正确的地方。</p>
<h1>数据结构</h1>
<h2 id="hashmap">hashmap</h2>
<h3 id="linkedhashmap">LinkedHashMap</h3>
<p>java 的实现是所有的节点都是双向链表的一部分，而每次 put 操作都往这个链表里加入一个节点。</p>
<h3 id="增强版-hashmap-能够在-o-1-时间里返回-key-的哈希表">增强版 hashMap-能够在 O(1) 时间里返回 key 的哈希表</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RandomizedSet</span> &#123;<br>    <span class="hljs-comment">// 存储元素的值</span><br>    List&lt;Integer&gt; nums;<br>    <span class="hljs-comment">// 记录每个元素对应在 nums 中的索引</span><br>    Map&lt;Integer, Integer&gt; valToIndex;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RandomizedSet</span><span class="hljs-params">()</span> &#123;<br>        nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        valToIndex = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 若 val 已存在，不用再插入</span><br>        <span class="hljs-keyword">if</span> (valToIndex.containsKey(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 若 val 不存在，插入到 nums 尾部，</span><br>        <span class="hljs-comment">// 并记录 val 对应的索引值</span><br>        valToIndex.put(val, nums.size());<br>        nums.add(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> val)</span> &#123;<br>        <span class="hljs-comment">// 若 val 不存在，不用再删除</span><br>        <span class="hljs-keyword">if</span> (!valToIndex.containsKey(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 先拿到 val 的索引</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> valToIndex.get(val);<br>        <span class="hljs-comment">// 将最后一个元素对应的索引修改为 index</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">lastElement</span> <span class="hljs-operator">=</span> nums.get(nums.size() - <span class="hljs-number">1</span>);<br>        valToIndex.put(lastElement, index);<br>        <span class="hljs-comment">// 交换 val 和最后一个元素</span><br>        nums.set(index, lastElement);<br>        <span class="hljs-comment">// 在数组中删除元素 val</span><br>        nums.remove(nums.size() - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 删除元素 val 对应的索引</span><br>        valToIndex.remove(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getRandom</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 随机获取 nums 中的一个元素</span><br>        <span class="hljs-keyword">return</span> nums.get((<span class="hljs-type">int</span>)(Math.random() * nums.size()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>比较巧妙的是，用list的index作为map的value，而map的key是原始 map 的value。这样就可以用一个满数组来保存所有的 key，而避开hashmap的槽空洞问题。</p>
<p>而 list 的 size 是一个隐藏的 current val 的 index。这个 index 不是 mod 出来的，而是增减出来的。</p>
<h1>算法在计算中的作用</h1>
<h2 id="算法的定义">算法的定义</h2>
<p>算法是良定义的计算过程，该过程输入某个值或者集合，产生某组值或集合。</p>
<ul>
<li>解决问题：对于每个输入实例，算法能够停机。</li>
<li>效率：输入规模比较重要，常系数经常被记法（notation）隐藏，在同级算法比较中会有用。</li>
<li>硬件也是程序：后面我们会看到指令执行模型在算法中的体现。</li>
</ul>
<h2 id="数据结构的定义">数据结构的定义</h2>
<p>存储和组织数据的方式。</p>
<h1>算法基础</h1>
<h2 id="复杂度">复杂度</h2>
<h3 id="编程语言特例">编程语言特例</h3>
<h4 id="java">java</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span>[] nums = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[n];<br></code></pre></td></tr></table></figure>
<p>这个操作申请了一块n大小的区域，空间复杂度是 O(n)，时间复杂度也是 O(n)-因为对某些操作而言，初始化这批区域需要逐次初始化。</p>
<h2 id="插入排序">插入排序</h2>
<h3 id="循环不变式-loop-invariant">循环不变式 loop invariant</h3>
<ul>
<li>初始化 initialization：循环第一次迭代以前，它为真</li>
<li>保持 mantainance：如果循环某次迭代前它为真，那么下次迭代之前它仍为真。</li>
<li>终止 termination：在循环终止时，不变式为我们提供一个有用的性质，该性质有助于证明算法是正确的。</li>
</ul>
<p>我们使用循环不变式来证明了我们用插入排序解决了排序问题。这个方法和数学归纳法的区别是数学归纳法不一定终止，<strong>但循环不变式会终止</strong>。</p>
<h3 id="分析算法">分析算法</h3>
<h4 id="ram-模型">RAM 模型</h4>
<p>在这个模型里，一切都是有限的（limited）：<br>
- 指令只能在常量时间里执行<br>
- arithmetic 加减乘除<br>
- 赋值 load<br>
- 控制<br>
- 数据的字长有限（更广义地讲，内存有限）：我们不能引入无限存储<br>
- <strong>程序单线程执行</strong><br>
- <strong>不考虑 memory hiarachy</strong>，否则问题会复杂得难以分析</p>
<p>基于这些假定，我们可以用一套伪代码来写所有算法，而且可以用统一的标准来衡量算法之间的复杂度。complexity（算法复杂度） is about step operation metric，我们在有限的资源里寻找合适消耗时间的算法。</p>
<h4 id="插入排序的算法分析">插入排序的算法分析</h4>
<ul>
<li>运行时间是输入规模的函数
<ul>
<li><strong>我们研究的问题不同，输入规模的定义也不同</strong>：排序的输入规模是项数，而相乘的输入规模则是位数，图的输入规模是顶点和边的数量</li>
<li>运行时间在我们写灯饰 T(n)=xxx 的时候，意味着我们在计算操作步数的总和</li>
</ul>
</li>
</ul>
<h4 id="增长量级">增长量级</h4>
<p>我们通常只关心运行时间的增长率和增长量级，所以一个多项式里我们只关注最高阶项的阶数，它表示通用精度。常系数和低阶项我们都不关注，它们表示多余的精度。</p>
<h2 id="设计算法">设计算法</h2>
<pre><code class="hljs mermaid">graph TD
    A[拿到最优解问题] --&gt; B&#123;决策点是什么?&#125;;
    B --&gt; C&#123;当前局部最优选择, 会影响全局结果吗?&#125;;
    C -- &quot;不会 (无后效性)&quot; --&gt; D[✅ 贪心算法];
    C -- &quot;会 (有后效性)&quot; --&gt; E&#123;需要记录所有子问题解吗?&#125;;
    E -- &quot;是, 状态复杂&quot; --&gt; F[✅ 动态规划];
    E -- &quot;否, 只需几个变量记录历史极值&quot; --&gt; G[✅ 极值法/单次遍历];
    
    subgraph &quot;其他思路&quot;
        H&#123;问题能拆成独立子问题吗?&#125;
        H -- &quot;能&quot; --&gt; I[✅ 分治法]
    end

    A --&gt; H</code></pre>
<pre><code class="hljs mermaid">flowchart TD
    A[分析问题] --&gt; B&#123;是否有时间/顺序约束？&#125;
    B --&gt;|有| C[考虑在线算法/流式处理]
    B --&gt;|无| D[考虑批处理算法]
    
    C --&gt; E&#123;局部决策是否影响全局？&#125;
    D --&gt; F&#123;子问题是否重叠？&#125;
    
    E --&gt;|不影响| G[贪心算法]
    E --&gt;|影响| H[动态规划]
    
    F --&gt;|重叠| I[动态规划]
    F --&gt;|不重叠| J[分治算法]</code></pre>
<h3 id="分治法">分治法</h3>
<ol>
<li>插入排序让我们引入了<strong>增量法</strong>，构造越来越大的子数组，待其等于主数组时，问题已被解决。</li>
<li>分治法是让我们递归地重复以下过程：divide-conquer-merge。</li>
</ol>
<p>当一个算法仅包含对其自身的调用的时候，我们可以使用递归方程来描述运行时间。</p>
<p>该方程根据在较小输入上的运行时间来描述在规模为 n 的问题上的总运行时间然后，我们可以使用数学工具来求解该递归式并给出算法性能的界。</p>
<p>使用递归树来计算 T(n) 的最坏情形：<br>
递归树总是层为 lgn+1，高为 lgn，宽为c的树。假设叶子节点的代价为c。</p>
<p>则除根部以外每层的代价都相等，为 cn（c取归并、分解和单独操作的最大值就能归并c在不同层级之间不一致的问题），则除根部以外的总代价为 宽 * 高 * 每层代价 = cnlgn，加上根部 cn（D(n) + C(n)即分解和归并的代价。<strong>这种式子能写成c2，和解决子问题的c1取一个最大值c即可进入上界分析问题</strong>），总代价为 cnlgn + cn，所以这个算法的时间复杂度上界为 O(lgn)。</p>
<h1>从鸽巢问题出发，我们看到什么</h1>
<h1>动态规划</h1>
<p>动态规划的本质，是寻找状态的定义，并基于这个定义给出状态转移的方程。</p>
<p>最优子结构(optimal substructure）</p>
<h2 id="定义">定义</h2>
<p>我们通常要做出一组选择来达到最优解。</p>
<p>在做每个选择的同事，通常会生成与原问题形式相同的子问题。当多于一个选择子集都生成相同的子问题的时候，动态规划通常就会很有效。其关键技术就是对每个这样的子问题都保存其解。档期重复出现时，可避免重复求解。</p>
<p>programming 其实是一种表格法，而非编程。分治法解决的问题是，互不相交的子问题。</p>
<p>最优解有两种： an optimal solution vs the optimal solution。</p>
<h2 id="步骤">步骤</h2>
<ol>
<li>刻画一个最优解的结构特征。</li>
<li>递归地定义最优解的值。</li>
<li>计算最优解的值，通过自底向上的方法。</li>
<li>利用计算出的信息，构造一个最优解。</li>
</ol>
<p>递归是自顶向下求解。<br>
迭代可以自底向上求解。</p>
<p>能够用动态规划来解的问题通常具有两个性质：</p>
<ul>
<li>最有子结构性质：问题的最优解，是由相关子问题的最优解组合而成，而这些子问题可以独立求解。</li>
<li>子问题重叠性质：最优子结构里可能出现的子问题，可能会产生重叠。</li>
</ul>
<h2 id="切割钢条问题">切割钢条问题</h2>
<h3 id="一般形式">一般形式</h3>
<p>要做基本的切割分析，得出切割方案的一般形式（因为对称性，我们总可以去掉一部分解），如：</p>
<p>rn = max(pn, r1 + r(n-1),…, rn-1 + r(1))</p>
<p>更进一步推导出具体形式：</p>
<p>rn = max(pn + rn-1)</p>
<h3 id="递归调用树分析">递归调用树分析</h3>
<p>借助递归调用树的节点总数，我们可以估计总调用次数。</p>
<p>需要通过证明，得知 T（n）= 2 的 n 次方（TODO）。</p>
<p>日后可以把它转化为子问题图：</p>
<h3 id="动态规划的两种等价实现方法">动态规划的两种等价实现方法</h3>
<p>动态规划仔细安排求解顺序，对每一个重复的子问题只求解一次，并将结果保存下来。</p>
<p>这是典型的时空权衡问题（time-memory trade-off）。</p>
<p>带备忘的自顶向下方法（top-down with memoization）。</p>
<h1>贪心算法</h1>
<p>与动态规划相似，贪心算法通常用于最优化问题。我们做出一组选择来达到最优解。贪心算法的四项，是每一步都追求局部最优解。</p>
<p>贪心选择性质的证明总是：假定一个存在一个最优解。最优解中的第一个选择如果可以被替换，替换成另一个贪心选择而能得到【另一个兼容】的最优解，则这个问题具有贪心选择性质。</p>
<p>只能用 dp 来解的问题，通常子问题的解是不能相容的，一个子问题的部分选择无法替换成另一个选择而让解的其他部分不变。贪心算法可以解决分数背包问题，不能解决0-1背包问题。因为0-1背包问题，把价值最高的解替换成功价值次高的解，有可能造成空间的变化，以至于让子问题的规模也得以变大-子问题的解可能也因此上升。</p>
<h1>霍夫曼编码</h1>
<p>霍夫曼具有贪心算法性质。<br>
霍夫曼编码使用了一种前缀编码（prefix code），即没有任何码字是其他码字的前缀。使用这种前缀码，我们得到一串编码后可以唯一地解析出我们想要的信息，不产生二义性。</p>
<p>变长编码本身是一种变长编码（variable-length code），有点类似于 utf-8。核心思想是让拥有更高出现频率的 character 得到更短的码字。</p>
<h2 id="摊还分析-amortized-analysis">摊还分析（amortized analysis）</h2>
<p>摊还分析只能拿来分析一类特定的算法。摊还分析并不是通过分析每个操作的实际代价的界，来分析操作序列代价的界，而是直接分析序列整体的代价的界。这种方法的一个好处是，虽然某些操作的代价可能很高，但其他很多操作的代价可能很低。</p>
<h1>Progamming Checklist</h1>
<ul>
<li>先写防御性编程方案。</li>
<li>然后写提前截断流程的子问题的答案。</li>
<li>开始用递归（自顶向下）或者迭代（自底向上）的方式求子问题的解，并逐渐推导到当前问题。</li>
</ul>
<h1>怎样把递归转迭代</h1>
<h2 id="必要条件">必要条件</h2>
<ul>
<li>
<p>状态可保存：递归中的局部变量和参数能用栈保存</p>
</li>
<li>
<p>执行路径明确：能清晰地分离递归的各个阶段</p>
</li>
<li>
<p>迭代转递归：引入层次，然后用递归来进行探索，探索到了指定层次再执行。这会引入重复递归调用，因为每个递归只是为了到达某一层，而不可复用递归结果，所以所有O(n)会变成O(n^2)。</p>
</li>
<li>
<p>递归转迭代：引入一个 stack（LinkedList天然支持 push 和 pop，也支持 offer 和 poll）。然后把接下来要调用的所有参数按照<strong>逆序</strong>压入 stack 里。</p>
</li>
</ul>
<h2 id="二叉树的例子">二叉树的例子</h2>
<h3 id="二叉树的定义">二叉树的定义</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    TreeNode left;<br>    TreeNode right;<br>    <br>    TreeNode() &#123;&#125;<br>    TreeNode(<span class="hljs-type">int</span> val) &#123; <span class="hljs-built_in">this</span>.val = val; &#125;<br>    TreeNode(<span class="hljs-type">int</span> val, TreeNode left, TreeNode right) &#123;<br>        <span class="hljs-built_in">this</span>.val = val;<br>        <span class="hljs-built_in">this</span>.left = left;<br>        <span class="hljs-built_in">this</span>.right = right;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="前序遍历-迭代实现">前序遍历 - 迭代实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">preorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> result;<br>    <br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    stack.push(root);<br>    <br>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> stack.pop();<br>        result.add(node.val);  <span class="hljs-comment">// 访问根节点</span><br>        <br>        <span class="hljs-comment">// 先压入右子树，再压入左子树</span><br>        <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(node.right);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(node.left);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="中序遍历-迭代实现">中序遍历 - 迭代实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> root;<br>    <br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>        <span class="hljs-comment">// 一直向左走到底</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(current);<br>            current = current.left;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 处理栈顶节点</span><br>        current = stack.pop();<br>        result.add(current.val);  <span class="hljs-comment">// 访问根节点</span><br>        <br>        <span class="hljs-comment">// 转向右子树</span><br>        current = current.right;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="中序遍历-迭代实现">中序遍历 - 迭代实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">inorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> root;<br>    <br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>        <span class="hljs-comment">// 一直向左走到底</span><br>        <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(current);<br>            current = current.left;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 处理栈顶节点</span><br>        current = stack.pop();<br>        result.add(current.val);  <span class="hljs-comment">// 访问根节点</span><br>        <br>        <span class="hljs-comment">// 转向右子树</span><br>        current = current.right;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="后序遍历-迭代实现">后序遍历 - 迭代实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title function_">postorderTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> result;<br>    <br>    Stack&lt;TreeNode&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">lastVisited</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">TreeNode</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> root;<br>    <br>    <span class="hljs-keyword">while</span> (current != <span class="hljs-literal">null</span> || !stack.isEmpty()) &#123;<br>        <span class="hljs-keyword">if</span> (current != <span class="hljs-literal">null</span>) &#123;<br>            stack.push(current);<br>            current = current.left;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">peekNode</span> <span class="hljs-operator">=</span> stack.peek();<br>            <span class="hljs-comment">// 如果右子树存在且未被访问过</span><br>            <span class="hljs-keyword">if</span> (peekNode.right != <span class="hljs-literal">null</span> &amp;&amp; lastVisited != peekNode.right) &#123;<br>                current = peekNode.right;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result.add(peekNode.val);<br>                lastVisited = stack.pop();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="层序遍历-bfs-迭代实现">层序遍历（BFS）- 迭代实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="hljs-title function_">levelOrder</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> result;<br>    <br>    Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    queue.offer(root);<br>    <br>    <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">levelSize</span> <span class="hljs-operator">=</span> queue.size();<br>        List&lt;Integer&gt; currentLevel = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; levelSize; i++) &#123;<br>            <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> queue.poll();<br>            currentLevel.add(node.val);<br>            <br>            <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(node.left);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                queue.offer(node.right);<br>            &#125;<br>        &#125;<br>        <br>        result.add(currentLevel);<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="简单的通用递归转迭代模板">简单的通用递归转迭代模板</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.*;<br><br><span class="hljs-comment">// 最简单的通用模板</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRecursiveToIterative</span> &#123;<br>    <br>    <span class="hljs-comment">// 简化版状态类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleState</span> &#123;<br>        <span class="hljs-type">int</span> value;<br>        <span class="hljs-type">int</span> step;  <span class="hljs-comment">// 执行步骤</span><br>        <br>        SimpleState(<span class="hljs-type">int</span> value, <span class="hljs-type">int</span> step) &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.step = step;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 最简单的通用转换模式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simpleRecursiveToIterative</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 1. 创建栈</span><br>        Stack&lt;SimpleState&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 2. 初始化状态</span><br>        stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleState</span>(<span class="hljs-number">5</span>, <span class="hljs-number">0</span>));<br>        <br>        <span class="hljs-comment">// 3. 循环处理</span><br>        <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>            <span class="hljs-comment">// 4. 弹出当前状态</span><br>            <span class="hljs-type">SimpleState</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> stack.pop();<br>            <br>            <span class="hljs-comment">// 5. 处理当前状态</span><br>            System.out.println(<span class="hljs-string">&quot;处理: &quot;</span> + current.value + <span class="hljs-string">&quot;, 步骤: &quot;</span> + current.step);<br>            <br>            <span class="hljs-comment">// 6. 推入下一个状态</span><br>            <span class="hljs-keyword">if</span> (current.value &gt; <span class="hljs-number">0</span> &amp;&amp; current.step &lt; <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-comment">// 模拟递归调用</span><br>                stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleState</span>(current.value - <span class="hljs-number">1</span>, current.step + <span class="hljs-number">1</span>));<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        simpleRecursiveToIterative();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="复杂递归转迭代示例">复杂递归转迭代示例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 复杂递归示例</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">State</span> &#123;<br>    TreeNode node;<br>    <span class="hljs-type">int</span> phase;<br>    <span class="hljs-type">boolean</span> flag;<br>    <br>    State(TreeNode node, <span class="hljs-type">int</span> phase, <span class="hljs-type">boolean</span> flag) &#123;<br>        <span class="hljs-built_in">this</span>.node = node;<br>        <span class="hljs-built_in">this</span>.phase = phase;<br>        <span class="hljs-built_in">this</span>.flag = flag;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">complexTraversal</span><span class="hljs-params">(TreeNode root)</span> &#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;<br>    <br>    Stack&lt;State&gt; stack = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Stack</span>&lt;&gt;();<br>    stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>(root, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>));<br>    <br>    <span class="hljs-keyword">while</span> (!stack.isEmpty()) &#123;<br>        <span class="hljs-type">State</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> stack.pop();<br>        <span class="hljs-type">TreeNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> state.node;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">phase</span> <span class="hljs-operator">=</span> state.phase;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> state.flag;<br>        <br>        <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) <span class="hljs-keyword">continue</span>;<br>        <br>        <span class="hljs-keyword">if</span> (flag) &#123;<br>            <span class="hljs-keyword">if</span> (phase == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 阶段1</span><br>                doSomething1(node);<br>                stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>(node, <span class="hljs-number">1</span>, flag));  <span class="hljs-comment">// 进入阶段2</span><br>                <span class="hljs-keyword">if</span> (node.left != <span class="hljs-literal">null</span>) &#123;<br>                    stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>(node.left, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>));<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (phase == <span class="hljs-number">1</span>) &#123;  <span class="hljs-comment">// 阶段2</span><br>                doSomething2(node);<br>                stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>(node, <span class="hljs-number">2</span>, flag));  <span class="hljs-comment">// 进入阶段3</span><br>                <span class="hljs-keyword">if</span> (node.right != <span class="hljs-literal">null</span>) &#123;<br>                    stack.push(<span class="hljs-keyword">new</span> <span class="hljs-title class_">State</span>(node.right, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>));<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (phase == <span class="hljs-number">2</span>) &#123;  <span class="hljs-comment">// 阶段3</span><br>                doSomething3(node);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething1</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Phase 1: &quot;</span> + node.val);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething2</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Phase 2: &quot;</span> + node.val);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething3</span><span class="hljs-params">(TreeNode node)</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;Phase 3: &quot;</span> + node.val);<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>二叉树</h1>
<pre><code class="hljs mermaid">graph TD
    A[二叉树 Binary Tree] --&gt; B[完全二叉树 Complete Binary Tree]
    A --&gt; C[满二叉树 Full Binary Tree]
    
    B --&gt; D[完美二叉树 Perfect Binary Tree]
    C --&gt; D
    B --&gt; E[堆 Heap]
    
    D --&gt; F[最大堆 Max Heap]
    D --&gt; G[最小堆 Min Heap]
    E --&gt; F
    E --&gt; G

    A --&gt;|特点| A1[每个节点最多两个子节点]
    B --&gt;|特点| B1[除最后一层外都完全填满&lt;br&gt;最后一层从左到右填充&lt;br&gt;适合数组实现]
    C --&gt;|特点| C1[每个节点要么0个子节点&lt;br&gt;要么2个子节点&lt;br&gt;无度为1的节点]
    D --&gt;|特点| D1[所有层完全填满&lt;br&gt;所有叶子在同一层&lt;br&gt;节点数=2^h-1]
    E --&gt;|特点| E1[父节点与子节点有序关系&lt;br&gt;支持优先队列操作]

    style A fill:#f9f,stroke:#333,stroke-width:3px
    style B fill:#e1f5fe,stroke:#333,stroke-width:2px
    style C fill:#fff3e0,stroke:#333,stroke-width:2px
    style D fill:#e8f5e8,stroke:#333,stroke-width:2px
    style E fill:#fce4ec,stroke:#333,stroke-width:2px</code></pre>
<pre><code class="hljs mermaid">graph TD
    A[二叉树&lt;br/&gt;Binary Tree]
    B[完全二叉树&lt;br/&gt;Complete Binary Tree]
    C[满二叉树&lt;br/&gt;Full Binary Tree]
    D[完美二叉树&lt;br/&gt;Perfect Binary Tree]
    E[堆&lt;br/&gt;Heap]
    F[最大堆&lt;br/&gt;Max Heap]
    G[最小堆&lt;br/&gt;Min Heap]

    %% Features
    A1[每个节点最多两个孩子&lt;br/&gt;At most two children per node]
    B1[除最后一层外都满，最后一层从左到右填充&lt;br/&gt;Levels full except last, last filled left to right]
    C1[每个节点要么0个要么2个孩子&lt;br/&gt;Each node has zero or two children]
    D1[所有层都满，叶子同深度&lt;br/&gt;All levels full, leaves same depth]
    E1[父子保持顺序&lt;br/&gt;Parent-child order maintained]

    %% Applications
    B2[堆、优先队列、数组存储&lt;br/&gt;Heap, Priority Queue, Array storage]
    C2[表达式树、哈夫曼树、博弈树&lt;br/&gt;Expression Tree, Huffman Tree, Game Tree]
    D2[理论模型，高度约为 log2&amp;#40;n&amp;#43;1&amp;#41;&lt;br/&gt;Theoretical model, Height ~ log2&amp;#40;n&amp;#43;1&amp;#41;]
    E2[任务调度、Dijkstra、A*、操作系统优先队列&lt;br/&gt;Task scheduling, Dijkstra, A*, OS priority queue]
    F2[最大堆用于优先队列和堆排序&lt;br/&gt;Max Heap for PQ and Heap Sort]
    G2[最小堆用于调度和负载均衡&lt;br/&gt;Min Heap for Scheduling and Load balancing]

    %% Relationships
    A --&gt; B
    A --&gt; C
    B --&gt; D
    C --&gt; D
    B --&gt; E
    D --&gt; F
    D --&gt; G
    E --&gt; F
    E --&gt; G

    %% Feature links
    A --&gt;|特征 Feature| A1
    B --&gt;|特征 Feature| B1
    C --&gt;|特征 Feature| C1
    D --&gt;|特征 Feature| D1
    E --&gt;|特征 Feature| E1

    %% Application links
    B --&gt;|应用 Application| B2
    C --&gt;|应用 Application| C2
    D --&gt;|应用 Application| D2
    E --&gt;|应用 Application| E2
    F --&gt;|应用 Application| F2
    G --&gt;|应用 Application| G2</code></pre>
<h1>图算法</h1>
<table>
<thead>
<tr>
<th>操作/属性</th>
<th>邻接矩阵</th>
<th>邻接表（链表）</th>
<th>邻接表（哈希表）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>判断是否邻接</strong></td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>添加边</strong></td>
<td>O(1)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>删除边</strong></td>
<td>O(1)</td>
<td>O(n)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>添加顶点</strong></td>
<td>O(n)</td>
<td>O(1)</td>
<td>O(1)</td>
</tr>
<tr>
<td><strong>删除顶点</strong></td>
<td>O(n<sup>2</sup>)</td>
<td>O(n + m)</td>
<td>O(n)</td>
</tr>
<tr>
<td><strong>内存空间占用</strong></td>
<td>O(n<sup>2</sup>)</td>
<td>O(n + m)</td>
<td>O(n + m)</td>
</tr>
</tbody>
</table>
<h1>回溯</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/* 回溯算法框架 */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">backtrack</span><span class="hljs-params">(State state, List&lt;Choice&gt; choices, List&lt;State&gt; res)</span> &#123;<br>    <span class="hljs-comment">// 判断是否为解</span><br>    <span class="hljs-keyword">if</span> (isSolution(state)) &#123;<br>        <span class="hljs-comment">// 记录解</span><br>        recordSolution(state, res);<br>        <span class="hljs-comment">// 不再继续搜索</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 遍历所有选择</span><br>    <span class="hljs-keyword">for</span> (Choice choice : choices) &#123;<br>        <span class="hljs-comment">// 剪枝：判断选择是否合法</span><br>        <span class="hljs-keyword">if</span> (isValid(state, choice)) &#123;<br>            <span class="hljs-comment">// 尝试：做出选择，更新状态</span><br>            makeChoice(state, choice);<br>            backtrack(state, choices, res);<br>            <span class="hljs-comment">// 回退：撤销选择，恢复到之前的状态</span><br>            undoChoice(state, choice);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>动态规划</h1>
<h2 id="动态规划状态分类表">动态规划状态分类表</h2>
<table>
<thead>
<tr>
<th>类别</th>
<th>状态定义模式</th>
<th>典型问题</th>
<th>状态例子</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>纯前缀型</td>
<td>只依赖「前i个元素」</td>
<td>- 最大子数组和（Kadane）<br>- 最长公共子序列（LCS一维化前）<br>- LIS（最长递增子序列）</td>
<td>dp[i] = 以第i个元素结尾的最优解</td>
<td>顺序天然递推，所有子结构都能用“以i结尾”覆盖</td>
</tr>
<tr>
<td>前缀 + 附加维度型</td>
<td>前缀索引 + 资源/条件维度</td>
<td>- 0/1背包、完全背包、多重背包<br>- 编辑距离（Levenshtein Distance）<br>- 股票买卖问题（天数 + 持仓状态）</td>
<td>背包：dp[i][c]<br>编辑距离：dp[i][j]<br>股票：dp[day][hold]</td>
<td>不仅依赖前缀，还要记录额外约束（容量、操作数、状态机…）</td>
</tr>
<tr>
<td>区间型</td>
<td>子问题是区间 [l, r]</td>
<td>- 石子合并/矩阵链乘法<br>- 最长回文子序列<br>- 区间博弈</td>
<td>dp[l][r] = 区间[l…r]的最优解</td>
<td>子问题是区间划分，通常要枚举中点k来划分子区间</td>
</tr>
<tr>
<td>集合/图型（状压）</td>
<td>状态是「集合 + 当前位置」</td>
<td>- TSP（旅行商问题）<br>- 最小斯坦纳树<br>- 子集覆盖问题</td>
<td>dp[mask][i] = 已访问集合为mask，当前在i的最优解</td>
<td>状态空间不是线性，而是子集或图节点；转移类似BFS/DFS</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2024/10/07/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/">https://magicliang.github.io/2024/10/07/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%AE%97%E6%B3%95/">算法</a></div><div class="post-share"><div class="social-share" data-image="/2024/10/07/%E9%AB%98%E7%BA%A7%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%88%86%E6%9E%90%E6%8A%80%E6%9C%AF/cover.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2018/11/14/%E6%95%A3%E5%88%97%E7%AE%97%E6%B3%95/" title="散列算法"><img class="cover" src="/img/wall-paper-52.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-11-14</div><div class="info-item-2">散列算法</div></div><div class="info-2"><div class="info-item-1">MD5 易于碰撞。 SHA1 是 git 默认的 commit 用的散列算法。 SHA2 是第二代安全散列算法，合共有六种。 SHA256 是其中一种。 参考： https://blog.csdn.net/chenze666/article/details/79730753 https://www.keycdn.com/support/sha1-vs-sha256 </div></div></div></a><a class="pagination-related" href="/2018/11/25/%E5%88%86%E6%B2%BB%E7%AD%96%E7%95%A5/" title="分治策略"><img class="cover" src="/img/wall-paper-151.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-11-25</div><div class="info-item-2">分治策略</div></div><div class="info-2"><div class="info-item-1">步骤 分解（divide）：将问题划分为一些子问题，子问题的形式与原问题一样，只是规模更小。 解决（conquer）：递归地杰出子问题。如果子问题的规模足够小，则停止递归，直接求解。 合并（Combine）：将子问题的解组合成原问题的解。 递归式 递归式（recurrence）可以帮我们刻画整个算法的运行时间。 一个常见刻画递归式的方法是画递归树。通过递归树的枝叶来试图把整个算法的步骤勾勒出来。 </div></div></div></a><a class="pagination-related" href="/2025/08/04/%E3%80%8A%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E3%80%8B/" title="《编程之美》"><img class="cover" src="/img/wall-paper-121.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-04</div><div class="info-item-2">《编程之美》</div></div><div class="info-2"><div class="info-item-1">序言 下水道井盖为什么是圆的 “下水道井盖是圆的，因为圆形不会掉进井口，而且圆形具有均匀分布压力的优势。” 一个屋子有一个门（门是关闭的）和3盏电灯。屋外有3个开关，分别与这3盏灯相连。你可以随意操纵这些开关，可一旦你将门打开，就不能变换开关了。确定每个开关具体管哪盏灯？ 答：将一盏灯开一段时间，再关掉，在剩余2盏灯里随机开一盏，进屋去看，发热的灯对应第一个碰的开关，亮着的灯对应开关开着的开关，灭的灯对应没碰过的开关。 游戏之乐 如何写一个程序让 cpu 占用率保持在 50%？ 不要用 if-else 来解决，要把比例转成不同的 worktime。 解法的精确与否其实取决于“多久时间内测度一次已占用的时间”和“睡眠”两类 api 的精度。 bash 版本 12345678910111213#!/bin/bash# 精简版CPU负载控制器L=$&#123;1:-50&#125;  # 默认50%[ $L -lt 0 ] || [ $L -gt 100 ] &amp;&amp; &#123; echo &quot;用法: $0 [0-100]&quot;; exit 1; &#125...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">思维导图</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">常用数学公式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">递归树分析法与算法复杂度速查表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%80%BB%E8%A7%88"><span class="toc-number">3.1.</span> <span class="toc-text">算法复杂度总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E6%A0%91%E5%88%86%E6%9E%90%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95%E8%AE%BA%E6%80%BB%E7%BB%93"><span class="toc-number">3.2.</span> <span class="toc-text">递归树分析核心方法论总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%A0%91%E9%AB%98-h-%E7%A1%AE%E5%AE%9A"><span class="toc-number">3.2.1.</span> <span class="toc-text">1. 树高（h）确定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%AF%8F%E5%B1%82%E6%88%90%E6%9C%AC-c-%E8%AE%A1%E7%AE%97"><span class="toc-number">3.2.2.</span> <span class="toc-text">2. 每层成本（C）计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%80%BB%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%85%AC%E5%BC%8F"><span class="toc-number">3.2.3.</span> <span class="toc-text">3. 总复杂度公式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E9%9D%9E%E9%80%92%E5%BD%92%E4%BC%98%E5%8C%96%E5%85%B3%E9%94%AE"><span class="toc-number">3.2.4.</span> <span class="toc-text">4. 非递归优化关键</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">主方法 &amp; 性能思维速记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%96%B9%E6%B3%95-master-method"><span class="toc-number">4.1.</span> <span class="toc-text">主方法 Master Method</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%B8%89%E6%AD%A5%E5%8F%A3%E8%AF%80"><span class="toc-number">4.1.1.</span> <span class="toc-text">1.1 三步口诀</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B"><span class="toc-number">4.1.2.</span> <span class="toc-text">常见案例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BC%B0%E7%AE%97-f-n-%E7%9A%84%E4%B8%89%E6%AD%A5%E8%AF%8A%E6%96%AD%E6%B3%95"><span class="toc-number">4.2.</span> <span class="toc-text">2. 估算 f(n) 的三步诊断法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%B6%E5%AD%90%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9D%A5%E6%BA%90"><span class="toc-number">4.3.</span> <span class="toc-text">叶子复杂度来源</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E6%91%8A%E5%88%86%E6%9E%90-amortized-analysis"><span class="toc-number">4.4.</span> <span class="toc-text">平摊分析 Amortized Analysis</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%A1%B9%E5%BC%8F-vs-%E9%9D%9E%E5%A4%9A%E9%A1%B9%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text">多项式 vs 非多项式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E7%BB%B4%E5%BA%A6%E5%85%AD%E5%B1%82%E9%9D%A2"><span class="toc-number">4.6.</span> <span class="toc-text">性能维度六层面</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">排序算法对比表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%AF%B4%E6%98%8E"><span class="toc-number">5.1.</span> <span class="toc-text">参数说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E8%AF%84%E4%BB%B7"><span class="toc-number">5.2.</span> <span class="toc-text">性能评价</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">CLRS 算法学习顺序与递进关系</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap"><span class="toc-number">7.1.</span> <span class="toc-text">hashmap</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedhashmap"><span class="toc-number">7.1.1.</span> <span class="toc-text">LinkedHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BA%E7%89%88-hashmap-%E8%83%BD%E5%A4%9F%E5%9C%A8-o-1-%E6%97%B6%E9%97%B4%E9%87%8C%E8%BF%94%E5%9B%9E-key-%E7%9A%84%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">7.1.2.</span> <span class="toc-text">增强版 hashMap-能够在 O(1) 时间里返回 key 的哈希表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">算法在计算中的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">8.1.</span> <span class="toc-text">算法的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">8.2.</span> <span class="toc-text">数据结构的定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">算法基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">9.1.</span> <span class="toc-text">复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%89%B9%E4%BE%8B"><span class="toc-number">9.1.1.</span> <span class="toc-text">编程语言特例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java"><span class="toc-number">9.1.1.1.</span> <span class="toc-text">java</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">9.2.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%8D%E5%8F%98%E5%BC%8F-loop-invariant"><span class="toc-number">9.2.1.</span> <span class="toc-text">循环不变式 loop invariant</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="toc-number">9.2.2.</span> <span class="toc-text">分析算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ram-%E6%A8%A1%E5%9E%8B"><span class="toc-number">9.2.2.1.</span> <span class="toc-text">RAM 模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E7%9A%84%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90"><span class="toc-number">9.2.2.2.</span> <span class="toc-text">插入排序的算法分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A2%9E%E9%95%BF%E9%87%8F%E7%BA%A7"><span class="toc-number">9.2.2.3.</span> <span class="toc-text">增长量级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95"><span class="toc-number">9.3.</span> <span class="toc-text">设计算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%B3%95"><span class="toc-number">9.3.1.</span> <span class="toc-text">分治法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">从鸽巢问题出发，我们看到什么</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89"><span class="toc-number">11.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A5%E9%AA%A4"><span class="toc-number">11.2.</span> <span class="toc-text">步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E5%89%B2%E9%92%A2%E6%9D%A1%E9%97%AE%E9%A2%98"><span class="toc-number">11.3.</span> <span class="toc-text">切割钢条问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F"><span class="toc-number">11.3.1.</span> <span class="toc-text">一般形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%92%E5%BD%92%E8%B0%83%E7%94%A8%E6%A0%91%E5%88%86%E6%9E%90"><span class="toc-number">11.3.2.</span> <span class="toc-text">递归调用树分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E4%B8%A4%E7%A7%8D%E7%AD%89%E4%BB%B7%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95"><span class="toc-number">11.3.3.</span> <span class="toc-text">动态规划的两种等价实现方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">贪心算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">霍夫曼编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%91%8A%E8%BF%98%E5%88%86%E6%9E%90-amortized-analysis"><span class="toc-number">13.1.</span> <span class="toc-text">摊还分析（amortized analysis）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">Progamming Checklist</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">怎样把递归转迭代</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">15.1.</span> <span class="toc-text">必要条件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">15.2.</span> <span class="toc-text">二叉树的例子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">15.2.1.</span> <span class="toc-text">二叉树的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.2.</span> <span class="toc-text">前序遍历 - 迭代实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.3.</span> <span class="toc-text">中序遍历 - 迭代实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.4.</span> <span class="toc-text">中序遍历 - 迭代实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.5.</span> <span class="toc-text">后序遍历 - 迭代实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86-bfs-%E8%BF%AD%E4%BB%A3%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.2.6.</span> <span class="toc-text">层序遍历（BFS）- 迭代实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%9A%84%E9%80%9A%E7%94%A8%E9%80%92%E5%BD%92%E8%BD%AC%E8%BF%AD%E4%BB%A3%E6%A8%A1%E6%9D%BF"><span class="toc-number">15.2.7.</span> <span class="toc-text">简单的通用递归转迭代模板</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E6%9D%82%E9%80%92%E5%BD%92%E8%BD%AC%E8%BF%AD%E4%BB%A3%E7%A4%BA%E4%BE%8B"><span class="toc-number">15.2.8.</span> <span class="toc-text">复杂递归转迭代示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">图算法</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">18.</span> <span class="toc-text">回溯</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">19.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%8A%B6%E6%80%81%E5%88%86%E7%B1%BB%E8%A1%A8"><span class="toc-number">19.1.</span> <span class="toc-text">动态规划状态分类表</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>