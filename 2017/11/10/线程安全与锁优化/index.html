<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>线程安全与锁优化 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级： 线程安全的分类 不可变 不可变的数据，都是线程安全的。不可变的对象引用，加上所有field都是不可变的。如果有得选，尽量连方">
<meta property="og:type" content="article">
<meta property="og:title" content="线程安全与锁优化">
<meta property="og:url" content="https://magicliang.github.io/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级： 线程安全的分类 不可变 不可变的数据，都是线程安全的。不可变的对象引用，加上所有field都是不可变的。如果有得选，尽量连方">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-29.jpg">
<meta property="article:published_time" content="2017-11-10T11:51:43.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:31.898Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-29.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "线程安全与锁优化",
  "url": "https://magicliang.github.io/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/",
  "image": "https://magicliang.github.io/img/wall-paper-29.jpg",
  "datePublished": "2017-11-10T11:51:43.000Z",
  "dateModified": "2025-10-22T08:01:31.898Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '线程安全与锁优化',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-29.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">线程安全与锁优化</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">线程安全与锁优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2017-11-10T11:51:43.000Z" title="Created 2017-11-10 19:51:43">2017-11-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:31.898Z" title="Updated 2025-10-22 16:01:31">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>15mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>线程安全</h1>
<h2 id="什么是线程安全">什么是线程安全</h2>
<p>“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。”</p>
<p>相对的线程安全，可以分成五个等级：</p>
<h2 id="线程安全的分类">线程安全的分类</h2>
<h3 id="不可变">不可变</h3>
<p>不可变的数据，都是线程安全的。不可变的对象引用，加上所有field都是不可变的。如果有得选，尽量连方法都是final的。</p>
<h3 id="绝对线程安全">绝对线程安全</h3>
<p>Vector不是线程安全的。它也会出现并发修改时 Out of Range 的异常（注意，不是 ConcurrentModification 的异常）。</p>
<h3 id="相对线程安全">相对线程安全</h3>
<p>需要保证对这个对象的单独操作是线程安全的，在调用的时候不需要加上额外的保障措施。对于特定顺序的连续操作，就需要额外的同步来保证调用的正确性了。</p>
<h3 id="线程兼容">线程兼容</h3>
<p>可以通过特殊手段做到线程安全的普通类，绝大部分类都属于相对线程安全的。</p>
<h3 id="线程对立">线程对立</h3>
<p>线程对立，是不管调用端是否采取了同步措施，都无法在多线程环境中使用的代码。常见的线程对立的操作还有 suspend()，resume()， System.setIn()，System.setOut()和System.runFinalizerOnExit()。</p>
<h2 id="线程安全的实现">线程安全的实现</h2>
<h3 id="互斥同步-mutual-exclusion-synchronization">互斥同步（Mutual Exclusion &amp; Synchronization)</h3>
<p>这是最常见（也是我们在考虑并发问题的时候，首先应该考虑的万能解决方案，也是《Java并发编程实践》和《Thinking in Java 》中最推荐的做法。）的保障并发正确性的手段。同步是指在多个线程并发访问共享数据的时候，保证共享数据在同一个时刻只被一条（使用信号量的话，多条）线程访问。而互斥是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量都是实现互斥的常见方式。互斥是因，同步是果，互斥是方法，同步是目的。这些同步的手段，同样也会出现在 OS 层面上。同步的终极目标，应该是化并发的乱序，转化为类型无并发时的有序。</p>
<p>在 Java 里面，最基本的互斥手段就是 synchronized 关键字。它经过编译后，会转化为 moniterenter 和 moniterexit 这两个字节码指令（bytecode instructions）。这两个字节码都需要一个 reference 类型的参数来指明加锁和解锁的对象。我们当然都知道，这个reference，不是一个平凡对象实例，就是一个 Class 对象了。</p>
<p>根据虚拟机规范，在执行 monitorenter 指令时，首先尝试获取对象的锁（实际上就是去用线程信息写 markword）。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，那么把锁的计数器加1。相应地，在执行 monitorexit 时，会对计数器减1，当计数器为0时，锁就被释放了。从某种意义上来讲，这种设计可以在分布式场景下用 Redis 实现。如果获取锁失败了，那么就会进入阻塞状态，直到对象锁被释放为止。虚拟机规范对 monitorenter 和 monitorexit 两条指令的行为描述中，有两点是需要特别注意的。<strong>首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死（阻塞）的情况。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入</strong>对于映射到操作系统原生进程的实现，不管是阻塞还是唤醒线程，都需要操作系统的调用帮忙，也就会牵涉到用户态转变入核心态的问题（系统控制权从用户空间转入内核空间）。<strong>这种切换需要消耗很多 CPU 时间。这也是为什么它是昂贵的原因，时间是最昂贵的。对于很多简单的getter()、setter（）操作，花在状态切换上的时间，甚至会多过用户代码执行的时间。甚至可以认为，这样的状态切换需要使用很多的汇编指令代码，以至于要使用很多的 cpu 时钟周期</strong>。因此synchronized本身是一种重量级（Heavyweight）操作。JVM（注意，不是Java语言） 本身可能会对重量锁进行优化，使用自旋来避免频繁地切入核心态之中（自旋难道就不浪费CPU 时间了吗？）。</p>
<p>J.U.C包里专门提供了Reentrantlock来实现同步。它同样具有 syncrhonized具有的可重入、阻塞其他求锁者的特性。但它还具有三个额外的特点（中、公、多条件，支持某些场景下的任务调度需求）：</p>
<ol>
<li>等待可中断。Lock接口有实现类可以实现试锁，超时试锁等功能。这样synchronized中，其他求锁线程傻等的情况可以避免。</li>
<li>公平锁。公平锁指的是按照求锁顺序来分配锁（求锁也是有顺序的）。默认的锁（synchronized 和 ReentrantLock 的默认构造函数）是非公平的，随机给予锁，这样性能更好。synchronized 本身并不内置公平锁，aqs 的公平锁通过允许插队，来减少 cpu 时间片花在调度/cpu上下文切换上的开销，来获得更高的吞吐。很多文档认为，如果排队会带来更多的 cpu 调度，似乎只是人云亦云，也没有讲清楚为什么。非公平锁的吞吐会更好，而公平锁免饥饿。ReentrantLock 默认使用非公平锁。</li>
<li>绑定多个条件。在 synchronized 的时代，多个 condition 就意味着多层 synchronized。</li>
</ol>
<p>synchronized 的性能屡屡被 JVM 的实现者改进，因此还是优先要使用synchronized（《TIJ》、《Java 并发实践》和《深入理解 Java 虚拟机》到此达到了同一结论）。</p>
<h3 id="非阻塞同步-non-blocking-synchronization">非阻塞同步（Non-Blocking Synchronization)</h3>
<p>也就是我们常说的乐观策略。不需要加锁，也就不需要负担线程状态切换的代价。但代价是，如果真的发生了冲突，乐观操作需要付出的代价就是补偿（compensation）。最常见的补偿，应该就是不断重试（又要引入自旋了）。乐观锁的核心基石，实际上是 CAS（CompareAndSet或者 CompareAndSwap），这两个操作必须是原子化操作，这就要求现代的处理器提供这样的指令原语（instruction primitive）。JVM 虚拟机里，专门通过  Unsafe 包来向上层提供这种原语的语义。</p>
<p>CAS操作有一个很讨厌的 ABA 问题。虽然 ABA 问题本身在大部分情况下不会引起问题，但J.U.C还是提供了一个 AtomicStampedReference操作来避免这个问题（所以说，<strong>带版本的原子值才是最安全的</strong>）。在大多数情况下，进入互斥同步，还比用这些鸡肋功能要高效（为什么？）。</p>
<h3 id="无同步方案">无同步方案</h3>
<h4 id="可重入代码-reentrant-code">可重入代码（Reentrant Code）</h4>
<p>也叫纯代码（Pure Code）。在它执行的任意时刻中断它，转而去执行另一端代码，再切换上下文回来以后，不会发生任何错误。所有可重入的代码都是线程安全的，但并非所有线程安全的代码都是可重入的。可重入性是基本的特性。</p>
<p>其实这就是函数式编程里的纯函数，<strong>所有的状态都由输入参数决定，结果可预测</strong>，不依赖其他global状态。这也是为什么函数式编程在高并发下是安全的，他们天然满足栈封闭的标准。</p>
<h4 id="线程本地存储">线程本地存储</h4>
<p>Thread中含有 ThreadLocalMap，而 ThreadLocal 的变量是 ThreadLocalMap 的 key，ThreadLocal 对应的 value <strong>，被ThreadLocalMap强引用。</strong></p>
<p>Thread -&gt; ThreadLocalMap -&gt; 弱引用 key（也就是我们的 ThreadLocal）<br>
-&gt;  强引用 value（也就是 ThreadLocal 自己的 value，经常被 init 操作的那个）</p>
<p>方法区静态变量 -&gt; 强引用 ThreadLocal<br>
ThreadLocalMap -&gt; 弱引用 ThreadLocal</p>
<blockquote>
<p>弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</p>
</blockquote>
<p>所以方法区静态变量=null会导致 ThreadLocal 会被回收，而 ThreadLocalMap 的key 会变成 null，再对 ThreadLocalMap 进行一次取值操作 ThreadLocalMap 就会把 value清除。这些条件的任一被破坏，都会反过来造成内存泄漏。</p>
<p>key 经常被声明为静态变量，这个静态变量如果泄露，就是方法区泄露。但 ThreadLocalMap 对 ThreadLocal 的弱引用与它无关，所以它自身的泄露和对静态变量生命周期的管理有关。</p>
<p>value 可能被跨线程混用，所以每个线程处理完以后都要及时 remove。它被 ThreadLocalMap 强引用，但只要频繁使用 ThreadLocalMap，它内部的自带方法都会隐式地 expunge 掉这些过期的 key-也就是说，只要 key 设为 null 了，entry 会被自动消灭。所以 value 的泄露实际上是由 key 的泄露导致的。<strong>value 本身并不被 key referenced，它是被 map referenced。</strong></p>
<p>因此，我们需要至少做几件事：<br>
1.尽可能手动地 remove ThreadLocal 的value。<br>
2. 尽可能关掉线程（在使用线程池的方案里，这恐怕很难做到）。<br>
3. 尽量触发一些 get/set/remove 操作，让 ThreadLocal 的内部操作把的 stale 的 给去除引用。</p>
<h1>对象头</h1>
<p>需要参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26357186/what-is-in-java-object-header">What is in Java object header?</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_50275872/article/details/124302457">并发编程的艺术（3）：深入理解Synchronized的原理</a></li>
</ol>
<p>在 32 位虚拟机里：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">普通对象<br>|<span class="hljs-string">--------------------------------------------------------------</span>|<br>|<span class="hljs-string">                   Object Header (64 bits)                    </span>|<br>|<span class="hljs-string">------------------------------------</span>|<span class="hljs-string">-------------------------</span>|<br>|<span class="hljs-string"> Mark Word (32 bits)                </span>|<span class="hljs-string"> Klass Word (32 bits)    </span>|<br>|<span class="hljs-string">------------------------------------</span>|<span class="hljs-string">-------------------------</span>|<br>数组对象<br>|<span class="hljs-string">---------------------------------------------------------------------------------</span>|<br>|<span class="hljs-string">                                 Object Header (96 bits)                         </span>|<br>|<span class="hljs-string">--------------------------------</span>|<span class="hljs-string">-----------------------</span>|<span class="hljs-string">------------------------</span>|<br>|<span class="hljs-string"> Mark Word(32bits)              </span>|<span class="hljs-string"> Klass Word(32bits)    </span>|<span class="hljs-string"> array length(32bits)   </span>|<br>|<span class="hljs-string">--------------------------------</span>|<span class="hljs-string">-----------------------</span>|<span class="hljs-string">------------------------</span>|<br>标记字是<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> Mark Word (32 bits)                                   </span>|<span class="hljs-string"> State              </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> hashcode:25 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:0              </span>|<span class="hljs-string"> 01 </span>|<span class="hljs-string"> Normal             </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> thread:23 </span>|<span class="hljs-string"> epoch:2 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1      </span>|<span class="hljs-string"> 01 </span>|<span class="hljs-string"> Biased             </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> ptr_to_lock_record:30(lock_record指针)           </span>|<span class="hljs-string"> 00 </span>|<span class="hljs-string"> Lightweight Locked </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> ptr_to_heavyweight_monitor:30(monitor指针)       </span>|<span class="hljs-string"> 10 </span>|<span class="hljs-string"> Heavyweight Locked </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string">                                                  </span>|<span class="hljs-string"> 11 </span>|<span class="hljs-string"> Marked for GC      </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>在64位虚拟机里<br>|<span class="hljs-string">--------------------------------------------------------------</span>|<br>|<span class="hljs-string">                     Object Header (128 bits)                 </span>|<br>|<span class="hljs-string">-------------------------------</span>|<span class="hljs-string">------------------------------</span>|<br>|<span class="hljs-string">          Mark Word (64 bits)  </span>|<span class="hljs-string">         Klass Word (64 bits) </span>|<br>|<span class="hljs-string">-------------------------------</span>|<span class="hljs-string">------------------------------</span>|<br>标记字是<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> Mark Word (64 bits)                                              </span>|<span class="hljs-string"> State              </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> unused:25 </span>|<span class="hljs-string"> hashcode:31 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:0 </span>|<span class="hljs-string"> 01  </span>|<span class="hljs-string"> Normal             </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> thread:54 </span>|<span class="hljs-string"> epoch:2 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1     </span>|<span class="hljs-string"> 01  </span>|<span class="hljs-string"> Biased             </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> ptr_to_lock_record:62                                      </span>|<span class="hljs-string"> 00  </span>|<span class="hljs-string"> Lightweight Locked </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> ptr_to_heavyweight_monitor:62                              </span>|<span class="hljs-string"> 10  </span>|<span class="hljs-string"> Heavyweight Locked </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string">                                                            </span>|<span class="hljs-string"> 11  </span>|<span class="hljs-string"> Marked for GC      </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br></code></pre></td></tr></table></figure>
<p><img src="monitor%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="monitor的结构"></p>
<p>我们大致上认为一个对象应该分为 object header 和 object body，然后再把header 分为 markword 和 klass pointer。markword 本身在对象生命周期里面表现得像 union 一样可变，是让研究 synchronized 的人最头痛的。</p>
<p><img src="%E9%94%81%E7%9A%84%E4%B8%89%E9%87%8D%E5%AF%B9%E8%B1%A1%E9%93%BE%E6%8E%A5.png" alt="锁的三重对象链接"></p>
<p>通常我们可以看到 thread 会维护 lock record/monitor record；monitor 会维护两种 set和 owner（aqs 原理的原型），似乎可以被看成操作系统的 mutext lock 在 jvm 里的句柄；object 本身使用一个 object header。</p>
<h1>锁优化</h1>
<p><img src="synchronized%E5%8E%9F%E7%90%86.jpg" alt="synchronized原理"><br>
<img src="%E9%94%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt="锁对象的变化流程"></p>
<p>所有的锁优化其实是 synchronized 优化。</p>
<h2 id="自旋锁-spinning-lock">自旋锁（Spinning Lock）</h2>
<p>一个已经拥有 CPU 执行时间的线程，在求锁的时候，如果直接被阻塞，其实是会降低操作系统的并发性能。所以这种时候可以让线程执行一个忙循环（busy waiting，怎么做到的？ PC jump 到一个一段被插入的代码上吗？）。循环的次数通常是不是很多，也就是10次而已。这个次数可以通过 -XX:PreBlockSpin 调整。当前版本的 JVM 还引入了自适应自旋锁（Adaptive Spinning）。自旋锁不适合长时间等待，那种情况下浪费的 CPU 时间实在太多了。CAS 这种非常小的 Set 值操作适合使用自旋锁。</p>
<h2 id="锁消除-lock-elimination">锁消除（Lock Elimination）</h2>
<p>如果 JVM 通过逃逸分析，可以去除掉不必要的同步。<br>
可以消除掉 Reentrantlock吗？根据<a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/~aldrich/papers/scp-camera.pdf">这篇文</a>，是可以的。</p>
<h2 id="锁粗化-lock-coarsening">锁粗化（Lock Coarsening）</h2>
<p>多个连续的频繁加锁，可能被虚拟机优化为一把大锁。</p>
<h2 id="轻量级锁-lightweight-lock">轻量级锁（Lightweight Lock）</h2>
<p>轻量级锁本身是 JDK 1.6 以后才加入的新型锁机制，它名字中的“轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的（<strong>Mutex等于重量锁，在不同的场景下又称 Mutext Lock、fat lock。可以认为OS的系统调用提供了并发机制-线程，就会必然提供互斥量机制。</strong>）。它不是用来代替重量级锁的，用意是在多线程竞争不激烈的情况下，减少重量级锁的使用，来减少性能消耗。</p>
<p>我们已经知道，对象头（Object Header）分成两个部分（不算Padding的话），“Mark Word” 与 Klass Point。Mark Word 的大小取决于虚拟机的版本，分别是32bits 和 64bits（总之总是字长对齐）。数组对象的 Klass Point 还有一个额外的部分存储数组长度。轻量级锁和偏向锁的关键是“Mark Word”。</p>
<p>“Mark Word”被设计成一个非固定的数据结构，以便在极小的空间内存储尽量多的信息。因此，它的内存布局是可变的。要动态地理解对象的数据结构，可以采用 jol 工具：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student stu=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(<span class="hljs-string">&quot;=====加锁之前======&quot;</span>);<br>        System.out.println(ClassLayout.parseInstance(stu).toPrintable());<br>        <span class="hljs-keyword">synchronized</span> (stu)&#123;<br>            System.out.println(<span class="hljs-string">&quot;=====加锁之后======&quot;</span>);<br>            System.out.println(ClassLayout.parseInstance(stu).toPrintable());<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储所对象目前的 Mark Word的拷贝（实际上被命名为 Displaced Markd Word）。<strong>也就是说，试图求锁的线程局部栈帧可能是不一样的。</strong></p>
<p>然后虚拟机试图使用 CAS 操作尝试将对象的Mark Word 更新为指向 Lock Record 的指针（<strong>注意是整个Mark Word</strong>）。如果更新成功了，那么线程就拥有了该对象的锁，并且 Mark Word 的**锁标志位（Markword的最后两位）**转变为“00”。如果这个更新失败了，虚拟机首先会检查对象的 Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word也就变成指向重量级锁的指针（<strong>也就是说，不再指向 Lock Record</strong>）。</p>
<p>轻量级锁的解锁过程，也必须借助 CAS 操作，把 Displaced Mark Word 的值写到 Mark Word 上。如果替换完成，同步结束。如果替换失败，证明有其他线程常识获取过该锁，那就要在释放锁的同时（<strong>可以看出此时锁已经膨胀过了，也就意味着要去释放 mutex，岂不是不对称的操作？</strong>），唤醒被挂起的线程。</p>
<p><img src="https://ws1.sinaimg.cn/large/66dd581fly1flsf4024taj20h40a5q5u.jpg" alt=""></p>
<p><img src="https://ws1.sinaimg.cn/large/66dd581fly1flsf43kk1vj20d40abtb2.jpg" alt=""></p>
<p>轻量级锁在发生竞争时，依然会出现锁膨胀，而且还加上了CAS的开销，反而比直接使用重量级锁更慢。使用偏向锁只能根据一种经验假定，“绝大部分锁，在同步周期内是不存在竞争的”。</p>
<p>从这个过程我们可以看出来，mark word里并不是存了线程号，而是直接把mark word指向了目标线程的栈帧，轻量级锁和重量级锁的差别就在于底层是不是会触发 Mutex。</p>
<h2 id="偏向锁-biased-lock">偏向锁（Biased Lock）</h2>
<p>偏向锁也是 JDK 1.6 中引入的一项锁优化。它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁在无竞争的情况下使用 CAS操作去消除同步使用的互斥量，偏向锁就是在无竞争的情况下，把整个同步过程都消除掉，连 CAS 都不做了。</p>
<p>偏向锁的偏，是偏心的。这个锁会偏向于第一个获得它的线程，如果接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。从这点来看，<strong>偏向锁导致同步消除了，等同于锁消除了。但锁消除并不等同于偏向锁，可能有JIT自己去掉同步代码的优化</strong>。</p>
<p>当对象在第一次被线程锁定的时候，虚拟机会把标志位设置为“01”（<strong>至此标志位已经被用尽了</strong>）。同时使用 CAS 模式（<strong>因为此时还不能保证没有竞争</strong>）试图把线程 ID 写入 Mark Word中（<strong>此处就真的写入线程号了</strong>）。如果CAS成功，那么以后再进入同步块，都不需要执行任何同步操作。</p>
<p>如果这个时候发生锁竞争，则会发生撤销偏向（Revoke Bias），对象回到未锁定状态，然后进入轻量级锁的竞争阶段（难道不是直接进入重量级锁的竞争阶段吗？）。偏向锁是默认打开的，很多推荐的JVM配置都关掉它，因为多线程竞争很激烈的情况下，偏向锁的假定往往会失效（轻量级锁实际上也会失效）。所以可以用 -XX:-UseBiasedLocking 来关闭偏向锁。</p>
<p>所以锁的变化过程就是无锁-&gt;偏向锁-&gt;轻量级锁-&gt;重量级锁。</p>
<p>偏向锁在 JVM 内部的实现实在太复杂了，<a target="_blank" rel="noopener" href="https://blog.csdn.net/guanshengg/article/details/126435955">从 Java 15 开始要逐步 deprecated</a>，在日常的 JVM 使用里面，很多团队为了性能考量，也会直接关闭偏向锁（非常多的 JVM 优化书籍也对使用这种锁提出反对意见）。可以认为，在 Java 6-15期间，偏向锁是默认打开，需要显式关闭的；在 Java 15 以后，偏向锁是默认关闭，需要显式打开，未来应该会删除。</p>
<p>无锁和轻量级锁的差别是：</p>
<ul>
<li>无锁是自旋修改同步资源：无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</li>
<li>轻量级锁是自旋抢锁而不是阻塞抢锁：是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</li>
</ul>
<p>如果硬要对比，可能无锁更像是 AQS 里面的 casSetSate，而轻量级锁可能像是 acquire。</p>
<p><img src="https://ws1.sinaimg.cn/large/66dd581fly1flsf7eso0hj21380jdn6j.jpg" alt=""></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">https://magicliang.github.io/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-29.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-140.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a><a class="pagination-related" href="/2017/11/03/JVM-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="JVM 的内存模型与线程"><img class="cover" src="/img/wall-paper-27.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-03</div><div class="info-item-2">JVM 的内存模型与线程</div></div><div class="info-2"><div class="info-item-1">1.性能何处寻   计算机的CPU比起其他所有的设备，都快得多，所以怎样尽量复用 CPU 的时间片，是压榨计算机性能的目标。多核和并发，使得阿姆达尔定律大显神威，超越摩尔定律成为提升系统性能的金科玉律 - 现在单核计算能力已经无法垂直提升，要水平提升核数来提升整体性能。 2.缓存一致性问题（Cache Coherence）   软件缓存，不过是硬件缓存的模仿，真正的缓存，早已存在于计算机的多级存储体系结构中。JVM 里，我们可以认为每个处理器都会在主内存（Main Memory）之外有高速缓存作为工作内存（Working memory）。除此之外，处理器和 JVM 都可能出现指令重排（Instruction Reorder）的的情况。工作内存是线程 Save 和 Load 的主要场所，主内存则是他们沟通的场所。 3.JVM 的对象信息   Java Object 除了基本的内存轮廓以外，还有：  Mark Word（对象的 Hash Code 的缓存值、GC标志、GC年龄、同步锁等信息）。 Klass Point（指向对象元数据信息的指针，指向 .class  的指针吗？不是，是...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-143.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">上下文 卡表和 RSet（Remember Set），是 JVM 为了解决分代收集时，live set 扫描需要穿梭到不同的代的时候的效率问题。 使用缓存表来提高查询效率，是化顺序查找为部分随机查找的一种常用的设计思路。 例如，在传统的计算机体系结构中，当我们把内存分成页以后，会有一个页表，页表又会有一个快表，作为一个中间缓存项，来帮助我们查找我们需要使用的页表项（table entry）。 JVM 在进行垃圾收集的时候，有一项非常重要的工作就是确定这一次垃圾收集的对象到底有多少个，即确定 live set 的范围。 对于新生代垃圾收集器而言，这个问题又有其特殊之处。根据 JVM 的弱分代收集假设（weak generational hypothesis）的存在，每次垃圾收集的时候，新生代的扫描范围可能很大，但新生代的 live set 不应该太大。card table/Remember Set 的设计目的，就是尽量减少无用的垃圾扫描范围，使用类似操作系统或者数据库的脏页表的形式，来做类似快表的查询。 卡表（card table）  卡表是 CMS 的解决方案。 卡表通常在 JV...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a><a class="pagination-related" href="/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" title="重述双亲委派模型"><img class="cover" src="/img/wall-paper-105.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-05</div><div class="info-item-2">重述双亲委派模型</div></div><div class="info-2"><div class="info-item-1">何时加载类  遇到 new、getstatic、putstatic 等指令时。 对类进行反射调用的时候。 初始化某个类的子类的时候。 虚拟机启动时会先加载设置的程序主类。 使用 dynamic 动态语言支持等相关特性时。  从 Java 到 cpp 源码分析  JVM 默认用于加载用户程序的ClassLoader为AppClassLoader，不过无论是什么ClassLoader，它的根父类都是java.lang.ClassLoader。在上面那个例子中，loadClass（）方法最终会调用到ClassLoader.definClass1（）中，这是一个 Native 方法。  12static native Class&lt;?&gt; defineClass1(ClassLoader loader, String name, byte[] b, int off, int len,                                        ProtectionDomain pd, String source);   definClass1（）对应的 JNI ...</div></div></div></a><a class="pagination-related" href="/2020/03/08/JMX-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9/" title="JMX 深度历险"><img class="cover" src="/img/wall-paper-170.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-08</div><div class="info-item-2">JMX 深度历险</div></div><div class="info-2"><div class="info-item-1">JMX 常见指标 JVM 指标 系统指标    System 相关指标 描述     system.load.average 系统load，如果是docker，此指标收集的物理机的load   cpu.system.load.percent 系统所有进程占用cpu的百分比   cpu.jvm.load.percent jvm占用cpu的百分比   system.process.used.phyical.memory 系统使用的物理内存   system.process.used.swap.size 系统使用的swap内存    JVM 内存指标    JVM相关指标 描述     jvm.gc.count GC的次数   jvm.gc.time GC的时间，单位毫秒   jvm.younggc.count 年轻代GC的次数 ，包括的GC算法（Copy，ParNew，PS Scavenge，G1 Young Generation）   jvm.younggc.time 年轻代GC的时间，单位毫秒   jvm.fullgc.count 年老代GC的次数，包括的GC算法   jvm.f...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.1.</span> <span class="toc-text">什么是线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">线程安全的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">1.2.1.</span> <span class="toc-text">不可变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.2.2.</span> <span class="toc-text">绝对线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.2.3.</span> <span class="toc-text">相对线程安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%BC%E5%AE%B9"><span class="toc-number">1.2.4.</span> <span class="toc-text">线程兼容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AF%B9%E7%AB%8B"><span class="toc-number">1.2.5.</span> <span class="toc-text">线程对立</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">线程安全的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5-mutual-exclusion-synchronization"><span class="toc-number">1.3.1.</span> <span class="toc-text">互斥同步（Mutual Exclusion &amp; Synchronization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5-non-blocking-synchronization"><span class="toc-number">1.3.2.</span> <span class="toc-text">非阻塞同步（Non-Blocking Synchronization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.3.</span> <span class="toc-text">无同步方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A3%E7%A0%81-reentrant-code"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">可重入代码（Reentrant Code）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">线程本地存储</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">对象头</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81-spinning-lock"><span class="toc-number">3.1.</span> <span class="toc-text">自旋锁（Spinning Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4-lock-elimination"><span class="toc-number">3.2.</span> <span class="toc-text">锁消除（Lock Elimination）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96-lock-coarsening"><span class="toc-number">3.3.</span> <span class="toc-text">锁粗化（Lock Coarsening）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-lightweight-lock"><span class="toc-number">3.4.</span> <span class="toc-text">轻量级锁（Lightweight Lock）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81-biased-lock"><span class="toc-number">3.5.</span> <span class="toc-text">偏向锁（Biased Lock）</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>