<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>昂贵的异常 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwi">
<meta property="og:type" content="article">
<meta property="og:title" content="昂贵的异常">
<meta property="og:url" content="https://magicliang.github.io/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwi">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-140.jpg">
<meta property="article:published_time" content="2017-10-23T11:29:39.000Z">
<meta property="article:modified_time" content="2025-10-22T08:01:31.897Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="异常处理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-140.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "昂贵的异常",
  "url": "https://magicliang.github.io/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/",
  "image": "https://magicliang.github.io/img/wall-paper-140.jpg",
  "datePublished": "2017-10-23T11:29:39.000Z",
  "dateModified": "2025-10-22T08:01:31.897Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '昂贵的异常',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-140.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">昂贵的异常</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">昂贵的异常</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2017-10-23T11:29:39.000Z" title="Created 2017-10-23 19:29:39">2017-10-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2025-10-22T08:01:31.897Z" title="Updated 2025-10-22 16:01:31">2025-10-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">3.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>11mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="抛出问题">抛出问题</h2>
<p>  Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。</p>
<blockquote>
<p>Throwing exception is expensive.</p>
</blockquote>
<p>  这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%8C%B4%E5%AD%90%E5%AE%9A%E5%BE%8B/6268365">猴子定律</a>，人们忘记了为什么不能这么做，却不明白为什么不能这么做。</p>
<p>  这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序运行性能！在开启JIT的情况下，throw也不会增加多少系统开销。”实际上这篇文章也做了一些对比，在不同的场景下，try-catch 会不会让系统变慢。</p>
<p>文中还提到一个有趣的实验：</p>
<hr>
<p>代码 A</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">// throw exception;</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码 B</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实验结果是：</p>
<table>
<thead>
<tr>
<th style="text-align:center">异常抛出</th>
<th style="text-align:center">关闭JIT</th>
<th style="text-align:center">开启JIT(默认开启)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无异常抛出</td>
<td style="text-align:center">两者耗时几乎相同</td>
<td style="text-align:center">两者耗时几乎相同</td>
</tr>
<tr>
<td style="text-align:center">A每次都抛异常</td>
<td style="text-align:center">A耗时约是B的30倍</td>
<td style="text-align:center">两者耗时几乎相同</td>
</tr>
</tbody>
</table>
<hr>
<p>  这几乎推翻了我们既有的刻板印象，从此抛出异常不再是一个需要考虑性能的设计决定了。在仔细研究了这个问题以后，我却有了一个不同的结论：try-catch 语句在 jit 的帮助下 ，也许可以达到和正常 return 一样的性能 ，然而 throw 却会产生远比文中描述的更严重的性能影响 ，因为 throw 不是孤立的语句，它必须伴随着异常对象的创建，而异常对象的创建的昂贵代价，是不可能被 jit 优化掉的。也就是说，我认为[《Java虚拟机是如何处理异常的》][3]中结论的前半部分是正确的，后半部分是不准确的。</p>
<h2 id="异常的机制">异常的机制</h2>
<p>  JVM 的异常处理机制，大致可以分为三个部分 ：</p>
<ol>
<li>new Exception</li>
<li>throw Exception</li>
<li>catch and deal with Exception</li>
</ol>
<p>  通过[《Java虚拟机是如何处理异常的》][4]我们已经可以明确理解，JVM 对于 try-throw-catch 的程序控制流处理，与普通的 return 如出一辙，都是基于程序计数器的改变，直接使得控制流发生跳转，并无特别之处。而 catch 异常如果为空（即如果我们生吞异常），则开销上看起来和平凡 return 一样。然而，new Exception 实际上是一个非常昂贵的操作。因为异常对象在生成的时候，其父类构造函数 Throwable 中的一部分会调用 fillInStackTrace() 操作。这个 fillInStackTrace() 函数，会试图把当前抛出异常的栈帧全都囊括在内，在实际的运行之中，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/299068/how-slow-are-java-exceptions">有可能导致复杂的 CPU 寄存器读写操作</a>。这种读写操作的复杂度与是否使用 jit 无关，也就不可能为 jit 锁优化，是一种很昂贵的固定成本。<br>
  [《Java虚拟机是如何处理异常的》][6]中提到的实验并不代表 Java in real world 的工作状况，因为现实中几乎没有栈深只为1的方法调用，一个框架或者容器，本身就会带来几十层的调用栈深度。</p>
<h2 id="一个实验">一个实验</h2>
<p>  StackOverflow 上已经有很多人做了相关的实验，我也决定试试用以下代码来印证自己的结论：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Param(&#123; &quot;1&quot;, &quot;100&quot;, &quot;200&quot;, &quot;1000&quot;, &quot;2000&quot;&#125;)</span><br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> recursiveDepth;<br><br> <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">returnMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> recursiveDepth)</span> &#123;<br>     <span class="hljs-keyword">if</span> ( recursiveDepth &gt; <span class="hljs-number">0</span> ) &#123;<br>         <span class="hljs-keyword">return</span> returnMethod(recursiveDepth - <span class="hljs-number">1</span>);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>     &#125;<br> &#125;<br><br><br> <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">throwMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> recursiveDepth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>     <span class="hljs-keyword">if</span> ( recursiveDepth &gt; <span class="hljs-number">0</span> ) &#123;<br>         <span class="hljs-keyword">return</span> throwMethod(recursiveDepth - <span class="hljs-number">1</span>);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>     &#125;<br> &#125;<br><br> <span class="hljs-comment">// 一定要是公开方法</span><br> <span class="hljs-meta">@Benchmark</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">benchMarkReturn</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">// 一定要明确使用返回结果，不然 JIT会优化掉很多东西。</span><br>     System.out.printly(returnMethod((recursiveDepth)));<br> &#125;<br><br> <span class="hljs-meta">@Benchmark</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">benchMarkThrow</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">try</span> &#123;<br>         throwMethod((recursiveDepth));<br>     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>         <span class="hljs-comment">// 一定要明确使用返回结果，不然 JIT会优化掉很多东西。</span><br>         System.out.println(e);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>  这是一个基于 JMH 的测试方案，先预热一万轮，再跑一万轮 benchmark 方法，使 jit 完全发挥作用。实验环境是 CentOS 7，使用 Java 8 的 JVM，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html">默认打开了分层编译</a>。栈深度分别为1、100，200，1000，2000。</p>
<p>  实验结果如下：</p>
<hr>
<table>
<thead>
<tr>
<th style="text-align:center">测试方法</th>
<th style="text-align:center">栈深度</th>
<th style="text-align:center">操作平均耗时（微秒）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">benchMarkReturn</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0.002</td>
</tr>
<tr>
<td style="text-align:center">benchMarkThrow</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1.462</td>
</tr>
<tr>
<td style="text-align:center">benchMarkReturn</td>
<td style="text-align:center">100</td>
<td style="text-align:center">0.178</td>
</tr>
<tr>
<td style="text-align:center">benchMarkThrow</td>
<td style="text-align:center">100</td>
<td style="text-align:center">15.200</td>
</tr>
<tr>
<td style="text-align:center">benchMarkReturn</td>
<td style="text-align:center">200</td>
<td style="text-align:center">0.369</td>
</tr>
<tr>
<td style="text-align:center">benchMarkThrow</td>
<td style="text-align:center">200</td>
<td style="text-align:center">28.595</td>
</tr>
<tr>
<td style="text-align:center">benchMarkReturn</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">1.864</td>
</tr>
<tr>
<td style="text-align:center">benchMarkThrow</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">152.968</td>
</tr>
<tr>
<td style="text-align:center">benchMarkReturn</td>
<td style="text-align:center">2000</td>
<td style="text-align:center">7.563</td>
</tr>
<tr>
<td style="text-align:center">benchMarkThrow</td>
<td style="text-align:center">2000</td>
<td style="text-align:center">238.049</td>
</tr>
</tbody>
</table>
<hr>
<p>  我们可以清晰地看到：</p>
<ol>
<li>
<p>在相同的栈深度下，抛出异常的时间有可能有是返回普通的对象<br>
的时间的30倍到700倍。</p>
</li>
<li>
<p>在我们的实验里，可能因为存在边际效应，栈深为1的时候反而是性能差距最大的。</p>
</li>
</ol>
<p>  这也基本符合在网上看到的其他人的测试的结论（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/299068/how-slow-are-java-exceptions">例子1</a>，<a target="_blank" rel="noopener" href="https://plumbr.eu/blog/java/throwing-exceptions-slow-and-ugly">例子2</a>）。</p>
<p>  如果我们再试图在 catch 块里 printStackTrace()，性能差距只会更大。</p>
<h2 id="结论">结论</h2>
<blockquote>
<p>在开启JIT的情况下，throw也不会增加多少系统开销。</p>
</blockquote>
<p>  固然是实话。</p>
<p>  然而现实之中，throw 却不能离开任何 Throwable 的子类，我们在使用异常机制的时候，必须背负上生成栈帧这样一个沉重的负担，空谈 throw 的性能优化是无意义的。所以</p>
<blockquote>
<p>所以当你遇到有人说try-catch一定要少用会影响性能时，或许你就不会再去盲从这种“建议”了。</p>
</blockquote>
<p>却是一种过于乐观的结论。我们当然不能无节制地使用 try-catch，因它不仅使程序变得支离破碎，而且除非不会发生异常抛出，否则 JVM 对它进行的优化，只是杯水车薪。</p>
<p>  我们应当永远记住，抛出异常是昂贵的，不是因为 try-catch 是昂贵的，因为无论怎么使用异常，异常都是昂贵的。</p>
<p>附原文：</p>
<blockquote></blockquote>
<pre><code>编码时我们常常被要求尽量减少try-catch语句块，理由就是就算不抛异常它们也会影响性能。然而影响究竟有多大呢？语句块应该放在循环体内部还是外部呢？下面译文将详细阐释Java虚拟机处理异常的机制。
虽然文中没有进行性能分析，但文末提供了一些基准测试的文章，先把结论写在前头：try-catch语句块几乎不会影响程序运行性能！在开启JIT的情况下，throw也不会增加多少系统开销。
</code></pre>
<p>异常机制</p>
<p>异常机制可以让你顺利的处理程序运行过程中所遇到的许多意想不到的情况。为了说明Java虚拟机处理异常的方式，我们来看一个名为NitPickyMath的类，它提供了针对整型的求模运算。和直接进行运算操作不同的是，该方法除零情况下将抛出受检查的异常（checked exceptions）。在Java虚拟机中除零时同样也会抛出ArithmeticException异常。NitPickyMath类抛出的异常定义如下：</p>
<p>class DivideByZeroException extends Exception {<br>
}</p>
<p>NitPickyMath类的remainder方法简单地捕获并抛出了异常：</p>
<p>static int remainder(int dividend, int divisor)<br>
throws DivideByZeroException {<br>
try {<br>
return dividend % divisor;<br>
}<br>
catch (ArithmeticException e) {<br>
throw new DivideByZeroException();<br>
}<br>
}</p>
<p>remainder方法仅仅只是将两个int入参进行了求模运算（也使用了除法）。当除数为0时，求模运算将抛出ArithmeticException异常，该方法将捕获这个异常并抛出一个自定义DivideByZeroException异常。</p>
<p>DivideByZeroException 和ArithmeticException 的不同之处在于前者是受检查异常，而后者是非受检查异常。因此后者抛出时不需要在方法头添加throws语句。Error或RuntimeException类的所有子类都是非受检查异常（例如ArithmeticException就是RuntimeException的子类）。</p>
<p>使用javac对remainder方法进行编译，将得到如下字节码：</p>
<p>remainder方法主体的字节码序列:<br>
0 iload_0   // 压入局部变量0 (传入的除数)<br>
1 iload_1   // 压入局部变量0 (传入的被除数)<br>
2 irem      // 弹出除数, 弹出被除数, 压入余数<br>
3 ireturn   // 返回栈顶的int值 (余数)</p>
<p>catch语句的的字节码序列 (ArithmeticException):<br>
4 pop       // 弹出ArithmeticException引用（因为没被用到）<br>
5 new #5 <Class DivideByZeroException><br>
// 创建并压入新对象DivideByZeroException的引用</p>
<p>DivideByZeroException<br>
8 dup       // 复制栈顶的DivideByZeroException引用，因为它既要被初始化又要被抛出，初始化将消耗掉栈顶的一个引用<br>
9 invokenonvirtual #9 &lt;Method DivideByZeroException.<init>()V&gt;<br>
// 调用DivideByZeroException的构造器来初始化，栈顶引用出栈<br>
12 athrow    // 弹出Throwable对象的引用并抛出异常</p>
<p>可以看到remainder的字节码序列主要分成了两部分，第一部分是方法正常执行的路径，这部分对应的pc程序计数器偏移为0到3。第二部分是catch语句，pc偏移为4到12。</p>
<p>运行时，字节码序列中的irem指令将抛出ArithmeticException异常，虚拟机将会根据异常查表来找到可以跳转到的catch语句位置。每个含有catch语句的方法的字节码中都附带了一个异常表，它包含每个异常try语句块的条目（entry）。每个条目都有四项信息：起点、终点、跳转的pc偏移位置以及该异常类所在常量池中的索引。remainder方法的异常表如下所示：</p>
<p>Exception table：<br>
from  to  target  type<br>
0   4   4   <Class java.lang.ArithmeticException></p>
<p>上面的异常表显示了try语句块的起始位置为0，结束位置为4（不包含4），如果ArithmeticException异常在0-3的语句块中抛出，那么pc计数器将直接跳转到偏移为4的位置。</p>
<p>如果在运行时抛出了一个异常，那么java虚拟机会按顺序搜索整个异常表找到匹配的条目，并且仅会匹配到在其指定范围内的异常。当找到第一个匹配的条目后，虚拟机便将程序计数器设置为新的偏移位置，然后继续执行指令。如果没有条目被匹配到，java虚拟机会弹出当前的栈帧（停止执行当前方法），并继续向上（调用remainder方法的方法）抛出同样的异常。当然上级方法也不会继续正常执行的，它同样需要查表来处理该异常，如此反复。</p>
<p>开发者可以使用throw申明来抛出一个异常，就像remainder方法的catch块中那样。相应的字节码描述如下：<br>
操作码   操作数   描述<br>
athrow  无   弹出Throwable对象引用，并抛出该异常</p>
<p>athrow指令弹出操作数栈栈顶的引用，该引用应当为Throwable的子类 (或者就是 Throwable自身)。<br>
思考</p>
<p>回到开头讨论的话题，你觉得下面两段代码性能差异有多大<br>
A：</p>
<p>for (int i = 0; i &lt; 1000000; i++) {<br>
try {<br>
// throw exception;<br>
} catch (Exception e) {<br>
}<br>
}</p>
<p>B：</p>
<p>try {<br>
for (int i = 0; i &lt; 1000000; i++) {<br>
}<br>
} catch (Exception e) {<br>
}</p>
<p>这篇博客给出了结果以及基准测试方法：try catch 对性能影响 。</p>
<p>我也使用JMH进行了测试，环境和细节就不列出了。其中使用了-Xint参数控制JIT热点编译，结果如下：<br>
异常抛出  关闭JIT   开启JIT(默认开启)<br>
A无异常抛出  两者耗时几乎相同  两者耗时几乎相同<br>
A每次都抛异常   A耗时约是B的30倍  两者耗时几乎相同</p>
<p>了解了译文中的异常的机制后，我们知道try-catch其实不过是在class文件中加了一个异常表用于异常查表，如果没有异常抛出，程序的执行方式和不包含try-catch块完全相同。如果有异常抛出，那么性能的确会下降，而这是有throw导致的，与try-catch无关。此时需要根据实际的业务来预估该方法抛出异常的频率有多高，就算你不去管，当方法被执行次数过多时，java虚拟机也会通过JIT来编译这段方法，编译过后两者的执行效率也是几乎相同的。注意，关闭JIT后循环方法整体性能下降了几十倍。</p>
<p>所以当你遇到有人说try-catch一定要少用会影响性能时，或许你就不会再去盲从这种“建议”了。当然在知晓这个信息的同时，我们反倒更应该去思考如何从业务和代码逻辑的角度来适当地使用try-catch写出更漂亮的代码。</p>
<p>本文参考：<br>
<a target="_blank" rel="noopener" href="http://www.javaworld.com/article/2076868/learn-java/how-the-java-virtual-machine-handles-exceptions.html">http://www.javaworld.com/article/2076868/learn-java/how-the-java-virtual-machine-handles-exceptions.html</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/">https://magicliang.github.io/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">异常处理</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-140.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/img/wall-paper-29.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-10</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1">线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级： 线程安全的分类 不可变 不可变的数据，都是线程安全的。不可变的对象引用，加上所有field都是不可变的。如果有得选，尽量连方法都是final的。 绝对线程安全 Vector不是线程安全的。它也会出现并发修改时 Out of Range 的异常（注意，不是 ConcurrentModification 的异常）。 相对线程安全 需要保证对这个对象的单独操作是线程安全的，在调用的时候不需要加上额外的保障措施。对于特定顺序的连续操作，就需要额外的同步来保证调用的正确性了。 线程兼容 可以通过特殊手段做到线程安全的普通类，绝大部分类都属于相对线程安全的。 线程对立 线程对立，是不管调用端是否采取了同步措施，都无法在多线程环境中使用的代码。常见的线程对立的操作还有 suspend()，resume()， System....</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-143.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">上下文 卡表和 RSet（Remember Set），是 JVM 为了解决分代收集时，live set 扫描需要穿梭到不同的代的时候的效率问题。 使用缓存表来提高查询效率，是化顺序查找为部分随机查找的一种常用的设计思路。 例如，在传统的计算机体系结构中，当我们把内存分成页以后，会有一个页表，页表又会有一个快表，作为一个中间缓存项，来帮助我们查找我们需要使用的页表项（table entry）。 JVM 在进行垃圾收集的时候，有一项非常重要的工作就是确定这一次垃圾收集的对象到底有多少个，即确定 live set 的范围。 对于新生代垃圾收集器而言，这个问题又有其特殊之处。根据 JVM 的弱分代收集假设（weak generational hypothesis）的存在，每次垃圾收集的时候，新生代的扫描范围可能很大，但新生代的 live set 不应该太大。card table/Remember Set 的设计目的，就是尽量减少无用的垃圾扫描范围，使用类似操作系统或者数据库的脏页表的形式，来做类似快表的查询。 卡表（card table）  卡表是 CMS 的解决方案。 卡表通常在 JV...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-12.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a><a class="pagination-related" href="/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" title="重述双亲委派模型"><img class="cover" src="/img/wall-paper-105.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-05</div><div class="info-item-2">重述双亲委派模型</div></div><div class="info-2"><div class="info-item-1">何时加载类  遇到 new、getstatic、putstatic 等指令时。 对类进行反射调用的时候。 初始化某个类的子类的时候。 虚拟机启动时会先加载设置的程序主类。 使用 dynamic 动态语言支持等相关特性时。  从 Java 到 cpp 源码分析  JVM 默认用于加载用户程序的ClassLoader为AppClassLoader，不过无论是什么ClassLoader，它的根父类都是java.lang.ClassLoader。在上面那个例子中，loadClass（）方法最终会调用到ClassLoader.definClass1（）中，这是一个 Native 方法。  12static native Class&lt;?&gt; defineClass1(ClassLoader loader, String name, byte[] b, int off, int len,                                        ProtectionDomain pd, String source);   definClass1（）对应的 JNI ...</div></div></div></a><a class="pagination-related" href="/2020/03/08/JMX-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9/" title="JMX 深度历险"><img class="cover" src="/img/wall-paper-170.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-08</div><div class="info-item-2">JMX 深度历险</div></div><div class="info-2"><div class="info-item-1">JMX 常见指标 JVM 指标 系统指标    System 相关指标 描述     system.load.average 系统load，如果是docker，此指标收集的物理机的load   cpu.system.load.percent 系统所有进程占用cpu的百分比   cpu.jvm.load.percent jvm占用cpu的百分比   system.process.used.phyical.memory 系统使用的物理内存   system.process.used.swap.size 系统使用的swap内存    JVM 内存指标    JVM相关指标 描述     jvm.gc.count GC的次数   jvm.gc.time GC的时间，单位毫秒   jvm.younggc.count 年轻代GC的次数 ，包括的GC算法（Copy，ParNew，PS Scavenge，G1 Young Generation）   jvm.younggc.time 年轻代GC的时间，单位毫秒   jvm.fullgc.count 年老代GC的次数，包括的GC算法   jvm.f...</div></div></div></a><a class="pagination-related" href="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" title="现代垃圾收集器"><img class="cover" src="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-27</div><div class="info-item-2">现代垃圾收集器</div></div><div class="info-2"><div class="info-item-1">所有的垃圾收集器，都基于弱分代假设。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优。 有几个常用原则：  减少临时对象，尽量复用内存。 使用对象池。 主动提前释放对象。 主动 gc。 好的代码比 tuning 更重要。 选 gc 算法比 tuning 参数重要，tuning 参数是最后一步。  其他情况，可以通过 tuning garbage collector 来解决。 操作系统的影响  SWAP 可能会显著增加 GC 时间，因为被换出的堆还要被换入。  美团的实践 参考：  《从实际案例聊聊Java应用的GC优化》 《Java中9种常见的CMS GC问题分析与解决》   Minor GC Major GC Full GC  垃圾收集器分类    可以看到一个现象：在大部分时候，g1 比 CMS 快，但极端的百分位里，CMS 比 g1 快。 出处见这里。 常用工具 命令行终端   标准终端类：jps、jinfo、jstat、jstack、jmap 功能整合类：jcm...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">抛出问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">异常的机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.</span> <span class="toc-text">一个实验</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">4.</span> <span class="toc-text">结论</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2017 - 2025 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>