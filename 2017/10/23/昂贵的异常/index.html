<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>昂贵的异常 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing e">
<meta property="og:type" content="article">
<meta property="og:title" content="昂贵的异常">
<meta property="og:url" content="https://magicliang.github.io/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing e">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-167.jpg">
<meta property="article:published_time" content="2017-10-23T11:29:39.000Z">
<meta property="article:modified_time" content="2026-02-07T06:48:57.917Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="异常处理">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-167.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "昂贵的异常",
  "url": "https://magicliang.github.io/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/",
  "image": "https://magicliang.github.io/img/wall-paper-167.jpg",
  "datePublished": "2017-10-23T11:29:39.000Z",
  "dateModified": "2026-02-07T06:48:57.917Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '昂贵的异常',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
</head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-167.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">昂贵的异常</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">昂贵的异常</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2017-10-23T11:29:39.000Z" title="Created 2017-10-23 19:29:39">2017-10-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-07T06:48:57.917Z" title="Updated 2026-02-07 14:48:57">2026-02-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">5.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>17mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="抛出问题">抛出问题</h2>
<p>Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 <code>return</code>、<code>break</code> 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。</p>
<blockquote>
<p>Throwing exception is expensive.</p>
</blockquote>
<p>这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E7%8C%B4%E5%AD%90%E5%AE%9A%E5%BE%8B/6268365">猴子定律</a>，人们知道不能这么做，却不明白为什么不能这么做。</p>
<p>此前读了一位同事写的好文<a target="_blank" rel="noopener" href="http://www.javaworld.com/article/2076868/learn-java/how-the-java-virtual-machine-handles-exceptions.html">《Java虚拟机是如何处理异常的》</a>，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！在开启 JIT 的情况下，throw 也不会增加多少系统开销。&quot;实际上这篇文章也做了一些对比，在不同的场景下，try-catch 会不会让系统变慢。</p>
<p>文中还提到一个有趣的实验：</p>
<hr>
<p>代码 A</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">// throw exception;</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>代码 B</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++) &#123;<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>实验结果是：</p>
<table>
<thead>
<tr>
<th style="text-align:center">异常抛出</th>
<th style="text-align:center">关闭JIT</th>
<th style="text-align:center">开启JIT(默认开启)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">无异常抛出</td>
<td style="text-align:center">两者耗时几乎相同</td>
<td style="text-align:center">两者耗时几乎相同</td>
</tr>
<tr>
<td style="text-align:center">A每次都抛异常</td>
<td style="text-align:center">A耗时约是B的30倍</td>
<td style="text-align:center">两者耗时几乎相同</td>
</tr>
</tbody>
</table>
<hr>
<p>  这几乎推翻了既有的刻板印象，从此抛出异常不再是一个需要考虑性能的设计决定了。在仔细研究了这个问题以后，却有了一个不同的结论：try-catch 语句在 JIT 的帮助下，也许可以达到和正常 <code>return</code> 一样的性能，然而 <code>throw</code> 却会产生远比文中描述的更严重的性能影响，因为 <code>throw</code> 不是孤立的语句，它必须伴随着异常对象的创建，而异常对象的创建的昂贵代价，是不可能被 JIT 优化掉的。也就是说，<a target="_blank" rel="noopener" href="http://www.javaworld.com/article/2076868/learn-java/how-the-java-virtual-machine-handles-exceptions.html">《Java虚拟机是如何处理异常的》</a>中结论的前半部分是正确的，后半部分是不准确的。</p>
<h2 id="异常的机制">异常的机制</h2>
<p>JVM 的异常处理机制，大致可以分为三个部分 ：</p>
<ol>
<li>new Exception</li>
<li>throw Exception</li>
<li>catch and deal with Exception</li>
</ol>
<p>通过<a target="_blank" rel="noopener" href="http://www.javaworld.com/article/2076868/learn-java/how-the-java-virtual-machine-handles-exceptions.html">《Java虚拟机是如何处理异常的》</a>已经可以明确理解，JVM 对于 try-throw-catch 的程序控制流处理，与普通的 <code>return</code> 如出一辙，都是基于程序计数器的改变，直接使得控制流发生跳转，并无特别之处。而 catch 异常如果为空（即生吞异常），则开销上看起来和平凡 <code>return</code> 一样。然而，<code>new Exception</code> 实际上是一个非常昂贵的操作。因为异常对象在生成的时候，其父类构造函数 <code>Throwable</code> 中的一部分会调用 <code>fillInStackTrace()</code> 操作。这个 <code>fillInStackTrace()</code> 函数，会试图把当前抛出异常的栈帧全都囊括在内，在实际的运行之中，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/299068/how-slow-are-java-exceptions">有可能导致复杂的 CPU 寄存器读写操作</a>。这种读写操作的复杂度与是否使用 JIT 无关，也就不可能被 JIT 所优化，是一种很昂贵的固定成本。</p>
<h3 id="fillinstacktrace-到底做了什么"><code>fillInStackTrace()</code> 到底做了什么</h3>
<p>要理解异常为什么昂贵，必须深入 <code>fillInStackTrace()</code> 的实现细节。这个方法是一个 <code>native</code> 方法，它的底层实现（在 HotSpot JVM 中）大致执行以下操作：</p>
<ol>
<li>
<p><strong>栈帧遍历（Stack Walking）</strong>：从当前栈帧开始，沿着调用链逐帧向上遍历。对于每一帧，需要读取帧指针（frame pointer）或通过栈展开表（unwind table）来定位上一帧。在没有帧指针的优化代码中（JIT 编译后的代码通常会省略帧指针以节省寄存器），这个过程需要查阅 JIT 编译器生成的元数据来确定每一帧的大小和布局。</p>
</li>
<li>
<p><strong>方法元数据解析</strong>：对于每一帧，需要将程序计数器（PC）映射回对应的 Java 方法名、类名和行号。这需要查阅方法的调试信息表（LineNumberTable）和常量池。对于 JIT 编译后的代码，还需要通过 PC 映射表（PcDesc）将本地代码地址映射回字节码偏移量。</p>
</li>
<li>
<p><strong>内存分配</strong>：遍历完成后，需要分配一个 <code>StackTraceElement[]</code> 数组来存储所有栈帧信息。每个 <code>StackTraceElement</code> 对象包含类名、方法名、文件名和行号四个字符串字段，这意味着还需要分配大量的 <code>String</code> 对象。</p>
</li>
</ol>
<p>在一个典型的 Spring Boot 应用中，一次 HTTP 请求的调用栈深度可能达到 50-100 层（Servlet 容器 + Spring MVC + AOP 代理 + 业务代码 + 数据库驱动），这意味着一次 <code>fillInStackTrace()</code> 需要遍历并记录 50-100 个栈帧的完整信息。</p>
<h3 id="writablestacktrace：跳过栈帧收集"><code>writableStackTrace</code>：跳过栈帧收集</h3>
<p>值得一提的是，Java 7 开始 <code>Throwable</code> 的构造器提供了 <code>writableStackTrace</code> 参数（<code>protected Throwable(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace)</code>），将其设为 <code>false</code> 可以跳过 <code>fillInStackTrace()</code> 的调用，从而大幅降低异常创建的开销。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LightweightException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">LightweightException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// writableStackTrace = false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种轻量级异常的创建开销与普通对象创建几乎相同，但代价是丢失了栈帧信息——在日志中你只能看到异常消息，无法看到异常是从哪里抛出的。这在某些场景下是可以接受的，比如用异常来表示业务校验失败（“用户名已存在”），此时栈帧信息对排查问题没有帮助。</p>
<h3 id="jvm-的隐式优化：fast-throw">JVM 的隐式优化：Fast Throw</h3>
<p>HotSpot JVM 还有一个鲜为人知的优化：当同一个位置反复抛出同一类型的异常时（如 <code>NullPointerException</code>），JVM 会在 C2 编译器中启用 <strong>Fast Throw</strong> 优化——直接抛出一个预先创建好的、不包含栈帧信息的异常单例。这个优化可以通过 <code>-XX:-OmitStackTraceInFastThrow</code> 来关闭。</p>
<p>这个优化在生产环境中是一把双刃剑：它确实提升了性能，但当你在日志中看到一个没有栈帧的 <code>NullPointerException</code> 时，排查问题会变得极其困难。这也是为什么很多运维团队会建议在生产环境中关闭这个优化。</p>
<p><a target="_blank" rel="noopener" href="http://www.javaworld.com/article/2076868/learn-java/how-the-java-virtual-machine-handles-exceptions.html">《Java虚拟机是如何处理异常的》</a>中提到的实验并不代表 Java 在真实生产环境中的工作状况，因为现实中几乎没有栈深只为 1 的方法调用，一个框架或者容器，本身就会带来几十层的调用栈深度。</p>
<h2 id="一个实验">一个实验</h2>
<p>StackOverflow 上已经有很多人做了相关的实验，以下代码用于印证上述结论：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Param(&#123; &quot;1&quot;, &quot;100&quot;, &quot;200&quot;, &quot;1000&quot;, &quot;2000&quot;&#125;)</span><br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> recursiveDepth;<br><br> <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">returnMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> recursiveDepth)</span> &#123;<br>     <span class="hljs-keyword">if</span> ( recursiveDepth &gt; <span class="hljs-number">0</span> ) &#123;<br>         <span class="hljs-keyword">return</span> returnMethod(recursiveDepth - <span class="hljs-number">1</span>);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>     &#125;<br> &#125;<br><br><br> <span class="hljs-keyword">private</span> Object <span class="hljs-title function_">throwMethod</span><span class="hljs-params">(<span class="hljs-type">int</span> recursiveDepth)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>     <span class="hljs-keyword">if</span> ( recursiveDepth &gt; <span class="hljs-number">0</span> ) &#123;<br>         <span class="hljs-keyword">return</span> throwMethod(recursiveDepth - <span class="hljs-number">1</span>);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>     &#125;<br> &#125;<br><br> <span class="hljs-comment">// 一定要是公开方法</span><br> <span class="hljs-meta">@Benchmark</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">benchMarkReturn</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-comment">// 一定要明确使用返回结果，不然 JIT会优化掉很多东西。</span><br>     System.out.println(returnMethod((recursiveDepth)));<br> &#125;<br><br> <span class="hljs-meta">@Benchmark</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">benchMarkThrow</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">try</span> &#123;<br>         throwMethod((recursiveDepth));<br>     &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>         <span class="hljs-comment">// 一定要明确使用返回结果，不然 JIT会优化掉很多东西。</span><br>         System.out.println(e);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>这是一个基于 JMH 的测试方案，先预热一万轮，再跑一万轮 benchmark 方法，使 JIT 完全发挥作用。实验环境是 CentOS 7，使用 Java 8 的 JVM，<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/performance-enhancements-7.html">默认打开了分层编译</a>。栈深度分别为 1、100、200、1000、2000。</p>
<p>实验结果如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">测试方法</th>
<th style="text-align:center">栈深度</th>
<th style="text-align:center">操作平均耗时（微秒）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">benchMarkReturn</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0.002</td>
</tr>
<tr>
<td style="text-align:center">benchMarkThrow</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1.462</td>
</tr>
<tr>
<td style="text-align:center">benchMarkReturn</td>
<td style="text-align:center">100</td>
<td style="text-align:center">0.178</td>
</tr>
<tr>
<td style="text-align:center">benchMarkThrow</td>
<td style="text-align:center">100</td>
<td style="text-align:center">15.200</td>
</tr>
<tr>
<td style="text-align:center">benchMarkReturn</td>
<td style="text-align:center">200</td>
<td style="text-align:center">0.369</td>
</tr>
<tr>
<td style="text-align:center">benchMarkThrow</td>
<td style="text-align:center">200</td>
<td style="text-align:center">28.595</td>
</tr>
<tr>
<td style="text-align:center">benchMarkReturn</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">1.864</td>
</tr>
<tr>
<td style="text-align:center">benchMarkThrow</td>
<td style="text-align:center">1000</td>
<td style="text-align:center">152.968</td>
</tr>
<tr>
<td style="text-align:center">benchMarkReturn</td>
<td style="text-align:center">2000</td>
<td style="text-align:center">7.563</td>
</tr>
<tr>
<td style="text-align:center">benchMarkThrow</td>
<td style="text-align:center">2000</td>
<td style="text-align:center">238.049</td>
</tr>
</tbody>
</table>
<p>我们可以清晰地看到：</p>
<ol>
<li>
<p>在相同的栈深度下，抛出异常的耗时是返回普通对象的 30 倍到 700 倍。</p>
</li>
<li>
<p>在本实验中，可能因为存在边际效应，栈深为 1 的时候反而是性能差距最大的。</p>
</li>
</ol>
<p>这也基本符合在网上看到的其他人的测试的结论（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/299068/how-slow-are-java-exceptions">例子1</a>，<a target="_blank" rel="noopener" href="https://plumbr.eu/blog/java/throwing-exceptions-slow-and-ugly">例子2</a>）。</p>
<p>如果再试图在 catch 块里调用 <code>printStackTrace()</code>，性能差距只会更大。</p>
<h3 id="数据背后的规律">数据背后的规律</h3>
<p>从实验数据中可以提炼出一个重要的规律：<strong>异常的开销与调用栈深度近似线性相关</strong>。这完全符合 <code>fillInStackTrace()</code> 的实现逻辑——它需要逐帧遍历调用栈，栈越深，遍历的帧越多，开销越大。</p>
<p>具体来看：</p>
<ul>
<li>栈深从 1 到 100，throw 耗时从 1.462μs 增长到 15.200μs，约 10 倍增长对应 100 倍栈深增长</li>
<li>栈深从 100 到 1000，throw 耗时从 15.200μs 增长到 152.968μs，几乎完美的 10 倍线性关系</li>
</ul>
<p>而 return 的耗时增长则平缓得多（0.002μs → 1.864μs），这部分增长主要来自递归调用本身的栈帧分配和回收开销，与异常机制无关。</p>
<p>这个线性关系给出了一个实用的估算公式：<strong>在典型的 Java 应用中，每增加一层调用栈深度，异常创建大约增加 0.15μs 的开销</strong>。对于一个栈深 50 层的 Spring Boot 应用，一次异常创建大约需要 7-8μs。如果每秒处理 10000 个请求，且每个请求都抛出一个异常，那么仅异常创建就会消耗约 70-80ms 的 CPU 时间——这在高并发场景下是不可忽视的。</p>
<h2 id="生产环境中的异常优化实践">生产环境中的异常优化实践</h2>
<p>理解了异常昂贵的根源之后，可以总结出几种在生产环境中优化异常性能的实践模式：</p>
<h3 id="模式一：用返回值代替异常">模式一：用返回值代替异常</h3>
<p>对于可预见的业务错误（如参数校验失败、资源不存在），使用返回值而非异常来传递错误信息。这是 Go 语言的核心设计哲学，在 Java 中可以通过 <code>Optional</code>、<code>Either</code> 模式或自定义 <code>Result</code> 类型来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 反模式：用异常传递业务错误</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUser</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userDao.findById(userId);<br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserNotFoundException</span>(<span class="hljs-string">&quot;User not found: &quot;</span> + userId);<br>    &#125;<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br><br><span class="hljs-comment">// 推荐：用 Optional 表达&quot;可能不存在&quot;的语义</span><br><span class="hljs-keyword">public</span> Optional&lt;User&gt; <span class="hljs-title function_">findUser</span><span class="hljs-params">(<span class="hljs-type">long</span> userId)</span> &#123;<br>    <span class="hljs-keyword">return</span> Optional.ofNullable(userDao.findById(userId));<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="模式二：轻量级异常">模式二：轻量级异常</h3>
<p>对于确实需要使用异常机制但不需要栈帧信息的场景（如业务校验），使用 <code>writableStackTrace = false</code> 的轻量级异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BusinessException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String errorCode;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BusinessException</span><span class="hljs-params">(String errorCode, String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>); <span class="hljs-comment">// 跳过 fillInStackTrace()</span><br>        <span class="hljs-built_in">this</span>.errorCode = errorCode;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getErrorCode</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> errorCode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="模式三：异常缓存与复用">模式三：异常缓存与复用</h3>
<p>对于某些固定的异常（如流控异常、熔断异常），可以预先创建异常实例并复用，避免反复调用 <code>fillInStackTrace()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FlowControlException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RuntimeException</span> &#123;<br>    <span class="hljs-comment">// 预先创建的单例，栈帧信息固定为类加载时的位置</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">FlowControlException</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FlowControlException</span>(<span class="hljs-string">&quot;Flow control triggered&quot;</span>);<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">FlowControlException</span><span class="hljs-params">(String message)</span> &#123;<br>        <span class="hljs-built_in">super</span>(message, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种模式在 Netty、Sentinel 等高性能框架中被广泛使用。例如 Netty 的 <code>StacklessClosedChannelException</code> 就是一个典型的轻量级异常。</p>
<h3 id="模式四：避免异常驱动的控制流">模式四：避免异常驱动的控制流</h3>
<p>某些 API 设计迫使开发者用异常来处理正常的控制流，这是应该避免的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 反模式：用异常来检测迭代结束（早期 Java 集合的做法）</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> iterator.next();<br>        process(item);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchElementException e) &#123;<br>    <span class="hljs-comment">// 迭代结束</span><br>&#125;<br><br><span class="hljs-comment">// 推荐：用 hasNext() 检查</span><br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    process(iterator.next());<br>&#125;<br></code></pre></td></tr></table></figure>
<p>类似地，<code>Integer.parseInt()</code> 在解析失败时抛出 <code>NumberFormatException</code>，如果你需要频繁地尝试解析可能不是数字的字符串，应该先用正则或其他方式预检查，而不是依赖异常来判断。</p>
<h2 id="结论">结论</h2>
<blockquote>
<p>在开启JIT的情况下，throw也不会增加多少系统开销。</p>
</blockquote>
<p>固然是实话。</p>
<p>然而现实之中，throw 却不能离开任何 Throwable 的子类，我们在使用异常机制的时候，必须背负上生成栈帧这样一个沉重的负担，空谈 throw 的性能优化是无意义的。所以</p>
<blockquote>
<p>所以当你遇到有人说try-catch一定要少用会影响性能时，或许你就不会再去盲从这种&quot;建议&quot;了。</p>
</blockquote>
<p>却是一种过于乐观的结论。我们当然不能无节制地使用 try-catch，因它不仅使程序变得支离破碎，而且除非不会发生异常抛出，否则 JVM 对它进行的优化，只是杯水车薪。</p>
<p>应当永远记住，抛出异常是昂贵的，不是因为 try-catch 是昂贵的，而是因为无论怎么使用异常，异常对象的创建（<code>fillInStackTrace()</code>）都是昂贵的。</p>
<p>更精确地说，异常的代价可以分解为三个层次：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>相对开销</th>
<th>能否被 JIT 优化</th>
</tr>
</thead>
<tbody>
<tr>
<td>try-catch 语句块（无异常抛出）</td>
<td>几乎为零</td>
<td>是</td>
</tr>
<tr>
<td>throw + catch（控制流跳转）</td>
<td>很小</td>
<td>是</td>
</tr>
<tr>
<td>new Exception（<code>fillInStackTrace()</code>）</td>
<td><strong>极大</strong>，与栈深线性相关</td>
<td><strong>否</strong></td>
</tr>
<tr>
<td><code>printStackTrace()</code></td>
<td>极大，涉及 IO</td>
<td>否</td>
</tr>
</tbody>
</table>
<p>理解这张表，就理解了异常性能问题的全部。优化的方向永远是：<strong>减少 <code>fillInStackTrace()</code> 的调用次数和每次调用时的栈深度</strong>。</p>
<p>附原文：</p>
<blockquote></blockquote>
<pre><code>编码时我们常常被要求尽量减少try-catch语句块，理由就是就算不抛异常它们也会影响性能。然而影响究竟有多大呢？语句块应该放在循环体内部还是外部呢？下面译文将详细阐释Java虚拟机处理异常的机制。
虽然文中没有进行性能分析，但文末提供了一些基准测试的文章，先把结论写在前头：try-catch语句块几乎不会影响程序运行性能！在开启JIT的情况下，throw也不会增加多少系统开销。
</code></pre>
<p>异常机制</p>
<p>异常机制可以让你顺利的处理程序运行过程中所遇到的许多意想不到的情况。为了说明Java虚拟机处理异常的方式，我们来看一个名为NitPickyMath的类，它提供了针对整型的求模运算。和直接进行运算操作不同的是，该方法除零情况下将抛出受检查的异常（checked exceptions）。在Java虚拟机中除零时同样也会抛出ArithmeticException异常。NitPickyMath类抛出的异常定义如下：</p>
<p>class DivideByZeroException extends Exception {<br>
}</p>
<p>NitPickyMath类的remainder方法简单地捕获并抛出了异常：</p>
<p>static int remainder(int dividend, int divisor)<br>
throws DivideByZeroException {<br>
try {<br>
return dividend % divisor;<br>
}<br>
catch (ArithmeticException e) {<br>
throw new DivideByZeroException();<br>
}<br>
}</p>
<p>remainder方法仅仅只是将两个int入参进行了求模运算（也使用了除法）。当除数为0时，求模运算将抛出ArithmeticException异常，该方法将捕获这个异常并抛出一个自定义DivideByZeroException异常。</p>
<p>DivideByZeroException 和ArithmeticException 的不同之处在于前者是受检查异常，而后者是非受检查异常。因此后者抛出时不需要在方法头添加throws语句。Error或RuntimeException类的所有子类都是非受检查异常（例如ArithmeticException就是RuntimeException的子类）。</p>
<p>使用javac对remainder方法进行编译，将得到如下字节码：</p>
<p>remainder方法主体的字节码序列:<br>
0 iload_0   // 压入局部变量0 (传入的除数)<br>
1 iload_1   // 压入局部变量0 (传入的被除数)<br>
2 irem      // 弹出除数, 弹出被除数, 压入余数<br>
3 ireturn   // 返回栈顶的int值 (余数)</p>
<p>catch语句的的字节码序列 (ArithmeticException):<br>
4 pop       // 弹出ArithmeticException引用（因为没被用到）<br>
5 new #5 <Class DivideByZeroException><br>
// 创建并压入新对象DivideByZeroException的引用</p>
<p>DivideByZeroException<br>
8 dup       // 复制栈顶的DivideByZeroException引用，因为它既要被初始化又要被抛出，初始化将消耗掉栈顶的一个引用<br>
9 invokenonvirtual #9 &lt;Method DivideByZeroException.<init>()V&gt;<br>
// 调用DivideByZeroException的构造器来初始化，栈顶引用出栈<br>
12 athrow    // 弹出Throwable对象的引用并抛出异常</p>
<p>可以看到remainder的字节码序列主要分成了两部分，第一部分是方法正常执行的路径，这部分对应的pc程序计数器偏移为0到3。第二部分是catch语句，pc偏移为4到12。</p>
<p>运行时，字节码序列中的irem指令将抛出ArithmeticException异常，虚拟机将会根据异常查表来找到可以跳转到的catch语句位置。每个含有catch语句的方法的字节码中都附带了一个异常表，它包含每个异常try语句块的条目（entry）。每个条目都有四项信息：起点、终点、跳转的pc偏移位置以及该异常类所在常量池中的索引。remainder方法的异常表如下所示：</p>
<p>Exception table：<br>
from  to  target  type<br>
0   4   4   <Class java.lang.ArithmeticException></p>
<p>上面的异常表显示了try语句块的起始位置为0，结束位置为4（不包含4），如果ArithmeticException异常在0-3的语句块中抛出，那么pc计数器将直接跳转到偏移为4的位置。</p>
<p>如果在运行时抛出了一个异常，那么java虚拟机会按顺序搜索整个异常表找到匹配的条目，并且仅会匹配到在其指定范围内的异常。当找到第一个匹配的条目后，虚拟机便将程序计数器设置为新的偏移位置，然后继续执行指令。如果没有条目被匹配到，java虚拟机会弹出当前的栈帧（停止执行当前方法），并继续向上（调用remainder方法的方法）抛出同样的异常。当然上级方法也不会继续正常执行的，它同样需要查表来处理该异常，如此反复。</p>
<p>开发者可以使用throw申明来抛出一个异常，就像remainder方法的catch块中那样。相应的字节码描述如下：<br>
操作码   操作数   描述<br>
athrow  无   弹出Throwable对象引用，并抛出该异常</p>
<p>athrow指令弹出操作数栈栈顶的引用，该引用应当为Throwable的子类 (或者就是 Throwable自身)。<br>
思考</p>
<p>回到开头讨论的话题，你觉得下面两段代码性能差异有多大<br>
A：</p>
<p>for (int i = 0; i &lt; 1000000; i++) {<br>
try {<br>
// throw exception;<br>
} catch (Exception e) {<br>
}<br>
}</p>
<p>B：</p>
<p>try {<br>
for (int i = 0; i &lt; 1000000; i++) {<br>
}<br>
} catch (Exception e) {<br>
}</p>
<p>这篇博客给出了结果以及基准测试方法：try catch 对性能影响 。</p>
<p>我也使用JMH进行了测试，环境和细节就不列出了。其中使用了-Xint参数控制JIT热点编译，结果如下：<br>
异常抛出  关闭JIT   开启JIT(默认开启)<br>
A无异常抛出  两者耗时几乎相同  两者耗时几乎相同<br>
A每次都抛异常   A耗时约是B的30倍  两者耗时几乎相同</p>
<p>了解了译文中的异常的机制后，我们知道try-catch其实不过是在class文件中加了一个异常表用于异常查表，如果没有异常抛出，程序的执行方式和不包含try-catch块完全相同。如果有异常抛出，那么性能的确会下降，而这是有throw导致的，与try-catch无关。此时需要根据实际的业务来预估该方法抛出异常的频率有多高，就算你不去管，当方法被执行次数过多时，java虚拟机也会通过JIT来编译这段方法，编译过后两者的执行效率也是几乎相同的。注意，关闭JIT后循环方法整体性能下降了几十倍。</p>
<p>所以当你遇到有人说try-catch一定要少用会影响性能时，或许你就不会再去盲从这种“建议”了。当然在知晓这个信息的同时，我们反倒更应该去思考如何从业务和代码逻辑的角度来适当地使用try-catch写出更漂亮的代码。</p>
<p>本文参考：<br>
<a target="_blank" rel="noopener" href="http://www.javaworld.com/article/2076868/learn-java/how-the-java-virtual-machine-handles-exceptions.html">http://www.javaworld.com/article/2076868/learn-java/how-the-java-virtual-machine-handles-exceptions.html</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/">https://magicliang.github.io/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/">异常处理</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-167.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-63.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">卡表和 RSet 问题定义：为什么需要跨区域引用记录 JVM 垃圾收集器的核心工作之一是确定 live set——哪些对象仍然存活、不可回收。确定 live set 的标准做法是从 GC Roots（栈帧中的局部变量、静态字段等）出发，沿引用链遍历所有可达对象。 问题在于：当堆被划分为多个区域（代、Region）并且只回收其中一部分时，如何高效地找到从&quot;不回收区域&quot;指向&quot;回收区域&quot;的引用？ 以 Young GC 为例：只回收新生代，但老年代中可能持有指向新生代对象的引用。如果不处理这些跨代引用，就会错误地回收仍被老年代引用的新生代对象。最朴素的做法是扫描整个老年代来找出这些引用——但老年代通常远大于新生代，这样做的代价过高，违背了分代收集&quot;只回收一部分堆&quot;的初衷。 卡表（Card Table）和 RSet（Remembered Set）正是为解决这个问题而设计的辅助数据结构。二者的关系并非互相替代，而是层次不同、协作互补：卡表是底层的脏标记机制，RSet 是建立在卡表之上的更高层索引结构。 核心概念速览 在深入细节之前，...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-164.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a><a class="pagination-related" href="/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" title="重述双亲委派模型"><img class="cover" src="/img/wall-paper-140.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-05</div><div class="info-item-2">重述双亲委派模型</div></div><div class="info-2"><div class="info-item-1">何时加载类 根据 Java 语言规范（JLS §12.4），类或接口在首次主动使用时才会被初始化。主动使用包括以下情况：  遇到 new、getstatic、putstatic、invokestatic 等字节码指令时。这些指令分别对应创建对象实例、读取或设置静态字段、调用静态方法。 对类进行反射调用时，如 Class.forName() 或 Method.invoke()。 初始化某个类的子类时，父类会先被初始化（但父类接口不会）。 虚拟机启动时会先加载设置的主类，即包含 main() 方法的类。 使用 java.lang.invoke 包的动态语言支持特性时，如 MethodHandle 调用。  需要注意的是，被动引用（如通过数组引用、常量引用、访问子类的静态字段等）不会触发类初始化。 从 Java 到 cpp 源码分析 双亲委派模型的工作流程 双亲委派模型的核心逻辑在 java.lang.ClassLoader.loadClass(String name, boolean resolve) 方法中： 123456789101112131415161718192021222...</div></div></div></a><a class="pagination-related" href="/2020/03/08/JMX-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9/" title="JMX 深度历险"><img class="cover" src="/img/wall-paper-69.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-08</div><div class="info-item-2">JMX 深度历险</div></div><div class="info-2"><div class="info-item-1">JMX 常见指标 JVM 指标 系统指标    System 相关指标 描述     system.load.average 系统load，如果是docker，此指标收集的物理机的load   cpu.system.load.percent 系统所有进程占用cpu的百分比   cpu.jvm.load.percent jvm占用cpu的百分比   system.process.used.phyical.memory 系统使用的物理内存   system.process.used.swap.size 系统使用的swap内存    JVM 内存指标    JVM相关指标 描述     jvm.gc.count GC的次数   jvm.gc.time GC的时间，单位毫秒   jvm.younggc.count 年轻代GC的次数 ，包括的GC算法（Copy，ParNew，PS Scavenge，G1 Young Generation）   jvm.younggc.time 年轻代GC的时间，单位毫秒   jvm.fullgc.count 年老代GC的次数，包括的GC算法   jvm.f...</div></div></div></a><a class="pagination-related" href="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" title="现代垃圾收集器"><img class="cover" src="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-27</div><div class="info-item-2">现代垃圾收集器</div></div><div class="info-2"><div class="info-item-1">所有的垃圾收集器，都基于弱分代假设。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优。 有几个常用原则：  减少临时对象，尽量复用内存。 使用对象池。 主动提前释放对象。 主动 gc。 好的代码比 tuning 更重要。 选 gc 算法比 tuning 参数重要，tuning 参数是最后一步。  其他情况，可以通过 tuning garbage collector 来解决。 操作系统的影响  SWAP 可能会显著增加 GC 时间，因为被换出的堆还要被换入。  美团的实践 参考：  《从实际案例聊聊Java应用的GC优化》 《Java中9种常见的CMS GC问题分析与解决》   Minor GC Major GC Full GC  垃圾收集器分类    可以看到一个现象：在大部分时候，g1 比 CMS 快，但极端的百分位里，CMS 比 g1 快。 出处见这里。 常用工具 命令行终端   标准终端类：jps、jinfo、jstat、jstack、jmap 功能整合类：jcm...</div></div></div></a><a class="pagination-related" href="/2021/07/19/%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%BE%AE%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/" title="如何实现正确的微基准测试"><img class="cover" src="/img/wall-paper-104.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-19</div><div class="info-item-2">如何实现正确的微基准测试</div></div><div class="info-2"><div class="info-item-1">原问题 FROM：《How do I write a correct micro-benchmark in Java?》 Tips about writing micro benchmarks from the creators of Java HotSpot: Rule 0: Read a reputable paper on JVMs and micro-benchmarking. A good one is Brian Goetz, 2005. Do not expect too much from micro-benchmarks; they measure only a limited range of JVM performance characteristics. Rule 1: Always include a warmup phase which runs your test kernel all the way through, enough to trigger all initializations and compilations before timi...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%9B%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">抛出问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E7%9A%84%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">异常的机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fillinstacktrace-%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-number">2.1.</span> <span class="toc-text">fillInStackTrace() 到底做了什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#writablestacktrace%EF%BC%9A%E8%B7%B3%E8%BF%87%E6%A0%88%E5%B8%A7%E6%94%B6%E9%9B%86"><span class="toc-number">2.2.</span> <span class="toc-text">writableStackTrace：跳过栈帧收集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm-%E7%9A%84%E9%9A%90%E5%BC%8F%E4%BC%98%E5%8C%96%EF%BC%9Afast-throw"><span class="toc-number">2.3.</span> <span class="toc-text">JVM 的隐式优化：Fast Throw</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%AE%9E%E9%AA%8C"><span class="toc-number">3.</span> <span class="toc-text">一个实验</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%83%8C%E5%90%8E%E7%9A%84%E8%A7%84%E5%BE%8B"><span class="toc-number">3.1.</span> <span class="toc-text">数据背后的规律</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.</span> <span class="toc-text">生产环境中的异常优化实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%80%EF%BC%9A%E7%94%A8%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BB%A3%E6%9B%BF%E5%BC%82%E5%B8%B8"><span class="toc-number">4.1.</span> <span class="toc-text">模式一：用返回值代替异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%BA%8C%EF%BC%9A%E8%BD%BB%E9%87%8F%E7%BA%A7%E5%BC%82%E5%B8%B8"><span class="toc-number">4.2.</span> <span class="toc-text">模式二：轻量级异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E4%B8%89%EF%BC%9A%E5%BC%82%E5%B8%B8%E7%BC%93%E5%AD%98%E4%B8%8E%E5%A4%8D%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">模式三：异常缓存与复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E5%9B%9B%EF%BC%9A%E9%81%BF%E5%85%8D%E5%BC%82%E5%B8%B8%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81"><span class="toc-number">4.4.</span> <span class="toc-text">模式四：避免异常驱动的控制流</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">5.</span> <span class="toc-text">结论</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>