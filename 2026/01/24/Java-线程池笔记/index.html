<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 线程池笔记 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从执行器到线程池  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finan">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 线程池笔记">
<meta property="og:url" content="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="从执行器到线程池  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finan">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png">
<meta property="article:published_time" content="2026-01-24T13:50:09.000Z">
<meta property="article:modified_time" content="2026-01-24T13:51:16.200Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 线程池笔记",
  "url": "https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png",
  "datePublished": "2026-01-24T13:50:09.000Z",
  "dateModified": "2026-01-24T13:51:16.200Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 线程池笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 线程池笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java 线程池笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-24T13:50:09.000Z" title="Created 2026-01-24 21:50:09">2026-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T13:51:16.200Z" title="Updated 2026-01-24 21:51:16">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">20.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>86mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="从执行器到线程池">从执行器到线程池</h2>
<blockquote>
<p>Pooling is the grouping together of resources (assets, equipment,<br>
personnel, effort, etc.) for the purposes of maximizing advantage or<br>
minimizing risk to the users. The term is used in finance, computing<br>
and equipment management.——wikipedia</p>
<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p>
<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p>
<p>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection<br>
Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池(Object<br>
Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</p>
</blockquote>
<p>Doug Lea 对线程池的期待有：</p>
<ol>
<li>改善性能。</li>
<li>有界地利用资源（多次强调 bounds）。</li>
<li>提供统计。</li>
</ol>
<h3 id="执行器继承体系">执行器继承体系</h3>
<p>“设计良好的API应该简单、一致、可扩展。”</p>
<p><img src="ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="ThreadPoolExecutorUML类图.png"></p>
<p>我们将任务交给执行器，于是有了执行器；我们将执行器内部用 FutureTask 包装任务，于是有了同步转异步，异步转同步的设计，和多种 API；我们将执行器用线程池来实现，于是我们得到了 ThreadPoolExecutor。</p>
<ul>
<li>Executor：只定义&quot;执行&quot;契约</li>
<li>ExecutorService：定义生命周期、 多种任务类型（Runnable/Callable）、批量任务契约</li>
</ul>
<p><strong>这两层都是契约层，方法之间没有明确关联</strong>。</p>
<ul>
<li>AbstractExecutorService：只提供算法模板-这一层提供了方法在 execute 之上的实现，把 api 关联起来。但是唯独 execute 的实现空余了。</li>
<li>ThreadPoolExecutor：只实现 execute，并且围绕它搭建了一整套线程池的参考实现：Worker+状态机+队列。</li>
<li>FutureTask：只负责任务包装。但是它的<strong>两个父接口让它成为连接了 <code>execute(Runnable)</code>和<code>Future.get()</code>两个世界的桥梁</strong>。</li>
</ul>
<pre><code class="hljs mermaid">classDiagram
    class Executor &#123;
        &lt;&lt;interface&gt;&gt;
        +execute(Runnable command) void  // 基础执行契约
    &#125;
    
    class ExecutorService &#123;
        &lt;&lt;interface&gt;&gt;
        +submit(Callable~T~ task) Future~T~  // 新增：结果获取API
        +invokeAll(Collection~Callable~T~~ tasks) List~Future~T~~  // 新增：批量处理API
        +shutdown() void  // 新增：生命周期API
        +awaitTermination(long timeout, TimeUnit unit) boolean  // 新增：等待关闭API
    &#125;
    
    class AbstractExecutorService &#123;
        &lt;&lt;abstract&gt;&gt;
        # 所有高级功能都围绕 newTaskFor（有返回值和无返回值的任务类型） + execute 构建
        #newTaskFor(Callable~T~ callable) RunnableFuture~T~  // 新增：任务包装工厂API
        #newTaskFor(Runnable runnable, T value) RunnableFuture~T~  // 新增：任务包装工厂API
        
        +submit(Callable~T~ task) Future~T~  // 实现：包装+提交算法
        +invokeAll(Collection~Callable~T~~ tasks) List~Future~T~~  // 实现：批量包装+提交算法
        +invokeAny(Collection~Callable~T~~ tasks) T  // 实现：任意完成算法
        
        // 关键：execute() 是抽象的，留给子类实现
        ~execute(Runnable command) void
    &#125;
    
    class ThreadPoolExecutor &#123;
        -corePoolSize: int
        -maximumPoolSize: int
        -workQueue: BlockingQueue~Runnable~
        -workers: HashSet~Worker~
        
        +execute(Runnable command) void
        +shutdown() void
        +beforeExecute(Thread t, Runnable r) void
        +afterExecute(Runnable r, Throwable t) void
    &#125;
    
    class ForkJoinPool &#123;
        &lt;&lt;concrete&gt;&gt;
        -parallelism: int
        -workQueues: WorkQueue[]  // 工作窃取队列数组
        -commonPool: ForkJoinPool  // 静态共享池
        
        +execute(ForkJoinTask~?~ task) void  // 重载 execute，专用于 ForkJoinTask
        +submit(ForkJoinTask~T~ task) ForkJoinTask~T~  // 支持 ForkJoinTask 的 submit
        +invoke(ForkJoinTask~T~ task) T  // 同步调用并返回结果（核心方法）
        +shutdown() void
        +awaitTermination(...) boolean
        
        // 内部线程继承 ForkJoinWorkerThread
    &#125;
    
    class ForkJoinTask &#123;
        &lt;&lt;abstract&gt;&gt;
        -status: int
        +fork() ForkJoinTask~T~  // 异步执行（入队到当前线程的队列）
        +join() T  // 阻塞等待结果
        +invoke() T  // fork + join 的快捷方式
        +tryUnfork() boolean
        +quietlyComplete()
    &#125;
    
    class RecursiveTask &#123;
        &lt;&lt;abstract&gt;&gt;
        +compute() V  // 用户实现逻辑，返回结果
    &#125;
    
    class RecursiveAction &#123;
        &lt;&lt;abstract&gt;&gt;
        +compute() void  // 用户实现逻辑，无返回值
    &#125;
    
    class FutureTask &#123;
        -callable: Callable~V~
        -outcome: Object
        -state: int
        -runner: Thread
        +run() void
        +get() V
        +cancel(boolean mayInterruptIfRunning) boolean
    &#125;
    
    class Worker &#123;
        -thread: Thread
        -firstTask: Runnable
        +run() void
    &#125;
    
    class ForkJoinWorkerThread &#123;
        &lt;&lt;concrete&gt;&gt;
        -pool: ForkJoinPool
        -workQueue: WorkQueue
        +run() void  // 执行工作窃取循环
    &#125;
    
    %% 关系
    Executor &lt;|-- ExecutorService : &quot;adds lifecycle+results API&quot;
    ExecutorService &lt;|-- AbstractExecutorService : &quot;adds algorithm implementation&quot;
    AbstractExecutorService &lt;|-- ThreadPoolExecutor : &quot;adds thread pool strategy&quot;
    AbstractExecutorService &lt;|-- ForkJoinPool : &quot;adds work-stealing strategy&quot;
    
    AbstractExecutorService ..&gt; FutureTask : &quot;creates via newTaskFor()&quot;
    
    ThreadPoolExecutor o-- Worker : &quot;manages pool of&quot;
    Worker ..&gt; Runnable : &quot;executes tasks&quot;
    ThreadPoolExecutor ..&gt; FutureTask : &quot;executes via workers&quot;
    
    ForkJoinPool o-- ForkJoinWorkerThread : &quot;manages pool of&quot;
    ForkJoinWorkerThread ..&gt; WorkQueue : &quot;owns&quot;
    WorkQueue ..&gt; ForkJoinTask : &quot;holds tasks&quot;
    ForkJoinPool ..&gt; ForkJoinTask : &quot;executes via work-stealing&quot;
    
    ForkJoinTask &lt;|-- RecursiveTask : &quot;returns result&quot;
    ForkJoinTask &lt;|-- RecursiveAction : &quot;no result&quot;
    
    FutureTask ..|&gt; RunnableFuture : &quot;implements&quot;
    RunnableFuture --|&gt; Runnable : &quot;extends&quot;
    RunnableFuture --|&gt; Future : &quot;extends&quot;
    
    ForkJoinTask ..|&gt; Future : &quot;implements (indirectly via ForkJoinTask&lt;V&gt; extends Future&lt;V&gt;)&quot;
    ForkJoinTask ..|&gt; Serializable : &quot;implements&quot;</code></pre>
<h4 id="executor-接口">Executor 接口</h4>
<p>将任务提交和任务执行进行解耦（<strong>decoupling the execution mechanic</strong>）。用户无需关注如何创建线程，如何调度线程（scheduling）来执行任务，用户只需提供 Runnable 对象，将任务的运行逻辑提交到执行器(Executor)中，由 Executor 框架完成线程的调配和任务的执行部分。</p>
<p>JUC 里所有的解耦设计都不一定是异步的，它只是<strong>解耦</strong>，所以执行器本身也是可以同步执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-comment">// 这个类型只有这一个核心方法</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable r)</span> &#123;<br>     r.run();<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>一般而言可以认为，executor 会 spawns a new thread for each task.</p>
<h4 id="executorservice-接口">ExecutorService 接口</h4>
<p>增加了一些能力：</p>
<p>扩充执行任务的能力，补充可以为一个或一批异步任务<strong>生成 Future 的方法</strong>（），<strong>从这里开始执行器开始可以执行异步任务</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task)<br><span class="hljs-comment">// 则个 api 是很神奇的，本质上 runnable 是没有返回值的，这相当于帮我们给一个 runnable 带上一个线程运行结束的结果</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span><br><span class="hljs-comment">// 这个接口有一个神奇的特性，只有所有异步流程都执行完，才会返回，否则会 hang 住</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="hljs-comment">// 这个接口的超时ji&#x27;s</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br></code></pre></td></tr></table></figure>
<p>在上面的方法里，submit 能接收无结果的 Runnable、有结果的 Runnable、能返回结果的 Callable，再加上底层无返回结果的 execute，构成了4个基础的单任务api。</p>
<p>ExecutorService 还提供了管控线程池的方法，比如停止线程池的运行。</p>
<ul>
<li>shutdown 拒绝接收任务，触发 rejection policy。</li>
<li>shutdownNow 除了 shutdown 的功能以外，还会强制触发线程中断。</li>
</ul>
<p>Memory consistency effects：future.get 满足 JSL 定义的 Memory consistency properties，也就是 happens before relation。</p>
<p>理解 happens before relation 一定不要按照硬件的工作方式来理解（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/67472344/java-volatile-and-final-volatile-as-flushing-all-memory-content">Flushing model is fundamentally flawed (it is just not how hardware works)</a>），最好从 JLS 的规范出发。</p>
<h4 id="abstractexecutorservice">AbstractExecutorService</h4>
<p>将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法<code>execute</code>即可。其他契约的借口全都在这一层实现了：</p>
<ul>
<li>大部分的任务接口在这一层有了实现，它们最终都调向了 execute() 接口。</li>
<li>生命周期接口留给下一层。</li>
</ul>
<p>这一层大部分的方法实现都是这样的：</p>
<ol>
<li>把任务包装成 FutureTask。</li>
<li>用 execute 执行这个 FutureTask。因为这个 FutureTask 包住了原始的 run 方法，所以它的 exception 处理机制会比 UncaughtExceptionHandler 更快一步拦截异常。</li>
<li>把 FutureTask 实例阻塞或者不阻塞地在同步流程里直接返回。</li>
<li>外部调用者不断与这些 task 通讯决定是否状态完成。</li>
</ol>
<p>其中多种调用模式的层叠大概是这样的：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant User
    participant AbstractExecutorService
    participant ThreadPoolExecutor
    participant WorkerThread
    participant FutureTask
    
    User-&gt;&gt;AbstractExecutorService: invokeAll(tasks)
    loop for each task
        AbstractExecutorService-&gt;&gt;AbstractExecutorService: newTaskFor(task)
        AbstractExecutorService-&gt;&gt;FutureTask: new FutureTask(task)
        AbstractExecutorService-&gt;&gt;ThreadPoolExecutor: execute(futureTask)
        ThreadPoolExecutor-&gt;&gt;WorkerThread: 分配任务
        WorkerThread-&gt;&gt;FutureTask: futureTask.run()
        FutureTask-&gt;&gt;Task: callable.call()
        Task--&gt;&gt;FutureTask: 返回结果
        FutureTask-&gt;&gt;FutureTask: set(result)
    end
    
    AbstractExecutorService-&gt;&gt;AbstractExecutorService: for each future: future.get()
    loop for each future
        AbstractExecutorService-&gt;&gt;FutureTask: future.get()
        alt 任务已完成
            FutureTask--&gt;&gt;AbstractExecutorService: 立即返回结果
        else 任务未完成
            FutureTask--&gt;&gt;FutureTask: 挂起等待
            FutureTask-&gt;&gt;FutureTask: 任务完成后唤醒
            FutureTask--&gt;&gt;AbstractExecutorService: 返回结果
        end
    end
    
    AbstractExecutorService--&gt;&gt;User: 返回所有Future结果</code></pre>
<h5 id="threadpoolexecutor">ThreadPoolExecutor</h5>
<p>实现了 execute，围绕execute 的批量和异步化给出了一个经典的线程池实现。</p>
<p>将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<p><img src="ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="ThreadPoolExecutor运行流程.png"></p>
<h5 id="forkjoinpool">ForkJoinPool</h5>
<p>这个线程池本身就是一个复杂框架，为 JDK 其他组件提供 yet another executor alternative。</p>
<p>这个框架有个特点：</p>
<ol>
<li>产生的线程默认是守护线程。</li>
<li>产生的线程会自动收缩-不存在空转的 core thread 问题。</li>
<li>公共线程池的名字一般叫“ForkJoinPool.commonPool-worker-1”。</li>
</ol>
<p>这里就要讨论到一个很多人忽略的问题：我们如何决定何时使用守护类线程。这类线程可以用来执行一些：</p>
<ol>
<li>临时执行的任务，这些任务之间如果存在父子关系更好。</li>
<li>后台监控类任务。</li>
<li>某些与 io 解耦的计算任务。</li>
</ol>
<p>这类线程池（包括守护线程本身）适合执行计算密集型任务，不适合执行 io 密集型任务，不然：</p>
<ol>
<li>工作线程池会在 JVM 关闭时被无声无息地杀死。</li>
<li>当其他非守护线程都结束后，这些守护线程的存在反而是 JVM 进入关闭态的理由。</li>
<li>典型的工作线程池就是 IO 线程池，和与他们绑定的计算线程池。</li>
</ol>
<p>初始化这类线程池有一些简单的工厂方法，比原始构造器更加可用：  <code>Executors.newWorkStealingPool(int parallelism)</code>。</p>
<p>更多内容见<a href="https://magicliang.github.io/2026/01/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3%EF%BC%9AForkJoinPool/">《线程池详解：ForkJoinPool》</a>。</p>
<h4 id="the-executors">The Executors</h4>
<blockquote>
<p>provides convenient factory methods for these Executors.</p>
</blockquote>
<h3 id="层次调用关系">层次调用关系</h3>
<h4 id="futuretask-作为线程池的核心任务载体">FutureTask 作为线程池的核心任务载体</h4>
<p>以  FutureTask 为核心，可以看出如下关系：</p>
<pre><code class="hljs mermaid">classDiagram
    class FutureTask &#123;
        -callable: Callable~V~
        -outcome: Object
        -state: int
        -runner: Thread
        
        +run() void
        +get() V
        +cancel(boolean) boolean
        +isDone() boolean
    &#125;
    
    class RunnableFuture &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    
    class Runnable &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    
    class Future &#123;
        &lt;&lt;interface&gt;&gt;
        +get() V
        +cancel(boolean) boolean
        +isDone() boolean
    &#125;
    
    class Callable &#123;
        &lt;&lt;interface&gt;&gt;
        +call() V
    &#125;
    
    FutureTask ..|&gt; RunnableFuture : implements
    RunnableFuture --|&gt; Runnable : extends
    RunnableFuture --|&gt; Future : extends
    FutureTask o-- Callable : has
    FutureTask o-- Object : stores
    FutureTask o-- Thread : references</code></pre>
<ul>
<li>我们先产生一个新的 Future 接口，然后把 Runnable 和 Future 联合继承出 RunnableFuture。这两个类型一个是对内线程池使用，一个是对外对任务的使用者使用。</li>
<li>然后 RunnableFuture 有个经典实现类 FutureTask-这是两个经典的 RunnableFuture 的经典实现之一（<code>All Known Implementing Classes:FutureTask, SwingWorker</code>），可以认为 FutureTask 是可执行的 Future 的最忠实实现。它本身<strong>不是 Callble，但是包含 Callable</strong>。它的5个一级子成员：
<ul>
<li>callable</li>
<li>outCome 这个成员同时可以是 result 也可以是异常，由 report 自行决定处理方式</li>
<li>runner：用来状态检查，并持有它保证拥有中断能力、取消能力</li>
<li>state：这是线程池里出现的第一个状态，</li>
</ul>
</li>
<li>因为是 runnable 包着 callable，所以底层的运行模式大概是这样的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 之所以这样设计，本质上是因为 Thread 类底层也是 run，不支持 call</span><br>task.run() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行组合的 Callable</span><br>        outcome = callable.call();  <span class="hljs-comment">// &quot;Hello World&quot;</span><br>        state = NORMAL;            <span class="hljs-comment">// 状态转换</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        exception = e;             <span class="hljs-comment">// 存储异常</span><br>        state = EXCEPTIONAL;       <span class="hljs-comment">// 状态转换</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="thread-模型底层">Thread 模型底层</h5>
<p>之所以这样设计，实际上是因为 Thread 模型底层只支持 run 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java 从 1.0 开始就实现了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> Runnable target;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>            target.run();  <span class="hljs-comment">// 只能调用 run()，没有返回值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>底层的 cpp 源码是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// HotSpot JVM 源码：thread.cpp</span><br><span class="hljs-built_in">JVM_ENTRY</span>(<span class="hljs-type">void</span>, <span class="hljs-built_in">JVM_StartThread</span>(JNIEnv* jni, jobject jthread))<br>  <span class="hljs-built_in">JVMWrapper</span>(<span class="hljs-string">&quot;JVM_StartThread&quot;</span>);<br>  <br>  <span class="hljs-comment">// 1. 从 Java 对象获取 C++ Thread 对象</span><br>  JavaThread* native_thread = java_lang_Thread::<span class="hljs-built_in">thread</span>(JNIHandles::<span class="hljs-built_in">resolve_non_null</span>(jthread));<br>  <br>  <span class="hljs-comment">// 2. 状态检查</span><br>  <span class="hljs-keyword">if</span> (native_thread-&gt;<span class="hljs-built_in">is_being_ext_suspended</span>()) &#123;<br>    native_thread-&gt;<span class="hljs-built_in">set_terminated_before_start</span>(<span class="hljs-literal">true</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 3. 创建操作系统线程</span><br>  <span class="hljs-keyword">if</span> (native_thread-&gt;<span class="hljs-built_in">osthread</span>() != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// 关键：调用 os::create_thread 创建 OS 线程</span><br>    <span class="hljs-keyword">if</span> (os::<span class="hljs-built_in">create_thread</span>(native_thread, java_thread)) &#123;<br>      <span class="hljs-comment">// 4. 设置线程状态为 INITIALIZED</span><br>      native_thread-&gt;<span class="hljs-built_in">set_state</span>(INITIALIZED);<br>      <br>      <span class="hljs-comment">// 5. 启动操作系统线程</span><br>      os::<span class="hljs-built_in">start_thread</span>(native_thread);<br>    &#125;<br>  &#125;<br>JVM_END<br><br><span class="hljs-comment">// Linux 实现 (os_linux.cpp)</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">os::create_thread</span><span class="hljs-params">(Thread* thread, ThreadType thr_type)</span> </span>&#123;<br>  <span class="hljs-comment">// 1. 创建 pthread_attr_t 属性</span><br>  <span class="hljs-type">pthread_attr_t</span> attr;<br>  <span class="hljs-built_in">pthread_attr_init</span>(&amp;attr);<br>  <br>  <span class="hljs-comment">// 2. 设置栈大小</span><br>  <span class="hljs-type">size_t</span> stack_size = ...; <span class="hljs-comment">// 根据线程类型设置</span><br>  <span class="hljs-built_in">pthread_attr_setstacksize</span>(&amp;attr, stack_size);<br>  <br>  <span class="hljs-comment">// 3. 关键：创建 pthread 线程</span><br>  <span class="hljs-type">pthread_t</span> tid;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;tid, &amp;attr, thread_native_entry, thread);<br>  <br>  <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 4. 保存线程 ID</span><br>    thread-&gt;<span class="hljs-built_in">set_thread_id</span>(tid);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 线程入口函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">thread_native_entry</span><span class="hljs-params">(Thread* thread)</span> </span>&#123;<br>  <span class="hljs-comment">// 1. 设置线程状态</span><br>  thread-&gt;<span class="hljs-built_in">set_state</span>(RUNNABLE);<br>  <br>  <span class="hljs-comment">// 2. 关键：调用 Java 层的 run() 方法</span><br>  thread-&gt;<span class="hljs-built_in">run</span>();<br>  <br>  <span class="hljs-comment">// 3. 线程结束处理</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// HotSpot JVM 中的关键结构，这个 javaThread 既持有操作系统线程句柄，也持有 Java 线程句柄。这样实现了平台无关性。</span><br><span class="hljs-comment">// JavaThread 确实是三位一体的设计：</span><br><span class="hljs-comment">// 1. JVM 层：JavaThread* 本身（管理 JVM 内部状态）</span><br><span class="hljs-comment">// 2. OS 层：OSThread* _osthread（操作系统资源）</span><br><span class="hljs-comment">// 3. Java 层：oop _threadObj（java.lang.Thread 对象）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaThread</span>: <span class="hljs-keyword">public</span> Thread &#123;<br><span class="hljs-keyword">private</span>:<br>  oop _threadObj;        <span class="hljs-comment">// 对应的 Java Thread 对象</span><br>  OSThread* _osthread;   <span class="hljs-comment">// 操作系统线程</span><br>  <span class="hljs-keyword">volatile</span> JavaThreadState _state; <span class="hljs-comment">// 线程状态</span><br>  <br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用 Java 层的 run() 方法</span><br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">thread_main_inner</span>();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_main_inner</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_java_lang_thread</span>()) &#123;<br>      <span class="hljs-comment">// 通过 JNI 调用 Java 层的 run() 方法</span><br>      JavaCalls::<span class="hljs-built_in">call_virtual</span>(<br>        &amp;result,<br>        klass,<br>        method,<br>        threadObj,<br>        CHECK<br>      );<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 通过 JNI 调用 Java 方法</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">call_run_method</span><span class="hljs-params">(JNIEnv* env, jobject jthread)</span> </span>&#123;<br>  jclass threadClass = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;java/lang/Thread&quot;</span>);<br>  jmethodID runMethod = env-&gt;<span class="hljs-built_in">GetMethodID</span>(threadClass, <span class="hljs-string">&quot;run&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>  <br>  <span class="hljs-comment">// 调用 Thread.run() 方法</span><br>  env-&gt;<span class="hljs-built_in">CallVoidMethod</span>(jthread, runMethod);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>整体调用的流程是从 java 到 cpp 再到 java 的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 调用链：</span><br>thread<span class="hljs-selector-class">.start</span>()<br>  → Thread<span class="hljs-selector-class">.start</span>() <span class="hljs-selector-attr">[Java]</span><br>  → <span class="hljs-built_in">start0</span>() <span class="hljs-selector-attr">[native]</span><br>  → <span class="hljs-built_in">JVM_StartThread</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → os::<span class="hljs-built_in">create_thread</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → <span class="hljs-built_in">pthread_create</span>() <span class="hljs-selector-attr">[Linux C]</span><br>  → <span class="hljs-built_in">thread_native_entry</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → JavaThread::<span class="hljs-built_in">run</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → JNI: <span class="hljs-built_in">CallVoidMethod</span>(threadObj, <span class="hljs-string">&quot;run&quot;</span>) <span class="hljs-selector-attr">[JNI]</span><br>  → Thread<span class="hljs-selector-class">.run</span>() <span class="hljs-selector-attr">[Java]</span><br>  → target<span class="hljs-selector-class">.run</span>() <span class="hljs-selector-attr">[Java]</span>  <span class="hljs-comment">// 最终调用用户代码</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">classDiagram
    class JavaThread &#123;
        -OSThread* _osthread
        -oop _threadObj
        -JavaThreadState _state
        -address _stack_base
        -size_t _stack_size
        
        +run()
        +thread_main_inner()
        +osthread() OSThread*
        +threadObj() oop
    &#125;
    
    class OSThread &#123;
        -pthread_t _thread_id
        -int _thread_state
        
        +set_thread_id(pthread_t)
        +thread_id() pthread_t
    &#125;
    
    class JavaThreadObj &#123;
        &lt;&lt;Java Object&gt;&gt;
        -Runnable target
        -int threadStatus
        
        +start()
        +run()
    &#125;
    
    JavaThread o-- OSThread : &quot;持有操作系统线程&quot;
    JavaThread o-- JavaThreadObj : &quot;关联Java对象&quot;</code></pre>
<pre><code class="hljs mermaid">sequenceDiagram
    participant User as Java代码
    participant JVM as JVM(JavaThread)
    participant OS as 操作系统
    
    User-&gt;&gt;JVM: new Thread(runnable)
    JVM-&gt;&gt;JVM: 创建JavaThread对象
    JVM-&gt;&gt;JVM: 创建OSThread对象
    JVM-&gt;&gt;JVM: 关联JavaThread和OSThread
    
    User-&gt;&gt;JVM: thread.start()
    JVM-&gt;&gt;JVM: 检查状态(threadStatus)
    JVM-&gt;&gt;JVM: 添加到线程组
    JVM-&gt;&gt;JVM: 调用start0()(native)
    
    JVM-&gt;&gt;OS: os::create_thread()
    OS-&gt;&gt;OS: 创建pthread线程
    OS-&gt;&gt;OS: 设置入口为thread_native_entry
    
    OS--&gt;&gt;JVM: 线程创建成功
    JVM--&gt;&gt;User: start()返回
    
    Note over OS: 新线程开始执行
    OS-&gt;&gt;JVM: thread_native_entry(JavaThread*)
    JVM-&gt;&gt;JVM: 设置线程状态为RUNNABLE
    JVM-&gt;&gt;JVM: thread-&gt;run()
    JVM-&gt;&gt;JVM: thread_main_inner()
    
    JVM-&gt;&gt;JVM: JNI: 查找Thread.run()方法
    JVM-&gt;&gt;JVM: JavaCalls::call_virtual()
    
    JVM-&gt;&gt;User: 调用Thread.run()
    User-&gt;&gt;User: target.run()(如果target!=null)
    
    User--&gt;&gt;JVM: 返回
    JVM-&gt;&gt;JVM: 线程结束清理
    JVM-&gt;&gt;OS: 释放操作系统资源</code></pre>
<h5 id="futuretask-的-run">FutureTask 的 run()</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123;<br>    <br>    <span class="hljs-comment">// 同时实现 Runnable（可执行）和 Future（可获取结果）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset, <span class="hljs-literal">null</span>, Thread.currentThread()))<br>            <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            Callable&lt;V&gt; c = callable;<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>                V result;<br>                <span class="hljs-type">boolean</span> ran;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    result = c.call();  <span class="hljs-comment">// 执行实际任务（支持返回值）</span><br>                    ran = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                    result = <span class="hljs-literal">null</span>;<br>                    ran = <span class="hljs-literal">false</span>;<br>                    setException(ex);  <span class="hljs-comment">// 设置异常</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (ran)<br>                    set(result);  <span class="hljs-comment">// 设置结果</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            runner = <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>            <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>                handlePossibleCancellationInterrupt(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="futuretask-的-runner">FutureTask 的 runner</h5>
<p>其中 runner 的注入/获取流程大致如下：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant ThreadA
    participant FutureTask
    participant ThreadB
    
    ThreadA-&gt;&gt;FutureTask: submit(task)
    FutureTask-&gt;&gt;FutureTask: state = NEW, runner = null
    
    ThreadB-&gt;&gt;FutureTask: execute(task) // 线程池线程
    FutureTask-&gt;&gt;FutureTask: CAS设置 runner = ThreadB
    FutureTask-&gt;&gt;ThreadB: 执行任务逻辑
    
    Note right of FutureTask: 此时 runner = ThreadB
    
    ThreadA-&gt;&gt;FutureTask: cancel(true)
    FutureTask-&gt;&gt;FutureTask: 检查 mayInterruptIfRunning = true
    FutureTask-&gt;&gt;ThreadB: runner.interrupt() // 使用runner字段
    
    ThreadB--&gt;&gt;FutureTask: 任务被中断
    FutureTask-&gt;&gt;FutureTask: state = INTERRUPTED
    FutureTask-&gt;&gt;FutureTask: runner = null // 清理引用
    
    Note right of FutureTask: 任务完成，runner = null</code></pre>
<h6 id="invokeall">invokeAll</h6>
<p><strong>invokeAll 是有界的</strong>，如果一次性提交了超过它界限的任务，即使这些任务是一瞬间执行的-invokeAll 也会触发拒绝，除非任务执行的速度比 for 循环调用底层的 execute 的速度还要快。</p>
<p>如果有得选，我们批量执行任务应该尽量采用 invokeAll，因为它带有这些特殊的代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                                         <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (tasks == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(tasks.size());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">done</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks)<br>                futures.add(newTaskFor(t));<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> futures.size();<br><br>            <span class="hljs-comment">// Interleave time checks and calls to execute in case</span><br>            <span class="hljs-comment">// executor doesn&#x27;t have any/much parallelism.</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                execute((Runnable)futures.get(i));<br>                nanos = deadline - System.nanoTime();<br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> futures;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                Future&lt;T&gt; f = futures.get(i);<br>                <span class="hljs-keyword">if</span> (!f.isDone()) &#123;<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                        <span class="hljs-keyword">return</span> futures;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// FutureTask 是可以重复获取的</span><br>                        f.get(nanos, TimeUnit.NANOSECONDS);<br>                    &#125; <span class="hljs-keyword">catch</span> (CancellationException ignore) &#123;<br>                    &#125; <span class="hljs-keyword">catch</span> (ExecutionException ignore) &#123;<br>                    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>                        <span class="hljs-keyword">return</span> futures;<br>                    &#125;<br>                    nanos = deadline - System.nanoTime();<br>                &#125;<br>            &#125;<br>            done = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> futures;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (!done)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = futures.size(); i &lt; size; i++)                <br>                    <span class="hljs-comment">// 我们不鼓励 cancel java 线程，但是可以，而且鼓励 cancel Future</span><br>                    futures.get(i).cancel(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h6 id="两种针对-runnable-的-submit">两种针对 Runnable 的 submit</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通 submit(Runnable) - Future.get() 返回 null</span><br>Future&lt;?&gt; future3 = executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;普通任务&quot;</span>));<br><span class="hljs-type">Object</span> <span class="hljs-variable">result3</span> <span class="hljs-operator">=</span> future3.get(); <span class="hljs-comment">// result3 == null</span><br><br><span class="hljs-comment">// submit(Runnable, T result) - Future.get() 返回指定的结果</span><br>Future&lt;String&gt; future4 = executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;带结果的任务&quot;</span>), <span class="hljs-string">&quot;自定义结果&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">result4</span> <span class="hljs-operator">=</span> future4.get(); <span class="hljs-comment">// result4 == &quot;自定义结果&quot;</span><br></code></pre></td></tr></table></figure>
<p>这里面使用到了2种适配器：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">用户层：需要 <span class="hljs-built_in">submit</span>(Runnable, T result) 这样的高级API<br>       ↓<br>适配层：RunnableAdapter 提供语义适配<br>       ↓  <br>执行层：FutureTask 提供接口适配  <br>       ↓<br>基础层：ThreadPoolExecutor 只认 <span class="hljs-built_in">execute</span>(Runnable)<br></code></pre></td></tr></table></figure>
<p>也就是说，底层的 execute 本身要求一个包含 callable + result 的 runnbale - FutureTask（向底层的 execute api 适配，向外提供 Future 的 get、cancel 等能力），但是这样的 callable 最初又要经过 RunnableAdapter 从 Runnable 得来（向上向原始的没有返回值的 Runnable 适配）。</p>
<p>想象一个国际物流系统：</p>
<ul>
<li>FutureTask：相当于报关代理，将&quot;有特殊要求的货物&quot;（Callable）转换成&quot;标准集装箱&quot;（Runnable）以便运输</li>
<li>RunnableAdapter：相当于包装服务，将&quot;普通货物&quot;（Runnable）包装成&quot;带保价标签的货物&quot;（Callable），提供额外保障</li>
</ul>
<p>两类底层调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 底层调用链</span><br><span class="hljs-comment">// 1. submit(callable) → new FutureTask(callable)</span><br><span class="hljs-comment">// 2. execute(futureTask) → futureTask.run()</span><br><span class="hljs-comment">// 3. futureTask.run() → callable.call() → return 42</span><br><span class="hljs-comment">// 4. future.get() → 42</span><br><br><span class="hljs-comment">// 底层调用链</span><br><span class="hljs-comment">// 1. submit(runnable, result) → Executors.callable(runnable, result) </span><br><span class="hljs-comment">//   → new RunnableAdapter(runnable, result)</span><br><span class="hljs-comment">// 2. new FutureTask(runnableAdapter) </span><br><span class="hljs-comment">//   → futureTask内部持有runnableAdapter</span><br><span class="hljs-comment">// 3. execute(futureTask) → futureTask.run()</span><br><span class="hljs-comment">// 4. futureTask.run() → runnableAdapter.call()</span><br><span class="hljs-comment">// 5. runnableAdapter.call() → runnable.run() + return successMessage</span><br><span class="hljs-comment">// 6. future.get() → successMessage</span><br></code></pre></td></tr></table></figure>
<h3 id="线程池如何维护自身状态">线程池如何维护自身状态</h3>
<p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>
<p>ctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，<strong>不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况</strong>。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。<strong>这里都使用的是位运算的方式，相比于基本运算，速度也会快很多</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 29</span><br>        System.out.println(COUNT_BITS);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">shifted</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 1 与 29 个 0，所以左移意味着补 0，左移一位意味着补 1 个 0，左移 29 位意味着补 29 个 0，最后得到 30 位数：100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(shifted));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> shifted - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 29个 1：11111111111111111111111111111</span><br>        System.out.println(Integer.toBinaryString(CAPACITY));<br>        <span class="hljs-comment">// 高 3 位为 1，低 29 位为 0：11100000000000000000000000000000，和 CAPACITY 低 29 位为 1，高 3 位为 0 恰好相反</span><br>        System.out.println(Integer.toBinaryString(~CAPACITY));<br>        System.out.println(Integer.toBinaryString(~CAPACITY));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// -1 意味着 32 个 1：11111111111111111111111111111111</span><br>        System.out.println(Integer.toBinaryString(-<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 3 个 1 和 29 个 0：11100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(RUNNING));<br>        <br>        <span class="hljs-comment">// 重点：从后方补 0 的算法，可以把 state 的基准位从低位移到高位，这样大数的一部分就可以拿来表示有限状态了</span><br>        <br>        <span class="hljs-comment">// 0 不管位移多少位都是 0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br>        System.out.println(Integer.toBinaryString(SHUTDOWN));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 1 和 29 个 0：100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(STOP));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 10 和 29 个 0：1000000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(TIDYING));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 11 和 29 个 0：1100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(TERMINATED));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> getCapacity();<br>        <span class="hljs-comment">// 把 CAPACITY 的补码按位与，这样高 32 位就可以被取出来</span><br>        <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; <br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> getCapacity();<br>        <span class="hljs-comment">// 低 32 位本身就是 workCount，这个 workCount 可以容纳很大的数</span><br>        <span class="hljs-keyword">return</span> c &amp; CAPACITY; <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123;<br>        <span class="hljs-keyword">return</span> rs | wc; <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCapacity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">shifted</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> shifted - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> CAPACITY;<br>    &#125;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">运行状态</th>
<th style="text-align:center">状态描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RUNNING</td>
<td style="text-align:center">能接受新提交的任务，并且也能处理阻塞队列中的任务。</td>
</tr>
<tr>
<td style="text-align:center">SHUTDOWN</td>
<td style="text-align:center">关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。</td>
</tr>
<tr>
<td style="text-align:center">STOP</td>
<td style="text-align:center">不能接受新任务，【也不处理队列中的任务，会中断正在处理任务的线程。】增加了两条措施，是一个更严厉的状态，理论上只要线程被中断完，线程池就可以走向关闭</td>
</tr>
<tr>
<td style="text-align:center">TIDYING</td>
<td style="text-align:center">所有的任务都已终止了，workerCount (有效线程数) 为0，这个状态的意思不是整理中，而是整理完了。</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td style="text-align:center">在terminated() 方法执行完后进入该状态。</td>
</tr>
</tbody>
</table>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程池生命周期.png"></p>
<p>其中 running 既是初始态，也是中间态，所以才有<code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</code>作为初始化块的一部分。</p>
<h4 id="尝试关闭线程池">尝试关闭线程池</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Transitions to TERMINATED state if either (SHUTDOWN and pool</span><br><span class="hljs-comment"> * and queue empty) or (STOP and pool empty).  If otherwise</span><br><span class="hljs-comment"> * eligible to terminate but workerCount is nonzero, interrupts an</span><br><span class="hljs-comment"> * idle worker to ensure that shutdown signals propagate. This</span><br><span class="hljs-comment"> * method must be called following any action that might make</span><br><span class="hljs-comment"> * termination possible -- reducing worker count or removing tasks</span><br><span class="hljs-comment"> * from the queue during shutdown. The method is non-private to</span><br><span class="hljs-comment"> * allow access from ScheduledThreadPoolExecutor.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 注意这里有个自旋</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">//  尝试把把本线程池的状态改成 TIDYING -&gt; TERMINATED，所以正在 running、正在 shutdown 但队列未空、已经高于 TIDYING 都直接返回</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 只要 wc&gt;0，就关闭并只关闭一个空闲线程（看起来这里是假设本方法通常是由线程退出来触发的，所以此处能够关掉一个就直接退出）</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果一个 worker 都没有了，就真的关闭本线程池</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这个地方做了一个多余操作，把 TIDYING 做一个 ctlOf 转化            // 先置为 TIDYING</span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 通常是一个空钩子方法，这两个状态之间就差了一个钩子设计</span><br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 再设置为 TERMINATED</span><br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    <span class="hljs-comment">// 已关闭才做 signalAll()</span><br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>        <span class="hljs-comment">// 这里失败，下次再从外部进入 TIDYING -&gt; TERMINATED 的循环</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="线程池如何管理任务">线程池如何管理任务</h3>
<p>每个线程池的 Worker 管理的实质上是 FutureTask，它既是<code>Callable</code>（确切地说，wrap Callable），也是<code>Future</code>（一个最完美的任务是一个<code>RunnableFuture&lt;V&gt;</code>，用成员变量来帮助 <code>Runnable</code>来保存一个<code>Callable</code>的返回值，以供<code>Future</code>使用）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个可以取消的计算。</span><br><span class="hljs-comment">// 基本上只能完成一次，除非执行 runAndReset，执行完成不能再 cancel</span><br><span class="hljs-comment">// 只有计算执行完成 get 才可以获取结果，之前必然阻塞</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A cancellable asynchronous computation.  This class provides a base</span><br><span class="hljs-comment"> * implementation of &#123;<span class="hljs-doctag">@link</span> Future&#125;, with methods to start and cancel</span><br><span class="hljs-comment"> * a computation, query to see if the computation is complete, and</span><br><span class="hljs-comment"> * retrieve the result of the computation.  The result can only be</span><br><span class="hljs-comment"> * retrieved when the computation has completed; the &#123;<span class="hljs-doctag">@code</span> get&#125;</span><br><span class="hljs-comment"> * methods will block if the computation has not yet completed.  Once</span><br><span class="hljs-comment"> * the computation has completed, the computation cannot be restarted</span><br><span class="hljs-comment"> * or cancelled (unless the computation is invoked using</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #runAndReset&#125;).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;A &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; can be used to wrap a &#123;<span class="hljs-doctag">@link</span> Callable&#125; or</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Runnable&#125; object.  Because &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; implements</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> Runnable&#125;, a &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; can be submitted to an</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Executor&#125; for execution.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;In addition to serving as a standalone class, this class provides</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> protected&#125; functionality that may be useful when creating</span><br><span class="hljs-comment"> * customized task classes.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Doug Lea</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;V&gt; The result type returned by this FutureTask&#x27;s &#123;<span class="hljs-doctag">@code</span> get&#125; methods</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>线程池使用一个把 Runnable 转变为 Callable 的适配器（Callable 转 Runnable 理论上也是容易做到的，但应该没有必要转换），来兼容把 Runnable 传进 submit 的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 把 runnable 和一个勉强的 result 包装成一个 callable，分三步</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>        <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>        <span class="hljs-built_in">this</span>.state = NEW;       <span class="hljs-comment">// ensure visibility of callable</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="hljs-title function_">callable</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt;(task, result);<br>    &#125;<br>    <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">final</span> Runnable task;<br>        <span class="hljs-keyword">final</span> T result;<br>        RunnableAdapter(Runnable task, T result) &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>            <span class="hljs-built_in">this</span>.result = result;<br>        &#125;<br>        <span class="hljs-comment">// 注意，这个 call() 是不抛出异常的，所以对 Java 而言，子类的签名里可以不继续抛出父类声明的异常，</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>            task.run();<br>            <span class="hljs-comment">// 组合逻辑在这一层</span><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>FutureTask 实现了 RunnableFuture，它本质上是一个携带 Runnable 和 state 的任务。</p>
<p>首先看它的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The run state of this task, initially NEW.  The run state</span><br><span class="hljs-comment">     * transitions to a terminal state only in methods set,</span><br><span class="hljs-comment">     * setException, and cancel.  During completion, state may take on</span><br><span class="hljs-comment">     * transient values of COMPLETING (while outcome is being set) or</span><br><span class="hljs-comment">     * INTERRUPTING (only while interrupting the runner to satisfy a</span><br><span class="hljs-comment">     * cancel(true)). Transitions from these intermediate to final</span><br><span class="hljs-comment">     * states use cheaper ordered/lazy writes because values are unique</span><br><span class="hljs-comment">     * and cannot be further modified.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Possible state transitions:</span><br><span class="hljs-comment">     * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="hljs-comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="hljs-comment">     * NEW -&gt; CANCELLED</span><br><span class="hljs-comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure>
<p><strong>FutureTask 状态转换图</strong>：</p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; NEW: 任务创建
    
    NEW --&gt; COMPLETING: call()执行完成
    NEW --&gt; CANCELLED: cancel(false)
    NEW --&gt; INTERRUPTING: cancel(true)
    
    COMPLETING --&gt; NORMAL: 正常结果设置完成
    COMPLETING --&gt; EXCEPTIONAL: 异常结果设置完成
    
    INTERRUPTING --&gt; INTERRUPTED: 中断完成
    
    NORMAL --&gt; [*]: 终态
    EXCEPTIONAL --&gt; [*]: 终态
    CANCELLED --&gt; [*]: 终态
    INTERRUPTED --&gt; [*]: 终态
    
    note right of NEW: 初始状态，任务可被取消
    note right of COMPLETING: 瞬态，正在设置结果
    note right of INTERRUPTING: 瞬态，正在中断runner</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>值得一提的是，任务的中间状态是一个瞬态，它非常的短暂。而且任务的中间态并不代表任务正在执行，而是任务已经执行完了，正在设置最终的返回结果，所以可以这么说：<br>
只要state不处于 NEW 状态，就说明任务已经执行完毕。<br>
注意，<strong>这里的执行完毕是指传入的Callable对象的call方法执行完毕</strong>，<strong>或者抛出了异常</strong>。所以这里的COMPLETING的名字显得有点迷惑性，它并不意味着任务正在执行中，而意味着call方法已经执行完毕，正在设置任务执行的结果。</p>
</blockquote>
<p>换言之，只有 NEW 状态才是 cancellable 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Doug Lea 本身比较喜欢使用普通整数来制造状态机</span><br><span class="hljs-comment">// COMPLETING 和 INTERRUPTING 是 set state 和取消任务的中间态</span><br>    <br>    <span class="hljs-comment">/** The underlying callable; nulled out after running */</span><br>    <span class="hljs-keyword">private</span> Callable&lt;V&gt; callable;<br>    <br>    <span class="hljs-comment">// 异常和输出使用同一个 outcome，所以 outcome 不能是泛型，必须是 object</span><br>    <span class="hljs-comment">// 它是非 volatile 的，需要巧妙利用 state 读写</span><br>    <span class="hljs-comment">// </span><br>    <span class="hljs-comment">// **happens-before 传递性分析**：outcome 的可见性是通过 state 的 volatile 写-读来保证的。</span><br>    <span class="hljs-comment">// 这依赖于 JMM 的 happens-before 传递性：</span><br>    <span class="hljs-comment">// 1. outcome = v happens-before state = NORMAL（程序顺序规则：同一线程内，前面的操作 happens-before 后面的操作）</span><br>    <span class="hljs-comment">// 2. state = NORMAL happens-before 读取 state（volatile 规则：volatile 写 happens-before 后续的 volatile 读）</span><br>    <span class="hljs-comment">// 3. 因此，outcome = v happens-before 读取 outcome（传递性）</span><br>    <span class="hljs-comment">// 这就是为什么 outcome 不需要声明为 volatile，只要保证在写 outcome 之后再写 volatile state，</span><br>    <span class="hljs-comment">// 在读 volatile state 之后再读 outcome，就能保证 outcome 的可见性。</span><br>    <span class="hljs-comment">/** The result to return or exception to throw from get() */</span><br>    <span class="hljs-keyword">private</span> Object outcome; <span class="hljs-comment">// non-volatile, protected by state reads/writes</span><br>    <br>    <span class="hljs-comment">/** The thread running the callable; CASed during run() */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread runner;<br>    <br>    <span class="hljs-comment">/** Treiber stack of waiting threads */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WaitNode waiters;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.callable = callable;<br>    <span class="hljs-comment">// ensure visibility of callable</span><br>    <span class="hljs-built_in">this</span>.state = NEW;       <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>            <span class="hljs-comment">// 把 volatile 变量写在写语句的最后，写在读语句的最前面，类似 monitorEnter 和 monitorExit 的语义，可以保证可见性</span><br>    <span class="hljs-comment">// ensure visibility of callable</span><br>    <span class="hljs-built_in">this</span>.state = NEW;       <br>&#125;<br></code></pre></td></tr></table></figure>
<p>它的状态管理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state &gt;= CANCELLED;<br>    &#125;<br>    <span class="hljs-comment">// 只要不是 NEW 就是完成了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state != NEW;<br>    &#125;<br><br>    <br>    <span class="hljs-comment">// 移除并通知所有等待线程，</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Removes and signals all waiting threads, invokes done(), and</span><br><span class="hljs-comment">     * nulls out callable.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishCompletion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// assert state &gt; COMPLETING;</span><br>        <span class="hljs-comment">// 漂亮的声明和比对写法</span><br>        <span class="hljs-keyword">for</span> (WaitNode q; (q = waiters) != <span class="hljs-literal">null</span>;) &#123;<br>            <span class="hljs-comment">// 在 for 循环里用 cas 把 waiter 置空</span><br>            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q, <span class="hljs-literal">null</span>)) &#123;        <br>                <span class="hljs-comment">// 在内层循环里把当前线程和 futureTask 的关系移除，并且</span><br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    <span class="hljs-comment">// 在这个内存循环里面，要做的就是一个个遍历链表的 next，unpark 掉它们，并且 help gc</span><br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q.thread;<br>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                        q.thread = <span class="hljs-literal">null</span>;<br>                        LockSupport.unpark(t);<br>                    &#125;<br>                    <span class="hljs-type">WaitNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> q.next;<br>                    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>                        <span class="hljs-keyword">break</span>;<br>                    q.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// unlink to help gc</span><br>                    q = next;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        done();<br>        <span class="hljs-comment">// 此处就是上面的 nulled 的意思了，任务进入终态以后 callable 也可以被回收</span><br>        callable = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// to reduce footprint</span><br>    &#125;<br>    <br><span class="hljs-comment">// 通过使 permit 变成 available 的方式，使这个线程从 blocked 状态变成非 blocked 状态，或者下次调用 park 的时候非阻塞。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>            UNSAFE.unpark(thread);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>实际被工作线程调度的 run 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 如果不等于 new 或者 cas 把线程绑定到本 future task 上，就直接退出，这其实是一种幂等</span><br>       <span class="hljs-comment">// runner 的获取是从上下文里获得的</span><br>       <span class="hljs-keyword">if</span> (state != NEW ||<br>           !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                        <span class="hljs-literal">null</span>, Thread.currentThread()))<br>           <span class="hljs-keyword">return</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           Callable&lt;V&gt; c = callable;<br>           <span class="hljs-comment">// 只有状态和 callable 完备才能把值设进来</span><br>           <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>               V result;<br>               <span class="hljs-type">boolean</span> ran;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   result = c.call();<br>                   ran = <span class="hljs-literal">true</span>;<br>               &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                   result = <span class="hljs-literal">null</span>;<br>                   ran = <span class="hljs-literal">false</span>;<br>                   <span class="hljs-comment">// 如果 run 出异常，就进入 setException 终态方法</span><br>                   setException(ex);<br>               &#125;<br>               <span class="hljs-keyword">if</span> (ran)<br>                   <span class="hljs-comment">// 否则，set result，走入另一种终态</span><br>                   set(result);<br>           &#125;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-comment">// runner must be non-null until state is settled to</span><br>           <span class="hljs-comment">// prevent concurrent calls to run()</span><br>           <span class="hljs-comment">// 执行完要把 runner 置空，这样上面那个 cas 对其他线程而言就会失败</span><br>           runner = <span class="hljs-literal">null</span>;<br>           <span class="hljs-comment">// state must be re-read after nulling runner to prevent</span><br>           <span class="hljs-comment">// leaked interrupts</span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>           <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>               <span class="hljs-comment">// 可能有其他线程在 interrupting，在这里实现一套等待到  interrupted 的自旋 yield</span><br>               handlePossibleCancellationInterrupt(s);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>run 有一个重跑版本，这个版本会重复执行，但不会影响 get 的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Executes the computation without setting its result, and then</span><br><span class="hljs-comment"> * resets this future to initial state, failing to do so if the</span><br><span class="hljs-comment"> * computation encounters an exception or is cancelled.  This is</span><br><span class="hljs-comment"> * designed for use with tasks that intrinsically execute more</span><br><span class="hljs-comment"> * than once.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if successfully run and reset</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runAndReset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (state != NEW ||<br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                     <span class="hljs-literal">null</span>, Thread.currentThread()))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ran</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Callable&lt;V&gt; c = callable;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; s == NEW) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                c.call(); <span class="hljs-comment">// don&#x27;t set result</span><br>                ran = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                setException(ex);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// runner must be non-null until state is settled to</span><br>        <span class="hljs-comment">// prevent concurrent calls to run()</span><br>        runner = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// state must be re-read after nulling runner to prevent</span><br>        <span class="hljs-comment">// leaked interrupts</span><br>        s = state;<br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>            handlePossibleCancellationInterrupt(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ran &amp;&amp; s == NEW;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 FutureTask 里有三类终态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V v)</span> &#123;<br>    <span class="hljs-comment">// 在两个 CAS 操作之间夹逼一个 outcome</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>        outcome = v;<br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, NORMAL); <span class="hljs-comment">// final state</span><br>        finishCompletion();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 几乎等同于 set，但夹逼的是把 Throwable 设进 outcome 里面</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setException</span><span class="hljs-params">(Throwable t)</span> &#123;<br>    <span class="hljs-comment">// 注意这里只能把 callable 内部的异常设置进 outcome 里面，如果本服务发生了 interrupt，则这里必然失败</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>        outcome = t;<br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="hljs-comment">// final state</span><br>        finishCompletion();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 从这个方法可以看出，中断也是 cancel 的一种</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br>    <span class="hljs-comment">// 在一个布尔表达式里面表达顺序结构</span><br>    <span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp;<br>          UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW,<br>              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br>        <span class="hljs-comment">// 只能从 new 迁移到 INTERRUPTING 或者 CANCELLED，只要 cas 不成功，就返回 false。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// in case call to interrupt throws exception</span><br>        <span class="hljs-comment">// 如果取消带有中断标志</span><br>        <span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;<br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 强制中断这个线程</span><br>                    t.interrupt();<br>            &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// final state</span><br>                <span class="hljs-comment">// 不使用 cas，把本应用的状态设为已中断</span><br>                UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, INTERRUPTED);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 所有的终态操作都有的一个操作</span><br>        finishCompletion();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果程序进入终态，则 get 终于可以得到合理的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// get 的阻塞部分交给 awaitDone，而取值部分交给 report</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-comment">// 比对状态</span><br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>        <span class="hljs-comment">// 进入计时的 awaitDone 流程，这里的计时结果是带有状态的，0L 意味着无限计时。</span><br>        s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    <span class="hljs-comment">// 进入 report 流程</span><br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br>   <br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>    <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>        (s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中等待流程见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Awaits completion or aborts on interrupt or timeout.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> timed true if use timed waits</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> nanos time to wait, if timed</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> state upon completion</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>     <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;<br>     <span class="hljs-type">WaitNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>     <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>     <span class="hljs-comment">// 这里通过自旋来实现计时等待</span><br>     <span class="hljs-keyword">for</span> (;;) &#123;<br>         <span class="hljs-comment">// 如果本线程被中断，则释放所有的 get 线程，然后抛出一个中断异常，这里引入了一个经典的设计模式，在 waiting  状态内发生 interrupt 的地方，响应中断的方式是清空中断位（而不是简单地 swap），并抛出中断异常</span><br>         <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>             <span class="hljs-comment">// 如果中断了（不正常退出），清空 waiter</span><br>             removeWaiter(q);<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>         &#125;<br><br>         <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>         <span class="hljs-comment">// 进入终态，返回 s</span><br>         <span class="hljs-keyword">if</span> (s &gt; COMPLETING) &#123;<br>             <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>)<br>                 <span class="hljs-comment">// 清空等待栈的线程，waitnode 可以功成身退了，但只清空当前的 q 的 thread，并不做完整的 removeWaiter</span><br>                 q.thread = <span class="hljs-literal">null</span>;<br>             <span class="hljs-keyword">return</span> s;<br>         &#125;<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == COMPLETING) <span class="hljs-comment">// cannot time out yet</span><br>             <span class="hljs-comment">// no-op</span><br>             Thread.<span class="hljs-keyword">yield</span>();<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)<br>             <span class="hljs-comment">// 这里生成了一个 waitnode，注意，这里的调用栈是等待线程 get -&gt; awaitDone()，所以此处会捕获get 线程进 waitnode 里，在本循环里产生了第一个 q 的节点。</span><br>             q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();<br>             <span class="hljs-comment">// 一般第一轮循环q 总是为 null 的，只有第二轮进入这个地方的，才会进入这个分支，而且这里可能会失败，如果失败也，这时候就会把</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)<br>             <span class="hljs-comment">// 如果 q 不为空，且没有入队，则首先把当前的 waiters 放到当前的 q.next 里，然后把 q 放到本类型的 waiters 里（用新 q 代替老 waiter）</span><br>             queued = UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                                                  q.next = waiters, q);<br>         <span class="hljs-comment">// 前面两轮循环都走过了（前面两轮必须使 q 不为空，queued变成 true，才进入接下来的循环），接下来就进入 park 或者 parkNanos，看看会不会再被唤醒了</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;<br>             nanos = deadline - System.nanoTime();<br>             <span class="hljs-comment">// 如果超时了（bu），清空 waiter</span><br>             <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                 removeWaiter(q);<br>                 <span class="hljs-keyword">return</span> state;<br>             &#125;<br>             <span class="hljs-comment">// 如果没有超时，本线程先驻留一下，驻留完进入下一个循环</span><br>             LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>         &#125;<br>         <span class="hljs-keyword">else</span><br>             <span class="hljs-comment">// 否则，无限驻留，直到下一个循环。下一个循环必须由 finishCompletion 里的 LockSupport.unpark(t); 触发</span><br>             LockSupport.park(<span class="hljs-built_in">this</span>);<br>     &#125;<br> &#125;<br> <br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Simple linked list nodes to record waiting threads in a Treiber</span><br><span class="hljs-comment">  * stack.  See other classes such as Phaser and SynchronousQueue</span><br><span class="hljs-comment">  * for more detailed explanation.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span> &#123;<br>     <span class="hljs-keyword">volatile</span> Thread thread;<br>     <span class="hljs-keyword">volatile</span> WaitNode next;<br>     WaitNode() &#123; thread = Thread.currentThread(); &#125;<br> &#125;<br> <br> <span class="hljs-comment">// 解掉链表，help gc</span><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Tries to unlink a timed-out or interrupted wait node to avoid</span><br><span class="hljs-comment">  * accumulating garbage.  Internal nodes are simply unspliced</span><br><span class="hljs-comment">  * without CAS since it is harmless if they are traversed anyway</span><br><span class="hljs-comment">  * by releasers.  To avoid effects of unsplicing from already</span><br><span class="hljs-comment">  * removed nodes, the list is retraversed in case of an apparent</span><br><span class="hljs-comment">  * race.  This is slow when there are a lot of nodes, but we don&#x27;t</span><br><span class="hljs-comment">  * expect lists to be long enough to outweigh higher-overhead</span><br><span class="hljs-comment">  * schemes.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeWaiter</span><span class="hljs-params">(WaitNode node)</span> &#123;<br>     <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>         node.thread = <span class="hljs-literal">null</span>;<br>         retry:<br>         <span class="hljs-keyword">for</span> (;;) &#123;          <span class="hljs-comment">// restart on removeWaiter race</span><br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">WaitNode</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, q = waiters, s; q != <span class="hljs-literal">null</span>; q = s) &#123;<br>                 s = q.next;<br>                 <span class="hljs-keyword">if</span> (q.thread != <span class="hljs-literal">null</span>)<br>                     pred = q;<br>                 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>                     pred.next = s;<br>                     <span class="hljs-keyword">if</span> (pred.thread == <span class="hljs-literal">null</span>) <span class="hljs-comment">// check for race</span><br>                         <span class="hljs-keyword">continue</span> retry;<br>                 &#125;<br>                 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                                                       q, s))<br>                     <span class="hljs-keyword">continue</span> retry;<br>             &#125;<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>然后就把outcome 通过 report 传出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里使用 object 转 v，必然带来 warning</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;<br>    <span class="hljs-keyword">if</span> (s == NORMAL)<br>        <span class="hljs-keyword">return</span> (V)x;<br>    <span class="hljs-keyword">if</span> (s &gt;= CANCELLED)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<br>    <span class="hljs-comment">// 我们在外部 get catch 的异常就是从这里抛出的。注意这个转型的用意，get 只有一个固定的执行异常，就是这个异常，表明错误来自计算过程内部</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable)x);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="任务执行">任务执行</h4>
<h5 id="提交任务调度">提交任务调度</h5>
<ol>
<li>首先检测线程池运行状态，如果不是 RUNNING，则直接拒绝，线程池要保证在 RUNNING 的状态下执行任务。</li>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p><img src="%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png" alt="任务调度流程.png"></p>
<h5 id="任务缓冲">任务缓冲</h5>
<p>任务缓冲模块是线程池能够管理任务的核心部分。<strong>线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦</strong>，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是**（阻塞的本质即为此）：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。**阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="阻塞队列的工作原理.png"></p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ArrayBlockingQueue</td>
<td style="text-align:center">一个用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序。<strong>支持公平锁和非公平锁</strong>。</td>
</tr>
<tr>
<td style="text-align:center">DelayQueue</td>
<td style="text-align:center">一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。</td>
</tr>
<tr>
<td style="text-align:center">LinkedBlockingDeque</td>
<td style="text-align:center">一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，<strong>可以将锁的竞争最多降到一半</strong>。</td>
</tr>
<tr>
<td style="text-align:center">LinkedBlockingQueue</td>
<td style="text-align:center">一个由链表结构组成的有界队列，此队列按照先进先出(FIFO)的原则对元素进行排序。此队列的默认长度为Integer.MAX_VALUE，<strong>所以默认创建的该队列有容量危险</strong>。</td>
</tr>
<tr>
<td style="text-align:center">LinkedTransferQueue</td>
<td style="text-align:center">一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</td>
</tr>
<tr>
<td style="text-align:center">PriorityBlockingQueue</td>
<td style="text-align:center">一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</td>
</tr>
<tr>
<td style="text-align:center">SynchronousQueue</td>
<td style="text-align:center">一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，<strong>线程空闲了60秒后会被回收</strong>。</td>
</tr>
</tbody>
</table>
<h5 id="任务申请">任务申请</h5>
<blockquote>
<p>任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
</blockquote>
<p>任务的执行主要有 submit-&gt;execute，submit 的主要逻辑是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>execute 的主要逻辑是：</p>
<p><img src="Worker%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.png" alt="Worker执行任务.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法体现了线程池的任务调度策略的顶层设计：先 core 后 queue 后非 core 的设计思路。不过，这里面的 queue 的使用方案需要考虑线程池的状态。</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Executes the given task sometime in the future.  The task</span><br><span class="hljs-comment"> * may execute in a new thread or in an existing pooled thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If the task cannot be submitted for execution, either because this</span><br><span class="hljs-comment"> * executor has been shutdown or because its capacity has been reached,</span><br><span class="hljs-comment"> * the task is handled by the current &#123;<span class="hljs-doctag">@code</span> RejectedExecutionHandler&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> command the task to execute</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException at discretion of</span><br><span class="hljs-comment"> *         &#123;<span class="hljs-doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span><br><span class="hljs-comment"> *         cannot be accepted for execution</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if &#123;<span class="hljs-doctag">@code</span> command&#125; is null</span><br><span class="hljs-comment"> */</span><br>execute(Runnable command) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * execute 本身也是一个经典的四步分发，线程管理就靠这一步了</span><br><span class="hljs-comment">     * Proceed in 3 steps:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="hljs-comment">     * start a new thread with the given command as its first</span><br><span class="hljs-comment">     * task.  The call to addWorker atomically checks runState and</span><br><span class="hljs-comment">     * workerCount, and so prevents false alarms that would add</span><br><span class="hljs-comment">     * threads when it shouldn&#x27;t, by returning false.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. If a task can be successfully queued, then we still need</span><br><span class="hljs-comment">     * to double-check whether we should have added a thread</span><br><span class="hljs-comment">     * (because existing ones died since last checking) or that</span><br><span class="hljs-comment">     * the pool shut down since entry into this method. So we</span><br><span class="hljs-comment">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="hljs-comment">     * stopped, or start a new thread if there are none.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="hljs-comment">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="hljs-comment">     * and so reject the task.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这需要用到<a href="#%E5%B0%9D%E8%AF%95%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B">尝试增加线程</a></p>
<h3 id="线程池如何管理线程">线程池如何管理线程</h3>
<p>核心线程的 idle 不影响核心线程的创建；非核心线程的 idle time 会导致它们退出。</p>
<h4 id="尝试增加线程">尝试增加线程</h4>
<p>注意 addWorker 只是 execute 的一个子分支而已。</p>
<p><img src="%E7%94%B3%E8%AF%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="申请线程执行流程图.png"></p>
<p>Worker 可以被认为是线程和锁的结合体，它的使命就是不断地把 runnable 从缓冲队列里拿出来，放在自己的 thread 里执行，其中关键的方法是 addWorker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Checks if a new worker can be added with respect to current</span><br><span class="hljs-comment"> * pool state and the given bound (either core or maximum). If so,</span><br><span class="hljs-comment"> * the worker count is adjusted accordingly, and, if possible, a</span><br><span class="hljs-comment"> * new worker is created and started, running firstTask as its</span><br><span class="hljs-comment"> * first task. This method returns false if the pool is stopped or</span><br><span class="hljs-comment"> * eligible to shut down. It also returns false if the thread</span><br><span class="hljs-comment"> * factory fails to create a thread when asked.  If the thread</span><br><span class="hljs-comment"> * creation fails, either due to the thread factory returning</span><br><span class="hljs-comment"> * null, or due to an exception (typically OutOfMemoryError in</span><br><span class="hljs-comment"> * Thread.start()), we roll back cleanly.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> firstTask the task the new thread should run first (or</span><br><span class="hljs-comment"> * null if none). Workers are created with an initial first task</span><br><span class="hljs-comment"> * (in method execute()) to bypass queuing when there are fewer</span><br><span class="hljs-comment"> * than corePoolSize threads (in which case we always start one),</span><br><span class="hljs-comment"> * or when the queue is full (in which case we must bypass queue).</span><br><span class="hljs-comment"> * Initially idle threads are usually created via</span><br><span class="hljs-comment"> * prestartCoreThread or to replace other dying workers.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> core if true use corePoolSize as bound, else</span><br><span class="hljs-comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span><br><span class="hljs-comment"> * value to ensure reads of fresh values after checking other pool</span><br><span class="hljs-comment"> * state).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true if successful</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    <span class="hljs-comment">// retry 是外部自旋的标签。大自旋保证 rs 是稳定的，小自旋保证 wc 是稳定的，在双自旋里面保证 wc 的修改成功</span><br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 获取运行时状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>        <br>        <span class="hljs-comment">// 如果线程池关闭了，或者不是worker 的 firstTask 为空，但 workQueue 不空</span><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 内层自旋</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">// 其实 worker 里并没有 core 与否的属性，core 主要看比对哪个 PoolSize</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 如果这次一个原子性地增加 WorkerCount 成功，则退出大自旋；否则还是在大自旋里做 cas 增加 workerCount</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">// 否则失败有两种可能：rc 变了，或者 wc 变了。看看当前 runState 是否还是大自旋的 runState</span><br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-comment">// 如果不是则返回大自旋</span><br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// 如果是则 runState 不变，只是 wc 变了，在小自旋里重新获取 wc 即可</span><br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 在上层的 ctl 的修改是通过自旋来做的，不加锁，但下层就必须加锁了。这个设计实际上让 ctl 的修改和 worker 的修改解耦，实现了某种“最终一致”</span><br>    <br>    <span class="hljs-comment">// worker 的创建和添加是两个状态</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 外部传进来的 firstTask 可能为空，这里照样传进去</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-comment">// 在 Worker 构造器的内部携带的线程工厂创建的 thread 也可能为空</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 凡是修改线程池的 bookkeeping 操作，包含状态之外（比如 worker）的成员复杂流程修改的时候，都需要加锁</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-comment">// Tests if this thread is alive. A thread is alive if it has been started and has not yet died.</span><br>                    <span class="hljs-comment">// 这个方法本身是为了启动新线程，如果线程工厂不是启动新线程而是像线程池一样复用线程的话，线程就是 alive 的了（注意这个状态和线程的 status 还不一样），这时候线程池 addWorker 会失败</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable                   </span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-comment">// 更新簿记值</span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">// 此时才开始线程</span><br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rolls back the worker thread creation.</span><br><span class="hljs-comment"> * - removes worker from workers, if present</span><br><span class="hljs-comment"> * - decrements worker count</span><br><span class="hljs-comment"> * - rechecks for termination, in case the existence of this</span><br><span class="hljs-comment"> *   worker was holding up termination</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)<br>            workers.remove(w);<br>        decrementWorkerCount();<br>        <span class="hljs-comment">// 增加线程失败，会导致线程池终结</span><br>        tryTerminate();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Decrements the workerCount field of ctl. This is called only on</span><br><span class="hljs-comment"> * abrupt termination of a thread (see processWorkerExit). Other</span><br><span class="hljs-comment"> * decrements are performed within getTask.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrementWorkerCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 减 worker count 的操作必须自旋到成功，这种小成员的自旋修改不需要 sleep！</span><br>    <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndIncrementWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect)</span> &#123;<br>    <span class="hljs-comment">// 因为 wc 在 32 位整数的低位，所以直接对 expect + 1 即可。</span><br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="线程执行">线程执行</h4>
<p><img src="%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png" alt="执行任务流程.png"></p>
<p>线程的执行强依赖于 worker 本身的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// worker 本身并不严重依赖自己的状态，所以不像线程池一样拥有一个 runState，但它持有一个 state，能够表达自身的锁状态。所以它自身拥有 -1、0、1 三种状态</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Class Worker mainly maintains interrupt control state for</span><br><span class="hljs-comment"> * threads running tasks, along with other minor bookkeeping.</span><br><span class="hljs-comment"> * This class opportunistically extends AbstractQueuedSynchronizer</span><br><span class="hljs-comment"> * to simplify acquiring and releasing a lock surrounding each</span><br><span class="hljs-comment"> * task execution.  This protects against interrupts that are</span><br><span class="hljs-comment"> * intended to wake up a worker thread waiting for a task from</span><br><span class="hljs-comment"> * instead interrupting a task being run.  We implement a simple</span><br><span class="hljs-comment"> * non-reentrant mutual exclusion lock rather than use</span><br><span class="hljs-comment"> * ReentrantLock because we do not want worker tasks to be able to</span><br><span class="hljs-comment"> * reacquire the lock when they invoke pool control methods like</span><br><span class="hljs-comment"> * setCorePoolSize.  Additionally, to suppress interrupts until</span><br><span class="hljs-comment"> * the thread actually starts running tasks, we initialize lock</span><br><span class="hljs-comment"> * state to a negative value, and clear it upon start (in</span><br><span class="hljs-comment"> * runWorker).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><br>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This class will never be serialized, but we provide a</span><br><span class="hljs-comment">     * serialVersionUID to suppress a javac warning.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6138294804551838833L</span>;<br><br>    <span class="hljs-comment">/** Thread this worker is running in.  Null if factory fails. */</span><br>    <span class="hljs-keyword">final</span> Thread thread;<br>    <span class="hljs-comment">/** Initial task to run.  Possibly null. */</span><br>    Runnable firstTask;<br>    <span class="hljs-comment">/** Per-thread task counter */</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates with given first task and thread from ThreadFactory.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> firstTask the first task (null if none)</span><br><span class="hljs-comment">     */</span><br>    Worker(Runnable firstTask) &#123;<br>        <span class="hljs-comment">// inhibit == prohibit，就是禁止中断的意思，中断前也要求锁</span><br>        setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>        <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>        <span class="hljs-comment">// 这个方法是调用的线程池的 factory，</span><br>        <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/** Delegates main run loop to outer runWorker  */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这个方法是线程池里的方法，这样交互委托可以实现上下文的 merge，以当前的线程去读外部的上下文</span><br>        runWorker(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Lock methods</span><br>    <span class="hljs-comment">// 0 代表常态无锁</span><br>    <span class="hljs-comment">// 1 代表常态加锁</span><br>    <span class="hljs-comment">// The value 0 represents the unlocked state.</span><br>    <span class="hljs-comment">// The value 1 represents the locked state.</span><br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 启动的时候使用的-1 是一种“启动时才能使用的锁”，这里也包含进来了</span><br>        <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// aqs 最关键的加锁方法，锁的标记位可以自定义</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        <span class="hljs-comment">// 这里体现了经典的设计模式，先 cas 把标记位加上去，然后绑定线程。这里要求线程安全的写只有锁的 cas，线程的归属却不是线程安全的</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        <span class="hljs-comment">// 恰好和上一个方法反过来</span><br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 强制解锁，无 cas</span><br>        setState(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>        &#123; acquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>      &#123; release(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-comment">// 锁只支持互斥锁定模式，不支持共享锁定模式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br>    <br>    <span class="hljs-comment">// 提供一种中断 worker（包括内部线程）的工作模式</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;<br>        Thread t;<br>        <span class="hljs-comment">// -1 和 1 不允许中断</span><br>        <span class="hljs-comment">// 在一个括号里实现了漂亮的取数操作</span><br>        <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp;<br>        <span class="hljs-comment">// 线程没有被中断的时候可以被中断</span><br>        !t.isInterrupted()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.interrupt();<br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在一个工作线程里，worker delegate 调用给线程池的 runWorker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Main worker run loop.  Repeatedly gets tasks from queue and</span><br><span class="hljs-comment"> * executes them, while coping with a number of issues:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1. We may start out with an initial task, in which case we</span><br><span class="hljs-comment"> * don&#x27;t need to get the first one. Otherwise, as long as pool is</span><br><span class="hljs-comment"> * running, we get tasks from getTask. If it returns null then the</span><br><span class="hljs-comment"> * worker exits due to changed pool state or configuration</span><br><span class="hljs-comment"> * parameters.  Other exits result from exception throws in</span><br><span class="hljs-comment"> * external code, in which case completedAbruptly holds, which</span><br><span class="hljs-comment"> * usually leads processWorkerExit to replace this thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. Before running any task, the lock is acquired to prevent</span><br><span class="hljs-comment"> * other pool interrupts while the task is executing, and then we</span><br><span class="hljs-comment"> * ensure that unless pool is stopping, this thread does not have</span><br><span class="hljs-comment"> * its interrupt set.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. Each task run is preceded by a call to beforeExecute, which</span><br><span class="hljs-comment"> * might throw an exception, in which case we cause thread to die</span><br><span class="hljs-comment"> * (breaking loop with completedAbruptly true) without processing</span><br><span class="hljs-comment"> * the task.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. Assuming beforeExecute completes normally, we run the task,</span><br><span class="hljs-comment"> * gathering any of its thrown exceptions to send to afterExecute.</span><br><span class="hljs-comment"> * We separately handle RuntimeException, Error (both of which the</span><br><span class="hljs-comment"> * specs guarantee that we trap) and arbitrary Throwables.</span><br><span class="hljs-comment"> * Because we cannot rethrow Throwables within Runnable.run, we</span><br><span class="hljs-comment"> * wrap them within Errors on the way out (to the thread&#x27;s</span><br><span class="hljs-comment"> * UncaughtExceptionHandler).  Any thrown exception also</span><br><span class="hljs-comment"> * conservatively causes thread to die.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. After task.run completes, we call afterExecute, which may</span><br><span class="hljs-comment"> * also throw an exception, which will also cause thread to</span><br><span class="hljs-comment"> * die. According to JLS Sec 14.20, this exception is the one that</span><br><span class="hljs-comment"> * will be in effect even if task.run throws.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The net effect of the exception mechanics is that afterExecute</span><br><span class="hljs-comment"> * and the thread&#x27;s UncaughtExceptionHandler have as accurate</span><br><span class="hljs-comment"> * information as we can provide about any problems encountered by</span><br><span class="hljs-comment"> * user code.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-comment">// 这里为什么不使用 worker 里面的线程呢？</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 做一个置换/置空操作</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 在对象初始化的时候触发了加锁，在线程启动的时候触发了解锁。线程池的 shutdown 方法本身会 interrupt worker，这里不允许在锁周期里面 interrupt worker</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-comment">// 突然完成默认为真</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// getTask 里封装了复杂的取任务流程，这里在一个表达式里面实现了漂亮的取任务操作</span><br>        <span class="hljs-comment">// 本线程只有在 getTask 取不到的时候才退出</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 只在 run 一个 task 的时候锁定自己一次，不可重入</span><br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-comment">// 如果线程池本身已经进入停止及以后状态，则直接求 工作线程的中断状态。否则，做一轮线程的中断，再求线程池状态（中断居然会影响线程池的状态，很奇怪？），再求工作线程的中断状态。这里有一个比较炫技的地方，wt 和 currentThread 都是当前线程，但偏偏不使用 wt 里的线程        </span><br>            <span class="hljs-comment">// 这里的思想是：不能由命令触发中断，必须由状态触发中断</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                <span class="hljs-comment">// 或者</span><br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                <span class="hljs-comment">// 遇到这些情况，就要中断 wt，在这里。所以内部线程是由 getTask 内部的流程中断的，然后才去执行下面的 run，看看下面的 run 会不会响应</span><br>                wt.interrupt();<br>            <span class="hljs-comment">// 线程的中断也不会影响接下来的 task.run()</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通常这个方法是空方法</span><br>                beforeExecute(wt, task);<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// runnable.run()</span><br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    <span class="hljs-comment">// 有这样的写法就意味着要在 finally 留存 thrown</span><br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// thrown 是给 afterExecute 准备的</span><br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 只有在 getTask 取不到的时候退出，这个值才是false，其他时候都算是“突然退出”</span><br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 阻塞式获取任务。</span><br><span class="hljs-comment">// 遇到异常情况给上游的返回值是 null：</span><br><span class="hljs-comment">// 1. 有超过maximumPoolSize 的线程数，这时候返回 null 会导致它退出。</span><br><span class="hljs-comment">// 2. 线程池 stopped 了（由 shutdownNow 来触发，比 shutdown 更严厉），这时候线程池也会用 null 的方式指示线程有序退出</span><br><span class="hljs-comment">// 3. 线程池 shutdown，且队列为空（其实光是本条件就可以返回 null，只是如果线程池还在工作中，队列应该让 getTask 的线程阻塞等待）</span><br><span class="hljs-comment">// 4. 线程超时。真正的超时实际上有两种：线程数超过 core 且超时，连 core 都允许超时且超时</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs blocking or timed wait for a task, depending on</span><br><span class="hljs-comment"> * current configuration settings, or returns null if this worker</span><br><span class="hljs-comment"> * must exit because of any of:</span><br><span class="hljs-comment"> * 1. There are more than maximumPoolSize workers (due to</span><br><span class="hljs-comment"> *    a call to setMaximumPoolSize).</span><br><span class="hljs-comment"> * 2. The pool is stopped.</span><br><span class="hljs-comment"> * 3. The pool is shutdown and the queue is empty.</span><br><span class="hljs-comment"> * 4. This worker timed out waiting for a task, and timed-out</span><br><span class="hljs-comment"> *    workers are subject to termination (that is,</span><br><span class="hljs-comment"> *    &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span><br><span class="hljs-comment"> *    both before and after the timed wait, and if the queue is</span><br><span class="hljs-comment"> *    non-empty, this worker is not the last thread in the pool.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> task, or null if the worker must exit, in which case</span><br><span class="hljs-comment"> *         workerCount is decremented</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-comment">// 在自旋里面</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>        <br>        <span class="hljs-comment">// 第一类情况返回 null</span><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling? 是否要强制减少线程数？是的话就要引入计时了</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>        <span class="hljs-comment">// 超时返回 null 的场景，但注意这里要能减掉一个线程才能返回 null。</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-comment">// 减线程数目（不一定成功，如 wc == 0 也可能进入这个语句块）</span><br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 不能减线程则 cas 失败，进入大循环里继续</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="回收线程">回收线程</h4>
<blockquote>
<p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反映线程现在的执行状态。</p>
<p>1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。<br>
2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p>
</blockquote>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="线程池回收线程的过程.png"><br>
<img src="%E7%BA%BF%E7%A8%8B%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B.png" alt="线程销毁流程.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">// 处理一些关闭和簿记工作：</span><br>   <span class="hljs-comment">// 1. 只能被从 worker 线程里调用，也就是说只能在 runWorker 方法里被调用</span><br>   <span class="hljs-comment">// 2. 先尝试把 workerCount 减一</span><br>   <span class="hljs-comment">// 3. 把 worker 从工作集里移除</span><br>   <span class="hljs-comment">// 4. 尝试终结线程池</span><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Performs cleanup and bookkeeping for a dying worker. Called</span><br><span class="hljs-comment">    * only from worker threads. Unless completedAbruptly is set,</span><br><span class="hljs-comment">    * assumes that workerCount has already been adjusted to account</span><br><span class="hljs-comment">    * for exit.  This method removes thread from worker set, and</span><br><span class="hljs-comment">    * possibly terminates the pool or replaces the worker if either</span><br><span class="hljs-comment">    * it exited due to user task exception or if fewer than</span><br><span class="hljs-comment">    * corePoolSize workers are running or queue is non-empty but</span><br><span class="hljs-comment">    * there are no workers.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> completedAbruptly if the worker died due to user exception</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;<br>       <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>           <span class="hljs-comment">// 只要能够成功减一就行了</span><br>           decrementWorkerCount();<br>       <br>       <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>       mainLock.lock();<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 不管怎样退出，都把 worker 的完成任务数加总到线程池的总数里</span><br>           completedTaskCount += w.completedTasks;<br>           <span class="hljs-comment">// 移除本 worker</span><br>           workers.remove(w);<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           mainLock.unlock();<br>       &#125;<br>       <span class="hljs-comment">// 每个 worker 终结都尝试终结线程池</span><br>       tryTerminate(); <br><br>       <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>       <span class="hljs-comment">// 如果线程池没有真的被真的关闭，可以加减线程池里的线程</span><br>       <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>           <span class="hljs-comment">// 如果线程池正常关闭</span><br>           <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>               <span class="hljs-comment">// allowCoreThreadTimeOut 通常为 false，所以线程池的最小值应该是 corePoolSize，否则核心线程数可以归零</span><br>               <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>               <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                   <span class="hljs-comment">// 如果缓冲队列不空，则最小线程数需要维持在 1</span><br>                   min = <span class="hljs-number">1</span>;<br>               <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                   <span class="hljs-comment">// 如果当前工作线程数大于等于 min，则直接退出</span><br>                   <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>           &#125;<br>           <span class="hljs-comment">// 反之则认为工作线程数小于 min，需要增加非核心线程（增加非核心线程实际上也是在增加核心线程），这里的设计思想是任何一个线程退出都应该增加一个线程，所以就当作非核心线程增加了</span><br>           addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>       &#125;<br>   &#125;<br>   <br>   <span class="hljs-comment">// 这个方法在线程退出时只关闭一个【空闲线程】，但在线程池关闭等场景下，会关闭所有的空闲线程，这样线程池最终就关闭了-因为每个worker 退出的时候最少都会关闭一个空闲线程，全局的线程最终得以全部关闭。但线程池的核心参数如 keepAliveTime、corePoolSize、maximumPoolSize 有变化的时候，都会触发全部空闲线程关闭</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Interrupts threads that might be waiting for tasks (as</span><br><span class="hljs-comment">    * indicated by not being locked) so they can check for</span><br><span class="hljs-comment">    * termination or configuration changes. Ignores</span><br><span class="hljs-comment">    * SecurityExceptions (in which case some threads may remain</span><br><span class="hljs-comment">    * uninterrupted).</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> onlyOne If true, interrupt at most one worker. This is</span><br><span class="hljs-comment">    * called only from tryTerminate when termination is otherwise</span><br><span class="hljs-comment">    * enabled but there are still other workers.  In this case, at</span><br><span class="hljs-comment">    * most one waiting worker is interrupted to propagate shutdown</span><br><span class="hljs-comment">    * signals in case all threads are currently waiting.</span><br><span class="hljs-comment">    * Interrupting any arbitrary thread ensures that newly arriving</span><br><span class="hljs-comment">    * workers since shutdown began will also eventually exit.</span><br><span class="hljs-comment">    * To guarantee eventual termination, it suffices to always</span><br><span class="hljs-comment">    * interrupt only one idle worker, but shutdown() interrupts all</span><br><span class="hljs-comment">    * idle workers so that redundant workers exit promptly, not</span><br><span class="hljs-comment">    * waiting for a straggler task to finish.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>       mainLock.lock();<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>               <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>               <span class="hljs-comment">// 能够被关闭的线程是一个能够拿到内部锁的线程</span><br>               <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                   <span class="hljs-keyword">try</span> &#123;<br>                       <span class="hljs-comment">// 中断，这个线程内部的工作线程能不能响应看 runnable 内部的实现了</span><br>                       t.interrupt();<br>                   &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                   &#125; <span class="hljs-keyword">finally</span> &#123;<br>                       w.unlock();<br>                   &#125;<br>               &#125;<br>               <span class="hljs-keyword">if</span> (onlyOne)<br>                   <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           mainLock.unlock();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h3 id="线程池使用中可能遇到的问题">线程池使用中可能遇到的问题</h3>
<p>线程池的调参有几个难点：</p>
<ol>
<li>如果核心线程数过小，则吞吐可能不够，遇到流量矛刺可能导致 RejectExecutionException；但值得警惕的是，如果核心线程数很大，可能导致频繁的上下文切换和过多的资源消耗（不管是 cpu 时间片还是操作系统的内核线程）。</li>
<li>如果队列过长，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。</li>
</ol>
<p>那么，如何计算这些参数呢？<br>
有一个基本的原则是：</p>
<ol>
<li>计算密集型的线程数本身应该尽量贴进 cpu 核数。</li>
<li>io 密集型的线程数要注意伸缩，要配合阻塞队列使用，要有承受拒绝失败的的准备。</li>
</ol>
<p>我们常见的计算方式主要来自于《Java并发编程实战》：</p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="线程池计算公式.png"></p>
<p>现实中可选的线程数计算公式最好是取一个并发 qps 数和 cpu 数的折中。通常可以认为 单任务的 rt/1ms 可以得到单一线程的吞吐数，qps 除以吞吐数可以得到 qps 相应的线程数，但这个方案没有考虑cpu 核数和上下文切换的问题。所以这样算出来的线程数的实际 qps 表现应该低于理论 qps，但可以通过估算和压测不断让理论值逼近实际值。</p>
<h3 id="线程池的可替换方案">线程池的可替换方案</h3>
<p>其他可替代方案，都不如线程池的调优方案成熟（<strong>在可以使用新技术的前提下，我们是否还有调优旧方案的魄力呢？</strong>）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">优势</th>
<th style="text-align:center">劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Disruptor框架</td>
<td style="text-align:center">线程池内部是通过一个工作队列去维护任务的执行的，它有一个根本性的缺陷：连续争用问题。也就是多个线程在申请任务时，为了合理地分配任务要付出锁资源，对比快速的任务执行来说，这部分申请的损耗是巨大的。高性能进程间消息库LMAX使用了一个叫作环形缓冲的数据结构，用这种这个特殊的数据结构替代队列，将会避免申请任务时出现的连续争用状况。</td>
<td style="text-align:center">避免连续争用，性能更佳</td>
<td style="text-align:center">缺乏线程管理的能力，使用场景较少</td>
</tr>
<tr>
<td style="text-align:center">协程框架</td>
<td style="text-align:center">协程是一种用户态的轻量级线程，其拥有自己的寄存器上下文和栈，当调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。这种切换上下文的方式要小于线程的开销。在瓶颈侧重IO的情况，使用协程获得并发性要优于使用线程。</td>
<td style="text-align:center">侧重IO情况时，性能更佳。与多线程策略无冲突，可结合使用</td>
<td style="text-align:center">在Java中缺乏成熟的应用</td>
</tr>
<tr>
<td style="text-align:center">Actor框架</td>
<td style="text-align:center">Actor模型通过维护多个Actor去处理并发的任务，它放弃了直接使用线程去获取并发性，而是自己定义了一系列系统组件应该如何动作和交互的通用规则，不需要开发者直接使用线程。通过在原生的线程或协程的级别上做了更高层次的封装，只需要开发者关心每个Actor的逻辑即可实现并发操作。由于避免了直接使用锁，很大程度解决了传统并发编程模式下大量依赖悲观锁导致的资源竞争情况。</td>
<td style="text-align:center">无锁策略，性能更佳，避免直接使用线程，安全性更高</td>
<td style="text-align:center">在Java中缺乏成熟的应用，内部复杂，难以排查和调试</td>
</tr>
</tbody>
</table>
<p>缺乏管控能力就不适合调优。</p>
<h3 id="最终解决方案">最终解决方案</h3>
<p>通过监控线程池负载，制定告警策略：</p>
<ol>
<li>线程池活跃度 = activeCount/maximumPoolSize。看看这个值是不是趋近于 1。</li>
<li>监控队列的capacity 和 size 的比例。</li>
<li>监控 RejectExecutionException 的出现。</li>
</ol>
<p>加引入线程池动态管控能力，基于告警制定 sop，确定是否要动态调节线程数和拒绝策略。</p>
<p>如果还是解决不了问题，需要考虑全局动态扩容的方案。</p>
<p>这里的 activeCount 是每个 worker 是否互斥 held 的总数的统计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getActiveCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// workers 是一个 HashSet，它是非线程安全的。</span><br>getActiveCount 需要遍历这个集合，如果不加全局的 mainLock，在遍历过程中如果有线程销毁或创建，会抛出 ConcurrentModificationException 或者读到错误的数据。所以 mainLock 是为了保护 workers 集合的遍历安全。<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (Worker w : workers)<br>                <span class="hljs-comment">// 在 ThreadPoolExecutor 的设计中，Worker 只要开始执行任务（runWorker 方法中），就会把自己锁住（lock）。</span><br>                <span class="hljs-comment">// 当 Worker 没有任务做，正在 getTask() 方法里阻塞等待（即空闲状态）时，它是**不加锁（unlocked）**的。</span><br>               <span class="hljs-comment">// 所以，isLocked() == true 等价于 “这个线程正在干活”。</span><br>getActiveCount 的目的就是统计“当前有多少个线程正在干活”，所以必须统计被锁住的 Worker。<br>                <span class="hljs-keyword">if</span> (w.isLocked())<br>                    ++n;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里的 isLocked 意味着这个工作线程正在跑  task 的run，意味着可能是如下状态：RUNNABLE、BLOCKED、WAITING、TIMED_WAITING。</p>
<h2 id="线程组">线程组</h2>
<p>线程组提供一个“集合”，可以把一群线程归于一处，可以批量 interrupt/stop/suspend。<br>
但这个方案是很危险的，使用线程池和并发安全的 Collection 都可以管理好线程。</p>
<h3 id="原本设计目的">原本设计目的</h3>
<ul>
<li>资源管理：将相关线程组织在一起，便于批量操作</li>
<li>安全隔离：不同线程组可以有不同的安全策略</li>
<li>异常处理：提供组级别的未捕获异常处理</li>
<li>层次结构：支持线程组的嵌套（parent-child关系）</li>
</ul>
<h3 id="缺陷">缺陷</h3>
<ul>
<li>API设计不一致且不完整</li>
<li>线程安全问题</li>
<li>功能缺失</li>
<li>安全模型过时</li>
</ul>
<h3 id="替代方案">替代方案</h3>
<ul>
<li>Executor框架</li>
<li>CompletableFuture</li>
<li>ForkJoinPool</li>
</ul>
<h3 id="官方态度">官方态度</h3>
<ul>
<li>Java 17+：线程组API标记为<code>@Deprecated(forRemoval = true)</code></li>
<li>JEP 411：移除SecurityManager，线程组失去最后的存在意义</li>
<li>OpenJDK邮件列表：多次讨论完全移除线程组</li>
</ul>
<h2 id="completionstage">CompletionStage</h2>
<p>这是定义“可能是”异步计算的一个阶段，可能被其他阶段触发，也可以触发其他阶段。它是 CompletableFuture 的父接口。</p>
<p>它有一个特点，大量非 void 方法返回值都是 CompletionStage 类型，这样既允许 builder 模式，也允许各种 transformation 模式。</p>
<h2 id="completablefuture">CompletableFuture</h2>
<p>线程池的超时中断机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">invokeAll(tasks, <span class="hljs-number">300L</span>, TimeUnit.MILLISECONDS);<br></code></pre></td></tr></table></figure>
<p>会让这个类型中断提前返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">432369</span>-Caused by: java.lang.InterruptedException: <span class="hljs-literal">null</span><br><span class="hljs-number">432370</span>- at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:<span class="hljs-number">347</span>)<br><span class="hljs-number">432371</span>- at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:<span class="hljs-number">1915</span>)<br><span class="hljs-number">432372</span>- at org.apache.dubbo.rpc.AsyncRpcResult.get(AsyncRpcResult.java:<span class="hljs-number">196</span>)<br><span class="hljs-number">432373</span>- at org.apache.dubbo.rpc.protocol.AbstractInvoker.waitForResultIfSync(AbstractInvoker.java:<span class="hljs-number">266</span>)<br><span class="hljs-number">432374</span>- at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:<span class="hljs-number">186</span>)<br><span class="hljs-number">432375</span>- at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invokeWithContext(AbstractClusterInvoker.java:<span class="hljs-number">379</span>)<br><span class="hljs-number">432376</span>- at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:<span class="hljs-number">81</span>)<br></code></pre></td></tr></table></figure>
<h1>小技巧</h1>
<h2 id="如何处理任务超时问题">如何处理任务超时问题</h2>
<h3 id="方法1：使用-futuretask-的实现">方法1：使用 FutureTask 的实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">    Future&lt;Map&lt;String, Object&gt;&gt; future = executor.submit(() -&gt; getFeatures(context, zeusSceneId));<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 穷人版超时：最简单的超时不是使用 circuit breaker，而是使用 FutureTask 的缺省超时实现，这个方案取不到值的时候底层会返回 TimeoutException，只要捕获这个超时就可以走入 fallback 逻辑</span><br>                features.putAll(future.get(paramCollectTimeout, TimeUnit.MILLISECONDS));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;<br>                <span class="hljs-comment">// fallback logic</span><br>            &#125;<br>            <br>    <span class="hljs-comment">// 其中 FutureTask 的实现是：</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>        <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>        <span class="hljs-comment">// 等待结束后抛出异常而不是空指针，否则调用 report 方法</span><br>        <span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>            (s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>        <span class="hljs-keyword">return</span> report(s);<br>    &#125;<br>    <br><span class="hljs-comment">// 约等价于</span><br>其中超时底层的最简单实现是：<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br>    <br>    <span class="hljs-comment">// 循环等待，直到任务完成或超时</span><br>    <span class="hljs-keyword">while</span> (state &lt;= COMPLETING) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> deadline - System.nanoTime();<br>        <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0L</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();  <span class="hljs-comment">// 超时了</span><br>        &#125;<br>        LockSupport.parkNanos(<span class="hljs-built_in">this</span>, remaining);  <span class="hljs-comment">// 等待指定时间</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> report(state);  <span class="hljs-comment">// 返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法2：使用条件变量">方法2：使用条件变量</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发出调用</span><br>condition.await<br><span class="hljs-comment">// 非阻塞地调用 isDone 方法，抛出异常或取值</span><br><span class="hljs-comment">// 这是方法1 的泛化实现</span><br></code></pre></td></tr></table></figure>
<h3 id="方法3：使用-countdownlatch-cyclicbarrier">方法3：使用 countDownLatch/CyclicBarrier</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发出调用</span><br>无锁的 await<br><span class="hljs-comment">// 非阻塞地调用 isDone 方法，抛出异常或取值，但要注意其他线程对 done 状态的维护</span><br></code></pre></td></tr></table></figure>
<p>这个方法不需要依赖于 ReentrantLock，是通过纯 AQS 实现的，见 CountDownLatch 源码。</p>
<h2 id="自定义线程池实现自定义中断">自定义线程池实现自定义中断</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">待补充<br></code></pre></td></tr></table></figure>
<h1>Java 异步执行中的异常处理与线程生命周期</h1>
<h2 id="从-futuretask-asyncuncaughtexceptionhandler-到-uncaughtexceptionhandler">从 FutureTask、AsyncUncaughtExceptionHandler 到 UncaughtExceptionHandler</h2>
<p>在 Java 并发和 Spring 异步执行模型中，异常处理涉及多个抽象层级：<br>
JVM 线程模型、JDK 并发工具以及 Spring 框架本身。</p>
<p>这些层级各自对异常承担不同职责，但它们的行为经常被混淆，典型问题包括：</p>
<ul>
<li>异步任务抛出的异常为何没有日志</li>
<li><code>UncaughtExceptionHandler</code> 在线程池中为何不生效</li>
<li><code>AsyncUncaughtExceptionHandler</code> 是否会影响线程生命周期</li>
</ul>
<p>本文从<strong>线程是否终止</strong>这一确定性问题出发，系统梳理三种机制的边界与协作方式。</p>
<hr>
<h2 id="一-线程是否终止的唯一判定标准">一、线程是否终止的唯一判定标准</h2>
<p>在 JVM 层面，线程是否终止只取决于一个条件：</p>
<blockquote>
<p><strong>是否存在未被捕获、并逃逸出 <code>Thread.run()</code> 的 <code>Throwable</code></strong>。从这个 run 出去以后，就进入 jvm 的cpp 代码的接管范围</p>
</blockquote>
<p>这一规则与使用何种框架无关。</p>
<h3 id="1-1-会导致线程终止的情况">1.1 会导致线程终止的情况</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<ul>
<li>异常未被捕获</li>
<li>异常逃逸出 run()</li>
<li>JVM 调用 UncaughtExceptionHandler</li>
<li>线程终止</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<p>源码位置：<a target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/c55d012dd067/src/share/vm/runtime/thread.cpp#l1799">Thread 的实现</a><br>
还可以参考这个：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chuyouyinghe/article/details/134306409">《01.崩溃捕获设计实践方案 crash方案》</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">JavaThread::exit</span><span class="hljs-params">(<span class="hljs-type">bool</span> destroy_vm)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_pending_exception</span>()) &#123;<br>        <span class="hljs-function">Handle <span class="hljs-title">exception</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, pending_exception())</span></span>;<br>        <span class="hljs-built_in">clear_pending_exception</span>();<br>        <br>        <span class="hljs-comment">// 直接内联处理，无单独 uncaught_exception 方法</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">threadObj</span>() != <span class="hljs-literal">NULL</span>) &#123;<br>            Klass* klass = SystemDictionary::<span class="hljs-built_in">Thread_klass</span>();<br>            <span class="hljs-comment">// ... 通过 JNI 调用 Java 层 uncaughtException</span><br>            JavaCalls::<span class="hljs-built_in">call_virtual</span>(&amp;result, klass, <br>                                   vmSymbols::<span class="hljs-built_in">uncaughtException_name</span>(),<br>                                   vmSymbols::<span class="hljs-built_in">thread_throwable_void_signature</span>(),<br>                                   &amp;args, <span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant JVM as JVM(C++)
    participant JavaThread as JavaThread(C++)
    participant ThreadJava as java.lang.Thread
    
    JVM-&gt;&gt;JavaThread: 线程执行中抛出异常
    JavaThread-&gt;&gt;JavaThread: set_pending_exception(exception)
    JVM-&gt;&gt;JavaThread: 线程退出调用 exit()
    JavaThread-&gt;&gt;JavaThread: has_pending_exception()
    JavaThread-&gt;&gt;JavaThread: 直接在 exit() 中处理
    JavaThread-&gt;&gt;ThreadJava: JNI call_virtual(&quot;uncaughtException&quot;)
    ThreadJava-&gt;&gt;ThreadJava: 实际调用 java.lang.Thread.uncaughtException
    ThreadJava-&gt;&gt;ThreadJava: dispatchUncaughtException(e)
    ThreadJava-&gt;&gt;ThreadGroup: getUncaughtExceptionHandler()
    ThreadGroup-&gt;&gt;SystemErr: 默认处理</code></pre>
<h3 id="1-2-不会导致线程终止的情况">1.2 不会导致线程终止的情况</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// handled</span><br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<ul>
<li>异常被捕获</li>
<li>JVM 不介入</li>
<li>线程继续运行</li>
</ul>
<p>结论：</p>
<ul>
<li>异常是否被捕获，决定了线程是否终止；</li>
<li>异常由谁处理，并不决定线程生死。</li>
</ul>
<h2 id="二-futuretask-对异常传播路径的改变">二、FutureTask 对异常传播路径的改变</h2>
<p>理解线程池与 Spring 异步行为，必须先理解 FutureTask。</p>
<h3 id="2-1-execute-与-submit-的根本差异">2.1 execute 与 submit 的根本差异</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">executor.execute(runnable);<br>executor.submit(callable);<br></code></pre></td></tr></table></figure>
<p>差异不在返回值，而在执行结构：</p>
<ul>
<li><code>execute</code>：<code>Runnable</code>直接在线程中执行</li>
<li><code>submit</code>：任务先被包装为<code>FutureTask</code>，再执行</li>
</ul>
<h3 id="2-2-futuretask-中的异常拦截点">2.2 FutureTask 中的异常拦截点</h3>
<p>FutureTask.run() 的核心逻辑如下（简化）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        callable.call();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        setException(ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键点：</p>
<ul>
<li>Throwable 被主动捕获</li>
<li>异常不会逃逸出 run()</li>
<li>JVM 不认为线程发生未捕获异常<br>
线程不会终止</li>
</ul>
<p>异常在这里已经脱离“线程异常”的语义。</p>
<h3 id="2-3-异常如何被重新抛出：report">2.3 异常如何被重新抛出：report()</h3>
<p>异常并未消失，而是作为执行结果存储：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">outcome = ex;<br>state = EXCEPTIONAL;<br></code></pre></td></tr></table></figure>
<p>在调用<code>Future.get()</code>时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;<br>    <span class="hljs-keyword">if</span> (s == NORMAL)<br>        <span class="hljs-keyword">return</span> (V) x;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable) x);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>report()</code>的职责是：</p>
<ul>
<li>将“执行结果状态”翻译为 Java 异常语义</li>
<li>将原始异常包装为 ExecutionException</li>
</ul>
<p>结论：</p>
<blockquote>
<p>FutureTask 将异常从“线程控制流”转移为“任务结果数据”。</p>
</blockquote>
<h2 id="三-uncaughtexceptionhandler-的职责边界">三、UncaughtExceptionHandler 的职责边界</h2>
<h3 id="3-1-触发条件">3.1 触发条件</h3>
<p><code>UncaughtExceptionHandler</code>仅在以下条件满足时被调用：</p>
<ul>
<li>异常未被捕获</li>
<li>异常逃逸出<code>Thread.run()</code></li>
<li>线程即将终止</li>
</ul>
<p>JVM 调用顺序为：</p>
<ol>
<li>Thread 自身的 handler</li>
<li>ThreadGroup</li>
<li>DefaultUncaughtExceptionHandler</li>
<li>JVM 默认 stderr</li>
</ol>
<h3 id="3-2-能力与限制">3.2 能力与限制</h3>
<p><code>UncaughtExceptionHandler</code>：</p>
<ul>
<li>无法阻止线程终止</li>
<li>无法恢复线程执行</li>
<li>仅用于日志、告警等系统级兜底</li>
</ul>
<p>在线程池中，只有 <code>execute()</code>且异常未被捕获时，才可能触发该 handler。</p>
<h2 id="四-spring-asyncuncaughtexceptionhandler-的作用范围">四、Spring AsyncUncaughtExceptionHandler 的作用范围</h2>
<h3 id="4-1-适用条件">4.1 适用条件</h3>
<p>Spring 明确限定：</p>
<ul>
<li>仅处理 @Async 标注的 void 方法</li>
<li>不处理返回 Future / CompletableFuture 的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Async</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-2-spring-的异常拦截方式">4.2 Spring 的异常拦截方式</h3>
<p>Spring 在异步调用边界处捕获异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    invokeMethod();<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>    asyncUncaughtExceptionHandler.handle(ex, method, params);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-3-对线程生命周期的影响">4.3 对线程生命周期的影响</h3>
<p><code>AsyncUncaughtExceptionHandler</code>：</p>
<ul>
<li>不会阻止线程终止</li>
<li>也不会导致线程终止</li>
</ul>
<p>原因是：</p>
<ul>
<li>异常已经被 Spring 捕获</li>
<li>JVM 无法感知未捕获异常</li>
<li>线程本身没有死亡条件</li>
</ul>
<p>结论：</p>
<ul>
<li>AsyncUncaughtExceptionHandler 只影响异常的业务处理路径，不影响线程生命周期。</li>
</ul>
<h2 id="五-三种异常路径的对比">五、三种异常路径的对比</h2>
<h3 id="5-1-async-void-方法">5.1 @Async void 方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Async</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">方法执行<br> → Spring 捕获<br> → AsyncUncaughtExceptionHandler<br> → 线程继续运行<br></code></pre></td></tr></table></figure>
<h3 id="5-2-线程池execute">5.2 线程池<code>execute</code></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">executor.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable.run<br> → 异常逃逸<br> → JVM<br> → UncaughtExceptionHandler<br> → 线程终止<br></code></pre></td></tr></table></figure>
<h3 id="5-3-线程池-submit">5.3 线程池 submit</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;?&gt; future = executor.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask.run<br> → <span class="hljs-keyword">catch</span> Throwable<br> → 异常存入 Future<br> → get() 时抛 ExecutionException<br></code></pre></td></tr></table></figure>
<h2 id="六-两种-handler-的推荐使用方式">六、两种 Handler 的推荐使用方式</h2>
<h3 id="6-1-asyncuncaughtexceptionhandler-业务层">6.1 AsyncUncaughtExceptionHandler（业务层）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AsyncConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> AsyncUncaughtExceptionHandler <span class="hljs-title function_">getAsyncUncaughtExceptionHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (ex, method, params) -&gt; &#123;<br>            log.error(<span class="hljs-string">&quot;Async void method failed: &#123;&#125;&quot;</span>, method.getName(), ex);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li>@Async void 方法</li>
<li>业务补偿、告警、日志</li>
</ul>
<h3 id="6-2-uncaughtexceptionhandler-系统层">6.2 UncaughtExceptionHandler（系统层）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> r -&gt; &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>    t.setUncaughtExceptionHandler((thread, ex) -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Thread &#123;&#125; terminated&quot;</span>, thread.getName(), ex);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;;<br><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(),<br>    factory<br>);<br></code></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li><code>execute()</code>执行的任务</li>
<li>系统级兜底监控</li>
</ul>
<h3 id="6-3-有返回值的异步任务">6.3 有返回值的异步任务</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture<br>    .supplyAsync(<span class="hljs-built_in">this</span>::work, executor)<br>    .exceptionally(ex -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Async failed&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<p>必须显式消费异常，否则异常不会被观察到。</p>
<h2 id="结论">结论</h2>
<ol>
<li>线程是否终止，仅由异常是否逃逸到 JVM 决定</li>
<li>FutureTask 和 Spring 已在更高层捕获异常，因此不会触发 JVM 机制</li>
<li>AsyncUncaughtExceptionHandler 不控制线程生死，仅提供业务回调</li>
<li>UncaughtExceptionHandler 只用于处理线程终止前的系统级事件</li>
</ol>
<h1>Spring 的异步支持</h1>
<ul>
<li>如果只是<code>@EnableAsync</code>，Spring 会创建一个默认的 SimpleAsyncTaskExecutor（注意不是 ThreadPoolTaskExecutor）：
<ul>
<li><strong>每个任务都会创建新线程</strong></li>
<li>没有线程池复用</li>
<li>性能较差，不适合生产环境</li>
</ul>
</li>
<li>在这个基础上，再实现<code>AsyncConfigurer.getAsyncExecutor()</code>就可以让自己的线程池替代框架的 Bean。</li>
</ul>
<h2 id="threadpooltaskexecutor">ThreadPoolTaskExecutor</h2>
<p>ThreadPoolTaskExecutor 是 ExecutorConfigurationSupport 的子类，也包装了一个 ThreadPoolExecutor。</p>
<ul>
<li>ExecutorConfigurationSupport 作为基类提供了：
<ul>
<li>生命周期管理：实现了 InitializingBean, DisposableBean</li>
<li>配置管理：线程工厂、拒绝策略、优雅关闭等配置</li>
<li>模板方法：定义了初始化和销毁的标准流程</li>
</ul>
</li>
</ul>
<p>特别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>    initialize();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isInfoEnabled()) &#123;<br>        <span class="hljs-built_in">this</span>.logger.info(<span class="hljs-string">&quot;Initializing ExecutorService &quot;</span> + (<span class="hljs-built_in">this</span>.beanName != <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot; &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.beanName + <span class="hljs-string">&quot;&#x27;&quot;</span> : <span class="hljs-string">&quot;&quot;</span>));<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.threadNamePrefixSet &amp;&amp; <span class="hljs-built_in">this</span>.beanName != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.setThreadNamePrefix(<span class="hljs-built_in">this</span>.beanName + <span class="hljs-string">&quot;-&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 调用子类的具体实现</span><br>    <span class="hljs-built_in">this</span>.executor = <span class="hljs-built_in">this</span>.initializeExecutor(<span class="hljs-built_in">this</span>.threadFactory, <span class="hljs-built_in">this</span>.rejectedExecutionHandler);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以在这个 bean 被使用以前，内部线程池要经过一个 afterPropertiesSet 驱动进行初始化和注入这个 ThreadPoolTaskExecutor 线程池外壳。</p>
<h2 id="threadpooltaskexecutor-内部线程池的替换">ThreadPoolTaskExecutor 内部线程池的替换</h2>
<h3 id="推荐：使用初始化器装饰">推荐：使用初始化器装饰</h3>
<p>initializeExecutor 初始化过程里会允许我们装饰这个线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> ExecutorService <span class="hljs-title function_">initializeExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">        ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;<br><br>    BlockingQueue&lt;Runnable&gt; queue = createQueue(<span class="hljs-built_in">this</span>.queueCapacity);<br><br>    ThreadPoolExecutor executor;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.taskDecorator != <span class="hljs-literal">null</span>) &#123;<br>        executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-built_in">this</span>.corePoolSize, <span class="hljs-built_in">this</span>.maxPoolSize, <span class="hljs-built_in">this</span>.keepAliveSeconds, TimeUnit.SECONDS,<br>                queue, threadFactory, rejectedExecutionHandler) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>                <span class="hljs-type">Runnable</span> <span class="hljs-variable">decorated</span> <span class="hljs-operator">=</span> taskDecorator.decorate(command);<br>                <span class="hljs-keyword">if</span> (decorated != command) &#123;<br>                    decoratedTaskMap.put(decorated, command);<br>                &#125;<br>                <span class="hljs-built_in">super</span>.execute(decorated);<br>            &#125;<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-built_in">this</span>.corePoolSize, <span class="hljs-built_in">this</span>.maxPoolSize, <span class="hljs-built_in">this</span>.keepAliveSeconds, TimeUnit.SECONDS,<br>                queue, threadFactory, rejectedExecutionHandler);<br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.allowCoreThreadTimeOut) &#123;<br>        executor.allowCoreThreadTimeOut(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.threadPoolExecutor = executor;<br>    <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>java 线程池的装饰逻辑就是<strong>只覆盖一个</strong><code>public void execute(Runnable command)</code>即可。</p>
<p>这个方法本质上是<strong>一切线程池外部提交/执行操作的入口</strong>，所以<strong>它的执行线程是外部线程而已不是工作线程</strong>。</p>
<p>可以说<strong>这个壳的其他方法都只是包装一下普通线程的成员方法，但是这个 initializeExecutor 和 decorate 是这个壳特有的，是它存在的意义</strong>。</p>
<p>所有外部 command 在执行前都要被 decorate 一下，而且存在 decoratedTaskMap 里，模式是装饰后-&gt;原始命令。目前这个map没有用处，未来可能在用修饰后的任务找原始 Runnable 的时候会有用。</p>
<h3 id="其他代理">其他代理</h3>
<p>其他方法都是用<strong>类似的模式来代理的，而且不支持多态</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> getThreadPoolExecutor();<br>    <span class="hljs-keyword">try</span> &#123;<br>        executor.execute(task);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskRejectedException</span>(<span class="hljs-string">&quot;Executor [&quot;</span> + executor + <span class="hljs-string">&quot;] did not accept task: &quot;</span> + task, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="如果我们要替换线程池实现">如果我们要替换线程池实现</h3>
<p>我们只能用反射来替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;bizCommonTaskExecutor&quot;)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ThreadPoolTaskExecutor <span class="hljs-title function_">getAsyncExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建支持EagleEye上下文传递的ThreadPoolTaskExecutor</span><br>    <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">taskExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> ThreadPoolExecutor <span class="hljs-title function_">initializeExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">                ThreadFactory threadFactory,</span><br><span class="hljs-params">                RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;<br>            <span class="hljs-comment">// 创建阻塞队列</span><br>            BlockingQueue&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY);<br>            <br>            <span class="hljs-comment">// 创建支持EagleEye上下文传递的线程池</span><br>            <span class="hljs-type">EagleEyeContextAwareThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EagleEyeContextAwareThreadPoolExecutor</span>(<br>                CORE_POOL_SIZE,<br>                MAX_POOL_SIZE,<br>                KEEP_ALIVE_SECONDS,<br>                TimeUnit.SECONDS,<br>                queue,<br>                threadFactory,<br>                rejectedExecutionHandler<br>            );<br><br>            <span class="hljs-comment">// 使用反射将executor赋值给父类的private threadPoolExecutor字段，这是目前唯一的方法</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                java.lang.reflect.<span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> ThreadPoolTaskExecutor.class.getDeclaredField(<span class="hljs-string">&quot;threadPoolExecutor&quot;</span>);<br>                field.setAccessible(<span class="hljs-literal">true</span>);<br>                field.set(<span class="hljs-built_in">this</span>, executor);<br>                <span class="hljs-comment">// 如果有必要，要存储老的 accessible，在 set 完了以后要还原</span><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LoggerUtils.error(LOGGER, <span class="hljs-string">&quot;Failed to set threadPoolExecutor via reflection&quot;</span>, e);<br>            &#125;<br>            <br>            <span class="hljs-keyword">return</span> executor;<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-comment">// 配置线程名前缀</span><br>    taskExecutor.setThreadNamePrefix(<span class="hljs-string">&quot;bd-common-async-&quot;</span>);<br>    <br>    <span class="hljs-comment">// 配置优雅停机</span><br>    taskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="hljs-literal">true</span>);<br>    taskExecutor.setAwaitTerminationSeconds(AWAIT_TERMINATION_SECONDS);<br>    <br>    <span class="hljs-keyword">return</span> taskExecutor;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们不推荐使用这种做法，除非我们真的<strong>有增强 execute 以外的诉求</strong>。</p>
<h2 id="对线程池实行-trace-传递">对线程池实行 trace 传递</h2>
<h3 id="如果使用统一包装器">如果使用统一包装器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法的第一层参数是 ThreadPoolTaskExecutor 的 execute 执行的时候的这个 command：</span><br><span class="hljs-comment">//              public void execute(Runnable command) &#123;</span><br><span class="hljs-comment">//                  Runnable decorated = taskDecorator.decorate(command);</span><br> taskExecutor.setTaskDecorator(runnable -&gt; &#123;<br>            <br>            <span class="hljs-comment">// 这里获取外部提交的时候的线程和上下文</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">submitThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <br>            <span class="hljs-comment">// 这里返回一个 runnable，给外部的 super.execute(decorated); 使用，这个方法就是原始线程池的 execute 了</span><br>            <span class="hljs-keyword">return</span> () -&gt; &#123;<br>                <span class="hljs-comment">// 这里开始执行的时候通常已经进入线程池的 worker 内部了</span><br>                <br>                <span class="hljs-comment">// 当拒绝策略为 CallerRunsPolicy 且在提交线程中执行时，直接运行即可</span><br>                <span class="hljs-keyword">if</span> (submitThread == Thread.currentThread()) &#123;<br>                    runnable.run();<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">oldContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (oldContext == <span class="hljs-literal">null</span>) &#123;<br>                        needClean = <span class="hljs-literal">true</span>;<br>                        EagleEye.setRpcContext(rpcContext);<br>                    &#125;<br>                    <span class="hljs-comment">// 这是在内部线程 run 之前执行的围绕操作</span><br>                    runnable.run();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span> (needClean) &#123;<br>                        EagleEye.clearRpcContext();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>        &#125;);<br></code></pre></td></tr></table></figure>
<p>其中装饰器被调用的地方是就是上面的<a href="#%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E8%A3%85%E9%A5%B0">使用初始化器装饰</a>。</p>
<p>本质上 executor 共有三个入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (EagleEye.currentRpcContext() == <span class="hljs-literal">null</span>) &#123;<br>                needClean = <span class="hljs-literal">true</span>;<br>                EagleEye.setRpcContext(rpcContext);<br>            &#125;<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (needClean) &#123;<br>                    EagleEye.clearRpcContext();<br>                &#125;<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (EagleEye.currentRpcContext() == <span class="hljs-literal">null</span>) &#123;<br>                needClean = <span class="hljs-literal">true</span>;<br>                EagleEye.setRpcContext(rpcContext);<br>            &#125;<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (needClean) &#123;<br>                    EagleEye.clearRpcContext();<br>                &#125;<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>    <span class="hljs-keyword">if</span> (command <span class="hljs-keyword">instanceof</span> FutureTask) &#123;<br>        <span class="hljs-built_in">super</span>.execute(command);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.execute(() -&gt; &#123;<br>            EagleEye.setRpcContext(rpcContext);<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                command.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                EagleEye.clearRpcContext();<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>前两个 newTaskFor 是其他 submit 方法到 execute 之前的底层方法。因为前两个入口最终都会调到<code>execute(Runnable command)</code>，所以它的内部要避开<code>if (command instanceof FutureTask) {</code>的场景。这个设计因此显得比较累赘。</p>
<p>实际上 decorator 的实现就是最佳的，最终只要实现一个 execute 的包装提交就行了。</p>
<p>这个实现里有一个地方要注意：执行完当前的 runnable 需要 clear，否则可能会出现以前有的遗留 traceId 污染的问题。</p>
<p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">《一行一行源码分析清楚AbstractQueuedSynchronizer》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《Java线程池实现原理及其在美团业务中的实践》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016058789">《Keep Coding》</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/">https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3%EF%BC%9AForkJoinPool/" title="线程池详解：ForkJoinPool"><img class="cover" src="/2026/01/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3%EF%BC%9AForkJoinPool/java-thread-x-forkjoin-%E5%8F%AA%E5%8F%91%E7%94%9F%E5%9C%A8%E5%90%8C%E5%B1%82%E4%B9%8B%E9%97%B4.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-04</div><div class="info-item-2">线程池详解：ForkJoinPool</div></div><div class="info-2"><div class="info-item-1"> 前言：分治并行的诞生 ForkJoinPool 不是为了通用&quot;并行&quot;而设计，而是专门为分治并行（Divide-and-Conquer Parallelism）这一特定模式量身定制。分治算法（如快速排序、归并排序、树遍历）具有独特的执行模式：  任务天然形成树状结构 父任务派生子任务后需要等待结果 子任务之间通常无依赖关系 计算密集，无I/O阻塞  理解分治算法的执行特性，是理解 ForkJoinPool 设计的关键。传统线程池在处理这类任务时遇到根本性挑战，ForkJoinPool 正是为解决这些挑战而诞生。 1. 核心数据结构：ForkJoinPool的基石 1.1 ForkJoinPool：去中心化的调度器 数据结构定义 1234567891011121314151617181920212223public class ForkJoinPool extends AbstractExecutorService &#123;    // 64位控制状态：编码活跃线程数、空闲线程数、任务计数    volatile long ctl;        // 工作...</div></div></div></a><a class="pagination-related" href="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" title="无锁队列"><img class="cover" src="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">无锁队列</div></div><div class="info-2"><div class="info-item-1">Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。 * * &lt;p&gt;原理说明： * - 仅允许一个线程调用 &#123;@code offer()&#125;，一个线程调用 &#123;@code poll()&#125;。 * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。 * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系： *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。 * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad）， *   ...</div></div></div></a><a class="pagination-related" href="/2026/01/18/%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E7%9A%84%E5%8E%86%E5%8F%B2/" title="异步进化的历史"><img class="cover" src="/2026/01/18/%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E7%9A%84%E5%8E%86%E5%8F%B2/CompletableFuture%E6%89%A7%E8%A1%8C%E6%A0%91.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">异步进化的历史</div></div><div class="info-2"><div class="info-item-1">本文一部分来自于qwen，一部分来自于以下文章：  《CompletableFuture原理与实践-外卖商家端API的异步化》  Java 演进本质 graph LR     A[Java 5 Future] --&gt;|阻塞痛点| B[Guava ListenableFuture]     B --&gt;|回调地狱| C[CompletableFuture]     C --&gt;|流处理需求| D[RxJava]     D --&gt;|Spring整合| E[Reactor]          A --&gt;|范式转变| F[命令式-&gt;声明式]     B --&gt;|抽象提升| G[事件驱动-&gt;数据流]     C --&gt;|能力增强| H[组合-&gt;背压]     D &amp; E --&gt;|统一理念| I[异步即数据流]  控制流：阻塞等待 → 回调响应 → 声明式组合 → 响应式流 错误处理：分散try-catch → 回调onFailure → 链式exceptionally → 流式onError 组合能力：无 → 有限tr...</div></div></div></a><a class="pagination-related" href="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="Java 并发编程笔记"><img class="cover" src="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-12</div><div class="info-item-2">Java 并发编程笔记</div></div><div class="info-2"><div class="info-item-1"> juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 MESA 模型 JAVA 采用 MESA 模型：  互斥（Mutual Exclusion）：通过锁机制保证同一时刻只有一个线程能进入管程内部执行。 同步（Synchronization）：利用条件变量（Condition Variable）实现线程间的等待与唤醒。 Signal and Continue：   当线程发出通知（signal/notify）时，它继续持有锁并运行，而被唤醒的线程仅仅是进入就绪队列，并不立即抢占 CPU。   必须使用 while 循环：   由于线程被唤醒后不一定立即执行，当它重新获得锁时，环境条件可能已发生变化，因此必须在一个 while 循环中重新检查等待条件（while (condition) { wait(); }）。  为什么用 se...</div></div></div></a><a class="pagination-related" href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-19</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1"> 版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374），在 JDK 18 中相关代码已被移除。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级。但在深入讨论线程安全的分类之前，我们需要先理解 Java 内存模型——它是理解线程安全问题的理论基础。 Java 内存模型基础 Java 内存模型（Java Memory Model，JMM）是 Java 语言规范的一部分，定义了多线程程序中共享变量的访问规则。理解 JMM 是理解线程安全问题的基础。 为什么需要内存模型？ 现代计算机系统中，CPU 与主内存之间存在巨大的速度差异。为了弥补这一差距，硬件层面引入了多级缓存（L1、L...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-169.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.</span> <span class="toc-text">从执行器到线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">执行器继承体系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#executor-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">Executor 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#executorservice-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.2.</span> <span class="toc-text">ExecutorService 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abstractexecutorservice"><span class="toc-number">1.1.3.</span> <span class="toc-text">AbstractExecutorService</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#threadpoolexecutor"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#forkjoinpool"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">ForkJoinPool</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#the-executors"><span class="toc-number">1.1.4.</span> <span class="toc-text">The Executors</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">层次调用关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#futuretask-%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%BB%E5%8A%A1%E8%BD%BD%E4%BD%93"><span class="toc-number">1.2.1.</span> <span class="toc-text">FutureTask 作为线程池的核心任务载体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#thread-%E6%A8%A1%E5%9E%8B%E5%BA%95%E5%B1%82"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Thread 模型底层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#futuretask-%E7%9A%84-run"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">FutureTask 的 run()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#futuretask-%E7%9A%84-runner"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">FutureTask 的 runner</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#invokeall"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">invokeAll</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%92%88%E5%AF%B9-runnable-%E7%9A%84-submit"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">两种针对 Runnable 的 submit</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8A%A4%E8%87%AA%E8%BA%AB%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">线程池如何维护自身状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.3.1.</span> <span class="toc-text">尝试关闭线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">线程池如何管理任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">1.4.1.</span> <span class="toc-text">任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">提交任务调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%BC%93%E5%86%B2"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">任务缓冲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%94%B3%E8%AF%B7"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">任务申请</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">线程池如何管理线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">尝试增加线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="toc-number">1.5.2.</span> <span class="toc-text">线程执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">回收线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">线程池使用中可能遇到的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88"><span class="toc-number">1.7.</span> <span class="toc-text">线程池的可替换方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.8.</span> <span class="toc-text">最终解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-number">2.</span> <span class="toc-text">线程组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E6%9C%AC%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84"><span class="toc-number">2.1.</span> <span class="toc-text">原本设计目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-number">2.2.</span> <span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">2.3.</span> <span class="toc-text">替代方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%80%81%E5%BA%A6"><span class="toc-number">2.4.</span> <span class="toc-text">官方态度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completionstage"><span class="toc-number">3.</span> <span class="toc-text">CompletionStage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completablefuture"><span class="toc-number">4.</span> <span class="toc-text">CompletableFuture</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">如何处理任务超时问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E4%BD%BF%E7%94%A8-futuretask-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">方法1：使用 FutureTask 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">方法2：使用条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E4%BD%BF%E7%94%A8-countdownlatch-cyclicbarrier"><span class="toc-number">5.1.3.</span> <span class="toc-text">方法3：使用 countDownLatch&#x2F;CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E6%96%AD"><span class="toc-number">5.2.</span> <span class="toc-text">自定义线程池实现自定义中断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Java 异步执行中的异常处理与线程生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-futuretask-asyncuncaughtexceptionhandler-%E5%88%B0-uncaughtexceptionhandler"><span class="toc-number">6.1.</span> <span class="toc-text">从 FutureTask、AsyncUncaughtExceptionHandler 到 UncaughtExceptionHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%88%E6%AD%A2%E7%9A%84%E5%94%AF%E4%B8%80%E5%88%A4%E5%AE%9A%E6%A0%87%E5%87%86"><span class="toc-number">6.2.</span> <span class="toc-text">一、线程是否终止的唯一判定标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.1 会导致线程终止的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">6.2.2.</span> <span class="toc-text">1.2 不会导致线程终止的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-futuretask-%E5%AF%B9%E5%BC%82%E5%B8%B8%E4%BC%A0%E6%92%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">6.3.</span> <span class="toc-text">二、FutureTask 对异常传播路径的改变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-execute-%E4%B8%8E-submit-%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%B7%AE%E5%BC%82"><span class="toc-number">6.3.1.</span> <span class="toc-text">2.1 execute 与 submit 的根本差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-futuretask-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA%E7%82%B9"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.2 FutureTask 中的异常拦截点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BC%82%E5%B8%B8%E5%A6%82%E4%BD%95%E8%A2%AB%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%EF%BC%9Areport"><span class="toc-number">6.3.3.</span> <span class="toc-text">2.3 异常如何被重新抛出：report()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-uncaughtexceptionhandler-%E7%9A%84%E8%81%8C%E8%B4%A3%E8%BE%B9%E7%95%8C"><span class="toc-number">6.4.</span> <span class="toc-text">三、UncaughtExceptionHandler 的职责边界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.4.1.</span> <span class="toc-text">3.1 触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%83%BD%E5%8A%9B%E4%B8%8E%E9%99%90%E5%88%B6"><span class="toc-number">6.4.2.</span> <span class="toc-text">3.2 能力与限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-spring-asyncuncaughtexceptionhandler-%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">6.5.</span> <span class="toc-text">四、Spring AsyncUncaughtExceptionHandler 的作用范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.5.1.</span> <span class="toc-text">4.1 适用条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-spring-%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.2.</span> <span class="toc-text">4.2 Spring 的异常拦截方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AF%B9%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">6.5.3.</span> <span class="toc-text">4.3 对线程生命周期的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E4%B8%89%E7%A7%8D%E5%BC%82%E5%B8%B8%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">6.6.</span> <span class="toc-text">五、三种异常路径的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-async-void-%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.1.</span> <span class="toc-text">5.1 @Async void 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0execute"><span class="toc-number">6.6.2.</span> <span class="toc-text">5.2 线程池execute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0-submit"><span class="toc-number">6.6.3.</span> <span class="toc-text">5.3 线程池 submit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E4%B8%A4%E7%A7%8D-handler-%E7%9A%84%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">6.7.</span> <span class="toc-text">六、两种 Handler 的推荐使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-asyncuncaughtexceptionhandler-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">6.7.1.</span> <span class="toc-text">6.1 AsyncUncaughtExceptionHandler（业务层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-uncaughtexceptionhandler-%E7%B3%BB%E7%BB%9F%E5%B1%82"><span class="toc-number">6.7.2.</span> <span class="toc-text">6.2 UncaughtExceptionHandler（系统层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">6.7.3.</span> <span class="toc-text">6.3 有返回值的异步任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">6.8.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">Spring 的异步支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpooltaskexecutor"><span class="toc-number">7.1.</span> <span class="toc-text">ThreadPoolTaskExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpooltaskexecutor-%E5%86%85%E9%83%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-number">7.2.</span> <span class="toc-text">ThreadPoolTaskExecutor 内部线程池的替换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E8%A3%85%E9%A5%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text">推荐：使用初始化器装饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BB%A3%E7%90%86"><span class="toc-number">7.2.2.</span> <span class="toc-text">其他代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%A6%81%E6%9B%BF%E6%8D%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.3.</span> <span class="toc-text">如果我们要替换线程池实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E8%A1%8C-trace-%E4%BC%A0%E9%80%92"><span class="toc-number">7.3.</span> <span class="toc-text">对线程池实行 trace 传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%E7%BB%9F%E4%B8%80%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">7.3.1.</span> <span class="toc-text">如果使用统一包装器</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>