<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 线程池笔记 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从执行器到线程池  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finan">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 线程池笔记">
<meta property="og:url" content="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="从执行器到线程池  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finan">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png">
<meta property="article:published_time" content="2026-01-24T13:50:09.000Z">
<meta property="article:modified_time" content="2026-01-29T16:45:09.972Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 线程池笔记",
  "url": "https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png",
  "datePublished": "2026-01-24T13:50:09.000Z",
  "dateModified": "2026-01-29T16:45:09.972Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 线程池笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 线程池笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java 线程池笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-24T13:50:09.000Z" title="Created 2026-01-24 21:50:09">2026-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-29T16:45:09.972Z" title="Updated 2026-01-30 00:45:09">2026-01-30</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">54.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>232mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>从执行器到线程池</h1>
<blockquote>
<p>Pooling is the grouping together of resources (assets, equipment,<br>
personnel, effort, etc.) for the purposes of maximizing advantage or<br>
minimizing risk to the users. The term is used in finance, computing<br>
and equipment management.——wikipedia</p>
<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p>
<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p>
<p>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection<br>
Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池(Object<br>
Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</p>
</blockquote>
<p>Doug Lea 对线程池的期待有：</p>
<ol>
<li>改善性能。</li>
<li>有界地利用资源（多次强调 bounds）。</li>
<li>提供统计。</li>
</ol>
<h2 id="执行器继承体系">执行器继承体系</h2>
<p>“设计良好的API应该简单、一致、可扩展。”</p>
<p><img src="ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="ThreadPoolExecutorUML类图.png"></p>
<p>我们将任务交给执行器，于是有了执行器；我们将执行器内部用 FutureTask 包装任务，于是有了同步转异步，异步转同步的设计，和多种 API；我们将执行器用线程池来实现，于是我们得到了 ThreadPoolExecutor。</p>
<ul>
<li>Executor：只定义&quot;执行&quot;契约</li>
<li>ExecutorService：定义生命周期、 多种任务类型（Runnable/Callable）、批量任务契约</li>
</ul>
<p><strong>这两层都是契约层，方法之间没有明确关联</strong>。</p>
<ul>
<li>AbstractExecutorService：只提供算法模板-这一层提供了方法在 execute 之上的实现，把 api 关联起来。但是唯独 execute 的实现空余了。</li>
<li>ThreadPoolExecutor：只实现 execute，并且围绕它搭建了一整套线程池的参考实现：Worker+状态机+队列。</li>
<li>FutureTask：只负责任务包装。但是它的<strong>两个父接口让它成为连接了 <code>execute(Runnable)</code>和<code>Future.get()</code>两个世界的桥梁</strong>。</li>
</ul>
<pre><code class="hljs mermaid">classDiagram
    class Executor &#123;
        &lt;&lt;interface&gt;&gt;
        +execute(Runnable command) void  // 基础执行契约
    &#125;
    
    class ExecutorService &#123;
        &lt;&lt;interface&gt;&gt;
        +submit(Callable~T~ task) Future~T~  // 新增：结果获取API
        +invokeAll(Collection~Callable~T~~ tasks) List~Future~T~~  // 新增：批量处理API
        +shutdown() void  // 新增：生命周期API
        +awaitTermination(long timeout, TimeUnit unit) boolean  // 新增：等待关闭API
    &#125;
    
    class AbstractExecutorService &#123;
        &lt;&lt;abstract&gt;&gt;
        # 所有高级功能都围绕 newTaskFor（有返回值和无返回值的任务类型） + execute 构建
        #newTaskFor(Callable~T~ callable) RunnableFuture~T~  // 新增：任务包装工厂API
        #newTaskFor(Runnable runnable, T value) RunnableFuture~T~  // 新增：任务包装工厂API
        
        +submit(Callable~T~ task) Future~T~  // 实现：包装+提交算法
        +invokeAll(Collection~Callable~T~~ tasks) List~Future~T~~  // 实现：批量包装+提交算法
        +invokeAny(Collection~Callable~T~~ tasks) T  // 实现：任意完成算法
        
        // 关键：execute() 是抽象的，留给子类实现
        ~execute(Runnable command) void
    &#125;
    
    class ThreadPoolExecutor &#123;
        -corePoolSize: int
        -maximumPoolSize: int
        -workQueue: BlockingQueue~Runnable~
        -workers: HashSet~Worker~
        
        +execute(Runnable command) void
        +shutdown() void
        +beforeExecute(Thread t, Runnable r) void
        +afterExecute(Runnable r, Throwable t) void
    &#125;
    
    class ForkJoinPool &#123;
        &lt;&lt;concrete&gt;&gt;
        -parallelism: int
        -workQueues: WorkQueue[]  // 工作窃取队列数组
        -commonPool: ForkJoinPool  // 静态共享池
        
        +execute(ForkJoinTask~?~ task) void  // 重载 execute，专用于 ForkJoinTask
        +submit(ForkJoinTask~T~ task) ForkJoinTask~T~  // 支持 ForkJoinTask 的 submit
        +invoke(ForkJoinTask~T~ task) T  // 同步调用并返回结果（核心方法）
        +shutdown() void
        +awaitTermination(...) boolean
        
        // 内部线程继承 ForkJoinWorkerThread
    &#125;
    
    class ForkJoinTask &#123;
        &lt;&lt;abstract&gt;&gt;
        -status: int
        +fork() ForkJoinTask~T~  // 异步执行（入队到当前线程的队列）
        +join() T  // 阻塞等待结果
        +invoke() T  // fork + join 的快捷方式
        +tryUnfork() boolean
        +quietlyComplete()
    &#125;
    
    class RecursiveTask &#123;
        &lt;&lt;abstract&gt;&gt;
        +compute() V  // 用户实现逻辑，返回结果
    &#125;
    
    class RecursiveAction &#123;
        &lt;&lt;abstract&gt;&gt;
        +compute() void  // 用户实现逻辑，无返回值
    &#125;
    
    class FutureTask &#123;
        -callable: Callable~V~
        -outcome: Object
        -state: int
        -runner: Thread
        +run() void
        +get() V
        +cancel(boolean mayInterruptIfRunning) boolean
    &#125;
    
    class Worker &#123;
        -thread: Thread
        -firstTask: Runnable
        +run() void
    &#125;
    
    class ForkJoinWorkerThread &#123;
        &lt;&lt;concrete&gt;&gt;
        -pool: ForkJoinPool
        -workQueue: WorkQueue
        +run() void  // 执行工作窃取循环
    &#125;
    
    %% 关系
    Executor &lt;|-- ExecutorService : &quot;adds lifecycle+results API&quot;
    ExecutorService &lt;|-- AbstractExecutorService : &quot;adds algorithm implementation&quot;
    AbstractExecutorService &lt;|-- ThreadPoolExecutor : &quot;adds thread pool strategy&quot;
    AbstractExecutorService &lt;|-- ForkJoinPool : &quot;adds work-stealing strategy&quot;
    
    AbstractExecutorService ..&gt; FutureTask : &quot;creates via newTaskFor()&quot;
    
    ThreadPoolExecutor o-- Worker : &quot;manages pool of&quot;
    Worker ..&gt; Runnable : &quot;executes tasks&quot;
    ThreadPoolExecutor ..&gt; FutureTask : &quot;executes via workers&quot;
    
    ForkJoinPool o-- ForkJoinWorkerThread : &quot;manages pool of&quot;
    ForkJoinWorkerThread ..&gt; WorkQueue : &quot;owns&quot;
    WorkQueue ..&gt; ForkJoinTask : &quot;holds tasks&quot;
    ForkJoinPool ..&gt; ForkJoinTask : &quot;executes via work-stealing&quot;
    
    ForkJoinTask &lt;|-- RecursiveTask : &quot;returns result&quot;
    ForkJoinTask &lt;|-- RecursiveAction : &quot;no result&quot;
    
    FutureTask ..|&gt; RunnableFuture : &quot;implements&quot;
    RunnableFuture --|&gt; Runnable : &quot;extends&quot;
    RunnableFuture --|&gt; Future : &quot;extends&quot;
    
    ForkJoinTask ..|&gt; Future : &quot;implements (indirectly via ForkJoinTask&lt;V&gt; extends Future&lt;V&gt;)&quot;
    ForkJoinTask ..|&gt; Serializable : &quot;implements&quot;</code></pre>
<h3 id="executor-接口">Executor 接口</h3>
<p>将任务提交和任务执行进行解耦（<strong>decoupling the execution mechanic</strong>）。用户无需关注如何创建线程，如何调度线程（scheduling）来执行任务，用户只需提供 Runnable 对象，将任务的运行逻辑提交到执行器(Executor)中，由 Executor 框架完成线程的调配和任务的执行部分。</p>
<p>JUC 里所有的解耦设计都不一定是异步的，它只是<strong>解耦</strong>，所以执行器本身也是可以同步执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-comment">// 这个类型只有这一个核心方法</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable r)</span> &#123;<br>     r.run();<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>一般而言可以认为，executor 会 spawns a new thread for each task.</p>
<h3 id="executorservice-接口">ExecutorService 接口</h3>
<p>增加了一些能力：</p>
<p>扩充执行任务的能力，补充可以为一个或一批异步任务<strong>生成 Future 的方法</strong>（），<strong>从这里开始执行器开始可以执行异步任务</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task)<br><span class="hljs-comment">// 则个 api 是很神奇的，本质上 runnable 是没有返回值的，这相当于帮我们给一个 runnable 带上一个线程运行结束的结果</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span><br><span class="hljs-comment">// 这个接口有一个神奇的特性，只有所有异步流程都执行完，才会返回，否则会 hang 住</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="hljs-comment">// 这个接口的超时ji&#x27;s</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br></code></pre></td></tr></table></figure>
<p>在上面的方法里，submit 能接收无结果的 Runnable、有结果的 Runnable、能返回结果的 Callable，再加上底层无返回结果的 execute，构成了4个基础的单任务api。</p>
<p>ExecutorService 还提供了管控线程池的方法，比如停止线程池的运行。</p>
<ul>
<li>shutdown 拒绝接收任务，触发 rejection policy。</li>
<li>shutdownNow 除了 shutdown 的功能以外，还会强制触发线程中断。</li>
</ul>
<p>Memory consistency effects：future.get 满足 JSL 定义的 Memory consistency properties，也就是 happens before relation。</p>
<p>理解 happens before relation 一定不要按照硬件的工作方式来理解（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/67472344/java-volatile-and-final-volatile-as-flushing-all-memory-content">Flushing model is fundamentally flawed (it is just not how hardware works)</a>），最好从 JLS 的规范出发。</p>
<h3 id="abstractexecutorservice">AbstractExecutorService</h3>
<p>将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法<code>execute</code>即可。其他契约的借口全都在这一层实现了：</p>
<ul>
<li>大部分的任务接口在这一层有了实现，它们最终都调向了 execute() 接口。</li>
<li>生命周期接口留给下一层。</li>
</ul>
<p>这一层大部分的方法实现都是这样的：</p>
<ol>
<li>把任务包装成 FutureTask。</li>
<li>用 execute 执行这个 FutureTask。因为这个 FutureTask 包住了原始的 run 方法，所以它的 exception 处理机制会比 UncaughtExceptionHandler 更快一步拦截异常。</li>
<li>把 FutureTask 实例阻塞或者不阻塞地在同步流程里直接返回。</li>
<li>外部调用者不断与这些 task 通讯决定是否状态完成。</li>
</ol>
<p>其中多种调用模式的层叠大概是这样的：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant User
    participant AbstractExecutorService
    participant ThreadPoolExecutor
    participant WorkerThread
    participant FutureTask
    
    User-&gt;&gt;AbstractExecutorService: invokeAll(tasks)
    loop for each task
        AbstractExecutorService-&gt;&gt;AbstractExecutorService: newTaskFor(task)
        AbstractExecutorService-&gt;&gt;FutureTask: new FutureTask(task)
        AbstractExecutorService-&gt;&gt;ThreadPoolExecutor: execute(futureTask)
        ThreadPoolExecutor-&gt;&gt;WorkerThread: 分配任务
        WorkerThread-&gt;&gt;FutureTask: futureTask.run()
        FutureTask-&gt;&gt;Task: callable.call()
        Task--&gt;&gt;FutureTask: 返回结果
        FutureTask-&gt;&gt;FutureTask: set(result)
    end
    
    AbstractExecutorService-&gt;&gt;AbstractExecutorService: for each future: future.get()
    loop for each future
        AbstractExecutorService-&gt;&gt;FutureTask: future.get()
        alt 任务已完成
            FutureTask--&gt;&gt;AbstractExecutorService: 立即返回结果
        else 任务未完成
            FutureTask--&gt;&gt;FutureTask: 挂起等待
            FutureTask-&gt;&gt;FutureTask: 任务完成后唤醒
            FutureTask--&gt;&gt;AbstractExecutorService: 返回结果
        end
    end
    
    AbstractExecutorService--&gt;&gt;User: 返回所有Future结果</code></pre>
<h4 id="threadpoolexecutor">ThreadPoolExecutor</h4>
<p>实现了 execute，围绕execute 的批量和异步化给出了一个经典的线程池实现。</p>
<p>将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<p><img src="ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="ThreadPoolExecutor运行流程.png"></p>
<h4 id="forkjoinpool">ForkJoinPool</h4>
<p>这个线程池本身就是一个复杂框架，为 JDK 其他组件提供 yet another executor alternative。</p>
<p>这个框架有个特点：</p>
<ol>
<li>产生的线程默认是守护线程。</li>
<li>产生的线程会自动收缩-不存在空转的 core thread 问题。</li>
<li>公共线程池的名字一般叫“ForkJoinPool.commonPool-worker-1”。</li>
</ol>
<p>这里就要讨论到一个很多人忽略的问题：我们如何决定何时使用守护类线程。这类线程可以用来执行一些：</p>
<ol>
<li>临时执行的任务，这些任务之间如果存在父子关系更好。</li>
<li>后台监控类任务。</li>
<li>某些与 io 解耦的计算任务。</li>
</ol>
<p>这类线程池（包括守护线程本身）适合执行计算密集型任务，不适合执行 io 密集型任务，不然：</p>
<ol>
<li>工作线程池会在 JVM 关闭时被无声无息地杀死。</li>
<li>当其他非守护线程都结束后，这些守护线程的存在反而是 JVM 进入关闭态的理由。</li>
<li>典型的工作线程池就是 IO 线程池，和与他们绑定的计算线程池。</li>
</ol>
<p>初始化这类线程池有一些简单的工厂方法，比原始构造器更加可用：  <code>Executors.newWorkStealingPool(int parallelism)</code>。</p>
<p>更多内容见<a href="#forkjoinpool%E8%AF%A6%E8%A7%A3%E5%88%86%E6%B2%BB%E5%B9%B6%E8%A1%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E">《线程池详解：ForkJoinPool》</a>。</p>
<h3 id="the-executors">The Executors</h3>
<blockquote>
<p>provides convenient factory methods for these Executors.</p>
</blockquote>
<h2 id="层次调用关系">层次调用关系</h2>
<h3 id="futuretask-作为线程池的核心任务载体">FutureTask 作为线程池的核心任务载体</h3>
<p>以  FutureTask 为核心，可以看出如下关系：</p>
<pre><code class="hljs mermaid">classDiagram
    class FutureTask &#123;
        -callable: Callable~V~
        -outcome: Object
        -state: int
        -runner: Thread
        
        +run() void
        +get() V
        +cancel(boolean) boolean
        +isDone() boolean
    &#125;
    
    class RunnableFuture &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    
    class Runnable &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    
    class Future &#123;
        &lt;&lt;interface&gt;&gt;
        +get() V
        +cancel(boolean) boolean
        +isDone() boolean
    &#125;
    
    class Callable &#123;
        &lt;&lt;interface&gt;&gt;
        +call() V
    &#125;
    
    FutureTask ..|&gt; RunnableFuture : implements
    RunnableFuture --|&gt; Runnable : extends
    RunnableFuture --|&gt; Future : extends
    FutureTask o-- Callable : has
    FutureTask o-- Object : stores
    FutureTask o-- Thread : references</code></pre>
<ul>
<li>我们先产生一个新的 Future 接口，然后把 Runnable 和 Future 联合继承出 RunnableFuture。这两个类型一个是对内线程池使用，一个是对外对任务的使用者使用。</li>
<li>然后 RunnableFuture 有个经典实现类 FutureTask-这是两个经典的 RunnableFuture 的经典实现之一（<code>All Known Implementing Classes:FutureTask, SwingWorker</code>），可以认为 FutureTask 是可执行的 Future 的最忠实实现。它本身<strong>不是 Callble，但是包含 Callable</strong>。它的5个一级子成员：
<ul>
<li>callable</li>
<li>outCome 这个成员同时可以是 result 也可以是异常，由 report 自行决定处理方式</li>
<li>runner：用来状态检查，并持有它保证拥有中断能力、取消能力</li>
<li>state：这是线程池里出现的第一个状态，</li>
</ul>
</li>
<li>因为是 runnable 包着 callable，所以底层的运行模式大概是这样的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 之所以这样设计，本质上是因为 Thread 类底层也是 run，不支持 call</span><br>task.run() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行组合的 Callable</span><br>        outcome = callable.call();  <span class="hljs-comment">// &quot;Hello World&quot;</span><br>        state = NORMAL;            <span class="hljs-comment">// 状态转换</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        exception = e;             <span class="hljs-comment">// 存储异常</span><br>        state = EXCEPTIONAL;       <span class="hljs-comment">// 状态转换</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="thread-模型底层">Thread 模型底层</h4>
<p>之所以这样设计，实际上是因为 Thread 模型底层只支持 run 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java 从 1.0 开始就实现了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> Runnable target;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>            target.run();  <span class="hljs-comment">// 只能调用 run()，没有返回值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>底层的 cpp 源码是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// HotSpot JVM 源码：thread.cpp</span><br><span class="hljs-built_in">JVM_ENTRY</span>(<span class="hljs-type">void</span>, <span class="hljs-built_in">JVM_StartThread</span>(JNIEnv* jni, jobject jthread))<br>  <span class="hljs-built_in">JVMWrapper</span>(<span class="hljs-string">&quot;JVM_StartThread&quot;</span>);<br>  <br>  <span class="hljs-comment">// 1. 从 Java 对象获取 C++ Thread 对象</span><br>  JavaThread* native_thread = java_lang_Thread::<span class="hljs-built_in">thread</span>(JNIHandles::<span class="hljs-built_in">resolve_non_null</span>(jthread));<br>  <br>  <span class="hljs-comment">// 2. 状态检查</span><br>  <span class="hljs-keyword">if</span> (native_thread-&gt;<span class="hljs-built_in">is_being_ext_suspended</span>()) &#123;<br>    native_thread-&gt;<span class="hljs-built_in">set_terminated_before_start</span>(<span class="hljs-literal">true</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 3. 创建操作系统线程</span><br>  <span class="hljs-keyword">if</span> (native_thread-&gt;<span class="hljs-built_in">osthread</span>() != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// 关键：调用 os::create_thread 创建 OS 线程</span><br>    <span class="hljs-keyword">if</span> (os::<span class="hljs-built_in">create_thread</span>(native_thread, java_thread)) &#123;<br>      <span class="hljs-comment">// 4. 设置线程状态为 INITIALIZED</span><br>      native_thread-&gt;<span class="hljs-built_in">set_state</span>(INITIALIZED);<br>      <br>      <span class="hljs-comment">// 5. 启动操作系统线程</span><br>      os::<span class="hljs-built_in">start_thread</span>(native_thread);<br>    &#125;<br>  &#125;<br>JVM_END<br><br><span class="hljs-comment">// Linux 实现 (os_linux.cpp)</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">os::create_thread</span><span class="hljs-params">(Thread* thread, ThreadType thr_type)</span> </span>&#123;<br>  <span class="hljs-comment">// 1. 创建 pthread_attr_t 属性</span><br>  <span class="hljs-type">pthread_attr_t</span> attr;<br>  <span class="hljs-built_in">pthread_attr_init</span>(&amp;attr);<br>  <br>  <span class="hljs-comment">// 2. 设置栈大小</span><br>  <span class="hljs-type">size_t</span> stack_size = ...; <span class="hljs-comment">// 根据线程类型设置</span><br>  <span class="hljs-built_in">pthread_attr_setstacksize</span>(&amp;attr, stack_size);<br>  <br>  <span class="hljs-comment">// 3. 关键：创建 pthread 线程</span><br>  <span class="hljs-type">pthread_t</span> tid;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;tid, &amp;attr, thread_native_entry, thread);<br>  <br>  <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 4. 保存线程 ID</span><br>    thread-&gt;<span class="hljs-built_in">set_thread_id</span>(tid);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 线程入口函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">thread_native_entry</span><span class="hljs-params">(Thread* thread)</span> </span>&#123;<br>  <span class="hljs-comment">// 1. 设置线程状态</span><br>  thread-&gt;<span class="hljs-built_in">set_state</span>(RUNNABLE);<br>  <br>  <span class="hljs-comment">// 2. 关键：调用 Java 层的 run() 方法</span><br>  thread-&gt;<span class="hljs-built_in">run</span>();<br>  <br>  <span class="hljs-comment">// 3. 线程结束处理</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// HotSpot JVM 中的关键结构，这个 javaThread 既持有操作系统线程句柄，也持有 Java 线程句柄。这样实现了平台无关性。</span><br><span class="hljs-comment">// JavaThread 确实是三位一体的设计：</span><br><span class="hljs-comment">// 1. JVM 层：JavaThread* 本身（管理 JVM 内部状态）</span><br><span class="hljs-comment">// 2. OS 层：OSThread* _osthread（操作系统资源）</span><br><span class="hljs-comment">// 3. Java 层：oop _threadObj（java.lang.Thread 对象）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaThread</span>: <span class="hljs-keyword">public</span> Thread &#123;<br><span class="hljs-keyword">private</span>:<br>  oop _threadObj;        <span class="hljs-comment">// 对应的 Java Thread 对象</span><br>  OSThread* _osthread;   <span class="hljs-comment">// 操作系统线程</span><br>  <span class="hljs-keyword">volatile</span> JavaThreadState _state; <span class="hljs-comment">// 线程状态</span><br>  <br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用 Java 层的 run() 方法</span><br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">thread_main_inner</span>();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_main_inner</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_java_lang_thread</span>()) &#123;<br>      <span class="hljs-comment">// 通过 JNI 调用 Java 层的 run() 方法</span><br>      JavaCalls::<span class="hljs-built_in">call_virtual</span>(<br>        &amp;result,<br>        klass,<br>        method,<br>        threadObj,<br>        CHECK<br>      );<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 通过 JNI 调用 Java 方法</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">call_run_method</span><span class="hljs-params">(JNIEnv* env, jobject jthread)</span> </span>&#123;<br>  jclass threadClass = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;java/lang/Thread&quot;</span>);<br>  jmethodID runMethod = env-&gt;<span class="hljs-built_in">GetMethodID</span>(threadClass, <span class="hljs-string">&quot;run&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>  <br>  <span class="hljs-comment">// 调用 Thread.run() 方法</span><br>  env-&gt;<span class="hljs-built_in">CallVoidMethod</span>(jthread, runMethod);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>整体调用的流程是从 java 到 cpp 再到 java 的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 调用链：</span><br>thread<span class="hljs-selector-class">.start</span>()<br>  → Thread<span class="hljs-selector-class">.start</span>() <span class="hljs-selector-attr">[Java]</span><br>  → <span class="hljs-built_in">start0</span>() <span class="hljs-selector-attr">[native]</span><br>  → <span class="hljs-built_in">JVM_StartThread</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → os::<span class="hljs-built_in">create_thread</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → <span class="hljs-built_in">pthread_create</span>() <span class="hljs-selector-attr">[Linux C]</span><br>  → <span class="hljs-built_in">thread_native_entry</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → JavaThread::<span class="hljs-built_in">run</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → JNI: <span class="hljs-built_in">CallVoidMethod</span>(threadObj, <span class="hljs-string">&quot;run&quot;</span>) <span class="hljs-selector-attr">[JNI]</span><br>  → Thread<span class="hljs-selector-class">.run</span>() <span class="hljs-selector-attr">[Java]</span><br>  → target<span class="hljs-selector-class">.run</span>() <span class="hljs-selector-attr">[Java]</span>  <span class="hljs-comment">// 最终调用用户代码</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">classDiagram
    class JavaThread &#123;
        -OSThread* _osthread
        -oop _threadObj
        -JavaThreadState _state
        -address _stack_base
        -size_t _stack_size
        
        +run()
        +thread_main_inner()
        +osthread() OSThread*
        +threadObj() oop
    &#125;
    
    class OSThread &#123;
        -pthread_t _thread_id
        -int _thread_state
        
        +set_thread_id(pthread_t)
        +thread_id() pthread_t
    &#125;
    
    class JavaThreadObj &#123;
        &lt;&lt;Java Object&gt;&gt;
        -Runnable target
        -int threadStatus
        
        +start()
        +run()
    &#125;
    
    JavaThread o-- OSThread : &quot;持有操作系统线程&quot;
    JavaThread o-- JavaThreadObj : &quot;关联Java对象&quot;</code></pre>
<pre><code class="hljs mermaid">sequenceDiagram
    participant User as Java代码
    participant JVM as JVM(JavaThread)
    participant OS as 操作系统
    
    User-&gt;&gt;JVM: new Thread(runnable)
    JVM-&gt;&gt;JVM: 创建JavaThread对象
    JVM-&gt;&gt;JVM: 创建OSThread对象
    JVM-&gt;&gt;JVM: 关联JavaThread和OSThread
    
    User-&gt;&gt;JVM: thread.start()
    JVM-&gt;&gt;JVM: 检查状态(threadStatus)
    JVM-&gt;&gt;JVM: 添加到线程组
    JVM-&gt;&gt;JVM: 调用start0()(native)
    
    JVM-&gt;&gt;OS: os::create_thread()
    OS-&gt;&gt;OS: 创建pthread线程
    OS-&gt;&gt;OS: 设置入口为thread_native_entry
    
    OS--&gt;&gt;JVM: 线程创建成功
    JVM--&gt;&gt;User: start()返回
    
    Note over OS: 新线程开始执行
    OS-&gt;&gt;JVM: thread_native_entry(JavaThread*)
    JVM-&gt;&gt;JVM: 设置线程状态为RUNNABLE
    JVM-&gt;&gt;JVM: thread-&gt;run()
    JVM-&gt;&gt;JVM: thread_main_inner()
    
    JVM-&gt;&gt;JVM: JNI: 查找Thread.run()方法
    JVM-&gt;&gt;JVM: JavaCalls::call_virtual()
    
    JVM-&gt;&gt;User: 调用Thread.run()
    User-&gt;&gt;User: target.run()(如果target!=null)
    
    User--&gt;&gt;JVM: 返回
    JVM-&gt;&gt;JVM: 线程结束清理
    JVM-&gt;&gt;OS: 释放操作系统资源</code></pre>
<h4 id="futuretask-的-run">FutureTask 的 run()</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123;<br>    <br>    <span class="hljs-comment">// 同时实现 Runnable（可执行）和 Future（可获取结果）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset, <span class="hljs-literal">null</span>, Thread.currentThread()))<br>            <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            Callable&lt;V&gt; c = callable;<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>                V result;<br>                <span class="hljs-type">boolean</span> ran;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    result = c.call();  <span class="hljs-comment">// 执行实际任务（支持返回值）</span><br>                    ran = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                    result = <span class="hljs-literal">null</span>;<br>                    ran = <span class="hljs-literal">false</span>;<br>                    setException(ex);  <span class="hljs-comment">// 设置异常</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (ran)<br>                    set(result);  <span class="hljs-comment">// 设置结果</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            runner = <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>            <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>                handlePossibleCancellationInterrupt(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="futuretask-的-runner">FutureTask 的 runner</h4>
<p>其中 runner 的注入/获取流程大致如下：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant ThreadA
    participant FutureTask
    participant ThreadB
    
    ThreadA-&gt;&gt;FutureTask: submit(task)
    FutureTask-&gt;&gt;FutureTask: state = NEW, runner = null
    
    ThreadB-&gt;&gt;FutureTask: execute(task) // 线程池线程
    FutureTask-&gt;&gt;FutureTask: CAS设置 runner = ThreadB
    FutureTask-&gt;&gt;ThreadB: 执行任务逻辑
    
    Note right of FutureTask: 此时 runner = ThreadB
    
    ThreadA-&gt;&gt;FutureTask: cancel(true)
    FutureTask-&gt;&gt;FutureTask: 检查 mayInterruptIfRunning = true
    FutureTask-&gt;&gt;ThreadB: runner.interrupt() // 使用runner字段
    
    ThreadB--&gt;&gt;FutureTask: 任务被中断
    FutureTask-&gt;&gt;FutureTask: state = INTERRUPTED
    FutureTask-&gt;&gt;FutureTask: runner = null // 清理引用
    
    Note right of FutureTask: 任务完成，runner = null</code></pre>
<h5 id="invokeall">invokeAll</h5>
<p><strong>invokeAll 是有界的</strong>，如果一次性提交了超过它界限的任务，即使这些任务是一瞬间执行的-invokeAll 也会触发拒绝，除非任务执行的速度比 for 循环调用底层的 execute 的速度还要快。</p>
<p>如果有得选，我们批量执行任务应该尽量采用 invokeAll，因为它带有这些特殊的代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                                         <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (tasks == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(tasks.size());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">done</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks)<br>                futures.add(newTaskFor(t));<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> futures.size();<br><br>            <span class="hljs-comment">// Interleave time checks and calls to execute in case</span><br>            <span class="hljs-comment">// executor doesn&#x27;t have any/much parallelism.</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                execute((Runnable)futures.get(i));<br>                nanos = deadline - System.nanoTime();<br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> futures;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                Future&lt;T&gt; f = futures.get(i);<br>                <span class="hljs-keyword">if</span> (!f.isDone()) &#123;<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                        <span class="hljs-keyword">return</span> futures;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// FutureTask 是可以重复获取的</span><br>                        f.get(nanos, TimeUnit.NANOSECONDS);<br>                    &#125; <span class="hljs-keyword">catch</span> (CancellationException ignore) &#123;<br>                    &#125; <span class="hljs-keyword">catch</span> (ExecutionException ignore) &#123;<br>                    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>                        <span class="hljs-keyword">return</span> futures;<br>                    &#125;<br>                    nanos = deadline - System.nanoTime();<br>                &#125;<br>            &#125;<br>            done = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> futures;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (!done)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = futures.size(); i &lt; size; i++)                <br>                    <span class="hljs-comment">// 我们不鼓励 cancel java 线程，但是可以，而且鼓励 cancel Future</span><br>                    futures.get(i).cancel(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="两种针对-runnable-的-submit">两种针对 Runnable 的 submit</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通 submit(Runnable) - Future.get() 返回 null</span><br>Future&lt;?&gt; future3 = executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;普通任务&quot;</span>));<br><span class="hljs-type">Object</span> <span class="hljs-variable">result3</span> <span class="hljs-operator">=</span> future3.get(); <span class="hljs-comment">// result3 == null</span><br><br><span class="hljs-comment">// submit(Runnable, T result) - Future.get() 返回指定的结果</span><br>Future&lt;String&gt; future4 = executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;带结果的任务&quot;</span>), <span class="hljs-string">&quot;自定义结果&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">result4</span> <span class="hljs-operator">=</span> future4.get(); <span class="hljs-comment">// result4 == &quot;自定义结果&quot;</span><br></code></pre></td></tr></table></figure>
<p>这里面使用到了2种适配器：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">用户层：需要 <span class="hljs-built_in">submit</span>(Runnable, T result) 这样的高级API<br>       ↓<br>适配层：RunnableAdapter 提供语义适配<br>       ↓  <br>执行层：FutureTask 提供接口适配  <br>       ↓<br>基础层：ThreadPoolExecutor 只认 <span class="hljs-built_in">execute</span>(Runnable)<br></code></pre></td></tr></table></figure>
<p>也就是说，底层的 execute 本身要求一个包含 callable + result 的 runnbale - FutureTask（向底层的 execute api 适配，向外提供 Future 的 get、cancel 等能力），但是这样的 callable 最初又要经过 RunnableAdapter 从 Runnable 得来（向上向原始的没有返回值的 Runnable 适配）。</p>
<p>想象一个国际物流系统：</p>
<ul>
<li>FutureTask：相当于报关代理，将&quot;有特殊要求的货物&quot;（Callable）转换成&quot;标准集装箱&quot;（Runnable）以便运输</li>
<li>RunnableAdapter：相当于包装服务，将&quot;普通货物&quot;（Runnable）包装成&quot;带保价标签的货物&quot;（Callable），提供额外保障</li>
</ul>
<p>两类底层调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 底层调用链</span><br><span class="hljs-comment">// 1. submit(callable) → new FutureTask(callable)</span><br><span class="hljs-comment">// 2. execute(futureTask) → futureTask.run()</span><br><span class="hljs-comment">// 3. futureTask.run() → callable.call() → return 42</span><br><span class="hljs-comment">// 4. future.get() → 42</span><br><br><span class="hljs-comment">// 底层调用链</span><br><span class="hljs-comment">// 1. submit(runnable, result) → Executors.callable(runnable, result) </span><br><span class="hljs-comment">//   → new RunnableAdapter(runnable, result)</span><br><span class="hljs-comment">// 2. new FutureTask(runnableAdapter) </span><br><span class="hljs-comment">//   → futureTask内部持有runnableAdapter</span><br><span class="hljs-comment">// 3. execute(futureTask) → futureTask.run()</span><br><span class="hljs-comment">// 4. futureTask.run() → runnableAdapter.call()</span><br><span class="hljs-comment">// 5. runnableAdapter.call() → runnable.run() + return successMessage</span><br><span class="hljs-comment">// 6. future.get() → successMessage</span><br></code></pre></td></tr></table></figure>
<h2 id="线程池如何维护自身状态">线程池如何维护自身状态</h2>
<p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>
<p>ctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，<strong>不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况</strong>。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。<strong>这里都使用的是位运算的方式，相比于基本运算，速度也会快很多</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 29</span><br>        System.out.println(COUNT_BITS);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">shifted</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 1 与 29 个 0，所以左移意味着补 0，左移一位意味着补 1 个 0，左移 29 位意味着补 29 个 0，最后得到 30 位数：100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(shifted));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> shifted - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 29个 1：11111111111111111111111111111</span><br>        System.out.println(Integer.toBinaryString(CAPACITY));<br>        <span class="hljs-comment">// 高 3 位为 1，低 29 位为 0：11100000000000000000000000000000，和 CAPACITY 低 29 位为 1，高 3 位为 0 恰好相反</span><br>        System.out.println(Integer.toBinaryString(~CAPACITY));<br>        System.out.println(Integer.toBinaryString(~CAPACITY));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// -1 意味着 32 个 1：11111111111111111111111111111111</span><br>        System.out.println(Integer.toBinaryString(-<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 3 个 1 和 29 个 0：11100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(RUNNING));<br>        <br>        <span class="hljs-comment">// 重点：从后方补 0 的算法，可以把 state 的基准位从低位移到高位，这样大数的一部分就可以拿来表示有限状态了</span><br>        <br>        <span class="hljs-comment">// 0 不管位移多少位都是 0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br>        System.out.println(Integer.toBinaryString(SHUTDOWN));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 1 和 29 个 0：100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(STOP));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 10 和 29 个 0：1000000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(TIDYING));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 11 和 29 个 0：1100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(TERMINATED));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> getCapacity();<br>        <span class="hljs-comment">// 把 CAPACITY 的补码按位与，这样高 32 位就可以被取出来</span><br>        <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; <br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> getCapacity();<br>        <span class="hljs-comment">// 低 32 位本身就是 workCount，这个 workCount 可以容纳很大的数</span><br>        <span class="hljs-keyword">return</span> c &amp; CAPACITY; <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123;<br>        <span class="hljs-keyword">return</span> rs | wc; <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCapacity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">shifted</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> shifted - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> CAPACITY;<br>    &#125;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">运行状态</th>
<th style="text-align:center">状态描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RUNNING</td>
<td style="text-align:center">能接受新提交的任务，并且也能处理阻塞队列中的任务。</td>
</tr>
<tr>
<td style="text-align:center">SHUTDOWN</td>
<td style="text-align:center">关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。</td>
</tr>
<tr>
<td style="text-align:center">STOP</td>
<td style="text-align:center">不能接受新任务，【也不处理队列中的任务，会中断正在处理任务的线程。】增加了两条措施，是一个更严厉的状态，理论上只要线程被中断完，线程池就可以走向关闭</td>
</tr>
<tr>
<td style="text-align:center">TIDYING</td>
<td style="text-align:center">所有的任务都已终止了，workerCount (有效线程数) 为0，这个状态的意思不是整理中，而是整理完了。</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td style="text-align:center">在terminated() 方法执行完后进入该状态。</td>
</tr>
</tbody>
</table>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程池生命周期.png"></p>
<p>其中 running 既是初始态，也是中间态，所以才有<code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</code>作为初始化块的一部分。</p>
<h3 id="尝试关闭线程池">尝试关闭线程池</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Transitions to TERMINATED state if either (SHUTDOWN and pool</span><br><span class="hljs-comment"> * and queue empty) or (STOP and pool empty).  If otherwise</span><br><span class="hljs-comment"> * eligible to terminate but workerCount is nonzero, interrupts an</span><br><span class="hljs-comment"> * idle worker to ensure that shutdown signals propagate. This</span><br><span class="hljs-comment"> * method must be called following any action that might make</span><br><span class="hljs-comment"> * termination possible -- reducing worker count or removing tasks</span><br><span class="hljs-comment"> * from the queue during shutdown. The method is non-private to</span><br><span class="hljs-comment"> * allow access from ScheduledThreadPoolExecutor.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 注意这里有个自旋</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">//  尝试把把本线程池的状态改成 TIDYING -&gt; TERMINATED，所以正在 running、正在 shutdown 但队列未空、已经高于 TIDYING 都直接返回</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 只要 wc&gt;0，就关闭并只关闭一个空闲线程（看起来这里是假设本方法通常是由线程退出来触发的，所以此处能够关掉一个就直接退出）</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果一个 worker 都没有了，就真的关闭本线程池</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这个地方做了一个多余操作，把 TIDYING 做一个 ctlOf 转化            // 先置为 TIDYING</span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 通常是一个空钩子方法，这两个状态之间就差了一个钩子设计</span><br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 再设置为 TERMINATED</span><br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    <span class="hljs-comment">// 已关闭才做 signalAll()</span><br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>        <span class="hljs-comment">// 这里失败，下次再从外部进入 TIDYING -&gt; TERMINATED 的循环</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="线程池如何管理任务">线程池如何管理任务</h2>
<p>每个线程池的 Worker 管理的实质上是 FutureTask，它既是<code>Callable</code>（确切地说，wrap Callable），也是<code>Future</code>（一个最完美的任务是一个<code>RunnableFuture&lt;V&gt;</code>，用成员变量来帮助 <code>Runnable</code>来保存一个<code>Callable</code>的返回值，以供<code>Future</code>使用）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个可以取消的计算。</span><br><span class="hljs-comment">// 基本上只能完成一次，除非执行 runAndReset，执行完成不能再 cancel</span><br><span class="hljs-comment">// 只有计算执行完成 get 才可以获取结果，之前必然阻塞</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A cancellable asynchronous computation.  This class provides a base</span><br><span class="hljs-comment"> * implementation of &#123;<span class="hljs-doctag">@link</span> Future&#125;, with methods to start and cancel</span><br><span class="hljs-comment"> * a computation, query to see if the computation is complete, and</span><br><span class="hljs-comment"> * retrieve the result of the computation.  The result can only be</span><br><span class="hljs-comment"> * retrieved when the computation has completed; the &#123;<span class="hljs-doctag">@code</span> get&#125;</span><br><span class="hljs-comment"> * methods will block if the computation has not yet completed.  Once</span><br><span class="hljs-comment"> * the computation has completed, the computation cannot be restarted</span><br><span class="hljs-comment"> * or cancelled (unless the computation is invoked using</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #runAndReset&#125;).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;A &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; can be used to wrap a &#123;<span class="hljs-doctag">@link</span> Callable&#125; or</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Runnable&#125; object.  Because &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; implements</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> Runnable&#125;, a &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; can be submitted to an</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Executor&#125; for execution.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;In addition to serving as a standalone class, this class provides</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> protected&#125; functionality that may be useful when creating</span><br><span class="hljs-comment"> * customized task classes.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Doug Lea</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;V&gt; The result type returned by this FutureTask&#x27;s &#123;<span class="hljs-doctag">@code</span> get&#125; methods</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>线程池使用一个把 Runnable 转变为 Callable 的适配器（Callable 转 Runnable 理论上也是容易做到的，但应该没有必要转换），来兼容把 Runnable 传进 submit 的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 把 runnable 和一个勉强的 result 包装成一个 callable，分三步</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>        <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>        <span class="hljs-built_in">this</span>.state = NEW;       <span class="hljs-comment">// ensure visibility of callable</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="hljs-title function_">callable</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt;(task, result);<br>    &#125;<br>    <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">final</span> Runnable task;<br>        <span class="hljs-keyword">final</span> T result;<br>        RunnableAdapter(Runnable task, T result) &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>            <span class="hljs-built_in">this</span>.result = result;<br>        &#125;<br>        <span class="hljs-comment">// 注意，这个 call() 是不抛出异常的，所以对 Java 而言，子类的签名里可以不继续抛出父类声明的异常，</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>            task.run();<br>            <span class="hljs-comment">// 组合逻辑在这一层</span><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>FutureTask 实现了 RunnableFuture，它本质上是一个携带 Runnable 和 state 的任务。</p>
<p>首先看它的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The run state of this task, initially NEW.  The run state</span><br><span class="hljs-comment">     * transitions to a terminal state only in methods set,</span><br><span class="hljs-comment">     * setException, and cancel.  During completion, state may take on</span><br><span class="hljs-comment">     * transient values of COMPLETING (while outcome is being set) or</span><br><span class="hljs-comment">     * INTERRUPTING (only while interrupting the runner to satisfy a</span><br><span class="hljs-comment">     * cancel(true)). Transitions from these intermediate to final</span><br><span class="hljs-comment">     * states use cheaper ordered/lazy writes because values are unique</span><br><span class="hljs-comment">     * and cannot be further modified.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Possible state transitions:</span><br><span class="hljs-comment">     * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="hljs-comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="hljs-comment">     * NEW -&gt; CANCELLED</span><br><span class="hljs-comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure>
<p><strong>FutureTask 状态转换图</strong>：</p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; NEW: 任务创建
    
    NEW --&gt; COMPLETING: call()执行完成
    NEW --&gt; CANCELLED: cancel(false)
    NEW --&gt; INTERRUPTING: cancel(true)
    
    COMPLETING --&gt; NORMAL: 正常结果设置完成
    COMPLETING --&gt; EXCEPTIONAL: 异常结果设置完成
    
    INTERRUPTING --&gt; INTERRUPTED: 中断完成
    
    NORMAL --&gt; [*]: 终态
    EXCEPTIONAL --&gt; [*]: 终态
    CANCELLED --&gt; [*]: 终态
    INTERRUPTED --&gt; [*]: 终态
    
    note right of NEW: 初始状态，任务可被取消
    note right of COMPLETING: 瞬态，正在设置结果
    note right of INTERRUPTING: 瞬态，正在中断runner</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>值得一提的是，任务的中间状态是一个瞬态，它非常的短暂。而且任务的中间态并不代表任务正在执行，而是任务已经执行完了，正在设置最终的返回结果，所以可以这么说：<br>
只要state不处于 NEW 状态，就说明任务已经执行完毕。<br>
注意，<strong>这里的执行完毕是指传入的Callable对象的call方法执行完毕</strong>，<strong>或者抛出了异常</strong>。所以这里的COMPLETING的名字显得有点迷惑性，它并不意味着任务正在执行中，而意味着call方法已经执行完毕，正在设置任务执行的结果。</p>
</blockquote>
<p>换言之，只有 NEW 状态才是 cancellable 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Doug Lea 本身比较喜欢使用普通整数来制造状态机</span><br><span class="hljs-comment">// COMPLETING 和 INTERRUPTING 是 set state 和取消任务的中间态</span><br>    <br>    <span class="hljs-comment">/** The underlying callable; nulled out after running */</span><br>    <span class="hljs-keyword">private</span> Callable&lt;V&gt; callable;<br>    <br>    <span class="hljs-comment">// 异常和输出使用同一个 outcome，所以 outcome 不能是泛型，必须是 object</span><br>    <span class="hljs-comment">// 它是非 volatile 的，需要巧妙利用 state 读写</span><br>    <span class="hljs-comment">// </span><br>    <span class="hljs-comment">// **happens-before 传递性分析**：outcome 的可见性是通过 state 的 volatile 写-读来保证的。</span><br>    <span class="hljs-comment">// 这依赖于 JMM 的 happens-before 传递性：</span><br>    <span class="hljs-comment">// 1. outcome = v happens-before state = NORMAL（程序顺序规则：同一线程内，前面的操作 happens-before 后面的操作）</span><br>    <span class="hljs-comment">// 2. state = NORMAL happens-before 读取 state（volatile 规则：volatile 写 happens-before 后续的 volatile 读）</span><br>    <span class="hljs-comment">// 3. 因此，outcome = v happens-before 读取 outcome（传递性）</span><br>    <span class="hljs-comment">// 这就是为什么 outcome 不需要声明为 volatile，只要保证在写 outcome 之后再写 volatile state，</span><br>    <span class="hljs-comment">// 在读 volatile state 之后再读 outcome，就能保证 outcome 的可见性。</span><br>    <span class="hljs-comment">/** The result to return or exception to throw from get() */</span><br>    <span class="hljs-keyword">private</span> Object outcome; <span class="hljs-comment">// non-volatile, protected by state reads/writes</span><br>    <br>    <span class="hljs-comment">/** The thread running the callable; CASed during run() */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread runner;<br>    <br>    <span class="hljs-comment">/** Treiber stack of waiting threads */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WaitNode waiters;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.callable = callable;<br>    <span class="hljs-comment">// ensure visibility of callable</span><br>    <span class="hljs-built_in">this</span>.state = NEW;       <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>            <span class="hljs-comment">// 把 volatile 变量写在写语句的最后，写在读语句的最前面，类似 monitorEnter 和 monitorExit 的语义，可以保证可见性</span><br>    <span class="hljs-comment">// ensure visibility of callable</span><br>    <span class="hljs-built_in">this</span>.state = NEW;       <br>&#125;<br></code></pre></td></tr></table></figure>
<p>它的状态管理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state &gt;= CANCELLED;<br>    &#125;<br>    <span class="hljs-comment">// 只要不是 NEW 就是完成了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state != NEW;<br>    &#125;<br><br>    <br>    <span class="hljs-comment">// 移除并通知所有等待线程，</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Removes and signals all waiting threads, invokes done(), and</span><br><span class="hljs-comment">     * nulls out callable.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishCompletion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// assert state &gt; COMPLETING;</span><br>        <span class="hljs-comment">// 漂亮的声明和比对写法</span><br>        <span class="hljs-keyword">for</span> (WaitNode q; (q = waiters) != <span class="hljs-literal">null</span>;) &#123;<br>            <span class="hljs-comment">// 在 for 循环里用 cas 把 waiter 置空</span><br>            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q, <span class="hljs-literal">null</span>)) &#123;        <br>                <span class="hljs-comment">// 在内层循环里把当前线程和 futureTask 的关系移除，并且</span><br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    <span class="hljs-comment">// 在这个内存循环里面，要做的就是一个个遍历链表的 next，unpark 掉它们，并且 help gc</span><br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q.thread;<br>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                        q.thread = <span class="hljs-literal">null</span>;<br>                        LockSupport.unpark(t);<br>                    &#125;<br>                    <span class="hljs-type">WaitNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> q.next;<br>                    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>                        <span class="hljs-keyword">break</span>;<br>                    q.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// unlink to help gc</span><br>                    q = next;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        done();<br>        <span class="hljs-comment">// 此处就是上面的 nulled 的意思了，任务进入终态以后 callable 也可以被回收</span><br>        callable = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// to reduce footprint</span><br>    &#125;<br>    <br><span class="hljs-comment">// 通过使 permit 变成 available 的方式，使这个线程从 blocked 状态变成非 blocked 状态，或者下次调用 park 的时候非阻塞。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>            UNSAFE.unpark(thread);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>实际被工作线程调度的 run 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 如果不等于 new 或者 cas 把线程绑定到本 future task 上，就直接退出，这其实是一种幂等</span><br>    <span class="hljs-comment">// runner 的获取是从上下文里获得的</span><br>    <span class="hljs-keyword">if</span> (state != NEW ||<br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                     <span class="hljs-literal">null</span>, Thread.currentThread()))<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Callable&lt;V&gt; c = callable;<br>        <span class="hljs-comment">// 只有状态和 callable 完备才能把值设进来</span><br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>            V result;<br>            <span class="hljs-type">boolean</span> ran;<br>            <span class="hljs-keyword">try</span> &#123;<br>                result = c.call();<br>                ran = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                result = <span class="hljs-literal">null</span>;<br>                ran = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// 如果 run 出异常，就进入 setException 终态方法</span><br>                setException(ex);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ran)<br>                <span class="hljs-comment">// 否则，set result，走入另一种终态</span><br>                set(result);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// runner must be non-null until state is settled to</span><br>        <span class="hljs-comment">// prevent concurrent calls to run()</span><br>        <span class="hljs-comment">// 执行完要把 runner 置空，这样上面那个 cas 对其他线程而言就会失败</span><br>        runner = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// state must be re-read after nulling runner to prevent</span><br>        <span class="hljs-comment">// leaked interrupts</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>            <span class="hljs-comment">// 可能有其他线程在 interrupting，在这里实现一套等待到  interrupted 的自旋 yield</span><br>            handlePossibleCancellationInterrupt(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>run 有一个重跑版本，这个版本会重复执行，但不会影响 get 的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Executes the computation without setting its result, and then</span><br><span class="hljs-comment"> * resets this future to initial state, failing to do so if the</span><br><span class="hljs-comment"> * computation encounters an exception or is cancelled.  This is</span><br><span class="hljs-comment"> * designed for use with tasks that intrinsically execute more</span><br><span class="hljs-comment"> * than once.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if successfully run and reset</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runAndReset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (state != NEW ||<br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                     <span class="hljs-literal">null</span>, Thread.currentThread()))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ran</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Callable&lt;V&gt; c = callable;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; s == NEW) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                c.call(); <span class="hljs-comment">// don&#x27;t set result</span><br>                ran = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                setException(ex);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// runner must be non-null until state is settled to</span><br>        <span class="hljs-comment">// prevent concurrent calls to run()</span><br>        runner = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// state must be re-read after nulling runner to prevent</span><br>        <span class="hljs-comment">// leaked interrupts</span><br>        s = state;<br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>            handlePossibleCancellationInterrupt(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ran &amp;&amp; s == NEW;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 FutureTask 里有三类终态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V v)</span> &#123;<br>    <span class="hljs-comment">// 在两个 CAS 操作之间夹逼一个 outcome</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>        outcome = v;<br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, NORMAL); <span class="hljs-comment">// final state</span><br>        finishCompletion();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 几乎等同于 set，但夹逼的是把 Throwable 设进 outcome 里面</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setException</span><span class="hljs-params">(Throwable t)</span> &#123;<br>    <span class="hljs-comment">// 注意这里只能把 callable 内部的异常设置进 outcome 里面，如果本服务发生了 interrupt，则这里必然失败</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>        outcome = t;<br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="hljs-comment">// final state</span><br>        finishCompletion();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 从这个方法可以看出，中断也是 cancel 的一种</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br>    <span class="hljs-comment">// 在一个布尔表达式里面表达顺序结构</span><br>    <span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp;<br>          UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW,<br>              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br>        <span class="hljs-comment">// 只能从 new 迁移到 INTERRUPTING 或者 CANCELLED，只要 cas 不成功，就返回 false。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// in case call to interrupt throws exception</span><br>        <span class="hljs-comment">// 如果取消带有中断标志</span><br>        <span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;<br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 强制中断这个线程</span><br>                    t.interrupt();<br>            &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// final state</span><br>                <span class="hljs-comment">// 不使用 cas，把本应用的状态设为已中断</span><br>                UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, INTERRUPTED);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 所有的终态操作都有的一个操作</span><br>        finishCompletion();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果程序进入终态，则 get 终于可以得到合理的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// get 的阻塞部分交给 awaitDone，而取值部分交给 report</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-comment">// 比对状态</span><br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>        <span class="hljs-comment">// 进入计时的 awaitDone 流程，这里的计时结果是带有状态的，0L 意味着无限计时。</span><br>        s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    <span class="hljs-comment">// 进入 report 流程</span><br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br>   <br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>    <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>        (s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中等待流程见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Awaits completion or aborts on interrupt or timeout.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> timed true if use timed waits</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> nanos time to wait, if timed</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> state upon completion</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>     <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;<br>     <span class="hljs-type">WaitNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>     <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>     <span class="hljs-comment">// 这里通过自旋来实现计时等待</span><br>     <span class="hljs-keyword">for</span> (;;) &#123;<br>         <span class="hljs-comment">// 如果本线程被中断，则释放所有的 get 线程，然后抛出一个中断异常，这里引入了一个经典的设计模式，在 waiting  状态内发生 interrupt 的地方，响应中断的方式是清空中断位（而不是简单地 swap），并抛出中断异常</span><br>         <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>             <span class="hljs-comment">// 如果中断了（不正常退出），清空 waiter</span><br>             removeWaiter(q);<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>         &#125;<br><br>         <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>         <span class="hljs-comment">// 进入终态，返回 s</span><br>         <span class="hljs-keyword">if</span> (s &gt; COMPLETING) &#123;<br>             <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>)<br>                 <span class="hljs-comment">// 清空等待栈的线程，waitnode 可以功成身退了，但只清空当前的 q 的 thread，并不做完整的 removeWaiter</span><br>                 q.thread = <span class="hljs-literal">null</span>;<br>             <span class="hljs-keyword">return</span> s;<br>         &#125;<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == COMPLETING) <span class="hljs-comment">// cannot time out yet</span><br>             <span class="hljs-comment">// no-op</span><br>             Thread.<span class="hljs-keyword">yield</span>();<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)<br>             <span class="hljs-comment">// 这里生成了一个 waitnode，注意，这里的调用栈是等待线程 get -&gt; awaitDone()，所以此处会捕获get 线程进 waitnode 里，在本循环里产生了第一个 q 的节点。</span><br>             q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();<br>             <span class="hljs-comment">// 一般第一轮循环q 总是为 null 的，只有第二轮进入这个地方的，才会进入这个分支，而且这里可能会失败，如果失败也，这时候就会把</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)<br>             <span class="hljs-comment">// 如果 q 不为空，且没有入队，则首先把当前的 waiters 放到当前的 q.next 里，然后把 q 放到本类型的 waiters 里（用新 q 代替老 waiter）</span><br>             queued = UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                                                  q.next = waiters, q);<br>         <span class="hljs-comment">// 前面两轮循环都走过了（前面两轮必须使 q 不为空，queued变成 true，才进入接下来的循环），接下来就进入 park 或者 parkNanos，看看会不会再被唤醒了</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;<br>             nanos = deadline - System.nanoTime();<br>             <span class="hljs-comment">// 如果超时了（bu），清空 waiter</span><br>             <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                 removeWaiter(q);<br>                 <span class="hljs-keyword">return</span> state;<br>             &#125;<br>             <span class="hljs-comment">// 如果没有超时，本线程先驻留一下，驻留完进入下一个循环</span><br>             LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>         &#125;<br>         <span class="hljs-keyword">else</span><br>             <span class="hljs-comment">// 否则，无限驻留，直到下一个循环。下一个循环必须由 finishCompletion 里的 LockSupport.unpark(t); 触发</span><br>             LockSupport.park(<span class="hljs-built_in">this</span>);<br>     &#125;<br> &#125;<br> <br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Simple linked list nodes to record waiting threads in a Treiber</span><br><span class="hljs-comment">  * stack.  See other classes such as Phaser and SynchronousQueue</span><br><span class="hljs-comment">  * for more detailed explanation.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span> &#123;<br>     <span class="hljs-keyword">volatile</span> Thread thread;<br>     <span class="hljs-keyword">volatile</span> WaitNode next;<br>     WaitNode() &#123; thread = Thread.currentThread(); &#125;<br> &#125;<br> <br> <span class="hljs-comment">// 解掉链表，help gc</span><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Tries to unlink a timed-out or interrupted wait node to avoid</span><br><span class="hljs-comment">  * accumulating garbage.  Internal nodes are simply unspliced</span><br><span class="hljs-comment">  * without CAS since it is harmless if they are traversed anyway</span><br><span class="hljs-comment">  * by releasers.  To avoid effects of unsplicing from already</span><br><span class="hljs-comment">  * removed nodes, the list is retraversed in case of an apparent</span><br><span class="hljs-comment">  * race.  This is slow when there are a lot of nodes, but we don&#x27;t</span><br><span class="hljs-comment">  * expect lists to be long enough to outweigh higher-overhead</span><br><span class="hljs-comment">  * schemes.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeWaiter</span><span class="hljs-params">(WaitNode node)</span> &#123;<br>     <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>         node.thread = <span class="hljs-literal">null</span>;<br>         retry:<br>         <span class="hljs-keyword">for</span> (;;) &#123;          <span class="hljs-comment">// restart on removeWaiter race</span><br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">WaitNode</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, q = waiters, s; q != <span class="hljs-literal">null</span>; q = s) &#123;<br>                 s = q.next;<br>                 <span class="hljs-keyword">if</span> (q.thread != <span class="hljs-literal">null</span>)<br>                     pred = q;<br>                 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>                     pred.next = s;<br>                     <span class="hljs-keyword">if</span> (pred.thread == <span class="hljs-literal">null</span>) <span class="hljs-comment">// check for race</span><br>                         <span class="hljs-keyword">continue</span> retry;<br>                 &#125;<br>                 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                                                       q, s))<br>                     <span class="hljs-keyword">continue</span> retry;<br>             &#125;<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>然后就把outcome 通过 report 传出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里使用 object 转 v，必然带来 warning</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;<br>    <span class="hljs-keyword">if</span> (s == NORMAL)<br>        <span class="hljs-keyword">return</span> (V)x;<br>    <span class="hljs-keyword">if</span> (s &gt;= CANCELLED)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<br>    <span class="hljs-comment">// 我们在外部 get catch 的异常就是从这里抛出的。注意这个转型的用意，get 只有一个固定的执行异常，就是这个异常，表明错误来自计算过程内部</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable)x);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="任务执行">任务执行</h3>
<h4 id="提交任务调度">提交任务调度</h4>
<ol>
<li>首先检测线程池运行状态，如果不是 RUNNING，则直接拒绝，线程池要保证在 RUNNING 的状态下执行任务。</li>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p><img src="%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png" alt="任务调度流程.png"></p>
<h4 id="任务缓冲">任务缓冲</h4>
<p>任务缓冲模块是线程池能够管理任务的核心部分。<strong>线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦</strong>，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是**（阻塞的本质即为此）：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。**阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="阻塞队列的工作原理.png"></p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ArrayBlockingQueue</td>
<td style="text-align:center">一个用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序。<strong>支持公平锁和非公平锁</strong>。</td>
</tr>
<tr>
<td style="text-align:center">DelayQueue</td>
<td style="text-align:center">一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。</td>
</tr>
<tr>
<td style="text-align:center">LinkedBlockingDeque</td>
<td style="text-align:center">一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，<strong>可以将锁的竞争最多降到一半</strong>。</td>
</tr>
<tr>
<td style="text-align:center">LinkedBlockingQueue</td>
<td style="text-align:center">一个由链表结构组成的有界队列，此队列按照先进先出(FIFO)的原则对元素进行排序。此队列的默认长度为Integer.MAX_VALUE，<strong>所以默认创建的该队列有容量危险</strong>。</td>
</tr>
<tr>
<td style="text-align:center">LinkedTransferQueue</td>
<td style="text-align:center">一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</td>
</tr>
<tr>
<td style="text-align:center">PriorityBlockingQueue</td>
<td style="text-align:center">一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</td>
</tr>
<tr>
<td style="text-align:center">SynchronousQueue</td>
<td style="text-align:center">一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，<strong>线程空闲了60秒后会被回收</strong>。</td>
</tr>
</tbody>
</table>
<p><strong>阻塞队列选择决策流程图：</strong></p>
<pre><code class="hljs mermaid">flowchart TD
    A[选择阻塞队列] --&gt; B&#123;是否需要有界队列?&#125;
    B --&gt;|是| C&#123;是否需要公平性?&#125;
    B --&gt;|否| D&#123;是否需要优先级?&#125;
    
    C --&gt;|是| E[ArrayBlockingQueue&lt;br/&gt;公平模式]
    C --&gt;|否| F&#123;数组还是链表?&#125;
    
    F --&gt;|数组-内存连续| G[ArrayBlockingQueue&lt;br/&gt;非公平模式]
    F --&gt;|链表-动态扩展| H[LinkedBlockingQueue&lt;br/&gt;指定容量]
    
    D --&gt;|是| I[PriorityBlockingQueue]
    D --&gt;|否| J&#123;是否需要延迟?&#125;
    
    J --&gt;|是| K[DelayQueue]
    J --&gt;|否| L&#123;是否需要直接传递?&#125;
    
    L --&gt;|是| M[SynchronousQueue]
    L --&gt;|否| N[LinkedBlockingQueue&lt;br/&gt;默认容量]
    
    style E fill:#90EE90
    style G fill:#90EE90
    style H fill:#87CEEB
    style I fill:#FFB6C1
    style K fill:#DDA0DD
    style M fill:#F0E68C
    style N fill:#87CEEB</code></pre>
<p><strong>各种阻塞队列的使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueueExamples</span> &#123;<br>    <br>    <span class="hljs-comment">// ==================== 1. ArrayBlockingQueue ====================</span><br>    <span class="hljs-comment">// 特点：数组实现、有界、支持公平/非公平锁</span><br>    <span class="hljs-comment">// 适用场景：生产消费速率相近，需要控制内存使用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arrayBlockingQueueExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建容量为10的有界队列，使用公平锁</span><br>        BlockingQueue&lt;String&gt; fairQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>);<br>        <br>        <span class="hljs-comment">// 创建容量为10的有界队列，使用非公平锁（默认，性能更好）</span><br>        BlockingQueue&lt;String&gt; unfairQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-literal">false</span>);<br>        <br>        <span class="hljs-comment">// 配合线程池使用 - 适合CPU密集型任务</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">4</span>,                          <span class="hljs-comment">// corePoolSize</span><br>            <span class="hljs-number">8</span>,                          <span class="hljs-comment">// maximumPoolSize</span><br>            <span class="hljs-number">60L</span>, TimeUnit.SECONDS,      <span class="hljs-comment">// keepAliveTime</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),  <span class="hljs-comment">// 有界队列，防止OOM</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="hljs-comment">// 队列满时由调用者执行</span><br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 2. LinkedBlockingQueue ====================</span><br>    <span class="hljs-comment">// 特点：链表实现、可选有界、读写分离锁</span><br>    <span class="hljs-comment">// 适用场景：生产消费速率不均，需要缓冲</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkedBlockingQueueExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 有界队列（推荐）</span><br>        BlockingQueue&lt;String&gt; boundedQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>);<br>        <br>        <span class="hljs-comment">// 无界队列（危险！可能导致OOM）</span><br>        BlockingQueue&lt;String&gt; unboundedQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 配合线程池使用 - 适合IO密集型任务</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">10</span>,                         <span class="hljs-comment">// corePoolSize</span><br>            <span class="hljs-number">10</span>,                         <span class="hljs-comment">// maximumPoolSize（与core相同，因为队列无界时max无意义）</span><br>            <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,  <span class="hljs-comment">// keepAliveTime</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">5000</span>),  <span class="hljs-comment">// 一定要指定容量！</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()<br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 3. SynchronousQueue ====================</span><br>    <span class="hljs-comment">// 特点：不存储元素、直接传递、支持公平/非公平</span><br>    <span class="hljs-comment">// 适用场景：任务需要立即执行，不需要缓冲</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronousQueueExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 非公平模式（默认，性能更好）</span><br>        BlockingQueue&lt;String&gt; unfairQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 公平模式</span><br>        BlockingQueue&lt;String&gt; fairQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;(<span class="hljs-literal">true</span>);<br>        <br>        <span class="hljs-comment">// 配合线程池使用 - CachedThreadPool的实现原理</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">0</span>,                          <span class="hljs-comment">// corePoolSize = 0</span><br>            Integer.MAX_VALUE,          <span class="hljs-comment">// maximumPoolSize = 无限</span><br>            <span class="hljs-number">60L</span>, TimeUnit.SECONDS,      <span class="hljs-comment">// 空闲60秒回收</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;(),   <span class="hljs-comment">// 直接传递，不缓冲</span><br>            Executors.defaultThreadFactory(),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()<br>        );<br>        <span class="hljs-comment">// 注意：这种配置可能创建大量线程，需谨慎使用</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 4. PriorityBlockingQueue ====================</span><br>    <span class="hljs-comment">// 特点：优先级排序、无界、不保证同优先级顺序</span><br>    <span class="hljs-comment">// 适用场景：任务有优先级区分</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">priorityBlockingQueueExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 使用自然排序</span><br>        BlockingQueue&lt;Integer&gt; naturalQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 使用自定义比较器 - 按任务优先级排序</span><br>        BlockingQueue&lt;PriorityTask&gt; customQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;&gt;(<br>            <span class="hljs-number">11</span>,  <span class="hljs-comment">// 初始容量</span><br>            (t1, t2) -&gt; Integer.compare(t2.priority, t1.priority)  <span class="hljs-comment">// 优先级高的先执行</span><br>        );<br>        <br>        <span class="hljs-comment">// 配合线程池使用</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;&gt;()  <span class="hljs-comment">// 注意：无界队列</span><br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">// 优先级任务示例</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>, Comparable&lt;PriorityTask&gt; &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> priority;<br>        <span class="hljs-keyword">final</span> String name;<br>        <br>        PriorityTask(<span class="hljs-type">int</span> priority, String name) &#123;<br>            <span class="hljs-built_in">this</span>.priority = priority;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;执行任务: &quot;</span> + name + <span class="hljs-string">&quot;, 优先级: &quot;</span> + priority);<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(PriorityTask other)</span> &#123;<br>            <span class="hljs-comment">// 优先级高的排在前面</span><br>            <span class="hljs-keyword">return</span> Integer.compare(other.priority, <span class="hljs-built_in">this</span>.priority);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 5. DelayQueue ====================</span><br>    <span class="hljs-comment">// 特点：延迟获取、无界、元素必须实现Delayed接口</span><br>    <span class="hljs-comment">// 适用场景：定时任务、缓存过期、订单超时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayQueueExample</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        DelayQueue&lt;DelayedTask&gt; delayQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 添加延迟任务</span><br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedTask</span>(<span class="hljs-string">&quot;任务1&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS));<br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedTask</span>(<span class="hljs-string">&quot;任务2&quot;</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS));<br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedTask</span>(<span class="hljs-string">&quot;任务3&quot;</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS));<br>        <br>        <span class="hljs-comment">// 按延迟时间顺序获取：任务2 -&gt; 任务3 -&gt; 任务1</span><br>        <span class="hljs-keyword">while</span> (!delayQueue.isEmpty()) &#123;<br>            <span class="hljs-type">DelayedTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> delayQueue.take();  <span class="hljs-comment">// 阻塞直到有元素到期</span><br>            System.out.println(<span class="hljs-string">&quot;执行: &quot;</span> + task.name);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 延迟任务示例</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>        <span class="hljs-keyword">final</span> String name;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> expireTime;  <span class="hljs-comment">// 到期时间（纳秒）</span><br>        <br>        DelayedTask(String name, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.expireTime = System.nanoTime() + unit.toNanos(delay);<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> expireTime - System.nanoTime();<br>            <span class="hljs-keyword">return</span> unit.convert(remaining, TimeUnit.NANOSECONDS);<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br>            <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> DelayedTask) &#123;<br>                <span class="hljs-keyword">return</span> Long.compare(<span class="hljs-built_in">this</span>.expireTime, ((DelayedTask) other).expireTime);<br>            &#125;<br>            <span class="hljs-keyword">return</span> Long.compare(getDelay(TimeUnit.NANOSECONDS), other.getDelay(TimeUnit.NANOSECONDS));<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 6. LinkedBlockingDeque ====================</span><br>    <span class="hljs-comment">// 特点：双端队列、可选有界、支持FIFO和LIFO</span><br>    <span class="hljs-comment">// 适用场景：工作窃取算法、需要双端操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkedBlockingDequeExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 有界双端队列</span><br>        LinkedBlockingDeque&lt;String&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="hljs-number">100</span>);<br>        <br>        <span class="hljs-comment">// 头部操作</span><br>        deque.addFirst(<span class="hljs-string">&quot;头部元素&quot;</span>);<br>        deque.offerFirst(<span class="hljs-string">&quot;头部元素2&quot;</span>);<br>        <br>        <span class="hljs-comment">// 尾部操作</span><br>        deque.addLast(<span class="hljs-string">&quot;尾部元素&quot;</span>);<br>        deque.offerLast(<span class="hljs-string">&quot;尾部元素2&quot;</span>);<br>        <br>        <span class="hljs-comment">// 工作窃取场景：本线程从头部取，其他线程从尾部偷</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ownTask</span> <span class="hljs-operator">=</span> deque.pollFirst();      <span class="hljs-comment">// 本线程取任务</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stolenTask</span> <span class="hljs-operator">=</span> deque.pollLast();    <span class="hljs-comment">// 其他线程偷任务</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>阻塞队列性能对比：</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph 吞吐量对比
        A[SynchronousQueue] --&gt;|最高| B[直接传递无锁竞争]
        C[LinkedBlockingQueue] --&gt;|高| D[读写分离锁]
        E[ArrayBlockingQueue] --&gt;|中| F[单锁]
        G[PriorityBlockingQueue] --&gt;|低| H[堆排序开销]
    end
    
    subgraph 内存占用对比
        I[SynchronousQueue] --&gt;|最低| J[不存储元素]
        K[ArrayBlockingQueue] --&gt;|固定| L[预分配数组]
        M[LinkedBlockingQueue] --&gt;|动态| N[按需分配节点]
        O[PriorityBlockingQueue] --&gt;|动态| P[堆结构]
    end</code></pre>
<h4 id="任务拒绝">任务拒绝</h4>
<p>当线程池的任务缓存队列已满并且线程池中的线程数目达到 maximumPoolSize 时，如果还有任务到来就会采取任务拒绝策略。</p>
<p><strong>拒绝策略触发流程：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client as 客户端
    participant TPE as ThreadPoolExecutor
    participant Queue as 阻塞队列
    participant Handler as RejectedExecutionHandler
    
    Client-&gt;&gt;TPE: execute(task)
    TPE-&gt;&gt;TPE: 检查线程数 &lt; corePoolSize?
    
    alt 线程数 &lt; corePoolSize
        TPE-&gt;&gt;TPE: 创建核心线程执行
    else 线程数 &gt;= corePoolSize
        TPE-&gt;&gt;Queue: offer(task)
        alt 队列未满
            Queue--&gt;&gt;TPE: true
            TPE--&gt;&gt;Client: 任务入队成功
        else 队列已满
            Queue--&gt;&gt;TPE: false
            TPE-&gt;&gt;TPE: 检查线程数 &lt; maximumPoolSize?
            alt 线程数 &lt; maximumPoolSize
                TPE-&gt;&gt;TPE: 创建非核心线程执行
            else 线程数 &gt;= maximumPoolSize
                TPE-&gt;&gt;Handler: rejectedExecution(task, executor)
                Note over Handler: 执行拒绝策略
            end
        end
    end</code></pre>
<p><strong>四种内置拒绝策略详解：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RejectionPolicyExamples</span> &#123;<br>    <br>    <span class="hljs-comment">// ==================== 1. AbortPolicy（默认策略）====================</span><br>    <span class="hljs-comment">// 行为：直接抛出 RejectedExecutionException</span><br>    <span class="hljs-comment">// 适用场景：需要明确感知任务被拒绝，由调用方决定如何处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abortPolicyExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()  <span class="hljs-comment">// 默认策略</span><br>        );<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 提交3个任务：1个执行中，1个在队列，第3个会被拒绝</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>                executor.execute(() -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                        System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + taskId + <span class="hljs-string">&quot;完成&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>            <span class="hljs-comment">// 捕获拒绝异常，可以记录日志、降级处理等</span><br>            System.err.println(<span class="hljs-string">&quot;任务被拒绝: &quot;</span> + e.getMessage());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            executor.shutdown();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 2. CallerRunsPolicy ====================</span><br>    <span class="hljs-comment">// 行为：由提交任务的线程直接执行该任务</span><br>    <span class="hljs-comment">// 适用场景：不允许丢弃任务，可以接受调用线程被阻塞</span><br>    <span class="hljs-comment">// 优点：提供了一种简单的反压机制</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callerRunsPolicyExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()<br>        );<br>        <br>        System.out.println(<span class="hljs-string">&quot;主线程: &quot;</span> + Thread.currentThread().getName());<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.execute(() -&gt; &#123;<br>                <span class="hljs-comment">// 第3个任务会在主线程中执行</span><br>                System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + taskId + <span class="hljs-string">&quot;在线程&quot;</span> + <br>                    Thread.currentThread().getName() + <span class="hljs-string">&quot;中执行&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <br>        executor.shutdown();<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 3. DiscardPolicy ====================</span><br>    <span class="hljs-comment">// 行为：静默丢弃被拒绝的任务，不抛出异常</span><br>    <span class="hljs-comment">// 适用场景：允许丢弃任务，且不需要知道任务被丢弃</span><br>    <span class="hljs-comment">// 警告：可能导致任务静默丢失，难以排查问题</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discardPolicyExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardPolicy()<br>        );<br>        <br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">completedCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.execute(() -&gt; &#123;<br>                completedCount.incrementAndGet();<br>                System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + taskId + <span class="hljs-string">&quot;完成&quot;</span>);<br>            &#125;);<br>        &#125;<br>        <br>        executor.shutdown();<br>        <span class="hljs-keyword">try</span> &#123;<br>            executor.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 只有部分任务完成，其他被静默丢弃</span><br>        System.out.println(<span class="hljs-string">&quot;完成任务数: &quot;</span> + completedCount.get() + <span class="hljs-string">&quot;/10&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 4. DiscardOldestPolicy ====================</span><br>    <span class="hljs-comment">// 行为：丢弃队列中最老的任务，然后重新尝试提交当前任务</span><br>    <span class="hljs-comment">// 适用场景：新任务比旧任务更重要</span><br>    <span class="hljs-comment">// 警告：可能导致某些任务永远无法执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discardOldestPolicyExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy()<br>        );<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.execute(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;执行任务&quot;</span> + taskId);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;);<br>            System.out.println(<span class="hljs-string">&quot;提交任务&quot;</span> + taskId);<br>        &#125;<br>        <br>        executor.shutdown();<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 5. 自定义拒绝策略 ====================</span><br>    <span class="hljs-comment">// 适用场景：需要自定义处理逻辑，如记录日志、持久化、降级等</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customPolicyExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 自定义策略：记录日志 + 持久化到数据库</span><br>        <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">customHandler</span> <span class="hljs-operator">=</span> (runnable, executor) -&gt; &#123;<br>            <span class="hljs-comment">// 1. 记录日志</span><br>            System.err.println(<span class="hljs-string">&quot;任务被拒绝: &quot;</span> + runnable.toString());<br>            System.err.println(<span class="hljs-string">&quot;线程池状态 - 活跃线程: &quot;</span> + executor.getActiveCount() <br>                + <span class="hljs-string">&quot;, 队列大小: &quot;</span> + executor.getQueue().size());<br>            <br>            <span class="hljs-comment">// 2. 可以选择持久化到数据库或消息队列</span><br>            <span class="hljs-comment">// saveToDatabase(runnable);</span><br>            <span class="hljs-comment">// sendToMQ(runnable);</span><br>            <br>            <span class="hljs-comment">// 3. 可以选择在新线程中执行（注意：可能创建过多线程）</span><br>            <span class="hljs-comment">// new Thread(runnable).start();</span><br>            <br>            <span class="hljs-comment">// 4. 可以选择阻塞等待队列有空位</span><br>            <span class="hljs-comment">// try &#123;</span><br>            <span class="hljs-comment">//     executor.getQueue().put(runnable);</span><br>            <span class="hljs-comment">// &#125; catch (InterruptedException e) &#123;</span><br>            <span class="hljs-comment">//     Thread.currentThread().interrupt();</span><br>            <span class="hljs-comment">// &#125;</span><br>            <br>            <span class="hljs-comment">// 5. 也可以抛出自定义异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;自定义拒绝: 线程池已满&quot;</span>);<br>        &#125;;<br>        <br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>),<br>            customHandler<br>        );<br>        <br>        <span class="hljs-comment">// 使用自定义策略的线程池</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>                executor.execute(() -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;捕获到自定义拒绝异常: &quot;</span> + e.getMessage());<br>        &#125;<br>        <br>        executor.shutdown();<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 6. 生产环境推荐策略 ====================</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadPoolExecutor <span class="hljs-title function_">createProductionExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 生产环境推荐：自定义策略 + 监控 + 降级</span><br>        <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">productionHandler</span> <span class="hljs-operator">=</span> (runnable, executor) -&gt; &#123;<br>            <span class="hljs-comment">// 1. 增加监控指标</span><br>            <span class="hljs-comment">// Metrics.counter(&quot;threadpool.rejected&quot;).increment();</span><br>            <br>            <span class="hljs-comment">// 2. 记录详细日志</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">taskInfo</span> <span class="hljs-operator">=</span> runnable.toString();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">queueSize</span> <span class="hljs-operator">=</span> executor.getQueue().size();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">activeCount</span> <span class="hljs-operator">=</span> executor.getActiveCount();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">poolSize</span> <span class="hljs-operator">=</span> executor.getPoolSize();<br>            <br>            System.err.printf(<span class="hljs-string">&quot;任务被拒绝 [task=%s, queue=%d, active=%d, pool=%d]%n&quot;</span>,<br>                taskInfo, queueSize, activeCount, poolSize);<br>            <br>            <span class="hljs-comment">// 3. 尝试降级处理</span><br>            <span class="hljs-keyword">if</span> (!executor.isShutdown()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 等待一小段时间后重试</span><br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">offered</span> <span class="hljs-operator">=</span> executor.getQueue().offer(runnable, <span class="hljs-number">100</span>, TimeUnit.MILLISECONDS);<br>                    <span class="hljs-keyword">if</span> (offered) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;重试入队成功&quot;</span>);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 4. 最终降级：由调用者执行</span><br>            <span class="hljs-keyword">if</span> (!executor.isShutdown()) &#123;<br>                runnable.run();<br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            Runtime.getRuntime().availableProcessors(),<br>            Runtime.getRuntime().availableProcessors() * <span class="hljs-number">2</span>,<br>            <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>                .setNameFormat(<span class="hljs-string">&quot;production-pool-%d&quot;</span>)<br>                .setUncaughtExceptionHandler((t, e) -&gt; <br>                    System.err.println(<span class="hljs-string">&quot;线程异常: &quot;</span> + e.getMessage()))<br>                .build(),<br>            productionHandler<br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">// 简单的ThreadFactory构建器</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadFactoryBuilder</span> &#123;<br>        <span class="hljs-keyword">private</span> String nameFormat;<br>        <span class="hljs-keyword">private</span> Thread.UncaughtExceptionHandler handler;<br>        <br>        ThreadFactoryBuilder <span class="hljs-title function_">setNameFormat</span><span class="hljs-params">(String format)</span> &#123;<br>            <span class="hljs-built_in">this</span>.nameFormat = format;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <br>        ThreadFactoryBuilder <span class="hljs-title function_">setUncaughtExceptionHandler</span><span class="hljs-params">(Thread.UncaughtExceptionHandler h)</span> &#123;<br>            <span class="hljs-built_in">this</span>.handler = h;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <br>        ThreadFactory <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> r -&gt; &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>                <span class="hljs-keyword">if</span> (nameFormat != <span class="hljs-literal">null</span>) &#123;<br>                    t.setName(String.format(nameFormat, count.getAndIncrement()));<br>                &#125;<br>                <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>                    t.setUncaughtExceptionHandler(handler);<br>                &#125;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>拒绝策略对比图：</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph 拒绝策略对比
        A[AbortPolicy] --&gt; A1[抛出异常]
        A1 --&gt; A2[调用方感知]
        A2 --&gt; A3[适合：需要明确处理拒绝的场景]
        
        B[CallerRunsPolicy] --&gt; B1[调用者执行]
        B1 --&gt; B2[提供反压]
        B2 --&gt; B3[适合：不能丢弃任务的场景]
        
        C[DiscardPolicy] --&gt; C1[静默丢弃]
        C1 --&gt; C2[无感知]
        C2 --&gt; C3[适合：允许丢弃且无需感知]
        
        D[DiscardOldestPolicy] --&gt; D1[丢弃最老任务]
        D1 --&gt; D2[新任务优先]
        D2 --&gt; D3[适合：新任务更重要的场景]
    end
    
    style A fill:#FF6B6B
    style B fill:#4ECDC4
    style C fill:#95A5A6
    style D fill:#F39C12</code></pre>
<h4 id="任务申请">任务申请</h4>
<blockquote>
<p>任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
</blockquote>
<p>任务的执行主要有 submit-&gt;execute，submit 的主要逻辑是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>execute 的主要逻辑是：</p>
<p><img src="Worker%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.png" alt="Worker执行任务.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法体现了线程池的任务调度策略的顶层设计：先 core 后 queue 后非 core 的设计思路。不过，这里面的 queue 的使用方案需要考虑线程池的状态。</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Executes the given task sometime in the future.  The task</span><br><span class="hljs-comment"> * may execute in a new thread or in an existing pooled thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If the task cannot be submitted for execution, either because this</span><br><span class="hljs-comment"> * executor has been shutdown or because its capacity has been reached,</span><br><span class="hljs-comment"> * the task is handled by the current &#123;<span class="hljs-doctag">@code</span> RejectedExecutionHandler&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> command the task to execute</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException at discretion of</span><br><span class="hljs-comment"> *         &#123;<span class="hljs-doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span><br><span class="hljs-comment"> *         cannot be accepted for execution</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if &#123;<span class="hljs-doctag">@code</span> command&#125; is null</span><br><span class="hljs-comment"> */</span><br>execute(Runnable command) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * execute 本身也是一个经典的四步分发，线程管理就靠这一步了</span><br><span class="hljs-comment">     * Proceed in 3 steps:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="hljs-comment">     * start a new thread with the given command as its first</span><br><span class="hljs-comment">     * task.  The call to addWorker atomically checks runState and</span><br><span class="hljs-comment">     * workerCount, and so prevents false alarms that would add</span><br><span class="hljs-comment">     * threads when it shouldn&#x27;t, by returning false.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. If a task can be successfully queued, then we still need</span><br><span class="hljs-comment">     * to double-check whether we should have added a thread</span><br><span class="hljs-comment">     * (because existing ones died since last checking) or that</span><br><span class="hljs-comment">     * the pool shut down since entry into this method. So we</span><br><span class="hljs-comment">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="hljs-comment">     * stopped, or start a new thread if there are none.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="hljs-comment">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="hljs-comment">     * and so reject the task.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这需要用到<a href="#%E5%B0%9D%E8%AF%95%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B">尝试增加线程</a></p>
<h2 id="线程池如何管理线程">线程池如何管理线程</h2>
<p>核心线程的 idle 不影响核心线程的创建；非核心线程的 idle time 会导致它们退出。</p>
<h3 id="尝试增加线程">尝试增加线程</h3>
<p>注意 addWorker 只是 execute 的一个子分支而已。</p>
<p><img src="%E7%94%B3%E8%AF%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="申请线程执行流程图.png"></p>
<p>Worker 可以被认为是线程和锁的结合体，它的使命就是不断地把 runnable 从缓冲队列里拿出来，放在自己的 thread 里执行，其中关键的方法是 addWorker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Checks if a new worker can be added with respect to current</span><br><span class="hljs-comment"> * pool state and the given bound (either core or maximum). If so,</span><br><span class="hljs-comment"> * the worker count is adjusted accordingly, and, if possible, a</span><br><span class="hljs-comment"> * new worker is created and started, running firstTask as its</span><br><span class="hljs-comment"> * first task. This method returns false if the pool is stopped or</span><br><span class="hljs-comment"> * eligible to shut down. It also returns false if the thread</span><br><span class="hljs-comment"> * factory fails to create a thread when asked.  If the thread</span><br><span class="hljs-comment"> * creation fails, either due to the thread factory returning</span><br><span class="hljs-comment"> * null, or due to an exception (typically OutOfMemoryError in</span><br><span class="hljs-comment"> * Thread.start()), we roll back cleanly.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> firstTask the task the new thread should run first (or</span><br><span class="hljs-comment"> * null if none). Workers are created with an initial first task</span><br><span class="hljs-comment"> * (in method execute()) to bypass queuing when there are fewer</span><br><span class="hljs-comment"> * than corePoolSize threads (in which case we always start one),</span><br><span class="hljs-comment"> * or when the queue is full (in which case we must bypass queue).</span><br><span class="hljs-comment"> * Initially idle threads are usually created via</span><br><span class="hljs-comment"> * prestartCoreThread or to replace other dying workers.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> core if true use corePoolSize as bound, else</span><br><span class="hljs-comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span><br><span class="hljs-comment"> * value to ensure reads of fresh values after checking other pool</span><br><span class="hljs-comment"> * state).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true if successful</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    <span class="hljs-comment">// retry 是外部自旋的标签。大自旋保证 rs 是稳定的，小自旋保证 wc 是稳定的，在双自旋里面保证 wc 的修改成功</span><br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 获取运行时状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>        <br>        <span class="hljs-comment">// 如果线程池关闭了，或者不是worker 的 firstTask 为空，但 workQueue 不空</span><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 内层自旋</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">// 其实 worker 里并没有 core 与否的属性，core 主要看比对哪个 PoolSize</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 如果这次一个原子性地增加 WorkerCount 成功，则退出大自旋；否则还是在大自旋里做 cas 增加 workerCount</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">// 否则失败有两种可能：rc 变了，或者 wc 变了。看看当前 runState 是否还是大自旋的 runState</span><br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-comment">// 如果不是则返回大自旋</span><br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// 如果是则 runState 不变，只是 wc 变了，在小自旋里重新获取 wc 即可</span><br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 在上层的 ctl 的修改是通过自旋来做的，不加锁，但下层就必须加锁了。这个设计实际上让 ctl 的修改和 worker 的修改解耦，实现了某种“最终一致”</span><br>    <br>    <span class="hljs-comment">// worker 的创建和添加是两个状态</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 外部传进来的 firstTask 可能为空，这里照样传进去</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-comment">// 在 Worker 构造器的内部携带的线程工厂创建的 thread 也可能为空</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 凡是修改线程池的 bookkeeping 操作，包含状态之外（比如 worker）的成员复杂流程修改的时候，都需要加锁</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-comment">// Tests if this thread is alive. A thread is alive if it has been started and has not yet died.</span><br>                    <span class="hljs-comment">// 这个方法本身是为了启动新线程，如果线程工厂不是启动新线程而是像线程池一样复用线程的话，线程就是 alive 的了（注意这个状态和线程的 status 还不一样），这时候线程池 addWorker 会失败</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable                   </span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-comment">// 更新簿记值</span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">// 此时才开始线程</span><br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rolls back the worker thread creation.</span><br><span class="hljs-comment"> * - removes worker from workers, if present</span><br><span class="hljs-comment"> * - decrements worker count</span><br><span class="hljs-comment"> * - rechecks for termination, in case the existence of this</span><br><span class="hljs-comment"> *   worker was holding up termination</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)<br>            workers.remove(w);<br>        decrementWorkerCount();<br>        <span class="hljs-comment">// 增加线程失败，会导致线程池终结</span><br>        tryTerminate();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Decrements the workerCount field of ctl. This is called only on</span><br><span class="hljs-comment"> * abrupt termination of a thread (see processWorkerExit). Other</span><br><span class="hljs-comment"> * decrements are performed within getTask.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrementWorkerCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 减 worker count 的操作必须自旋到成功，这种小成员的自旋修改不需要 sleep！</span><br>    <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndIncrementWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect)</span> &#123;<br>    <span class="hljs-comment">// 因为 wc 在 32 位整数的低位，所以直接对 expect + 1 即可。</span><br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="线程执行">线程执行</h3>
<p><img src="%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png" alt="执行任务流程.png"></p>
<p>线程的执行强依赖于 worker 本身的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// worker 本身并不严重依赖自己的状态，所以不像线程池一样拥有一个 runState，但它持有一个 state，能够表达自身的锁状态。所以它自身拥有 -1、0、1 三种状态</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Class Worker mainly maintains interrupt control state for</span><br><span class="hljs-comment"> * threads running tasks, along with other minor bookkeeping.</span><br><span class="hljs-comment"> * This class opportunistically extends AbstractQueuedSynchronizer</span><br><span class="hljs-comment"> * to simplify acquiring and releasing a lock surrounding each</span><br><span class="hljs-comment"> * task execution.  This protects against interrupts that are</span><br><span class="hljs-comment"> * intended to wake up a worker thread waiting for a task from</span><br><span class="hljs-comment"> * instead interrupting a task being run.  We implement a simple</span><br><span class="hljs-comment"> * non-reentrant mutual exclusion lock rather than use</span><br><span class="hljs-comment"> * ReentrantLock because we do not want worker tasks to be able to</span><br><span class="hljs-comment"> * reacquire the lock when they invoke pool control methods like</span><br><span class="hljs-comment"> * setCorePoolSize.  Additionally, to suppress interrupts until</span><br><span class="hljs-comment"> * the thread actually starts running tasks, we initialize lock</span><br><span class="hljs-comment"> * state to a negative value, and clear it upon start (in</span><br><span class="hljs-comment"> * runWorker).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><br>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This class will never be serialized, but we provide a</span><br><span class="hljs-comment">     * serialVersionUID to suppress a javac warning.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6138294804551838833L</span>;<br><br>    <span class="hljs-comment">/** Thread this worker is running in.  Null if factory fails. */</span><br>    <span class="hljs-keyword">final</span> Thread thread;<br>    <span class="hljs-comment">/** Initial task to run.  Possibly null. */</span><br>    Runnable firstTask;<br>    <span class="hljs-comment">/** Per-thread task counter */</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates with given first task and thread from ThreadFactory.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> firstTask the first task (null if none)</span><br><span class="hljs-comment">     */</span><br>    Worker(Runnable firstTask) &#123;<br>        <span class="hljs-comment">// inhibit == prohibit，就是禁止中断的意思，中断前也要求锁</span><br>        setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>        <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>        <span class="hljs-comment">// 这个方法是调用的线程池的 factory，</span><br>        <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/** Delegates main run loop to outer runWorker  */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这个方法是线程池里的方法，这样交互委托可以实现上下文的 merge，以当前的线程去读外部的上下文</span><br>        runWorker(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Lock methods</span><br>    <span class="hljs-comment">// 0 代表常态无锁</span><br>    <span class="hljs-comment">// 1 代表常态加锁</span><br>    <span class="hljs-comment">// The value 0 represents the unlocked state.</span><br>    <span class="hljs-comment">// The value 1 represents the locked state.</span><br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 启动的时候使用的-1 是一种“启动时才能使用的锁”，这里也包含进来了</span><br>        <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// aqs 最关键的加锁方法，锁的标记位可以自定义</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        <span class="hljs-comment">// 这里体现了经典的设计模式，先 cas 把标记位加上去，然后绑定线程。这里要求线程安全的写只有锁的 cas，线程的归属却不是线程安全的</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        <span class="hljs-comment">// 恰好和上一个方法反过来</span><br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 强制解锁，无 cas</span><br>        setState(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>        &#123; acquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>      &#123; release(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-comment">// 锁只支持互斥锁定模式，不支持共享锁定模式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br>    <br>    <span class="hljs-comment">// 提供一种中断 worker（包括内部线程）的工作模式</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;<br>        Thread t;<br>        <span class="hljs-comment">// -1 和 1 不允许中断</span><br>        <span class="hljs-comment">// 在一个括号里实现了漂亮的取数操作</span><br>        <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp;<br>        <span class="hljs-comment">// 线程没有被中断的时候可以被中断</span><br>        !t.isInterrupted()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.interrupt();<br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Worker 生命周期状态图：</strong></p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; Created: new Worker(firstTask)
    
    Created --&gt; Initialized: setState(-1)&lt;br/&gt;禁止中断
    Initialized --&gt; Started: thread.start()
    
    Started --&gt; Running: runWorker(this)
    Running --&gt; Unlocked: w.unlock()&lt;br/&gt;允许中断
    
    state Running &#123;
        Unlocked --&gt; WaitingTask: getTask()
        WaitingTask --&gt; GotTask: task != null
        WaitingTask --&gt; NoTask: task == null
        
        GotTask --&gt; Locked: w.lock()
        Locked --&gt; Executing: task.run()
        Executing --&gt; Unlocked: w.unlock()
    &#125;
    
    NoTask --&gt; Exiting: processWorkerExit()
    Exiting --&gt; [*]: 线程终止
    
    note right of Created
        Worker 构造时：
        1. setState(-1) 禁止中断
        2. 保存 firstTask
        3. 通过 ThreadFactory 创建线程
    end note
    
    note right of WaitingTask
        getTask() 返回 null 的情况：
        1. 线程数 &gt; maximumPoolSize
        2. 线程池 STOP 状态
        3. 线程池 SHUTDOWN 且队列空
        4. 等待超时
    end note</code></pre>
<p><strong>Worker 锁状态转换图：</strong></p>
<pre><code class="hljs mermaid">graph TD
    subgraph Worker锁状态
        A[state = -1&lt;br/&gt;初始化状态] --&gt;|w.unlock| B[state = 0&lt;br/&gt;空闲状态]
        B --&gt;|w.lock| C[state = 1&lt;br/&gt;执行任务中]
        C --&gt;|w.unlock| B
    end
    
    subgraph 锁状态含义
        D[-1: 禁止中断&lt;br/&gt;Worker刚创建] 
        E[0: 允许中断&lt;br/&gt;Worker空闲等待任务]
        F[1: 正在执行任务&lt;br/&gt;不应被中断]
    end
    
    subgraph 中断规则
        G[interruptIfStarted] --&gt; H&#123;getState &gt;= 0?&#125;
        H --&gt;|是| I[可以中断]
        H --&gt;|否| J[不能中断]
    end
    
    style A fill:#FFB6C1
    style B fill:#90EE90
    style C fill:#87CEEB</code></pre>
<p><strong>runWorker 执行流程详解：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant TPE as ThreadPoolExecutor
    participant W as Worker
    participant T as Thread
    participant Q as BlockingQueue
    
    Note over W: 构造函数: setState(-1)
    TPE-&gt;&gt;W: addWorker(task, core)
    TPE-&gt;&gt;T: thread.start()
    T-&gt;&gt;W: run()
    W-&gt;&gt;TPE: runWorker(this)
    
    TPE-&gt;&gt;W: w.unlock() // setState(0)
    Note over W: 现在允许中断
    
    loop 任务循环
        alt 有 firstTask
            TPE-&gt;&gt;TPE: task = firstTask
        else 无 firstTask
            TPE-&gt;&gt;Q: getTask()
            Q--&gt;&gt;TPE: task 或 null
        end
        
        alt task != null
            TPE-&gt;&gt;W: w.lock() // setState(1)
            Note over W: 执行期间不应中断
            
            TPE-&gt;&gt;TPE: beforeExecute(thread, task)
            TPE-&gt;&gt;T: task.run()
            TPE-&gt;&gt;TPE: afterExecute(task, thrown)
            
            TPE-&gt;&gt;W: w.unlock() // setState(0)
            TPE-&gt;&gt;W: completedTasks++
        else task == null
            Note over TPE: 退出循环
        end
    end
    
    TPE-&gt;&gt;TPE: processWorkerExit(w, completedAbruptly)
    Note over W: Worker 生命周期结束</code></pre>
<p>在一个工作线程里，worker delegate 调用给线程池的 runWorker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Main worker run loop.  Repeatedly gets tasks from queue and</span><br><span class="hljs-comment"> * executes them, while coping with a number of issues:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1. We may start out with an initial task, in which case we</span><br><span class="hljs-comment"> * don&#x27;t need to get the first one. Otherwise, as long as pool is</span><br><span class="hljs-comment"> * running, we get tasks from getTask. If it returns null then the</span><br><span class="hljs-comment"> * worker exits due to changed pool state or configuration</span><br><span class="hljs-comment"> * parameters.  Other exits result from exception throws in</span><br><span class="hljs-comment"> * external code, in which case completedAbruptly holds, which</span><br><span class="hljs-comment"> * usually leads processWorkerExit to replace this thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. Before running any task, the lock is acquired to prevent</span><br><span class="hljs-comment"> * other pool interrupts while the task is executing, and then we</span><br><span class="hljs-comment"> * ensure that unless pool is stopping, this thread does not have</span><br><span class="hljs-comment"> * its interrupt set.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. Each task run is preceded by a call to beforeExecute, which</span><br><span class="hljs-comment"> * might throw an exception, in which case we cause thread to die</span><br><span class="hljs-comment"> * (breaking loop with completedAbruptly true) without processing</span><br><span class="hljs-comment"> * the task.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. Assuming beforeExecute completes normally, we run the task,</span><br><span class="hljs-comment"> * gathering any of its thrown exceptions to send to afterExecute.</span><br><span class="hljs-comment"> * We separately handle RuntimeException, Error (both of which the</span><br><span class="hljs-comment"> * specs guarantee that we trap) and arbitrary Throwables.</span><br><span class="hljs-comment"> * Because we cannot rethrow Throwables within Runnable.run, we</span><br><span class="hljs-comment"> * wrap them within Errors on the way out (to the thread&#x27;s</span><br><span class="hljs-comment"> * UncaughtExceptionHandler).  Any thrown exception also</span><br><span class="hljs-comment"> * conservatively causes thread to die.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. After task.run completes, we call afterExecute, which may</span><br><span class="hljs-comment"> * also throw an exception, which will also cause thread to</span><br><span class="hljs-comment"> * die. According to JLS Sec 14.20, this exception is the one that</span><br><span class="hljs-comment"> * will be in effect even if task.run throws.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The net effect of the exception mechanics is that afterExecute</span><br><span class="hljs-comment"> * and the thread&#x27;s UncaughtExceptionHandler have as accurate</span><br><span class="hljs-comment"> * information as we can provide about any problems encountered by</span><br><span class="hljs-comment"> * user code.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-comment">// 这里为什么不使用 worker 里面的线程呢？</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 做一个置换/置空操作</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 在对象初始化的时候触发了加锁，在线程启动的时候触发了解锁。线程池的 shutdown 方法本身会 interrupt worker，这里不允许在锁周期里面 interrupt worker</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-comment">// 突然完成默认为真</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// getTask 里封装了复杂的取任务流程，这里在一个表达式里面实现了漂亮的取任务操作</span><br>        <span class="hljs-comment">// 本线程只有在 getTask 取不到的时候才退出</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 只在 run 一个 task 的时候锁定自己一次，不可重入</span><br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-comment">// 如果线程池本身已经进入停止及以后状态，则直接求 工作线程的中断状态。否则，做一轮线程的中断，再求线程池状态（中断居然会影响线程池的状态，很奇怪？），再求工作线程的中断状态。这里有一个比较炫技的地方，wt 和 currentThread 都是当前线程，但偏偏不使用 wt 里的线程        </span><br>            <span class="hljs-comment">// 这里的思想是：不能由命令触发中断，必须由状态触发中断</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                <span class="hljs-comment">// 或者</span><br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                <span class="hljs-comment">// 遇到这些情况，就要中断 wt，在这里。所以内部线程是由 getTask 内部的流程中断的，然后才去执行下面的 run，看看下面的 run 会不会响应</span><br>                wt.interrupt();<br>            <span class="hljs-comment">// 线程的中断也不会影响接下来的 task.run()</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通常这个方法是空方法</span><br>                beforeExecute(wt, task);<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// runnable.run()</span><br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    <span class="hljs-comment">// 有这样的写法就意味着要在 finally 留存 thrown</span><br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// thrown 是给 afterExecute 准备的</span><br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 只有在 getTask 取不到的时候退出，这个值才是false，其他时候都算是“突然退出”</span><br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 阻塞式获取任务。</span><br><span class="hljs-comment">// 遇到异常情况给上游的返回值是 null：</span><br><span class="hljs-comment">// 1. 有超过maximumPoolSize 的线程数，这时候返回 null 会导致它退出。</span><br><span class="hljs-comment">// 2. 线程池 stopped 了（由 shutdownNow 来触发，比 shutdown 更严厉），这时候线程池也会用 null 的方式指示线程有序退出</span><br><span class="hljs-comment">// 3. 线程池 shutdown，且队列为空（其实光是本条件就可以返回 null，只是如果线程池还在工作中，队列应该让 getTask 的线程阻塞等待）</span><br><span class="hljs-comment">// 4. 线程超时。真正的超时实际上有两种：线程数超过 core 且超时，连 core 都允许超时且超时</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs blocking or timed wait for a task, depending on</span><br><span class="hljs-comment"> * current configuration settings, or returns null if this worker</span><br><span class="hljs-comment"> * must exit because of any of:</span><br><span class="hljs-comment"> * 1. There are more than maximumPoolSize workers (due to</span><br><span class="hljs-comment"> *    a call to setMaximumPoolSize).</span><br><span class="hljs-comment"> * 2. The pool is stopped.</span><br><span class="hljs-comment"> * 3. The pool is shutdown and the queue is empty.</span><br><span class="hljs-comment"> * 4. This worker timed out waiting for a task, and timed-out</span><br><span class="hljs-comment"> *    workers are subject to termination (that is,</span><br><span class="hljs-comment"> *    &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span><br><span class="hljs-comment"> *    both before and after the timed wait, and if the queue is</span><br><span class="hljs-comment"> *    non-empty, this worker is not the last thread in the pool.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> task, or null if the worker must exit, in which case</span><br><span class="hljs-comment"> *         workerCount is decremented</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-comment">// 在自旋里面</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>        <br>        <span class="hljs-comment">// 第一类情况返回 null</span><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling? 是否要强制减少线程数？是的话就要引入计时了</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>        <span class="hljs-comment">// 超时返回 null 的场景，但注意这里要能减掉一个线程才能返回 null。</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-comment">// 减线程数目（不一定成功，如 wc == 0 也可能进入这个语句块）</span><br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 不能减线程则 cas 失败，进入大循环里继续</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="回收线程">回收线程</h3>
<blockquote>
<p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反映线程现在的执行状态。</p>
<p>1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。<br>
2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p>
</blockquote>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="线程池回收线程的过程.png"><br>
<img src="%E7%BA%BF%E7%A8%8B%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B.png" alt="线程销毁流程.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 处理一些关闭和簿记工作：</span><br><span class="hljs-comment">// 1. 只能被从 worker 线程里调用，也就是说只能在 runWorker 方法里被调用</span><br><span class="hljs-comment">// 2. 先尝试把 workerCount 减一</span><br><span class="hljs-comment">// 3. 把 worker 从工作集里移除</span><br><span class="hljs-comment">// 4. 尝试终结线程池</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs cleanup and bookkeeping for a dying worker. Called</span><br><span class="hljs-comment"> * only from worker threads. Unless completedAbruptly is set,</span><br><span class="hljs-comment"> * assumes that workerCount has already been adjusted to account</span><br><span class="hljs-comment"> * for exit.  This method removes thread from worker set, and</span><br><span class="hljs-comment"> * possibly terminates the pool or replaces the worker if either</span><br><span class="hljs-comment"> * it exited due to user task exception or if fewer than</span><br><span class="hljs-comment"> * corePoolSize workers are running or queue is non-empty but</span><br><span class="hljs-comment"> * there are no workers.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> completedAbruptly if the worker died due to user exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;<br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        <span class="hljs-comment">// 只要能够成功减一就行了</span><br>        decrementWorkerCount();<br>    <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 不管怎样退出，都把 worker 的完成任务数加总到线程池的总数里</span><br>        completedTaskCount += w.completedTasks;<br>        <span class="hljs-comment">// 移除本 worker</span><br>        workers.remove(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>    <span class="hljs-comment">// 每个 worker 终结都尝试终结线程池</span><br>    tryTerminate(); <br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-comment">// 如果线程池没有真的被真的关闭，可以加减线程池里的线程</span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-comment">// 如果线程池正常关闭</span><br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-comment">// allowCoreThreadTimeOut 通常为 false，所以线程池的最小值应该是 corePoolSize，否则核心线程数可以归零</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                <span class="hljs-comment">// 如果缓冲队列不空，则最小线程数需要维持在 1</span><br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-comment">// 如果当前工作线程数大于等于 min，则直接退出</span><br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        <span class="hljs-comment">// 反之则认为工作线程数小于 min，需要增加非核心线程（增加非核心线程实际上也是在增加核心线程），这里的设计思想是任何一个线程退出都应该增加一个线程，所以就当作非核心线程增加了</span><br>        addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 这个方法在线程退出时只关闭一个【空闲线程】，但在线程池关闭等场景下，会关闭所有的空闲线程，这样线程池最终就关闭了-因为每个worker 退出的时候最少都会关闭一个空闲线程，全局的线程最终得以全部关闭。但线程池的核心参数如 keepAliveTime、corePoolSize、maximumPoolSize 有变化的时候，都会触发全部空闲线程关闭</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Interrupts threads that might be waiting for tasks (as</span><br><span class="hljs-comment"> * indicated by not being locked) so they can check for</span><br><span class="hljs-comment"> * termination or configuration changes. Ignores</span><br><span class="hljs-comment"> * SecurityExceptions (in which case some threads may remain</span><br><span class="hljs-comment"> * uninterrupted).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> onlyOne If true, interrupt at most one worker. This is</span><br><span class="hljs-comment"> * called only from tryTerminate when termination is otherwise</span><br><span class="hljs-comment"> * enabled but there are still other workers.  In this case, at</span><br><span class="hljs-comment"> * most one waiting worker is interrupted to propagate shutdown</span><br><span class="hljs-comment"> * signals in case all threads are currently waiting.</span><br><span class="hljs-comment"> * Interrupting any arbitrary thread ensures that newly arriving</span><br><span class="hljs-comment"> * workers since shutdown began will also eventually exit.</span><br><span class="hljs-comment"> * To guarantee eventual termination, it suffices to always</span><br><span class="hljs-comment"> * interrupt only one idle worker, but shutdown() interrupts all</span><br><span class="hljs-comment"> * idle workers so that redundant workers exit promptly, not</span><br><span class="hljs-comment"> * waiting for a straggler task to finish.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>            <span class="hljs-comment">// 能够被关闭的线程是一个能够拿到内部锁的线程</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 中断，这个线程内部的工作线程能不能响应看 runnable 内部的实现了</span><br>                    t.interrupt();<br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (onlyOne)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="线程池使用中可能遇到的问题">线程池使用中可能遇到的问题</h2>
<p>线程池的调参有几个难点：</p>
<ol>
<li>如果核心线程数过小，则吞吐可能不够，遇到流量矛刺可能导致 RejectExecutionException；但值得警惕的是，如果核心线程数很大，可能导致频繁的上下文切换和过多的资源消耗（不管是 cpu 时间片还是操作系统的内核线程）。</li>
<li>如果队列过长，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。</li>
</ol>
<p>那么，如何计算这些参数呢？<br>
有一个基本的原则是：</p>
<ol>
<li>计算密集型的线程数本身应该尽量贴进 cpu 核数。</li>
<li>io 密集型的线程数要注意伸缩，要配合阻塞队列使用，要有承受拒绝失败的的准备。</li>
</ol>
<p>我们常见的计算方式主要来自于《Java并发编程实战》：</p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="线程池计算公式.png"></p>
<p>现实中可选的线程数计算公式最好是取一个并发 qps 数和 cpu 数的折中。通常可以认为 单任务的 rt/1ms 可以得到单一线程的吞吐数，qps 除以吞吐数可以得到 qps 相应的线程数，但这个方案没有考虑cpu 核数和上下文切换的问题。所以这样算出来的线程数的实际 qps 表现应该低于理论 qps，但可以通过估算和压测不断让理论值逼近实际值。</p>
<h2 id="线程池的可替换方案">线程池的可替换方案</h2>
<p>其他可替代方案，都不如线程池的调优方案成熟（<strong>在可以使用新技术的前提下，我们是否还有调优旧方案的魄力呢？</strong>）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">优势</th>
<th style="text-align:center">劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Disruptor框架</td>
<td style="text-align:center">线程池内部是通过一个工作队列去维护任务的执行的，它有一个根本性的缺陷：连续争用问题。也就是多个线程在申请任务时，为了合理地分配任务要付出锁资源，对比快速的任务执行来说，这部分申请的损耗是巨大的。高性能进程间消息库LMAX使用了一个叫作环形缓冲的数据结构，用这种这个特殊的数据结构替代队列，将会避免申请任务时出现的连续争用状况。</td>
<td style="text-align:center">避免连续争用，性能更佳</td>
<td style="text-align:center">缺乏线程管理的能力，使用场景较少</td>
</tr>
<tr>
<td style="text-align:center">协程框架</td>
<td style="text-align:center">协程是一种用户态的轻量级线程，其拥有自己的寄存器上下文和栈，当调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。这种切换上下文的方式要小于线程的开销。在瓶颈侧重IO的情况，使用协程获得并发性要优于使用线程。</td>
<td style="text-align:center">侧重IO情况时，性能更佳。与多线程策略无冲突，可结合使用</td>
<td style="text-align:center">在Java中缺乏成熟的应用</td>
</tr>
<tr>
<td style="text-align:center">Actor框架</td>
<td style="text-align:center">Actor模型通过维护多个Actor去处理并发的任务，它放弃了直接使用线程去获取并发性，而是自己定义了一系列系统组件应该如何动作和交互的通用规则，不需要开发者直接使用线程。通过在原生的线程或协程的级别上做了更高层次的封装，只需要开发者关心每个Actor的逻辑即可实现并发操作。由于避免了直接使用锁，很大程度解决了传统并发编程模式下大量依赖悲观锁导致的资源竞争情况。</td>
<td style="text-align:center">无锁策略，性能更佳，避免直接使用线程，安全性更高</td>
<td style="text-align:center">在Java中缺乏成熟的应用，内部复杂，难以排查和调试</td>
</tr>
</tbody>
</table>
<p>缺乏管控能力就不适合调优。</p>
<h2 id="最终解决方案">最终解决方案</h2>
<p>通过监控线程池负载，制定告警策略：</p>
<ol>
<li>线程池活跃度 = activeCount/maximumPoolSize。看看这个值是不是趋近于 1。</li>
<li>监控队列的capacity 和 size 的比例。</li>
<li>监控 RejectExecutionException 的出现。</li>
</ol>
<p>加引入线程池动态管控能力，基于告警制定 sop，确定是否要动态调节线程数和拒绝策略。</p>
<p>如果还是解决不了问题，需要考虑全局动态扩容的方案。</p>
<p><strong>线程池监控指标体系：</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph 核心监控指标
        A[线程池监控] --&gt; B[线程指标]
        A --&gt; C[队列指标]
        A --&gt; D[任务指标]
        A --&gt; E[异常指标]
        
        B --&gt; B1[poolSize&lt;br/&gt;当前线程数]
        B --&gt; B2[activeCount&lt;br/&gt;活跃线程数]
        B --&gt; B3[largestPoolSize&lt;br/&gt;历史最大线程数]
        B --&gt; B4[corePoolSize&lt;br/&gt;核心线程数]
        B --&gt; B5[maximumPoolSize&lt;br/&gt;最大线程数]
        
        C --&gt; C1[queue.size&lt;br/&gt;队列当前大小]
        C --&gt; C2[queue.remainingCapacity&lt;br/&gt;队列剩余容量]
        C --&gt; C3[队列使用率&lt;br/&gt;size/capacity]
        
        D --&gt; D1[taskCount&lt;br/&gt;总任务数]
        D --&gt; D2[completedTaskCount&lt;br/&gt;已完成任务数]
        D --&gt; D3[待执行任务数&lt;br/&gt;taskCount-completedTaskCount]
        
        E --&gt; E1[rejectedCount&lt;br/&gt;拒绝任务数]
        E --&gt; E2[exceptionCount&lt;br/&gt;异常任务数]
    end
    
    style A fill:#4ECDC4
    style B fill:#87CEEB
    style C fill:#90EE90
    style D fill:#FFB6C1
    style E fill:#FF6B6B</code></pre>
<p><strong>完整的线程池监控实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 可监控的线程池实现</span><br><span class="hljs-comment"> * 提供完整的监控指标收集和告警能力</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitoredThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br>    <br>    <span class="hljs-comment">// ==================== 监控指标 ====================</span><br>    <br>    <span class="hljs-comment">/** 拒绝任务计数器 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">rejectedCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/** 异常任务计数器 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">exceptionCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/** 任务执行时间统计（纳秒） */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">totalExecutionTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/** 任务开始时间记录（用于计算执行时间） */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Runnable, Long&gt; taskStartTimes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-comment">/** 线程池名称（用于日志和监控标识） */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String poolName;<br>    <br>    <span class="hljs-comment">/** 告警阈值配置 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">double</span> <span class="hljs-variable">activeRatioThreshold</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.8</span>;      <span class="hljs-comment">// 活跃度告警阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">double</span> <span class="hljs-variable">queueUsageThreshold</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.8</span>;       <span class="hljs-comment">// 队列使用率告警阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">taskTimeoutMs</span> <span class="hljs-operator">=</span> <span class="hljs-number">30000</span>;             <span class="hljs-comment">// 任务超时阈值（毫秒）</span><br>    <br>    <span class="hljs-comment">// ==================== 构造函数 ====================</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MonitoredThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">            String poolName,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">            <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">            TimeUnit unit,</span><br><span class="hljs-params">            BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">            ThreadFactory threadFactory)</span> &#123;<br>        <br>        <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory,<br>            <span class="hljs-comment">// 使用自定义拒绝策略来统计拒绝次数</span><br>            (r, executor) -&gt; &#123;<br>                ((MonitoredThreadPoolExecutor) executor).rejectedCount.incrementAndGet();<br>                <span class="hljs-comment">// 记录拒绝日志</span><br>                System.err.printf(<span class="hljs-string">&quot;[%s] 任务被拒绝: queue=%d, active=%d, pool=%d%n&quot;</span>,<br>                    ((MonitoredThreadPoolExecutor) executor).poolName,<br>                    executor.getQueue().size(),<br>                    executor.getActiveCount(),<br>                    executor.getPoolSize());<br>                <span class="hljs-comment">// 默认行为：抛出异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task rejected from &quot;</span> + <br>                    ((MonitoredThreadPoolExecutor) executor).poolName);<br>            &#125;);<br>        <br>        <span class="hljs-built_in">this</span>.poolName = poolName;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 生命周期钩子 ====================</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>        <span class="hljs-built_in">super</span>.beforeExecute(t, r);<br>        <span class="hljs-comment">// 记录任务开始时间</span><br>        taskStartTimes.put(r, System.nanoTime());<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 计算任务执行时间</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> taskStartTimes.remove(r);<br>            <span class="hljs-keyword">if</span> (startTime != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">executionTime</span> <span class="hljs-operator">=</span> System.nanoTime() - startTime;<br>                totalExecutionTime.addAndGet(executionTime);<br>                <br>                <span class="hljs-comment">// 检查任务是否超时</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">executionTimeMs</span> <span class="hljs-operator">=</span> TimeUnit.NANOSECONDS.toMillis(executionTime);<br>                <span class="hljs-keyword">if</span> (executionTimeMs &gt; taskTimeoutMs) &#123;<br>                    System.err.printf(<span class="hljs-string">&quot;[%s] 任务执行超时: %dms &gt; %dms%n&quot;</span>,<br>                        poolName, executionTimeMs, taskTimeoutMs);<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 统计异常</span><br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                exceptionCount.incrementAndGet();<br>                System.err.printf(<span class="hljs-string">&quot;[%s] 任务执行异常: %s%n&quot;</span>, poolName, t.getMessage());<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 监控指标获取 ====================</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取线程池活跃度（0.0 ~ 1.0）</span><br><span class="hljs-comment">     * 活跃度 = 活跃线程数 / 最大线程数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getActiveRatio</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) getActiveCount() / getMaximumPoolSize();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取队列使用率（0.0 ~ 1.0）</span><br><span class="hljs-comment">     * 使用率 = 队列当前大小 / 队列总容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getQueueUsageRatio</span><span class="hljs-params">()</span> &#123;<br>        BlockingQueue&lt;Runnable&gt; queue = getQueue();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> size + queue.remainingCapacity();<br>        <span class="hljs-keyword">return</span> capacity &gt; <span class="hljs-number">0</span> ? (<span class="hljs-type">double</span>) size / capacity : <span class="hljs-number">0.0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取平均任务执行时间（毫秒）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getAverageExecutionTimeMs</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">completed</span> <span class="hljs-operator">=</span> getCompletedTaskCount();<br>        <span class="hljs-keyword">if</span> (completed == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">return</span> TimeUnit.NANOSECONDS.toMillis(totalExecutionTime.get()) / (<span class="hljs-type">double</span>) completed;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取拒绝任务数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getRejectedCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> rejectedCount.get();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取异常任务数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getExceptionCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> exceptionCount.get();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取待执行任务数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getPendingTaskCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getTaskCount() - getCompletedTaskCount();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取完整的监控快照</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ThreadPoolMetrics <span class="hljs-title function_">getMetrics</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolMetrics</span>(<br>            poolName,<br>            getCorePoolSize(),<br>            getMaximumPoolSize(),<br>            getPoolSize(),<br>            getActiveCount(),<br>            getLargestPoolSize(),<br>            getTaskCount(),<br>            getCompletedTaskCount(),<br>            getQueue().size(),<br>            getQueue().remainingCapacity(),<br>            rejectedCount.get(),<br>            exceptionCount.get(),<br>            getAverageExecutionTimeMs()<br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 告警检查 ====================</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查是否需要告警</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndAlert</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 检查活跃度</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">activeRatio</span> <span class="hljs-operator">=</span> getActiveRatio();<br>        <span class="hljs-keyword">if</span> (activeRatio &gt;= activeRatioThreshold) &#123;<br>            System.err.printf(<span class="hljs-string">&quot;[%s] 告警: 线程池活跃度过高 %.2f%% &gt;= %.2f%%%n&quot;</span>,<br>                poolName, activeRatio * <span class="hljs-number">100</span>, activeRatioThreshold * <span class="hljs-number">100</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 检查队列使用率</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">queueUsage</span> <span class="hljs-operator">=</span> getQueueUsageRatio();<br>        <span class="hljs-keyword">if</span> (queueUsage &gt;= queueUsageThreshold) &#123;<br>            System.err.printf(<span class="hljs-string">&quot;[%s] 告警: 队列使用率过高 %.2f%% &gt;= %.2f%%%n&quot;</span>,<br>                poolName, queueUsage * <span class="hljs-number">100</span>, queueUsageThreshold * <span class="hljs-number">100</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 检查拒绝任务</span><br>        <span class="hljs-keyword">if</span> (rejectedCount.get() &gt; <span class="hljs-number">0</span>) &#123;<br>            System.err.printf(<span class="hljs-string">&quot;[%s] 告警: 存在被拒绝的任务 count=%d%n&quot;</span>,<br>                poolName, rejectedCount.get());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 动态调参 ====================</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 动态调整核心线程数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustCorePoolSize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCorePoolSize)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldSize</span> <span class="hljs-operator">=</span> getCorePoolSize();<br>        setCorePoolSize(newCorePoolSize);<br>        System.out.printf(<span class="hljs-string">&quot;[%s] 核心线程数调整: %d -&gt; %d%n&quot;</span>, poolName, oldSize, newCorePoolSize);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 动态调整最大线程数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustMaximumPoolSize</span><span class="hljs-params">(<span class="hljs-type">int</span> newMaximumPoolSize)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldSize</span> <span class="hljs-operator">=</span> getMaximumPoolSize();<br>        setMaximumPoolSize(newMaximumPoolSize);<br>        System.out.printf(<span class="hljs-string">&quot;[%s] 最大线程数调整: %d -&gt; %d%n&quot;</span>, poolName, oldSize, newMaximumPoolSize);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 监控指标数据类 ====================</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolMetrics</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String poolName;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> corePoolSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maximumPoolSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> activeCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> largestPoolSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> taskCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> completedTaskCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> queueSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> queueRemainingCapacity;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> rejectedCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> exceptionCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> avgExecutionTimeMs;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolMetrics</span><span class="hljs-params">(String poolName, <span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                <span class="hljs-type">int</span> poolSize, <span class="hljs-type">int</span> activeCount, <span class="hljs-type">int</span> largestPoolSize, <span class="hljs-type">long</span> taskCount,</span><br><span class="hljs-params">                <span class="hljs-type">long</span> completedTaskCount, <span class="hljs-type">int</span> queueSize, <span class="hljs-type">int</span> queueRemainingCapacity,</span><br><span class="hljs-params">                <span class="hljs-type">long</span> rejectedCount, <span class="hljs-type">long</span> exceptionCount, <span class="hljs-type">double</span> avgExecutionTimeMs)</span> &#123;<br>            <span class="hljs-built_in">this</span>.poolName = poolName;<br>            <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>            <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>            <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>            <span class="hljs-built_in">this</span>.activeCount = activeCount;<br>            <span class="hljs-built_in">this</span>.largestPoolSize = largestPoolSize;<br>            <span class="hljs-built_in">this</span>.taskCount = taskCount;<br>            <span class="hljs-built_in">this</span>.completedTaskCount = completedTaskCount;<br>            <span class="hljs-built_in">this</span>.queueSize = queueSize;<br>            <span class="hljs-built_in">this</span>.queueRemainingCapacity = queueRemainingCapacity;<br>            <span class="hljs-built_in">this</span>.rejectedCount = rejectedCount;<br>            <span class="hljs-built_in">this</span>.exceptionCount = exceptionCount;<br>            <span class="hljs-built_in">this</span>.avgExecutionTimeMs = avgExecutionTimeMs;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> String.format(<br>                <span class="hljs-string">&quot;ThreadPoolMetrics&#123;pool=%s, core=%d, max=%d, current=%d, active=%d, &quot;</span> +<br>                <span class="hljs-string">&quot;largest=%d, tasks=%d, completed=%d, queue=%d/%d, rejected=%d, &quot;</span> +<br>                <span class="hljs-string">&quot;exceptions=%d, avgTime=%.2fms&#125;&quot;</span>,<br>                poolName, corePoolSize, maximumPoolSize, poolSize, activeCount,<br>                largestPoolSize, taskCount, completedTaskCount, queueSize,<br>                queueSize + queueRemainingCapacity, rejectedCount, exceptionCount,<br>                avgExecutionTimeMs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>定时监控任务示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolMonitorExample</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 创建可监控的线程池</span><br>        <span class="hljs-type">MonitoredThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MonitoredThreadPoolExecutor</span>(<br>            <span class="hljs-string">&quot;business-pool&quot;</span>,<br>            <span class="hljs-number">4</span>,                              <span class="hljs-comment">// corePoolSize</span><br>            <span class="hljs-number">8</span>,                              <span class="hljs-comment">// maximumPoolSize</span><br>            <span class="hljs-number">60L</span>, TimeUnit.SECONDS,          <span class="hljs-comment">// keepAliveTime</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>), <span class="hljs-comment">// workQueue</span><br>            r -&gt; &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>                t.setName(<span class="hljs-string">&quot;business-pool-&quot;</span> + t.getId());<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        );<br>        <br>        <span class="hljs-comment">// 启动监控任务（每5秒打印一次指标）</span><br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">monitor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadScheduledExecutor();<br>        monitor.scheduleAtFixedRate(() -&gt; &#123;<br>            <span class="hljs-comment">// 获取并打印监控指标</span><br>            MonitoredThreadPoolExecutor.<span class="hljs-type">ThreadPoolMetrics</span> <span class="hljs-variable">metrics</span> <span class="hljs-operator">=</span> executor.getMetrics();<br>            System.out.println(metrics);<br>            <br>            <span class="hljs-comment">// 检查告警</span><br>            executor.checkAndAlert();<br>            <br>            <span class="hljs-comment">// 可以在这里将指标上报到监控系统</span><br>            <span class="hljs-comment">// metricsReporter.report(metrics);</span><br>            <br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        <br>        <span class="hljs-comment">// 模拟提交任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">try</span> &#123;<br>                executor.execute(() -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 模拟任务执行</span><br>                        Thread.sleep((<span class="hljs-type">long</span>) (Math.random() * <span class="hljs-number">1000</span>));<br>                        System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + taskId + <span class="hljs-string">&quot;完成&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;);<br>            &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>                System.err.println(<span class="hljs-string">&quot;任务&quot;</span> + taskId + <span class="hljs-string">&quot;被拒绝&quot;</span>);<br>            &#125;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 等待任务完成</span><br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        <br>        <span class="hljs-comment">// 关闭</span><br>        executor.shutdown();<br>        monitor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>监控告警决策流程：</strong></p>
<pre><code class="hljs mermaid">flowchart TD
    A[定时采集指标] --&gt; B&#123;活跃度 &gt;= 80%?&#125;
    B --&gt;|是| C[告警: 线程池繁忙]
    B --&gt;|否| D&#123;队列使用率 &gt;= 80%?&#125;
    
    D --&gt;|是| E[告警: 队列积压]
    D --&gt;|否| F&#123;有拒绝任务?&#125;
    
    F --&gt;|是| G[告警: 任务被拒绝]
    F --&gt;|否| H&#123;平均执行时间过长?&#125;
    
    H --&gt;|是| I[告警: 任务执行慢]
    H --&gt;|否| J[正常]
    
    C --&gt; K&#123;是否自动扩容?&#125;
    E --&gt; K
    G --&gt; K
    
    K --&gt;|是| L[动态调整参数]
    K --&gt;|否| M[通知运维处理]
    
    L --&gt; N&#123;调整core?&#125;
    N --&gt;|是| O[setCorePoolSize]
    N --&gt;|否| P&#123;调整max?&#125;
    P --&gt;|是| Q[setMaximumPoolSize]
    P --&gt;|否| R[调整队列容量]
    
    style C fill:#FF6B6B
    style E fill:#FF6B6B
    style G fill:#FF6B6B
    style I fill:#FFB6C1
    style J fill:#90EE90
    style L fill:#4ECDC4</code></pre>
<p><strong>Spring Boot 集成监控示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.actuate.endpoint.annotation.*;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程池监控端点</span><br><span class="hljs-comment"> * 访问 /actuator/threadpool 获取所有线程池状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Endpoint(id = &quot;threadpool&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolEndpoint</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, MonitoredThreadPoolExecutor&gt; executors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String name, MonitoredThreadPoolExecutor executor)</span> &#123;<br>        executors.put(name, executor);<br>    &#125;<br>    <br>    <span class="hljs-meta">@ReadOperation</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">health</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, Object&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, MonitoredThreadPoolExecutor&gt; entry : executors.entrySet()) &#123;<br>            <span class="hljs-type">MonitoredThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> entry.getValue();<br>            Map&lt;String, Object&gt; poolInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <br>            <span class="hljs-comment">// 基础指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;corePoolSize&quot;</span>, executor.getCorePoolSize());<br>            poolInfo.put(<span class="hljs-string">&quot;maximumPoolSize&quot;</span>, executor.getMaximumPoolSize());<br>            poolInfo.put(<span class="hljs-string">&quot;poolSize&quot;</span>, executor.getPoolSize());<br>            poolInfo.put(<span class="hljs-string">&quot;activeCount&quot;</span>, executor.getActiveCount());<br>            poolInfo.put(<span class="hljs-string">&quot;largestPoolSize&quot;</span>, executor.getLargestPoolSize());<br>            <br>            <span class="hljs-comment">// 任务指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;taskCount&quot;</span>, executor.getTaskCount());<br>            poolInfo.put(<span class="hljs-string">&quot;completedTaskCount&quot;</span>, executor.getCompletedTaskCount());<br>            poolInfo.put(<span class="hljs-string">&quot;pendingTaskCount&quot;</span>, executor.getPendingTaskCount());<br>            <br>            <span class="hljs-comment">// 队列指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;queueSize&quot;</span>, executor.getQueue().size());<br>            poolInfo.put(<span class="hljs-string">&quot;queueRemainingCapacity&quot;</span>, executor.getQueue().remainingCapacity());<br>            <br>            <span class="hljs-comment">// 计算指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;activeRatio&quot;</span>, String.format(<span class="hljs-string">&quot;%.2f%%&quot;</span>, executor.getActiveRatio() * <span class="hljs-number">100</span>));<br>            poolInfo.put(<span class="hljs-string">&quot;queueUsageRatio&quot;</span>, String.format(<span class="hljs-string">&quot;%.2f%%&quot;</span>, executor.getQueueUsageRatio() * <span class="hljs-number">100</span>));<br>            poolInfo.put(<span class="hljs-string">&quot;avgExecutionTimeMs&quot;</span>, String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, executor.getAverageExecutionTimeMs()));<br>            <br>            <span class="hljs-comment">// 异常指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;rejectedCount&quot;</span>, executor.getRejectedCount());<br>            poolInfo.put(<span class="hljs-string">&quot;exceptionCount&quot;</span>, executor.getExceptionCount());<br>            <br>            result.put(entry.getKey(), poolInfo);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-meta">@WriteOperation</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">adjustPoolSize</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@Selector</span> String poolName,</span><br><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> Integer corePoolSize,</span><br><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> Integer maximumPoolSize)</span> &#123;<br>        <br>        <span class="hljs-type">MonitoredThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> executors.get(poolName);<br>        <span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程池不存在: &quot;</span> + poolName;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (corePoolSize != <span class="hljs-literal">null</span>) &#123;<br>            executor.adjustCorePoolSize(corePoolSize);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (maximumPoolSize != <span class="hljs-literal">null</span>) &#123;<br>            executor.adjustMaximumPoolSize(maximumPoolSize);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;调整成功&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的 activeCount 是每个 worker 是否互斥 held 的总数的统计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getActiveCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// workers 是一个 HashSet，它是非线程安全的。</span><br>getActiveCount 需要遍历这个集合，如果不加全局的 mainLock，在遍历过程中如果有线程销毁或创建，会抛出 ConcurrentModificationException 或者读到错误的数据。所以 mainLock 是为了保护 workers 集合的遍历安全。<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (Worker w : workers)<br>                <span class="hljs-comment">// 在 ThreadPoolExecutor 的设计中，Worker 只要开始执行任务（runWorker 方法中），就会把自己锁住（lock）。</span><br>                <span class="hljs-comment">// 当 Worker 没有任务做，正在 getTask() 方法里阻塞等待（即空闲状态）时，它是**不加锁（unlocked）**的。</span><br>               <span class="hljs-comment">// 所以，isLocked() == true 等价于 “这个线程正在干活”。</span><br>getActiveCount 的目的就是统计“当前有多少个线程正在干活”，所以必须统计被锁住的 Worker。<br>                <span class="hljs-keyword">if</span> (w.isLocked())<br>                    ++n;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里的 isLocked 意味着这个工作线程正在跑  task 的run，意味着可能是如下状态：RUNNABLE、BLOCKED、WAITING、TIMED_WAITING。</p>
<h2 id="线程组">线程组</h2>
<p>线程组提供一个“集合”，可以把一群线程归于一处，可以批量 interrupt/stop/suspend。<br>
但这个方案是很危险的，使用线程池和并发安全的 Collection 都可以管理好线程。</p>
<h3 id="原本设计目的">原本设计目的</h3>
<ul>
<li>资源管理：将相关线程组织在一起，便于批量操作</li>
<li>安全隔离：不同线程组可以有不同的安全策略</li>
<li>异常处理：提供组级别的未捕获异常处理</li>
<li>层次结构：支持线程组的嵌套（parent-child关系）</li>
</ul>
<h3 id="缺陷">缺陷</h3>
<ul>
<li>API设计不一致且不完整</li>
<li>线程安全问题</li>
<li>功能缺失</li>
<li>安全模型过时</li>
</ul>
<h3 id="替代方案">替代方案</h3>
<ul>
<li>Executor框架</li>
<li>CompletableFuture</li>
<li>ForkJoinPool</li>
</ul>
<h3 id="官方态度">官方态度</h3>
<ul>
<li>Java 17+：线程组API标记为<code>@Deprecated(forRemoval = true)</code></li>
<li>JEP 411：移除SecurityManager，线程组失去最后的存在意义</li>
<li>OpenJDK邮件列表：多次讨论完全移除线程组</li>
</ul>
<h2 id="completionstage">CompletionStage</h2>
<p>这是定义“可能是”异步计算的一个阶段，可能被其他阶段触发，也可以触发其他阶段。它是 CompletableFuture 的父接口。</p>
<p>它有一个特点，大量非 void 方法返回值都是 CompletionStage 类型，这样既允许 builder 模式，也允许各种 transformation 模式。</p>
<h2 id="completablefuture">CompletableFuture</h2>
<p>线程池的超时中断机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">invokeAll(tasks, <span class="hljs-number">300L</span>, TimeUnit.MILLISECONDS);<br></code></pre></td></tr></table></figure>
<p>会让这个类型中断提前返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">432369</span>-Caused by: java.lang.InterruptedException: <span class="hljs-literal">null</span><br><span class="hljs-number">432370</span>- at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:<span class="hljs-number">347</span>)<br><span class="hljs-number">432371</span>- at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:<span class="hljs-number">1915</span>)<br><span class="hljs-number">432372</span>- at org.apache.dubbo.rpc.AsyncRpcResult.get(AsyncRpcResult.java:<span class="hljs-number">196</span>)<br><span class="hljs-number">432373</span>- at org.apache.dubbo.rpc.protocol.AbstractInvoker.waitForResultIfSync(AbstractInvoker.java:<span class="hljs-number">266</span>)<br><span class="hljs-number">432374</span>- at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:<span class="hljs-number">186</span>)<br><span class="hljs-number">432375</span>- at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invokeWithContext(AbstractClusterInvoker.java:<span class="hljs-number">379</span>)<br><span class="hljs-number">432376</span>- at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:<span class="hljs-number">81</span>)<br></code></pre></td></tr></table></figure>
<h1>小技巧</h1>
<h2 id="如何处理任务超时问题">如何处理任务超时问题</h2>
<h3 id="方法1：使用-futuretask-的实现">方法1：使用 FutureTask 的实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">    Future&lt;Map&lt;String, Object&gt;&gt; future = executor.submit(() -&gt; getFeatures(context, zeusSceneId));<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 穷人版超时：最简单的超时不是使用 circuit breaker，而是使用 FutureTask 的缺省超时实现，这个方案取不到值的时候底层会返回 TimeoutException，只要捕获这个超时就可以走入 fallback 逻辑</span><br>                features.putAll(future.get(paramCollectTimeout, TimeUnit.MILLISECONDS));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;<br>                <span class="hljs-comment">// fallback logic</span><br>            &#125;<br>            <br>    <span class="hljs-comment">// 其中 FutureTask 的实现是：</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>        <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>        <span class="hljs-comment">// 等待结束后抛出异常而不是空指针，否则调用 report 方法</span><br>        <span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>            (s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>        <span class="hljs-keyword">return</span> report(s);<br>    &#125;<br>    <br><span class="hljs-comment">// 约等价于</span><br>其中超时底层的最简单实现是：<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br>    <br>    <span class="hljs-comment">// 循环等待，直到任务完成或超时</span><br>    <span class="hljs-keyword">while</span> (state &lt;= COMPLETING) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> deadline - System.nanoTime();<br>        <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0L</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();  <span class="hljs-comment">// 超时了</span><br>        &#125;<br>        LockSupport.parkNanos(<span class="hljs-built_in">this</span>, remaining);  <span class="hljs-comment">// 等待指定时间</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> report(state);  <span class="hljs-comment">// 返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法2：使用条件变量">方法2：使用条件变量</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发出调用</span><br>condition.await<br><span class="hljs-comment">// 非阻塞地调用 isDone 方法，抛出异常或取值</span><br><span class="hljs-comment">// 这是方法1 的泛化实现</span><br></code></pre></td></tr></table></figure>
<h3 id="方法3：使用-countdownlatch-cyclicbarrier">方法3：使用 countDownLatch/CyclicBarrier</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发出调用</span><br>无锁的 await<br><span class="hljs-comment">// 非阻塞地调用 isDone 方法，抛出异常或取值，但要注意其他线程对 done 状态的维护</span><br></code></pre></td></tr></table></figure>
<p>这个方法不需要依赖于 ReentrantLock，是通过纯 AQS 实现的，见 CountDownLatch 源码。</p>
<h2 id="自定义线程池实现自定义中断">自定义线程池实现自定义中断</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">待补充<br></code></pre></td></tr></table></figure>
<h1>Java 异步执行中的异常处理与线程生命周期</h1>
<h2 id="从-futuretask-asyncuncaughtexceptionhandler-到-uncaughtexceptionhandler">从 FutureTask、AsyncUncaughtExceptionHandler 到 UncaughtExceptionHandler</h2>
<p>在 Java 并发和 Spring 异步执行模型中，异常处理涉及多个抽象层级：<br>
JVM 线程模型、JDK 并发工具以及 Spring 框架本身。</p>
<p>这些层级各自对异常承担不同职责，但它们的行为经常被混淆，典型问题包括：</p>
<ul>
<li>异步任务抛出的异常为何没有日志</li>
<li><code>UncaughtExceptionHandler</code> 在线程池中为何不生效</li>
<li><code>AsyncUncaughtExceptionHandler</code> 是否会影响线程生命周期</li>
</ul>
<p>本文从<strong>线程是否终止</strong>这一确定性问题出发，系统梳理三种机制的边界与协作方式。</p>
<hr>
<h2 id="一-线程是否终止的唯一判定标准">一、线程是否终止的唯一判定标准</h2>
<p>在 JVM 层面，线程是否终止只取决于一个条件：</p>
<blockquote>
<p><strong>是否存在未被捕获、并逃逸出 <code>Thread.run()</code> 的 <code>Throwable</code></strong>。从这个 run 出去以后，就进入 jvm 的cpp 代码的接管范围</p>
</blockquote>
<p>这一规则与使用何种框架无关。</p>
<h3 id="1-1-会导致线程终止的情况">1.1 会导致线程终止的情况</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<ul>
<li>异常未被捕获</li>
<li>异常逃逸出 run()</li>
<li>JVM 调用 UncaughtExceptionHandler</li>
<li>线程终止</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<p>源码位置：<a target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/c55d012dd067/src/share/vm/runtime/thread.cpp#l1799">Thread 的实现</a><br>
还可以参考这个：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chuyouyinghe/article/details/134306409">《01.崩溃捕获设计实践方案 crash方案》</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">JavaThread::exit</span><span class="hljs-params">(<span class="hljs-type">bool</span> destroy_vm)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_pending_exception</span>()) &#123;<br>        <span class="hljs-function">Handle <span class="hljs-title">exception</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, pending_exception())</span></span>;<br>        <span class="hljs-built_in">clear_pending_exception</span>();<br>        <br>        <span class="hljs-comment">// 直接内联处理，无单独 uncaught_exception 方法</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">threadObj</span>() != <span class="hljs-literal">NULL</span>) &#123;<br>            Klass* klass = SystemDictionary::<span class="hljs-built_in">Thread_klass</span>();<br>            <span class="hljs-comment">// ... 通过 JNI 调用 Java 层 uncaughtException</span><br>            JavaCalls::<span class="hljs-built_in">call_virtual</span>(&amp;result, klass, <br>                                   vmSymbols::<span class="hljs-built_in">uncaughtException_name</span>(),<br>                                   vmSymbols::<span class="hljs-built_in">thread_throwable_void_signature</span>(),<br>                                   &amp;args, <span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant JVM as JVM(C++)
    participant JavaThread as JavaThread(C++)
    participant ThreadJava as java.lang.Thread
    
    JVM-&gt;&gt;JavaThread: 线程执行中抛出异常
    JavaThread-&gt;&gt;JavaThread: set_pending_exception(exception)
    JVM-&gt;&gt;JavaThread: 线程退出调用 exit()
    JavaThread-&gt;&gt;JavaThread: has_pending_exception()
    JavaThread-&gt;&gt;JavaThread: 直接在 exit() 中处理
    JavaThread-&gt;&gt;ThreadJava: JNI call_virtual(&quot;uncaughtException&quot;)
    ThreadJava-&gt;&gt;ThreadJava: 实际调用 java.lang.Thread.uncaughtException
    ThreadJava-&gt;&gt;ThreadJava: dispatchUncaughtException(e)
    ThreadJava-&gt;&gt;ThreadGroup: getUncaughtExceptionHandler()
    ThreadGroup-&gt;&gt;SystemErr: 默认处理</code></pre>
<h3 id="1-2-不会导致线程终止的情况">1.2 不会导致线程终止的情况</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// handled</span><br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<ul>
<li>异常被捕获</li>
<li>JVM 不介入</li>
<li>线程继续运行</li>
</ul>
<p>结论：</p>
<ul>
<li>异常是否被捕获，决定了线程是否终止；</li>
<li>异常由谁处理，并不决定线程生死。</li>
</ul>
<h2 id="二-futuretask-对异常传播路径的改变">二、FutureTask 对异常传播路径的改变</h2>
<p>理解线程池与 Spring 异步行为，必须先理解 FutureTask。</p>
<h3 id="2-1-execute-与-submit-的根本差异">2.1 execute 与 submit 的根本差异</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">executor.execute(runnable);<br>executor.submit(callable);<br></code></pre></td></tr></table></figure>
<p>差异不在返回值，而在执行结构：</p>
<ul>
<li><code>execute</code>：<code>Runnable</code>直接在线程中执行</li>
<li><code>submit</code>：任务先被包装为<code>FutureTask</code>，再执行</li>
</ul>
<h3 id="2-2-futuretask-中的异常拦截点">2.2 FutureTask 中的异常拦截点</h3>
<p>FutureTask.run() 的核心逻辑如下（简化）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        callable.call();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        setException(ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键点：</p>
<ul>
<li>Throwable 被主动捕获</li>
<li>异常不会逃逸出 run()</li>
<li>JVM 不认为线程发生未捕获异常<br>
线程不会终止</li>
</ul>
<p>异常在这里已经脱离“线程异常”的语义。</p>
<h3 id="2-3-异常如何被重新抛出：report">2.3 异常如何被重新抛出：report()</h3>
<p>异常并未消失，而是作为执行结果存储：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">outcome = ex;<br>state = EXCEPTIONAL;<br></code></pre></td></tr></table></figure>
<p>在调用<code>Future.get()</code>时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;<br>    <span class="hljs-keyword">if</span> (s == NORMAL)<br>        <span class="hljs-keyword">return</span> (V) x;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable) x);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>report()</code>的职责是：</p>
<ul>
<li>将“执行结果状态”翻译为 Java 异常语义</li>
<li>将原始异常包装为 ExecutionException</li>
</ul>
<p>结论：</p>
<blockquote>
<p>FutureTask 将异常从“线程控制流”转移为“任务结果数据”。</p>
</blockquote>
<h2 id="三-uncaughtexceptionhandler-的职责边界">三、UncaughtExceptionHandler 的职责边界</h2>
<h3 id="3-1-触发条件">3.1 触发条件</h3>
<p><code>UncaughtExceptionHandler</code>仅在以下条件满足时被调用：</p>
<ul>
<li>异常未被捕获</li>
<li>异常逃逸出<code>Thread.run()</code></li>
<li>线程即将终止</li>
</ul>
<p>JVM 调用顺序为：</p>
<ol>
<li>Thread 自身的 handler</li>
<li>ThreadGroup</li>
<li>DefaultUncaughtExceptionHandler</li>
<li>JVM 默认 stderr</li>
</ol>
<h3 id="3-2-能力与限制">3.2 能力与限制</h3>
<p><code>UncaughtExceptionHandler</code>：</p>
<ul>
<li>无法阻止线程终止</li>
<li>无法恢复线程执行</li>
<li>仅用于日志、告警等系统级兜底</li>
</ul>
<p>在线程池中，只有 <code>execute()</code>且异常未被捕获时，才可能触发该 handler。</p>
<h2 id="四-spring-asyncuncaughtexceptionhandler-的作用范围">四、Spring AsyncUncaughtExceptionHandler 的作用范围</h2>
<h3 id="4-1-适用条件">4.1 适用条件</h3>
<p>Spring 明确限定：</p>
<ul>
<li>仅处理 @Async 标注的 void 方法</li>
<li>不处理返回 Future / CompletableFuture 的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Async</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-2-spring-的异常拦截方式">4.2 Spring 的异常拦截方式</h3>
<p>Spring 在异步调用边界处捕获异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    invokeMethod();<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>    asyncUncaughtExceptionHandler.handle(ex, method, params);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-3-对线程生命周期的影响">4.3 对线程生命周期的影响</h3>
<p><code>AsyncUncaughtExceptionHandler</code>：</p>
<ul>
<li>不会阻止线程终止</li>
<li>也不会导致线程终止</li>
</ul>
<p>原因是：</p>
<ul>
<li>异常已经被 Spring 捕获</li>
<li>JVM 无法感知未捕获异常</li>
<li>线程本身没有死亡条件</li>
</ul>
<p>结论：</p>
<ul>
<li>AsyncUncaughtExceptionHandler 只影响异常的业务处理路径，不影响线程生命周期。</li>
</ul>
<h2 id="五-三种异常路径的对比">五、三种异常路径的对比</h2>
<h3 id="5-1-async-void-方法">5.1 @Async void 方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Async</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">方法执行<br> → Spring 捕获<br> → AsyncUncaughtExceptionHandler<br> → 线程继续运行<br></code></pre></td></tr></table></figure>
<h3 id="5-2-线程池execute">5.2 线程池<code>execute</code></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">executor.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable.run<br> → 异常逃逸<br> → JVM<br> → UncaughtExceptionHandler<br> → 线程终止<br></code></pre></td></tr></table></figure>
<h3 id="5-3-线程池-submit">5.3 线程池 submit</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;?&gt; future = executor.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask.run<br> → <span class="hljs-keyword">catch</span> Throwable<br> → 异常存入 Future<br> → get() 时抛 ExecutionException<br></code></pre></td></tr></table></figure>
<h2 id="六-两种-handler-的推荐使用方式">六、两种 Handler 的推荐使用方式</h2>
<h3 id="6-1-asyncuncaughtexceptionhandler-业务层">6.1 AsyncUncaughtExceptionHandler（业务层）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AsyncConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> AsyncUncaughtExceptionHandler <span class="hljs-title function_">getAsyncUncaughtExceptionHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (ex, method, params) -&gt; &#123;<br>            log.error(<span class="hljs-string">&quot;Async void method failed: &#123;&#125;&quot;</span>, method.getName(), ex);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li>@Async void 方法</li>
<li>业务补偿、告警、日志</li>
</ul>
<h3 id="6-2-uncaughtexceptionhandler-系统层">6.2 UncaughtExceptionHandler（系统层）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> r -&gt; &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>    t.setUncaughtExceptionHandler((thread, ex) -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Thread &#123;&#125; terminated&quot;</span>, thread.getName(), ex);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;;<br><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(),<br>    factory<br>);<br></code></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li><code>execute()</code>执行的任务</li>
<li>系统级兜底监控</li>
</ul>
<h3 id="6-3-有返回值的异步任务">6.3 有返回值的异步任务</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture<br>    .supplyAsync(<span class="hljs-built_in">this</span>::work, executor)<br>    .exceptionally(ex -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Async failed&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<p>必须显式消费异常，否则异常不会被观察到。</p>
<h2 id="结论">结论</h2>
<ol>
<li>线程是否终止，仅由异常是否逃逸到 JVM 决定</li>
<li>FutureTask 和 Spring 已在更高层捕获异常，因此不会触发 JVM 机制</li>
<li>AsyncUncaughtExceptionHandler 不控制线程生死，仅提供业务回调</li>
<li>UncaughtExceptionHandler 只用于处理线程终止前的系统级事件</li>
</ol>
<h1>Spring 的异步支持</h1>
<ul>
<li>如果只是<code>@EnableAsync</code>，Spring 会创建一个默认的 SimpleAsyncTaskExecutor（注意不是 ThreadPoolTaskExecutor）：
<ul>
<li><strong>每个任务都会创建新线程</strong></li>
<li>没有线程池复用</li>
<li>性能较差，不适合生产环境</li>
</ul>
</li>
<li>在这个基础上，再实现<code>AsyncConfigurer.getAsyncExecutor()</code>就可以让自己的线程池替代框架的 Bean。</li>
</ul>
<h2 id="threadpooltaskexecutor">ThreadPoolTaskExecutor</h2>
<p>ThreadPoolTaskExecutor 是 ExecutorConfigurationSupport 的子类，也包装了一个 ThreadPoolExecutor。</p>
<ul>
<li>ExecutorConfigurationSupport 作为基类提供了：
<ul>
<li>生命周期管理：实现了 InitializingBean, DisposableBean</li>
<li>配置管理：线程工厂、拒绝策略、优雅关闭等配置</li>
<li>模板方法：定义了初始化和销毁的标准流程</li>
</ul>
</li>
</ul>
<p>特别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>    initialize();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isInfoEnabled()) &#123;<br>        <span class="hljs-built_in">this</span>.logger.info(<span class="hljs-string">&quot;Initializing ExecutorService &quot;</span> + (<span class="hljs-built_in">this</span>.beanName != <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot; &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.beanName + <span class="hljs-string">&quot;&#x27;&quot;</span> : <span class="hljs-string">&quot;&quot;</span>));<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.threadNamePrefixSet &amp;&amp; <span class="hljs-built_in">this</span>.beanName != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.setThreadNamePrefix(<span class="hljs-built_in">this</span>.beanName + <span class="hljs-string">&quot;-&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 调用子类的具体实现</span><br>    <span class="hljs-built_in">this</span>.executor = <span class="hljs-built_in">this</span>.initializeExecutor(<span class="hljs-built_in">this</span>.threadFactory, <span class="hljs-built_in">this</span>.rejectedExecutionHandler);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以在这个 bean 被使用以前，内部线程池要经过一个 afterPropertiesSet 驱动进行初始化和注入这个 ThreadPoolTaskExecutor 线程池外壳。</p>
<h2 id="threadpooltaskexecutor-内部线程池的替换">ThreadPoolTaskExecutor 内部线程池的替换</h2>
<h3 id="推荐：使用初始化器装饰">推荐：使用初始化器装饰</h3>
<p>initializeExecutor 初始化过程里会允许我们装饰这个线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> ExecutorService <span class="hljs-title function_">initializeExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">        ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;<br><br>    BlockingQueue&lt;Runnable&gt; queue = createQueue(<span class="hljs-built_in">this</span>.queueCapacity);<br><br>    ThreadPoolExecutor executor;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.taskDecorator != <span class="hljs-literal">null</span>) &#123;<br>        executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-built_in">this</span>.corePoolSize, <span class="hljs-built_in">this</span>.maxPoolSize, <span class="hljs-built_in">this</span>.keepAliveSeconds, TimeUnit.SECONDS,<br>                queue, threadFactory, rejectedExecutionHandler) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>                <span class="hljs-type">Runnable</span> <span class="hljs-variable">decorated</span> <span class="hljs-operator">=</span> taskDecorator.decorate(command);<br>                <span class="hljs-keyword">if</span> (decorated != command) &#123;<br>                    decoratedTaskMap.put(decorated, command);<br>                &#125;<br>                <span class="hljs-built_in">super</span>.execute(decorated);<br>            &#125;<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-built_in">this</span>.corePoolSize, <span class="hljs-built_in">this</span>.maxPoolSize, <span class="hljs-built_in">this</span>.keepAliveSeconds, TimeUnit.SECONDS,<br>                queue, threadFactory, rejectedExecutionHandler);<br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.allowCoreThreadTimeOut) &#123;<br>        executor.allowCoreThreadTimeOut(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.threadPoolExecutor = executor;<br>    <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>java 线程池的装饰逻辑就是<strong>只覆盖一个</strong><code>public void execute(Runnable command)</code>即可。</p>
<p>这个方法本质上是<strong>一切线程池外部提交/执行操作的入口</strong>，所以<strong>它的执行线程是外部线程而已不是工作线程</strong>。</p>
<p>可以说<strong>这个壳的其他方法都只是包装一下普通线程的成员方法，但是这个 initializeExecutor 和 decorate 是这个壳特有的，是它存在的意义</strong>。</p>
<p>所有外部 command 在执行前都要被 decorate 一下，而且存在 decoratedTaskMap 里，模式是装饰后-&gt;原始命令。目前这个map没有用处，未来可能在用修饰后的任务找原始 Runnable 的时候会有用。</p>
<h3 id="其他代理">其他代理</h3>
<p>其他方法都是用<strong>类似的模式来代理的，而且不支持多态</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> getThreadPoolExecutor();<br>    <span class="hljs-keyword">try</span> &#123;<br>        executor.execute(task);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskRejectedException</span>(<span class="hljs-string">&quot;Executor [&quot;</span> + executor + <span class="hljs-string">&quot;] did not accept task: &quot;</span> + task, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="如果我们要替换线程池实现">如果我们要替换线程池实现</h3>
<p>我们只能用反射来替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;bizCommonTaskExecutor&quot;)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ThreadPoolTaskExecutor <span class="hljs-title function_">getAsyncExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建支持EagleEye上下文传递的ThreadPoolTaskExecutor</span><br>    <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">taskExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> ThreadPoolExecutor <span class="hljs-title function_">initializeExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">                ThreadFactory threadFactory,</span><br><span class="hljs-params">                RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;<br>            <span class="hljs-comment">// 创建阻塞队列</span><br>            BlockingQueue&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY);<br>            <br>            <span class="hljs-comment">// 创建支持EagleEye上下文传递的线程池</span><br>            <span class="hljs-type">EagleEyeContextAwareThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EagleEyeContextAwareThreadPoolExecutor</span>(<br>                CORE_POOL_SIZE,<br>                MAX_POOL_SIZE,<br>                KEEP_ALIVE_SECONDS,<br>                TimeUnit.SECONDS,<br>                queue,<br>                threadFactory,<br>                rejectedExecutionHandler<br>            );<br><br>            <span class="hljs-comment">// 使用反射将executor赋值给父类的private threadPoolExecutor字段，这是目前唯一的方法</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                java.lang.reflect.<span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> ThreadPoolTaskExecutor.class.getDeclaredField(<span class="hljs-string">&quot;threadPoolExecutor&quot;</span>);<br>                field.setAccessible(<span class="hljs-literal">true</span>);<br>                field.set(<span class="hljs-built_in">this</span>, executor);<br>                <span class="hljs-comment">// 如果有必要，要存储老的 accessible，在 set 完了以后要还原</span><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LoggerUtils.error(LOGGER, <span class="hljs-string">&quot;Failed to set threadPoolExecutor via reflection&quot;</span>, e);<br>            &#125;<br>            <br>            <span class="hljs-keyword">return</span> executor;<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-comment">// 配置线程名前缀</span><br>    taskExecutor.setThreadNamePrefix(<span class="hljs-string">&quot;bd-common-async-&quot;</span>);<br>    <br>    <span class="hljs-comment">// 配置优雅停机</span><br>    taskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="hljs-literal">true</span>);<br>    taskExecutor.setAwaitTerminationSeconds(AWAIT_TERMINATION_SECONDS);<br>    <br>    <span class="hljs-keyword">return</span> taskExecutor;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们不推荐使用这种做法，除非我们真的<strong>有增强 execute 以外的诉求</strong>。</p>
<h2 id="对线程池实行-trace-传递">对线程池实行 trace 传递</h2>
<h3 id="如果使用统一包装器">如果使用统一包装器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法的第一层参数是 ThreadPoolTaskExecutor 的 execute 执行的时候的这个 command：</span><br><span class="hljs-comment">//              public void execute(Runnable command) &#123;</span><br><span class="hljs-comment">//                  Runnable decorated = taskDecorator.decorate(command);</span><br> taskExecutor.setTaskDecorator(runnable -&gt; &#123;<br>            <br>            <span class="hljs-comment">// 这里获取外部提交的时候的线程和上下文</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">submitThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <br>            <span class="hljs-comment">// 这里返回一个 runnable，给外部的 super.execute(decorated); 使用，这个方法就是原始线程池的 execute 了</span><br>            <span class="hljs-keyword">return</span> () -&gt; &#123;<br>                <span class="hljs-comment">// 这里开始执行的时候通常已经进入线程池的 worker 内部了</span><br>                <br>                <span class="hljs-comment">// 当拒绝策略为 CallerRunsPolicy 且在提交线程中执行时，直接运行即可</span><br>                <span class="hljs-keyword">if</span> (submitThread == Thread.currentThread()) &#123;<br>                    runnable.run();<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">oldContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (oldContext == <span class="hljs-literal">null</span>) &#123;<br>                        needClean = <span class="hljs-literal">true</span>;<br>                        EagleEye.setRpcContext(rpcContext);<br>                    &#125;<br>                    <span class="hljs-comment">// 这是在内部线程 run 之前执行的围绕操作</span><br>                    runnable.run();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span> (needClean) &#123;<br>                        EagleEye.clearRpcContext();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>        &#125;);<br></code></pre></td></tr></table></figure>
<p>其中装饰器被调用的地方是就是上面的<a href="#%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E8%A3%85%E9%A5%B0">使用初始化器装饰</a>。</p>
<p>本质上 executor 共有三个入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (EagleEye.currentRpcContext() == <span class="hljs-literal">null</span>) &#123;<br>                needClean = <span class="hljs-literal">true</span>;<br>                EagleEye.setRpcContext(rpcContext);<br>            &#125;<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (needClean) &#123;<br>                    EagleEye.clearRpcContext();<br>                &#125;<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (EagleEye.currentRpcContext() == <span class="hljs-literal">null</span>) &#123;<br>                needClean = <span class="hljs-literal">true</span>;<br>                EagleEye.setRpcContext(rpcContext);<br>            &#125;<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (needClean) &#123;<br>                    EagleEye.clearRpcContext();<br>                &#125;<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>    <span class="hljs-keyword">if</span> (command <span class="hljs-keyword">instanceof</span> FutureTask) &#123;<br>        <span class="hljs-built_in">super</span>.execute(command);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.execute(() -&gt; &#123;<br>            EagleEye.setRpcContext(rpcContext);<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                command.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                EagleEye.clearRpcContext();<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>前两个 newTaskFor 是其他 submit 方法到 execute 之前的底层方法。因为前两个入口最终都会调到<code>execute(Runnable command)</code>，所以它的内部要避开<code>if (command instanceof FutureTask) {</code>的场景。这个设计因此显得比较累赘。</p>
<p>实际上 decorator 的实现就是最佳的，最终只要实现一个 execute 的包装提交就行了。</p>
<p>这个实现里有一个地方要注意：执行完当前的 runnable 需要 clear，否则可能会出现以前有的遗留 traceId 污染的问题。</p>
<p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">《一行一行源码分析清楚AbstractQueuedSynchronizer》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《Java线程池实现原理及其在美团业务中的实践》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016058789">《Keep Coding》</a></li>
</ol>
<hr>
<h1>ForkJoinPool详解：分治并行的执行引擎</h1>
<p><img src="java-thread-x-forkjoin-%E5%8F%AA%E5%8F%91%E7%94%9F%E5%9C%A8%E5%90%8C%E5%B1%82%E4%B9%8B%E9%97%B4.png" alt="java-thread-x-forkjoin-只发生在同层之间.png"></p>
<h2 id="前言：分治并行的诞生">前言：分治并行的诞生</h2>
<p>ForkJoinPool 不是为了通用&quot;并行&quot;而设计，而是专门为<strong>分治并行</strong>（Divide-and-Conquer Parallelism）这一特定模式量身定制。分治算法（如快速排序、归并排序、树遍历）具有独特的执行模式：</p>
<ul>
<li>任务天然形成树状结构</li>
<li>父任务派生子任务后需要等待结果</li>
<li>子任务之间通常无依赖关系</li>
<li>计算密集，无I/O阻塞</li>
</ul>
<p>理解分治算法的执行特性，是理解 ForkJoinPool 设计的关键。传统线程池在处理这类任务时遇到根本性挑战，ForkJoinPool 正是为解决这些挑战而诞生。</p>
<h2 id="1-核心数据结构：forkjoinpool的基石">1. 核心数据结构：ForkJoinPool的基石</h2>
<h3 id="1-1-forkjoinpool：去中心化的调度器">1.1 ForkJoinPool：去中心化的调度器</h3>
<h4 id="数据结构定义">数据结构定义</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-comment">// 64位控制状态：编码活跃线程数、空闲线程数、任务计数</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> ctl;<br>    <br>    <span class="hljs-comment">// 工作队列数组：每个工作线程一个队列</span><br>    <span class="hljs-keyword">volatile</span> WorkQueue[] workQueues; <span class="hljs-comment">// 与TPE的关键区别：TPE用HashSet&lt;Worker&gt;持有线程，</span><br>                                     <span class="hljs-comment">// 而FJP不需要持有工作线程集合，因为：</span><br>                                     <span class="hljs-comment">// 1. 线程通过ctl字段的位操作管理</span><br>                                     <span class="hljs-comment">// 2. 任务调度通过workQueues数组实现</span><br>                                     <span class="hljs-comment">// 3. 工作窃取算法只需要访问队列，不需要直接访问线程</span><br>    <br>    <span class="hljs-comment">// 专用线程工厂</span><br>    <span class="hljs-keyword">final</span> ForkJoinWorkerThreadFactory factory;<br>    <br>    <span class="hljs-comment">// 未捕获异常处理器</span><br>    <span class="hljs-keyword">final</span> UncaughtExceptionHandler ueh;<br>    <br>    <span class="hljs-comment">// 配置参数</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> config; <span class="hljs-comment">// 低16位：并行度（parallelism）</span><br>    <br>    <span class="hljs-comment">// 静态公共池</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ForkJoinPool <span class="hljs-title function_">commonPool</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="与threadpoolexecutor的本质区别">与ThreadPoolExecutor的本质区别</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadPoolExecutor的核心结构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue; <span class="hljs-comment">// 单一共享队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers;          <span class="hljs-comment">// Worker线程集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;               <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;            <span class="hljs-comment">// 最大线程数</span><br>&#125;<br><br><span class="hljs-comment">// ForkJoinPool的核心结构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-keyword">volatile</span> WorkQueue[] workQueues;                <span class="hljs-comment">// 工作队列数组，每个 ForkjoinWokerThread 持有一个 workQueue，这个池就持有一个 workQueue 数组</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> ctl;                              <span class="hljs-comment">// 64位状态控制</span><br>    <span class="hljs-comment">// 无corePoolSize/maximumPoolSize概念</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="关键差异">关键差异</h4>
<ul>
<li><strong>队列模型</strong>：TPE使用单一共享队列，FJP使用每个线程私有队列</li>
<li><strong>线程管理</strong>：TPE有明确的core/max参数，FJP只有目标并行度</li>
<li><strong>调度策略</strong>：TPE基于生产者-消费者模型，FJP基于工作窃取模型</li>
</ul>
<h3 id="1-2-forkjoinworkerthreadfactory：专用线程工厂">1.2 ForkJoinWorkerThreadFactory：专用线程工厂</h3>
<h4 id="接口定义与对比">接口定义与对比</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 标准ThreadFactory接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建新线程</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r 线程要执行的Runnable</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 新线程</span><br><span class="hljs-comment">     */</span><br>    Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span>;<br>&#125;<br><br><span class="hljs-comment">// ForkJoinWorkerThreadFactory接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ForkJoinWorkerThreadFactory</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建新的ForkJoinWorkerThread</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pool 线程所属的ForkJoinPool</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 新的工作线程</span><br><span class="hljs-comment">     */</span><br>    ForkJoinWorkerThread <span class="hljs-title function_">newThread</span><span class="hljs-params">(ForkJoinPool pool)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="关键区别">关键区别</h4>
<ul>
<li>完全不同的接口：两者没有继承关系，签名完全不同</li>
<li>上下文差异：标准工厂只接收Runnable，即任务，负责包装出线程；FJP工厂接收 ForkJoinPool 即线程池。</li>
<li>线程定制能力：线程工厂通常可以设置：
<ul>
<li>线程名称（便于调试）</li>
<li>线程优先级（Thread.setPriority()）</li>
<li>守护状态（Thread.setDaemon()）</li>
<li>上下文类加载器（Thread.setContextClassLoader()）</li>
<li>异常处理器（Thread.setUncaughtExceptionHandler()）</li>
<li>为什么在工厂里创建，传统工厂使用这个接口把任务包装成进程，并且启动：<code>thread.start(); // 一旦 start()，大部分属性就无法修改了</code></li>
</ul>
</li>
</ul>
<h5 id="fjp-的扩展方法">FJP 的扩展方法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinPool;<br><span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinWorkerThread;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomForkJoinWorkerThreadFactory</span> <br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ForkJoinPool</span>.ForkJoinWorkerThreadFactory &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String poolName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> threadPriority;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader contextClassLoader;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomForkJoinWorkerThreadFactory</span><span class="hljs-params">(</span><br><span class="hljs-params">        String poolName, </span><br><span class="hljs-params">        <span class="hljs-type">int</span> threadPriority,</span><br><span class="hljs-params">        ClassLoader contextClassLoader</span><br><span class="hljs-params">    )</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolName = poolName;<br>        <span class="hljs-built_in">this</span>.threadPriority = threadPriority;<br>        <span class="hljs-built_in">this</span>.contextClassLoader = contextClassLoader;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ForkJoinWorkerThread <span class="hljs-title function_">newThread</span><span class="hljs-params">(ForkJoinPool pool)</span> &#123;<br>        <span class="hljs-comment">// 1. 使用默认工厂创建基础线程</span><br>        <span class="hljs-type">ForkJoinWorkerThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);<br>        <br>        <span class="hljs-comment">// 2. 自定义线程名称（便于调试）</span><br>        thread.setName(String.format(<span class="hljs-string">&quot;%s-worker-%d&quot;</span>, poolName, threadNumber.getAndIncrement()));<br>        <br>        <span class="hljs-comment">// 3. 设置线程优先级</span><br>        thread.setPriority(threadPriority);<br>        <br>        <span class="hljs-comment">// 4. 设置上下文类加载器</span><br>        thread.setContextClassLoader(contextClassLoader);<br>        <br>        <span class="hljs-comment">// 5. 设置未捕获异常处理器（线程级别的）</span><br>        thread.setUncaughtExceptionHandler((t, e) -&gt; &#123;<br>            System.err.printf(<span class="hljs-string">&quot;[%s] 线程 %s 发生未捕获异常: %s%n&quot;</span>, <br>                poolName, t.getName(), e.getMessage());<br>            e.printStackTrace();<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 6. 其他自定义设置</span><br>        thread.setDaemon(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 虽然ForkJoinPool会强制设置，但这里显式设置</span><br>        <br>        System.out.printf(<span class="hljs-string">&quot;创建工作线程: %s, 优先级: %d, 类加载器: %s%n&quot;</span>,<br>            thread.getName(), thread.getPriority(), contextClassLoader.getClass().getSimpleName());<br>        <br>        <span class="hljs-keyword">return</span> thread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="设计意义">设计意义</h4>
<blockquote>
<p>FJP的工作线程需要知道池的存在，才能参与工作窃取算法。标准ThreadFactory无法提供这种上下文，因此需要专用接口。</p>
</blockquote>
<h3 id="1-3-forkjoinworkerthread：协作式执行者">1.3 ForkJoinWorkerThread：协作式执行者</h3>
<h4 id="数据结构">数据结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinWorkerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">// 所属线程池</span><br>    <span class="hljs-keyword">final</span> ForkJoinPool pool;<br>    <br>    <span class="hljs-comment">// 专属工作队列（由池在registerWorker时分配，而非构造函数直接创建）</span><br>    <span class="hljs-keyword">final</span> WorkQueue workQueue;<br>    <br>    <span class="hljs-comment">// 构造函数（简化示意）</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">ForkJoinWorkerThread</span><span class="hljs-params">(ForkJoinPool pool)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pool = pool;<br>        <span class="hljs-comment">// 注意：WorkQueue 不是在这里直接 new 出来的</span><br>        <span class="hljs-comment">// 实际流程是调用 pool.registerWorker(this)，由池统一分配队列</span><br>        <span class="hljs-comment">// 这确保了 WorkQueue 在 workQueues 数组中的索引由池统一管理</span><br>        <span class="hljs-built_in">this</span>.workQueue = pool.registerWorker(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="与threadpoolexecutor-worker的对比">与ThreadPoolExecutor.Worker的对比</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadPoolExecutor.Worker（组合模式）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">final</span> Thread thread;       <span class="hljs-comment">// 通过组合持有Thread</span><br>    Runnable firstTask;        <span class="hljs-comment">// 初始任务。任务和执行线程解耦，是兄弟成员。这个成员只使用一次，就在 addWorker 的时候减少对拥塞队列的锁竞争</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks; <span class="hljs-comment">// 完成任务数</span><br>&#125;<br><br><span class="hljs-comment">// ForkJoinWorkerThread（继承模式）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinWorkerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">final</span> ForkJoinPool pool;   <span class="hljs-comment">// 直接持有池引用</span><br>    <span class="hljs-keyword">final</span> WorkQueue workQueue; <span class="hljs-comment">// 专属队列</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>Worker：“可以自锁定的 runnable，初始化是把自己装进 Thread 里，run 是在线程里自旋获取拥塞队列里的任务”。</li>
<li>ForkJoinWorkerThread：“具有自主窃取能力的协作线程，run 是在本地队列空闲时主动扫描并窃取其他工作队列任务的群体智能执行器”。</li>
</ol>
<h4 id="设计决策">设计决策</h4>
<ul>
<li><strong>Worker使用组合</strong>：TPE的工作线程只需执行任务，无需特殊行为</li>
<li><strong>FJP使用继承</strong>：需要重写run()实现工作窃取，且需要池上下文。继承意味着可以直接使用线程的生命周期方法。</li>
</ul>
<h4 id="线程安全特性：为什么forkjoinpool不会有线程泄露问题？">线程安全特性：为什么ForkJoinPool不会有线程泄露问题？</h4>
<p>ForkJoinPool 在线程管理上具有两个关键特性，使其天然避免了线程泄露问题：</p>
<p><strong>1. 所有工作线程都是 Daemon 线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinPool.registerWorker() 源码片段</span><br><span class="hljs-keyword">final</span> WorkQueue <span class="hljs-title function_">registerWorker</span><span class="hljs-params">(ForkJoinWorkerThread wt)</span> &#123;<br>    wt.setDaemon(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 强制设置为守护线程</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这意味着：</p>
<ul>
<li>即使忘记调用 <code>shutdown()</code>，ForkJoinPool 的线程也<strong>不会阻止 JVM 退出</strong></li>
<li>当所有非 daemon 线程结束时，JVM 会自动终止，daemon 线程随之销毁</li>
<li>与 ThreadPoolExecutor 的关键区别：TPE 默认创建非 daemon 线程，忘记关闭会导致 JVM 无法退出</li>
</ul>
<p><strong>2. 空闲线程会被自动回收</strong></p>
<p>根据 Javadoc 文档：</p>
<blockquote>
<p>“Using the common pool normally reduces resource usage (its threads are slowly reclaimed during periods of non-use, and reinstated upon subsequent use).”</p>
</blockquote>
<p>ForkJoinPool 的线程回收机制：</p>
<ul>
<li>空闲线程不会立即销毁，而是先 <code>park()</code> 等待</li>
<li>空闲时间超过阈值后，线程主动退出 <code>run()</code> 循环</li>
<li>下次需要时重新创建，避免永久空闲线程占用资源</li>
</ul>
<p><strong>结论</strong>：由于 daemon 线程 + 自动回收机制的双重保障，ForkJoinPool 在实践中几乎不会出现线程泄露问题。但这<strong>不意味着可以忽略资源管理</strong>——对于自定义创建的 ForkJoinPool，仍建议使用 <code>try-with-resources</code>（JDK 19+）或 <code>try-finally</code> 显式关闭，以确保及时释放内部资源。</p>
<h3 id="1-4-workqueue：双端队列的实现">1.4 WorkQueue：双端队列的实现</h3>
<h4 id="数据结构">数据结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkQueue</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> base;          <span class="hljs-comment">// 队列头部索引（公开，供窃取）</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> top;           <span class="hljs-comment">// 队列尾部索引（虽主要由owner修改，但需volatile保证可见性）</span><br>    ForkJoinTask&lt;?&gt;[] array;    <span class="hljs-comment">// 任务数组（环形缓冲区）</span><br>    <span class="hljs-keyword">final</span> ForkJoinPool pool;    <span class="hljs-comment">// 所属池</span><br>    <span class="hljs-keyword">final</span> ForkJoinWorkerThread owner; <span class="hljs-comment">// 所属线程（外部提交队列的owner为null）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="核心操作">核心操作</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 本地push (LIFO)</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(ForkJoinTask&lt;?&gt; task)</span> &#123;<br>    ForkJoinTask&lt;?&gt;[] a = array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> top, cap = a.length;<br>    a[s &amp; (cap - <span class="hljs-number">1</span>)] = task;  <span class="hljs-comment">// 写入尾部</span><br>    top = s + <span class="hljs-number">1</span>;              <span class="hljs-comment">// 仅本线程修改，无锁</span><br>&#125;<br><br><span class="hljs-comment">// 本地pop (LIFO)</span><br><span class="hljs-keyword">final</span> ForkJoinTask&lt;?&gt; pop() &#123;<br>    ForkJoinTask&lt;?&gt;[] a = array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> top, cap = a.length;<br>    <span class="hljs-keyword">if</span> (s != base) &#123;          <span class="hljs-comment">// 队列非空</span><br>        ForkJoinTask&lt;?&gt; t = a[--s &amp; (cap - <span class="hljs-number">1</span>)]; <span class="hljs-comment">// 从尾部取</span><br>        a[s &amp; (cap - <span class="hljs-number">1</span>)] = <span class="hljs-literal">null</span>;<br>        top = s;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 窃取poll (FIFO)</span><br><span class="hljs-keyword">final</span> ForkJoinTask&lt;?&gt; poll() &#123;<br>    ForkJoinTask&lt;?&gt;[] a = array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> base, cap = a.length;<br>    <span class="hljs-keyword">if</span> (b != top) &#123;           <span class="hljs-comment">// 队列非空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b &amp; (cap - <span class="hljs-number">1</span>);<br>        ForkJoinTask&lt;?&gt; t = a[i];<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; <br>            base == b &amp;&amp;      <span class="hljs-comment">// 检查base未变</span><br>            UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, BASE, b, b + <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// CAS更新</span><br>            a[i] = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="lifo-fifo-的设计智慧：">LIFO + FIFO 的设计智慧：</h4>
<ul>
<li>本地LIFO：最近派生的任务最先执行，保持时间局部性（temporal locality）：
<ul>
<li>时间局部性：最近访问的数据很可能再次被访问</li>
<li>在分治算法中，最近派生的任务通常与父任务共享数据</li>
<li>保持这些数据在CPU缓存中，避免缓存失效惩罚</li>
</ul>
</li>
<li>窃取FIFO：最早派生的任务最先被窃取，保证窃取到&quot;大块&quot;任务
<ul>
<li>&quot;大块任务&quot;解释：这不是编程隐喻，而是指计算量大的任务。在分治算法中：
<ul>
<li>最早派生的任务通常是父任务分解的第一层子任务，包含大量工作</li>
<li>最近派生的任务通常是深层子任务，计算量较小</li>
</ul>
</li>
<li>例如快速排序中，根任务分解为左右子任务，这两个是&quot;大块任务&quot;；而叶子节点任务只处理几个元素，是&quot;小块任务&quot;</li>
<li>本地LIFO执行小任务（保持缓存），窃取FIFO获取大任务（避免任务碎片化）</li>
</ul>
</li>
</ul>
<h4 id="forkjointask-join-与-thread-join-的本质差异">ForkJoinTask.join() 与 Thread.join() 的本质差异</h4>
<p>这是 ForkJoinPool 能够高效处理海量递归任务而不会死锁的关键机制。两种 join 有着根本性的不同。</p>
<p><strong>Thread.join() - 阻塞式等待</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread.join() 的行为</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; doWork());<br>thread.start();<br>thread.join();  <span class="hljs-comment">// 当前线程进入 WAITING 状态，完全放弃 CPU</span><br></code></pre></td></tr></table></figure>
<p>当调用 <code>Thread.join()</code> 时：</p>
<ol>
<li>调用线程进入 <strong>WAITING</strong> 状态</li>
<li>线程被操作系统挂起，<strong>完全停止执行</strong></li>
<li>直到目标线程结束，调用线程才被唤醒</li>
<li>这是<strong>操作系统级别的线程阻塞</strong></li>
</ol>
<p><strong>ForkJoinTask.join() - 协作式等待</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinTask.join() 的行为</span><br>RecursiveTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveTask</span>&lt;&gt;() &#123;<br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        RecursiveTask&lt;Integer&gt; subtask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveTask</span>&lt;&gt;() &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br>        subtask.fork();<br>        <span class="hljs-keyword">return</span> subtask.join();  <span class="hljs-comment">// 不会阻塞工作线程</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>当调用 <code>ForkJoinTask.join()</code> 时：</p>
<ol>
<li>工作线程<strong>不会进入 WAITING 状态</strong></li>
<li>线程继续执行其他任务（work-stealing）</li>
<li>定期检查等待的任务是否完成</li>
<li>这是<strong>用户态的协作式调度</strong></li>
</ol>
<p><strong>关键差异对比</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 A
    participant T2 as 线程 B
    participant OS as 操作系统
    
    Note over T1,OS: Thread.join() - 阻塞式
    T1-&gt;&gt;T2: 启动线程 B
    T1-&gt;&gt;T1: 调用 threadB.join()
    T1-&gt;&gt;OS: 进入 WAITING 状态
    OS-&gt;&gt;T1: 挂起线程 A
    Note over T1: 线程 A 停止执行
    T2-&gt;&gt;T2: 执行任务
    T2-&gt;&gt;OS: 线程 B 结束
    OS-&gt;&gt;T1: 唤醒线程 A
    T1-&gt;&gt;T1: 继续执行
    
    Note over T1,OS: ForkJoinTask.join() - 协作式
    T1-&gt;&gt;T1: 调用 task.join()
    alt 任务已完成
        T1-&gt;&gt;T1: 直接返回结果
    else 任务未完成
        T1-&gt;&gt;T1: 尝试执行该任务
        alt 任务在本地队列
            T1-&gt;&gt;T1: 直接执行任务
        else 任务在其他队列
            T1-&gt;&gt;T1: 窃取其他任务执行
            T1-&gt;&gt;T1: 定期检查任务状态
        end
    end
    Note over T1: 线程 A 始终保持 RUNNABLE</code></pre>
<p><strong>为什么 ForkJoinTask.join() 不会导致死锁</strong></p>
<p>考虑这个递归场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveSum</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Long&gt; &#123;<br>    <span class="hljs-keyword">protected</span> Long <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (size &lt;= THRESHOLD) &#123;<br>            <span class="hljs-keyword">return</span> computeDirectly();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 父任务等待子任务</span><br>        <span class="hljs-type">RecursiveSum</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveSum</span>(leftHalf);<br>        <span class="hljs-type">RecursiveSum</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveSum</span>(rightHalf);<br>        <br>        left.fork();   <span class="hljs-comment">// 提交到队列</span><br>        right.fork();  <span class="hljs-comment">// 提交到队列</span><br>        <br>        <span class="hljs-comment">// 父任务调用 join() 等待子任务</span><br>        <span class="hljs-keyword">return</span> left.join() + right.join();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果使用 <code>Thread.join()</code>，这种模式会导致问题：</p>
<ul>
<li>父线程阻塞等待子线程</li>
<li>但子任务可能还在队列中等待执行</li>
<li>如果所有线程都在等待，就会<strong>死锁</strong></li>
</ul>
<p>使用 <code>ForkJoinTask.join()</code>，不会死锁：</p>
<ul>
<li>父任务调用 <code>join()</code> 时，工作线程不会阻塞</li>
<li>工作线程会尝试执行等待的子任务</li>
<li>如果子任务在自己的队列中，直接执行</li>
<li>如果子任务在其他队列中，窃取其他任务继续工作</li>
<li>这样<strong>父子任务永远不会相互阻塞</strong></li>
</ul>
<p><strong>实现原理：ForkJoinTask.join() 的源码逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinTask.join() 的简化逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)<br>        reportException(s);<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doJoin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;<br>    <br>    <span class="hljs-comment">// 1. 如果任务已完成，直接返回</span><br>    <span class="hljs-keyword">return</span> (s = status) &lt; <span class="hljs-number">0</span> ? s :<br>        <br>        <span class="hljs-comment">// 2. 如果是 ForkJoinWorkerThread，尝试执行或窃取</span><br>        ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) ?<br>        (w = (wt = (ForkJoinWorkerThread)t).workQueue).<br>        tryUnpush(<span class="hljs-built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="hljs-number">0</span> ? s :<br>        wt.pool.awaitJoin(w, <span class="hljs-built_in">this</span>, <span class="hljs-number">0L</span>) :<br>        <br>        <span class="hljs-comment">// 3. 外部线程，使用阻塞等待</span><br>        externalAwaitDone();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键点：</p>
<ol>
<li><strong>快速路径</strong>：任务已完成，直接返回</li>
<li><strong>工作线程路径</strong>：尝试执行任务或窃取其他任务</li>
<li><strong>外部线程路径</strong>：非 ForkJoinWorkerThread 才会阻塞</li>
</ol>
<p><strong>性能影响</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Thread.join()</th>
<th>ForkJoinTask.join()</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线程状态</strong></td>
<td>WAITING（阻塞）</td>
<td>RUNNABLE（继续工作）</td>
</tr>
<tr>
<td><strong>CPU 利用率</strong></td>
<td>降低（线程挂起）</td>
<td>保持（继续执行任务）</td>
</tr>
<tr>
<td><strong>上下文切换</strong></td>
<td>需要（操作系统调度）</td>
<td>不需要（用户态调度）</td>
</tr>
<tr>
<td><strong>死锁风险</strong></td>
<td>高（递归场景）</td>
<td>无（协作式调度）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>独立线程</td>
<td>分治递归任务</td>
</tr>
</tbody>
</table>
<p><strong>总结</strong></p>
<p>ForkJoinTask.join() 的协作式等待机制是 ForkJoinPool 的核心优势：</p>
<ol>
<li><strong>避免线程阻塞</strong>：工作线程永远不会因为等待而停止工作</li>
<li><strong>充分利用 CPU</strong>：等待期间继续执行其他任务</li>
<li><strong>避免死锁</strong>：父子任务可以在同一个线程中执行</li>
<li><strong>支持海量任务</strong>：可以提交远超线程数的任务而不会耗尽资源</li>
</ol>
<p>这种设计使得 ForkJoinPool 特别适合处理递归分治问题，如归并排序、快速排序、并行流等场景。</p>
<h3 id="1-5-forkjointask：任务抽象">1.5 ForkJoinTask：任务抽象</h3>
<h4 id="核心结构">核心结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Future</span>&lt;V&gt;, Serializable &#123;<br>    <span class="hljs-comment">// 32位状态字段</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> status;<br>    <br>    <span class="hljs-comment">// 状态常量（JDK 8实际定义）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DONE_MASK</span>   <span class="hljs-operator">=</span> <span class="hljs-number">0xf0000000</span>; <span class="hljs-comment">// 完成掩码</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>      <span class="hljs-operator">=</span> <span class="hljs-number">0xf0000000</span>; <span class="hljs-comment">// 正常完成（必须为负数）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>   <span class="hljs-operator">=</span> <span class="hljs-number">0xc0000000</span>; <span class="hljs-comment">// 已取消（必须小于NORMAL）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x80000000</span>; <span class="hljs-comment">// 异常完成（必须小于CANCELLED）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>      <span class="hljs-operator">=</span> <span class="hljs-number">0x00010000</span>; <span class="hljs-comment">// 需要信号（必须 &gt;= 1 &lt;&lt; 16）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SMASK</span>       <span class="hljs-operator">=</span> <span class="hljs-number">0x0000ffff</span>; <span class="hljs-comment">// 短整型位用于标签</span><br>    <span class="hljs-comment">// 注意：没有COMPLETING常量，COMPLETING是FutureTask的状态，不是ForkJoinTask的</span><br>    <br>    <span class="hljs-comment">// 核心方法</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异步提交当前任务到当前线程的本地队列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> this，支持链式调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 异步提交</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 等待当前任务完成并返回结果</span><br><span class="hljs-comment">     * 与 Thread.join()的关键区别：</span><br><span class="hljs-comment">     * - Thread.join()会阻塞当前线程，不做任何有用工作</span><br><span class="hljs-comment">     * - ForkJoinTask.join()会：</span><br><span class="hljs-comment">     *   1. 检查任务是否已完成</span><br><span class="hljs-comment">     *   2. 如果未完成，当前线程不会阻塞</span><br><span class="hljs-comment">     *   3. 而是执行&quot;协作式等待&quot;：</span><br><span class="hljs-comment">     *      a. 扫描其他工作队列窃取任务</span><br><span class="hljs-comment">     *      b. 如果窃取到的任务是目标任务的子任务，直接帮助执行</span><br><span class="hljs-comment">     *      c. 通过帮助执行，加速目标任务的完成</span><br><span class="hljs-comment">     *   4. 仅当全局无任务可做时才真正阻塞</span><br><span class="hljs-comment">     * - 可以从外部调用，但通常在FJ任务内部调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span>;               <span class="hljs-comment">// 等待完成</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务的核心计算逻辑，由子类实现</span><br><span class="hljs-comment">     * 与join()的区别：</span><br><span class="hljs-comment">     * - compute()包含任务的实际执行逻辑</span><br><span class="hljs-comment">     * - join()是等待其他任务完成的方法</span><br><span class="hljs-comment">     * - compute()在当前线程执行，join()触发协作执行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>;        <span class="hljs-comment">// 子类实现</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取原始结果（由compute()设置）</span><br><span class="hljs-comment">     * 满足Future&lt;V&gt;接口契约</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置原始结果</span><br><span class="hljs-comment">     * 通常由compute()内部调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(V value)</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试从当前线程的队列中移除任务</span><br><span class="hljs-comment">     * 用于任务取消</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryUnfork</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="标准子类">标准子类</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无返回值任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;Void&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 无返回值的计算逻辑</span><br><span class="hljs-comment">     * JLS允许将Void作为类型参数，虽然Void不可实例化</span><br><span class="hljs-comment">     * Void是不可实例化的占位符类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 为什么需要这个方法？</span><br><span class="hljs-comment">     * - 满足ForkJoinTask&lt;Void&gt;的接口契约</span><br><span class="hljs-comment">     * - 虽然返回Void，但类型系统需要具体实现</span><br><span class="hljs-comment">     * - 比RecursiveTask更轻量，因为不需要处理返回值</span><br><span class="hljs-comment">     * - 保持API一致性，避免特殊处理</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Void <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(Void mustBeNull)</span> &#123; &#125;<br>&#125;<br><br><span class="hljs-comment">// 有返回值任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveTask</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;V&gt; &#123;<br>    V result; <span class="hljs-comment">// 存储计算结果</span><br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 唯一需要子类实现的抽象方法</span><br>    <br>    <span class="hljs-comment">// 注意：以下方法是final的，不是abstract的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> result; &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(V value)</span> &#123; result = value; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="与futuretask的关键区别">与FutureTask的关键区别</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FutureTask.get()：可能完全阻塞</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>        <span class="hljs-comment">// s 的最终赋值是等待完成的结果</span><br>        s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>); <span class="hljs-comment">// 可能阻塞</span><br>    <span class="hljs-comment">// 最终 s 决定了 report 的行为</span><br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br><br><span class="hljs-comment">// ForkJoinTask.join()：协作式等待</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (doJoin() != NORMAL)       <span class="hljs-comment">// doJoin()包含帮助执行逻辑</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-关键api：与threadpoolexecutor的差异">2. 关键API：与ThreadPoolExecutor的差异</h2>
<h3 id="2-1-forkjoinpool的核心api">2.1 ForkJoinPool的核心API</h3>
<h4 id="外部客户端api">外部客户端API</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重写的Executor.execute方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// 将Runnable包装为ForkJoinTask</span><br>    ForkJoinTask&lt;?&gt; job = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskAdaptor</span>(task);<br>    externalPush(job); <span class="hljs-comment">// 提交到外部队列</span><br>&#125;<br><br><span class="hljs-comment">// 针对ForkJoinTask的专用方法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为什么需要这个重载？</span><br><span class="hljs-comment"> * - 针对ForkJoinTask优化：避免包装开销</span><br><span class="hljs-comment"> * - 直接调用externalPush，性能更好</span><br><span class="hljs-comment"> * - 与父类的execute(Runnable)不是相互嵌套关系</span><br><span class="hljs-comment"> * - 两个方法针对不同类型的任务优化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ForkJoinTask&lt;?&gt; task)</span>;<br><br><span class="hljs-comment">// 同步执行并返回结果</span><br>&lt;T&gt; T <span class="hljs-title function_">invoke</span><span class="hljs-params">(ForkJoinTask&lt;T&gt; task)</span>;<br><br><span class="hljs-comment">// 提交任务并返回Future</span><br>&lt;T&gt; ForkJoinTask&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(ForkJoinTask&lt;T&gt; task)</span>;<br></code></pre></td></tr></table></figure>
<ol>
<li>对 TPE：<code>execute(Runnable)</code>是调度层的核心，不是最底层。最底层是 <code>runWorker()</code>。</li>
<li>对于外部提交，<code>externalPush()</code>或<code>externalSubmit()</code>是入口；但内部<code>fork()</code>调用的是<code>WorkQueue.push()</code>，两者是并行的入口路径，不是汇聚关系。</li>
</ol>
<h4 id="内部计算api">内部计算API</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内部API的访问控制：</span><br><span class="hljs-comment"> * - 虽然fork()/join()是public方法，但文档约定只在FJ任务内部调用</span><br><span class="hljs-comment"> * - 通过文档约定和性能惩罚来限制，不是通过访问控制</span><br><span class="hljs-comment"> * - 在外部调用fork()会回退到commonPool，性能较差</span><br><span class="hljs-comment"> * - 正确用法：外部客户端用invoke()，内部计算用fork()/join()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> ForkJoinTask.fork();    <span class="hljs-comment">// 异步派生子任务</span><br>V ForkJoinTask.join();       <span class="hljs-comment">// 等待子任务完成</span><br>V ForkJoinTask.invoke();     <span class="hljs-comment">// 执行并等待完成</span><br></code></pre></td></tr></table></figure>
<h4 id="监控与管理api">监控与管理API</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取全局窃取次数</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">getStealCount</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 等待池变为空闲</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitQuiescence</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>;<br><br><span class="hljs-comment">// 优雅关闭</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<h3 id="2-2-api使用边界：为什么不能混用？">2.2 API使用边界：为什么不能混用？</h3>
<p>Javadoc 明确划分了 API 使用边界：</p>
<table>
<thead>
<tr>
<th>meannings</th>
<th>Call from non-fork/join clients</th>
<th>Call from within fork/join computations</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Arrange async execution</strong></td>
<td><code>execute(ForkJoinTask)</code></td>
<td><code>ForkJoinTask.fork()</code></td>
</tr>
<tr>
<td><strong>Await and obtain result</strong></td>
<td><code>invoke(ForkJoinTask)</code></td>
<td><code>ForkJoinTask.invoke()</code></td>
</tr>
<tr>
<td><strong>Arrange exec and obtain Future</strong></td>
<td><code>submit(ForkJoinTask)</code></td>
<td><code>ForkJoinTask.fork()</code> (ForkJoinTasks are Futures)</td>
</tr>
</tbody>
</table>
<p><strong>&quot;Arrange&quot;的含义：</strong><br>
此处的&quot;Arrange&quot;是英语动词，意为&quot;安排、组织&quot;，描述API的意图：</p>
<ul>
<li>Arrange async execution = “安排异步执行” → 任务提交后立即返回</li>
<li>Await and obtain result = “等待并获取结果” → 阻塞直到任务完成</li>
<li>Arrange exec and obtain Future = “安排执行并获取 Future” → 异步执行但保留结果句柄，通过 Future 获取结果。</li>
</ul>
<blockquote>
<p>原始文档强调<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/271521213">2</a>： “These methods are designed to be used primarily by clients<br>
not already engaged in fork/join computations in the current pool…<br>
tasks that are already executing in a pool should normally instead use<br>
the within-computation forms…”</p>
</blockquote>
<p><strong>混用API的代价</strong>：</p>
<ul>
<li><strong>性能下降</strong>：绕过工作窃取优化</li>
<li><strong>死锁风险</strong>：阻塞式等待导致资源浪费</li>
<li><strong>缓存失效</strong>：失去任务局部性</li>
</ul>
<h2 id="3-线程调度机制：动态适应的艺术">3. 线程调度机制：动态适应的艺术</h2>
<h3 id="3-1-并行度：唯一的核心参数">3.1 并行度：唯一的核心参数</h3>
<h4 id="配置参数">配置参数</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism,</span><br><span class="hljs-params">                   ForkJoinWorkerThreadFactory factory,</span><br><span class="hljs-params">                   UncaughtExceptionHandler handler,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> asyncMode)</span>;<br></code></pre></td></tr></table></figure>
<p>asyncMode：<br>
- false（默认）：LIFO（后进先出） - <strong>适合递归分解任务</strong><br>
- true：FIFO（先进先出） - 适合生产者-消费者模式</p>
<h4 id="公共池的系统属性">公共池的系统属性</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.concurrent.ForkJoinPool.common.parallelism<br>    - 目标并行度，控制活跃线程数<br>    - 默认 = Runtime.getRuntime().availableProcessors()<br>    <br>java.util.concurrent.ForkJoinPool.common.threadFactory<br>    - 自定义工作线程创建逻辑<br>    - 默认使用DefaultForkJoinWorkerThreadFactory<br>    <br>java.util.concurrent.ForkJoinPool.common.exceptionHandler<br>    - 处理未捕获异常<br>    - 默认使用系统默认异常处理器：<br>    <span class="hljs-comment">//   - 打印异常堆栈到System.err</span><br>    <span class="hljs-comment">//   - 不终止JVM</span><br>    <span class="hljs-comment">//   - 可通过Thread.setDefaultUncaughtExceptionHandler覆盖</span><br>    <br>java.util.concurrent.ForkJoinPool.common.maximumSpares<br>    - 额外线程上限，用于补偿阻塞<br>    - 默认 = <span class="hljs-number">256</span><br></code></pre></td></tr></table></figure>
<h4 id="各参数的实际影响：">各参数的实际影响：</h4>
<ul>
<li><strong>parallelism</strong>：直接影响CPU利用率，设置过大导致上下文切换开销</li>
<li><strong>threadFactory</strong>：可控制线程优先级、名称、守护状态</li>
<li><strong>exceptionHandler</strong>：确保异常不会静默失败</li>
<li><strong>maximumSpares</strong>：处理阻塞时的补偿机制，过小导致性能下降</li>
</ul>
<h3 id="3-2-无core-max参数的设计哲学">3.2 无core/max参数的设计哲学</h3>
<h4 id="threadpoolexecutor的线程管理">ThreadPoolExecutor的线程管理</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TPE的线程创建逻辑</span><br><span class="hljs-keyword">if</span> (当前线程数 &lt; corePoolSize) 创建核心线程<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (队列未满) 入队<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (当前线程数 &lt; maximumPoolSize) 创建非核心线程<br><span class="hljs-keyword">else</span> 拒绝策略<br></code></pre></td></tr></table></figure>
<h4 id="forkjoinpool的线程管理">ForkJoinPool的线程管理</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FJP的线程创建逻辑</span><br><span class="hljs-keyword">if</span> (活跃线程数 &lt; parallelism) 创建新线程<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (有线程阻塞且 spare线程数 &lt; maximumSpares) 创建spare线程<br><span class="hljs-keyword">else</span> 复用现有线程 <span class="hljs-comment">// 任务数超过线程数时：</span><br>                 <span class="hljs-comment">//   - 通过工作窃取实现负载均衡</span><br>                 <span class="hljs-comment">//   - 空闲线程会窃取其他队列的任务</span><br>                 <span class="hljs-comment">//   - 如果没有空闲线程：</span><br>                 <span class="hljs-comment">//     * 新任务入队到当前线程的本地队列</span><br>                 <span class="hljs-comment">//     * 队列会动态扩容（无界）</span><br>                 <span class="hljs-comment">//   - 不会创建新线程，除非有阻塞</span><br></code></pre></td></tr></table></figure>
<h4 id="parallelism-vs-corepoolsize-maximumspares-vs-maximumpoolsize：">parallelism vs corePoolSize, maximumSpares vs maximumPoolSize：</h4>
<ul>
<li>本质不同：
<ul>
<li>TPE：corePoolSize是静态下限（保持的最小线程数），maximumPoolSize是静态上限（允许的最大线程数）</li>
<li>FJP：parallelism是动态目标（期望的<strong>活跃线程数</strong>），maximumSpares是补偿上限（允许的额外线程数）：<strong>只要有任务，机制可以通过一个有限度的补偿拼命维持 active thread 的 count；ThreadPoolExecutor维持的是线程数量的边界范围（corePoolSize ≤ 线程数 ≤ maximumPoolSize），而不是特别关注线程的活跃状态。</strong></li>
<li>TPE的线程边界是硬性的，FJP的线程边界是软性的</li>
<li>TPE创建线程是为了处理更多任务，FJP创建spare线程是为了补偿阻塞</li>
</ul>
</li>
<li>关键区别：
<ul>
<li>线程数硬性上限：FJP的线程数永远不会超过 parallelism + maximumSpares</li>
<li>当达到上限后：
<ul>
<li>有线程阻塞时，无法创建spare线程</li>
<li>新任务入队到现有线程的队列（队列无界，会动态扩容）</li>
</ul>
</li>
<li>与TPE的核心区别：
<ul>
<li>TPE：有界队列满 + 线程=max 时触发拒绝策略（RejectedExecutionHandler）</li>
<li>FJP：<strong>无需配置拒绝策略</strong>，队列动态扩容，仅在 shutdown 或内部资源耗尽时抛出 RejectedExecutionException</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="线程回收机制对比">线程回收机制对比</h4>
<blockquote>
<p>Javadoc明确说明 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/271521213">2</a>： “Using the common pool normally reduces resource<br>
usage (its threads are slowly reclaimed during periods of non-use, and<br>
reinstated upon subsequent use).”</p>
</blockquote>
<h4 id="fjp线程回收细节">FJP线程回收细节</h4>
<ul>
<li>空闲线程不会立即销毁，而是park()</li>
<li>如果空闲时间超过阈值，标记为可回收</li>
<li>通过ctl字段的位操作，逐步减少活跃线程计数</li>
<li>下次需要时重新创建，避免频繁创建/销毁开销</li>
</ul>
<h3 id="3-3-为什么没有拒绝策略：无界队列与任务消费模型">3.3 为什么没有拒绝策略：无界队列与任务消费模型</h3>
<h4 id="forkjoinpool-构造器对比">ForkJoinPool 构造器对比</h4>
<p>查看 ForkJoinPool 的构造器签名，会发现一个显著的差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadPoolExecutor 构造器（7个参数）</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">    <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">    TimeUnit unit,</span><br><span class="hljs-params">    BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">    ThreadFactory threadFactory,</span><br><span class="hljs-params">    RejectedExecutionHandler handler  // 拒绝策略</span><br><span class="hljs-params">)</span><br><br><span class="hljs-comment">// ForkJoinPool 构造器（最完整版本，4个参数）</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> parallelism,</span><br><span class="hljs-params">    ForkJoinWorkerThreadFactory factory,</span><br><span class="hljs-params">    UncaughtExceptionHandler handler,  // 异常处理器，不是拒绝策略</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> asyncMode</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>
<p><strong>ForkJoinPool 没有 RejectedExecutionHandler 参数</strong>。这不是疏忽，而是有意为之的设计决策。</p>
<h4 id="为什么不需要拒绝策略？">为什么不需要拒绝策略？</h4>
<pre><code class="hljs mermaid">flowchart TB
    subgraph TPE[&quot;ThreadPoolExecutor 任务流&quot;]
        T1[新任务] --&gt; T2&#123;线程数 &lt; core?&#125;
        T2 --&gt;|是| T3[创建核心线程]
        T2 --&gt;|否| T4&#123;队列未满?&#125;
        T4 --&gt;|是| T5[入队等待]
        T4 --&gt;|否| T6&#123;线程数 &lt; max?&#125;
        T6 --&gt;|是| T7[创建非核心线程]
        T6 --&gt;|否| T8[触发拒绝策略]
        
        style T8 fill:#ff6b6b,color:#fff
    end
    
    subgraph FJP[&quot;ForkJoinPool 任务流&quot;]
        F1[新任务] --&gt; F2&#123;外部提交?&#125;
        F2 --&gt;|是| F3[放入共享提交队列]
        F2 --&gt;|否| F4[放入当前线程本地队列]
        F3 --&gt; F5[队列动态扩容]
        F4 --&gt; F5
        F5 --&gt; F6[工作窃取平衡负载]
        F6 --&gt; F7[join时帮助执行]
        
        style F5 fill:#51cf66,color:#fff
        style F7 fill:#51cf66,color:#fff
    end</code></pre>
<p><strong>原因一：队列是无界的</strong></p>
<p>每个 WorkQueue 内部使用 <code>ForkJoinTask&lt;?&gt;[] array</code> 存储任务：</p>
<p>根据 ForkJoinPool 的 Javadoc（Java SE 8+）：</p>
<blockquote>
<p>“This implementation rejects submitted tasks (that is, by throwing RejectedExecutionException) only when the pool is shut down or internal resources have been exhausted.”</p>
</blockquote>
<p>这意味着 ForkJoinPool <strong>不需要显式的拒绝策略参数</strong>，因为：</p>
<ul>
<li>正常运行时，任务总能被接受（队列会动态扩容）</li>
<li>只有在 shutdown 或内部资源耗尽时才会拒绝</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// WorkQueue 内部结构（来自 OpenJDK 8 源码）</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkQueue</span> &#123;<br>    ForkJoinTask&lt;?&gt;[] array;  <span class="hljs-comment">// 任务数组</span><br>    <span class="hljs-type">int</span> base;                  <span class="hljs-comment">// 窃取端索引（FIFO）</span><br>    <span class="hljs-type">int</span> top;                   <span class="hljs-comment">// 本地端索引（LIFO）</span><br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-comment">// 数组容量范围（来自 OpenJDK 源码）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_QUEUE_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>;  <span class="hljs-comment">// 8192</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_QUEUE_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">26</span>;  <span class="hljs-comment">// 67,108,864（约 6700 万）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>当队列满时，会自动扩容（容量翻倍），直到达到 MAXIMUM_QUEUE_CAPACITY。这意味着：</p>
<ul>
<li>单个队列理论上可以容纳约 6700 万个任务</li>
<li>多个工作线程各有自己的队列</li>
<li>实际上，内存耗尽（OOM）会先于队列容量上限触发 “internal resources exhausted”</li>
</ul>
<p><strong>原因二：任务模型的本质差异</strong></p>
<p>ThreadPoolExecutor 处理的是<strong>独立任务</strong>：</p>
<ul>
<li>任务之间没有依赖关系</li>
<li>拒绝一个任务不影响其他任务</li>
<li>拒绝策略是合理的边界保护</li>
</ul>
<p>ForkJoinPool 处理的是<strong>可分解的递归任务</strong>：</p>
<ul>
<li>父任务 fork 出子任务</li>
<li>父任务必须 join 等待子任务完成</li>
<li><strong>如果拒绝子任务，父任务将永远无法完成，导致死锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果 ForkJoinPool 有拒绝策略，这段代码可能死锁</span><br><span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size &lt; THRESHOLD) &#123;<br>        <span class="hljs-keyword">return</span> directCompute();<br>    &#125;<br>    <br>    <span class="hljs-type">SubTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTask</span>(leftHalf);<br>    <span class="hljs-type">SubTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTask</span>(rightHalf);<br>    <br>    left.fork();   <span class="hljs-comment">// 如果这里被拒绝...</span><br>    right.fork();  <span class="hljs-comment">// 或者这里被拒绝...</span><br>    <br>    <span class="hljs-comment">// 父任务将永远阻塞在这里</span><br>    <span class="hljs-keyword">return</span> left.join() + right.join();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>原因三：join 的协作式消费</strong></p>
<p>ForkJoinPool 的 join 不是被动等待，而是主动帮助消费任务：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Parent as 父任务线程
    participant Queue as 本地队列
    participant Child as 子任务
    
    Parent-&gt;&gt;Queue: fork(子任务)
    Parent-&gt;&gt;Parent: 准备 join
    
    alt 子任务还在本地队列顶部
        Parent-&gt;&gt;Queue: tryUnpush(子任务)
        Parent-&gt;&gt;Child: 直接执行子任务
        Child--&gt;&gt;Parent: 返回结果
    else 子任务被窃取
        Parent-&gt;&gt;Queue: 执行队列中其他任务
        Note over Parent: 帮助消费，而非空等
        Child--&gt;&gt;Parent: 异步完成后返回结果
    end</code></pre>
<p>这种设计意味着：</p>
<ul>
<li>即使队列中有大量任务，线程也在持续消费</li>
<li>join 操作本身就是在帮助消费队列</li>
<li>任务的生产和消费是协作式的，不会出现&quot;生产远超消费&quot;的失控情况</li>
</ul>
<h4 id="队列无界会导致-oom-吗？">队列无界会导致 OOM 吗？</h4>
<p>理论上是的，但在正确使用 ForkJoinPool 的场景下，这不是问题：</p>
<p><strong>分治任务的&quot;菱形&quot;特征</strong>：</p>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;任务数量随时间变化&quot;
        A[根任务] --&gt; B1[子任务1]
        A --&gt; B2[子任务2]
        B1 --&gt; C1[孙任务1]
        B1 --&gt; C2[孙任务2]
        B2 --&gt; C3[孙任务3]
        B2 --&gt; C4[孙任务4]
        
        C1 --&gt; D1[结果1]
        C2 --&gt; D2[结果2]
        C3 --&gt; D3[结果3]
        C4 --&gt; D4[结果4]
        
        D1 --&gt; E1[合并1]
        D2 --&gt; E1
        D3 --&gt; E2[合并2]
        D4 --&gt; E2
        
        E1 --&gt; F[最终结果]
        E2 --&gt; F
    end
    
    style A fill:#4dabf7
    style B1 fill:#748ffc
    style B2 fill:#748ffc
    style C1 fill:#9775fa
    style C2 fill:#9775fa
    style C3 fill:#9775fa
    style C4 fill:#9775fa
    style D1 fill:#da77f2
    style D2 fill:#da77f2
    style D3 fill:#da77f2
    style D4 fill:#da77f2
    style E1 fill:#f783ac
    style E2 fill:#f783ac
    style F fill:#ff6b6b</code></pre>
<p>典型的分治任务呈现&quot;先增后减&quot;的菱形模式：</p>
<ol>
<li><strong>分解阶段</strong>：任务数量指数增长</li>
<li><strong>基准情况</strong>：到达阈值，开始直接计算</li>
<li><strong>合并阶段</strong>：任务数量指数减少</li>
</ol>
<p>工作窃取算法确保任务被及时消费，队列长度不会无限增长。</p>
<p><strong>如果滥用会怎样？</strong></p>
<p>如果把 ForkJoinPool 当作普通线程池，不断提交独立任务而不消费结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误用法：把 ForkJoinPool 当作无界队列使用</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ForkJoinPool.commonPool();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    pool.execute(() -&gt; &#123;<br>        <span class="hljs-comment">// 永远不结束的任务，或者生产速度远超消费速度</span><br>        Thread.sleep(Long.MAX_VALUE);<br>    &#125;);<br>&#125;<br><span class="hljs-comment">// 最终会 OOM</span><br></code></pre></td></tr></table></figure>
<p>这与使用 <code>new ThreadPoolExecutor(..., new LinkedBlockingQueue&lt;&gt;())</code> 的效果相同——都会因为无界队列导致 OOM。</p>
<h4 id="设计哲学总结">设计哲学总结</h4>
<table>
<thead>
<tr>
<th>维度</th>
<th>ThreadPoolExecutor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>任务模型</strong></td>
<td>独立任务</td>
<td>可分解的递归任务</td>
</tr>
<tr>
<td><strong>队列类型</strong></td>
<td>可配置（有界/无界）</td>
<td>动态扩容（无界）</td>
</tr>
<tr>
<td><strong>拒绝策略</strong></td>
<td>必需配置 RejectedExecutionHandler</td>
<td>无需配置，仅在 shutdown/资源耗尽时拒绝</td>
</tr>
<tr>
<td><strong>消费模式</strong></td>
<td>被动等待</td>
<td>协作式消费（join帮助执行）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>通用任务执行</td>
<td>分治并行计算</td>
</tr>
<tr>
<td><strong>OOM风险</strong></td>
<td>无界队列时存在</td>
<td>滥用时存在（触发 internal resources exhausted）</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>核心洞察</strong>：ForkJoinPool 的构造器不需要 RejectedExecutionHandler 参数，是因为在分治并行模型中，拒绝子任务会导致父任务死锁。根据 Javadoc，ForkJoinPool 仅在 shutdown 或内部资源耗尽时抛出 RejectedExecutionException。动态扩容的队列配合工作窃取和协作式 join，形成了一个自平衡的任务消费系统。</p>
</blockquote>
<h3 id="3-4-工作线程生命周期">3.4 工作线程生命周期</h3>
<p>工作线程经历四个阶段：</p>
<ul>
<li><strong>初始化</strong>：首次提交任务时创建，初始活跃线程数不超过parallelism，但总线程数可能达到 parallelism + maximumSpares
<ul>
<li>与TPE的关键区别：TPE的核心线程即使空闲也不会回收（除非设置allowCoreThreadTimeOut），<strong>而FJP的所有线程在空闲时都会被回收</strong></li>
<li>FJP的设计哲学：按需创建，及时释放，适合间歇性负载</li>
</ul>
</li>
<li><strong>活跃期</strong>：执行任务 + 窃取任务，检测阻塞时触发spare线程
<ul>
<li>通过<code>ManagedBlocker</code>接口检测阻塞</li>
<li>当线程阻塞时，可能创建spare线程补偿</li>
</ul>
</li>
<li><strong>空闲期</strong>：无任务时park()，保持空闲状态
<ul>
<li>线程通过<code>awaitWork()</code>方法（内部实现）进入等待，使用<code>LockSupport.park()</code>挂起</li>
<li>有新任务时被唤醒</li>
</ul>
</li>
<li><strong>回收期</strong>：空闲超过阈值，逐步减少线程
<ul>
<li>通过ctl字段的位操作管理线程状态，空闲超时后线程主动退出run()循环</li>
<li>线程退出run()方法，被垃圾回收</li>
<li>下次需要时重新创建，避免永久空闲线程</li>
</ul>
</li>
</ul>
<p>根据 ForkJoinPool 源码注释和 Javadoc 文档：</p>
<blockquote>
<p>“The pool attempts to maintain enough active (or available) threads by dynamically adding, suspending, or resuming internal worker threads, even if some tasks are stalled waiting to join others.”</p>
</blockquote>
<p>这意味着 ForkJoinPool 会动态调整线程数以维持目标并行度，同时避免频繁的线程创建/销毁循环。与传统线程池不同，ForkJoinPool 会回收所有空闲线程以减少资源消耗。</p>
<h2 id="4-实战案例：并行文件搜索系统">4. 实战案例：并行文件搜索系统</h2>
<h3 id="4-1-业务需求">4.1 业务需求</h3>
<ul>
<li>搜索指定目录下的所有文件</li>
<li>查找包含特定关键词的文件</li>
<li>统计匹配行数</li>
<li>处理大型目录（10万+文件）</li>
<li>要求高效利用多核CPU</li>
</ul>
<h3 id="4-2-数据结构定义">4.2 数据结构定义</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文件搜索任务：递归遍历目录树</span><br><span class="hljs-comment"> * 使用RecursiveTask，因为需要返回匹配结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSearchTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;List&lt;SearchResult&gt;&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 子任务阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Path directory;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String keyword;<br>    <br>    FileSearchTask(Path directory, String keyword) &#123;<br>        <span class="hljs-built_in">this</span>.directory = directory;<br>        <span class="hljs-built_in">this</span>.keyword = keyword;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> List&lt;SearchResult&gt; <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取目录下的所有路径（文件和子目录）</span><br>            List&lt;Path&gt; paths = Files.list(directory)<br>                                   .collect(Collectors.toList());<br>            <br>            <span class="hljs-comment">// 基本情况：小目录直接处理</span><br>            <span class="hljs-keyword">if</span> (paths.size() &lt;= THRESHOLD) &#123;<br>                <span class="hljs-keyword">return</span> searchDirectly(paths);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 递归情况：分解为子任务</span><br>            List&lt;FileSearchTask&gt; subtasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            List&lt;Path&gt; currentBatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <br>            <span class="hljs-keyword">for</span> (Path path : paths) &#123;<br>                currentBatch.add(path);<br>                <span class="hljs-comment">// 每THRESHOLD个路径创建一个子任务</span><br>                <span class="hljs-keyword">if</span> (currentBatch.size() &gt;= THRESHOLD) &#123;<br>                    subtasks.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(createTempDir(currentBatch), keyword));<br>                    currentBatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 处理剩余路径</span><br>            <span class="hljs-keyword">if</span> (!currentBatch.isEmpty()) &#123;<br>                subtasks.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(createTempDir(currentBatch), keyword));<br>            &#125;<br>            <br>            <span class="hljs-comment">// 优化：fork其他任务，直接执行最后一个任务（减少调度开销）</span><br>            <span class="hljs-keyword">if</span> (subtasks.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 将最后一个任务留给自己执行，它不进入 fork</span><br>                <span class="hljs-comment">// 因为 fork 是一次执行，compute 是另一次，计算并不一定是幂等的</span><br>                <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">lastTask</span> <span class="hljs-operator">=</span> subtasks.remove(subtasks.size() - <span class="hljs-number">1</span>);<br>                <br>                <span class="hljs-comment">// 异步fork其他任务</span><br>                <span class="hljs-keyword">for</span> (FileSearchTask task : subtasks) &#123;<br>                    task.fork(); <span class="hljs-comment">// 正确：无锁本地队列push</span><br>                &#125;<br>                <br>                <span class="hljs-comment">// 同步执行最后一个任务</span><br>                List&lt;SearchResult&gt; results = lastTask.compute(); <span class="hljs-comment">// 正确：保持缓存</span><br>                <br>                <span class="hljs-comment">// 等待其他任务完成</span><br>                <span class="hljs-keyword">for</span> (FileSearchTask task : subtasks) &#123;<br>                    results.addAll(task.join()); <span class="hljs-comment">// 正确：协作式等待</span><br>                &#125;<br>                <br>                <span class="hljs-keyword">return</span> results;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 只有一个子任务，直接执行</span><br>                <span class="hljs-keyword">return</span> subtasks.get(<span class="hljs-number">0</span>).compute();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UncheckedIOException</span>(e);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;SearchResult&gt; <span class="hljs-title function_">searchDirectly</span><span class="hljs-params">(List&lt;Path&gt; paths)</span> &#123;<br>        List&lt;SearchResult&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Path path : paths) &#123;<br>            <span class="hljs-keyword">if</span> (Files.isDirectory(path)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 递归处理子目录</span><br>                    results.addAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(path, keyword).compute());<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-comment">// 忽略无法访问的目录</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 处理文件</span><br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> Files.newBufferedReader(path)) &#123;<br>                    String line;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">lineNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (line.contains(keyword)) &#123;<br>                            results.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchResult</span>(path, lineNumber, line));<br>                        &#125;<br>                        lineNumber++;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-comment">// 忽略无法读取的文件</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Path <span class="hljs-title function_">createTempDir</span><span class="hljs-params">(List&lt;Path&gt; paths)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 创建临时目录的逻辑（简化）</span><br>        <span class="hljs-keyword">return</span> Files.createTempDirectory(<span class="hljs-string">&quot;search_&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 搜索结果封装</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SearchResult</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Path filePath;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> lineNumber;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String lineContent;<br>    <br>    SearchResult(Path filePath, <span class="hljs-type">int</span> lineNumber, String lineContent) &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>        <span class="hljs-built_in">this</span>.lineNumber = lineNumber;<br>        <span class="hljs-built_in">this</span>.lineContent = lineContent;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s:%d: %s&quot;</span>, filePath, lineNumber, lineContent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-3-线程池初始化与使用">4.3 线程池初始化与使用</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParallelFileSearch</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建自定义ForkJoinPool</span><br><span class="hljs-comment">     * 根据业务需求配置参数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ForkJoinPool <span class="hljs-title function_">createSearchPool</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parallelism</span> <span class="hljs-operator">=</span> Math.min(<br>            Runtime.getRuntime().availableProcessors(),<br>            <span class="hljs-number">16</span> <span class="hljs-comment">// 限制最大并行度，避免I/O瓶颈</span><br>        );<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<br>            parallelism,<br>            ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>            (thread, throwable) -&gt; &#123;<br>                <span class="hljs-comment">// 自定义异常处理：记录日志</span><br>                System.err.printf(<span class="hljs-string">&quot;Thread %s threw exception: %s%n&quot;</span>, <br>                                 thread.getName(), throwable.getMessage());<br>            &#125;,<br>            <span class="hljs-literal">false</span> <span class="hljs-comment">// asyncMode = false，使用LIFO模式</span><br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 搜索入口方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;SearchResult&gt; <span class="hljs-title function_">search</span><span class="hljs-params">(Path rootDir, String keyword)</span> &#123;<br>        <span class="hljs-comment">// 创建自定义池，避免使用公共池影响其他组件</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> createSearchPool()) &#123;<br>            <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">rootTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(rootDir, keyword);<br>            <br>            <span class="hljs-comment">// 正确：外部客户端使用invoke()</span><br>            <span class="hljs-keyword">return</span> pool.invoke(rootTask);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 错误用法示例（注释说明）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;SearchResult&gt; <span class="hljs-title function_">wrongApproach</span><span class="hljs-params">(Path rootDir, String keyword)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> createSearchPool()) &#123;<br>            <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">rootTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(rootDir, keyword);<br>            <br>            <span class="hljs-comment">// 错误1：在外部客户端使用fork()</span><br>            <span class="hljs-comment">// rootTask.fork(); // 这会在公共池执行，绕过自定义池配置</span><br>            <br>            <span class="hljs-comment">// 错误2：混用API</span><br>            <span class="hljs-comment">// 在compute()内部这样写是错误的：</span><br>            <span class="hljs-comment">// pool.submit(subtask); // 绕过工作窃取</span><br>            <span class="hljs-comment">// pool.invoke(anotherTask); // 阻塞当前线程</span><br>            <br>            <span class="hljs-comment">// 正确：外部客户端使用invoke()</span><br>            <span class="hljs-keyword">return</span> pool.invoke(rootTask);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">2</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Usage: java ParallelFileSearch &lt;directory&gt; &lt;keyword&gt;&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">Path</span> <span class="hljs-variable">rootDir</span> <span class="hljs-operator">=</span> Paths.get(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">keyword</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        List&lt;SearchResult&gt; results = search(rootDir, keyword);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <br>        System.out.printf(<span class="hljs-string">&quot;Found %d matches in %d ms%n&quot;</span>, <br>                         results.size(), endTime - startTime);<br>        <br>        <span class="hljs-comment">// 打印前10个结果</span><br>        results.stream().limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以正确的框架是：</p>
<ol>
<li>定义一个 RecursiveTask 或者 RecursiveAction，而不是直接使用 ForkJoinTask，然后让 ForkJoinPool 来 invoke 根 task。</li>
<li>每个任务内部：
<ol>
<li>先检查任务大小，只有大任务才分解生成子任务，小任务直接计算。</li>
<li>从子任务列表中移除最后一个任务，保留给自己直接执行。</li>
<li>对其余子任务调用fork()（异步提交）。</li>
<li>对保留的任务调用compute()（同步执行）。</li>
<li>对其他任务进行 join 收集计算结果，合并进上一个计算结果里。</li>
<li>返回全部计算结果。</li>
</ol>
</li>
<li>所以在任务外部使用 invoke，内部使用 fork/compute/join。外部不应该用fork()/join()，看上面的 arrange。</li>
</ol>
<h3 id="4-4-关键设计决策解析">4.4 关键设计决策解析</h3>
<h4 id="1-为什么使用-recursivetask-而不是-recursiveaction？">1. 为什么使用 RecursiveTask 而不是 RecursiveAction？</h4>
<ul>
<li>需要返回搜索结果（List）</li>
<li>RecursiveTask 提供类型安全的返回值</li>
<li>符合分治模式：子任务结果合并为父任务结果</li>
</ul>
<h4 id="2-为什么设置threshold-100？">2. 为什么设置THRESHOLD=100？</h4>
<ul>
<li>任务分解粒度需要平衡：
<ul>
<li>太小：调度开销超过计算收益</li>
<li>
<ul>
<li>太大：负载不均衡，CPU核心利用率低</li>
</ul>
</li>
</ul>
</li>
<li>100是经验值，可根据文件大小调整</li>
<li>通过基准测试确定最优值</li>
</ul>
<h4 id="3-为什么fork其他任务-直接执行最后一个任务？">3. 为什么fork其他任务，直接执行最后一个任务？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 优化：fork其他任务，直接执行最后一个任务（避免不必要的调度开销）</span><br><span class="hljs-keyword">if</span> (subtasks.size() &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">lastTask</span> <span class="hljs-operator">=</span> subtasks.remove(subtasks.size() - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (FileSearchTask task : subtasks) &#123;<br>        task.fork(); <span class="hljs-comment">// 异步提交</span><br>    &#125;<br>    <br>    List&lt;SearchResult&gt; results = lastTask.compute(); <span class="hljs-comment">// 同步执行</span><br>    <br>    <span class="hljs-keyword">for</span> (FileSearchTask task : subtasks) &#123;<br>        results.addAll(task.join()); <span class="hljs-comment">// 等待完成</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>设计理由：</p>
<ul>
<li><strong>避免调度开销</strong>：直接compute()比fork()后再join()少一次入队出队操作</li>
<li><strong>缓存局部性</strong>：直接执行的任务与父任务共享数据，保持CPU缓存热度</li>
<li><strong>栈深度控制</strong>：避免过深的递归导致StackOverflowError</li>
<li><strong>注意</strong>：这里的&quot;最后一个任务&quot;不是指&quot;最大的任务&quot;，而是任意选择一个任务直接执行以减少调度开销</li>
</ul>
<h4 id="4-为什么创建自定义池而不是使用公共池？">4. 为什么创建自定义池而不是使用公共池？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> createSearchPool()) &#123;<br>    <span class="hljs-keyword">return</span> pool.invoke(rootTask);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计理由</strong>：</p>
<ul>
<li><strong>资源隔离</strong>：避免影响其他使用公共池的组件</li>
<li><strong>参数定制</strong>：限制并行度（16），避免I/O瓶颈</li>
<li><strong>异常处理</strong>：自定义异常处理器，确保错误可见</li>
<li><strong>生命周期管理</strong>：try-with-resources确保池关闭</li>
</ul>
<h4 id="5-为什么asyncmode-false？">5. 为什么asyncMode=false？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(parallelism, ..., <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>
<p><strong>设计理由</strong>：</p>
<ul>
<li>
<p><strong>LIFO模式</strong>：适合分治算法，保持缓存局部性</p>
</li>
<li>
<p><strong>asyncMode=true</strong>：使用FIFO模式，适合事件处理</p>
</li>
<li>
<p>文件搜索是典型的分治场景，LIFO更高效</p>
</li>
</ul>
<h2 id="5-常见错误模式与避坑指南">5. 常见错误模式与避坑指南</h2>
<h3 id="5-1-api混用错误">5.1 API混用错误</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ❌ 错误：在ForkJoinTask.compute()内部调用pool方法</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(leftDir, keyword);<br>    <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(rightDir, keyword);<br>    <br>    <span class="hljs-comment">// 错误1：绕过工作窃取优化</span><br>    pool.submit(left); <span class="hljs-comment">// 提交到共享队列，失去局部性</span><br>    <br>    <span class="hljs-comment">// 错误2：阻塞当前线程</span><br>    List&lt;SearchResult&gt; rightResults = pool.invoke(right); <span class="hljs-comment">// 完全阻塞</span><br>    <br>    <span class="hljs-comment">// 错误3：结果合并时可能未完成</span><br>    List&lt;SearchResult&gt; results = left.get(); <span class="hljs-comment">// 可能抛出异常</span><br>    results.addAll(rightResults);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>正确做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ✅ 正确：使用fork/join API</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(leftDir, keyword);<br>    <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(rightDir, keyword);<br>    <br>    <span class="hljs-comment">// 优化：fork较小的任务</span><br>    <span class="hljs-keyword">if</span> (leftDirSize &lt; rightDirSize) &#123;<br>        left.fork(); <span class="hljs-comment">// 无锁本地队列push</span><br>        List&lt;SearchResult&gt; results = right.compute(); <span class="hljs-comment">// 保持缓存</span><br>        results.addAll(left.join()); <span class="hljs-comment">// 协作式等待</span><br>        <span class="hljs-keyword">return</span> results;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        right.fork();<br>        List&lt;SearchResult&gt; results = left.compute();<br>        results.addAll(right.join());<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-2-i-o阻塞错误">5.2 I/O阻塞错误</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ❌ 错误：在ForkJoinTask中执行阻塞I/O</span><br><span class="hljs-keyword">protected</span> List&lt;SearchResult&gt; <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file)) &#123;<br>        <span class="hljs-comment">// 阻塞读取文件</span><br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[fis.available()];<br>        fis.read(data); <span class="hljs-comment">// 阻塞I/O</span><br>        <br>        <span class="hljs-comment">// 处理数据...</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>正确做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ✅ 正确：I/O与计算分离</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReadTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;<span class="hljs-type">byte</span>[]&gt; &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">byte</span>[] compute() &#123;<br>        <span class="hljs-comment">// 非阻塞I/O或使用NIO</span><br>        <span class="hljs-keyword">return</span> Files.readAllBytes(path);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileProcessTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;List&lt;SearchResult&gt;&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] fileData;<br>    <br>    <span class="hljs-keyword">protected</span> List&lt;SearchResult&gt; <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 纯CPU计算，无I/O</span><br>        List&lt;SearchResult&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(fileData);<br>        <span class="hljs-comment">// 处理内容...</span><br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 外部协调</span><br><span class="hljs-type">byte</span>[] fileData = fileReadPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReadTask</span>(path)).get();<br>List&lt;SearchResult&gt; results = computePool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileProcessTask</span>(fileData));<br></code></pre></td></tr></table></figure>
<h3 id="5-3-资源泄漏错误">5.3 资源泄漏错误</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误：不关闭自定义池</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br>pool.invoke(task); <span class="hljs-comment">// 池永远不会关闭</span><br></code></pre></td></tr></table></figure>
<p>正确做法（JDK 19+）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 19+ 正确：使用try-with-resources（ForkJoinPool实现了AutoCloseable）</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>()) &#123;<br>    <span class="hljs-keyword">return</span> pool.invoke(task);<br>&#125; <span class="hljs-comment">// 自动调用shutdown()和awaitTermination()</span><br></code></pre></td></tr></table></figure>
<p>正确做法（JDK 8-18）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 8-18：ForkJoinPool不实现AutoCloseable，需手动管理</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> pool.invoke(task);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    pool.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>要点：即使线程不会泄露，线程池仍然需要关闭，否则线程池实例本身会泄露。</strong></p>
<p>ForkJoinPool会自动回收空闲worker线程到0（通过<code>keepAliveTime</code>机制，默认60秒无任务后线程自动退出），因此<strong>线程本身不会泄露</strong>。但这并不意味着可以不关闭线程池——<strong>线程池实例本身持有的内部资源不会自动释放</strong>。临时创建的ForkJoinPool若不显式调用shutdown()/shutdownNow()，将导致以下资源泄露：</p>
<ol>
<li>内存资源泄露：</li>
</ol>
<ul>
<li>64位ctl状态字段（原子控制变量）</li>
<li>WorkQueue数组（每个worker线程的任务队列）</li>
<li>任务引用（队列中未处理的任务对象）</li>
<li>线程工厂实例（ForkJoinWorkerThreadFactory引用）</li>
<li>异常处理器（UncaughtExceptionHandler引用）</li>
<li>内部锁和条件变量（同步器对象）</li>
</ul>
<ol start="2">
<li>系统资源泄露：</li>
</ol>
<ul>
<li>文件描述符（如果ThreadFactory创建了带资源的线程）</li>
<li>本地内存（JVM内部线程状态结构）</li>
<li>类加载器引用（可能导致ClassLoader泄露）</li>
</ul>
<ol start="3">
<li>监控资源泄露：</li>
</ol>
<ul>
<li>JMX MBean注册（每个pool注册的监控指标）</li>
<li>线程统计信息（活跃/已完成任务计数器）</li>
</ul>
<p>commonPool()由JVM在shutdown hook中自动管理，手动关闭会破坏全局并发设施。生产环境应通过静态复用或池缓存机制管理ForkJoinPool实例，避免高频创建/销毁。每次临时创建后必须用try-finally确保关闭，否则在长时间运行的应用中将累积严重内存压力。</p>
<h2 id="6-父子任务死锁：传统线程池的致命缺陷与forkjoinpool的解决方案">6. 父子任务死锁：传统线程池的致命缺陷与ForkJoinPool的解决方案</h2>
<h3 id="6-1-问题场景：线程池饥饿死锁">6.1 问题场景：线程池饥饿死锁</h3>
<p>在使用传统<code>ThreadPoolExecutor</code>时，一个经典的陷阱是<strong>父子任务使用同一线程池导致的死锁</strong>。</p>
<h4 id="死锁复现代码">死锁复现代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolDeadlockDemo</span> &#123;<br>    <span class="hljs-comment">// 固定大小的线程池，只有2个线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 提交2个父任务，恰好占满线程池</span><br>        Future&lt;Integer&gt; f1 = pool.submit(() -&gt; parentTask(<span class="hljs-string">&quot;Parent-1&quot;</span>));<br>        Future&lt;Integer&gt; f2 = pool.submit(() -&gt; parentTask(<span class="hljs-string">&quot;Parent-2&quot;</span>));<br>        <br>        <span class="hljs-comment">// 永远无法完成 -- 死锁</span><br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + f1.get() + <span class="hljs-string">&quot;, &quot;</span> + f2.get());<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">parentTask</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(name + <span class="hljs-string">&quot; started on &quot;</span> + Thread.currentThread().getName());<br>        <br>        <span class="hljs-comment">// 父任务提交子任务到同一个线程池</span><br>        Future&lt;Integer&gt; childFuture = pool.submit(() -&gt; childTask(name));<br>        <br>        <span class="hljs-comment">// 父任务阻塞等待子任务完成</span><br>        <span class="hljs-comment">// 但子任务在队列中等待线程，而所有线程都被父任务占用</span><br>        <span class="hljs-keyword">return</span> childFuture.get(); <span class="hljs-comment">// 死锁点</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">childTask</span><span class="hljs-params">(String parentName)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child of &quot;</span> + parentName + <span class="hljs-string">&quot; on &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="死锁分析">死锁分析</h4>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">时间线：<br>T1: Parent<span class="hljs-string">-1</span> 提交，获得 Thread<span class="hljs-string">-1</span>，开始执行<br>T2: Parent<span class="hljs-string">-2</span> 提交，获得 Thread<span class="hljs-string">-2</span>，开始执行<br>T3: Parent<span class="hljs-string">-1</span> 提交 Child<span class="hljs-string">-1</span> 到队列，调用 childFuture.get() 阻塞<br>T4: Parent<span class="hljs-string">-2</span> 提交 Child<span class="hljs-string">-2</span> 到队列，调用 childFuture.get() 阻塞<br>T5: 死锁形成<br>    - Thread<span class="hljs-string">-1</span> 被 Parent<span class="hljs-string">-1</span> 占用，等待 Child<span class="hljs-string">-1</span><br>    - Thread<span class="hljs-string">-2</span> 被 Parent<span class="hljs-string">-2</span> 占用，等待 Child<span class="hljs-string">-2</span><br>    - Child<span class="hljs-string">-1</span> 和 Child<span class="hljs-string">-2</span> 在队列中，等待空闲线程<br>    - 没有空闲线程，因为都被父任务占用<br></code></pre></td></tr></table></figure>
<p>这就是经典的<strong>线程池饥饿死锁</strong>（Thread Pool Starvation Deadlock）：</p>
<ul>
<li><strong>必要条件1</strong>：父任务持有线程资源</li>
<li><strong>必要条件2</strong>：父任务阻塞等待子任务</li>
<li><strong>必要条件3</strong>：子任务需要线程资源才能执行</li>
<li><strong>必要条件4</strong>：线程池容量有限</li>
</ul>
<h3 id="6-2-传统解决方案的局限性">6.2 传统解决方案的局限性</h3>
<h4 id="方案1：增大线程池容量">方案1：增大线程池容量</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>无法预知任务的嵌套深度</li>
<li>递归分治算法的任务数量呈指数增长</li>
<li>过大的线程池浪费资源，过小仍可能死锁</li>
</ul>
<h4 id="方案2：使用无界线程池">方案2：使用无界线程池</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>失去对并发度的控制</li>
<li>可能创建过多线程，导致OOM或上下文切换开销</li>
<li>不适合生产环境</li>
</ul>
<h4 id="方案3：父子任务使用不同线程池">方案3：父子任务使用不同线程池</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">parentPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">childPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>需要预知任务层级结构</li>
<li>多层嵌套需要多个线程池</li>
<li>资源利用率低，管理复杂</li>
</ul>
<h3 id="6-3-forkjoinpool的根本性解决：协作式等待">6.3 ForkJoinPool的根本性解决：协作式等待</h3>
<p>ForkJoinPool通过<strong>协作式等待</strong>（Cooperative Waiting）从根本上解决了这个问题。</p>
<h4 id="核心机制：join-不是真正的阻塞">核心机制：join()不是真正的阻塞</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinTask.join() 的简化逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)<br>        reportException(s);<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doJoin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;<br>    <br>    <span class="hljs-comment">// 1. 检查任务是否已完成</span><br>    <span class="hljs-keyword">if</span> ((s = status) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> s;<br>    <br>    <span class="hljs-comment">// 2. 如果当前线程是 ForkJoinWorkerThread</span><br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) &#123;<br>        wt = (ForkJoinWorkerThread)t;<br>        w = wt.workQueue;<br>        <br>        <span class="hljs-comment">// 3. 尝试从本地队列弹出并执行目标任务</span><br>        <span class="hljs-keyword">if</span> (w.tryUnpush(<span class="hljs-built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> s;<br>        <br>        <span class="hljs-comment">// 4. 如果目标任务不在本地队列顶部，进入协作等待</span><br>        <span class="hljs-keyword">return</span> wt.pool.awaitJoin(w, <span class="hljs-built_in">this</span>, <span class="hljs-number">0L</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 5. 非 ForkJoinWorkerThread，使用外部等待</span><br>    <span class="hljs-keyword">return</span> externalAwaitDone();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="协作等待的核心：awaitjoin">协作等待的核心：awaitJoin()</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinPool.awaitJoin() 的简化逻辑</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitJoin</span><span class="hljs-params">(WorkQueue w, ForkJoinTask&lt;?&gt; task, <span class="hljs-type">long</span> deadline)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 循环直到任务完成</span><br>        <span class="hljs-keyword">while</span> ((s = task.status) &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 关键：不是阻塞等待，而是尝试帮助执行</span><br>            <span class="hljs-keyword">if</span> (!tryHelpStealer(w, task))  <span class="hljs-comment">// 尝试帮助窃取者</span><br>                <span class="hljs-keyword">if</span> (!tryCompensate(w))      <span class="hljs-comment">// 尝试补偿（创建新线程）</span><br>                    LockSupport.park(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 仅当无事可做时才真正阻塞</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="帮助窃取者机制-help-stealer">帮助窃取者机制（Help Stealer）</h4>
<p>当线程A等待任务T完成时，如果T被线程B窃取：</p>
<ol>
<li>A不会阻塞等待</li>
<li>A会扫描B的工作队列</li>
<li>A帮助执行B队列中的任务（可能是T的子任务）</li>
<li>通过帮助B，间接加速T的完成</li>
</ol>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">场景：<span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span> 执行 <span class="hljs-variable">Parent</span>，<span class="hljs-variable">fork</span> 了 <span class="hljs-variable">Child</span>，然后 <span class="hljs-variable">join</span><span class="hljs-punctuation">(</span><span class="hljs-variable">Child</span><span class="hljs-punctuation">)</span><br>      <span class="hljs-variable">Child</span> 被 <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> 窃取<br><br>传统线程池：<br>  <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span>阻塞等待 <span class="hljs-variable">Child</span> 完成<span class="hljs-punctuation">]</span> <span class="hljs-operator">&lt;--</span> 线程资源浪费<br>  <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span>执行 <span class="hljs-variable">Child</span><span class="hljs-punctuation">]</span><br><br><span class="hljs-variable">ForkJoinPool</span>：<br>  <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span>发现 <span class="hljs-variable">Child</span> 被 <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> 窃取<span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">[</span>扫描 <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> 的队列<span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">[</span>帮助执行 <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> 队列中的其他任务<span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">[</span>间接加速 <span class="hljs-variable">Child</span> 完成<span class="hljs-punctuation">]</span><br>  <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span>执行 <span class="hljs-variable">Child</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>
<h3 id="6-4-为什么父子任务可以不相互阻塞？">6.4 为什么父子任务可以不相互阻塞？</h3>
<p>这个问题的答案涉及ForkJoinTask接口设计的精妙之处：</p>
<h4 id="接口层面的异步化解耦">接口层面的异步化解耦</h4>
<p><code>ForkJoinTask</code>的<code>fork()</code>和<code>join()</code>方法在接口设计上实现了<strong>计算与等待的解耦</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// fork() 只是将任务入队，不执行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">()</span> &#123;<br>    Thread t;<br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread)<br>        ((ForkJoinWorkerThread)t).workQueue.push(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">else</span><br>        ForkJoinPool.common.externalPush(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br><span class="hljs-comment">// join() 不是简单等待，而是&quot;参与式等待&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (doJoin() != NORMAL)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键设计点</strong>：</p>
<ol>
<li><strong>fork()是纯异步的</strong>：只负责将任务放入队列，立即返回</li>
<li><strong>join()是协作式的</strong>：不是被动等待，而是主动寻找可执行的工作</li>
<li><strong>compute()是可分解的</strong>：子类通过重写compute()定义分解逻辑</li>
</ol>
<h4 id="分治模式的天然适配">分治模式的天然适配</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (任务足够小) &#123;<br>        <span class="hljs-keyword">return</span> 直接计算();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 分解</span><br>    <span class="hljs-type">SubTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTask</span>(左半部分);<br>    <span class="hljs-type">SubTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTask</span>(右半部分);<br>    <br>    <span class="hljs-comment">// fork() 只是入队，不阻塞</span><br>    left.fork();<br>    <br>    <span class="hljs-comment">// 当前线程直接执行 right，不入队</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightResult</span> <span class="hljs-operator">=</span> right.compute();<br>    <br>    <span class="hljs-comment">// join() 时，如果 left 还在本地队列，直接弹出执行</span><br>    <span class="hljs-comment">// 如果被窃取，则帮助窃取者执行其他任务</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftResult</span> <span class="hljs-operator">=</span> left.join();<br>    <br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-keyword">return</span> leftResult + rightResult;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么不会死锁</strong>：</p>
<ol>
<li><code>right.compute()</code>直接在当前线程执行，不占用额外线程</li>
<li><code>left.join()</code>时，如果left还在本地队列顶部，直接弹出执行（tryUnpush）</li>
<li>如果left被窃取，当前线程不会阻塞，而是帮助执行其他任务</li>
<li>即使所有线程都在&quot;等待&quot;，它们实际上都在执行任务</li>
</ol>
<h3 id="6-5-线程补偿机制：有限度的弹性">6.5 线程补偿机制：有限度的弹性</h3>
<h4 id="线程可以无限补偿吗？">线程可以无限补偿吗？</h4>
<p><strong>答案是否定的</strong>。ForkJoinPool的线程补偿受到<code>maximumSpares</code>参数的严格限制。</p>
<h4 id="补偿机制的工作原理">补偿机制的工作原理</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// tryCompensate() 的简化逻辑</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryCompensate</span><span class="hljs-params">(WorkQueue w)</span> &#123;<br>    <span class="hljs-comment">// 检查是否可以创建补偿线程</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(ctl &amp; ~SMASK);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> config &amp; SMASK;  <span class="hljs-comment">// parallelism</span><br>    <br>    <span class="hljs-comment">// 计算当前spare线程数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(ctl &gt;&gt;&gt; TC_SHIFT);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(ctl &gt;&gt; AC_SHIFT);<br>    <br>    <span class="hljs-comment">// 如果spare线程数已达上限，不再创建</span><br>    <span class="hljs-keyword">if</span> (tc &gt;= pc + MAX_SPARES) <span class="hljs-comment">// MAX_SPARES 默认为 256</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 创建补偿线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 条件满足 */</span>) &#123;<br>        createWorker();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="线程数的硬性上限">线程数的硬性上限</h4>
<p>ForkJoinPool的线程数永远不会超过：<strong>parallelism + maximumSpares</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 系统属性配置</span><br>java.util.concurrent.ForkJoinPool.common.maximumSpares = <span class="hljs-number">256</span> <span class="hljs-comment">// 默认值</span><br></code></pre></td></tr></table></figure>
<h4 id="当达到上限后会发生什么？">当达到上限后会发生什么？</h4>
<ol>
<li><strong>无法创建新的补偿线程</strong></li>
<li><strong>tryCompensate()返回false</strong></li>
<li><strong>线程进入真正的阻塞等待</strong>（LockSupport.park）</li>
<li><strong>如果所有线程都阻塞，可能导致吞吐量下降</strong></li>
</ol>
<h4 id="为什么要限制补偿？">为什么要限制补偿？</h4>
<ol>
<li><strong>防止线程爆炸</strong>：无限补偿可能导致创建过多线程</li>
<li><strong>资源保护</strong>：每个线程都消耗栈内存（默认1MB）</li>
<li><strong>上下文切换开销</strong>：过多线程导致调度开销增加</li>
<li><strong>设计哲学</strong>：ForkJoinPool假设任务是CPU密集型的，不应频繁阻塞</li>
</ol>
<h4 id="最佳实践">最佳实践</h4>
<ol>
<li><strong>避免在ForkJoinTask中执行阻塞I/O</strong></li>
<li><strong>如果必须阻塞，使用ManagedBlocker接口</strong></li>
<li><strong>合理设置parallelism和maximumSpares</strong></li>
<li><strong>监控getPoolSize()和getActiveThreadCount()</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用ManagedBlocker处理阻塞操作</span><br>ForkJoinPool.managedBlock(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>.ManagedBlocker() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">block</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 执行阻塞操作</span><br>        result = blockingOperation();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReleasable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 检查是否已完成</span><br>        <span class="hljs-keyword">return</span> result != <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="6-6-对比验证">6.6 对比验证</h3>
<h4 id="forkjoinpool版本-不会死锁">ForkJoinPool版本（不会死锁）</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinNoDeadlockDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentTask</span>(<span class="hljs-string">&quot;Root&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result); <span class="hljs-comment">// 正常完成</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>        <br>        ParentTask(String name) &#123; <span class="hljs-built_in">this</span>.name = name; &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(name + <span class="hljs-string">&quot; on &quot;</span> + Thread.currentThread().getName());<br>            <br>            <span class="hljs-comment">// 创建子任务</span><br>            <span class="hljs-type">ChildTask</span> <span class="hljs-variable">child1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildTask</span>(name + <span class="hljs-string">&quot;-Child1&quot;</span>);<br>            <span class="hljs-type">ChildTask</span> <span class="hljs-variable">child2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildTask</span>(name + <span class="hljs-string">&quot;-Child2&quot;</span>);<br>            <br>            <span class="hljs-comment">// fork 子任务</span><br>            child1.fork();<br>            child2.fork();<br>            <br>            <span class="hljs-comment">// join 不会死锁</span><br>            <span class="hljs-comment">// 当前线程会帮助执行子任务，而不是阻塞等待</span><br>            <span class="hljs-keyword">return</span> child1.join() + child2.join();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>        <br>        ChildTask(String name) &#123; <span class="hljs-built_in">this</span>.name = name; &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(name + <span class="hljs-string">&quot; on &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">21</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="执行结果">执行结果</h4>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Root</span> <span class="hljs-literal">on</span> ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span><br><span class="hljs-attribute">Root</span>-Child1 <span class="hljs-literal">on</span> ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>  // 父线程帮助执行子任务<br><span class="hljs-attribute">Root</span>-Child2 <span class="hljs-literal">on</span> ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span><br><span class="hljs-attribute">Result</span>: <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure>
<p>注意：即使只有2个线程，父任务也能完成，因为父线程在<code>join()</code>时直接执行了<code>Child1</code>。</p>
<h3 id="6-7-设计启示">6.7 设计启示</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>ThreadPoolExecutor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td>等待语义</td>
<td>阻塞等待（浪费线程）</td>
<td>协作等待（帮助执行）</td>
</tr>
<tr>
<td>父子任务</td>
<td>可能死锁</td>
<td>天然支持</td>
</tr>
<tr>
<td>线程利用率</td>
<td>等待时为0</td>
<td>等待时仍在工作</td>
</tr>
<tr>
<td>线程补偿</td>
<td>无</td>
<td>有限度补偿（maximumSpares）</td>
</tr>
<tr>
<td>适用场景</td>
<td>独立任务</td>
<td>分治/递归任务</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>核心洞察</strong>：ForkJoinPool的<code>join()</code>不是&quot;等待&quot;，而是&quot;参与&quot;。线程不会因为等待子任务而闲置，而是主动寻找可执行的工作。这种设计从根本上消除了父子任务死锁的可能性，同时通过有限度的线程补偿机制，在保证系统稳定性的前提下提供了额外的弹性。</p>
</blockquote>
<h2 id="7-结论：设计的本质">7. 结论：设计的本质</h2>
<p>ForkJoinPool不是&quot;另一个线程池&quot;，而是<strong>为分治并行量身定制的执行引擎</strong>。其核心设计决策源于对问题域的深刻理解：</p>
<ol>
<li><strong>任务结构驱动执行模型</strong>：分治算法的&quot;父-子&quot;任务结构要求特殊的调度策略，工作窃取正是为这种结构优化。</li>
<li><strong>局部性优先于公平性</strong>：LIFO本地执行牺牲任务执行的公平性，换取时间局部性的显著提升。</li>
<li><strong>协作优于竞争</strong>：线程从&quot;竞争共享资源&quot;转变为&quot;协作完成任务&quot;，资源利用率显著提高。</li>
<li><strong>动态适应优于静态配置</strong>：与ThreadPoolExecutor的&quot;核心-最大&quot;静态模型不同，ForkJoinPool通过目标并行度+spare线程机制，动态适应工作负载。</li>
<li><strong>资源效率优于固定开销</strong>：与TPE保持核心线程不同，FJP回收所有空闲线程，适合间歇性负载。</li>
</ol>
<p>正如Doug Lea在论文结论中所述：</p>
<blockquote>
<p>“This paper has demonstrated that it is possible to support portable, efficient, scalable parallel processing in pure Java, with a programming model and framework that can be convenient for programmers.”</p>
<p>（本论文证明了，纯粹的Java语言也能够实现可移植、高效可伸缩的并行处理，并且能够为程序员提供便捷的编程模型和框架。）</p>
</blockquote>
<p>理解ForkJoinPool的核心数据结构和设计哲学，才能在正确场景发挥其价值。它不是万能的，但在分治并行领域，它代表了并发计算的理论最优解。</p>
<p><strong>ForkJoinPool参考文献</strong>：</p>
<ul>
<li>Doug Lea. “A Java Fork/Join Framework”. In Proceedings of the ACM 2000 conference on Java Grande, 2000. <a target="_blank" rel="noopener" href="https://gee.cs.oswego.edu/dl/papers/fj.pdf">https://gee.cs.oswego.edu/dl/papers/fj.pdf</a></li>
</ul>
<hr>
<h1>异步编程的进化</h1>
<p>本章节一部分来自于qwen，一部分来自于以下文章：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">《CompletableFuture原理与实践-外卖商家端API的异步化》</a></li>
</ol>
<h2 id="演进本质">演进本质</h2>
<pre><code class="hljs mermaid">graph LR
    A[Java 5 Future] --&gt;|阻塞痛点| B[Guava ListenableFuture]
    B --&gt;|回调地狱| C[CompletableFuture]
    C --&gt;|流处理需求| D[RxJava]
    D --&gt;|Spring整合| E[Reactor]
    
    A --&gt;|范式转变| F[命令式-&gt;声明式]
    B --&gt;|抽象提升| G[事件驱动-&gt;数据流]
    C --&gt;|能力增强| H[组合-&gt;背压]
    D &amp; E --&gt;|统一理念| I[异步即数据流]</code></pre>
<ul>
<li>控制流：阻塞等待 → 回调响应 → 声明式组合 → 响应式流</li>
<li>错误处理：分散try-catch → 回调onFailure → 链式exceptionally → 流式onError</li>
<li>组合能力：无 → 有限transform → 丰富组合操作符 → 完整流处理</li>
<li>背压支持：无 → 无 → 有限 → 完整内建支持</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">核心特征</th>
<th style="text-align:left">编程范式</th>
<th style="text-align:left">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Java 5 Future</td>
<td style="text-align:left">阻塞等待</td>
<td style="text-align:left">命令式</td>
<td style="text-align:left">简单异步任务，兼容性要求高</td>
</tr>
<tr>
<td style="text-align:left">Guava ListenableFuture</td>
<td style="text-align:left">回调驱动</td>
<td style="text-align:left">事件驱动</td>
<td style="text-align:left">中等复杂度，需要非阻塞回调</td>
</tr>
<tr>
<td style="text-align:left">CompletableFuture</td>
<td style="text-align:left">链式组合</td>
<td style="text-align:left">声明式</td>
<td style="text-align:left">复杂异步流程，需要组合和错误处理</td>
</tr>
<tr>
<td style="text-align:left">RxJava</td>
<td style="text-align:left">响应式流</td>
<td style="text-align:left">函数式响应式</td>
<td style="text-align:left">事件流处理，背压支持，复杂数据转换</td>
</tr>
<tr>
<td style="text-align:left">Reactor</td>
<td style="text-align:left">响应式流</td>
<td style="text-align:left">函数式响应式</td>
<td style="text-align:left">Spring生态，高性能流处理，背压内建</td>
</tr>
</tbody>
</table>
<h2 id="传统调用时序">传统调用时序</h2>
<h3 id="java-5-future">Java 5 Future</h3>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#FFF5E1&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant Executor as ExecutorService
    participant Future as Future&lt;T&gt;
    participant Task as Callable&lt;T&gt;

    Note over Client,Task: Java 5 Future (阻塞式)
    Client-&gt;&gt;Executor: submit(Callable)
    Executor-&gt;&gt;Future: 创建Future
    Executor--&gt;&gt;Client: 返回Future
    Note right of Client: 非阻塞返回

    Executor-&gt;&gt;Task: 执行任务
    Task--&gt;&gt;Executor: 返回结果

    Client-&gt;&gt;Future: get() / get(timeout)
    Note right of Client: 阻塞等待
    Future--&gt;&gt;Client: 返回结果或抛出异常
    Note over Client: 阻塞式: submit/get</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心特点：阻塞等待结果</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;String&gt; future = executor.submit(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello Future&quot;</span>;<br>&#125;);<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// [注意] 阻塞当前线程等待结果</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(<span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>    System.out.println(result);<br>&#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>    System.err.println(<span class="hljs-string">&quot;超时了!&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="guava-listenablefuture">Guava ListenableFuture</h3>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#D5E8D4&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant Executor as ListeningExecutorService
    participant Future as ListenableFuture&lt;T&gt;
    participant Callback as FutureCallback&lt;T&gt;
    participant Task as Callable&lt;T&gt;

    Note over Client,Task: Guava ListenableFuture (回调式)
    Client-&gt;&gt;Executor: submit(Callable)
    Executor-&gt;&gt;Future: 创建ListenableFuture
    Executor--&gt;&gt;Client: 返回ListenableFuture
    Note right of Client: 非阻塞返回

    Client-&gt;&gt;Future: addCallback(FutureCallback)
    Note right of Client: 注册回调，非阻塞

    Executor-&gt;&gt;Task: 执行任务
    Task--&gt;&gt;Executor: 返回结果

    Future-&gt;&gt;Callback: onSuccess(result) 或 onFailure(ex)
    Note over Client: 回调式: submit/addCallback</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心特点：回调处理结果</span><br><span class="hljs-type">ListeningExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> MoreExecutors.listeningDecorator(<br>    Executors.newSingleThreadExecutor()<br>);<br><br>ListenableFuture&lt;String&gt; future = executor.submit(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello ListenableFuture&quot;</span>;<br>&#125;);<br><br><span class="hljs-comment">// [正确] 非阻塞：注册回调处理结果</span><br>Futures.addCallback(future, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(String result)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;成功: &quot;</span> + result);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>        System.err.println(<span class="hljs-string">&quot;失败: &quot;</span> + t.getMessage());<br>    &#125;<br>&#125;, executor);<br><br><span class="hljs-comment">// [注意] 需要手动关闭executor</span><br>executor.shutdown();<br></code></pre></td></tr></table></figure>
<p>这个方案是很容易产生回调地狱的，因为总是会有 addCallback + onSuccess 这种不可编排、组合 api 不适合把大型并发结果组合在一起的缺陷：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回调地狱示例</span><br>ListenableFuture&lt;User&gt; userFuture = userService.getUser(userId);<br><br><span class="hljs-comment">// 第一层回调</span><br>Futures.addCallback(userFuture, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;User&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-comment">// 第二层回调：需要 user 结果</span><br>        ListenableFuture&lt;List&lt;Order&gt;&gt; ordersFuture = orderService.getOrders(user.getId());<br>        <br>        Futures.addCallback(ordersFuture, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;List&lt;Order&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(List&lt;Order&gt; orders)</span> &#123;<br>                <span class="hljs-comment">// 第三层回调：需要 orders 结果</span><br>                ListenableFuture&lt;List&lt;Product&gt;&gt; productsFuture = <br>                    productService.getProducts(orders.stream()<br>                        .map(Order::getProductId)<br>                        .collect(Collectors.toList()));<br>                <br>                Futures.addCallback(productsFuture, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;List&lt;Product&gt;&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(List&lt;Product&gt; products)</span> &#123;<br>                        <span class="hljs-comment">// 第四层回调：需要 products 结果</span><br>                        <span class="hljs-comment">// 终于可以组装最终结果了...</span><br>                        <span class="hljs-type">OrderDetails</span> <span class="hljs-variable">details</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDetails</span>(user, orders, products);<br>                        log.info(<span class="hljs-string">&quot;订单详情: &#123;&#125;&quot;</span>, details);<br>                    &#125;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>                        log.error(<span class="hljs-string">&quot;Products retrieval failed&quot;</span>, t);<br>                        auditService.logFailure(<span class="hljs-string">&quot;products&quot;</span>, t);<br>                    &#125;<br>                &#125;, executor);<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>                log.error(<span class="hljs-string">&quot;Orders retrieval failed&quot;</span>, t);<br>                auditService.logFailure(<span class="hljs-string">&quot;orders&quot;</span>, t);<br>            &#125;<br>        &#125;, executor);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>        log.error(<span class="hljs-string">&quot;User retrieval failed&quot;</span>, t);<br>        auditService.logFailure(<span class="hljs-string">&quot;user&quot;</span>, t);<br>    &#125;<br>&#125;, executor);<br></code></pre></td></tr></table></figure>
<h3 id="completablefuture">CompletableFuture</h3>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#DAE8FC&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant CF1 as CompletableFuture&lt;T&gt;
    participant CF2 as CompletableFuture&lt;U&gt;
    participant Executor as Executor

    Note over Client,Executor: CompletableFuture (链式组合)
    Client-&gt;&gt;CF1: supplyAsync(Supplier)
    CF1--&gt;&gt;Client: 返回CompletableFuture
    Note right of Client: 非阻塞返回

    Client-&gt;&gt;CF1: thenApply(Function)
    CF1-&gt;&gt;CF2: 创建新的CompletableFuture
    CF2--&gt;&gt;Client: 返回新的CompletableFuture
    Note right of Client: 链式组合，非阻塞

    Executor-&gt;&gt;CF1: 执行任务
    CF1-&gt;&gt;CF2: 传递结果
    CF2--&gt;&gt;Client: 完成时通知
    Note over Client: 链式: supplyAsync/thenApply/thenCompose</code></pre>
<p>CompletableFuture 和 ListenableFuture 的设计哲学差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ListenableFuture 设计哲学：</span><br><span class="hljs-comment">// &quot;当异步操作完成时，通知我&quot;</span><br>future.addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;T&gt;() &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(T result)</span>;    <span class="hljs-comment">// 回调处理成功</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span>; <span class="hljs-comment">// 回调处理失败</span><br>&#125;);<br><br><span class="hljs-comment">// CompletableFuture 设计哲学：</span><br><span class="hljs-comment">// &quot;将这个异步操作与下一个操作组合起来&quot;</span><br>future.thenCompose(result -&gt; nextOperation(result))<br>      .thenApply(transformed -&gt; process(transformed))<br>      .exceptionally(ex -&gt; handle(ex));<br></code></pre></td></tr></table></figure>
<h4 id="执行树">执行树</h4>
<p><img src="CompletableFuture%E6%89%A7%E8%A1%8C%E6%A0%91.png" alt="CompletableFuture执行树.png"></p>
<h4 id="核心-api">核心 API</h4>
<pre><code class="hljs mermaid">classDiagram
    class CompletableFuture~T~ &#123;
        &lt;&lt;核心类&gt;&gt;
        +T result
        +Throwable exception
        +Object stack
        
        %% 创建方法
        +supplyAsync(Supplier~T~) CompletableFuture~T~
        +runAsync(Runnable) CompletableFuture~Void~
        +completedFuture(T) CompletableFuture~T~
        
        %% 转换方法
        +thenApply(Function) CompletableFuture~U~
        +thenApplyAsync(Function) CompletableFuture~U~
        +thenCompose(Function) CompletableFuture~U~
        
        %% 消费方法
        +thenAccept(Consumer) CompletableFuture~Void~
        +thenRun(Runnable) CompletableFuture~Void~
        
        %% 组合方法
        +thenCombine(CompletableFuture, BiFunction) CompletableFuture~V~
        +allOf(CompletableFuture...) CompletableFuture~Void~
        +anyOf(CompletableFuture...) CompletableFuture~Object~
        
        %% 异常处理
        +exceptionally(Function) CompletableFuture~T~
        +handle(BiFunction) CompletableFuture~U~
        +whenComplete(BiConsumer) CompletableFuture~T~
        
        %% 完成方法
        +complete(T) boolean
        +completeExceptionally(Throwable) boolean
        
        %% 获取结果
        +get() T
        +join() T
        +getNow(T) T
    &#125;
    
    class CompletionStage~T~ &#123;
        &lt;&lt;接口&gt;&gt;
        +thenApply(Function) CompletionStage~U~
        +thenCompose(Function) CompletionStage~U~
        +thenCombine(CompletionStage, BiFunction) CompletionStage~V~
        +exceptionally(Function) CompletionStage~T~
    &#125;
    
    class Future~T~ &#123;
        &lt;&lt;接口&gt;&gt;
        +get() T
        +get(long, TimeUnit) T
        +cancel(boolean) boolean
        +isDone() boolean
        +isCancelled() boolean
    &#125;
    
    CompletableFuture ..|&gt; CompletionStage : implements
    CompletableFuture ..|&gt; Future : implements</code></pre>
<h4 id="使用原则">使用原则</h4>
<h5 id="原则一：异步回调要传线程池">原则一：异步回调要传线程池</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 不指定线程池，使用默认的ForkJoinPool.commonPool()</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))  <span class="hljs-comment">// 可能在commonPool线程执行</span><br>    .thenAccept(result -&gt; save(result)); <span class="hljs-comment">// 可能在调用线程执行</span><br><br><span class="hljs-comment">// [正确] 明确指定线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ioExecutor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuExecutor</span> <span class="hljs-operator">=</span> Executors.newWorkStealingPool();<br><br>CompletableFuture.supplyAsync(() -&gt; fetchData(), ioExecutor)<br>    .thenApplyAsync(data -&gt; process(data), cpuExecutor)<br>    .thenAcceptAsync(result -&gt; save(result), ioExecutor);<br></code></pre></td></tr></table></figure>
<h5 id="原则二：completablefuture-中不要吞异常">原则二：CompletableFuture 中不要吞异常</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 异常被吞掉，无法感知</span><br>CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;出错了&quot;</span>);<br>&#125;).thenApply(result -&gt; result + <span class="hljs-string">&quot;processed&quot;</span>);<br><span class="hljs-comment">// 如果不调用get/join，异常永远不会被发现</span><br><br><span class="hljs-comment">// [正确] 使用exceptionally或handle处理异常</span><br>CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;出错了&quot;</span>);<br>&#125;).exceptionally(ex -&gt; &#123;<br>    log.error(<span class="hljs-string">&quot;任务执行失败&quot;</span>, ex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;默认值&quot;</span>;<br>&#125;).thenApply(result -&gt; result + <span class="hljs-string">&quot;processed&quot;</span>);<br><br><span class="hljs-comment">// [更好] 使用whenComplete记录日志，不影响异常传播</span><br>CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;出错了&quot;</span>);<br>&#125;).whenComplete((result, ex) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (ex != <span class="hljs-literal">null</span>) &#123;<br>        log.error(<span class="hljs-string">&quot;任务执行失败&quot;</span>, ex);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h5 id="原则三：自定义线程池时-注意饱和策略">原则三：自定义线程池时，注意饱和策略</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 使用无界队列，可能导致OOM</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;()  <span class="hljs-comment">// 无界队列</span><br>);<br><br><span class="hljs-comment">// [正确] 使用有界队列 + 合适的拒绝策略</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="hljs-comment">// 调用者执行策略</span><br>);<br></code></pre></td></tr></table></figure>
<h5 id="原则四：正确进行异常处理">原则四：正确进行异常处理</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 只处理部分异常</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))<br>    .exceptionally(ex -&gt; handleFetchError(ex));  <span class="hljs-comment">// 只能处理fetchData的异常</span><br><br><span class="hljs-comment">// [正确] 在链的末端统一处理异常</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))<br>    .thenApply(result -&gt; transform(result))<br>    .exceptionally(ex -&gt; &#123;<br>        <span class="hljs-comment">// 处理整个链中的任何异常</span><br>        log.error(<span class="hljs-string">&quot;处理失败&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> defaultValue;<br>    &#125;);<br><br><span class="hljs-comment">// [更好] 使用handle同时处理结果和异常</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))<br>    .handle((result, ex) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (ex != <span class="hljs-literal">null</span>) &#123;<br>            log.error(<span class="hljs-string">&quot;处理失败&quot;</span>, ex);<br>            <span class="hljs-keyword">return</span> defaultValue;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<h5 id="原则五：合理设置超时">原则五：合理设置超时</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 没有超时控制</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-comment">// 可能永远阻塞</span><br>    <span class="hljs-keyword">return</span> slowService.call();<br>&#125;);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.join();  <span class="hljs-comment">// 可能永远阻塞</span><br><br><span class="hljs-comment">// [正确] Java 9+ 使用orTimeout</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">return</span> slowService.call();<br>&#125;).orTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// [正确] Java 8 使用get with timeout</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>&#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>    future.cancel(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 处理超时</span><br>&#125;<br><br><span class="hljs-comment">// [更好] 使用completeOnTimeout提供默认值 (Java 9+)</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">return</span> slowService.call();<br>&#125;).completeOnTimeout(<span class="hljs-string">&quot;默认值&quot;</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>
<h5 id="原则六：避免在回调中阻塞">原则六：避免在回调中阻塞</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 在回调中阻塞</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; &#123;<br>        <span class="hljs-comment">// 阻塞操作，会占用线程池线程</span><br>        <span class="hljs-keyword">return</span> anotherService.syncCall(data);<br>    &#125;);<br><br><span class="hljs-comment">// [正确] 使用thenCompose处理嵌套的异步操作</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenCompose(data -&gt; &#123;<br>        <span class="hljs-comment">// 返回新的CompletableFuture，不阻塞</span><br>        <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(<br>            () -&gt; anotherService.syncCall(data), <br>            ioExecutor<br>        );<br>    &#125;);<br></code></pre></td></tr></table></figure>
<h4 id="完成保证原则">完成保证原则</h4>
<p>完成保证原则（Completion Guarantee Principle）是 CompletableFuture 编程中的一个核心设计模式，其核心思想是：</p>
<blockquote>
<p><strong>在调用 <code>join()</code> 或 <code>get()</code> 之前，确保目标 Future 已经完成，从而将阻塞操作转化为非阻塞的结果获取。</strong></p>
</blockquote>
<h5 id="为什么需要完成保证原则？">为什么需要完成保证原则？</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [问题] 直接调用join()会阻塞当前线程</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;result&quot;</span>;<br>&#125;);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.join();  <span class="hljs-comment">// 阻塞1秒</span><br><br><span class="hljs-comment">// [解决] 使用allOf确保完成后再join</span><br>CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(future);<br>allDone.thenApply(v -&gt; &#123;<br>    <span class="hljs-comment">// 此时future已完成，join()立即返回，不阻塞</span><br>    <span class="hljs-keyword">return</span> future.join();<br>&#125;);<br></code></pre></td></tr></table></figure>
<h5 id="完成保证原则的核心模式">完成保证原则的核心模式</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 模式：allOf() + thenApplyAsync() + join()</span><br>List&lt;CompletableFuture&lt;String&gt;&gt; futures = services.stream()<br>    .map(service -&gt; CompletableFuture.supplyAsync(() -&gt; service.call(), ioExecutor))<br>    .collect(Collectors.toList());<br><br>CompletableFuture&lt;List&lt;String&gt;&gt; resultFuture = CompletableFuture<br>    .allOf(futures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>]))  <span class="hljs-comment">// 1. 等待所有完成</span><br>    .thenApplyAsync(v -&gt; &#123;                              <span class="hljs-comment">// 2. 完成后执行回调</span><br>        <span class="hljs-keyword">return</span> futures.stream()<br>            .map(CompletableFuture::join)               <span class="hljs-comment">// 3. join()不阻塞</span><br>            .collect(Collectors.toList());<br>    &#125;, cpuExecutor);<br></code></pre></td></tr></table></figure>
<h5 id="完整示例">完整示例</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完成保证原则示例</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 核心思想：在调用join()之前，确保Future已完成</span><br><span class="hljs-comment"> * 模式：allOf() + thenApplyAsync() + join()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompletionGuaranteeExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建IO线程池（用于网络调用等IO密集型任务）</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ioPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>, r -&gt; &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;io-pool-&quot;</span> + System.nanoTime());<br>            t.setDaemon(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 创建CPU线程池（用于结果聚合等CPU密集型任务）</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<br>            Runtime.getRuntime().availableProcessors(),<br>            r -&gt; &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;cpu-pool-&quot;</span> + System.nanoTime());<br>                t.setDaemon(<span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        );<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;] 开始执行&quot;</span>);<br>            <br>            <span class="hljs-comment">// 1. 创建多个异步任务（模拟30个服务调用）</span><br>            List&lt;CompletableFuture&lt;String&gt;&gt; serviceFutures = IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">30</span>)<br>                .mapToObj(i -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;] 调用服务 &quot;</span> + i);<br>                    simulateIoOperation(i);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;result-&quot;</span> + i;<br>                &#125;, ioPool))<br>                .collect(Collectors.toList());<br><br>            <span class="hljs-comment">// 2. 应用完成保证原则：allOf() + thenApplyAsync() + join()</span><br>            CompletableFuture&lt;List&lt;String&gt;&gt; resultFuture = CompletableFuture<br>                .allOf(serviceFutures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>])) <span class="hljs-comment">// 等待所有完成</span><br>                .thenApplyAsync(v -&gt; &#123; <span class="hljs-comment">// 所有future完成后才执行此回调</span><br>                    System.out.println(<span class="hljs-string">&quot;\n[正确] 原则验证: 所有服务调用已完成，开始聚合结果&quot;</span>);<br>                    System.out.println(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;] 聚合阶段启动（CPU密集型）&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// 关键点：此处join() 100% 不阻塞！</span><br>                    List&lt;String&gt; results = serviceFutures.stream()<br>                        .map(future -&gt; &#123;<br>                            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                            <br>                            <span class="hljs-comment">// [要点] 完成保证原则核心：</span><br>                            <span class="hljs-comment">// 由于 allOf() 确保所有 future 已完成，</span><br>                            <span class="hljs-comment">// future.join() 直接返回内部存储的 result 字段</span><br>                            <span class="hljs-comment">// 无锁竞争、无上下文切换、无阻塞</span><br>                            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.join(); <br>                            <br>                            <span class="hljs-type">long</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> System.nanoTime() - start;<br>                            System.out.printf(<br>                                <span class="hljs-string">&quot;[%s] join() 耗时: %d ns, 结果: %s\n&quot;</span>, <br>                                Thread.currentThread().getName(), <br>                                duration, <br>                                result<br>                            );<br>                            <br>                            <span class="hljs-comment">// [注意] 重要验证：join() 耗时应接近 0（通常 &lt; 1000 ns）</span><br>                            <span class="hljs-comment">// 如果耗时 &gt; 10000 ns，说明存在阻塞（违反完成保证原则）</span><br>                            <span class="hljs-keyword">return</span> result;<br>                        &#125;)<br>                        .collect(Collectors.toList());<br>                    <br>                    <span class="hljs-keyword">return</span> results;<br>                &#125;, cpuPool) <span class="hljs-comment">// 显式指定CPU线程池，避免在IO线程执行计算</span><br>                .exceptionally(ex -&gt; &#123;<br>                    System.err.println(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;] [错误] 全局异常: &quot;</span> + ex.getMessage());<br>                    <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;GLOBAL_FALLBACK&quot;</span>);<br>                &#125;);<br><br>            <span class="hljs-comment">// 3. 获取最终结果（末端阻塞，由主线程执行）</span><br>            List&lt;String&gt; results = resultFuture.join();<br>            System.out.println(<span class="hljs-string">&quot;\n最终聚合结果: &quot;</span> + results.size() + <span class="hljs-string">&quot; 个结果&quot;</span>);<br>            results.forEach(r -&gt; System.out.println(<span class="hljs-string">&quot;  - &quot;</span> + r));<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ioPool.shutdown();<br>            cpuPool.shutdown();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟IO操作（可变延迟）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simulateIoOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 不同服务不同延迟，模拟真实场景</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span> + (id * <span class="hljs-number">10</span>) % <span class="hljs-number">200</span>;<br>            Thread.sleep(delay);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;IO操作被中断&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="对传统的线程池的效率改进">对传统的线程池的效率改进</h4>
<p>CompletableFuture 相对于一般线程池的改进主要来自于对于<strong>复杂结果编排的 API 优化，本身并不提供性能优化</strong>。</p>
<p>如果要实现性能优化，可以</p>
<ol>
<li>基于 Netty/NIO 实现了真正的异步 RPC：</li>
</ol>
<ul>
<li>发起调用后立即返回，不阻塞线程；</li>
<li>结果由 Netty 的 IO 线程（或专用回调线程）在数据到达时触发；</li>
<li>一个 IO 线程可同时管理成千上万个连接（C10K+）。</li>
</ul>
<ol start="2">
<li>CompletableFuture 被用作&quot;胶水层&quot;：</li>
</ol>
<ul>
<li>将 NIO 回调封装为 CompletableFuture（如 toCompletableFuture 工具方法）；</li>
<li>用 thenCompose / allOf 等组合多个异步 RPC；</li>
<li>业务逻辑不再关心回调注册，只关注数据流依赖。</li>
</ul>
<pre><code class="hljs mermaid">graph TD
    A[&quot;Client Request&quot;] --&gt; B[&quot;Inbound IO Thread&lt;br&gt;Netty EventLoop&quot;]
    B --&gt; C[&quot;Business Worker Thread&lt;br&gt;from biz-pool&quot;]

    C --&gt; d1[&quot;Create CF1 = new CompletableFuture()&quot;]
    C --&gt; d2[&quot;Create CF2 = new CompletableFuture()&quot;]
    C --&gt; d3[&quot;Create CF3 = new CompletableFuture()&quot;]

    d1 --&gt; e1[&quot;Register Observer1:&lt;br&gt;onSuccess → CF1.complete(...)&lt;br&gt;onFailure → CF1.completeEx(...)&quot;]
    d2 --&gt; e2[&quot;Register Observer2:&lt;br&gt;onSuccess → CF2.complete(...)&lt;br&gt;onFailure → CF2.completeEx(...)&quot;]
    d3 --&gt; e3[&quot;Register Observer3:&lt;br&gt;onSuccess → CF3.complete(...)&lt;br&gt;onFailure → CF3.completeEx(...)&quot;]

    e1 --&gt; f1[&quot;Call mtthrift.async(orderService, Observer1)&quot;]
    e2 --&gt; f2[&quot;Call mtthrift.async(productService, Observer2)&quot;]
    e3 --&gt; f3[&quot;Call mtthrift.async(deliveryService, Observer3)&quot;]

    f1 --&gt; g[&quot;Outbound IO Thread&lt;br&gt;Netty Client EventLoop&quot;]
    f2 --&gt; g
    f3 --&gt; g

    g --&gt; h1[&quot;(orderService)&quot;]
    g --&gt; h2[&quot;(productService)&quot;]
    g --&gt; h3[&quot;(deliveryService)&quot;]

    h1 --&gt;|Response| i1[&quot;Outbound IO Thread invokes&lt;br&gt;Observer1.onSuccess(result)&quot;]
    h2 --&gt;|Response| i2[&quot;Outbound IO Thread invokes&lt;br&gt;Observer2.onSuccess(result)&quot;]
    h3 --&gt;|Error| i3[&quot;Outbound IO Thread invokes&lt;br&gt;Observer3.onFailure(ex)&quot;]

    i1 --&gt; j1[&quot;CF1.complete(result)&quot;]
    i2 --&gt; j2[&quot;CF2.complete(result)&quot;]
    i3 --&gt; j3[&quot;CF3.completeExceptionally(ex)&quot;]

    j1 --&gt; k1[&quot;CF1.thenApplyAsync(enrichOrder, cpu-pool)&quot;]
    j2 --&gt; k2[&quot;CF2.thenApplyAsync(enrichProduct, cpu-pool)&quot;]
    j3 --&gt; k3[&quot;CF3.exceptionally(handleFallback)&quot;]

    k1 --&gt; l[&quot;CF4 = CF1.thenCombine(CF2, merge)&quot;]
    k2 --&gt; l
    k1 --&gt; m[&quot;CompletableFuture.allOf(CF1..CF30)&quot;]
    k2 --&gt; m
    k3 --&gt; m

    m --&gt; n[&quot;m.thenApplyAsync(aggregateAll, cpu-pool)&quot;]
    n --&gt; o[&quot;Final Result&quot;]
    o --&gt; p[&quot;Write Response via Inbound IO Thread&quot;]
    p --&gt; q[&quot;Client&quot;]

    classDef io fill:#d5e8d4,stroke:#82b366;
    classDef worker fill:#dae8fc,stroke:#6c8ebf;
    classDef outbound fill:#e1d5e7,stroke:#9673a6;
    classDef cf fill:#fff2cc,stroke:#d6b656;
    classDef service fill:#f8cecc,stroke:#b85450;
    classDef observer fill:#e6e6fa,stroke:#999;

    class B,p io
    class C,d1,d2,d3,e1,e2,e3,f1,f2,f3,k1,k2,k3,l,m,n worker
    class g,i1,i2,i3 outbound
    class j1,j2,j3,o cf
    class h1,h2,h3 service
    class e1,e2,e3 observer</code></pre>
<h2 id="rxjava">RxJava</h2>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#E1D5E7&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant Observable as Observable
    participant Operator1 as map
    participant Operator2 as filter
    participant Subscriber as Subscriber

    Note over Client,Subscriber: RxJava (响应式流)
    Client-&gt;&gt;Observable: create(emitter)
    Observable--&gt;&gt;Operator1: 注册操作符
    Operator1-&gt;&gt;Observable: map(transform)
    Observable--&gt;&gt;Operator2: 注册操作符
    Operator2-&gt;&gt;Observable: filter(predicate)
    Observable--&gt;&gt;Subscriber: subscribe(Subscriber)
    Note right of Client: 非阻塞订阅

    par 数据流处理
        Observable-&gt;&gt;Operator1: onNext(item)
        Operator1-&gt;&gt;Operator2: onNext(mapped)
        Operator2-&gt;&gt;Subscriber: onNext(filtered)
    end

    Observable-&gt;&gt;Subscriber: onComplete()
    Note over Client: 响应式: map/filter/subscribe</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心特点：数据流处理，背压支持</span><br>Observable&lt;String&gt; observable1 = Observable.fromCallable(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;).subscribeOn(Schedulers.io());<br><br>Observable&lt;String&gt; observable2 = Observable.fromCallable(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RxJava&quot;</span>;<br>&#125;).subscribeOn(Schedulers.io());<br><br><span class="hljs-comment">// [正确] 非阻塞：流式处理</span><br>Observable.zip(observable1, observable2, (s1, s2) -&gt; s1 + <span class="hljs-string">&quot; &quot;</span> + s2)<br>    .map(String::toUpperCase)<br>    .timeout(<span class="hljs-number">2</span>, TimeUnit.SECONDS)<br>    .onErrorReturn(ex -&gt; <span class="hljs-string">&quot;FALLBACK: &quot;</span> + ex.getMessage())<br>    .subscribe(<br>        result -&gt; System.out.println(<span class="hljs-string">&quot;结果: &quot;</span> + result),<br>        error -&gt; System.err.println(<span class="hljs-string">&quot;错误: &quot;</span> + error.getMessage())<br>    );<br><br><span class="hljs-comment">// [注意] RxJava通常不需要手动关闭调度器</span><br></code></pre></td></tr></table></figure>
<h2 id="reactor">Reactor</h2>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#9DC3E6&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant Flux as Flux
    participant Operator1 as map
    participant Operator2 as flatMap
    participant Subscriber as Subscriber

    Note over Client,Subscriber: Reactor (响应式流)
    Client-&gt;&gt;Flux: create(sink)
    Flux--&gt;&gt;Operator1: 注册操作符
    Operator1-&gt;&gt;Flux: map(transform)
    Flux--&gt;&gt;Operator2: 注册操作符
    Operator2-&gt;&gt;Flux: flatMap(asyncOp)
    Flux--&gt;&gt;Subscriber: subscribe(Subscriber)
    Note right of Client: 非阻塞订阅

    par 数据流处理
        Flux-&gt;&gt;Operator1: onNext(item)
        Operator1-&gt;&gt;Operator2: onNext(mapped)
        Operator2-&gt;&gt;Subscriber: onNext(result)
    end

    Flux-&gt;&gt;Subscriber: onComplete()
    Note over Client: 响应式: map/flatMap/subscribe</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心特点：响应式流，背压内建，Spring集成</span><br>Flux&lt;String&gt; flux1 = Flux.fromCallable(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;).subscribeOn(Schedulers.boundedElastic());<br><br>Flux&lt;String&gt; flux2 = Flux.fromCallable(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Reactor&quot;</span>;<br>&#125;).subscribeOn(Schedulers.boundedElastic());<br><br><span class="hljs-comment">// [正确] 非阻塞：声明式流处理</span><br>Flux.zip(flux1, flux2, (s1, s2) -&gt; s1 + <span class="hljs-string">&quot; &quot;</span> + s2)<br>    .map(String::toUpperCase)<br>    .timeout(Duration.ofSeconds(<span class="hljs-number">2</span>))<br>    .onErrorResume(ex -&gt; Mono.just(<span class="hljs-string">&quot;FALLBACK: &quot;</span> + ex.getMessage()))<br>    .subscribe(<br>        result -&gt; System.out.println(<span class="hljs-string">&quot;结果: &quot;</span> + result),<br>        error -&gt; System.err.println(<span class="hljs-string">&quot;错误: &quot;</span> + error.getMessage()),<br>        () -&gt; System.out.println(<span class="hljs-string">&quot;完成&quot;</span>)<br>    );<br><br><span class="hljs-comment">// [注意] Reactor通常由Spring管理生命周期</span><br></code></pre></td></tr></table></figure>
<hr>
<h1>虚拟线程：Java 并发模型的未来</h1>
<p>虚拟线程（Virtual Threads）是 JDK 21 正式引入的革命性特性（JEP 444），代表了 Java 并发模型的未来方向。理解虚拟线程与传统线程池的差异，对架构决策至关重要。</p>
<h2 id="为什么需要虚拟线程？">为什么需要虚拟线程？</h2>
<h3 id="传统线程模型的困境">传统线程模型的困境</h3>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;传统平台线程模型&quot;
        A[Java Thread] --&gt;|1:1 映射| B[OS Thread]
        B --&gt; C[内核调度]
        C --&gt; D[上下文切换开销大]
        D --&gt; E[线程数受限于内存]
        E --&gt; F[线程池成为必需品]
    end
    
    subgraph &quot;问题&quot;
        F --&gt; G[线程池大小难以调优]
        F --&gt; H[阻塞操作浪费线程]
        F --&gt; I[高并发场景受限]
    end</code></pre>
<p>传统 Java 线程（平台线程）的问题：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
<th>影响</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>内存开销大</strong></td>
<td>每个线程默认栈大小 1MB</td>
<td>10000 线程 ≈ 10GB 内存</td>
</tr>
<tr>
<td><strong>创建成本高</strong></td>
<td>需要 OS 内核参与</td>
<td>创建/销毁耗时约 1ms</td>
</tr>
<tr>
<td><strong>上下文切换昂贵</strong></td>
<td>内核态切换</td>
<td>约 1-10μs 每次切换</td>
</tr>
<tr>
<td><strong>数量受限</strong></td>
<td>受 OS 和内存限制</td>
<td>通常数千到数万</td>
</tr>
</tbody>
</table>
<h3 id="虚拟线程的解决方案">虚拟线程的解决方案</h3>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;虚拟线程模型&quot;
        A1[Virtual Thread 1] --&gt; B1[Carrier Thread 1]
        A2[Virtual Thread 2] --&gt; B1
        A3[Virtual Thread 3] --&gt; B1
        A4[Virtual Thread 4] --&gt; B2[Carrier Thread 2]
        A5[Virtual Thread ...] --&gt; B2
        A6[Virtual Thread N] --&gt; B2
        
        B1 --&gt; C1[OS Thread 1]
        B2 --&gt; C2[OS Thread 2]
    end
    
    subgraph &quot;优势&quot;
        D[M:N 调度模型]
        E[JVM 管理调度]
        F[阻塞时自动让出]
        G[百万级并发]
    end</code></pre>
<h2 id="虚拟线程-vs-平台线程">虚拟线程 vs 平台线程</h2>
<h3 id="核心差异对比">核心差异对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>平台线程 (Platform Thread)</th>
<th>虚拟线程 (Virtual Thread)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>映射关系</strong></td>
<td>1:1 映射到 OS 线程</td>
<td>M:N 映射（多对少）</td>
</tr>
<tr>
<td><strong>调度者</strong></td>
<td>OS 内核</td>
<td>JVM（用户态调度）</td>
</tr>
<tr>
<td><strong>栈大小</strong></td>
<td>固定（默认 1MB）</td>
<td>动态增长（初始 KB 级）</td>
</tr>
<tr>
<td><strong>创建成本</strong></td>
<td>高（~1ms）</td>
<td>极低（~1μs）</td>
</tr>
<tr>
<td><strong>数量上限</strong></td>
<td>数千到数万</td>
<td>数百万</td>
</tr>
<tr>
<td><strong>阻塞行为</strong></td>
<td>阻塞 OS 线程</td>
<td>自动挂起，让出载体线程</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>CPU 密集型</td>
<td>IO 密集型</td>
</tr>
</tbody>
</table>
<h3 id="代码对比">代码对比</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ========== 传统平台线程池方式 ==========</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">platformPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">200</span>);<br><br><span class="hljs-comment">// 问题：200个线程处理10000个请求，大量时间浪费在等待IO</span><br>List&lt;Future&lt;String&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>    futures.add(platformPool.submit(() -&gt; &#123;<br>        <span class="hljs-comment">// 模拟IO操作（数据库查询、HTTP调用等）</span><br>        Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 线程被阻塞，无法处理其他请求</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result-&quot;</span> + id;<br>    &#125;));<br>&#125;<br><br><span class="hljs-comment">// ========== 虚拟线程方式 (JDK 21+) ==========</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">virtualPool</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    <span class="hljs-comment">// 优势：可以创建10000个虚拟线程，每个请求一个线程</span><br>    List&lt;Future&lt;String&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>        futures.add(virtualPool.submit(() -&gt; &#123;<br>            <span class="hljs-comment">// 虚拟线程阻塞时自动让出载体线程</span><br>            Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 不会阻塞载体线程！</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result-&quot;</span> + id;<br>        &#125;));<br>    &#125;<br>    <br>    <span class="hljs-comment">// 收集结果</span><br>    <span class="hljs-keyword">for</span> (Future&lt;String&gt; future : futures) &#123;<br>        System.out.println(future.get());<br>    &#125;<br>&#125; <span class="hljs-comment">// try-with-resources 自动关闭</span><br></code></pre></td></tr></table></figure>
<h2 id="虚拟线程的工作原理">虚拟线程的工作原理</h2>
<h3 id="挂载与卸载机制">挂载与卸载机制</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant VT as Virtual Thread
    participant CT as Carrier Thread
    participant OS as OS Thread
    participant IO as IO Operation

    Note over VT,OS: 虚拟线程执行流程
    
    VT-&gt;&gt;CT: 挂载 (mount)
    CT-&gt;&gt;OS: 执行用户代码
    
    VT-&gt;&gt;IO: 发起阻塞IO
    Note over VT: 检测到阻塞操作
    VT-&gt;&gt;CT: 卸载 (unmount)
    Note over CT: 载体线程空闲，可执行其他虚拟线程
    
    IO--&gt;&gt;VT: IO完成
    VT-&gt;&gt;CT: 重新挂载 (remount)
    CT-&gt;&gt;OS: 继续执行</code></pre>
<h3 id="虚拟线程调度模型：与-go-gpm-的对比">虚拟线程调度模型：与 Go GPM 的对比</h3>
<p>理解虚拟线程的调度机制，需要与 Go 语言的 GPM 模型进行对比。两者都实现了 M:N 调度，但设计哲学有所不同。</p>
<p><strong>Go 的 GPM 模型</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Go Runtime&quot;
        G1[Goroutine 1]
        G2[Goroutine 2]
        G3[Goroutine 3]
        G4[Goroutine 4]
        
        P1[P: Processor 1&lt;br/&gt;本地队列]
        P2[P: Processor 2&lt;br/&gt;本地队列]
        
        M1[M: OS Thread 1]
        M2[M: OS Thread 2]
        
        GQ[Global Queue&lt;br/&gt;全局队列]
        
        G1 --&gt; P1
        G2 --&gt; P1
        G3 --&gt; P2
        G4 --&gt; GQ
        
        P1 --&gt; M1
        P2 --&gt; M2
        
        M1 --&gt; OS1[OS Scheduler]
        M2 --&gt; OS1
    end
    
    style P1 fill:#90EE90
    style P2 fill:#90EE90</code></pre>
<p><strong>Java 虚拟线程模型</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;JVM&quot;
        VT1[Virtual Thread 1]
        VT2[Virtual Thread 2]
        VT3[Virtual Thread 3]
        VT4[Virtual Thread 4]
        
        WQ1[WorkQueue 1]
        WQ2[WorkQueue 2]
        
        CT1[Carrier Thread 1&lt;br/&gt;ForkJoinWorkerThread]
        CT2[Carrier Thread 2&lt;br/&gt;ForkJoinWorkerThread]
        
        VT1 -.unmounted.-&gt; WQ1
        VT2 --&gt; CT1
        VT3 --&gt; CT2
        VT4 -.unmounted.-&gt; WQ2
        
        CT1 --&gt; OS1[OS Thread 1]
        CT2 --&gt; OS2[OS Thread 2]
        
        OS1 --&gt; OSS[OS Scheduler]
        OS2 --&gt; OSS
    end
    
    style CT1 fill:#87CEEB
    style CT2 fill:#87CEEB</code></pre>
<p><strong>核心差异对比</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Go GPM</th>
<th>Java Virtual Thread</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>G (Goroutine)</strong></td>
<td>用户态协程</td>
<td>虚拟线程 (Virtual Thread)</td>
</tr>
<tr>
<td><strong>P (Processor)</strong></td>
<td>逻辑处理器，持有 G 的本地队列</td>
<td>无显式 P 概念，使用 ForkJoinPool 的 WorkQueue</td>
</tr>
<tr>
<td><strong>M (Machine)</strong></td>
<td>OS 线程</td>
<td>Carrier Thread (载体线程)</td>
</tr>
<tr>
<td><strong>调度器</strong></td>
<td>Go Runtime Scheduler</td>
<td>ForkJoinPool (work-stealing)</td>
</tr>
<tr>
<td><strong>队列模型</strong></td>
<td>本地队列 + 全局队列</td>
<td>每个 Carrier Thread 的 WorkQueue</td>
</tr>
<tr>
<td><strong>Work Stealing</strong></td>
<td>P 之间窃取 G</td>
<td>Carrier Thread 之间窃取任务</td>
</tr>
<tr>
<td><strong>阻塞处理</strong></td>
<td>M 阻塞时创建新 M</td>
<td>Carrier Thread 不阻塞，虚拟线程 unmount</td>
</tr>
</tbody>
</table>
<p><strong>关键设计差异</strong></p>
<ol>
<li>
<p><strong>Go 的 P (Processor)</strong>：</p>
<ul>
<li>Go 显式引入了 P 的概念，作为 G 和 M 之间的中介</li>
<li>P 的数量通常等于 CPU 核心数（GOMAXPROCS）</li>
<li>P 持有本地队列，减少全局队列的竞争</li>
</ul>
</li>
<li>
<p><strong>Java 的简化模型</strong>：</p>
<ul>
<li>Java 没有显式的 P 概念</li>
<li>直接使用 ForkJoinPool 的 work-stealing 机制</li>
<li>Carrier Thread 数量默认等于 CPU 核心数</li>
<li>每个 Carrier Thread 有自己的 WorkQueue</li>
</ul>
</li>
</ol>
<p><strong>为什么 Java 不需要 P？</strong></p>
<p>Go 的 P 设计是为了解决以下问题：</p>
<ul>
<li>减少全局队列的锁竞争</li>
<li>支持 work-stealing</li>
<li>管理 G 的本地缓存</li>
</ul>
<p>Java 虚拟线程通过 <strong>ForkJoinPool</strong> 已经实现了这些功能：</p>
<ul>
<li>ForkJoinPool 本身就是为 work-stealing 设计的</li>
<li>每个 ForkJoinWorkerThread 有自己的双端队列</li>
<li>无需额外的 P 抽象层</li>
</ul>
<h3 id="虚拟线程的-continuation-机制：unmount-mount-的本质">虚拟线程的 Continuation 机制：unmount/mount 的本质</h3>
<p>虚拟线程的核心是 <strong>Continuation</strong>（延续）机制。这是理解 unmount/mount 行为的关键。</p>
<p><strong>什么是 Continuation？</strong></p>
<p>Continuation 是一种可以暂停和恢复执行的程序抽象。在 Java 中，它是 <code>jdk.internal.vm.Continuation</code> 类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简化的 Continuation 概念示例（实际是 JVM 内部实现）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Continuation</span> &#123;<br>    <span class="hljs-keyword">private</span> Object[] stack;  <span class="hljs-comment">// 保存的栈帧</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pc;          <span class="hljs-comment">// 程序计数器</span><br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行到 yield 点</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 保存当前栈帧和 PC</span><br>        <span class="hljs-comment">// 返回到调用者</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">resume</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 恢复栈帧和 PC</span><br>        <span class="hljs-comment">// 继续执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>虚拟线程的 unmount/mount 流程</strong></p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; Unmounted: 创建虚拟线程
    
    Unmounted --&gt; Mounted: mount()&lt;br/&gt;分配 Carrier Thread
    
    Mounted --&gt; Running: 开始执行
    
    Running --&gt; Unmounted: unmount()&lt;br/&gt;遇到阻塞操作
    
    Running --&gt; Pinned: 遇到 synchronized&lt;br/&gt;或 native 方法
    
    Pinned --&gt; Running: 阻塞操作完成&lt;br/&gt;(Carrier Thread 被阻塞)
    
    Unmounted --&gt; Mounted: IO 完成&lt;br/&gt;重新调度
    
    Running --&gt; [*]: 任务完成
    
    note right of Unmounted
        虚拟线程状态保存在堆中
        Continuation 保存栈帧
        不占用 Carrier Thread
    end note
    
    note right of Mounted
        虚拟线程在 Carrier Thread 上执行
        栈帧在 Carrier Thread 的栈上
    end note
    
    note right of Pinned
        无法 unmount
        Carrier Thread 被阻塞
        降级为平台线程行为
    end note</code></pre>
<p><strong>自动 unmount 的场景</strong></p>
<p>根据 JEP 444 和 JDK 源码，虚拟线程在以下场景会自动 unmount：</p>
<table>
<thead>
<tr>
<th>阻塞操作</th>
<th>是否 unmount</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>Thread.sleep()</code></strong></td>
<td>✅ 是</td>
<td>JDK 内部实现为 <code>Continuation.yield()</code></td>
</tr>
<tr>
<td><strong><code>Object.wait()</code></strong></td>
<td>✅ 是</td>
<td>不在 synchronized 块内时</td>
</tr>
<tr>
<td><strong><code>LockSupport.park()</code></strong></td>
<td>✅ 是</td>
<td>虚拟线程的标准阻塞原语</td>
</tr>
<tr>
<td><strong><code>BlockingQueue.take()</code></strong></td>
<td>✅ 是</td>
<td>内部使用 <code>LockSupport.park()</code></td>
</tr>
<tr>
<td><strong><code>Semaphore.acquire()</code></strong></td>
<td>✅ 是</td>
<td>内部使用 <code>LockSupport.park()</code></td>
</tr>
<tr>
<td><strong><code>ReentrantLock.lock()</code></strong></td>
<td>✅ 是</td>
<td>阻塞时使用 <code>LockSupport.park()</code></td>
</tr>
<tr>
<td><strong>Socket I/O</strong></td>
<td>✅ 是</td>
<td>JDK 改造为非阻塞实现</td>
</tr>
<tr>
<td><strong>File I/O</strong></td>
<td>✅ 是</td>
<td>JDK 改造为非阻塞实现</td>
</tr>
<tr>
<td><strong><code>synchronized</code> 块</strong></td>
<td>❌ 否</td>
<td><strong>Pinning 问题</strong></td>
</tr>
<tr>
<td><strong>JNI 调用</strong></td>
<td>❌ 否</td>
<td><strong>Pinning 问题</strong></td>
</tr>
<tr>
<td><strong>CPU 密集计算</strong></td>
<td>❌ 否</td>
<td>无阻塞点，无法 unmount</td>
</tr>
</tbody>
</table>
<p><strong>unmount 的实现原理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 虚拟线程阻塞时的简化流程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadBlocking</span> &#123;<br>    <br>    <span class="hljs-comment">// 当虚拟线程调用 Thread.sleep() 时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;<br>        <span class="hljs-comment">// 1. 检查当前线程是否是虚拟线程</span><br>        <span class="hljs-keyword">if</span> (Thread.currentThread().isVirtual()) &#123;<br>            <span class="hljs-comment">// 2. 调用 Continuation.yield()</span><br>            <span class="hljs-comment">//    - 保存当前栈帧到堆中</span><br>            <span class="hljs-comment">//    - 释放 Carrier Thread</span><br>            <span class="hljs-comment">//    - 注册唤醒回调（定时器）</span><br>            Continuation.<span class="hljs-keyword">yield</span>(SLEEP_SCOPE);<br>            <br>            <span class="hljs-comment">// 3. 当定时器触发时</span><br>            <span class="hljs-comment">//    - 虚拟线程被重新调度</span><br>            <span class="hljs-comment">//    - 分配新的 Carrier Thread</span><br>            <span class="hljs-comment">//    - 恢复栈帧，继续执行</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 平台线程：直接调用 OS sleep</span><br>            Thread0.sleep(millis);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>与 C 协程的差异：隐式 vs 显式调度</strong></p>
<p>这是一个关键的设计差异：</p>
<p><strong>C 协程（如 libco）</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C 协程支持显式 yield</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">coroutine_func</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Step 1\n&quot;</span>);<br>    co_yield();  <span class="hljs-comment">// 显式让出 CPU</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Step 2\n&quot;</span>);<br>    co_yield();  <span class="hljs-comment">// 再次显式让出</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Step 3\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Java 虚拟线程</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java 虚拟线程是隐式调度</span><br>Thread.ofVirtual().start(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Step 1&quot;</span>);<br>    <span class="hljs-comment">// 无法显式 yield！</span><br>    <span class="hljs-comment">// 只能通过阻塞操作触发 unmount</span><br>    Thread.sleep(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 隐式 yield</span><br>    System.out.println(<span class="hljs-string">&quot;Step 2&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>为什么 Java 选择隐式调度？</strong></p>
<ol>
<li><strong>向后兼容</strong>：现有的阻塞 API 无需修改即可工作</li>
<li><strong>简化编程</strong>：开发者无需关心调度细节</li>
<li><strong>安全性</strong>：避免程序员错误使用 yield 导致的问题</li>
<li><strong>性能</strong>：JVM 可以优化 unmount 时机</li>
</ol>
<p><strong>unmount 的性能开销</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// unmount 的成本分析</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnmountCost</span> &#123;<br>    <br>    <span class="hljs-comment">// 1. 保存栈帧到堆（几百纳秒）</span><br>    <span class="hljs-comment">//    - 拷贝栈帧数据</span><br>    <span class="hljs-comment">//    - 保存程序计数器</span><br>    <br>    <span class="hljs-comment">// 2. 释放 Carrier Thread（几十纳秒）</span><br>    <span class="hljs-comment">//    - 从 Carrier Thread 解绑</span><br>    <br>    <span class="hljs-comment">// 3. 重新调度（微秒级）</span><br>    <span class="hljs-comment">//    - 等待 IO 完成</span><br>    <span class="hljs-comment">//    - 分配新的 Carrier Thread</span><br>    <span class="hljs-comment">//    - 恢复栈帧</span><br>    <br>    <span class="hljs-comment">// 总开销：约 1-10 微秒</span><br>    <span class="hljs-comment">// 对比：平台线程上下文切换约 1-10 微秒</span><br>    <span class="hljs-comment">// 但虚拟线程的优势在于不阻塞 Carrier Thread</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>核心洞察</strong></p>
<ol>
<li>
<p><strong>Java 虚拟线程不是&quot;完全&quot;的协程</strong>：</p>
<ul>
<li>无法在任意点 yield</li>
<li>只能在特定的阻塞点 unmount</li>
<li>这是设计选择，不是技术限制</li>
</ul>
</li>
<li>
<p><strong>unmount 是自动的，不是手动的</strong>：</p>
<ul>
<li>JVM 检测到阻塞操作时自动触发</li>
<li>开发者无需（也无法）显式控制</li>
</ul>
</li>
<li>
<p><strong>Pinning 是虚拟线程的限制</strong>：</p>
<ul>
<li><code>synchronized</code> 和 JNI 调用无法 unmount</li>
<li>这是当前实现的限制，未来可能改进</li>
</ul>
</li>
<li>
<p><strong>虚拟线程的价值不在于&quot;任意点切换&quot;</strong>：</p>
<ul>
<li>而在于&quot;阻塞时不浪费 Carrier Thread&quot;</li>
<li>这对 IO 密集型应用已经足够</li>
</ul>
</li>
</ol>
<h3 id="关键概念">关键概念</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 虚拟线程核心概念示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadConcepts</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 创建虚拟线程的三种方式</span><br>        <br>        <span class="hljs-comment">// 方式一：Thread.ofVirtual()</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">vt1</span> <span class="hljs-operator">=</span> Thread.ofVirtual()<br>            .name(<span class="hljs-string">&quot;virtual-thread-1&quot;</span>)<br>            .start(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;Running on: &quot;</span> + Thread.currentThread());<br>                System.out.println(<span class="hljs-string">&quot;Is virtual: &quot;</span> + Thread.currentThread().isVirtual());<br>            &#125;);<br>        <br>        <span class="hljs-comment">// 方式二：Thread.startVirtualThread()</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">vt2</span> <span class="hljs-operator">=</span> Thread.startVirtualThread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Quick virtual thread&quot;</span>);<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 方式三：Executors.newVirtualThreadPerTaskExecutor()</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;Virtual thread from executor&quot;</span>);<br>            &#125;);<br>        &#125;<br>        <br>        vt1.join();<br>        vt2.join();<br>        <br>        <span class="hljs-comment">// 2. 虚拟线程的特性</span><br>        Thread.ofVirtual().start(() -&gt; &#123;<br>            <span class="hljs-comment">// 获取载体线程（仅用于调试）</span><br>            <span class="hljs-comment">// 注意：生产代码不应依赖载体线程</span><br>            System.out.println(<span class="hljs-string">&quot;Virtual thread running&quot;</span>);<br>            <br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 阻塞操作会触发卸载</span><br>                Thread.sleep(<span class="hljs-number">100</span>);<br>                <span class="hljs-comment">// sleep 期间，载体线程可以执行其他虚拟线程</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;).join();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="虚拟线程的使用原则">虚拟线程的使用原则</h2>
<h3 id="原则一：不要池化虚拟线程">原则一：不要池化虚拟线程</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 不要池化虚拟线程！</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">wrongPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">100</span>, <br>    Thread.ofVirtual().factory()); <span class="hljs-comment">// 错误：限制了虚拟线程数量</span><br><br><span class="hljs-comment">// [正确] 每个任务一个虚拟线程</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">correctPool</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor();<br><span class="hljs-comment">// 虚拟线程非常轻量，无需池化</span><br></code></pre></td></tr></table></figure>
<p><strong>为什么虚拟线程无需池化？</strong></p>
<p>传统线程池的设计目的是<strong>复用昂贵的操作系统线程资源</strong>。理解这一点是理解虚拟线程设计哲学的关键。</p>
<p><strong>平台线程的成本结构</strong>：</p>
<table>
<thead>
<tr>
<th>成本项</th>
<th>平台线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>创建成本</strong></td>
<td>~1ms（需要 OS 内核参与）</td>
<td>~1μs（纯 JVM 对象创建）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>固定 1MB 栈空间</td>
<td>初始几 KB，按需增长</td>
</tr>
<tr>
<td><strong>调度开销</strong></td>
<td>内核态切换（~1-10μs）</td>
<td>用户态切换（纳秒级）</td>
</tr>
<tr>
<td><strong>数量上限</strong></td>
<td>数千到数万（受内存限制）</td>
<td>数百万（受堆内存限制）</td>
</tr>
</tbody>
</table>
<p><strong>虚拟线程的&quot;用完即弃&quot;设计</strong>：</p>
<p>根据 JEP 444，虚拟线程被设计为 <strong>use-and-throw-away</strong>（用完即弃）资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 虚拟线程的创建成本接近普通对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">vt</span> <span class="hljs-operator">=</span> Thread.ofVirtual().start(() -&gt; &#123;<br>    <span class="hljs-comment">// 执行任务</span><br>&#125;);<br><span class="hljs-comment">// 任务完成后，虚拟线程被 GC 回收，无需复用</span><br></code></pre></td></tr></table></figure>
<p><strong>池化虚拟线程的问题</strong>：</p>
<ol>
<li><strong>违背设计初衷</strong>：虚拟线程本身就是为了避免池化的复杂性</li>
<li><strong>限制并发能力</strong>：池化会人为限制虚拟线程数量，失去其核心优势</li>
<li><strong>增加复杂性</strong>：需要管理池的生命周期、任务队列等</li>
<li><strong>状态清理开销</strong>：复用线程需要清理 ThreadLocal 等状态，反而增加开销</li>
</ol>
<p><strong>对比示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 平台线程：必须池化</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">platformPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">200</span>);<br><span class="hljs-comment">// 原因：创建 10000 个平台线程会耗尽内存（10GB+）</span><br><br><span class="hljs-comment">// 虚拟线程：无需池化</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">virtualPool</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    <span class="hljs-comment">// 可以轻松创建 10000 个虚拟线程（仅需 ~20MB）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>        virtualPool.submit(() -&gt; doWork());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>核心洞察</strong>：虚拟线程将&quot;线程&quot;从&quot;昂贵的需要复用的资源&quot;变成了&quot;廉价的可随意创建的对象&quot;。这是并发编程范式的根本转变。</p>
<h3 id="原则二：避免在虚拟线程中执行-cpu-密集型任务">原则二：避免在虚拟线程中执行 CPU 密集型任务</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] CPU密集型任务不适合虚拟线程</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    executor.submit(() -&gt; &#123;<br>        <span class="hljs-comment">// CPU密集型计算</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10_000_000_000L</span>; i++) &#123;<br>            result += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// [正确] CPU密集型任务使用平台线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<br>    Runtime.getRuntime().availableProcessors()<br>);<br>cpuPool.submit(() -&gt; &#123;<br>    <span class="hljs-comment">// CPU密集型计算</span><br>    <span class="hljs-keyword">return</span> heavyComputation();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>原因</strong>：虚拟线程的优势在于 IO 等待期间让出载体线程。CPU 密集型任务没有等待，无法发挥虚拟线程优势。</p>
<h3 id="原则三：注意-synchronized-和-native-方法的-pinning-问题">原则三：注意 synchronized 和 native 方法的 Pinning 问题</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [问题] synchronized 会导致虚拟线程 &quot;pinning&quot;（钉住载体线程）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PinningExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-comment">// [错误] synchronized 块内的阻塞操作会钉住载体线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">badMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 载体线程被钉住！</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// [正确] 使用 ReentrantLock 替代 synchronized</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodMethod</span><span class="hljs-params">()</span> &#123;<br>        reentrantLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 虚拟线程可以正常卸载</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            reentrantLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Pinning（钉住）</strong>：当虚拟线程执行 <code>synchronized</code> 块或 native 方法时，无法从载体线程卸载，导致载体线程被阻塞。</p>
<h3 id="原则四：正确使用-threadlocal">原则四：正确使用 ThreadLocal</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [注意] 虚拟线程与 ThreadLocal 的交互</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalWithVirtualThreads</span> &#123;<br>    <br>    <span class="hljs-comment">// 传统 ThreadLocal 在虚拟线程中仍然有效</span><br>    <span class="hljs-comment">// 但要注意：百万虚拟线程 × ThreadLocal 数据 = 巨大内存开销</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;ExpensiveObject&gt; threadLocal = <br>        ThreadLocal.withInitial(ExpensiveObject::<span class="hljs-keyword">new</span>);<br>    <br>    <span class="hljs-comment">// [推荐] 对于虚拟线程，考虑使用 ScopedValue (JDK 21 Preview)</span><br>    <span class="hljs-comment">// ScopedValue 是不可变的，更适合虚拟线程场景</span><br>    <span class="hljs-comment">// private static final ScopedValue&lt;String&gt; SCOPED_VALUE = ScopedValue.newInstance();</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 使用 ThreadLocal</span><br>        <span class="hljs-type">ExpensiveObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> threadLocal.get();<br>        <span class="hljs-comment">// ... 使用 obj</span><br>        <br>        <span class="hljs-comment">// [重要] 虚拟线程结束后，ThreadLocal 会被清理</span><br>        <span class="hljs-comment">// 但如果虚拟线程数量巨大，仍需注意内存</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="虚拟线程与传统线程池的选择">虚拟线程与传统线程池的选择</h2>
<h3 id="决策流程图">决策流程图</h3>
<pre><code class="hljs mermaid">flowchart TD
    A[新任务] --&gt; B&#123;任务类型?&#125;
    
    B --&gt;|IO密集型| C&#123;JDK版本?&#125;
    C --&gt;|JDK 21+| D[使用虚拟线程]
    C --&gt;|JDK 21以下| E[使用传统IO线程池]
    
    B --&gt;|CPU密集型| F[使用平台线程池]
    F --&gt; G[线程数 = CPU核心数]
    
    B --&gt;|混合型| H&#123;主要瓶颈?&#125;
    H --&gt;|IO等待| D
    H --&gt;|CPU计算| F
    
    D --&gt; I[newVirtualThreadPerTaskExecutor]
    E --&gt; J[newCachedThreadPool 或 自定义线程池]
    
    style D fill:#90EE90
    style F fill:#87CEEB
    style E fill:#FFE4B5</code></pre>
<h3 id="场景对比">场景对比</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Web 服务器处理 HTTP 请求</strong></td>
<td>虚拟线程</td>
<td>大量 IO 等待（数据库、外部 API）</td>
</tr>
<tr>
<td><strong>批量数据处理/ETL</strong></td>
<td>虚拟线程</td>
<td>文件 IO、网络传输</td>
</tr>
<tr>
<td><strong>图像/视频处理</strong></td>
<td>平台线程池</td>
<td>CPU 密集型计算</td>
</tr>
<tr>
<td><strong>科学计算/机器学习</strong></td>
<td>平台线程池 + ForkJoinPool</td>
<td>CPU 密集型，需要并行计算</td>
</tr>
<tr>
<td><strong>实时交易系统</strong></td>
<td>平台线程池</td>
<td>低延迟要求，避免 JVM 调度开销</td>
</tr>
<tr>
<td><strong>微服务间调用</strong></td>
<td>虚拟线程</td>
<td>大量网络 IO 等待</td>
</tr>
</tbody>
</table>
<h3 id="迁移示例">迁移示例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从传统线程池迁移到虚拟线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MigrationExample</span> &#123;<br><br>    <span class="hljs-comment">// ========== 迁移前：传统线程池 ==========</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">legacyPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>        <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()<br>    );<br>    <br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">fetchDataLegacy</span><span class="hljs-params">(String url)</span> &#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;<br>            <span class="hljs-comment">// 模拟 HTTP 调用</span><br>            <span class="hljs-keyword">return</span> httpClient.get(url);<br>        &#125;, legacyPool);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ========== 迁移后：虚拟线程 ==========</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">virtualPool</span> <span class="hljs-operator">=</span> <br>        Executors.newVirtualThreadPerTaskExecutor();<br>    <br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">fetchDataVirtual</span><span class="hljs-params">(String url)</span> &#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;<br>            <span class="hljs-comment">// 相同的业务逻辑，无需修改</span><br>            <span class="hljs-keyword">return</span> httpClient.get(url);<br>        &#125;, virtualPool);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ========== 混合模式：IO 用虚拟线程，CPU 用平台线程 ==========</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ioPool</span> <span class="hljs-operator">=</span> <br>        Executors.newVirtualThreadPerTaskExecutor();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuPool</span> <span class="hljs-operator">=</span> <br>        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br>    <br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;ProcessedData&gt; <span class="hljs-title function_">fetchAndProcess</span><span class="hljs-params">(String url)</span> &#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture<br>            .supplyAsync(() -&gt; httpClient.get(url), ioPool)      <span class="hljs-comment">// IO：虚拟线程</span><br>            .thenApplyAsync(data -&gt; heavyProcess(data), cpuPool); <span class="hljs-comment">// CPU：平台线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="虚拟线程的性能特征">虚拟线程的性能特征</h2>
<h3 id="吞吐量对比">吞吐量对比</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 虚拟线程 vs 平台线程性能对比示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PerformanceComparison</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TASK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">100_000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">IO_DELAY_MS</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 平台线程池（200线程）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">platformTime</span> <span class="hljs-operator">=</span> benchmarkPlatformThreads();<br>        System.out.println(<span class="hljs-string">&quot;Platform threads: &quot;</span> + platformTime + <span class="hljs-string">&quot; ms&quot;</span>);<br>        <br>        <span class="hljs-comment">// 虚拟线程</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">virtualTime</span> <span class="hljs-operator">=</span> benchmarkVirtualThreads();<br>        System.out.println(<span class="hljs-string">&quot;Virtual threads: &quot;</span> + virtualTime + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">benchmarkPlatformThreads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">200</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <br>        List&lt;Future&lt;?&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; TASK_COUNT; i++) &#123;<br>            futures.add(pool.submit(() -&gt; &#123;<br>                Thread.sleep(IO_DELAY_MS);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;));<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (Future&lt;?&gt; f : futures) f.get();<br>        pool.shutdown();<br>        <br>        <span class="hljs-keyword">return</span> System.currentTimeMillis() - start;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">benchmarkVirtualThreads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>            List&lt;Future&lt;?&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; TASK_COUNT; i++) &#123;<br>                futures.add(pool.submit(() -&gt; &#123;<br>                    Thread.sleep(IO_DELAY_MS);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;));<br>            &#125;<br>            <br>            <span class="hljs-keyword">for</span> (Future&lt;?&gt; f : futures) f.get();<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> System.currentTimeMillis() - start;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 典型结果（100,000 任务，50ms IO 延迟）：</span><br><span class="hljs-comment">// Platform threads (200): ~25,000 ms</span><br><span class="hljs-comment">// Virtual threads: ~100 ms</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 虚拟线程快 250 倍！</span><br><span class="hljs-comment">// 原因：平台线程受限于 200 个线程，需要排队</span><br><span class="hljs-comment">//       虚拟线程可以同时处理所有任务</span><br></code></pre></td></tr></table></figure>
<h3 id="内存占用对比">内存占用对比</h3>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>10,000 线程内存</th>
<th>100,000 线程内存</th>
<th>1,000,000 线程内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>平台线程</td>
<td>~10 GB</td>
<td>~100 GB（不可行）</td>
<td>不可能</td>
</tr>
<tr>
<td>虚拟线程</td>
<td>~20 MB</td>
<td>~200 MB</td>
<td>~2 GB</td>
</tr>
</tbody>
</table>
<h2 id="总结：线程池技术的演进">总结：线程池技术的演进</h2>
<pre><code class="hljs mermaid">timeline
    title Java 并发模型演进
    
    section JDK 1.0-1.4
        1996 : Thread 类
             : 手动管理线程
    
    section JDK 5
        2004 : ExecutorService
             : ThreadPoolExecutor
             : 线程池标准化
    
    section JDK 7
        2011 : ForkJoinPool
             : 工作窃取算法
             : 分治并行
    
    section JDK 8
        2014 : CompletableFuture
             : 异步编程
             : 链式组合
    
    section JDK 21
        2023 : Virtual Threads
             : 百万级并发
             : 简化异步编程</code></pre>
<h3 id="技术选型总结">技术选型总结</h3>
<table>
<thead>
<tr>
<th>技术</th>
<th>适用场景</th>
<th>核心优势</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ThreadPoolExecutor</strong></td>
<td>通用任务执行</td>
<td>成熟稳定，参数可控</td>
<td>需要调优线程池参数</td>
</tr>
<tr>
<td><strong>ForkJoinPool</strong></td>
<td>分治/递归任务</td>
<td>工作窃取，高效并行</td>
<td>任务需可分解</td>
</tr>
<tr>
<td><strong>CompletableFuture</strong></td>
<td>异步编排</td>
<td>链式组合，声明式</td>
<td>注意线程池选择</td>
</tr>
<tr>
<td><strong>Virtual Threads</strong></td>
<td>IO 密集型高并发</td>
<td>轻量级，简化编程</td>
<td>JDK 21+，避免 Pinning</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>核心洞察</strong>：虚拟线程不是要取代线程池，而是为 IO 密集型场景提供更简单、更高效的解决方案。在 CPU 密集型场景，传统线程池仍然是最佳选择。理解每种技术的适用场景，才能做出正确的架构决策。</p>
</blockquote>
<hr>
<h2 id="结构化并发-structured-concurrency">结构化并发 (Structured Concurrency)</h2>
<h3 id="1-历史背景">1. 历史背景</h3>
<h4 id="概念起源">概念起源</h4>
<p><strong>结构化并发</strong> (Structured Concurrency) 这个概念最早由 <strong>Martin Sústrik</strong> 在 <strong>2016年</strong> 提出。Martin Sústrik 是 ZeroMQ 的创始人,他在其博客文章 <a target="_blank" rel="noopener" href="https://www.250bpm.com/p/structured-concurrency">Structured Concurrency</a> 中首次系统阐述了这一理念。</p>
<pre><code class="hljs mermaid">timeline
    title 结构化并发发展历程
    
    section 概念萌芽
        2016 : Martin Sústrik 提出结构化并发概念
              : 在 250bpm.com 发表系列文章
    section 理论发展
        2018 : Nathaniel J. Smith 撰写 &quot;Notes on structured concurrency&quot;
              : 深入分析 go 语句的危害
        2018 : Python Trio 库发布
              : 首个完整实现结构化并发的库
    section 语言采纳
        2018 : Kotlin 1.3 引入协程
              : 内置结构化并发支持
        2022 : Java 19 引入结构化并发 (JEP 428)
              : 作为孵化器 API</code></pre>
<h4 id="与结构化编程的关系：类比而非继承">与结构化编程的关系：类比而非继承</h4>
<p><strong>需要澄清的是</strong>：结构化并发并非&quot;来自于&quot;或&quot;继承自&quot;结构化编程，而是<strong>借鉴了结构化编程的思想</strong>，通过类比的方式将相似的原则应用于并发控制流。</p>
<p>Nathaniel J. Smith 在其 2018 年的文章中指出：</p>
<blockquote>
<p>“The popular concurrency primitives – go statements, thread spawning functions, callbacks, futures, promises, … they’re all variants on goto, in theory and in practice.”</p>
</blockquote>
<p>这个类比的核心是：<code>go</code> 语句（启动后台任务）之于并发编程，如同 <code>goto</code> 语句之于顺序编程——两者都破坏了程序的结构化控制流。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>结构化编程（1968）</th>
<th>结构化并发（2016）</th>
<th>关系</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>问题根源</strong></td>
<td><code>goto</code> 破坏顺序控制流</td>
<td><code>go</code> 破坏并发控制流</td>
<td>类比</td>
</tr>
<tr>
<td><strong>核心原则</strong></td>
<td>代码块有清晰的入口和出口</td>
<td>并发任务有清晰的生命周期边界</td>
<td>类比</td>
</tr>
<tr>
<td><strong>解决方案</strong></td>
<td>if/while/函数调用</td>
<td>Nursery/StructuredTaskScope</td>
<td>类比</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>异常沿调用栈向上传播</td>
<td>异常沿任务树向上传播</td>
<td>类比</td>
</tr>
<tr>
<td><strong>资源管理</strong></td>
<td>代码块结束时自动清理资源</td>
<td>作用域结束时自动清理任务</td>
<td>类比</td>
</tr>
</tbody>
</table>
<p><strong>关键区别</strong>：结构化编程是对顺序控制流的规范，结构化并发是对并发控制流的规范。两者解决的是不同领域的问题，但采用了相似的思路</p>
<h4 id="传统并发编程的问题">传统并发编程的问题</h4>
<p>传统并发模型 (如 <code>ExecutorService</code>) 存在以下核心问题:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题 1: 线程泄漏 - 任务的生命周期不清晰</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLeakExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processRequest</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 启动后台任务,但没有管理它的生命周期</span><br>        executor.submit(() -&gt; &#123;<br>            <span class="hljs-comment">// 如果这个任务永远不会结束,就会造成线程泄漏</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                doSomething();<br>            &#125;<br>        &#125;);<br>        <span class="hljs-comment">// 方法返回了,但后台任务仍在运行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题 2: 错误处理困难 - 异常容易被遗忘</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ErrorHandlingProblem</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parallelProcess</span><span class="hljs-params">()</span> &#123;<br>        Future&lt;String&gt; future1 = executor.submit(() -&gt; task1());<br>        Future&lt;String&gt; future2 = executor.submit(() -&gt; task2());<br>        <br>        <span class="hljs-comment">// 如果 task1 抛出异常,我们可能忘记处理</span><br>        <span class="hljs-comment">// 如果忘记调用 future.get(),异常就会被忽略</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">result1</span> <span class="hljs-operator">=</span> future1.get();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">result2</span> <span class="hljs-operator">=</span> future2.get();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// 错误处理变得复杂</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 问题 3: 取消传播困难</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CancellationProblem</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWithTimeout</span><span class="hljs-params">()</span> &#123;<br>        Future&lt;String&gt; future1 = executor.submit(() -&gt; &#123;<br>            <span class="hljs-comment">// 启动嵌套任务</span><br>            Future&lt;String&gt; nested = executor.submit(() -&gt; nestedTask());<br>            <span class="hljs-comment">// 如果外部任务被取消,嵌套任务不会自动取消</span><br>            <span class="hljs-keyword">return</span> nested.get();<br>        &#125;);<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            future1.get(<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>            future1.cancel(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 取消外部任务</span><br>            <span class="hljs-comment">// 但嵌套任务仍在运行!</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="2-理论基础">2. 理论基础</h3>
<h4 id="核心思想">核心思想</h4>
<p>结构化并发的核心原则是:</p>
<blockquote>
<p><strong>&quot;如果一个任务分解为并发子任务,那么这些子任务都应该返回到同一个地方,即任务的代码块。&quot;</strong></p>
</blockquote>
<p><strong>关键特性</strong>:</p>
<ol>
<li><strong>生命周期绑定</strong>: 子任务的生命周期不能超过父任务</li>
<li><strong>错误传播</strong>: 子任务的异常会自动传播到父任务</li>
<li><strong>取消传播</strong>: 父任务取消时,所有子任务自动取消</li>
<li><strong>作用域清晰</strong>: 并发任务的作用域通过代码块明确定义</li>
</ol>
<pre><code class="hljs mermaid">graph TD
    A[Main Task] --&gt; B[Subtask 1]
    A --&gt; C[Subtask 2]
    A --&gt; D[Subtask 3]
    
    B --&gt; B1[Sub-subtask 1.1]
    B --&gt; B2[Sub-subtask 1.2]
    
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#fff4e1
    style D fill:#fff4e1
    style B1 fill:#ffe1e1
    style B2 fill:#ffe1e1
    
    A -.-&gt;|生命周期| B
    A -.-&gt;|生命周期| C
    A -.-&gt;|生命周期| D
    B -.-&gt;|生命周期| B1
    B -.-&gt;|生命周期| B2</code></pre>
<h4 id="与-go-语言-goroutine-的对比">与 Go 语言 goroutine 的对比</h4>
<p>Go 语言的 goroutine 模型是结构化并发的重要参考,但 Go 本身<strong>不强制结构化</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Go: 非结构化并发 (fire-and-forget)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 这个 goroutine 的生命周期不清晰</span><br>        doWork()<br>    &#125;()<br>    <span class="hljs-comment">// 函数返回,goroutine 继续运行</span><br>&#125;<br><br><span class="hljs-comment">// Go: 使用 errgroup 实现结构化并发</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleStructured</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>    g, ctx := errgroup.WithContext(context.Background())<br>    <br>    g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>        <span class="hljs-keyword">return</span> task1()<br>    &#125;)<br>    <br>    g.Go(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-type">error</span> &#123;<br>        <span class="hljs-keyword">return</span> task2()<br>    &#125;)<br>    <br>    <span class="hljs-comment">// 等待所有任务完成</span><br>    <span class="hljs-keyword">return</span> g.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>特性</th>
<th>Go goroutine</th>
<th>Java Structured Concurrency</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>强制结构化</strong></td>
<td>❌ 需要手动管理</td>
<td>✅ 语言级别强制</td>
</tr>
<tr>
<td><strong>取消传播</strong></td>
<td>⚠️ 需要 context</td>
<td>✅ 自动传播</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>⚠️ 需要手动收集</td>
<td>✅ 自动传播</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>⚠️ 不明确</td>
<td>✅ 明确的作用域</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>⚠️ 需要额外工具</td>
<td>✅ 内置线程 dump</td>
</tr>
</tbody>
</table>
<h4 id="与-kotlin-coroutines-的对比">与 Kotlin Coroutines 的对比</h4>
<p>Kotlin 协程是<strong>原生支持结构化并发</strong>的代表:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Kotlin: 结构化并发</span><br><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">handle</span><span class="hljs-params">()</span></span> = coroutineScope &#123;<br>    <span class="hljs-comment">// 自动创建结构化作用域</span><br>    <span class="hljs-keyword">val</span> deferred1 = async &#123; task1() &#125;<br>    <span class="hljs-keyword">val</span> deferred2 = async &#123; task2() &#125;<br>    <br>    <span class="hljs-comment">// 等待所有子任务完成</span><br>    <span class="hljs-keyword">val</span> result1 = deferred1.await()<br>    <span class="hljs-keyword">val</span> result2 = deferred2.await()<br>    <br>    <span class="hljs-comment">// 如果任何一个任务失败,整个作用域会取消</span><br>    <span class="hljs-comment">// 如果 coroutineScope 被取消,所有子任务自动取消</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>对比表格</strong>:</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Kotlin Coroutines</th>
<th>Java Structured Concurrency</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>语法集成</strong></td>
<td>✅ 语言级别关键字</td>
<td>✅ API + try-with-resources</td>
</tr>
<tr>
<td><strong>挂起函数</strong></td>
<td>✅ <code>suspend</code> 关键字</td>
<td>⚠️ 需要手动设计</td>
</tr>
<tr>
<td><strong>虚拟线程</strong></td>
<td>❌ 使用线程池</td>
<td>✅ 原生虚拟线程</td>
</tr>
<tr>
<td><strong>作用域类型</strong></td>
<td><code>coroutineScope</code>, <code>supervisorScope</code></td>
<td><code>StructuredTaskScope</code></td>
</tr>
<tr>
<td><strong>错误处理策略</strong></td>
<td>灵活 (supervisorScope)</td>
<td>灵活 (自定义策略)</td>
</tr>
</tbody>
</table>
<h4 id="与-python-trio-库的关系">与 Python Trio 库的关系</h4>
<p><strong>Python Trio</strong> 是 Nathaniel J. Smith 创建的库,它是<strong>结构化并发理念的坚定实践者</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Python Trio: 结构化并发</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">def</span> <span class="hljs-title function_">handle</span>():<br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> trio.open_nursery() <span class="hljs-keyword">as</span> nursery:<br>        <span class="hljs-comment"># nursery 确保所有任务在退出前完成</span><br>        nursery.start_soon(task1)<br>        nursery.start_soon(task2)<br>        <br>        <span class="hljs-comment"># 如果任何任务失败,nursery 会取消其他任务</span><br>        <span class="hljs-comment"># 如果 nursery 被取消,所有任务自动取消</span><br></code></pre></td></tr></table></figure>
<p><strong>Trio 的核心贡献</strong>:</p>
<ol>
<li><strong>Nursery 模式</strong>: 明确的子任务作用域</li>
<li><strong>取消传播</strong>: 自动化的取消机制</li>
<li><strong>错误处理</strong>: 异常自动传播到父任务</li>
<li><strong>资源管理</strong>: 使用 <code>async with</code> 确保清理</li>
</ol>
<p><strong>Java 结构化并发直接借鉴了 Trio 的设计理念</strong>:</p>
<table>
<thead>
<tr>
<th>Trio 概念</th>
<th>Java 对应</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>nursery</code></td>
<td><code>StructuredTaskScope</code></td>
</tr>
<tr>
<td><code>nursery.start_soon()</code></td>
<td><code>scope.fork()</code></td>
</tr>
<tr>
<td><code>async with nursery</code></td>
<td><code>try (var scope = ...)</code></td>
</tr>
<tr>
<td>自动取消</td>
<td><code>shutdown()</code> 方法</td>
</tr>
</tbody>
</table>
<h3 id="3-java-中的演进">3. Java 中的演进</h3>
<h4 id="jep-428-structured-concurrency-incubator-jdk-19">JEP 428: Structured Concurrency (Incubator) - JDK 19</h4>
<p><strong>发布时间</strong>: 2022年9月</p>
<p><strong>目标</strong>: 引入结构化并发 API 作为孵化器特性</p>
<p><strong>核心特性</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 19: 首次引入结构化并发</span><br><span class="hljs-keyword">import</span> jdk.incubator.concurrent.StructuredTaskScope;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FirstStructuredConcurrency</span> &#123;<br>    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;String&gt;()) &#123;<br>            <span class="hljs-comment">// fork 子任务</span><br>            StructuredTaskScope.Subtask&lt;String&gt; userTask = <br>                scope.fork(() -&gt; findUser());<br>            StructuredTaskScope.Subtask&lt;Integer&gt; orderTask = <br>                scope.fork(() -&gt; fetchOrder());<br>            <br>            <span class="hljs-comment">// 等待所有任务完成</span><br>            scope.join();<br>            <br>            <span class="hljs-comment">// 处理结果</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<br>                userTask.get(), <br>                orderTask.get()<br>            );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键 API</strong>:</p>
<ul>
<li><code>StructuredTaskScope</code>: 核心作用域类</li>
<li><code>fork(Callable)</code>: 启动子任务</li>
<li><code>join()</code>: 等待所有子任务完成</li>
<li><code>shutdown()</code>: 取消所有子任务</li>
<li><code>close()</code>: 关闭作用域</li>
</ul>
<p><strong>限制</strong>:</p>
<ul>
<li>位于 <code>jdk.incubator.concurrent</code> 模块</li>
<li>需要使用 <code>--add-modules jdk.incubator.concurrent</code></li>
<li>返回 <code>Future</code> 而非专门的 <code>Subtask</code></li>
</ul>
<h4 id="jep-437-structured-concurrency-second-incubator-jdk-20">JEP 437: Structured Concurrency (Second Incubator) - JDK 20</h4>
<p><strong>发布时间</strong>: 2023年3月</p>
<p><strong>主要变化</strong>:</p>
<ol>
<li><strong>API 改进</strong>: 优化了 <code>fork()</code> 方法的返回值</li>
<li><strong>错误处理</strong>: 改进了异常处理机制</li>
<li><strong>文档完善</strong>: 增加了更多示例和最佳实践</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 20: API 改进</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ImprovedStructuredConcurrency</span> &#123;<br>    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">handle</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>            <span class="hljs-comment">// 使用 ShutdownOnFailure 策略</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">userTask</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; findUser());<br>            <span class="hljs-type">var</span> <span class="hljs-variable">orderTask</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchOrder());<br>            <br>            scope.join()<br>                  .throwIfFailed();  <span class="hljs-comment">// 如果任何任务失败,抛出异常</span><br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<br>                userTask.get(), <br>                orderTask.get()<br>            );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="jep-453-structured-concurrency-preview-jdk-21">JEP 453: Structured Concurrency (Preview) - JDK 21</h4>
<p><strong>发布时间</strong>: 2023年9月 (LTS 版本)</p>
<p><strong>重大变化</strong>:</p>
<ol>
<li><strong>从孵化器转为预览特性</strong>: 移至标准库 <code>java.util.concurrent</code></li>
<li><strong>API 重构</strong>:
<ul>
<li><code>fork()</code> 返回 <code>Subtask</code> 而非 <code>Future</code></li>
<li>移除 <code>Future.resultNow()</code> 和 <code>Future.exceptionNow()</code></li>
<li>引入 <code>Subtask</code> 接口</li>
</ul>
</li>
<li><strong>新增策略类</strong>:
<ul>
<li><code>ShutdownOnFailure</code>: 任一任务失败时取消其他任务</li>
<li><code>ShutdownOnSuccess</code>: 任一任务成功时取消其他任务</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 21: Preview 特性</span><br><span class="hljs-keyword">import</span> java.util.concurrent.StructuredTaskScope;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PreviewStructuredConcurrency</span> &#123;<br>    <span class="hljs-comment">// ShutdownOnFailure: 所有任务必须成功</span><br>    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">handleAllOrNothing</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>            <span class="hljs-type">var</span> <span class="hljs-variable">userTask</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; findUser());<br>            <span class="hljs-type">var</span> <span class="hljs-variable">orderTask</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchOrder());<br>            <br>            scope.join()<br>                  .throwIfFailed();<br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(<br>                userTask.get(), <br>                orderTask.get()<br>            );<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ShutdownOnSuccess: 只需要一个任务成功</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">handleFirstSuccess</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnSuccess&lt;String&gt;()) &#123;<br>            scope.fork(() -&gt; fetchFromPrimaryDB());<br>            scope.fork(() -&gt; fetchFromSecondaryDB());<br>            scope.fork(() -&gt; fetchFromCache());<br>            <br>            scope.join();<br>            <span class="hljs-keyword">return</span> scope.result();  <span class="hljs-comment">// 返回第一个成功的结果</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Subtask 接口</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">sealed</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Subtask</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Supplier</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123; SUCCESS, FAILED, UNAVAILABLE &#125;<br>    <br>    State <span class="hljs-title function_">state</span><span class="hljs-params">()</span>;           <span class="hljs-comment">// 任务状态</span><br>    Callable&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; task();  <span class="hljs-comment">// 原始任务</span><br>    T <span class="hljs-title function_">get</span><span class="hljs-params">()</span>;                 <span class="hljs-comment">// 获取结果 (仅在 SUCCESS 状态可用)</span><br>    Throwable <span class="hljs-title function_">exception</span><span class="hljs-params">()</span>;   <span class="hljs-comment">// 获取异常 (仅在 FAILED 状态可用)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="jep-462-structured-concurrency-second-preview-jdk-22">JEP 462: Structured Concurrency (Second Preview) - JDK 22</h4>
<p><strong>发布时间</strong>: 2024年3月</p>
<p><strong>主要改进</strong>:</p>
<ol>
<li><strong>API 细化</strong>: 基于社区反馈优化</li>
<li><strong>性能优化</strong>: 改进虚拟线程调度</li>
<li><strong>文档增强</strong>: 更详细的 API 文档</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 22: Second Preview</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SecondPreviewExample</span> &#123;<br>    <span class="hljs-comment">// 改进的自定义策略</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectingScope</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;T&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleComplete</span><span class="hljs-params">(Subtask&lt;? extends T&gt; subtask)</span> &#123;<br>            <span class="hljs-keyword">if</span> (subtask.state() == Subtask.State.SUCCESS) &#123;<br>                results.add(subtask.get());<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> Stream&lt;T&gt; <span class="hljs-title function_">results</span><span class="hljs-params">()</span> &#123;<br>            ensureOwnerAndJoined();<br>            <span class="hljs-keyword">return</span> results.stream();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title function_">handleAllSuccessful</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CollectingScope</span>&lt;String&gt;()) &#123;<br>            scope.fork(() -&gt; fetchFromSource1());<br>            scope.fork(() -&gt; fetchFromSource2());<br>            scope.fork(() -&gt; fetchFromSource3());<br>            <br>            scope.join();<br>            <span class="hljs-keyword">return</span> scope.results().toList();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="版本演进对比">版本演进对比</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>JDK 19 (JEP 428)</th>
<th>JDK 20 (JEP 437)</th>
<th>JDK 21 (JEP 453)</th>
<th>JDK 22 (JEP 462)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>模块</strong></td>
<td><code>jdk.incubator.concurrent</code></td>
<td><code>jdk.incubator.concurrent</code></td>
<td><code>java.util.concurrent</code></td>
<td><code>java.util.concurrent</code></td>
</tr>
<tr>
<td><strong>状态</strong></td>
<td>Incubator</td>
<td>Second Incubator</td>
<td>Preview</td>
<td>Second Preview</td>
</tr>
<tr>
<td><strong>fork() 返回</strong></td>
<td><code>Future</code></td>
<td><code>Future</code></td>
<td><code>Subtask</code></td>
<td><code>Subtask</code></td>
</tr>
<tr>
<td><strong>ShutdownOnFailure</strong></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><strong>ShutdownOnSuccess</strong></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><strong>自定义策略</strong></td>
<td>⚠️ 有限</td>
<td>⚠️ 有限</td>
<td>✅ 完善</td>
<td>✅ 完善</td>
</tr>
<tr>
<td><strong>虚拟线程集成</strong></td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
<td>✅</td>
</tr>
<tr>
<td><strong>ScopedValue 集成</strong></td>
<td>❌</td>
<td>❌</td>
<td>✅</td>
<td>✅</td>
</tr>
</tbody>
</table>
<h3 id="4-核心-api">4. 核心 API</h3>
<h4 id="structuredtaskscope-设计">StructuredTaskScope 设计</h4>
<p><strong>类层次结构</strong>:</p>
<pre><code class="hljs mermaid">classDiagram
    class AutoCloseable &#123;
        &lt;&lt;interface&gt;&gt;
        +close() void
    &#125;
    
    class StructuredTaskScope~T~ &#123;
        -ThreadFactory factory
        -List~Subtask~? extends T~~ forks
        -boolean shutdown
        &lt;&lt;abstract&gt;&gt;
        +fork(Callable) Subtask
        +shutdown() void
        +join() StructuredTaskScope
        +joinUntil(Instant) StructuredTaskScope
        +close() void
        #handleComplete(Subtask) void*
        #ensureOwnerAndJoined() void
    &#125;
    
    class ShutdownOnFailure &#123;
        +join() ShutdownOnFailure
        +throwIfFailed() void
        +throwIfFailed(Function) void
        +exception() Throwable
    &#125;
    
    class ShutdownOnSuccess~T~ &#123;
        +join() ShutdownOnSuccess
        +result() T
        +resultOrElse(Supplier) T
    &#125;
    
    AutoCloseable &lt;|-- StructuredTaskScope
    StructuredTaskScope &lt;|-- ShutdownOnFailure
    StructuredTaskScope &lt;|-- ShutdownOnSuccess</code></pre>
<p><strong>核心方法详解</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Fork 一个子任务</span><br><span class="hljs-comment">     * - 创建新的虚拟线程执行任务</span><br><span class="hljs-comment">     * - 返回 Subtask 对象用于获取结果</span><br><span class="hljs-comment">     * - 可以从 owner 或其他子任务调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;U <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; Subtask&lt;U&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">(Callable&lt;? extends U&gt; task)</span> &#123;<br>        <span class="hljs-comment">// 实现细节:</span><br>        <span class="hljs-comment">// 1. 检查调用者是否在作用域树中</span><br>        <span class="hljs-comment">// 2. 如果已 shutdown,返回 UNAVAILABLE 状态的 Subtask</span><br>        <span class="hljs-comment">// 3. 创建虚拟线程执行任务</span><br>        <span class="hljs-comment">// 4. 返回 Subtask 对象</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭作用域,取消所有未完成的子任务</span><br><span class="hljs-comment">     * - 中断所有运行中的子任务</span><br><span class="hljs-comment">     * - 阻止新的 fork 操作</span><br><span class="hljs-comment">     * - 类似于并发代码中的 break 语句</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 实现细节:</span><br>        <span class="hljs-comment">// 1. 设置 shutdown 标志</span><br>        <span class="hljs-comment">// 2. 中断所有运行中的子任务</span><br>        <span class="hljs-comment">// 3. 唤醒等待的 join()</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 等待所有子任务完成</span><br><span class="hljs-comment">     * - 阻塞直到所有子任务完成或被取消</span><br><span class="hljs-comment">     * - 如果 owner 被中断,会自动 shutdown</span><br><span class="hljs-comment">     * - 必须在 close() 前调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> StructuredTaskScope&lt;T&gt; <span class="hljs-title function_">join</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 实现细节:</span><br>        <span class="hljs-comment">// 1. 等待所有 fork 的子任务完成</span><br>        <span class="hljs-comment">// 2. 如果 owner 被中断,自动调用 shutdown()</span><br>        <span class="hljs-comment">// 3. 返回 this 以支持链式调用</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 支持超时的 join</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> StructuredTaskScope&lt;T&gt; <span class="hljs-title function_">joinUntil</span><span class="hljs-params">(Instant deadline)</span> <br>        <span class="hljs-keyword">throws</span> InterruptedException, TimeoutException &#123;<br>        <span class="hljs-comment">// 实现细节:</span><br>        <span class="hljs-comment">// 1. 等待直到 deadline 或所有任务完成</span><br>        <span class="hljs-comment">// 2. 超时后抛出 TimeoutException</span><br>        <span class="hljs-comment">// 3. try-with-resources 会自动 shutdown</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 关闭作用域</span><br><span class="hljs-comment">     * - 如果未 shutdown,自动 shutdown</span><br><span class="hljs-comment">     * - 等待所有子任务终止</span><br><span class="hljs-comment">     * - 由 try-with-resources 自动调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 实现细节:</span><br>        <span class="hljs-comment">// 1. 如果未调用 join(),会等待所有任务完成</span><br>        <span class="hljs-comment">// 2. 如果未 shutdown,自动 shutdown</span><br>        <span class="hljs-comment">// 3. 等待所有子任务终止</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 子任务完成时的回调</span><br><span class="hljs-comment">     * 由子类重写以实现自定义策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleComplete</span><span class="hljs-params">(Subtask&lt;? extends T&gt; subtask)</span> &#123;<br>        <span class="hljs-comment">// 默认实现: 什么都不做</span><br>        <span class="hljs-comment">// 子类可以重写以收集结果或触发 shutdown</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="shutdownonfailure-策略">ShutdownOnFailure 策略</h4>
<p><strong>语义</strong>: “所有任务必须成功,否则全部取消”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShutdownOnFailure</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;Object&gt; &#123;<br>    <span class="hljs-keyword">private</span> Throwable firstException;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当子任务完成时调用</span><br><span class="hljs-comment">     * - 如果任务失败,记录第一个异常并 shutdown</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleComplete</span><span class="hljs-params">(Subtask&lt;?&gt; subtask)</span> &#123;<br>        <span class="hljs-keyword">if</span> (subtask.state() == Subtask.State.FAILED &amp;&amp; firstException == <span class="hljs-literal">null</span>) &#123;<br>            firstException = subtask.exception();<br>            shutdown();  <span class="hljs-comment">// 取消其他任务</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果有任务失败,抛出异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ShutdownOnFailure <span class="hljs-title function_">throwIfFailed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>        <span class="hljs-keyword">if</span> (firstException != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>(firstException);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义异常转换</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;X <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Throwable</span>&gt; ShutdownOnFailure <span class="hljs-title function_">throwIfFailed</span><span class="hljs-params">(</span><br><span class="hljs-params">        Function&lt;Throwable, X&gt; exceptionMapper</span><br><span class="hljs-params">    )</span> <span class="hljs-keyword">throws</span> X &#123;<br>        <span class="hljs-keyword">if</span> (firstException != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> exceptionMapper.apply(firstException);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取第一个异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Throwable <span class="hljs-title function_">exception</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> firstException;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>使用示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 场景: 聚合多个数据源,全部成功才能继续</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AggregationService</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> UserProfile <span class="hljs-title function_">getUserProfile</span><span class="hljs-params">(String userId)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>            <span class="hljs-comment">// 并行获取多个数据源</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">basicInfo</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchBasicInfo(userId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">preferences</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchPreferences(userId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchActivity(userId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">social</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchSocialData(userId));<br>            <br>            <span class="hljs-comment">// 等待所有任务完成</span><br>            scope.join()<br>                  .throwIfFailed();<br>            <br>            <span class="hljs-comment">// 所有任务都成功了,聚合结果</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserProfile</span>(<br>                basicInfo.get(),<br>                preferences.get(),<br>                activity.get(),<br>                social.get()<br>            );<br>        &#125;<br>        <span class="hljs-comment">// 作用域关闭,所有子任务都已终止</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> BasicInfo <span class="hljs-title function_">fetchBasicInfo</span><span class="hljs-params">(String userId)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 可能失败</span><br>        <span class="hljs-keyword">return</span> httpClient.get(<span class="hljs-string">&quot;/users/&quot;</span> + userId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="shutdownonsuccess-策略">ShutdownOnSuccess 策略</h4>
<p><strong>语义</strong>: “只需要一个任务成功”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShutdownOnSuccess</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> T firstResult;<br>    <span class="hljs-keyword">private</span> Subtask&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; firstSuccess;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当子任务成功完成时,记录结果并 shutdown</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleComplete</span><span class="hljs-params">(Subtask&lt;? extends T&gt; subtask)</span> &#123;<br>        <span class="hljs-keyword">if</span> (subtask.state() == Subtask.State.SUCCESS &amp;&amp; firstResult == <span class="hljs-literal">null</span>) &#123;<br>            firstSuccess = subtask;<br>            firstResult = subtask.get();<br>            shutdown();  <span class="hljs-comment">// 取消其他任务</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取第一个成功的结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">result</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>        <span class="hljs-keyword">if</span> (firstResult != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> firstResult;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>(<span class="hljs-string">&quot;No subtask completed successfully&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果没有成功结果,返回默认值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">resultOrElse</span><span class="hljs-params">(Supplier&lt;? extends T&gt; supplier)</span> &#123;<br>        <span class="hljs-keyword">return</span> firstResult != <span class="hljs-literal">null</span> ? firstResult : supplier.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>使用示例</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 场景: 从多个备份源获取数据,只要一个成功即可</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedundancyService</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> Data <span class="hljs-title function_">fetchWithRedundancy</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnSuccess&lt;Data&gt;()) &#123;<br>            <span class="hljs-comment">// 尝试多个数据源</span><br>            scope.fork(() -&gt; fetchFromPrimary(key));<br>            scope.fork(() -&gt; fetchFromSecondary(key));<br>            scope.fork(() -&gt; fetchFromCache(key));<br>            scope.fork(() -&gt; fetchFromCDN(key));<br>            <br>            <span class="hljs-comment">// 等待第一个成功</span><br>            scope.join();<br>            <span class="hljs-keyword">return</span> scope.result();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Data <span class="hljs-title function_">fetchFromPrimary</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 主数据库</span><br>        <span class="hljs-keyword">return</span> db.query(key);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Data <span class="hljs-title function_">fetchFromSecondary</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 备份数据库</span><br>        <span class="hljs-keyword">return</span> backupDb.query(key);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Data <span class="hljs-title function_">fetchFromCache</span><span class="hljs-params">(String key)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// Redis 缓存</span><br>        <span class="hljs-keyword">return</span> redis.get(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="与虚拟线程的协同">与虚拟线程的协同</h4>
<p><strong>虚拟线程是结构化并发的基础设施</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadIntegration</span> &#123;<br>    <br>    <span class="hljs-comment">// 1. 默认使用虚拟线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">defaultVirtualThread</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>            <span class="hljs-comment">// fork 默认使用虚拟线程</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; blockingIO1());<br>            <span class="hljs-type">var</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; blockingIO2());<br>            <br>            scope.join().throwIfFailed();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 2. 自定义线程工厂</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customThreadFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 使用平台线程</span><br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">platformFactory</span> <span class="hljs-operator">=</span> Thread.ofPlatform().factory();<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;Object&gt;(<span class="hljs-literal">null</span>, platformFactory)) &#123;<br>            <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; cpuIntensiveTask());<br>            scope.join();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 使用自定义虚拟线程名称</span><br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">namedVirtualFactory</span> <span class="hljs-operator">=</span> Thread.ofVirtual()<br>            .name(<span class="hljs-string">&quot;worker-&quot;</span>, <span class="hljs-number">0</span>)<br>            .factory();<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;Object&gt;(<span class="hljs-literal">null</span>, namedVirtualFactory)) &#123;<br>            <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; ioTask());<br>            scope.join();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 3. 嵌套作用域</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nestedScopes</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">outerScope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>            <span class="hljs-type">var</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> outerScope.fork(() -&gt; &#123;<br>                <span class="hljs-comment">// 在子任务中创建嵌套作用域</span><br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">innerScope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>                    <span class="hljs-type">var</span> <span class="hljs-variable">subTask1</span> <span class="hljs-operator">=</span> innerScope.fork(() -&gt; subTask1());<br>                    <span class="hljs-type">var</span> <span class="hljs-variable">subTask2</span> <span class="hljs-operator">=</span> innerScope.fork(() -&gt; subTask2());<br>                    <br>                    innerScope.join().throwIfFailed();<br>                    <span class="hljs-keyword">return</span> combineResults(subTask1.get(), subTask2.get());<br>                &#125;<br>            &#125;);<br>            <br>            <span class="hljs-type">var</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> outerScope.fork(() -&gt; anotherTask());<br>            <br>            outerScope.join().throwIfFailed();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 4. 与 ScopedValue 集成</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScopedValue&lt;String&gt; CONTEXT = ScopedValue.newInstance();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">withScopedValue</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;user-123&quot;</span>;<br>        <br>        ScopedValue.where(CONTEXT, context).run(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>                <span class="hljs-comment">// 所有子任务都能访问到 CONTEXT</span><br>                <span class="hljs-type">var</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> CONTEXT.get();  <span class="hljs-comment">// &quot;user-123&quot;</span><br>                    <span class="hljs-keyword">return</span> processWithContext(ctx);<br>                &#125;);<br>                <br>                <span class="hljs-type">var</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; &#123;<br>                    <span class="hljs-type">String</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> CONTEXT.get();  <span class="hljs-comment">// &quot;user-123&quot;</span><br>                    <span class="hljs-keyword">return</span> processWithContext(ctx);<br>                &#125;);<br>                <br>                scope.join().throwIfFailed();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>虚拟线程的优势</strong>:</p>
<ol>
<li><strong>轻量级</strong>: 可以创建百万级虚拟线程</li>
<li><strong>阻塞友好</strong>: <code>Thread.sleep()</code>, <code>BlockingQueue.take()</code> 等阻塞操作不会消耗平台线程</li>
<li><strong>结构化友好</strong>: 虚拟线程的生命周期管理简单,适合结构化并发</li>
</ol>
<h3 id="5-实际应用场景">5. 实际应用场景</h3>
<h4 id="典型使用模式">典型使用模式</h4>
<h5 id="模式-1-fan-out-fan-in">模式 1: Fan-Out / Fan-In</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Fan-Out: 并行执行多个任务</span><br><span class="hljs-comment"> * Fan-In: 聚合所有结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FanOutFanInPattern</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> OrderSummary <span class="hljs-title function_">processOrder</span><span class="hljs-params">(String orderId)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>            <span class="hljs-comment">// Fan-Out: 并行获取订单相关数据</span><br>            <span class="hljs-type">var</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; orderService.getOrder(orderId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">items</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; itemService.getItems(orderId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">customer</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; customerService.getCustomer(orderId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">shipping</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; shippingService.getShipping(orderId));<br>            <span class="hljs-type">var</span> <span class="hljs-variable">payment</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; paymentService.getPayment(orderId));<br>            <br>            <span class="hljs-comment">// Fan-In: 等待所有任务完成并聚合结果</span><br>            scope.join().throwIfFailed();<br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderSummary</span>(<br>                order.get(),<br>                items.get(),<br>                customer.get(),<br>                shipping.get(),<br>                payment.get()<br>            );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="模式-2-竞争模式-race">模式 2: 竞争模式 (Race)</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 竞争模式: 多个任务竞争,第一个成功的胜出</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RacePattern</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">fetchWithFallback</span><span class="hljs-params">(String url)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnSuccess&lt;String&gt;()) &#123;<br>            <span class="hljs-comment">// 主数据源</span><br>            scope.fork(() -&gt; fetchFromPrimary(url));<br>            <br>            <span class="hljs-comment">// 备份数据源 (延迟启动)</span><br>            Thread.sleep(<span class="hljs-number">50</span>);  <span class="hljs-comment">// 给主数据源一点时间</span><br>            scope.fork(() -&gt; fetchFromSecondary(url));<br>            <br>            <span class="hljs-comment">// 缓存</span><br>            scope.fork(() -&gt; fetchFromCache(url));<br>            <br>            scope.join();<br>            <span class="hljs-keyword">return</span> scope.result();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="模式-3-批量处理">模式 3: 批量处理</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 批量处理: 并行处理一批任务,收集所有成功结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BatchProcessingPattern</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> List&lt;ProcessedItem&gt; <span class="hljs-title function_">processBatch</span><span class="hljs-params">(List&lt;Item&gt; items)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CollectingScope</span>&lt;ProcessedItem&gt;()) &#123;<br>            <span class="hljs-comment">// 并行处理所有项目</span><br>            <span class="hljs-keyword">for</span> (Item item : items) &#123;<br>                scope.fork(() -&gt; processItem(item));<br>            &#125;<br>            <br>            scope.join();<br>            <br>            <span class="hljs-comment">// 返回所有成功处理的结果</span><br>            <span class="hljs-keyword">return</span> scope.results().toList();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CollectingScope</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;T&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleComplete</span><span class="hljs-params">(Subtask&lt;? extends T&gt; subtask)</span> &#123;<br>            <span class="hljs-keyword">if</span> (subtask.state() == Subtask.State.SUCCESS) &#123;<br>                results.add(subtask.get());<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> Stream&lt;T&gt; <span class="hljs-title function_">results</span><span class="hljs-params">()</span> &#123;<br>            ensureOwnerAndJoined();<br>            <span class="hljs-keyword">return</span> results.stream();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="模式-4-服务器处理">模式 4: 服务器处理</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务器模式: 持续接受连接,每个连接在独立作用域中处理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServerPattern</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startServer</span><span class="hljs-params">(ServerSocket serverSocket)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>&lt;Void&gt;()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                    <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>                    <br>                    <span class="hljs-comment">// 每个连接在独立的子任务中处理</span><br>                    scope.fork(() -&gt; handleConnection(socket));<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 如果出现异常或被中断,关闭所有连接</span><br>                scope.shutdown();<br>                scope.join();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Void <span class="hljs-title function_">handleConnection</span><span class="hljs-params">(Socket socket)</span> &#123;<br>        <span class="hljs-keyword">try</span> (socket) &#123;<br>            <span class="hljs-comment">// 处理连接</span><br>            processRequests(socket);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            log.error(<span class="hljs-string">&quot;Connection error&quot;</span>, e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="与传统-executorservice-的对比">与传统 ExecutorService 的对比</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 对比: 传统 ExecutorService vs 结构化并发</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Comparison</span> &#123;<br>    <br>    <span class="hljs-comment">// ========== 传统 ExecutorService ==========</span><br>    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">handleWithExecutorService</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            Future&lt;String&gt; userFuture = executor.submit(() -&gt; findUser());<br>            Future&lt;Integer&gt; orderFuture = executor.submit(() -&gt; fetchOrder());<br>            <br>            <span class="hljs-comment">// 问题 1: 需要手动等待所有任务</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> userFuture.get();<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">order</span> <span class="hljs-operator">=</span> orderFuture.get();<br>            <br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(user, order);<br>            <br>            <span class="hljs-comment">// 问题 2: 如果任务失败,需要手动处理异常</span><br>            <span class="hljs-comment">// 问题 3: 如果方法被中断,任务不会自动取消</span><br>            <span class="hljs-comment">// 问题 4: 需要手动管理线程池生命周期</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            executor.shutdown();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ========== 结构化并发 ==========</span><br>    <span class="hljs-keyword">public</span> Response <span class="hljs-title function_">handleWithStructuredConcurrency</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>            <span class="hljs-type">var</span> <span class="hljs-variable">userTask</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; findUser());<br>            <span class="hljs-type">var</span> <span class="hljs-variable">orderTask</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; fetchOrder());<br>            <br>            <span class="hljs-comment">// 自动等待所有任务</span><br>            scope.join()<br>                  .throwIfFailed();  <span class="hljs-comment">// 自动处理异常</span><br>            <br>            <span class="hljs-comment">// 自动取消未完成任务</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Response</span>(userTask.get(), orderTask.get());<br>            <br>            <span class="hljs-comment">// 自动清理: try-with-resources 确保关闭</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>详细对比</strong>:</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>ExecutorService</th>
<th>Structured Concurrency</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>任务生命周期</strong></td>
<td>不明确,需要手动管理</td>
<td>明确,绑定到作用域</td>
</tr>
<tr>
<td><strong>错误处理</strong></td>
<td>需要手动检查 Future</td>
<td>自动传播到父任务</td>
</tr>
<tr>
<td><strong>取消传播</strong></td>
<td>需要手动实现</td>
<td>自动传播</td>
</tr>
<tr>
<td><strong>资源清理</strong></td>
<td>需要手动 shutdown</td>
<td>自动清理</td>
</tr>
<tr>
<td><strong>可观测性</strong></td>
<td>需要额外工具</td>
<td>内置线程 dump</td>
</tr>
<tr>
<td><strong>代码可读性</strong></td>
<td>中等</td>
<td>高 (类似同步代码)</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>长期运行的任务池</td>
<td>请求-响应模式</td>
</tr>
</tbody>
</table>
<h4 id="最佳实践">最佳实践</h4>
<h5 id="1-正确使用-try-with-resources">1. 正确使用 try-with-resources</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ✅ 推荐: 使用 try-with-resources</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">goodExample</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; doWork());<br>        scope.join().throwIfFailed();<br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ❌ 错误: 忘记关闭作用域</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">badExample</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure();<br>    <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; doWork());<br>    scope.join().throwIfFailed();<br>    <span class="hljs-keyword">return</span> task.get();<br>    <span class="hljs-comment">// 忘记 close(),可能导致资源泄漏</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="2-正确处理异常">2. 正确处理异常</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ✅ 推荐: 使用 throwIfFailed</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">goodExceptionHandling</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; doWork());<br>        scope.join()<br>              .throwIfFailed(e -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBusinessException</span>(e));<br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ❌ 错误: 忽略异常</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">badExceptionHandling</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; doWork());<br>        scope.join();<br>        <span class="hljs-comment">// 忘记检查异常</span><br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="3-响应中断">3. 响应中断</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ✅ 推荐: 子任务响应中断</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">goodInterruptHandling</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; &#123;<br>            <span class="hljs-comment">// 使用可中断的方法</span><br>            <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> httpClient.get(url);<br>                <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> data;<br>                Thread.sleep(<span class="hljs-number">100</span>);  <span class="hljs-comment">// 可中断</span><br>            &#125;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>(<span class="hljs-string">&quot;Task was cancelled&quot;</span>);<br>        &#125;);<br>        <br>        scope.join().throwIfFailed();<br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ❌ 错误: 子任务不响应中断</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">badInterruptHandling</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; &#123;<br>            <span class="hljs-comment">// 使用不可中断的方法</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> httpClient.get(url);<br>                <span class="hljs-keyword">if</span> (data != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> data;<br>                Thread.sleep(<span class="hljs-number">100</span>);  <span class="hljs-comment">// 可中断</span><br>                <span class="hljs-comment">// 忽略中断信号</span><br>            &#125;<br>        &#125;);<br>        <br>        scope.join().throwIfFailed();<br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="4-避免过深的嵌套">4. 避免过深的嵌套</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ⚠️ 避免过深的嵌套</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">deepNesting</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task1</span> <span class="hljs-operator">=</span> scope1.fork(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>                <span class="hljs-type">var</span> <span class="hljs-variable">task2</span> <span class="hljs-operator">=</span> scope2.fork(() -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>                        <span class="hljs-type">var</span> <span class="hljs-variable">task3</span> <span class="hljs-operator">=</span> scope3.fork(() -&gt; doWork());<br>                        scope3.join().throwIfFailed();<br>                        <span class="hljs-keyword">return</span> task3.get();<br>                    &#125;<br>                &#125;);<br>                scope2.join().throwIfFailed();<br>                <span class="hljs-keyword">return</span> task2.get();<br>            &#125;<br>        &#125;);<br>        scope1.join().throwIfFailed();<br>        <span class="hljs-keyword">return</span> task1.get();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ✅ 推荐: 提取方法</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">flatStructure</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; processNested());<br>        scope.join().throwIfFailed();<br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">processNested</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; doWork());<br>        scope.join().throwIfFailed();<br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="5-合理使用超时">5. 合理使用超时</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ✅ 推荐: 使用 joinUntil</span><br><span class="hljs-keyword">public</span> Response <span class="hljs-title function_">withTimeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">Instant</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> Instant.now().plusSeconds(<span class="hljs-number">5</span>);<br>    <br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>        <span class="hljs-type">var</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> scope.fork(() -&gt; doWork());<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            scope.joinUntil(deadline).throwIfFailed();<br>        &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>            <span class="hljs-comment">// 超时后,作用域会自动 shutdown</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BusinessException</span>(<span class="hljs-string">&quot;Operation timed out&quot;</span>, e);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> task.get();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="6-可观测性">6. 可观测性</h3>
<p>结构化并发提供了强大的可观测性支持:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 生成结构化线程 dump</span><br><span class="hljs-comment">// $ jcmd &lt;pid&gt; Thread.dump_to_file -format=json &lt;file&gt;</span><br><br><span class="hljs-comment">// 输出示例:</span><br>&#123;<br>  <span class="hljs-string">&quot;threadDump&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;threadContainers&quot;</span>: [<br>      &#123;<br>        <span class="hljs-string">&quot;container&quot;</span>: <span class="hljs-string">&quot;&lt;root&gt;&quot;</span>,<br>        <span class="hljs-string">&quot;threads&quot;</span>: [...]<br>      &#125;,<br>      &#123;<br>        <span class="hljs-string">&quot;container&quot;</span>: <span class="hljs-string">&quot;java.util.concurrent.StructuredTaskScope$ShutdownOnFailure@123&quot;</span>,<br>        <span class="hljs-string">&quot;parent&quot;</span>: <span class="hljs-string">&quot;&lt;root&gt;&quot;</span>,<br>        <span class="hljs-string">&quot;owner&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>,<br>        <span class="hljs-string">&quot;threads&quot;</span>: [<br>          &#123;<br>            <span class="hljs-string">&quot;tid&quot;</span>: <span class="hljs-string">&quot;21&quot;</span>,<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>            <span class="hljs-string">&quot;stack&quot;</span>: [<br>              <span class="hljs-string">&quot;java.base/java.lang.VirtualThread.parkNanos&quot;</span>,<br>              <span class="hljs-string">&quot;java.base/java.lang.Thread.sleep&quot;</span>,<br>              <span class="hljs-string">&quot;com.example.Service.doWork&quot;</span>,<br>              <span class="hljs-string">&quot;...&quot;</span><br>            ]<br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>可观测性优势</strong>:</p>
<ol>
<li><strong>任务树结构</strong>: 清晰显示父子任务关系</li>
<li><strong>作用域信息</strong>: 每个任务属于哪个作用域</li>
<li><strong>栈追踪</strong>: 显示任务在做什么</li>
<li><strong>调试友好</strong>: 类似单线程调试体验</li>
</ol>
<h3 id="7-总结">7. 总结</h3>
<h4 id="结构化并发的优势">结构化并发的优势</h4>
<pre><code class="hljs mermaid">mindmap
  root((结构化并发))
    优势
      代码可读性
        类似同步代码
        清晰的作用域
      可靠性
        自动取消传播
        自动错误处理
      可维护性
        自动资源清理
        明确的生命周期
      可观测性
        内置线程 dump
        任务树结构
    与虚拟线程协同
      轻量级并发
      百万级任务
      阻塞友好
    适用场景
      IO 密集型
      请求-响应
      并行聚合</code></pre>
<h4 id="迁移建议">迁移建议</h4>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否迁移</th>
<th>建议</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>新的 IO 密集型应用</strong></td>
<td>✅ 强烈推荐</td>
<td>直接使用结构化并发</td>
</tr>
<tr>
<td><strong>现有 ExecutorService 代码</strong></td>
<td>⚠️ 评估</td>
<td>逐步迁移,优先迁移新功能</td>
</tr>
<tr>
<td><strong>CPU 密集型任务</strong></td>
<td>❌ 不推荐</td>
<td>继续使用 ForkJoinPool</td>
</tr>
<tr>
<td><strong>长期运行的任务池</strong></td>
<td>❌ 不推荐</td>
<td>继续使用 ExecutorService</td>
</tr>
<tr>
<td><strong>需要细粒度控制的场景</strong></td>
<td>⚠️ 评估</td>
<td>结构化并发可能过于严格</td>
</tr>
</tbody>
</table>
<h4 id="未来展望">未来展望</h4>
<p>结构化并发代表了 Java 并发编程的未来方向:</p>
<ol>
<li><strong>JDK 23/24</strong>: 可能正式定稿</li>
<li><strong>生态系统</strong>: 更多库将支持结构化并发</li>
<li><strong>工具链</strong>: IDE 和监控工具将增强支持</li>
<li><strong>最佳实践</strong>: 社区将积累更多经验</li>
</ol>
<blockquote>
<p><strong>核心洞察</strong>: 结构化并发不是要完全取代 ExecutorService,而是为请求-响应模式的并发编程提供更简单、更安全、更可维护的解决方案。理解其适用场景,才能充分发挥其价值。</p>
</blockquote>
<hr>
<p><strong>参考资料</strong>:</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://openjdk.org/jeps/428">JEP 428: Structured Concurrency (Incubator)</a></li>
<li><a target="_blank" rel="noopener" href="https://openjdk.org/jeps/437">JEP 437: Structured Concurrency (Second Incubator)</a></li>
<li><a target="_blank" rel="noopener" href="https://openjdk.org/jeps/453">JEP 453: Structured Concurrency (Preview)</a></li>
<li><a target="_blank" rel="noopener" href="https://openjdk.org/jeps/462">JEP 462: Structured Concurrency (Second Preview)</a></li>
<li><a target="_blank" rel="noopener" href="https://www.250bpm.com/p/structured-concurrency">Martin Sústrik - Structured Concurrency</a></li>
<li><a target="_blank" rel="noopener" href="https://vorpus.org/blog/notes-on-structured-concurrency-or-go-statement-considered-harmful/">Nathaniel J. Smith - Notes on structured concurrency</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/21/core/structured-concurrency.html">Oracle Documentation - Structured Concurrency</a></li>
<li><a target="_blank" rel="noopener" href="https://kotlinlang.org/docs/coroutines-basics.html">Kotlin Coroutines Documentation</a></li>
<li><a target="_blank" rel="noopener" href="https://trio.readthedocs.io/">Python Trio Documentation</a></li>
</ol>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/">https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" title="无锁队列"><img class="cover" src="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">无锁队列</div></div><div class="info-2"><div class="info-item-1">Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。 * * &lt;p&gt;原理说明： * - 仅允许一个线程调用 &#123;@code offer()&#125;，一个线程调用 &#123;@code poll()&#125;。 * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。 * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系： *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。 * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad）， *   ...</div></div></div></a><a class="pagination-related" href="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="Java 并发编程笔记"><img class="cover" src="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-12</div><div class="info-item-2">Java 并发编程笔记</div></div><div class="info-2"><div class="info-item-1"> juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 MESA 模型 JAVA 采用 MESA 模型：  互斥（Mutual Exclusion）：通过锁机制保证同一时刻只有一个线程能进入管程内部执行。 同步（Synchronization）：利用条件变量（Condition Variable）实现线程间的等待与唤醒。 Signal and Continue：   当线程发出通知（signal/notify）时，它继续持有锁并运行，而被唤醒的线程仅仅是进入就绪队列，并不立即抢占 CPU。   必须使用 while 循环：   由于线程被唤醒后不一定立即执行，当它重新获得锁时，环境条件可能已发生变化，因此必须在一个 while 循环中重新检查等待条件（while (condition) { wait(); }）。  为什么用 se...</div></div></div></a><a class="pagination-related" href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-19</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1"> 版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374）。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级。但在深入讨论线程安全的分类之前，我们需要先理解 Java 内存模型——它是理解线程安全问题的理论基础。 Java 内存模型基础 Java 内存模型（Java Memory Model，JMM）是 Java 语言规范的一部分，定义了多线程程序中共享变量的访问规则。理解 JMM 是理解线程安全问题的基础。 为什么需要内存模型？ 现代计算机系统中，CPU 与主内存之间存在巨大的速度差异。为了弥补这一差距，硬件层面引入了多级缓存（L1、L2、L3 Cache）。这带来了一个问...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-111.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a><a class="pagination-related" href="/2017/11/03/JVM-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="JVM 的内存模型与线程"><img class="cover" src="/img/wall-paper-82.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-03</div><div class="info-item-2">JVM 的内存模型与线程</div></div><div class="info-2"><div class="info-item-1">1.性能何处寻   计算机的CPU比起其他所有的设备，都快得多，所以怎样尽量复用 CPU 的时间片，是压榨计算机性能的目标。多核和并发，使得阿姆达尔定律大显神威，超越摩尔定律成为提升系统性能的金科玉律 - 现在单核计算能力已经无法垂直提升，要水平提升核数来提升整体性能。 2.缓存一致性问题（Cache Coherence）   软件缓存，不过是硬件缓存的模仿，真正的缓存，早已存在于计算机的多级存储体系结构中。JVM 里，我们可以认为每个处理器都会在主内存（Main Memory）之外有高速缓存作为工作内存（Working memory）。除此之外，处理器和 JVM 都可能出现指令重排（Instruction Reorder）的的情况。工作内存是线程 Save 和 Load 的主要场所，主内存则是他们沟通的场所。 3.JVM 的对象信息   Java Object 除了基本的内存轮廓以外，还有：  Mark Word（对象的 Hash Code 的缓存值、GC标志、GC年龄、同步锁等信息）。 Klass Point（指向对象元数据信息的指针，指向 .class  的指针吗？不是，是...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-130.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">上下文 卡表和 RSet（Remember Set），是 JVM 为了解决分代收集时，live set 扫描需要穿梭到不同的代的时候的效率问题。 使用缓存表来提高查询效率，是化顺序查找为部分随机查找的一种常用的设计思路。 例如，在传统的计算机体系结构中，当我们把内存分成页以后，会有一个页表，页表又会有一个快表，作为一个中间缓存项，来帮助我们查找我们需要使用的页表项（table entry）。 JVM 在进行垃圾收集的时候，有一项非常重要的工作就是确定这一次垃圾收集的对象到底有多少个，即确定 live set 的范围。 对于新生代垃圾收集器而言，这个问题又有其特殊之处。根据 JVM 的弱分代收集假设（weak generational hypothesis）的存在，每次垃圾收集的时候，新生代的扫描范围可能很大，但新生代的 live set 不应该太大。card table/Remember Set 的设计目的，就是尽量减少无用的垃圾扫描范围，使用类似操作系统或者数据库的脏页表的形式，来做类似快表的查询。 卡表（card table）  卡表是 CMS 的解决方案。 卡表通常在 JV...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">从执行器到线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">执行器继承体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#executor-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">Executor 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#executorservice-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.2.</span> <span class="toc-text">ExecutorService 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abstractexecutorservice"><span class="toc-number">1.1.3.</span> <span class="toc-text">AbstractExecutorService</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#threadpoolexecutor"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjoinpool"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">ForkJoinPool</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-executors"><span class="toc-number">1.1.4.</span> <span class="toc-text">The Executors</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">层次调用关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#futuretask-%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%BB%E5%8A%A1%E8%BD%BD%E4%BD%93"><span class="toc-number">1.2.1.</span> <span class="toc-text">FutureTask 作为线程池的核心任务载体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#thread-%E6%A8%A1%E5%9E%8B%E5%BA%95%E5%B1%82"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Thread 模型底层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#futuretask-%E7%9A%84-run"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">FutureTask 的 run()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#futuretask-%E7%9A%84-runner"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">FutureTask 的 runner</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#invokeall"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">invokeAll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%92%88%E5%AF%B9-runnable-%E7%9A%84-submit"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">两种针对 Runnable 的 submit</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8A%A4%E8%87%AA%E8%BA%AB%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">线程池如何维护自身状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.3.1.</span> <span class="toc-text">尝试关闭线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">线程池如何管理任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">1.4.1.</span> <span class="toc-text">任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">提交任务调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%BC%93%E5%86%B2"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">任务缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8B%92%E7%BB%9D"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">任务拒绝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%94%B3%E8%AF%B7"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">任务申请</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">线程池如何管理线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">尝试增加线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="toc-number">1.5.2.</span> <span class="toc-text">线程执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.3.</span> <span class="toc-text">回收线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">线程池使用中可能遇到的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88"><span class="toc-number">1.7.</span> <span class="toc-text">线程池的可替换方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.8.</span> <span class="toc-text">最终解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-number">1.9.</span> <span class="toc-text">线程组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E6%9C%AC%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84"><span class="toc-number">1.9.1.</span> <span class="toc-text">原本设计目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-number">1.9.2.</span> <span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">1.9.3.</span> <span class="toc-text">替代方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%80%81%E5%BA%A6"><span class="toc-number">1.9.4.</span> <span class="toc-text">官方态度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completionstage"><span class="toc-number">1.10.</span> <span class="toc-text">CompletionStage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completablefuture"><span class="toc-number">1.11.</span> <span class="toc-text">CompletableFuture</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">如何处理任务超时问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E4%BD%BF%E7%94%A8-futuretask-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">方法1：使用 FutureTask 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">方法2：使用条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E4%BD%BF%E7%94%A8-countdownlatch-cyclicbarrier"><span class="toc-number">2.1.3.</span> <span class="toc-text">方法3：使用 countDownLatch&#x2F;CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E6%96%AD"><span class="toc-number">2.2.</span> <span class="toc-text">自定义线程池实现自定义中断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Java 异步执行中的异常处理与线程生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-futuretask-asyncuncaughtexceptionhandler-%E5%88%B0-uncaughtexceptionhandler"><span class="toc-number">3.1.</span> <span class="toc-text">从 FutureTask、AsyncUncaughtExceptionHandler 到 UncaughtExceptionHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%88%E6%AD%A2%E7%9A%84%E5%94%AF%E4%B8%80%E5%88%A4%E5%AE%9A%E6%A0%87%E5%87%86"><span class="toc-number">3.2.</span> <span class="toc-text">一、线程是否终止的唯一判定标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.1 会导致线程终止的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.2.2.</span> <span class="toc-text">1.2 不会导致线程终止的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-futuretask-%E5%AF%B9%E5%BC%82%E5%B8%B8%E4%BC%A0%E6%92%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">3.3.</span> <span class="toc-text">二、FutureTask 对异常传播路径的改变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-execute-%E4%B8%8E-submit-%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%B7%AE%E5%BC%82"><span class="toc-number">3.3.1.</span> <span class="toc-text">2.1 execute 与 submit 的根本差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-futuretask-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA%E7%82%B9"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.2 FutureTask 中的异常拦截点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BC%82%E5%B8%B8%E5%A6%82%E4%BD%95%E8%A2%AB%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%EF%BC%9Areport"><span class="toc-number">3.3.3.</span> <span class="toc-text">2.3 异常如何被重新抛出：report()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-uncaughtexceptionhandler-%E7%9A%84%E8%81%8C%E8%B4%A3%E8%BE%B9%E7%95%8C"><span class="toc-number">3.4.</span> <span class="toc-text">三、UncaughtExceptionHandler 的职责边界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.1 触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%83%BD%E5%8A%9B%E4%B8%8E%E9%99%90%E5%88%B6"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.2 能力与限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-spring-asyncuncaughtexceptionhandler-%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">3.5.</span> <span class="toc-text">四、Spring AsyncUncaughtExceptionHandler 的作用范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.1.</span> <span class="toc-text">4.1 适用条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-spring-%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.2.</span> <span class="toc-text">4.2 Spring 的异常拦截方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AF%B9%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">3.5.3.</span> <span class="toc-text">4.3 对线程生命周期的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E4%B8%89%E7%A7%8D%E5%BC%82%E5%B8%B8%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.6.</span> <span class="toc-text">五、三种异常路径的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-async-void-%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.1.</span> <span class="toc-text">5.1 @Async void 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0execute"><span class="toc-number">3.6.2.</span> <span class="toc-text">5.2 线程池execute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0-submit"><span class="toc-number">3.6.3.</span> <span class="toc-text">5.3 线程池 submit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E4%B8%A4%E7%A7%8D-handler-%E7%9A%84%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">六、两种 Handler 的推荐使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-asyncuncaughtexceptionhandler-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">3.7.1.</span> <span class="toc-text">6.1 AsyncUncaughtExceptionHandler（业务层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-uncaughtexceptionhandler-%E7%B3%BB%E7%BB%9F%E5%B1%82"><span class="toc-number">3.7.2.</span> <span class="toc-text">6.2 UncaughtExceptionHandler（系统层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.7.3.</span> <span class="toc-text">6.3 有返回值的异步任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">3.8.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Spring 的异步支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpooltaskexecutor"><span class="toc-number">4.1.</span> <span class="toc-text">ThreadPoolTaskExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpooltaskexecutor-%E5%86%85%E9%83%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">ThreadPoolTaskExecutor 内部线程池的替换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E8%A3%85%E9%A5%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">推荐：使用初始化器装饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BB%A3%E7%90%86"><span class="toc-number">4.2.2.</span> <span class="toc-text">其他代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%A6%81%E6%9B%BF%E6%8D%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">如果我们要替换线程池实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E8%A1%8C-trace-%E4%BC%A0%E9%80%92"><span class="toc-number">4.3.</span> <span class="toc-text">对线程池实行 trace 传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%E7%BB%9F%E4%B8%80%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">如果使用统一包装器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">ForkJoinPool详解：分治并行的执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A%E5%88%86%E6%B2%BB%E5%B9%B6%E8%A1%8C%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-number">5.1.</span> <span class="toc-text">前言：分治并行的诞生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Aforkjoinpool%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-number">5.2.</span> <span class="toc-text">1. 核心数据结构：ForkJoinPool的基石</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-forkjoinpool%EF%BC%9A%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.1 ForkJoinPool：去中心化的调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">数据结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Ethreadpoolexecutor%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">与ThreadPoolExecutor的本质区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%B7%AE%E5%BC%82"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">关键差异</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-forkjoinworkerthreadfactory%EF%BC%9A%E4%B8%93%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82"><span class="toc-number">5.2.2.</span> <span class="toc-text">1.2 ForkJoinWorkerThreadFactory：专用线程工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">接口定义与对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">关键区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fjp-%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.2.1.</span> <span class="toc-text">FJP 的扩展方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%84%8F%E4%B9%89"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">设计意义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-forkjoinworkerthread%EF%BC%9A%E5%8D%8F%E4%BD%9C%E5%BC%8F%E6%89%A7%E8%A1%8C%E8%80%85"><span class="toc-number">5.2.3.</span> <span class="toc-text">1.3 ForkJoinWorkerThread：协作式执行者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Ethreadpoolexecutor-worker%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">与ThreadPoolExecutor.Worker的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">设计决策</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88forkjoinpool%E4%B8%8D%E4%BC%9A%E6%9C%89%E7%BA%BF%E7%A8%8B%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">5.2.3.4.</span> <span class="toc-text">线程安全特性：为什么ForkJoinPool不会有线程泄露问题？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-workqueue%EF%BC%9A%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.4.</span> <span class="toc-text">1.4 WorkQueue：双端队列的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.4.2.</span> <span class="toc-text">核心操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lifo-fifo-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%99%BA%E6%85%A7%EF%BC%9A"><span class="toc-number">5.2.4.3.</span> <span class="toc-text">LIFO + FIFO 的设计智慧：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjointask-join-%E4%B8%8E-thread-join-%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%B7%AE%E5%BC%82"><span class="toc-number">5.2.4.4.</span> <span class="toc-text">ForkJoinTask.join() 与 Thread.join() 的本质差异</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-forkjointask%EF%BC%9A%E4%BB%BB%E5%8A%A1%E6%8A%BD%E8%B1%A1"><span class="toc-number">5.2.5.</span> <span class="toc-text">1.5 ForkJoinTask：任务抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">核心结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%AD%90%E7%B1%BB"><span class="toc-number">5.2.5.2.</span> <span class="toc-text">标准子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Efuturetask%E7%9A%84%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.5.3.</span> <span class="toc-text">与FutureTask的关键区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AEapi%EF%BC%9A%E4%B8%8Ethreadpoolexecutor%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">5.3.</span> <span class="toc-text">2. 关键API：与ThreadPoolExecutor的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-forkjoinpool%E7%9A%84%E6%A0%B8%E5%BF%83api"><span class="toc-number">5.3.1.</span> <span class="toc-text">2.1 ForkJoinPool的核心API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%AE%A2%E6%88%B7%E7%AB%AFapi"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">外部客户端API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E8%AE%A1%E7%AE%97api"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">内部计算API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E4%B8%8E%E7%AE%A1%E7%90%86api"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">监控与管理API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-api%E4%BD%BF%E7%94%A8%E8%BE%B9%E7%95%8C%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%B7%B7%E7%94%A8%EF%BC%9F"><span class="toc-number">5.3.2.</span> <span class="toc-text">2.2 API使用边界：为什么不能混用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8A%A8%E6%80%81%E9%80%82%E5%BA%94%E7%9A%84%E8%89%BA%E6%9C%AF"><span class="toc-number">5.4.</span> <span class="toc-text">3. 线程调度机制：动态适应的艺术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B9%B6%E8%A1%8C%E5%BA%A6%EF%BC%9A%E5%94%AF%E4%B8%80%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.1.</span> <span class="toc-text">3.1 并行度：唯一的核心参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">配置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E6%B1%A0%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">公共池的系统属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%9E%E9%99%85%E5%BD%B1%E5%93%8D%EF%BC%9A"><span class="toc-number">5.4.1.3.</span> <span class="toc-text">各参数的实际影响：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%97%A0core-max%E5%8F%82%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">5.4.2.</span> <span class="toc-text">3.2 无core&#x2F;max参数的设计哲学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#threadpoolexecutor%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">ThreadPoolExecutor的线程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjoinpool%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">ForkJoinPool的线程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parallelism-vs-corepoolsize-maximumspares-vs-maximumpoolsize%EF%BC%9A"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">parallelism vs corePoolSize, maximumSpares vs maximumPoolSize：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.2.4.</span> <span class="toc-text">线程回收机制对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fjp%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6%E7%BB%86%E8%8A%82"><span class="toc-number">5.4.2.5.</span> <span class="toc-text">FJP线程回收细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9A%E6%97%A0%E7%95%8C%E9%98%9F%E5%88%97%E4%B8%8E%E4%BB%BB%E5%8A%A1%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.4.3.</span> <span class="toc-text">3.3 为什么没有拒绝策略：无界队列与任务消费模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjoinpool-%E6%9E%84%E9%80%A0%E5%99%A8%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">ForkJoinPool 构造器对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">为什么不需要拒绝策略？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%97%A0%E7%95%8C%E4%BC%9A%E5%AF%BC%E8%87%B4-oom-%E5%90%97%EF%BC%9F"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">队列无界会导致 OOM 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E6%80%BB%E7%BB%93"><span class="toc-number">5.4.3.4.</span> <span class="toc-text">设计哲学总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.4.4.</span> <span class="toc-text">3.4 工作线程生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B9%B6%E8%A1%8C%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.5.</span> <span class="toc-text">4. 实战案例：并行文件搜索系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82"><span class="toc-number">5.5.1.</span> <span class="toc-text">4.1 业务需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.5.2.</span> <span class="toc-text">4.2 数据结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">5.5.3.</span> <span class="toc-text">4.3 线程池初始化与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96%E8%A7%A3%E6%9E%90"><span class="toc-number">5.5.4.</span> <span class="toc-text">4.4 关键设计决策解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-recursivetask-%E8%80%8C%E4%B8%8D%E6%98%AF-recursiveaction%EF%BC%9F"><span class="toc-number">5.5.4.1.</span> <span class="toc-text">1. 为什么使用 RecursiveTask 而不是 RecursiveAction？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E7%BD%AEthreshold-100%EF%BC%9F"><span class="toc-number">5.5.4.2.</span> <span class="toc-text">2. 为什么设置THRESHOLD&#x3D;100？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88fork%E5%85%B6%E4%BB%96%E4%BB%BB%E5%8A%A1-%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-number">5.5.4.3.</span> <span class="toc-text">3. 为什么fork其他任务，直接执行最后一个任务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B1%A0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%BD%BF%E7%94%A8%E5%85%AC%E5%85%B1%E6%B1%A0%EF%BC%9F"><span class="toc-number">5.5.4.4.</span> <span class="toc-text">4. 为什么创建自定义池而不是使用公共池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88asyncmode-false%EF%BC%9F"><span class="toc-number">5.5.4.5.</span> <span class="toc-text">5. 为什么asyncMode&#x3D;false？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97"><span class="toc-number">5.6.</span> <span class="toc-text">5. 常见错误模式与避坑指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-api%E6%B7%B7%E7%94%A8%E9%94%99%E8%AF%AF"><span class="toc-number">5.6.1.</span> <span class="toc-text">5.1 API混用错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-i-o%E9%98%BB%E5%A1%9E%E9%94%99%E8%AF%AF"><span class="toc-number">5.6.2.</span> <span class="toc-text">5.2 I&#x2F;O阻塞错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E9%94%99%E8%AF%AF"><span class="toc-number">5.6.3.</span> <span class="toc-text">5.3 资源泄漏错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%88%B6%E5%AD%90%E4%BB%BB%E5%8A%A1%E6%AD%BB%E9%94%81%EF%BC%9A%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%87%B4%E5%91%BD%E7%BC%BA%E9%99%B7%E4%B8%8Eforkjoinpool%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.7.</span> <span class="toc-text">6. 父子任务死锁：传统线程池的致命缺陷与ForkJoinPool的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%A5%A5%E9%A5%BF%E6%AD%BB%E9%94%81"><span class="toc-number">5.7.1.</span> <span class="toc-text">6.1 问题场景：线程池饥饿死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%8D%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">5.7.1.1.</span> <span class="toc-text">死锁复现代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-number">5.7.1.2.</span> <span class="toc-text">死锁分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%BC%A0%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">5.7.2.</span> <span class="toc-text">6.2 传统解决方案的局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%881%EF%BC%9A%E5%A2%9E%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%B9%E9%87%8F"><span class="toc-number">5.7.2.1.</span> <span class="toc-text">方案1：增大线程池容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%882%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%97%A0%E7%95%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.7.2.2.</span> <span class="toc-text">方案2：使用无界线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%883%EF%BC%9A%E7%88%B6%E5%AD%90%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.7.2.3.</span> <span class="toc-text">方案3：父子任务使用不同线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-forkjoinpool%E7%9A%84%E6%A0%B9%E6%9C%AC%E6%80%A7%E8%A7%A3%E5%86%B3%EF%BC%9A%E5%8D%8F%E4%BD%9C%E5%BC%8F%E7%AD%89%E5%BE%85"><span class="toc-number">5.7.3.</span> <span class="toc-text">6.3 ForkJoinPool的根本性解决：协作式等待</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9Ajoin-%E4%B8%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%98%BB%E5%A1%9E"><span class="toc-number">5.7.3.1.</span> <span class="toc-text">核心机制：join()不是真正的阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C%E7%AD%89%E5%BE%85%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%9Aawaitjoin"><span class="toc-number">5.7.3.2.</span> <span class="toc-text">协作等待的核心：awaitJoin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E7%AA%83%E5%8F%96%E8%80%85%E6%9C%BA%E5%88%B6-help-stealer"><span class="toc-number">5.7.3.3.</span> <span class="toc-text">帮助窃取者机制（Help Stealer）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%88%B6%E5%AD%90%E4%BB%BB%E5%8A%A1%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%9B%B8%E4%BA%92%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-number">5.7.4.</span> <span class="toc-text">6.4 为什么父子任务可以不相互阻塞？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B1%82%E9%9D%A2%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8C%96%E8%A7%A3%E8%80%A6"><span class="toc-number">5.7.4.1.</span> <span class="toc-text">接口层面的异步化解耦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A4%A9%E7%84%B6%E9%80%82%E9%85%8D"><span class="toc-number">5.7.4.2.</span> <span class="toc-text">分治模式的天然适配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E7%BA%BF%E7%A8%8B%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%9C%89%E9%99%90%E5%BA%A6%E7%9A%84%E5%BC%B9%E6%80%A7"><span class="toc-number">5.7.5.</span> <span class="toc-text">6.5 线程补偿机制：有限度的弹性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%97%A0%E9%99%90%E8%A1%A5%E5%81%BF%E5%90%97%EF%BC%9F"><span class="toc-number">5.7.5.1.</span> <span class="toc-text">线程可以无限补偿吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.7.5.2.</span> <span class="toc-text">补偿机制的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84%E7%A1%AC%E6%80%A7%E4%B8%8A%E9%99%90"><span class="toc-number">5.7.5.3.</span> <span class="toc-text">线程数的硬性上限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E8%BE%BE%E5%88%B0%E4%B8%8A%E9%99%90%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.7.5.4.</span> <span class="toc-text">当达到上限后会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%99%90%E5%88%B6%E8%A1%A5%E5%81%BF%EF%BC%9F"><span class="toc-number">5.7.5.5.</span> <span class="toc-text">为什么要限制补偿？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.7.5.6.</span> <span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E5%AF%B9%E6%AF%94%E9%AA%8C%E8%AF%81"><span class="toc-number">5.7.6.</span> <span class="toc-text">6.6 对比验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjoinpool%E7%89%88%E6%9C%AC-%E4%B8%8D%E4%BC%9A%E6%AD%BB%E9%94%81"><span class="toc-number">5.7.6.1.</span> <span class="toc-text">ForkJoinPool版本（不会死锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">5.7.6.2.</span> <span class="toc-text">执行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E8%AE%BE%E8%AE%A1%E5%90%AF%E7%A4%BA"><span class="toc-number">5.7.7.</span> <span class="toc-text">6.7 设计启示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BB%93%E8%AE%BA%EF%BC%9A%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">5.8.</span> <span class="toc-text">7. 结论：设计的本质</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">异步编程的进化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%94%E8%BF%9B%E6%9C%AC%E8%B4%A8"><span class="toc-number">6.1.</span> <span class="toc-text">演进本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%B0%83%E7%94%A8%E6%97%B6%E5%BA%8F"><span class="toc-number">6.2.</span> <span class="toc-text">传统调用时序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-5-future"><span class="toc-number">6.2.1.</span> <span class="toc-text">Java 5 Future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#guava-listenablefuture"><span class="toc-number">6.2.2.</span> <span class="toc-text">Guava ListenableFuture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#completablefuture"><span class="toc-number">6.2.3.</span> <span class="toc-text">CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%A0%91"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">执行树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-api"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">核心 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.3.3.</span> <span class="toc-text">使用原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%80%EF%BC%9A%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E8%A6%81%E4%BC%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.2.3.3.1.</span> <span class="toc-text">原则一：异步回调要传线程池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%BA%8C%EF%BC%9Acompletablefuture-%E4%B8%AD%E4%B8%8D%E8%A6%81%E5%90%9E%E5%BC%82%E5%B8%B8"><span class="toc-number">6.2.3.3.2.</span> <span class="toc-text">原则二：CompletableFuture 中不要吞异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%B6-%E6%B3%A8%E6%84%8F%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-number">6.2.3.3.3.</span> <span class="toc-text">原则三：自定义线程池时，注意饱和策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E5%9B%9B%EF%BC%9A%E6%AD%A3%E7%A1%AE%E8%BF%9B%E8%A1%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">6.2.3.3.4.</span> <span class="toc-text">原则四：正确进行异常处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%BA%94%EF%BC%9A%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE%E8%B6%85%E6%97%B6"><span class="toc-number">6.2.3.3.5.</span> <span class="toc-text">原则五：合理设置超时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E5%85%AD%EF%BC%9A%E9%81%BF%E5%85%8D%E5%9C%A8%E5%9B%9E%E8%B0%83%E4%B8%AD%E9%98%BB%E5%A1%9E"><span class="toc-number">6.2.3.3.6.</span> <span class="toc-text">原则六：避免在回调中阻塞</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.3.4.</span> <span class="toc-text">完成保证原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AE%8C%E6%88%90%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">6.2.3.4.1.</span> <span class="toc-text">为什么需要完成保证原则？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%88%99%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.3.4.2.</span> <span class="toc-text">完成保证原则的核心模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.2.3.4.3.</span> <span class="toc-text">完整示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BC%A0%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%95%88%E7%8E%87%E6%94%B9%E8%BF%9B"><span class="toc-number">6.2.3.5.</span> <span class="toc-text">对传统的线程池的效率改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rxjava"><span class="toc-number">6.3.</span> <span class="toc-text">RxJava</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reactor"><span class="toc-number">6.4.</span> <span class="toc-text">Reactor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">虚拟线程：Java 并发模型的未来</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">为什么需要虚拟线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9B%B0%E5%A2%83"><span class="toc-number">7.1.1.</span> <span class="toc-text">传统线程模型的困境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.1.2.</span> <span class="toc-text">虚拟线程的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B-vs-%E5%B9%B3%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">虚拟线程 vs 平台线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%B7%AE%E5%BC%82%E5%AF%B9%E6%AF%94"><span class="toc-number">7.2.1.</span> <span class="toc-text">核心差异对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AF%B9%E6%AF%94"><span class="toc-number">7.2.2.</span> <span class="toc-text">代码对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">虚拟线程的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.1.</span> <span class="toc-text">挂载与卸载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%8E-go-gpm-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">7.3.2.</span> <span class="toc-text">虚拟线程调度模型：与 Go GPM 的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84-continuation-%E6%9C%BA%E5%88%B6%EF%BC%9Aunmount-mount-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">7.3.3.</span> <span class="toc-text">虚拟线程的 Continuation 机制：unmount&#x2F;mount 的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="toc-number">7.3.4.</span> <span class="toc-text">关键概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">7.4.</span> <span class="toc-text">虚拟线程的使用原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%80%EF%BC%9A%E4%B8%8D%E8%A6%81%E6%B1%A0%E5%8C%96%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.4.1.</span> <span class="toc-text">原则一：不要池化虚拟线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%BA%8C%EF%BC%9A%E9%81%BF%E5%85%8D%E5%9C%A8%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C-cpu-%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.4.2.</span> <span class="toc-text">原则二：避免在虚拟线程中执行 CPU 密集型任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%89%EF%BC%9A%E6%B3%A8%E6%84%8F-synchronized-%E5%92%8C-native-%E6%96%B9%E6%B3%95%E7%9A%84-pinning-%E9%97%AE%E9%A2%98"><span class="toc-number">7.4.3.</span> <span class="toc-text">原则三：注意 synchronized 和 native 方法的 Pinning 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E5%9B%9B%EF%BC%9A%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8-threadlocal"><span class="toc-number">7.4.4.</span> <span class="toc-text">原则四：正确使用 ThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">7.5.</span> <span class="toc-text">虚拟线程与传统线程池的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">7.5.1.</span> <span class="toc-text">决策流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">7.5.2.</span> <span class="toc-text">场景对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.5.3.</span> <span class="toc-text">迁移示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E7%89%B9%E5%BE%81"><span class="toc-number">7.6.</span> <span class="toc-text">虚拟线程的性能特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">7.6.1.</span> <span class="toc-text">吞吐量对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%AF%B9%E6%AF%94"><span class="toc-number">7.6.2.</span> <span class="toc-text">内存占用对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">7.7.</span> <span class="toc-text">总结：线程池技术的演进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="toc-number">7.7.1.</span> <span class="toc-text">技术选型总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91-structured-concurrency"><span class="toc-number">7.8.</span> <span class="toc-text">结构化并发 (Structured Concurrency)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%8E%86%E5%8F%B2%E8%83%8C%E6%99%AF"><span class="toc-number">7.8.1.</span> <span class="toc-text">1. 历史背景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%E8%B5%B7%E6%BA%90"><span class="toc-number">7.8.1.1.</span> <span class="toc-text">概念起源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB%EF%BC%9A%E7%B1%BB%E6%AF%94%E8%80%8C%E9%9D%9E%E7%BB%A7%E6%89%BF"><span class="toc-number">7.8.1.2.</span> <span class="toc-text">与结构化编程的关系：类比而非继承</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">7.8.1.3.</span> <span class="toc-text">传统并发编程的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">7.8.2.</span> <span class="toc-text">2. 理论基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">7.8.2.1.</span> <span class="toc-text">核心思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-go-%E8%AF%AD%E8%A8%80-goroutine-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">7.8.2.2.</span> <span class="toc-text">与 Go 语言 goroutine 的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-kotlin-coroutines-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">7.8.2.3.</span> <span class="toc-text">与 Kotlin Coroutines 的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-python-trio-%E5%BA%93%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.8.2.4.</span> <span class="toc-text">与 Python Trio 库的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-java-%E4%B8%AD%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">7.8.3.</span> <span class="toc-text">3. Java 中的演进</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jep-428-structured-concurrency-incubator-jdk-19"><span class="toc-number">7.8.3.1.</span> <span class="toc-text">JEP 428: Structured Concurrency (Incubator) - JDK 19</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jep-437-structured-concurrency-second-incubator-jdk-20"><span class="toc-number">7.8.3.2.</span> <span class="toc-text">JEP 437: Structured Concurrency (Second Incubator) - JDK 20</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jep-453-structured-concurrency-preview-jdk-21"><span class="toc-number">7.8.3.3.</span> <span class="toc-text">JEP 453: Structured Concurrency (Preview) - JDK 21</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jep-462-structured-concurrency-second-preview-jdk-22"><span class="toc-number">7.8.3.4.</span> <span class="toc-text">JEP 462: Structured Concurrency (Second Preview) - JDK 22</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E6%BC%94%E8%BF%9B%E5%AF%B9%E6%AF%94"><span class="toc-number">7.8.3.5.</span> <span class="toc-text">版本演进对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E6%A0%B8%E5%BF%83-api"><span class="toc-number">7.8.4.</span> <span class="toc-text">4. 核心 API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#structuredtaskscope-%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.8.4.1.</span> <span class="toc-text">StructuredTaskScope 设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shutdownonfailure-%E7%AD%96%E7%95%A5"><span class="toc-number">7.8.4.2.</span> <span class="toc-text">ShutdownOnFailure 策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shutdownonsuccess-%E7%AD%96%E7%95%A5"><span class="toc-number">7.8.4.3.</span> <span class="toc-text">ShutdownOnSuccess 策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8D%8F%E5%90%8C"><span class="toc-number">7.8.4.4.</span> <span class="toc-text">与虚拟线程的协同</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.8.5.</span> <span class="toc-text">5. 实际应用场景</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.8.5.1.</span> <span class="toc-text">典型使用模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F-1-fan-out-fan-in"><span class="toc-number">7.8.5.1.1.</span> <span class="toc-text">模式 1: Fan-Out &#x2F; Fan-In</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F-2-%E7%AB%9E%E4%BA%89%E6%A8%A1%E5%BC%8F-race"><span class="toc-number">7.8.5.1.2.</span> <span class="toc-text">模式 2: 竞争模式 (Race)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F-3-%E6%89%B9%E9%87%8F%E5%A4%84%E7%90%86"><span class="toc-number">7.8.5.1.3.</span> <span class="toc-text">模式 3: 批量处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F-4-%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%A4%84%E7%90%86"><span class="toc-number">7.8.5.1.4.</span> <span class="toc-text">模式 4: 服务器处理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F-executorservice-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">7.8.5.2.</span> <span class="toc-text">与传统 ExecutorService 的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.8.5.3.</span> <span class="toc-text">最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8-try-with-resources"><span class="toc-number">7.8.5.3.1.</span> <span class="toc-text">1. 正确使用 try-with-resources</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%AD%A3%E7%A1%AE%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="toc-number">7.8.5.3.2.</span> <span class="toc-text">2. 正确处理异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%93%8D%E5%BA%94%E4%B8%AD%E6%96%AD"><span class="toc-number">7.8.5.3.3.</span> <span class="toc-text">3. 响应中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E9%81%BF%E5%85%8D%E8%BF%87%E6%B7%B1%E7%9A%84%E5%B5%8C%E5%A5%97"><span class="toc-number">7.8.5.3.4.</span> <span class="toc-text">4. 避免过深的嵌套</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%90%88%E7%90%86%E4%BD%BF%E7%94%A8%E8%B6%85%E6%97%B6"><span class="toc-number">7.8.5.3.5.</span> <span class="toc-text">5. 合理使用超时</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7"><span class="toc-number">7.8.6.</span> <span class="toc-text">6. 可观测性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%80%BB%E7%BB%93"><span class="toc-number">7.8.7.</span> <span class="toc-text">7. 总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">7.8.7.1.</span> <span class="toc-text">结构化并发的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB%E5%BB%BA%E8%AE%AE"><span class="toc-number">7.8.7.2.</span> <span class="toc-text">迁移建议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%AA%E6%9D%A5%E5%B1%95%E6%9C%9B"><span class="toc-number">7.8.7.3.</span> <span class="toc-text">未来展望</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>