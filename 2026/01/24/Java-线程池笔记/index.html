<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 线程池笔记 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从执行器到线程池（from executor interface to thread pool implementation）  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 线程池笔记">
<meta property="og:url" content="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="从执行器到线程池（from executor interface to thread pool implementation）  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png">
<meta property="article:published_time" content="2026-01-24T13:50:09.000Z">
<meta property="article:modified_time" content="2026-02-23T11:31:00.267Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 线程池笔记",
  "url": "https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png",
  "datePublished": "2026-01-24T13:50:09.000Z",
  "dateModified": "2026-02-23T11:31:00.267Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 线程池笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 线程池笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java 线程池笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-24T13:50:09.000Z" title="Created 2026-01-24 21:50:09">2026-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-23T11:31:00.267Z" title="Updated 2026-02-23 19:31:00">2026-02-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">99.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>390mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>从执行器到线程池（from executor interface to thread pool implementation）</h1>
<blockquote>
<p>Pooling is the grouping together of resources (assets, equipment,<br>
personnel, effort, etc.) for the purposes of maximizing advantage or<br>
minimizing risk to the users. The term is used in finance, computing<br>
and equipment management.——wikipedia</p>
<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p>
<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p>
<p>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection<br>
Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池(Object<br>
Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</p>
</blockquote>
<h3 id="本文模式总览">本文模式总览</h3>
<p>本文从源码和实践两个维度剖析 Java 线程池，提炼出以下可迁移的设计模式和工程实践模式。读者可先浏览此表建立全局认知，再深入各章节：</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>模式</th>
<th>章节</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>工程实践</strong></td>
<td>线程池选型三板斧</td>
<td><a href="#threadpoolexecutor-%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5">ThreadPoolExecutor 监控与调优实践</a></td>
</tr>
<tr>
<td></td>
<td>有界队列+明确拒绝策略</td>
<td><a href="#%E4%BB%BB%E5%8A%A1%E7%BC%93%E5%86%B2%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97">任务缓冲：阻塞队列</a></td>
</tr>
<tr>
<td></td>
<td>ThreadFactory 命名</td>
<td><a href="#threadpoolexecutor-%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5">ThreadPoolExecutor 监控与调优实践</a></td>
</tr>
<tr>
<td></td>
<td>池隔离原则</td>
<td><a href="#threadpoolexecutor-%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5">ThreadPoolExecutor 监控与调优实践</a></td>
</tr>
<tr>
<td></td>
<td>Spring @Scheduled 单线程陷阱</td>
<td><a href="#spring-scheduled-%E7%9A%84%E9%BB%98%E8%AE%A4%E9%99%B7%E9%98%B1%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8">Spring @Scheduled 的默认陷阱</a></td>
</tr>
<tr>
<td><strong>调度策略</strong></td>
<td>Rate vs Delay</td>
<td><a href="#scheduledthreadpoolexecutor-%E8%AF%A6%E8%A7%A3">ScheduledThreadPoolExecutor 详解</a></td>
</tr>
<tr>
<td></td>
<td>周期任务防御性编程</td>
<td><a href="#scheduledthreadpoolexecutor-%E8%AF%A6%E8%A7%A3">ScheduledThreadPoolExecutor 详解</a></td>
</tr>
<tr>
<td></td>
<td>cancel 后清理队列</td>
<td><a href="#scheduledthreadpoolexecutor-%E8%AF%A6%E8%A7%A3">ScheduledThreadPoolExecutor 详解</a></td>
</tr>
<tr>
<td><strong>并发设计</strong></td>
<td>CAS + 锁分层</td>
<td><a href="#mainlock%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%92%E6%96%A5%E9%94%81">mainLock：线程池的全局互斥锁</a></td>
</tr>
<tr>
<td></td>
<td>Worker 不可重入锁</td>
<td><a href="#worker-%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%8E%E9%94%81%E7%8A%B6%E6%80%81">Worker 类定义与锁状态</a></td>
</tr>
<tr>
<td></td>
<td>FutureTask 状态机</td>
<td><a href="#futuretask%E4%BB%BB%E5%8A%A1%E5%8C%85%E8%A3%85%E7%9A%84%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0">FutureTask：任务包装的标准实现</a></td>
</tr>
<tr>
<td><strong>异步编排</strong></td>
<td>execute vs submit</td>
<td><a href="#%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%85%A5%E5%8F%A3submit-%E4%B8%8E-execute">任务提交入口：submit 与 execute</a></td>
</tr>
<tr>
<td></td>
<td>CompletableFuture 异步编排</td>
<td><a href="#completablefuture">CompletableFuture</a></td>
</tr>
<tr>
<td></td>
<td>CompletableFuture 完成保证</td>
<td><a href="#%E5%AE%8C%E6%88%90%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%88%99">完成保证原则</a></td>
</tr>
<tr>
<td></td>
<td>shutdown 优雅关闭</td>
<td><a href="#%E5%B0%9D%E8%AF%95%E5%85%B3%E9%97%AD-threadpoolexecutor">尝试关闭 ThreadPoolExecutor</a></td>
</tr>
<tr>
<td><strong>未来方向</strong></td>
<td>虚拟线程使用原则</td>
<td><a href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99">虚拟线程的使用原则</a></td>
</tr>
</tbody>
</table>
<p>Doug Lea 对线程池的期待有：</p>
<ol>
<li>改善性能。</li>
<li>有界地利用资源（多次强调 bounds）。</li>
<li>提供统计。</li>
</ol>
<h2 id="执行器继承体系">执行器继承体系</h2>
<p>“设计良好的API应该简单、一致、可扩展。”</p>
<p><img src="ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="ThreadPoolExecutorUML类图.png"></p>
<p>我们将任务交给执行器，于是有了执行器（executor）；我们将执行器内部用 FutureTask 包装任务，于是有了同步转异步，异步转同步的设计，和多种 API（ExecutorService 和 AbstractExecutorService）；我们将执行器用线程池来实现，于是我们得到了线程池执行器（ThreadPoolExecutor）。</p>
<ul>
<li>Executor：只定义&quot;执行&quot;契约</li>
<li>ExecutorService：定义生命周期、 多种任务类型（Runnable/Callable）、批量任务契约</li>
</ul>
<p><strong>这两层都是契约层，方法之间没有明确关联</strong>。</p>
<ul>
<li>AbstractExecutorService：只提供算法模板-这一层提供了其他执行方法在 execute 之上的实现，把 api 关联起来。但是唯独 execute 的实现空余了。也没有提供工作线程和拥塞队列的实现。</li>
<li>ThreadPoolExecutor：只实现 execute，并且围绕它搭建了一整套线程池的参考实现：Worker + 状态机 + 队列 + 拒绝策略 + 线程工厂。</li>
<li>FutureTask：只负责任务包装。但是它的<strong>两个父接口让它成为连接了 <code>execute(Runnable)</code>和<code>Future.get()</code>两个世界的桥梁</strong>。</li>
</ul>
<pre><code class="hljs mermaid">classDiagram
    direction TB
    
    %% ========== 设计原则注释 ==========
    note for ThreadPoolExecutor &quot;普通任务：生产者-消费者模式&quot;
    note for ForkJoinPool &quot;并行计算：工作窃取模式&quot;
    
    %% ========== 契约层 ==========
    class Executor &#123;
        &lt;&lt;interface&gt;&gt;
        +execute(Runnable command) void
        note: &quot;契约层：只定义&#x27;执行&#x27;契约&quot;
    &#125;
    
    class ExecutorService &#123;
        &lt;&lt;interface&gt;&gt;
        +submit(Callable~T~ task) Future~T~
        +invokeAll(Collection~Callable~T~~ tasks) List~Future~T~~
        +invokeAny(Collection~Callable~T~~ tasks) T
        +shutdown() void
        +awaitTermination(long timeout, TimeUnit unit) boolean
        note: &quot;契约层：生命周期+批量任务&quot;
    &#125;
    
    class ScheduledExecutorService &#123;
        &lt;&lt;interface&gt;&gt;
        +schedule(Runnable command, long delay, TimeUnit unit) ScheduledFuture~?~
        +schedule(Callable~V~ callable, long delay, TimeUnit unit) ScheduledFuture~V~
        +scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) ScheduledFuture~?~
        +scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) ScheduledFuture~?~
        note: &quot;契约层：延迟和周期任务&quot;
    &#125;
    
    class Future &#123;
        &lt;&lt;interface&gt;&gt;
        +cancel(boolean mayInterruptIfRunning) boolean
        +isCancelled() boolean
        +isDone() boolean
        +get() V
        +get(long timeout, TimeUnit unit) V
    &#125;
    
    class RunnableFuture &#123;
        &lt;&lt;interface&gt;&gt;
        note: &quot;标记接口：Runnable+Future&quot;
    &#125;
    
    class ScheduledFuture &#123;
        &lt;&lt;interface&gt;&gt;
    &#125;
    
    class RunnableScheduledFuture &#123;
        &lt;&lt;interface&gt;&gt;
        +isPeriodic() boolean
    &#125;
    
    class RejectedExecutionHandler &#123;
        &lt;&lt;interface&gt;&gt;
        +rejectedExecution(Runnable r, ThreadPoolExecutor executor) void
        note: &quot;策略模式：饱和处理&quot;
    &#125;
    
    class ThreadFactory &#123;
        &lt;&lt;interface&gt;&gt;
        +newThread(Runnable r) Thread
    &#125;
    
    %% ========== 模板层 ==========
    class AbstractExecutorService &#123;
        &lt;&lt;abstract&gt;&gt;
        #newTaskFor(Callable~T~ callable) RunnableFuture~T~
        #newTaskFor(Runnable runnable, V value) RunnableFuture~V~
        +submit(Callable~T~ task) Future~T~
        +submit(Runnable task, V result) Future~V~
        +invokeAll(Collection~Callable~T~~ tasks) List~Future~T~~
        +invokeAny(Collection~Callable~T~~ tasks) T
        note: &quot;模板层：默认实现&quot;
    &#125;
    
    %% ========== 实现层 - ThreadPoolExecutor ==========
    class ThreadPoolExecutor &#123;
        -corePoolSize: int
        -maximumPoolSize: int
        -keepAliveTime: long
        -workQueue: BlockingQueue~Runnable~
        -workers: HashSet~Worker~
        -ctl: AtomicInteger
        -threadFactory: ThreadFactory
        -handler: RejectedExecutionHandler
        +execute(Runnable command) void
        +shutdown() void
        +shutdownNow() List~Runnable~
        +beforeExecute(Thread t, Runnable r) void
        +afterExecute(Runnable r, Throwable t) void
        #terminated() void
        note: &quot;ctl:高3位状态+低29位线程数&quot;
    &#125;
    
    class Worker &#123;
        -thread: Thread
        -firstTask: Runnable
        -completedTasks: long
        +run() void
        +lock() void
        +unlock() void
        +isLocked() boolean
        +tryLock() boolean
        note: &quot;继承AQS的不可重入锁&quot;
    &#125;
    
    class FutureTask &#123;
        -callable: Callable~V~
        -outcome: Object
        -state: int
        -runner: Thread
        -waiters: WaitNode
        +run() void
        +get() V
        +get(long timeout, TimeUnit unit) V
        +cancel(boolean mayInterruptIfRunning) boolean
        +isCancelled() boolean
        +isDone() boolean
        -set(V v) boolean
        -setException(Throwable t) void
        -report(int s) V
        note: &quot;状态机:NEW→COMPLETING→NORMAL/EXCEPTIONAL&quot;
    &#125;
    
    class AbortPolicy &#123;
        +rejectedExecution(Runnable r, ThreadPoolExecutor executor) void
    &#125;
    
    class CallerRunsPolicy &#123;
        +rejectedExecution(Runnable r, ThreadPoolExecutor executor) void
    &#125;
    
    class DiscardPolicy &#123;
        +rejectedExecution(Runnable r, ThreadPoolExecutor executor) void
    &#125;
    
    class DiscardOldestPolicy &#123;
        +rejectedExecution(Runnable r, ThreadPoolExecutor executor) void
    &#125;
    
    %% ========== 实现层 - ScheduledThreadPoolExecutor ==========
    class ScheduledThreadPoolExecutor &#123;
        -delayedWorkQueue: DelayedWorkQueue
        -removeOnCancel: boolean
        +schedule(Runnable command, long delay, TimeUnit unit) ScheduledFuture~?~
        +schedule(Callable~V~ callable, long delay, TimeUnit unit) ScheduledFuture~V~
        +scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) ScheduledFuture~?~
        +scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) ScheduledFuture~?~
        +decorateTask(Runnable runnable, RunnableScheduledFuture~?~ task) RunnableScheduledFuture~?~
        +decorateTask(Callable~V~ callable, RunnableScheduledFuture~V~ task) RunnableScheduledFuture~V~
        +setRemoveOnCancelPolicy(boolean removeOnCancel) void
        note: &quot;基于DelayQueue的延迟调度&quot;
    &#125;
    
    class ScheduledFutureTask &#123;
        -time: long
        -sequenceNumber: long
        -period: long
        -outerTask: RunnableScheduledFuture~V~
        +run() void
        +runAndReset() boolean
        +isPeriodic() boolean
        +getDelay(TimeUnit unit) long
        +compareTo(Delayed other) int
        -setNextRunTime() void
        -reExecutePeriodic(RunnableScheduledFuture~?~ task) void
        note: &quot;period&gt;0:固定频率;period&lt;0:固定延迟&quot;
    &#125;
    
    class DelayedWorkQueue &#123;
        -queue: RunnableScheduledFuture~?~[]
        -size: int
        -leader: Thread
        -lock: ReentrantLock
        -available: Condition
        +offer(RunnableScheduledFuture~?~ e) boolean
        +take() RunnableScheduledFuture~?~
        +poll() RunnableScheduledFuture~?~
        +poll(long timeout, TimeUnit unit) RunnableScheduledFuture~?~
        +peek() RunnableScheduledFuture~?~
        +size() int
        +clear() void
        note: &quot;堆实现+leader机制&quot;
    &#125;
    
    class Delayed &#123;
        &lt;&lt;interface&gt;&gt;
        +getDelay(TimeUnit unit) long
    &#125;
    
    %% ========== 实现层 - ForkJoinPool ==========
    class ForkJoinPool &#123;
        -parallelism: int
        -workQueues: WorkQueue[]
        +execute(ForkJoinTask~?~ task) void
        +submit(ForkJoinTask~T~ task) ForkJoinTask~T~
        +invoke(ForkJoinTask~T~ task) T
        note: &quot;工作窃取:双端队列(LIFO/FIFO)&quot;
    &#125;
    
    class ForkJoinWorkerThread &#123;
        -pool: ForkJoinPool
        -workQueue: WorkQueue
        +run() void
        +onStart() void
        +onTermination(Throwable exception) void
    &#125;
    
    class WorkQueue &#123;
        -array: ForkJoinTask~?~[]
        -base: int
        -top: int
        -ctl: int
        -pool: ForkJoinPool
        -owner: ForkJoinWorkerThread
        +push(ForkJoinTask~?~ task) int
        +pop() ForkJoinTask~?~
        +poll() ForkJoinTask~?~
        +tryUnpush(ForkJoinTask~?~ task) boolean
        +growArray() ForkJoinTask~?~[]
        note: &quot;array容量8192起,base/top无锁&quot;
    &#125;
    
    class ForkJoinTask &#123;
        &lt;&lt;abstract&gt;&gt;
        -status: int
        +fork() ForkJoinTask~T~
        +join() T
        +invoke() T
        +tryUnfork() boolean
        +quietlyComplete() void
        note: &quot;增强Future:fork/join语义+工作窃取支持&quot;
    &#125;
    
    class RecursiveTask &#123;
        &lt;&lt;abstract&gt;&gt;
        +compute() V
    &#125;
    
    class RecursiveAction &#123;
        &lt;&lt;abstract&gt;&gt;
        +compute() void
    &#125;
    
    class CountedCompleter &#123;
        &lt;&lt;abstract&gt;&gt;
        -completer: CountedCompleter~?~
        -pending: int
        +compute() void
        +onCompletion(CountedCompleter~?~ caller) void
        +tryComplete() void
        +propagateCompletion() void
        +addToPendingCount(int delta) void
        note: &quot;JDK8 Stream并行实现的核心载体&quot;
    &#125;
    
    class Runnable &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    
    %% ========== 继承关系（放在类定义之后）==========
    Executor &lt;|-- ExecutorService
    ExecutorService &lt;|-- ScheduledExecutorService
    ExecutorService &lt;|-- AbstractExecutorService
    AbstractExecutorService &lt;|-- ThreadPoolExecutor
    AbstractExecutorService &lt;|-- ForkJoinPool
    ThreadPoolExecutor &lt;|-- ScheduledThreadPoolExecutor
    
    Future &lt;|-- RunnableFuture
    RunnableFuture &lt;|.. FutureTask
    Future &lt;|-- ForkJoinTask
    Future &lt;|-- ScheduledFuture
    RunnableScheduledFuture --|&gt; ScheduledFuture
    RunnableScheduledFuture --|&gt; Runnable
    ScheduledFutureTask ..|&gt; RunnableScheduledFuture
    Delayed &lt;|.. ScheduledFutureTask
    
    ForkJoinTask &lt;|-- RecursiveTask
    ForkJoinTask &lt;|-- RecursiveAction
    ForkJoinTask &lt;|-- CountedCompleter
    
    RunnableFuture --|&gt; Runnable
    
    RejectedExecutionHandler &lt;|.. AbortPolicy
    RejectedExecutionHandler &lt;|.. CallerRunsPolicy
    RejectedExecutionHandler &lt;|.. DiscardPolicy
    RejectedExecutionHandler &lt;|.. DiscardOldestPolicy
    
    %% ========== 组合关系 ==========
    AbstractExecutorService ..&gt; FutureTask : creates
    ThreadPoolExecutor o-- Worker : manages
    ThreadPoolExecutor --&gt; RejectedExecutionHandler : uses
    ThreadPoolExecutor --&gt; ThreadFactory : uses
    
    ScheduledThreadPoolExecutor o-- ScheduledFutureTask : manages
    ScheduledThreadPoolExecutor --&gt; DelayedWorkQueue : uses
    
    ForkJoinPool o-- ForkJoinWorkerThread : manages
    ForkJoinWorkerThread --&gt; WorkQueue : owns
    WorkQueue --&gt; ForkJoinTask : stores
    
    Executors ..&gt; ThreadPoolExecutor : creates
    Executors ..&gt; ScheduledThreadPoolExecutor : creates
    Executors ..&gt; ForkJoinPool : creates
    
    %% ========== 工具类 ==========
    class Executors &#123;
        &lt;&lt;utility&gt;&gt;
        +newFixedThreadPool(int nThreads) ExecutorService
        +newCachedThreadPool() ExecutorService
        +newSingleThreadExecutor() ExecutorService
        +newScheduledThreadPool(int corePoolSize) ScheduledExecutorService
        +newWorkStealingPool() ExecutorService
        +defaultThreadFactory() ThreadFactory
        note: &quot;工厂方法(已不推荐)&quot;
    &#125;
    
    class TimeUnit &#123;
        &lt;&lt;enum&gt;&gt;
        NANOSECONDS
        MICROSECONDS
        MILLISECONDS
        SECONDS
        +toNanos(long d) long
        +toMillis(long d) long
        +sleep(long timeout) void
    &#125;</code></pre>
<h3 id="父子孙">父子孙</h3>
<p>从上述类图可提炼出清晰的继承层次：</p>
<ul>
<li><strong>ThreadPoolExecutor</strong> 与 <strong>ForkJoinPool</strong> 是兄弟关系，都继承自 <strong>AbstractExecutorService</strong></li>
<li><strong>ScheduledThreadPoolExecutor</strong> 是 <strong>ThreadPoolExecutor</strong> 的子类，是 <strong>AbstractExecutorService</strong> 的孙子</li>
</ul>
<h3 id="executor-接口">Executor 接口</h3>
<p>将任务提交和任务执行进行解耦（<strong>decoupling the execution mechanic</strong>）。用户无需关注如何创建线程，如何调度线程（scheduling）来执行任务，用户只需提供 Runnable 对象，将任务的运行逻辑提交到执行器(Executor)中，由 Executor 框架完成线程的调配和任务的执行部分。</p>
<p>JUC 里所有的解耦设计都不一定是异步的，它只是<strong>解耦</strong>，所以执行器本身也是可以同步执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-comment">// 这个类型只有这一个核心方法</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable r)</span> &#123;<br>     r.run();<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>一般而言可以认为，executor 会 spawns a new thread for each task.</p>
<h3 id="executorservice-接口">ExecutorService 接口</h3>
<p>增加了一些能力：</p>
<p>扩充执行任务的能力，补充可以为一个或一批异步任务<strong>生成 Future 的方法</strong>（），<strong>从这里开始执行器开始可以执行异步任务</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 立即返回:Future.get 不一定可用</span><br><span class="hljs-comment">// public Future&lt;?&gt; submit(Runnable task)</span><br><span class="hljs-comment">// 这个 api 是很神奇的,本质上 runnable 是没有返回值的,这相当于帮我们给一个 runnable 带上一个线程运行结束的结果</span><br><span class="hljs-comment">// public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result)</span><br><span class="hljs-comment">// 立即返回:Future.get 已经可用(调用 get() 时才会阻塞直到任务完成)</span><br><span class="hljs-comment">// public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task)</span><br><span class="hljs-comment">// 执行并返回任意一个成功完成的任务结果</span><br><span class="hljs-comment">// &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException</span><br><span class="hljs-comment">// 执行并返回任意一个成功完成的任务结果(带超时)</span><br><span class="hljs-comment">// &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException</span><br><span class="hljs-comment">// 执行所有任务并返回结果列表</span><br><span class="hljs-comment">// &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException</span><br><span class="hljs-comment">// 执行所有任务并返回结果列表(带超时)</span><br><span class="hljs-comment">// &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException</span><br></code></pre></td></tr></table></figure>
<p>在上面的方法里，submit 能接收无结果的 Runnable、有结果的 Runnable、能返回结果的 Callable，再加上底层无返回结果的 execute，构成了4个基础的单任务api。</p>
<p>ExecutorService 还提供了管控线程池的方法，比如停止线程池的运行。</p>
<ul>
<li>shutdown 拒绝接收任务，<strong>触发 rejection policy</strong>。</li>
<li>shutdownNow 除了 shutdown 的功能以外，还会<strong>强制触发线程中断</strong>。系统内置的被动触发包括：线程池饱和、awaitTermination超时、周期任务异常、tryTerminate。</li>
</ul>
<h3 id="abstractexecutorservice">AbstractExecutorService</h3>
<p>将执行任务的流程串联起来，保证下层实现只需关注 <code>execute()</code> 方法：</p>
<ul>
<li>大部分任务接口在这一层有了实现，最终都调向 execute()</li>
<li>生命周期接口留给下层实现</li>
</ul>
<p>详细实现原理（newTaskFor 工厂方法、任务包装机制、模板方法模式）见 <a href="#abstractexecutorservice-%E8%AF%A6%E8%A7%A3">AbstractExecutorService 详解</a> 章节。</p>
<h3 id="threadpoolexecutor">ThreadPoolExecutor</h3>
<p>实现了 execute，围绕 execute 的批量和异步化给出了一个经典的线程池执行器实现。</p>
<p>将会一方面维护自身的生命周期，另一方面同时管理线程（Thread）和任务（Task，也就是 Runnable），使两者良好的结合从而执行并行任务。</p>
<p>execute 的三段式判断体现了生产者-消费者解耦模型：当 <code>workerCount &lt; corePoolSize</code> 时创建核心线程，任务作为 <code>firstTask</code> 直接传递给 Worker；当队列未满时入队等待，阻塞队列成为生产者与消费者之间的桥梁；当核心线程数已满、队列已满（入队失败）且<code> workerCount &lt; maximumPoolSize</code>时创建非核心线程，同样以 <code>firstTask</code> 方式传递。无论哪种路径，真正的消费者都是 Worker 线程的 <code>runWorker</code> 循环——它先消费 <code>firstTask</code>，后续通过 <code>getTask()</code> 从队列持续消费。</p>
<p><img src="ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="ThreadPoolExecutor运行流程.png"></p>
<h3 id="scheduledexecutorservice-接口">ScheduledExecutorService 接口</h3>
<p>ScheduledExecutorService 扩展了 ExecutorService 接口，专门用于支持延迟执行和周期性执行的任务调度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ========== 一次性延迟执行 ==========</span><br><span class="hljs-comment">// 延迟执行 Runnable 任务（无返回值）</span><br><span class="hljs-comment">// public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit)</span><br><span class="hljs-comment">// 延迟执行 Callable 任务（有返回值）</span><br><span class="hljs-comment">// public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit)</span><br><br><span class="hljs-comment">// ========== 周期性执行 ==========</span><br><span class="hljs-comment">// 固定频率执行（从上次任务开始计时）</span><br><span class="hljs-comment">// public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</span><br><span class="hljs-comment">// 固定延迟执行（从上次任务完成计时）</span><br><span class="hljs-comment">// public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit)</span><br></code></pre></td></tr></table></figure>
<p><strong>两种周期模式的时间计算差异</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>时间计算基准</th>
<th>任务耗时 &gt; period 时的行为</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>scheduleAtFixedRate</code></td>
<td>上次<strong>开始时间</strong> + period</td>
<td>等待完成后立即执行下一次（追赶）</td>
<td>心跳检测、定时采样</td>
</tr>
<tr>
<td><code>scheduleWithFixedDelay</code></td>
<td>上次<strong>完成时间</strong> + delay</td>
<td>严格保证任务间隔</td>
<td>任务队列处理、限流场景</td>
</tr>
</tbody>
</table>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">scheduleAtFixedRate<span class="hljs-params">(<span class="hljs-attr">period</span>=1s)</span> 执行时间轴：<br>|<span class="hljs-params">-----</span> delay <span class="hljs-params">-----</span>|<span class="hljs-params">---</span> period <span class="hljs-params">---</span>|<span class="hljs-params">---</span> period <span class="hljs-params">---</span>|<span class="hljs-params">---</span> period <span class="hljs-params">---</span>|<br>                      [task1]       [task2]       [task3]<br>语义：尝试按固定频率触发，若任务耗时超过 period 则完成后立即追赶<br><br>scheduleWithFixedDelay<span class="hljs-params">(<span class="hljs-attr">delay</span>=1s)</span> 执行时间轴：<br>|<span class="hljs-params">-----</span> delay <span class="hljs-params">-----</span>|<span class="hljs-params">---</span> task <span class="hljs-params">---</span>|<span class="hljs-params">---</span> delay <span class="hljs-params">---</span>|<span class="hljs-params">---</span> task <span class="hljs-params">---</span>|<br>                      [task1]       [task2]<br>语义：每次完成后等待固定延迟再执行，严格保证任务间隔<br><br>示例：delay=1s，任务执行0.5s → 每1.5秒执行一次；任务执行2s → 每3秒执行一次<br></code></pre></td></tr></table></figure>
<p><strong>核心特性</strong>：</p>
<ul>
<li>支持一次性延迟执行</li>
<li>支持固定频率/固定延迟两种周期模式</li>
<li>返回 ScheduledFuture 用于任务控制和结果获取</li>
</ul>
<p><strong>实现类</strong>：</p>
<ul>
<li><code>ScheduledThreadPoolExecutor</code> 是主要实现</li>
<li>内部使用 <code>DelayedWorkQueue</code>（基于二叉堆的优先级队列）</li>
<li>任务通过 <code>ScheduledFutureTask</code> 封装，支持时间管理和周期计算</li>
</ul>
<blockquote>
<p><strong>详细说明</strong>：关于内部实现机制、核心组件架构、任务调度原理等内容，请参阅第2章《ScheduledThreadPoolExecutor 详解》。</p>
</blockquote>
<h3 id="scheduledthreadpoolexecutor-对-threadpoolexecutor-的扩展">ScheduledThreadPoolExecutor 对 ThreadPoolExecutor 的扩展</h3>
<p>ScheduledExecutorService 接口定义了定时调度的契约，而 ScheduledThreadPoolExecutor 是其主要实现。其类声明体现了双重设计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span><br>        <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ScheduledExecutorService</span><br></code></pre></td></tr></table></figure>
<p>这形成了一个清晰的扩展层次：</p>
<ul>
<li><strong>接口层</strong>：ScheduledExecutorService 扩展 ExecutorService，新增定时调度契约</li>
<li><strong>实现层</strong>：ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor，复用线程池核心能力</li>
</ul>
<p><strong>核心扩展点</strong>：</p>
<table>
<thead>
<tr>
<th>扩展维度</th>
<th>ThreadPoolExecutor</th>
<th>ScheduledThreadPoolExecutor</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>队列</strong></td>
<td>外部传入 <code>BlockingQueue</code></td>
<td>强制使用 <code>DelayedWorkQueue</code>（二叉堆）</td>
</tr>
<tr>
<td><strong>任务封装</strong></td>
<td><code>FutureTask</code></td>
<td><code>ScheduledFutureTask</code>（新增 time/period 字段）</td>
</tr>
<tr>
<td><strong>execute()</strong></td>
<td>直接入队执行</td>
<td>重写为 <code>schedule(command, 0, NANOSECONDS)</code></td>
</tr>
<tr>
<td><strong>submit()</strong></td>
<td>通过 execute()</td>
<td>同样走 schedule(0) 路径</td>
</tr>
<tr>
<td><strong>新增方法</strong></td>
<td>无</td>
<td>schedule 系列、setRemoveOnCancelPolicy、decorateTask</td>
</tr>
</tbody>
</table>
<p><strong>设计要点</strong>：</p>
<ol>
<li>
<p><strong>队列强制绑定</strong>：构造器不接受外部队列参数，在 super() 调用中硬编码 DelayedWorkQueue</p>
</li>
<li>
<p><strong>任务周期管理</strong>：ScheduledFutureTask 通过 period 字段区分一次性任务（0）、fixed-rate（正数）、fixed-delay（负数）</p>
</li>
<li>
<p><strong>线程池复用</strong>：完全继承 ThreadPoolExecutor 的 Worker 管理、状态机、拒绝策略机制</p>
<blockquote>
<p><strong>Worker 机制复用解析</strong>：延时线程池确实能够完全复用 ThreadPoolExecutor 的 Worker 机制，关键在于<strong>队列的阻塞语义</strong>。Worker 线程的 <code>getTask()</code> 方法调用 <code>queue.take()</code> 获取任务，<strong>而 <code>DelayedWorkQueue.take()</code> 会阻塞直到队首任务到期</strong>。Worker 线程对此完全无感知——它只是在队列上等待，取到任务后执行。换言之，<strong>延时逻辑封装在队列层而非 Worker 层</strong>，这正是 ThreadPoolExecutor 将队列设计为可扩展组件的精妙之处：通过替换队列实现，无需修改 Worker 代码即可支持延时调度。</p>
<p><strong>任务提交路径</strong>：ScheduledThreadPoolExecutor 的 <code>execute()</code> 和 <code>schedule()</code> 都<strong>没有调用父类的 <code>execute()</code></strong>。<code>execute()</code> 被重写为 <code>schedule(command, 0, NANOSECONDS)</code>，而 <code>schedule()</code> 内部通过 <code>delayedExecute()</code> 直接调用 <code>super.getQueue().add(task)</code> 向队列投递任务，并调用 <code>ensurePrestart()</code> 确保有线程运行。这跳过了 ThreadPoolExecutor 原生的入队逻辑，强制所有任务走 DelayedWorkQueue。</p>
<p><strong>生产者-消费者解耦</strong>：Worker 线程的运行与 <code>execute()</code>/<code>schedule()</code> 是解耦的。后者只是生产者，向队列投递任务；Worker 线程一旦启动，就在 <code>runWorker()</code> 的 while 循环中自主运行，通过 <code>getTask()</code> 从队列消费任务。两者通过队列连接，互不直接驱动。</p>
</blockquote>
</li>
<li>
<p><strong>API 兼容</strong>：execute/submit 语义保持不变，内部转换为即时调度</p>
<blockquote>
<p><strong>API 主次之分</strong>：从设计意图看，<code>execute()</code> 和 <code>submit()</code> 都是通过 <code>schedule(0)</code> 路径实现的，本质上是&quot;延时为 0 的调度&quot;，只是延时封装下的立即执行。真正体现 ScheduledExecutorService 定时调度能力的核心 API 是 <code>schedule()</code>、<code>scheduleAtFixedRate()</code> 和 <code>scheduleWithFixedDelay()</code>，而后者两个周期调度方法永远不会被传统的 AbstractExecutorService 体系（execute/submit/invokeAll/invokeAny）调用。</p>
</blockquote>
</li>
</ol>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">继承关系：<br><br>ExecutorService ←─ <span class="hljs-keyword">ScheduledExecutorService（接口扩展：新增 </span><span class="hljs-keyword">schedule </span>系列）<br>       ↑                        ↑<br>       │                        │<br>ThreadPoolExecutor ←─ <span class="hljs-keyword">ScheduledThreadPoolExecutor（类继承：复用 </span>+ 扩展）<br></code></pre></td></tr></table></figure>
<h3 id="forkjoinpool">ForkJoinPool</h3>
<p>这个线程池本身就是一个复杂框架，为 JDK 其他组件提供 yet another executor alternative。</p>
<p>这个框架有个特点：</p>
<ol>
<li>产生的线程默认是守护线程，其他线程池产生的默认不是守护线程。</li>
<li>产生的线程会自动收缩-不存在空转的 core thread 问题。</li>
<li>公共线程池的名字一般叫“ForkJoinPool.commonPool-worker-1”。</li>
</ol>
<p>这里就要讨论到一个很多人忽略的问题：我们如何决定何时使用守护类线程。这类线程可以用来执行一些：</p>
<ol>
<li>临时执行的任务，这些任务之间如果存在父子关系更好。</li>
<li>后台监控类任务。</li>
<li>可以被中断的计算任务。</li>
</ol>
<blockquote>
<p><strong>规范说明</strong>：根据Java Language Specification §12.8，守护线程的关键特性是&quot;不阻止JVM退出&quot;。因此判断是否使用守护线程的标准应该是：</p>
<ul>
<li>任务是否可以在JVM退出时被安全中断</li>
<li>任务是否需要确保完成（如数据持久化、事务提交）</li>
<li>任务失败是否可以接受或能够重试恢复</li>
</ul>
</blockquote>
<ol start="3">
<li>典型的工作线程池包括两类：
<ul>
<li><strong>IO线程池</strong>：平台线程池的一种，专门处理IO密集型任务（如文件读写、网络请求），通常使用固定大小的线程池（如FixedThreadPool，本质是 ThreadPoolExecutor 的封装）。</li>
<li><strong>计算线程池</strong>：平台线程池的一种，专门处理CPU密集型任务（如数值计算、数据处理），可使用ForkJoinPool等工作窃取线程池。</li>
</ul>
</li>
</ol>
<p>初始化这类线程池有一些简单的工厂方法，比原始构造器更加可用：<code>Executors.newWorkStealingPool(int parallelism)</code>，其余工厂方法见后文。</p>
<p><strong>ForkJoinPool 概述</strong>：</p>
<p>ForkJoinPool 是 Java 7 引入的另一种 <code>ExecutorService</code> 实现，与 <code>ThreadPoolExecutor</code> 走了完全不同的设计路线。它的核心特性包括：</p>
<ul>
<li><strong>工作窃取（Work-Stealing）</strong>：<strong>每个工作线程拥有独立的双端队列（Deque）</strong>，<strong>空闲线程会主动从繁忙线程的队列中&quot;窃取&quot;任务</strong>，实现自动负载均衡。</li>
<li><strong>分治并行（Fork/Join）</strong>：天然支持递归任务分解，通过 <code>ForkJoinTask</code>（<code>RecursiveTask</code>/<code>RecursiveAction</code>）实现分治算法。</li>
<li><strong>asyncMode 参数</strong>：控制工作队列的调度模式——LIFO（默认，适合递归分治）或 FIFO（适合事件驱动场景）。</li>
<li><strong>固定并行度</strong>：线程数通常等于 CPU 核心数，不像 <code>ThreadPoolExecutor</code> 那样动态扩缩容。</li>
</ul>
<p><strong>特性关系澄清</strong>：</p>
<p>这四个特性中，<strong>工作窃取是 ForkJoinPool 的核心基础设施</strong>，无论选择哪种 asyncMode 或任务类型，<strong>工作窃取机制都始终启用</strong>。工作窃取是调度层面的机制（如何分发任务），分治并行是任务层面的模式（如何分解任务），两者是正交关系——工作窃取可服务于非分治任务（如 <code>newWorkStealingPool()</code> 处理普通并行任务），分治算法理论上也可使用其他调度机制。在 ForkJoinPool 的实现中，工作窃取是分治并行的底层支撑，但这不代表两者在概念上存在从属关系。</p>
<p>JDK 提供了两种常用的获取方式：</p>
<ul>
<li><code>ForkJoinPool.commonPool()</code>：全局共享的 ForkJoinPool 实例，<code>parallelStream()</code> 和 <code>CompletableFuture</code> 默认使用。</li>
<li><code>Executors.newWorkStealingPool(int parallelism)</code>：创建独立的工作窃取线程池。</li>
</ul>
<p>关于 ForkJoinPool 的 asyncMode 参数详解、工作窃取机制原理、与 ThreadPoolExecutor 的核心差异对比、commonPool 的任务排队机制等深入内容，详见 <a href="#forkjoinpool%E8%AF%A6%E8%A7%A3-%E5%88%86%E6%B2%BB%E5%B9%B6%E8%A1%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E">ForkJoinPool 详解：分治并行的执行引擎</a> 章节。</p>
<h2 id="小结">小结</h2>
<p>本章介绍了 Java 线程池的核心接口体系，遵循“契约层 → 模板层 → 实现层 → 工厂层”的设计脉络：</p>
<ul>
<li><strong>契约层</strong>：Executor → ExecutorService → ScheduledExecutorService，逐层扩展执行、生命周期、定时调度契约（详见上文各接口章节）</li>
<li><strong>模板层</strong>：AbstractExecutorService 为 <code>submit</code>/<code>invokeAll</code>/<code>invokeAny</code> 提供默认实现，下层只需实现 <code>execute()</code>（详见 <a href="#abstractexecutorservice-%E8%AF%A6%E8%A7%A3">AbstractExecutorService 详解</a>）</li>
<li><strong>实现层</strong>：ThreadPoolExecutor（经典线程池）、ScheduledThreadPoolExecutor（定时调度）、ForkJoinPool（工作窃取）</li>
<li><strong>工厂层</strong>：Executors 静态工厂方法集合（如 <code>newFixedThreadPool</code>、<code>newCachedThreadPool</code>、<code>newWorkStealingPool</code>）</li>
</ul>
<hr>
<h1>AbstractExecutorService 详解</h1>
<p>AbstractExecutorService 将执行任务的流程串联起来，保证下层实现只需关注 <code>execute()</code> 方法。这一层的大部分方法实现遵循以下模式：</p>
<ol>
<li>把任务包装成 FutureTask</li>
<li>用 execute 执行这个 FutureTask</li>
<li>返回 FutureTask 实例供调用者使用</li>
</ol>
<h2 id="newtaskfor：任务包装的核心工厂方法">newTaskFor：任务包装的核心工厂方法</h2>
<p><code>newTaskFor</code> 是 AbstractExecutorService 的核心工厂方法，它负责将用户提交的任务（Runnable 或 Callable）包装成 <code>RunnableFuture</code>，默认返回 FutureTask 实例，但子类可以 override 提供自定义实现。关于 FutureTask 的内部结构（callable/outcome/run 的同级关系、状态机、RunnableAdapter 适配器等），详见 <a href="#threadpoolexecutor-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1">ThreadPoolExecutor 如何管理任务</a> 章节。</p>
<p><strong>方法签名</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractExecutorService.java</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为给定的 Callable 任务返回一个 RunnableFuture</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> callable 有返回值的任务</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 包装后的 RunnableFuture</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为给定的 Runnable 任务返回一个 RunnableFuture。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> runnable 无返回值的任务</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value 任务完成后的返回值（可为 null）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 包装后的 RunnableFuture</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span>;<br></code></pre></td></tr></table></figure>
<p>Runnable 变成 Future，总要配一个 Value，这是一个好的设计模式。</p>
<p><strong>封装关系：把什么东西封装成什么东西？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. Callable&lt;T&gt; -&gt; FutureTask&lt;T&gt;</span><br>Callable&lt;String&gt; callable = () -&gt; <span class="hljs-string">&quot;Hello&quot;</span>;<br>RunnableFuture&lt;String&gt; future = newTaskFor(callable);<br><span class="hljs-comment">// 封装关系：Callable 被封装为 FutureTask</span><br><span class="hljs-comment">// - Callable.call() 提供计算逻辑</span><br><span class="hljs-comment">// - FutureTask 提供 Future 接口（get()、cancel() 等）</span><br><span class="hljs-comment">// - FutureTask 同时实现 Runnable，可以提交给 execute()</span><br><br><span class="hljs-comment">// 2. Runnable + T -&gt; FutureTask&lt;T&gt;</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;Task&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Done&quot;</span>;<br>RunnableFuture&lt;String&gt; future = newTaskFor(runnable, result);<br><span class="hljs-comment">// 封装关系：Runnable + result 被封装为 FutureTask</span><br><span class="hljs-comment">// - Runnable.run() 提供执行逻辑</span><br><span class="hljs-comment">// - result 提供&quot;虚拟&quot;返回值</span><br><span class="hljs-comment">// - FutureTask 提供 Future 接口</span><br></code></pre></td></tr></table></figure>
<p><strong>默认实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractExecutorService 的默认实现</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable);<br>&#125;<br><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么需要 newTaskFor？</strong></p>
<ol>
<li>
<p><strong>解耦任务类型</strong>：</p>
<ul>
<li>用户提交的是 <code>Callable&lt;T&gt;</code> 或 <code>Runnable</code></li>
<li>Executor 接收的是 <code>Runnable</code></li>
<li>Future 接口提供 <code>get()</code> 获取结果</li>
<li><code>newTaskFor</code> 将这三者统一起来</li>
</ul>
</li>
<li>
<p><strong>支持自定义扩展</strong>：<br>
子类可以重写 <code>newTaskFor</code> 来添加自定义逻辑：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义实现示例：添加 RPC 上下文传递</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;<br>    <span class="hljs-comment">// 闭包写法：声明在方法体中，被匿名类捕获为 effectively final 变量</span><br>    <span class="hljs-comment">// Object rpcContext = RpcContext.getCurrent();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable) &#123;<br>        <span class="hljs-comment">// 实例字段写法：声明为匿名类成员，初始化时机同样是 newTaskFor 调用时</span><br>        <span class="hljs-comment">// 两种写法执行时机相同，都会被编译器处理为匿名类的成员字段</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> RpcContext.getCurrent();<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// run() 在工作线程执行，通过实例字段访问提交时保存的上下文</span><br>            RpcContext.set(rpcContext);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                RpcContext.clear();<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li><strong>统一任务包装</strong>：<br>
所有高级方法都依赖 <code>newTaskFor</code>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// submit() 的实现</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);  <span class="hljs-comment">// 使用 newTaskFor</span><br>    execute(ftask);                                <span class="hljs-comment">// 提交给 execute</span><br>    <span class="hljs-keyword">return</span> ftask;                                  <span class="hljs-comment">// 返回 Future</span><br>&#125;<br><br><span class="hljs-comment">// invokeAll() 的实现</span><br><span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tasks == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    List&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(tasks.size());<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">done</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;<br>            RunnableFuture&lt;T&gt; f = newTaskFor(t);  <span class="hljs-comment">// 使用 newTaskFor</span><br>            futures.add(f);<br>            execute(f);<br>        &#125;<br>       <span class="hljs-comment">// 正确</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 异常处理</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// invokeAny() 的实现（简化）</span><br><span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>    <span class="hljs-comment">// 内部使用 ExecutorCompletionService 追踪完成顺序</span><br>    ExecutorCompletionService&lt;T&gt; ecs = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutorCompletionService</span>&lt;T&gt;(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 提交所有任务</span><br>        <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks)<br>            ecs.submit(t);  <span class="hljs-comment">// 内部调用 newTaskFor + execute</span><br>        <span class="hljs-comment">// 轮询等待任意一个任务成功完成</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; tasks.size(); ++i) &#123;<br>            Future&lt;T&gt; f = ecs.take();  <span class="hljs-comment">// 阻塞等待下一个完成的任务</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">return</span> f.get();  <span class="hljs-comment">// 成功则直接返回结果，不返回 Future</span><br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException eex) &#123;<br>                <span class="hljs-comment">// 该任务失败，继续等待下一个</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>(<span class="hljs-string">&quot;No task completed successfully&quot;</span>, <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 取消所有未完成的任务</span><br>        cancelAll(futures);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>invokeAny 为什么返回 T 而不是 Future<T>？</strong></p>
<p>与 <code>submit</code> 和 <code>invokeAll</code> 不同，<code>invokeAny</code> 直接返回结果值 <code>T</code>。这源于语义差异：</p>
<ul>
<li><code>submit</code>/<code>invokeAll</code>：提交任务后立即返回，调用者稍后通过 Future 获取结果——返回时任务可能未完成</li>
<li><code>invokeAny</code>：阻塞等待任意一个任务成功完成——返回时结果已确定，不存在&quot;未来&quot;需要等待</li>
</ul>
<p>如果 <code>invokeAny</code> 返回 <code>Future&lt;T&gt;</code>，调用者必然要调用 <code>get()</code>，而此时 Future 已完成，这层包装毫无价值。直接返回 <code>T</code> 简化了 API 使用，符合&quot;最少意外原则&quot;。</p>
<p>这两个方法的实现透露了得到 future 的诀窍，因为 execute 不带有返回值，<strong>所以要保持 newTaskFor 的返回值引用</strong>，然后任由 execute 去执行，可以说<strong>凡是需要 execute 的最底层，要得到最后的 future 都需要抓住 newTaskFor 的返回值</strong>。</p>
<p>各种方法都需要单一类型的包装和对 <code>execute</code> 的调用，像 <code>invokeAll</code> 和 <code>submit</code> 只是&quot;封装&quot; + <code>execute</code> 的门面，这些门面里还有<strong>间隙</strong>，可以处理 FutureTask 对引用。</p>
<p><strong>封装的核心价值</strong></p>
<table>
<thead>
<tr>
<th>输入</th>
<th>封装过程</th>
<th>输出</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Callable&lt;T&gt;</code></td>
<td><code>newTaskFor()</code></td>
<td><code>FutureTask&lt;T&gt;</code></td>
<td>获得异步结果获取能力</td>
</tr>
<tr>
<td><code>Runnable</code> + <code>T</code></td>
<td><code>newTaskFor()</code></td>
<td><code>FutureTask&lt;T&gt;</code></td>
<td>无返回值任务也能返回结果</td>
</tr>
<tr>
<td>计算逻辑</td>
<td>包装为 <code>Runnable</code> + <code>Future</code></td>
<td>可提交、可等待</td>
<td>统一的异步编程模型</td>
</tr>
</tbody>
</table>
<p><strong>设计模式：工厂方法模式</strong></p>
<pre><code class="hljs mermaid">classDiagram
    class AbstractExecutorService &#123;
        &lt;&lt;abstract&gt;&gt;
        #newTaskFor(Callable~T~) RunnableFuture~T~
        #newTaskFor(Runnable, T) RunnableFuture~T~
        +submit(Callable~T~) Future~T~
        +invokeAll(...) List~Future~T~~
    &#125;
    
    class ThreadPoolExecutor &#123;
        #newTaskFor(Callable~T~) RunnableFuture~T~
        #newTaskFor(Runnable, T) RunnableFuture~T~
    &#125;
    
    class CustomExecutor &#123;
        #newTaskFor(Callable~T~) RunnableFuture~T~
    &#125;
    
    class RunnableFuture &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    
    class Future~T~ &#123;
        &lt;&lt;interface&gt;&gt;
    &#125;
    
    class FutureTask &#123;
        +run()
        +get() T
        +cancel()
    &#125;
    
    RunnableFuture --|&gt; Future : extends
    AbstractExecutorService &lt;|-- ThreadPoolExecutor
    AbstractExecutorService &lt;|-- CustomExecutor
    AbstractExecutorService ..&gt; RunnableFuture : creates via
    FutureTask ..|&gt; RunnableFuture : implements</code></pre>
<p><strong>要点</strong></p>
<p><code>newTaskFor</code> 是连接&quot;同步任务&quot;和&quot;异步执行&quot;的桥梁：</p>
<ol>
<li>它将<strong>计算任务</strong>（Callable/Runnable）封装为<strong>可执行可等待的对象</strong>（FutureTask）</li>
<li>它是 AbstractExecutorService 所有高级方法的基础</li>
<li>它提供了扩展点，允许子类自定义任务包装逻辑，我们常见的自定义 traceId 传递的 newTask 匿名类内部，都有使用扩展的 FutureTask。</li>
<li>它体现了&quot;模板方法模式&quot;：定义算法骨架，子类实现具体步骤</li>
</ol>
<h3 id="futuretask：任务包装的标准实现">FutureTask：任务包装的标准实现</h3>
<h4 id="类型体系与设计定位">类型体系与设计定位</h4>
<p>FutureTask 是 Java 并发框架中「可取消的异步计算」的核心实现（<code>@since 1.5, @author Doug Lea</code>）。它实现了 <code>RunnableFuture&lt;V&gt;</code> 接口，而 <code>RunnableFuture</code> 同时继承了 <code>Runnable</code> 和 <code>Future</code>——这两个接口一个面向线程池（对内执行），一个面向任务调用方（对外获取结果）。FutureTask 是 <code>RunnableFuture</code> 的两个经典实现之一（<code>All Known Implementing Classes: FutureTask, SwingWorker</code>），可以认为它是可执行 Future 的最忠实实现。</p>
<pre><code class="hljs mermaid">classDiagram
    class FutureTask &#123;
        -callable: Callable~V~
        -outcome: Object
        -state: int
        -runner: Thread
        -waiters: WaitNode
        
        +run() void
        +get() V
        +cancel(boolean) boolean
        +isDone() boolean
    &#125;
    note for FutureTask &quot;@since 1.5&quot;
    
    class RunnableFuture &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    note for RunnableFuture &quot;@since 1.6&quot;
    
    class Runnable &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    note for Runnable &quot;@since 1.0&quot;
    
    class Future &#123;
        &lt;&lt;interface&gt;&gt;
        +get() V
        +cancel(boolean) boolean
        +isDone() boolean
    &#125;
    note for Future &quot;@since 1.5&quot;
    
    class Callable &#123;
        &lt;&lt;interface&gt;&gt;
        +call() V
    &#125;
    note for Callable &quot;@since 1.5&quot;
    
    FutureTask ..|&gt; RunnableFuture : implements
    RunnableFuture --|&gt; Runnable : extends
    RunnableFuture --|&gt; Future : extends
    FutureTask o-- Callable : has
    FutureTask o-- Object : stores
    FutureTask o-- Thread : references</code></pre>
<p>FutureTask 本身<strong>不是 Callable，但包含 Callable</strong>。它的双重身份是设计的关键：</p>
<ul>
<li><strong>作为 Runnable</strong>：可以被提交给 Executor 执行</li>
<li><strong>作为 Future</strong>：提供结果获取、取消、状态查询能力</li>
</ul>
<p>核心语义约束：</p>
<ol>
<li><strong>单次执行原则</strong>：任务只能执行一次，一旦进入终态（NORMAL/EXCEPTIONAL/CANCELLED/INTERRUPTED）就不可重启。</li>
<li><strong>阻塞语义</strong>：<code>get()</code> 在任务完成前会阻塞调用线程，这是 Future 模式的核心价值。</li>
<li><strong>不可逆取消</strong>：一旦取消成功，任务即使尚未开始也不会再执行。</li>
<li><strong>runAndReset 是例外</strong>：专为周期性任务设计，执行后<strong>重置状态但不设置结果</strong>。</li>
</ol>
<p><strong>执行环境无关性</strong>：FutureTask 的 <code>run()</code>、<code>runAndReset()</code> 及其状态机设计与执行环境完全解耦。不假定调用者是 ThreadPoolExecutor 的 Worker、用户线程还是 main 线程；不区分同步调用、异步提交或定时调度。<code>runner = Thread.currentThread()</code> 的语义是“谁调用就记录谁”，状态转换完全自包含，不依赖外部线程池状态。这是典型的关注点分离设计：FutureTask 只负责状态管理、结果存储、等待/唤醒协调，线程池只负责线程管理和任务调度，两者通过 <code>Runnable</code> 接口解耦。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A cancellable asynchronous computation.  This class provides a base</span><br><span class="hljs-comment"> * implementation of &#123;<span class="hljs-doctag">@link</span> Future&#125;, with methods to start and cancel</span><br><span class="hljs-comment"> * a computation, query to see if the computation is complete, and</span><br><span class="hljs-comment"> * retrieve the result of the computation.  The result can only be</span><br><span class="hljs-comment"> * retrieved when the computation has completed; the &#123;<span class="hljs-doctag">@code</span> get&#125;</span><br><span class="hljs-comment"> * methods will block if the computation has not yet completed.  Once</span><br><span class="hljs-comment"> * the computation has completed, the computation cannot be restarted</span><br><span class="hljs-comment"> * or cancelled (unless the computation is invoked using</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #runAndReset&#125;).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;A &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; can be used to wrap a &#123;<span class="hljs-doctag">@link</span> Callable&#125; or</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Runnable&#125; object.  Because &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; implements</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> Runnable&#125;, a &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; can be submitted to an</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Executor&#125; for execution.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;In addition to serving as a standalone class, this class provides</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> protected&#125; functionality that may be useful when creating</span><br><span class="hljs-comment"> * customized task classes.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Doug Lea</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;V&gt; The result type returned by this FutureTask&#x27;s &#123;<span class="hljs-doctag">@code</span> get&#125; methods</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Javadoc 释义：</p>
<ul>
<li>「cancellable asynchronous computation」：FutureTask 的核心定位是可取消的异步计算单元。</li>
<li>「base implementation of Future」：提供 Future 接口的基础实现，子类可扩展。</li>
<li>「get methods will block」：阻塞是获取异步结果的代价，这是 Future 模式的本质特征。</li>
<li>「wrap a Callable or Runnable」：适配器模式，统一两种任务类型-通过两种构造器的形式。实际上只能wrap一个 Callable，Runnable 必须适配成 Callable 放进来。</li>
<li>「protected functionality」：模板方法模式，<code>done()</code> 等钩子供子类定制。</li>
</ul>
</blockquote>
<h4 id="成员字段与构造">成员字段与构造</h4>
<p>FutureTask 有 5 个一级成员字段，它们之间构成了一个典型的「输入 → 执行 → 输出」模型：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dart">FutureTask&lt;V&gt;<br>├── callable: Callable&lt;V&gt;      <span class="hljs-comment">// 输入：持有待执行的任务</span><br>├── outcome: <span class="hljs-built_in">Object</span>            <span class="hljs-comment">// 输出：存储执行结果或异常</span><br>├── state: <span class="hljs-built_in">int</span>                 <span class="hljs-comment">// 控制：状态机</span><br>├── runner: Thread             <span class="hljs-comment">// 控制：执行线程引用</span><br>└── waiters: WaitNode          <span class="hljs-comment">// 控制：等待线程的 Treiber 栈</span><br></code></pre></td></tr></table></figure>
<p><code>run()</code> 方法的核心职责就是调用 <code>callable.call()</code> 获取返回值，然后通过 <code>set(result)</code> 将结果写入 <code>outcome</code>。<code>callable</code> 是输入，<code>run()</code> 是执行器（内建），<code>outcome</code> 是输出（内建）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** The underlying callable; nulled out after running */</span><br><span class="hljs-comment">// 任务进入终态后 callable 会被置空-所以任务绝对不可重复执行，帮助 GC</span><br><span class="hljs-keyword">private</span> Callable&lt;V&gt; callable;<br><br><span class="hljs-comment">/** The result to return or exception to throw from get() */</span><br><span class="hljs-comment">// 异常和结果使用同一个 outcome，所以 outcome 不能是泛型，必须是 Object。</span><br><span class="hljs-comment">// 它是非 volatile 的，可见性通过 state 的 volatile 读写来保证（[volatile 捎带同步](/2026/02/07/JVM-的内存模型与线程/#7-1-volatile-的捎带同步（Piggybacking）)）：</span><br><span class="hljs-comment">// 1. outcome = v happens-before state = NORMAL（程序顺序规则）</span><br><span class="hljs-comment">// 2. state = NORMAL happens-before 读取 state（volatile 规则）</span><br><span class="hljs-comment">// 3. 因此，outcome = v happens-before 读取 outcome（传递性）</span><br><span class="hljs-keyword">private</span> Object outcome; <span class="hljs-comment">// non-volatile, protected by state reads/writes</span><br><br><span class="hljs-comment">/** The thread running the callable; CASed during run() */</span><br><span class="hljs-comment">// 持有执行线程引用，用于 cancel(true) 时中断执行线程。</span><br><span class="hljs-comment">// 语义精确性：runner != null 表示有线程正在执行 run() 方法体（从 CAS 成功到 finally 清空），</span><br><span class="hljs-comment">// 但不等价于 callable.call() 正在执行，可能处于 call() 前、call() 中、或 set()/setException() 执行期间。这是嵌套任务的必然设计，FutureTask 的状态是大于 callable 的状态的。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread runner;<br><br><span class="hljs-comment">/** Treiber stack of waiting threads */</span><br><span class="hljs-comment">// 管理阻塞在 get() 上的等待线程，使用无锁并发栈（Treiber Stack）-当我们park里线程又需要 unpark 线程的时候，需要记录等待线程</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WaitNode waiters;<br></code></pre></td></tr></table></figure>
<p>FutureTask 提供两个构造器，支持 Callable 和 Runnable 两种任务类型。构造器中 <code>state = NEW</code> 写在最后，利用 <a href="/2026/02/07/JVM-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/#7-1-volatile-%E7%9A%84%E6%8D%8E%E5%B8%A6%E5%90%8C%E6%AD%A5%EF%BC%88Piggybacking%EF%BC%89">volatile 捎带同步</a>保证 callable 的可见性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.callable = callable;<br>    <span class="hljs-built_in">this</span>.state = NEW;       <span class="hljs-comment">// ensure visibility of callable。以后 get 值以前要先 check state 就可以</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>    <span class="hljs-built_in">this</span>.state = NEW;       <span class="hljs-comment">// ensure visibility of callable</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>当传入 Runnable 时，线程池使用 <code>RunnableAdapter</code> 将其适配为 Callable：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Executors.callable() 的适配逻辑</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">final</span> Runnable task;<br>    <span class="hljs-keyword">final</span> T result;<br>    RunnableAdapter(Runnable task, T result) &#123;<br>        <span class="hljs-built_in">this</span>.task = task;<br>        <span class="hljs-built_in">this</span>.result = result;<br>    &#125;<br>    <span class="hljs-comment">// 实现类可以不声明接口方法的受检异常</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 可以看出，task 的run 不能修改 result，所以把 runnable 封装成计算式的 callable 是不现实的</span><br>        task.run();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这形成了清晰的封装层次：<code>FutureTask.run()</code> → <code>callable.call()</code>（可能是 <code>RunnableAdapter.call()</code>，也可能是普通的<code>callable.call()</code>）→ <code>task.run()</code> → <code>return result 设置 outcome</code> → <code>report outcome</code>。整个链路将无返回值的 Runnable 转换为有返回值的 Future 模式。之所以这样设计，本质上是因为 <code>Thread</code> 类底层只支持 <code>run()</code>，不支持 <code>call()</code>。FutureTask 是能让 runnable 内部含有结果，而且可以借助一个输出接口输出结果的经典范例。</p>
<p><strong>同级封装适配的设计动因</strong>：</p>
<table>
<thead>
<tr>
<th>方向</th>
<th>机制</th>
<th>核心约束</th>
<th>设计要点</th>
</tr>
</thead>
<tbody>
<tr>
<td>Callable → Runnable</td>
<td>FutureTask（实质上是 RunnableFuture）</td>
<td>run() 是 void，无法返回值</td>
<td>run() 内部调用 call()，将返回值存入 outcome，通过 get() 暴露。get() 是带有延时和状态检查的 call()：call() 立即执行并返回，get() 等待状态机达到终态后才返回 outcome</td>
</tr>
<tr>
<td>Runnable → Callable</td>
<td>RunnableAdapter（实质上是 Callable）</td>
<td>run() 无返回值，无法产出计算结果</td>
<td>只能提供预设的 result，call() 执行 run() 后直接返回预设值。若需计算结果，应直接使用 Callable</td>
</tr>
</tbody>
</table>
<p>简言之：Callable 封装成 Runnable 需要一个中间层（FutureTask-RunnableFuture）来“接住”返回值；Runnable 适配成 Callable 只能「带着结果进去」，无法「计算出结果」。</p>
<h4 id="状态机">状态机</h4>
<p>state 字段是 FutureTask 的核心状态机，使用 <code>volatile int</code> 而非枚举类型——这是 Doug Lea 的常见设计风格，核心考量是：配合 <code>UNSAFE.compareAndSwapInt</code> 实现无锁状态转换，volatile 保证可见性，整数比较性能更高。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * The run state of this task, initially NEW.  The run state</span><br><span class="hljs-comment"> * transitions to a terminal state only in methods set,</span><br><span class="hljs-comment"> * setException, and cancel.  During completion, state may take on</span><br><span class="hljs-comment"> * transient values of COMPLETING (while outcome is being set) or</span><br><span class="hljs-comment"> * INTERRUPTING (only while interrupting the runner to satisfy a</span><br><span class="hljs-comment"> * cancel(true)). Transitions from these intermediate to final</span><br><span class="hljs-comment"> * states use cheaper ordered/lazy writes because values are unique</span><br><span class="hljs-comment"> * and cannot be further modified.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Possible state transitions:</span><br><span class="hljs-comment"> * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="hljs-comment"> * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="hljs-comment"> * NEW -&gt; CANCELLED</span><br><span class="hljs-comment"> * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 核心状态机字段，volatile 保证多线程可见性，配合 CAS 实现无锁状态转换。</span><br><span class="hljs-comment">// 设计动因：使用 int 而非枚举，因为需要配合 UNSAFE.compareAndSwapInt 进行原子操作。</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><span class="hljs-comment">// NEW(0)：初始态，任务尚未执行或正在执行中，是唯一可被 cancel 的状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-comment">// COMPLETING(1)：瞬态，call() 已返回，正在写入 outcome，持续时间极短</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-comment">// NORMAL(2)：终态，任务正常完成，outcome 存储返回值</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-comment">// EXCEPTIONAL(3)：终态，任务异常完成，outcome 存储 Throwable</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-comment">// CANCELLED(4)：终态，任务被 cancel(false) 取消，未触发中断</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-comment">// INTERRUPTING(5)：瞬态，cancel(true) 正在中断 runner 线程</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-comment">// INTERRUPTED(6)：终态，cancel(true) 完成，runner 已被中断</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Javadoc 释义：</p>
<ul>
<li>「initially NEW」：构造后初始状态为 NEW(0)，这是唯一可以接受任务取消的状态</li>
<li>「terminal state」：终态包括 NORMAL/EXCEPTIONAL/CANCELLED/INTERRUPTED，不可逆转</li>
<li>「transient values」：COMPLETING/INTERRUPTING 是瞬态，主要用于设置 outcome 或执行中断的窗口期</li>
<li>「ordered/lazy writes」：使用 <code>UNSAFE.putOrderedInt</code> 而非 volatile 写，因为终态唯一不可变</li>
</ul>
</blockquote>
<p><strong>putOrderedInt 语义详解</strong>：<code>putOrderedInt</code> 是弱化版 volatile 写（又称 lazySet）。与 <code>putIntVolatile</code> 的区别在于内存屏障：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>写前屏障</th>
<th>写后屏障</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>putIntVolatile</code></td>
<td>StoreStore</td>
<td>StoreLoad</td>
</tr>
<tr>
<td><code>putOrderedInt</code></td>
<td>StoreStore</td>
<td>无</td>
</tr>
</tbody>
</table>
<p>为什么叫 “ordered”：保证 store-store ordering，此写操作之前的所有写不会被重排序到此写之后（如 <code>outcome = v</code> 必然先于 <code>state = NORMAL</code>）。</p>
<p>为什么叫 “lazy”：省略了写后的 StoreLoad 屏障，写入可能滞留在 CPU 写缓冲区，其他线程最终会看到但不保证立即可见。在 x86 上，<code>putOrderedInt</code> 编译为普通 MOV 指令，而 <code>putIntVolatile</code> 需要 LOCK 前缀或 MFENCE。</p>
<p>适用场景：<strong>只需 happens-before 传递性不需即时可见性时使用</strong>。FutureTask 终态写入正是此场景：读到终态的线程必能读到 outcome，但不要求终态立即被观测到。JDK 9+ 的 <code>VarHandle.setRelease()</code> 是其替代 API。</p>
<p><strong>FutureTask 状态转换图</strong>：</p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; NEW: 任务创建
    
    NEW --&gt; COMPLETING: call()执行完成
    NEW --&gt; CANCELLED: cancel(false)
    NEW --&gt; INTERRUPTING: cancel(true)
    
    COMPLETING --&gt; NORMAL: 正常结果设置完成
    COMPLETING --&gt; EXCEPTIONAL: 异常结果设置完成
    
    INTERRUPTING --&gt; INTERRUPTED: 中断完成
    
    NORMAL --&gt; [*]: 终态
    EXCEPTIONAL --&gt; [*]: 终态
    CANCELLED --&gt; [*]: 终态
    INTERRUPTED --&gt; [*]: 终态
    
    note right of NEW: 初始状态，任务可被取消
    note right of COMPLETING: 瞬态，正在设置结果
    note right of INTERRUPTING: 瞬态，正在中断runner</code></pre>
<blockquote>
<p>值得一提的是，任务的中间状态是一个瞬态，它非常的短暂。而且任务的中间态并不代表任务正在执行，而是任务已经执行完了，正在设置最终的返回结果，所以可以这么说：<br>
只要 state 不处于 NEW 状态，就说明任务已经执行完毕。<br>
注意，<strong>这里的执行完毕是指传入的 Callable 对象的 call 方法执行完毕</strong>，<strong>或者抛出了异常</strong>。所以这里的 COMPLETING 的名字显得有点迷惑性，它并不意味着任务正在执行中，而意味着 call 方法已经执行完毕，正在设置任务执行的结果。</p>
</blockquote>
<p>换言之，只有 NEW 状态才是 cancellable 的。</p>
<p><strong>状态查询方法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> state &gt;= CANCELLED;<br>&#125;<br><br><span class="hljs-comment">// 只要不是 NEW 就算完成——包括过渡态（COMPLETING/INTERRUPTING），即使结果还不可用</span><br><span class="hljs-comment">// 注意：isDone()=true 不等于 get() 可立即返回，过渡态下仍需等待</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> state != NEW;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="执行入口：run-与-runandreset">执行入口：run() 与 runAndReset()</h4>
<h5 id="run">run()</h5>
<p><code>state == NEW</code> 检查与 CAS 绑定 runner 共同保证 FutureTask 最多执行一次。</p>
<p><code>run()</code> 是任务执行的入口-通常由线程池的 worker 调用，worker 最终也成为 runner。核心流程：state 检查 + CAS 绑定 runner 保证幂等 → 执行 <code>callable.call()</code> → 根据结果调用 <code>set()</code> 或 <code>setException()</code>（内部 CAS NEW→COMPLETING 进入中间态，再转为终态，这个转换在一个方法里全部完成，所以中间态是很短暂的）→ finally 中置空 runner 并处理可能的中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 这是一个需要反向理解的幂等保证：只有 state == NEW 且 CAS 成功绑定 runner 才执行</span><br>    <span class="hljs-keyword">if</span> (state != NEW ||<br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                     <span class="hljs-literal">null</span>, Thread.currentThread()))<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Callable&lt;V&gt; c = callable;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>            V result;<br>            <span class="hljs-comment">// ran 是一个局部变量</span><br>            <span class="hljs-type">boolean</span> ran;<br>            <span class="hljs-keyword">try</span> &#123;<br>                result = c.call();<br>                ran = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                result = <span class="hljs-literal">null</span>;<br>                ran = <span class="hljs-literal">false</span>;<br>                setException(ex);    <span class="hljs-comment">// NEW → COMPLETING → EXCEPTIONAL</span><br>            &#125;<br>            <span class="hljs-comment">// 为何不在 try 块内直接调用 set()?</span><br>            <span class="hljs-comment">// set() 内部的 finishCompletion() 会唤醒等待线程、执行回调，理论上可能抛异常</span><br>            <span class="hljs-comment">// 若在 try 块内抛出，会被 catch(Throwable) 捕获并触发 setException()</span><br>            <span class="hljs-comment">// 任务明明成功了却被标记为失败——这是错误的</span><br>            <span class="hljs-comment">// 用 ran 标志位退出 catch 块后再调用，确保异常边界清晰</span><br>            <span class="hljs-keyword">if</span> (ran)<br>                set(result);         <span class="hljs-comment">// NEW → COMPLETING → NORMAL</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// runner 必须在状态确定后才能置空，防止并发调用 run()</span><br>        runner = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 置空 runner 后必须重读 state，防止泄漏中断</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>            handlePossibleCancellationInterrupt(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="runner-的生命周期">runner 的生命周期</h5>
<p>runner 字段记录了正在执行任务的线程引用，它的注入和使用流程如下：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Caller as 调用方线程
    participant Pool as 线程池
    participant FutureTask
    participant Worker as 线程池Worker
    
    Caller-&gt;&gt;Pool: submit(task)
    Pool-&gt;&gt;FutureTask: new FutureTask(task)
    Note right of FutureTask: state = NEW, runner = null
    Pool--&gt;&gt;Caller: return futureTask
    
    Worker-&gt;&gt;FutureTask: run()
    FutureTask-&gt;&gt;FutureTask: CAS设置 runner = Worker
    Note right of FutureTask: Worker执行 callable.call()
    
    Caller-&gt;&gt;FutureTask: cancel(true)
    FutureTask-&gt;&gt;FutureTask: CAS NEW→INTERRUPTING
    FutureTask-&gt;&gt;Worker: runner.interrupt()
    FutureTask-&gt;&gt;FutureTask: state = INTERRUPTED
    FutureTask-&gt;&gt;FutureTask: finishCompletion()
    
    Note over Worker: Worker收到中断信号
    Worker-&gt;&gt;FutureTask: run()的finally块
    FutureTask-&gt;&gt;FutureTask: runner = null
    FutureTask-&gt;&gt;FutureTask: handlePossibleCancellationInterrupt()
    Note right of FutureTask: 若state==INTERRUPTING则自旋等待</code></pre>
<h5 id="runandreset">runAndReset()</h5>
<p><code>runAndReset()</code> 专为周期性任务设计（典型应用场景是 <code>ScheduledThreadPoolExecutor</code> 中的定时任务）。与 <code>run()</code> 的关键区别：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th><code>run()</code></th>
<th><code>runAndReset()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>结果设置</td>
<td>调用 <code>set(result)</code> 或 <code>setException(ex)</code> 清空 callable；runner 在 finally 块中清空</td>
<td>不设置结果，<code>get()</code> 永远阻塞或超时，无法获取中间结果。正常完成时不调用 <code>set()</code>，故不触发 <code>finishCompletion()</code>，callable 保留；runner 在 finally 块中清空</td>
</tr>
<tr>
<td>正常完成</td>
<td>NEW → NORMAL（终态）</td>
<td><strong>状态保持 NEW</strong>，允许再次执行</td>
</tr>
<tr>
<td>异常/取消</td>
<td>进入终态</td>
<td>进入终态（与 <code>run()</code> 一致）</td>
</tr>
<tr>
<td>可重复执行</td>
<td>否</td>
<td>仅正常完成时可重复</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Executes the computation without setting its result, and then</span><br><span class="hljs-comment"> * resets this future to initial state, failing to do so if the</span><br><span class="hljs-comment"> * computation encounters an exception or is cancelled.  This is</span><br><span class="hljs-comment"> * designed for use with tasks that intrinsically execute more</span><br><span class="hljs-comment"> * than once.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if successfully run and reset</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">// 核心职责：执行任务但不设置结果，正常完成时保持 NEW 状态以支持重复执行。</span><br><span class="hljs-comment">// 设计动因：专为周期性任务设计（如 ScheduledThreadPoolExecutor 的定时任务），</span><br><span class="hljs-comment">// 与 run() 的关键区别是不调用 set()，因此不会触发状态转换和 finishCompletion()。</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runAndReset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 幂等保证：state == NEW 且 CAS 绑定 runner 成功才能执行</span><br>    <span class="hljs-keyword">if</span> (state != NEW ||<br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                     <span class="hljs-literal">null</span>, Thread.currentThread()))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ran</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;  <span class="hljs-comment">// volatile 读，获取当前状态快照</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Callable&lt;V&gt; c = callable;<br>        <span class="hljs-comment">// 双重检查：callable 非空且状态仍为 NEW（防止并发 cancel）</span><br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; s == NEW) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                c.call(); <span class="hljs-comment">// 执行但不保存结果——这是与 run() 的核心区别</span><br>                ran = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                <span class="hljs-comment">// 异常时进入终态，后续不可重复执行</span><br>                setException(ex);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// runner 必须在状态确定后才能置空，防止并发调用</span><br>        runner = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 重读 state：防止 cancel(true) 的中断信号泄漏</span><br>        s = state;<br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>            handlePossibleCancellationInterrupt(s);<br>    &#125;<br>    <span class="hljs-comment">// 返回 true 条件：成功执行且状态仍为 NEW（未被 cancel 或异常）</span><br>    <span class="hljs-keyword">return</span> ran &amp;&amp; s == NEW;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>Javadoc 释义：</p>
<ul>
<li>「without setting its result」：执行但不产生可获取的结果</li>
<li>「resets this future to initial state」：重置的是状态而非 callable 引用</li>
<li>「failing to do so if…exception or cancelled」：异常和取消都会导致进入终态，不再可重置</li>
<li>「intrinsically execute more than once」：典型如定时任务、心跳任务等周期性场景</li>
</ul>
</blockquote>
<h4 id="三类终态方法：set-setexception-cancel">三类终态方法：set / setException / cancel</h4>
<p>FutureTask 有三种进入终态的路径，它们都以 <code>finishCompletion()</code> 收尾：</p>
<h5 id="set-：正常完成">set()：正常完成</h5>
<p>状态转换：NEW → COMPLETING → NORMAL。CAS 先设置中间态 COMPLETING 防止并发取消，中间态期间写入 outcome（可见性由后续的 volatile state 写入保证），然后用 <code>putOrderedInt</code>（懒写）写入终态 NORMAL。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心职责：将任务标记为正常完成，存储结果并唤醒等待线程。</span><br><span class="hljs-comment">// 状态转换：NEW → COMPLETING → NORMAL</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V v)</span> &#123;<br>    <span class="hljs-comment">// CAS NEW→COMPLETING：抢占中间态，防止并发 cancel 或重复 set</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>        <span class="hljs-comment">// CAS 失败时 outcome 丢失——这是设计折衷，cancel 优先级高于结果设置</span><br>        outcome = v;  <span class="hljs-comment">// 非 volatile 写，可见性由后续 state 写入保证（volatile 捎带同步）</span><br>        <span class="hljs-comment">// putOrderedInt：懒写终态，省略 StoreLoad 屏障，因为终态唯一不可变</span><br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, NORMAL); <span class="hljs-comment">// final state</span><br>        <span class="hljs-comment">// 唤醒所有等待线程，执行 done() 回调，清空 callable</span><br>        finishCompletion();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="setexception-：异常完成">setException()：异常完成</h5>
<p>状态转换：NEW → COMPLETING → EXCEPTIONAL。与 <code>set()</code> 几乎相同，但 outcome 存储的是 Throwable。如果 CAS 失败（已被 cancel），异常信息丢失，这是设计折衷。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心职责：将任务标记为异常完成，存储异常并唤醒等待线程。</span><br><span class="hljs-comment">// 状态转换：NEW → COMPLETING → EXCEPTIONAL</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setException</span><span class="hljs-params">(Throwable t)</span> &#123;<br>    <span class="hljs-comment">// CAS NEW→COMPLETING：与 set() 逻辑相同，抢占中间态</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>        <span class="hljs-comment">// CAS 失败时异常信息丢失——若已被 cancel，调用方通过 CancellationException 感知</span><br>        outcome = t;  <span class="hljs-comment">// outcome 复用存储异常，类型由 state 决定如何解释</span><br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="hljs-comment">// final state</span><br>        finishCompletion();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="cancel-：取消-中断">cancel()：取消/中断</h5>
<p>从这个方法可以看出，中断也是 cancel 的一种。只能从 NEW 状态取消，返回 true 表示状态迁移成功，不保证任务实际停止。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br>    <span class="hljs-comment">// 只能从 NEW 迁移到 INTERRUPTING 或 CANCELLED。已经进入 COMPLETING 意味着 callable 已经执行完了，就不允许 cancel 任务了。如果迁移到 CANCELLED，下面的 try 语句的 if 也不会执行。</span><br>    <span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp;<br>          UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW,<br>              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// in case call to interrupt throws exception</span><br>        <span class="hljs-comment">// 能走到这里，任务可能正在运行（runner != null）或尚未启动（runner == null）。</span><br>        <span class="hljs-comment">// 若正在运行则中断执行线程；若尚未启动，runner 为 null 不执行 interrupt，</span><br>        <span class="hljs-comment">// 但状态已迁移，后续 run() 会因 state != NEW 而直接返回。</span><br>        <span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// === TOCTOU（Time-of-Check to Time-of-Use）防护模式 ===</span><br>                <span class="hljs-comment">// 问题背景：多线程环境下，&quot;检查&quot;和&quot;使用&quot;之间存在时间窗口，</span><br>                <span class="hljs-comment">// 此窗口内状态可能被其他线程修改，导致检查结果失效。</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// 本例中的竞态场景：</span><br>                <span class="hljs-comment">// 线程A（本线程）          线程B（run方法执行线程）</span><br>                <span class="hljs-comment">// ─────────────────────   ─────────────────────────</span><br>                <span class="hljs-comment">// if (runner != null)      // 检查通过</span><br>                <span class="hljs-comment">//                          finally &#123; runner = null; &#125;</span><br>                <span class="hljs-comment">// runner.interrupt()      // NPE！runner已被置空</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// 防护方案：将 volatile 字段快照到局部变量，保证检查和使用的是同一个引用。</span><br>                <span class="hljs-comment">// 即使原字段随后被其他线程修改，局部变量仍持有旧引用，避免 NPE。</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// 这是 JDK 并发代码标准模式，广泛用于：</span><br>                <span class="hljs-comment">// - FutureTask.cancel()：快照 runner 字段</span><br>                <span class="hljs-comment">// - ThreadPoolExecutor.execute()：快照 ctl 字段</span><br>                <span class="hljs-comment">// - Reference.get()：快照 referent 字段</span><br>                <span class="hljs-comment">// - StampedLock：快照 stamp 值</span><br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;<br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>                    t.interrupt();<br>            &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// final state</span><br>                UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, INTERRUPTED);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果没有 mayInterruptIfRunning，其实只执行这里。收尾工作</span><br>        finishCompletion();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>参数</th>
<th>状态转换</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cancel(false)</code></td>
<td>NEW → CANCELLED</td>
<td>仅标记取消，不中断执行线程</td>
</tr>
<tr>
<td><code>cancel(true)</code></td>
<td>NEW → INTERRUPTING → INTERRUPTED</td>
<td>标记取消并对 runner 线程调用 <code>interrupt()</code></td>
</tr>
</tbody>
</table>
<p><strong>为何需要 INTERRUPTING 中间态？</strong></p>
<p><code>cancel(true)</code> 分两步：CAS 进入 INTERRUPTING → 执行 <code>t.interrupt()</code> → 设置 INTERRUPTED。若直接 CAS 到 INTERRUPTED，存在时序竞争：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pf">线程A执行run()                          线程B执行cancel(true)<br>─────────────────────────────────────────────────────────────<br>                                        CAS NEW→INTERRUPTING ✓<br>                                        Thread t = runner (拿到线程A)<br>                                        ──被挂起──<br>callable.call() 完成<br>finally: runner = null<br>读取 <span class="hljs-keyword">state</span> = INTERRUPTING<br>handlePossibleCancellationInterrupt()<br>  → 自旋等待 <span class="hljs-keyword">state</span> 变为 INTERRUPTED<br>                                        ──恢复执行──<br>                                        t.interrupt()<br>                                        <span class="hljs-keyword">state</span> = INTERRUPTED<br>run() 返回<br></code></pre></td></tr></table></figure>
<p>若无 INTERRUPTING 中间态，<code>run()</code> 无法感知 <code>cancel(true)</code> 正在进行，可能在 <code>t.interrupt()</code> 执行前就返回，线程被复用执行新任务时收到这个“过期中断”——即中断泄漏。<code>handlePossibleCancellationInterrupt()</code> 通过自旋等待确保中断操作完成后 <code>run()</code> 才返回。</p>
<h5 id="finishcompletion-：终态收尾">finishCompletion()：终态收尾</h5>
<p>不管是正常完成/异常完成/取消，最终都一定要调用到这个方法。</p>
<p>所有终态方法最终都调用 <code>finishCompletion()</code>，它负责三件事：唤醒所有等待线程、调用 <code>done()</code> 钩子、置空 callable 帮助 GC。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Removes and signals all waiting threads, invokes done(), and</span><br><span class="hljs-comment"> * nulls out callable.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishCompletion</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 外层 for 循环：尝试获取等待队列的所有权</span><br>    <span class="hljs-comment">// 这里用 for 而非 while，是为了在循环头部同时完成初始化和条件检查</span><br>    <span class="hljs-keyword">for</span> (WaitNode q; (q = waiters) != <span class="hljs-literal">null</span>;) &#123;<br>        <span class="hljs-comment">// CAS 将 waiters 头指针置为 null，原子性地获取整个 Treiber 栈的所有权。</span><br>        <span class="hljs-comment">// CAS 成功后，当前线程负责唤醒所有已入队的等待线程。</span><br>        <span class="hljs-comment">// 新到达的等待线程会发现任务已进入终态，不会真正 park。</span><br>        <span class="hljs-comment">// CAS 失败可能因为：(1) 新的等待线程入队导致栈头变化，或 (2) 另一终态方法已获取所有权。</span><br>        <span class="hljs-comment">// 重新读取 waiters，若为 null 则退出，否则继续尝试。</span><br>        <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q, <span class="hljs-literal">null</span>)) &#123;<br>            <span class="hljs-comment">// 内层无限循环：遍历 Treiber 栈，逐个唤醒等待线程</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q.thread;<br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 先置空 thread 引用，再唤醒</span><br>                    <span class="hljs-comment">// 防止同一节点被重复处理（虽然当前场景不会发生，但是防御性编程）</span><br>                    q.thread = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-comment">// 唤醒等待线程，unpark 可以在 park 之前调用（permit 模型）</span><br>                    LockSupport.unpark(t);<br>                &#125;<br>                <span class="hljs-type">WaitNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> q.next;<br>                <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">break</span>;         <span class="hljs-comment">// 栈底，遍历结束</span><br>                q.next = <span class="hljs-literal">null</span>;     <span class="hljs-comment">// 断开链表引用，帮助 GC 回收 WaitNode</span><br>                q = next;          <span class="hljs-comment">// 移动到下一个节点</span><br>            &#125;<br>            <span class="hljs-keyword">break</span>;                 <span class="hljs-comment">// CAS 成功并完成遍历，退出外层循环</span><br>        &#125;<br>        <span class="hljs-comment">// CAS 失败则重新读取 waiters，继续尝试</span><br>    &#125;<br>    <span class="hljs-comment">// 模板方法钩子，子类可重写以实现完成回调（如 SwingWorker 更新 UI）。但是默认实现为空</span><br>    done();<br>    <span class="hljs-comment">// 置空 callable 减少内存占用，任务已完成，callable 不再需要</span><br>    callable = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>LockSupport 补充</strong>：<code>LockSupport</code> 是 JUC 底层的线程阻塞/唤醒原语，基于许可证（permit）模型：<code>park()</code> 消费许可证（无则阻塞），<code>unpark()</code> 生产许可证（可提前发放，<strong>不可累加</strong>）。与 <code>Object.wait/notify</code> 的关键区别是无需持有监视器锁、<code>unpark</code> 可在 <code>park</code> 之前调用、不会抛出 <code>InterruptedException</code>。</p>
</blockquote>
<h4 id="结果获取：get-awaitdone-report">结果获取：get() / awaitDone() / report()</h4>
<p><code>get()</code> 的逻辑分为两部分：阻塞等待交给 <code>awaitDone()</code>，结果解释交给 <code>report()</code>。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Caller as 调用方线程
    participant FutureTask
    participant WaitNode
    participant Runner as 执行线程(Worker)
    
    Caller-&gt;&gt;FutureTask: get()
    FutureTask-&gt;&gt;FutureTask: 检查 state &lt;= COMPLETING?
    
    alt state &gt; COMPLETING
        FutureTask-&gt;&gt;FutureTask: report(state)
        FutureTask--&gt;&gt;Caller: 返回结果或抛出异常
    else state &lt;= COMPLETING
        FutureTask-&gt;&gt;FutureTask: awaitDone(timed, nanos)
        
        loop 多轮自旋
            Note over FutureTask: 检查中断状态
            alt 被中断
                FutureTask-&gt;&gt;FutureTask: removeWaiter(q)
                FutureTask--&gt;&gt;Caller: 抛出 InterruptedException
            end
            
            alt state &gt; COMPLETING
                FutureTask--&gt;&gt;FutureTask: 返回终态
            else state == COMPLETING
                FutureTask-&gt;&gt;FutureTask: Thread.yield()
            else q == null
                FutureTask-&gt;&gt;WaitNode: new WaitNode()
                Note right of WaitNode: 捕获当前线程引用
            else !queued
                FutureTask-&gt;&gt;FutureTask: CAS 入栈(q.next=waiters, waiters=q)
            else
                FutureTask-&gt;&gt;FutureTask: LockSupport.park(this)
                Note over FutureTask: 线程挂起等待唤醒
            end
        end
        
        Note over Runner: 任务执行完成
        Runner-&gt;&gt;FutureTask: set(result) 或 setException(ex)
        FutureTask-&gt;&gt;FutureTask: finishCompletion()
        
        loop 遍历 waiters 栈
            FutureTask-&gt;&gt;WaitNode: 获取 thread 引用
            FutureTask-&gt;&gt;Caller: LockSupport.unpark(thread)
        end
        
        Note over Caller: 被唤醒，继续自旋
        FutureTask-&gt;&gt;FutureTask: 检测到 state &gt; COMPLETING
        FutureTask--&gt;&gt;FutureTask: awaitDone 返回终态
        
        FutureTask-&gt;&gt;FutureTask: report(state)
        alt state == NORMAL
            FutureTask--&gt;&gt;Caller: 返回 (V)outcome
        else state &gt;= CANCELLED
            FutureTask--&gt;&gt;Caller: 抛出 CancellationException
        else state == EXCEPTIONAL
            FutureTask--&gt;&gt;Caller: 抛出 ExecutionException
        end
    end</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>        s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);   <span class="hljs-comment">// 无限等待</span><br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>    <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>        (s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="awaitdone-：自旋-locksupport-park-的阻塞等待">awaitDone()：自旋 + LockSupport.park 的阻塞等待</h5>
<p><code>awaitDone</code> 采用多轮自旋策略：第一轮创建 WaitNode，第二轮 CAS 入队，第三轮开始 park。中断时清除中断位并抛出 <code>InterruptedException</code>，超时后清理节点并返回当前状态。唤醒由 <code>finishCompletion()</code> 中的 <code>LockSupport.unpark()</code> 触发。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Awaits completion or aborts on interrupt or timeout.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;核心职责：阻塞当前线程直到任务完成、中断或超时。</span><br><span class="hljs-comment"> * 设计动因：采用多轮自旋而非直接 park，是因为每轮自旋都会重新检查 state，</span><br><span class="hljs-comment"> * 可在 COMPLETING 瞬态时遇到的短暂调度延迟内快速返回，避免不必要的线程挂起/唤醒开销。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> timed true if use timed waits。timed=true 表示限时等待</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nanos time to wait, if timed。最大等待纳秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> state upon completion。任务终态（NORMAL/EXCEPTIONAL/CANCELLED/INTERRUPTED），</span><br><span class="hljs-comment"> *         调用方据此决定 report() 路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException 中断时立即抛出，符合 JUC 可中断等待的标准契约</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;<br>    <span class="hljs-type">WaitNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 中断检查只针对当前调用 get() 的线程——每个等待线程独立响应自己的中断信号，</span><br>        <span class="hljs-comment">// 被中断时只清理自己的 WaitNode 并抛出异常，不影响其他等待线程。</span><br>        <span class="hljs-comment">// 响应中断：清空中断位，移除等待节点，抛出异常。任何一轮循环开始都可能被中断，在此插入对中断的处理。</span><br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>            removeWaiter(q);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>        <span class="hljs-keyword">if</span> (s &gt; COMPLETING) &#123;<br>            <span class="hljs-comment">// 已进入终态，清空当前节点的 thread 引用即可</span><br>            <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>)<br>                q.thread = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> s;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == COMPLETING)<br>            <span class="hljs-comment">// COMPLETING 是瞬态，让出 CPU 等一下即可</span><br>            Thread.<span class="hljs-keyword">yield</span>();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)<br>            <span class="hljs-comment">// 否则，state == NEW 但尚未入栈，开始准备长期等待（分两轮完成入栈）</span><br>            <span class="hljs-comment">// 第一轮：创建 WaitNode，捕获当前 get 线程</span><br>            q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)<br>            <span class="hljs-comment">// 第二轮：CAS 入栈（头插法，新节点成为 waiters 头指针）</span><br>            queued = UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                                                 q.next = waiters, q);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;<br>            nanos = deadline - System.nanoTime();<br>            <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                removeWaiter(q);<br>                <span class="hljs-keyword">return</span> state;<br>            &#125;<br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">// 无限驻留，直到 finishCompletion 中 unpark 唤醒</span><br>            LockSupport.park(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="waitnode：treiber-stack-节点">WaitNode：Treiber Stack 节点</h5>
<p>WaitNode 是用于记录等待 <code>get()</code> 结果的线程的单向链表节点，组织成 Treiber Stack（无锁并发栈）。</p>
<p><strong>为什么需要 waiters/WaitNode</strong>：一个 FutureTask 可能被多个线程同时调用 <code>get()</code>，这些线程都会通过 <code>LockSupport.park()</code> 阻塞等待结果。JUC 的设计约束是：每个 <code>park()</code> 点都必须有对应的 <code>unpark()</code> 路径，否则线程会永久阻塞。因此 FutureTask 必须记录所有等待线程的引用，确保任务完成时 <code>finishCompletion()</code> 能遍历并 <code>unpark()</code> 每一个。详见<a href="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/#JUC-%E7%9A%84%E7%BB%9F%E4%B8%80%E9%98%BB%E5%A1%9E%E5%8E%9F%E8%AF%AD">《Java 并发编程笔记·JUC 的统一阻塞原语》</a>。</p>
<p><strong>为什么不用 AQS 而选择 Treiber Stack</strong>：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>AQS CLH Queue 变种</th>
<th>FutureTask Treiber Stack</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>结构</strong></td>
<td>双向链表（prev + next）</td>
<td>单向链表（仅 next）</td>
</tr>
<tr>
<td><strong>入队顺序</strong></td>
<td>FIFO（先入先出）</td>
<td>LIFO（后入先出）</td>
</tr>
<tr>
<td><strong>节点摘除</strong></td>
<td>支持任意节点 cancel 后摘除（需 prev 指针回溯）</td>
<td>不支持中间节点摘除（只标记 thread=null）</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>较高（每节点 2 个指针 + waitStatus）</td>
<td>较低（每节点 1 个指针）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>锁竞争（需公平性、可取消）</td>
<td>结果等待（无公平性要求、节点数少）</td>
</tr>
</tbody>
</table>
<p><strong>为什么 AQS 是 CLH 的「变种」</strong>：经典 CLH 是单向链表 + 自旋，AQS 改为双向链表 + <code>park/unpark</code>，因为需要支持取消语义——取消的节点必须物理摘除，否则后续节点无法被唤醒。核心差异：AQS 是「传递唤醒」（中间断链会死锁），FutureTask 是「广播唤醒」（跳过无效节点即可）。详见<a href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/#%E4%B8%8E-FutureTask-Treiber-Stack-%E7%9A%84%E5%AF%B9%E6%AF%94">AQS CLH Queue 与 FutureTask Treiber Stack 对比</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Simple linked list nodes to record waiting threads in a Treiber</span><br><span class="hljs-comment"> * stack.  See other classes such as Phaser and SynchronousQueue</span><br><span class="hljs-comment"> * for more detailed explanation.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;设计动因：轻量级无锁栈节点，避免引入 AQS 等待队列的内存开销。</span><br><span class="hljs-comment"> * Treiber Stack 采用头插法 + CAS 实现无锁并发入栈，适合高争用场景。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span> &#123;<br>    <span class="hljs-comment">// 等待线程引用，finishCompletion() 中 unpark 的目标。</span><br>    <span class="hljs-comment">// volatile 保证可见性：入栈线程写入后，finishCompletion 线程能立即读取。</span><br>    <span class="hljs-comment">// 任务完成后置 null，帮助 GC 回收。</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;<br>    <span class="hljs-comment">// 栈中下一个节点（指向栈底方向）。</span><br>    <span class="hljs-comment">// volatile 保证多线程 CAS 入栈时链表结构的可见性。</span><br>    <span class="hljs-keyword">volatile</span> WaitNode next;<br>    <span class="hljs-comment">// 构造器捕获当前调用 get() 的线程，记录“谁在等待”。</span><br>    WaitNode() &#123; thread = Thread.currentThread(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="removewaiter-：清理超时-中断的等待节点">removeWaiter()：清理超时/中断的等待节点</h5>
<p>移除因超时或中断而不再等待的节点。先置空 thread 标记为&quot;待删除&quot;，然后遍历链表跳过这些节点。头节点用 CAS，内部节点直接修改 next 指针（因为 <code>finishCompletion()</code> 会跳过 <code>thread == null</code> 的节点，所以并发遍历无害）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Tries to unlink a timed-out or interrupted wait node to avoid</span><br><span class="hljs-comment"> * accumulating garbage.  Internal nodes are simply unspliced</span><br><span class="hljs-comment"> * without CAS since it is harmless if they are traversed anyway</span><br><span class="hljs-comment"> * by releasers.  To avoid effects of unsplicing from already</span><br><span class="hljs-comment"> * removed nodes, the list is retraversed in case of an apparent</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;移除因超时或中断而不再等待的节点。先置空 thread 标记为&quot;待删除&quot;，</span><br><span class="hljs-comment"> * 然后遍历链表跳过这些节点。头节点用 CAS，内部节点直接修改 next 指针</span><br><span class="hljs-comment"> * （因为 &#123;<span class="hljs-doctag">@code</span> finishCompletion()&#125; 会跳过 &#123;<span class="hljs-doctag">@code</span> thread == null&#125; 的节点，</span><br><span class="hljs-comment"> * 所以并发遍历无害）。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;核心职责：从 Treiber Stack 中移除超时或被中断的等待节点，避免内存泄漏。</span><br><span class="hljs-comment"> * 设计动因：等待线程因超时/中断退出时，其 WaitNode 仍在栈中，需主动清理。</span><br><span class="hljs-comment"> * 并发安全策略：头节点用 CAS 移除，内部节点直接修改 next（因为 finishCompletion</span><br><span class="hljs-comment"> * 遍历时会跳过 thread==null 的节点，所以并发修改无害）。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * race.  This is slow when there are a lot of nodes, but we don&#x27;t</span><br><span class="hljs-comment"> * expect lists to be long enough to outweigh higher-overhead</span><br><span class="hljs-comment"> * schemes.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeWaiter</span><span class="hljs-params">(WaitNode node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 第一步：标记节点为「待删除」，置空 thread 引用</span><br>        node.thread = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 外层循环：检测到并发冲突时从头重新遍历</span><br>        retry:<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 内层循环：遍历链表，pred 记录前驱，q 是当前节点，s 是后继</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">WaitNode</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, q = waiters, s; q != <span class="hljs-literal">null</span>; q = s) &#123;<br>                s = q.next;  <span class="hljs-comment">// 先保存后继，因为 q 可能被移除</span><br>                <span class="hljs-keyword">if</span> (q.thread != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 节点有效，更新前驱指针继续遍历</span><br>                    pred = q;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 内部节点待删除：直接修改前驱的 next 跳过当前节点</span><br>                    pred.next = s;<br>                    <span class="hljs-comment">// TOCTOU 防护：若前驱也被并发标记为待删除，需重新遍历</span><br>                    <span class="hljs-keyword">if</span> (pred.thread == <span class="hljs-literal">null</span>)<br>                        <span class="hljs-keyword">continue</span> retry;<br>                &#125;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                                                      q, s))<br>                    <span class="hljs-comment">// 头节点待删除：CAS 更新 waiters 指针，失败则重试</span><br>                    <span class="hljs-keyword">continue</span> retry;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;  <span class="hljs-comment">// 遍历完成，退出</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="report-：终态到返回值-异常的转换">report()：终态到返回值/异常的转换</h5>
<p><code>report()</code> 根据终态将 outcome 解释为结果或异常。outcome 是 Object 类型，可能是结果 V 或 Throwable，由 state 决定如何解释。类型安全由状态机保证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心职责：根据终态将 outcome 解释为结果或异常，是 get() 的最终出口。</span><br><span class="hljs-comment">// 设计动因：outcome 是 Object 类型，可能是结果 V 或 Throwable，</span><br><span class="hljs-comment">// 类型安全由状态机保证——只有 NORMAL 时才强转为 V，EXCEPTIONAL 时才强转为 Throwable。</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;  <span class="hljs-comment">// 此时 state 已是终态，outcome 可见性由 volatile state 读保证</span><br>    <span class="hljs-keyword">if</span> (s == NORMAL)<br>        <span class="hljs-keyword">return</span> (V)x;  <span class="hljs-comment">// 正常完成：返回结果</span><br>    <span class="hljs-keyword">if</span> (s &gt;= CANCELLED)<br>        <span class="hljs-comment">// 取消/中断：抛出 CancellationException（无需 outcome，因为取消无结果）</span><br>        <span class="hljs-comment">// 注意：此异常在 get() 调用时才抛出，而非 cancel() 时。</span><br>        <span class="hljs-comment">// cancel() 只设置状态位，延迟异常模式允许调用方选择是否感知取消。</span><br>        <span class="hljs-comment">// 与 afterExecute(Throwable t) 无关——afterExecute 捕获的是 task.run() 向外抛出的异常，</span><br>        <span class="hljs-comment">// 而 FutureTask.run() 不向外抛异常，CancellationException 仅在此处（get() 调用链）产生。</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<br>    <span class="hljs-comment">// 异常完成：包装为 ExecutionException，表明错误来自任务内部而非线程池</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable)x);<br>&#125;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>终态</th>
<th>report() 行为</th>
<th>调用方感知</th>
</tr>
</thead>
<tbody>
<tr>
<td>NORMAL</td>
<td>返回 <code>(V)outcome</code></td>
<td>正常获取结果</td>
</tr>
<tr>
<td>EXCEPTIONAL</td>
<td>抛出 <code>ExecutionException((Throwable)outcome)</code></td>
<td><code>catch (ExecutionException)</code></td>
</tr>
<tr>
<td>CANCELLED / INTERRUPTED</td>
<td>抛出 <code>CancellationException</code></td>
<td><code>catch (CancellationException)</code></td>
</tr>
</tbody>
</table>
<h4 id="futuretask-在线程池中的调用链路">FutureTask 在线程池中的调用链路</h4>
<p>每个线程池的 Worker 管理的实质上是 FutureTask。一个标准的可执行可等待任务是一个 <code>RunnableFuture&lt;V&gt;</code>，用成员变量来帮助 <code>Runnable</code> 保存一个 <code>Callable</code> 的返回值，以供 <code>Future</code> 使用。以 <code>invokeAll</code> 为例，完整的调用链路如下：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant User
    participant AbstractExecutorService
    participant ThreadPoolExecutor
    participant WorkerThread
    participant FutureTask
    
    User-&gt;&gt;AbstractExecutorService: invokeAll(tasks)
    loop for each task
        AbstractExecutorService-&gt;&gt;AbstractExecutorService: newTaskFor(task)
        AbstractExecutorService-&gt;&gt;FutureTask: new FutureTask(task)
        AbstractExecutorService-&gt;&gt;ThreadPoolExecutor: execute(futureTask)
        ThreadPoolExecutor-&gt;&gt;WorkerThread: 分配任务
        WorkerThread-&gt;&gt;FutureTask: futureTask.run()
        FutureTask-&gt;&gt;FutureTask: callable.call()
        FutureTask-&gt;&gt;FutureTask: set(result)
    end
    
    AbstractExecutorService-&gt;&gt;AbstractExecutorService: for each future: future.get()
    loop for each future
        AbstractExecutorService-&gt;&gt;FutureTask: future.get()
        alt 任务已完成
            FutureTask--&gt;&gt;AbstractExecutorService: 立即返回结果
        else 任务未完成
            FutureTask--&gt;&gt;FutureTask: 挂起等待
            FutureTask-&gt;&gt;FutureTask: 任务完成后唤醒
            FutureTask--&gt;&gt;AbstractExecutorService: 返回结果
        end
    end
    
    AbstractExecutorService--&gt;&gt;User: 返回所有Future结果</code></pre>
<h3 id="invokeall">invokeAll</h3>
<p><strong>invokeAll 是有界的</strong>-有界来源于底层的 execute 是有界的，如果一次性提交了超过它界限的任务，即使这些任务是一瞬间执行的-invokeAll 也会触发拒绝，除非任务执行的速度比 for 循环调用底层的 execute 的速度还要快。</p>
<p>如果有得选，我们批量执行任务应该尽量采用 invokeAll，因为它带有这些特殊的代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                                         <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (tasks == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(tasks.size());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">done</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks)<br>                futures.add(newTaskFor(t));<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> futures.size();<br><br>            <span class="hljs-comment">// Interleave time checks and calls to execute in case</span><br>            <span class="hljs-comment">// executor doesn&#x27;t have any/much parallelism.</span><br>            <span class="hljs-comment">// 释义：交替进行超时检查和任务提交，以防执行器没有足够的并行度。</span><br>            <span class="hljs-comment">// 设计意图：如果线程池并行度很低（如单线程池），需要在提交每个任务后检查是否已超时，</span><br>            <span class="hljs-comment">// 否则可能在所有任务提交完成前就已经超时了。</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                <span class="hljs-comment">// invokeAll 的有界性源于 execute 的有界性（队列容量 + 线程数上限 + 拒绝策略）</span><br>                execute((Runnable)futures.get(i));<br>                nanos = deadline - System.nanoTime();<br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> futures;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                Future&lt;T&gt; f = futures.get(i);<br>                <span class="hljs-keyword">if</span> (!f.isDone()) &#123;<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                        <span class="hljs-keyword">return</span> futures;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 等待任务完成，get() 可多次调用返回相同结果</span><br>                        f.get(nanos, TimeUnit.NANOSECONDS);<br>                    &#125; <span class="hljs-keyword">catch</span> (CancellationException ignore) &#123;<br>                    &#125; <span class="hljs-keyword">catch</span> (ExecutionException ignore) &#123;<br>                    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>                        <span class="hljs-keyword">return</span> futures;<br>                    &#125;<br>                    nanos = deadline - System.nanoTime();<br>                &#125;<br>            &#125;<br>            done = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> futures;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (!done)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = futures.size(); i &lt; size; i++)                <br>                    <span class="hljs-comment">// 我们不鼓励 cancel java 线程，但是可以，而且鼓励 cancel Future</span><br>                    futures.get(i).cancel(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Caller as 调用方
    participant AES as AbstractExecutorService
    participant TPE as ThreadPoolExecutor
    participant FT as FutureTask[]

    Caller-&gt;&gt;AES: invokeAll(tasks, timeout)
    
    rect rgb(240, 248, 255)
        Note over AES: 第一阶段：包装任务
        loop 遍历 tasks
            AES-&gt;&gt;FT: newTaskFor(callable)
        end
    end
    
    rect rgb(255, 248, 240)
        Note over AES: 第二阶段：提交任务（有界性来源）
        loop 遍历 futures
            AES-&gt;&gt;TPE: execute(futureTask)
            Note right of TPE: 队列满则触发拒绝策略
            AES-&gt;&gt;AES: 检查超时
            alt 已超时
                AES--&gt;&gt;Caller: return futures（部分未提交）
            end
        end
    end
    
    rect rgb(240, 255, 240)
        Note over AES: 第三阶段：等待完成
        loop 遍历 futures
            AES-&gt;&gt;FT: f.get(remaining, NANOSECONDS)
            alt 超时
                AES--&gt;&gt;Caller: return futures（部分未完成）
            end
        end
    end
    
    AES-&gt;&gt;AES: done = true
    AES--&gt;&gt;Caller: return futures（全部完成）
    
    Note over AES: finally: if (!done) cancel 所有任务</code></pre>
<h3 id="两种针对-runnable-的-submit">两种针对 Runnable 的 submit</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通 submit(Runnable) - Future.get() 返回 null</span><br>Future&lt;?&gt; future3 = executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;普通任务&quot;</span>));<br><span class="hljs-type">Object</span> <span class="hljs-variable">result3</span> <span class="hljs-operator">=</span> future3.get(); <span class="hljs-comment">// result3 == null</span><br><br><span class="hljs-comment">// submit(Runnable, T result) - Future.get() 返回指定的结果</span><br>Future&lt;String&gt; future4 = executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;带结果的任务&quot;</span>), <span class="hljs-string">&quot;自定义结果&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">result4</span> <span class="hljs-operator">=</span> future4.get(); <span class="hljs-comment">// result4 == &quot;自定义结果&quot;</span><br></code></pre></td></tr></table></figure>
<p>这里面使用到了2种适配器：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">用户层：需要 <span class="hljs-built_in">submit</span>(Runnable, T result) 这样的高级API<br>       ↓<br>适配层：RunnableAdapter 提供语义适配<br>       ↓  <br>执行层：FutureTask 提供接口适配  <br>       ↓<br>基础层：ThreadPoolExecutor 只认 <span class="hljs-built_in">execute</span>(Runnable)<br></code></pre></td></tr></table></figure>
<p>底层的 execute 本身要求一个包含 callable + result 的 runnbale - FutureTask（向底层的 execute api 适配，向外提供 Future 的 get、cancel 等能力），但是这样的 callable 最初又要经过 RunnableAdapter 从 Runnable 得来（向上向原始的没有返回值的 Runnable 适配）。</p>
<p>可以认为，RunnableAdapter 是一个对象适配器，原始类型是 Runnable，目标类型是 Callable。</p>
<p>我们得到一个 Runnable，要先经过 RunnableAdapter 转成普通 Callable，然后再经 FutureTask 转成 RunnableFuture。</p>
<p>两类底层调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 底层调用链</span><br><span class="hljs-comment">// 1. submit(callable) → new FutureTask(callable)</span><br><span class="hljs-comment">// 2. execute(futureTask) → futureTask.run()</span><br><span class="hljs-comment">// 3. futureTask.run() → callable.call() → return 42</span><br><span class="hljs-comment">// 4. future.get() → 42</span><br><br><span class="hljs-comment">// 底层调用链</span><br><span class="hljs-comment">// 1. submit(runnable, result) → Executors.callable(runnable, result) </span><br><span class="hljs-comment">//   → new RunnableAdapter(runnable, result)</span><br><span class="hljs-comment">// 2. new FutureTask(runnableAdapter) </span><br><span class="hljs-comment">//   → futureTask内部持有runnableAdapter</span><br><span class="hljs-comment">// 3. execute(futureTask) → futureTask.run()</span><br><span class="hljs-comment">// 4. futureTask.run() → runnableAdapter.call()</span><br><span class="hljs-comment">// 5. runnableAdapter.call() → runnable.run() + return successMessage</span><br><span class="hljs-comment">// 6. future.get() → successMessage</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Caller as 调用方
    participant AES as AbstractExecutorService
    participant RA as RunnableAdapter
    participant FT as FutureTask
    participant TPE as ThreadPoolExecutor

    rect rgb(240, 248, 255)
        Note over Caller,TPE: 路径一：submit(Callable)
        Caller-&gt;&gt;AES: submit(callable)
        AES-&gt;&gt;FT: new FutureTask(callable)
        AES-&gt;&gt;TPE: execute(futureTask)
        TPE-&gt;&gt;FT: futureTask.run()
        FT-&gt;&gt;FT: callable.call()
        Caller-&gt;&gt;FT: future.get()
        FT--&gt;&gt;Caller: 返回 callable 的结果
    end

    rect rgb(255, 248, 240)
        Note over Caller,TPE: 路径二：submit(Runnable, result)
        Caller-&gt;&gt;AES: submit(runnable, result)
        AES-&gt;&gt;RA: Executors.callable(runnable, result)
        Note right of RA: RunnableAdapter 封装
        AES-&gt;&gt;FT: new FutureTask(runnableAdapter)
        AES-&gt;&gt;TPE: execute(futureTask)
        TPE-&gt;&gt;FT: futureTask.run()
        FT-&gt;&gt;RA: runnableAdapter.call()
        RA-&gt;&gt;RA: runnable.run()
        RA--&gt;&gt;FT: return result
        Caller-&gt;&gt;FT: future.get()
        FT--&gt;&gt;Caller: 返回预设的 result
    end</code></pre>
<p>至此，我们已经理解了执行器体系的继承关系、任务包装机制和调用链路。</p>
<h3 id="相关适配器一览">相关适配器一览</h3>
<p><code>newTaskFor</code> 使用 <code>FutureTask</code> 将 <code>Callable/Runnable</code> 适配为 <code>RunnableFuture</code>，这是 ThreadPoolExecutor 体系的核心适配机制。JDK 中还有其他场景的任务适配器：</p>
<p><strong>Executors.RunnableAdapter</strong></p>
<p><code>RunnableAdapter</code> 将 <code>Runnable + result</code> 适配为 <code>Callable</code>，用于 <code>submit(Runnable, T result)</code> 场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Executors.java</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">final</span> Runnable task;<br>    <span class="hljs-keyword">final</span> T result;<br>    RunnableAdapter(Runnable task, T result) &#123;<br>        <span class="hljs-built_in">this</span>.task = task;<br>        <span class="hljs-built_in">this</span>.result = result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>        task.run();<br>        <span class="hljs-keyword">return</span> result;  <span class="hljs-comment">// 返回预设的结果</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用场景</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);  <span class="hljs-comment">// 内部调用 Executors.callable(task, result)</span><br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">// Executors.callable() 的实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="hljs-title function_">callable</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt;(task, result);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>ForkJoinTask 中的适配器</strong></p>
<p>ForkJoinPool 要求任务必须是 <code>ForkJoinTask</code> 类型，因此需要不同的适配器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinTask.java（JDK 8 及之前版本）</span><br><br><span class="hljs-comment">// 将 Runnable + result 适配为 ForkJoinTask&lt;T&gt;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdaptedRunnable</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;T&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">final</span> Runnable runnable;<br>    <span class="hljs-keyword">final</span> T resultOnCompletion;<br>    AdaptedRunnable(Runnable runnable, T result) &#123;<br>        <span class="hljs-built_in">this</span>.runnable = runnable;<br>        <span class="hljs-built_in">this</span>.resultOnCompletion = result;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> resultOnCompletion; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(T v)</span> &#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span> &#123;<br>        runnable.run();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; invoke(); &#125;<br>&#125;<br><br><span class="hljs-comment">// 将 Runnable 适配为 ForkJoinTask&lt;Void&gt;（无返回值）</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdaptedRunnableAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;Void&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">final</span> Runnable runnable;<br>    AdaptedRunnableAction(Runnable runnable) &#123;<br>        <span class="hljs-built_in">this</span>.runnable = runnable;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(Void v)</span> &#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span> &#123;<br>        runnable.run();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; invoke(); &#125;<br>&#125;<br><br><span class="hljs-comment">// 将 Callable&lt;T&gt; 适配为 ForkJoinTask&lt;T&gt;</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdaptedCallable</span>&lt;T&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;T&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;<br>    Callable&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; callable;<br>    T result;<br>    AdaptedCallable(Callable&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; callable) &#123;<br>        <span class="hljs-built_in">this</span>.callable = callable;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> result; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(T v)</span> &#123; result = v; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            result = callable.call();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            setException(e);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123; <span class="hljs-keyword">return</span> invoke(); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>ForkJoinPool 中的 RunnableExecuteAdapter</strong></p>
<p>JDK 较新版本中，ForkJoinPool 使用 <code>RunnableExecuteAdapter</code> 处理 <code>execute(Runnable)</code> 场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinPool.java（JDK 较新版本）</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableExecuteAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;Void&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">final</span> Runnable runnable;<br>    RunnableExecuteAdapter(Runnable runnable) &#123;<br>        <span class="hljs-built_in">this</span>.runnable = runnable;<br>    &#125;<br>    <span class="hljs-keyword">public</span> Void <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(Void v)</span> &#123; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">exec</span><span class="hljs-params">()</span> &#123;<br>        runnable.run();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; invoke(); &#125;<br>&#125;<br><br><span class="hljs-comment">// ForkJoinPool.execute() 使用</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    ForkJoinTask&lt;?&gt; job;<br>    <span class="hljs-keyword">if</span> (task <span class="hljs-keyword">instanceof</span> ForkJoinTask)<br>        job = (ForkJoinTask&lt;?&gt;) task;  <span class="hljs-comment">// 已是 ForkJoinTask，无需包装</span><br>    <span class="hljs-keyword">else</span><br>        job = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableExecuteAdapter</span>(task);  <span class="hljs-comment">// 包装为 ForkJoinTask</span><br>    externalPush(job);  <span class="hljs-comment">// 提交到外部队列</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>适配器对比</strong></p>
<table>
<thead>
<tr>
<th>适配器</th>
<th>所在类</th>
<th>输入</th>
<th>输出</th>
<th>使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>FutureTask</code></td>
<td>AbstractExecutorService</td>
<td><code>Callable&lt;T&gt;</code> 或 <code>Runnable + T</code></td>
<td><code>RunnableFuture&lt;T&gt;</code></td>
<td><code>submit()</code> 返回 Future</td>
</tr>
<tr>
<td><code>RunnableAdapter</code></td>
<td>Executors</td>
<td><code>Runnable + T</code></td>
<td><code>Callable&lt;T&gt;</code></td>
<td><code>submit(Runnable, T)</code> 内部转换</td>
</tr>
<tr>
<td><code>AdaptedRunnable&lt;T&gt;</code></td>
<td>ForkJoinTask</td>
<td><code>Runnable + T</code></td>
<td><code>ForkJoinTask&lt;T&gt;</code></td>
<td>ForkJoinPool 处理带返回值的 Runnable</td>
</tr>
<tr>
<td><code>AdaptedRunnableAction</code></td>
<td>ForkJoinTask</td>
<td><code>Runnable</code></td>
<td><code>ForkJoinTask&lt;Void&gt;</code></td>
<td>ForkJoinPool 处理无返回值 Runnable</td>
</tr>
<tr>
<td><code>AdaptedCallable&lt;T&gt;</code></td>
<td>ForkJoinTask</td>
<td><code>Callable&lt;T&gt;</code></td>
<td><code>ForkJoinTask&lt;T&gt;</code></td>
<td>ForkJoinPool 处理 Callable</td>
</tr>
<tr>
<td><code>RunnableExecuteAdapter</code></td>
<td>ForkJoinPool</td>
<td><code>Runnable</code></td>
<td><code>ForkJoinTask&lt;Void&gt;</code></td>
<td>ForkJoinPool.execute(Runnable)</td>
</tr>
</tbody>
</table>
<p><strong>设计模式共性</strong></p>
<p>这些适配器都遵循<strong>适配器模式</strong>，核心价值是：</p>
<ol>
<li><strong>接口统一</strong>：将不同形式的任务（Runnable、Callable、ForkJoinTask）适配为统一的执行格式</li>
<li><strong>语义保持</strong>：适配过程中保持原任务的执行语义不变</li>
<li><strong>功能增强</strong>：为原任务添加 Future 能力（取消、结果获取、状态查询）</li>
</ol>
<pre><code class="hljs mermaid">classDiagram
    %% ========== 接口层 ==========
    class Runnable &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    class Callable~T~ &#123;
        &lt;&lt;interface&gt;&gt;
        +call() T
    &#125;
    class Future~T~ &#123;
        &lt;&lt;interface&gt;&gt;
        +get() T
        +cancel(boolean) boolean
        +isDone() boolean
    &#125;
    class RunnableFuture~T~ &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    class ForkJoinTask~T~ &#123;
        &lt;&lt;abstract&gt;&gt;
        +exec() boolean
        +getRawResult() T
        +setRawResult(T) void
        note: &quot;增强Future:fork/join+工作窃取&quot;
    &#125;
    
    %% ========== 实现层：适配器 ==========
    class RunnableAdapter~T~ &#123;
        -Runnable task
        -T result
        +call() T
    &#125;
    class FutureTask~T~ &#123;
        -Callable~T~ callable
        +run() void
        +get() T
    &#125;
    class AdaptedRunnable~T~ &#123;
        -Runnable runnable
        -T resultOnCompletion
        +exec() boolean
    &#125;
    
    %% ========== 继承关系 ==========
    RunnableFuture --|&gt; Runnable
    RunnableFuture --|&gt; Future
    ForkJoinTask --|&gt; Future
    AdaptedRunnable --|&gt; ForkJoinTask
    
    %% ========== 实现关系 ==========
    RunnableAdapter ..|&gt; Callable
    FutureTask ..|&gt; RunnableFuture
    
    %% ========== 组合关系 ==========
    RunnableAdapter o-- Runnable : wraps
    FutureTask o-- Callable : wraps
    AdaptedRunnable o-- Runnable : wraps</code></pre>
<hr>
<h1>ThreadPoolExecutor</h1>
<blockquote>
<p><strong>前置知识</strong>：本节内容依赖对 ThreadPoolExecutor 内部状态机制的理解。如对状态体系不熟悉，请先阅读 <a href="#%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84ctl-%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E6%9C%BA">核心架构：ctl 与线程池状态机</a> 章节。</p>
</blockquote>
<h2 id="核心架构：ctl-与线程池状态机">核心架构：ctl 与线程池状态机</h2>
<p>在深入 ThreadPoolExecutor 的状态维护机制之前，有必要先厘清线程池体系中涉及的多层状态体系。线程池架构中存在 <strong>4 层独立但相互关联的状态体系</strong>：</p>
<table>
<thead>
<tr>
<th>状态体系</th>
<th>层级</th>
<th>状态数量</th>
<th>状态类型</th>
<th>核心作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ThreadPoolExecutor 生命周期状态</strong></td>
<td>池级别</td>
<td>5 种</td>
<td>RUNNING → SHUTDOWN/STOP → TIDYING → TERMINATED</td>
<td>控制线程池整体生命周期</td>
</tr>
<tr>
<td><strong>Worker 锁状态</strong></td>
<td>工作线程级别</td>
<td>3 种</td>
<td>-1 / 0 / 1</td>
<td>保护任务执行期间的中断控制（-1 是 Worker 自定义的初始化状态，0/1 是 AQS 标准锁状态）</td>
</tr>
<tr>
<td><strong>Java Thread 状态</strong></td>
<td>原生线程级别</td>
<td>6 种</td>
<td>NEW / RUNNABLE / BLOCKED / WAITING / TIMED_WAITING / TERMINATED</td>
<td>JVM 线程调度与监控</td>
</tr>
<tr>
<td><strong>FutureTask 任务状态</strong></td>
<td>任务级别</td>
<td>7 种</td>
<td>NEW → COMPLETING → NORMAL/EXCEPTIONAL/CANCELLED/INTERRUPTED</td>
<td>异步任务生命周期</td>
</tr>
</tbody>
</table>
<p>这 4 层状态<strong>相互独立又相互影响</strong>。例如：线程池进入 STOP 状态会中断 Worker，Worker 被中断会导致其持有的 Java 线程状态变化；<strong>FutureTask 的状态变化则独立于线程池和 Worker</strong>，仅反映任务自身的执行进展。理解这些状态的层次关系，有助于在排查线程池问题时准确定位问题所在层级。</p>
<p>下面首先介绍 ThreadPoolExecutor 自身的生命周期状态维护机制。</p>
<p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量(workerCount)。这种将多个字段打包到一个整型变量中的设计称为<strong>字段打包(Field Packing)</strong>，是无锁编程中的一种惯用法。位运算只是实现手段，核心目的是将多个逻辑字段打包到一个物理字段中，实现单次CAS原子更新。</p>
<p><strong>JDK中Field Packing应用案例</strong>：</p>
<table>
<thead>
<tr>
<th>类</th>
<th>字段</th>
<th>打包内容</th>
<th>设计目的</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ThreadPoolExecutor</code></td>
<td><code>ctl</code></td>
<td>高3位runState + 低29位workerCount</td>
<td>原子更新状态与线程数</td>
</tr>
<tr>
<td><code>ForkJoinPool</code></td>
<td><code>ctl</code></td>
<td>高16位runState + 中间位workerCount + 其他标志</td>
<td>原子更新状态、线程数与并行度</td>
</tr>
<tr>
<td><code>ReentrantReadWriteLock.Sync</code></td>
<td><code>state</code></td>
<td>高16位读锁计数 + 低16位写锁计数</td>
<td>原子更新读写锁计数</td>
</tr>
<tr>
<td><code>StampedLock</code></td>
<td><code>state</code></td>
<td>高24位版本戳 + 第8位写锁标志 + 低7位读锁计数</td>
<td>乐观读锁与版本校验</td>
</tr>
<tr>
<td><code>LongAdder.Cell</code></td>
<td>状态字</td>
<td>竞争标志 + 计数值</td>
<td>高并发累加优化</td>
</tr>
</tbody>
</table>
<p>在具体实现中，线程池将运行状态(runState)、线程数量(workerCount)两个关键参数的维护放在了一起，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>
<p>ctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段，它同时包含两部分的信息：线程池的运行状态(runState)和线程池内有效线程的数量(workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。</p>
<p><strong>原子更新机制</strong>：线程数放低位的设计使得<code>ctl.getAndIncrement()</code>可直接原子增加线程数而不影响高位状态，但必须校验<code>workerCount &lt; CAPACITY</code>防止溢出污染状态位（不要忘记，CAPACITY 作为掩码是一个大整数）。状态变更则需要通过<code>ctl.compareAndSet(oldCtl, ctlOf(newState, workerCountOf(oldCtl)))</code>复合更新，一次CAS同时更新两个字段。</p>
<p>用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数，均使用位运算实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 29</span><br>        System.out.println(COUNT_BITS);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">shifted</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 1 与 29 个 0，所以左移意味着补 0，左移一位意味着补 1 个 0，左移 29 位意味着补 29 个 0，最后得到 30 位数：100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(shifted));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> shifted - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 29个 1：11111111111111111111111111111，其实左边还有3个0</span><br>        System.out.println(Integer.toBinaryString(CAPACITY));<br>        <span class="hljs-comment">// 高 3 位为 1，低 29 位为 0：11100000000000000000000000000000，和 CAPACITY 低 29 位为 1，高 3 位为 0 恰好相反</span><br>        System.out.println(Integer.toBinaryString(~CAPACITY));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// -1 意味着 32 个 1：11111111111111111111111111111111</span><br>        System.out.println(Integer.toBinaryString(-<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 3 个 1 和 29 个 0：11100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(RUNNING));<br>        <br>        <span class="hljs-comment">// 重点：从后方补 0 的算法，可以把 state 的基准位从低位移到高位，这样大数的一部分就可以拿来表示有限状态了</span><br>        <br>        <span class="hljs-comment">// 0 不管位移多少位都是 0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br>        System.out.println(Integer.toBinaryString(SHUTDOWN));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 1 和 29 个 0：100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(STOP));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 10 和 29 个 0：1000000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(TIDYING));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 11 和 29 个 0：1100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(TERMINATED));<br><br>        <span class="hljs-comment">// 总结：因为有5种状态，所以需要3个二进制位</span><br>    &#125;<br></code></pre></td></tr></table></figure>
<p><strong>各状态的二进制表示</strong>（Java 7+ 支持 <code>0b</code> 前缀的二进制字面量）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程数容量：低29位全1</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br><span class="hljs-comment">// CAPACITY = 0b000_11111111111111111111111111111</span><br><br><span class="hljs-comment">// 运行状态：高3位存储</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// RUNNING    = 0b111_00000000000000000000000000000</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// SHUTDOWN   = 0b000_00000000000000000000000000000</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// STOP       = 0b001_00000000000000000000000000000</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// TIDYING    = 0b010_00000000000000000000000000000</span><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br><span class="hljs-comment">// TERMINATED = 0b011_00000000000000000000000000000</span><br></code></pre></td></tr></table></figure>
<p><strong>位分布示意</strong>：</p>
<figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tap">位索引:  <span class="hljs-number"> 31 </span>30<span class="hljs-number"> 29 </span>|<span class="hljs-number"> 28 </span>27<span class="hljs-number"> 26 </span>...<span class="hljs-number"> 1 </span>0<br>          └───┬───┘ └───────┬───────┘<br>           runState       workerCount<br>            (3位)           (29位)<br><br>RUNNING:     <span class="hljs-number"> 111 </span>| 00000000000000000000000000000<br>SHUTDOWN:    <span class="hljs-number"> 000 </span>| 00000000000000000000000000000<br>STOP:        <span class="hljs-number"> 001 </span>| 00000000000000000000000000000<br>TIDYING:     <span class="hljs-number"> 010 </span>| 00000000000000000000000000000<br>TERMINATED:  <span class="hljs-number"> 011 </span>| 00000000000000000000000000000<br></code></pre></td></tr></table></figure>
<p>状态值按数值大小排列：<code>RUNNING(-1) &lt; SHUTDOWN(0) &lt; STOP(1) &lt; TIDYING(2) &lt; TERMINATED(3)</code>，这使得 <code>runStateAtLeast(c, state)</code> 可通过数值比较判断状态是否达到或超过某阈值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ctl 的拆解与组合方法，基于位运算实现高效状态操作。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 设计要点：</span><br><span class="hljs-comment">// 1. ~CAPACITY 即 0b11100000...00，取高 3 位的掩码</span><br><span class="hljs-comment">// 2. CAPACITY 即 0b00011111...11，取低 29 位的掩码</span><br><span class="hljs-comment">// 3. OR 运算组合状态与线程数，因为两者位不重叠</span><br><span class="hljs-comment">// 4. 这些操作都是纯位运算，无锁且高效</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 提取运行状态：取高 3 位，低 29 位置 0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123;<br>    <span class="hljs-comment">// c &amp; ~CAPACITY = c &amp; 0b11100000...00</span><br>    <span class="hljs-comment">// 例如：0b111_xxxxx (RUNNING + workerCount) &amp; 0b11100000...00 = 0b11100000...00 = RUNNING</span><br>    <span class="hljs-keyword">return</span> c &amp; ~CAPACITY;<br>&#125;<br><span class="hljs-comment">// 提取线程数：取低 29 位，高 3 位置 0</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123;<br>    <span class="hljs-comment">// c &amp; CAPACITY = c &amp; 0b00011111...11</span><br>    <span class="hljs-comment">// 例如：0b111_00000...00101 (RUNNING + 5) &amp; 0b00011111...11 = 5</span><br>    <span class="hljs-keyword">return</span> c &amp; CAPACITY;<br>&#125;<br><span class="hljs-comment">// 组合状态与线程数：高 3 位放 rs，低 29 位放 wc</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123;<br>    <span class="hljs-comment">// rs | wc，例如：RUNNING | 5 = 0b111_00000...00000 | 0b000_00000...00101 = 0b111_00000...00101</span><br>    <span class="hljs-keyword">return</span> rs | wc;<br>&#125;<br><span class="hljs-comment">// CAS 更新 ctl：原子性地更新状态+线程数</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, update);<br>&#125;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">运行状态</th>
<th style="text-align:center">状态描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RUNNING</td>
<td style="text-align:center">能接受新提交的任务，并且也能处理阻塞队列中的任务。</td>
</tr>
<tr>
<td style="text-align:center">SHUTDOWN</td>
<td style="text-align:center">关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。</td>
</tr>
<tr>
<td style="text-align:center">STOP</td>
<td style="text-align:center">不能接受新任务，<strong>也不处理队列中的任务，会中断正在处理任务的线程</strong>。增加了两条措施，是一个更严厉的状态，理论上只要线程被中断完，线程池就可以走向关闭</td>
</tr>
<tr>
<td style="text-align:center">TIDYING</td>
<td style="text-align:center">所有的任务都已终止了，workerCount (有效线程数) 为0，这个状态的意思不是整理中，而是整理完了。</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td style="text-align:center">在terminated() 方法执行完后进入该状态。</td>
</tr>
</tbody>
</table>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程池生命周期.png"></p>
<p>其中 running 既是初始态，也是中间态，所以才有<code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</code>作为初始化块的一部分。</p>
<h2 id="threadpoolexecutor-如何管理任务">ThreadPoolExecutor 如何管理任务</h2>
<h3 id="设计哲学：任务与线程解耦">设计哲学：任务与线程解耦</h3>
<p><strong>线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦</strong>，不让两者直接关联，才可以做后续的分配工作。线程池采用<strong>生产者消费者模式</strong>，通过<strong>阻塞队列实现任务缓冲</strong>。</p>
<p>任务执行存在两种路径：</p>
<table>
<thead>
<tr>
<th>路径</th>
<th>触发条件</th>
<th>机制</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>firstTask 路径</strong></td>
<td>创建新 Worker 时（核心线程未满，或队列满但非核心线程未满）</td>
<td>任务作为 <code>firstTask</code> 直接传入 Worker，<strong>省去入队再出队的开销</strong></td>
</tr>
<tr>
<td><strong>队列路径</strong></td>
<td>任务入队后</td>
<td>空闲 Worker 通过 <code>getTask()</code> 从队列 <code>poll/take</code> 获取任务</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// runWorker 源码片段——体现两种路径</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;  <span class="hljs-comment">// 路径1：Worker 创建时直接携带的任务</span><br>w.firstTask = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 置空以后才使用，只能使用一次</span><br><span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;  <span class="hljs-comment">// 路径2：从队列获取</span><br>    <span class="hljs-comment">// 执行任务</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="任务提交入口：submit-与-execute">任务提交入口：submit 与 execute</h3>
<p><strong>submit 方法</strong>（AbstractExecutorService 提供）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// submit 方法是 AbstractExecutorService 提供的高级任务提交接口，与 execute 的核心区别是返回 Future。</span><br><span class="hljs-comment">// 设计模式：模板方法模式。submit 实现统一的任务包装和提交流程，底层调用子类实现的 execute()。</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 异常处理语义：</span><br><span class="hljs-comment">// - RejectedExecutionException：线程池已关闭或达到容量上限</span><br><span class="hljs-comment">// - NullPointerException：任务为 null</span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Javadoc 释义：<span class="hljs-doctag">@throws</span> 继承父接口 ExecutorService 的异常说明：</span><br><span class="hljs-comment"> * &lt;ul&gt;</span><br><span class="hljs-comment"> *   &lt;li&gt;RejectedExecutionException：任务被拒绝（线程池已关闭或饱和）&lt;/li&gt;</span><br><span class="hljs-comment"> *   &lt;li&gt;NullPointerException：任务为 null&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;/ul&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Javadoc 释义：同上，此重载允许调用方预设返回值。</span><br><span class="hljs-comment"> * 任务执行完成后，&#123;<span class="hljs-doctag">@code</span> Future.get()&#125; 将返回预设的 &#123;<span class="hljs-doctag">@code</span> result&#125;，</span><br><span class="hljs-comment"> * 而非 &#123;<span class="hljs-doctag">@code</span> null&#125;（&#123;<span class="hljs-doctag">@code</span> Runnable.run()&#125; 本身无返回值）。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Javadoc 释义：最常用的重载，任务自带返回值逻辑。</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> Callable.call()&#125; 的返回值将作为 &#123;<span class="hljs-doctag">@code</span> Future.get()&#125; 的结果。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>execute 方法</strong>（ThreadPoolExecutor 核心）：</p>
<p><img src="Worker%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.png" alt="Worker执行任务.png"></p>
<p>图中空任务的 worker 看下面对 execute 的入队分支的注释。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * execute 是 ThreadPoolExecutor 的核心方法，体现线程池任务调度策略的顶层设计。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 【调度策略】先 core 后 queue 后非 core：</span><br><span class="hljs-comment"> * 先尝试创建核心线程，再入队，最后创建非核心线程。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 【执行路径】任务有两种执行路径：</span><br><span class="hljs-comment"> * 1. 新线程直接执行：firstTask 作为新创建 Worker 的第一个任务</span><br><span class="hljs-comment"> * 2. 入队等待执行：空闲 Worker 通过 getTask() 从队列获取</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * JDK 源码描述：Executes the given task sometime in the future.</span><br><span class="hljs-comment"> * The task may execute in a new thread or in an existing pooled thread.</span><br><span class="hljs-comment"> * - 「sometime in the future」：异步语义，不保证立即执行</span><br><span class="hljs-comment"> * - 「new thread or existing pooled thread」：上述两种执行路径</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 【拒绝时机】</span><br><span class="hljs-comment"> * - 线程池已 shutdown</span><br><span class="hljs-comment"> * - 队列已满且线程数达 maximumPoolSize</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> command 待执行的任务，不允许为 null</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException 任务被拒绝时抛出，由 RejectedExecutionHandler 决定</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException command 为 null 时抛出</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * ========== 三步调度策略 ==========</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 步骤1：workerCount &lt; corePoolSize → 创建核心线程直接执行</span><br><span class="hljs-comment">     * 步骤2：入队成功 → 双重检查（状态检查 + 消费者检查）</span><br><span class="hljs-comment">     * 步骤3：入队失败/线程池不再运行 → 创建非核心线程，失败则拒绝</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 关键设计差异：</span><br><span class="hljs-comment">     * - addWorker 成功 → 任务已绑定线程，无需后续检查</span><br><span class="hljs-comment">     * - offer 成功 → 任务在队列中无&quot;主人&quot;，必须双重检查</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 注：此处&quot;双重检查&quot;指入队前后的状态校验，非 DCL 模式。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br><br>    <span class="hljs-comment">// ==================== 步骤1：尝试创建核心线程 ====================</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))  <span class="hljs-comment">// true = 受 corePoolSize 限制。在这个方法里，只有这一个地方可能 addWorker 的类型是 true</span><br>            <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 成功：任务已绑定到 Worker 线程，无需后续检查</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 【失败原因】workerCount &lt; corePoolSize 仍可能失败：</span><br><span class="hljs-comment">         * (1) 池状态变为 SHUTDOWN/STOP：并发关闭，状态校验失败</span><br><span class="hljs-comment">         * (2) workerCount 已达 corePoolSize：竞态条件下其他线程抢先创建</span><br><span class="hljs-comment">         * (3) ThreadFactory 返回 null：工厂拒绝创建线程</span><br><span class="hljs-comment">         * (4) OOM 或 CAS 失败：资源或竞争问题</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 【Fallback 语义】失败后进入步骤2是合理的——若池仍 RUNNING，</span><br><span class="hljs-comment">         * 任务可尝试入队，保障任务不丢失。就好像线程池的 wc &gt;= corePoolSize 一样。</span><br><span class="hljs-comment">         */</span><br>        c = ctl.get();  <span class="hljs-comment">// 状态可能已变化，刷新 ctl 用于步骤2/3的判断</span><br>    &#125;<br><br>    <span class="hljs-comment">// ==================== 步骤2：尝试入队 ====================</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 【为何必须双重检查】</span><br><span class="hljs-comment">         * offer 成功时任务仅在队列中，无&quot;主人&quot;。从 offer 到状态检查之间存在 TOCTOU 窗口：</span><br><span class="hljs-comment">         * - 池可能在此窗口内关闭</span><br><span class="hljs-comment">         * - 所有工作线程可能在此窗口内退出（allowCoreThreadTimeOut=true 或异常退出）</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 从这里我们可以看得出来，我们在外部尝试操作线程和队列的时候，要面对线程池状态/线程数/队列状态的瞬息万变的变化。</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * 因此需要双重检查：</span><br><span class="hljs-comment">         * (1) 确认池仍在运行，否则移除任务并拒绝</span><br><span class="hljs-comment">         * (2) 确认有消费者线程，否则补偿创建</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br><br>        <span class="hljs-comment">// 检查1：池是否在入队窗口内关闭？如果关闭，则尝试移除 command，这一步仍然可能失败</span><br>        <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);  <span class="hljs-comment">// 移除成功则拒绝；移除失败说明已被取走，无需处理</span><br><br>        <span class="hljs-comment">// 检查2：池仍在运行/移除命令失败，但工作线程是否全部销毁？</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 【何以此境？】池 RUNNING 但 wc=0 的场景：</span><br><span class="hljs-comment">             * - allowCoreThreadTimeOut=true：核心线程空闲超时退出</span><br><span class="hljs-comment">             * - 任务执行异常：runWorker() 抛未捕获异常，触发 processWorkerExit</span><br><span class="hljs-comment">             *   移除 Worker 并尝试补偿（addWorker(null, false)），但补偿可能失败</span><br><span class="hljs-comment">             *   （池状态变为 STOP / 线程数已达 maximumPoolSize / ThreadFactory 返回 null 等）</span><br><span class="hljs-comment">             *</span><br><span class="hljs-comment">             * 【罕见场景】池已关闭 + remove 失败 + wc=0：</span><br><span class="hljs-comment">             * command 被其他 Worker 取走后该 Worker 立即退出，导致 wc=0。</span><br><span class="hljs-comment">             * 此时任 addWorker(null, false) 在 SHUTDOWN 状态下可能成功</span><br><span class="hljs-comment">             * （firstTask==null 且队列非空），确保剩余任务有消费者。</span><br><span class="hljs-comment">             *</span><br><span class="hljs-comment">             * 【任务与线程解耦】新 Worker 获取的是队首任务，</span><br><span class="hljs-comment">             * 不一定是本次 command——体现解耦设计。</span><br><span class="hljs-comment">             *</span><br><span class="hljs-comment">             * addWorker(null, false)：</span><br><span class="hljs-comment">             * - null = 新线程从队列取任务，不直接执行 command。这个 null 参数在线程池里只有内部方法才用，产生的 worker 是所谓的 drain worker</span><br><span class="hljs-comment">             * - false = 受 maximumPoolSize 限制</span><br><span class="hljs-comment">             */</span><br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 主流路径：双重检查通过，任务正常入队且有消费者</span><br>        <span class="hljs-comment">// 注：大多数情况下 workerCountOf(recheck) 不为 0，两个 if 都不执行</span><br>    &#125;<br><br>    <span class="hljs-comment">// ==================== 步骤3：尝试创建非核心线程 ====================</span><br>    <span class="hljs-comment">// 【进入条件】步骤2的 if 条件为 false，有两种情况：</span><br>    <span class="hljs-comment">// (1) isRunning(c) = false：池已关闭，短路不尝试 offer</span><br>    <span class="hljs-comment">// (2) workQueue.offer(command) = false：入队失败</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>)) &#123;  <span class="hljs-comment">// false = 受 maximumPoolSize 限制</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 【入队失败场景】offer 返回 false：</span><br><span class="hljs-comment">         * (1) 有界队列已满：ArrayBlockingQueue、LinkedBlockingQueue 容量耗尽</span><br><span class="hljs-comment">         * (2) SynchronousQueue：无容量，offer 永远返回 false</span><br><span class="hljs-comment">         * (3) 自定义队列拒绝：策略性拒绝</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 【拒绝条件】addWorker 失败意味着：</span><br><span class="hljs-comment">         * - 池已关闭（SHUTDOWN/STOP），或</span><br><span class="hljs-comment">         * - 线程数已达 maximumPoolSize（饱和）</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 【SHUTDOWN vs STOP】</span><br><span class="hljs-comment">         * - SHUTDOWN：不接受新任务，但处理队列中任务。addWorker(firstTask,null) 可成功</span><br><span class="hljs-comment">         * - STOP：不接受新任务，不处理队列，中断执行中任务。addWorker 必失败</span><br><span class="hljs-comment">         * 此处 addWorker(command, false) 的 firstTask 非null，</span><br><span class="hljs-comment">         * 故即使在 SHUTDOWN 状态下也会失败——SHUTDOWN 只允许创建&quot;取队列任务&quot;的线程。</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         * 【为何无需双重检查】addWorker 失败无遗留状态——任务未入队、未绑定线程，</span><br><span class="hljs-comment">         * 直接拒绝即可，无状态需要回滚或清理。</span><br><span class="hljs-comment">         */</span><br>        reject(command);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><a href="%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png">任务调度流程.png</a></p>
<h3 id="创建工作线程：addworker">创建工作线程：addWorker</h3>
<p><code>addWorker</code> 是 <code>execute</code> 三步调度策略的核心支撑方法，负责创建并启动工作线程。</p>
<p><img src="%E7%94%B3%E8%AF%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="申请线程执行流程图.png"></p>
<p>Worker 可以被认为是线程和锁的结合体，它的使命就是不断地把 runnable/command/task 从缓冲队列里拿出来，放在自己的 thread 里执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// addWorker 是 ThreadPoolExecutor 创建并启动工作线程的核心方法。</span><br><span class="hljs-comment">// 方法逻辑分两阶段：</span><br><span class="hljs-comment">// 1. 双层自旋增加 workerCount：外层检查 runState，内层 CAS 增加 workerCount</span><br><span class="hljs-comment">// 2. 加锁创建并启动 Worker：持有 mainLock 期间创建 Worker、加入 workers 集合、启动线程</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 返回 false 的场景：</span><br><span class="hljs-comment">// - 线程池已 STOP 或更高状态</span><br><span class="hljs-comment">// - 线程池已 SHUTDOWN 且（firstTask 不为 null 或队列为空）</span><br><span class="hljs-comment">// - workerCount 达到上限（core ? corePoolSize : maximumPoolSize）</span><br><span class="hljs-comment">// - ThreadFactory 创建线程失败（返回 null 或抛异常，如 Thread.start() 的 OutOfMemoryError）</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 参数说明：</span><br><span class="hljs-comment">// - firstTask：新线程首个执行的任务。为 null 时创建空闲 Worker 从队列获取任务（prestartCoreThread 或替换死亡 Worker）；</span><br><span class="hljs-comment">//   不为 null 时绕过队列直接执行（线程数 &lt; corePoolSize 或队列满时），节省开销</span><br><span class="hljs-comment">// - core：true 使用 corePoolSize 为上限，false 使用 maximumPoolSize。采用布尔值而非数值确保每次读取最新配置，</span><br><span class="hljs-comment">//   允许线程池运行时 reconfigure</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">// 线程创建失败时：回滚 workerCount 并尝试终止线程池</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    <span class="hljs-comment">// retry 是外部自旋的标签。大自旋保证 rs 是稳定的，小自旋保证 wc 是稳定的，在双自旋里面保证 wc 的修改成功</span><br>    <span class="hljs-comment">// 这一步的 break 意味着自旋成功了而不是失败了</span><br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 获取运行时状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>        <br>        <span class="hljs-comment">// 【为什么要在增加 worker 前检查线程池状态？】</span><br>        <span class="hljs-comment">// 线程池有生命周期状态机，SHUTDOWN 表示「不再接受新任务但执行队列剩余任务」，</span><br>        <span class="hljs-comment">// STOP 表示「立即终止，不执行队列任务」。此检查是线程池语义的最后一道防线——</span><br>        <span class="hljs-comment">// 调用方（如 execute）可能已通过状态检查，但在并发场景下，其他线程可能在</span><br>        <span class="hljs-comment">// execute 检查后、addWorker 执行前调用 shutdown()，因此 addWorker 必须再次校验。</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// 【唯一例外场景】rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; workQueue 非空</span><br>        <span class="hljs-comment">// 此时机：SHUTDOWN 后队列中还有任务，需要创建线程（firstTask=null）来消费队列。</span><br>        <span class="hljs-comment">// 这种 worker 称为「drain worker」，仅用于清理队列，不接受外部提交的新任务。</span><br>        <span class="hljs-comment">// 若 firstTask 不为 null，说明是外部提交的新任务，违反 SHUTDOWN 语义，必须拒绝。</span><br>        <span class="hljs-comment">// 若队列为空，则没有任务需要消费，创建 worker 毫无意义。</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <br>        <span class="hljs-comment">// 内层自旋：处理 workerCount 的 CAS 竞争</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>            <br>            <span class="hljs-comment">// 【为什么要检查线程数量上限？】</span><br>            <span class="hljs-comment">// 线程是昂贵资源（每个线程约 1MB 栈空间），无限制创建会导致 OOM 或系统资源耗尽。</span><br>            <span class="hljs-comment">// core 参数决定上限来源：true 用 corePoolSize（常驻线程数），false 用 maximumPoolSize（峰值线程数）。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 【为什么用布尔值 core 而非直接传入数值？】</span><br>            <span class="hljs-comment">// corePoolSize 和 maximumPoolSize 可在运行时通过 setCorePoolSize/setMaximumPoolSize 修改。</span><br>            <span class="hljs-comment">// 布尔值确保每次都读取最新配置，而非调用方缓存的旧值。若传入数值，</span><br>            <span class="hljs-comment">// 调用方可能在读取配置后、调用 addWorker 前配置已被其他线程修改，导致上限检查失效。</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <br>            <span class="hljs-comment">// 【为什么要用 CAS 而非直接递增？】</span><br>            <span class="hljs-comment">// ctl 是共享状态，多个线程可能同时调用 addWorker，直接递增会丢失更新。</span><br>            <span class="hljs-comment">// CAS 是无锁并发的标准模式：读取当前值 → 尝试原子更新 → 失败则重试。</span><br>            <span class="hljs-comment">// 相比加锁，CAS 在低竞争时性能更好，但需要处理失败重试逻辑。</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <br>            <span class="hljs-comment">// 【为什么 CAS 失败后要重新检查状态？】</span><br>            <span class="hljs-comment">// CAS 失败说明 ctl 被其他线程修改了，有两种可能：</span><br>            <span class="hljs-comment">// 1. workerCount 被改：其他线程也在创建 worker，CAS 竞争失败</span><br>            <span class="hljs-comment">// 2. runState 被改：其他线程调用了 shutdown() 或 shutdownNow()</span><br>            <span class="hljs-comment">// 第二种情况必须返回外层循环重新判断是否还能创建 worker，</span><br>            <span class="hljs-comment">// 否则可能在线程池已关闭的状态下继续创建线程，违反状态机语义。</span><br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// 若仅 workerCount 变化，状态机语义未变，在内层循环重试 CAS 即可</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 至此，workerCount 已成功递增（CAS 成功），但 Worker 对象尚未创建。</span><br>    <span class="hljs-comment">// 这种「先占位后创建」的设计需要回滚机制：若后续创建失败，必须归还占位。</span><br>    <br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// firstTask 已在状态检查中验证：SHUTDOWN 状态下只有 firstTask==null 且队列非空才允许创建 Worker。</span><br>        <span class="hljs-comment">// Worker 构造函数接受 null（drain worker 的 firstTask 为 null）。</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <br>        <span class="hljs-comment">// 【为什么 ThreadFactory 返回的 thread 可能为 null？】</span><br>        <span class="hljs-comment">// ThreadFactory 是扩展点，用户可实现自定义工厂。恶意或错误的实现可能返回 null。</span><br>        <span class="hljs-comment">// 这是防御性编程：不信任用户代码的返回值，避免后续 NPE。</span><br>        <span class="hljs-comment">// 若 t 为 null，workerStarted 保持 false，最终触发 addWorkerFailed 回滚。</span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 【为什么加锁后还要重新检查状态？TOCTOU 问题】</span><br>                <span class="hljs-comment">// Time-of-Check to Time-of-Use：检查时刻与使用时刻之间，状态可能被修改。</span><br>                <span class="hljs-comment">// 在 CAS 成功后、获取 mainLock 前，其他线程可能调用 shutdown() 或 shutdownNow()。</span><br>                <span class="hljs-comment">// 若不加锁重检，可能在 SHUTDOWN 后仍然添加 Worker 并启动线程，违反状态机语义。</span><br>                <span class="hljs-comment">// mainLock 保护 workers 集合和 largestPoolSize 等簿记数据的修改，</span><br>                <span class="hljs-comment">// 同时也作为状态重检的同步点。</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-comment">// 【加锁后状态重检的分支】</span><br>                <span class="hljs-comment">// rs &lt; SHUTDOWN：正常运行状态，允许添加</span><br>                <span class="hljs-comment">// rs == SHUTDOWN &amp;&amp; firstTask == null：SHUTDOWN 状态下仅允许 drain worker</span><br>                <span class="hljs-comment">// 其他情况：状态已变为 STOP 或 SHUTDOWN 且 firstTask 不为 null，拒绝添加</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <br>                    <span class="hljs-comment">// 【为什么要检查 t.isAlive()？】</span><br>                    <span class="hljs-comment">// Thread 对象只能 start 一次，重复调用 start() 会抛 IllegalThreadStateException。</span><br>                    <span class="hljs-comment">// 自定义 ThreadFactory 可能返回已启动的线程（如从线程池中复用），</span><br>                    <span class="hljs-comment">// 若不检查直接加入 workers 集合，后续 t.start() 会失败。</span><br>                    <span class="hljs-comment">// 此处主动检查并抛异常，比让系统在 start() 时抛更早暴露问题。</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive())<br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <br>                    <span class="hljs-comment">// 【为什么要更新 largestPoolSize？】</span><br>                    <span class="hljs-comment">// 纯粹是统计信息，用于监控和调试（如 JMX 暴露）。</span><br>                    <span class="hljs-comment">// 不影响线程池运行逻辑，但帮助运维人员了解线程池的历史峰值使用情况。</span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// 若状态已变为拒绝添加，workerAdded 保持 false，</span><br>                <span class="hljs-comment">// 但 workerCount 已在 CAS 阶段递增，必须回滚。</span><br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">// 这一步就启动了 run 钩子，走进线程池的 runWorker 的主循环</span><br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 【为什么要回滚？】</span><br>        <span class="hljs-comment">// 若 workerStarted 为 false，说明 Worker 创建或启动失败，但 CAS 阶段已递增 workerCount。</span><br>        <span class="hljs-comment">// 若不回滚，workerCount 会比实际运行的线程数多，导致线程池永远无法达到预期的线程数量，</span><br>        <span class="hljs-comment">// 甚至无法正确判断是否需要创建新线程（因为「已有线程数」被错误地虚高）。</span><br>        <span class="hljs-comment">// tryTerminate() 是因为减少了一个可能阻止终止的 worker，需检查是否满足终止条件。</span><br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rolls back the worker thread creation.</span><br><span class="hljs-comment"> * - removes worker from workers, if present</span><br><span class="hljs-comment"> * - decrements worker count</span><br><span class="hljs-comment"> * - rechecks for termination, in case the existence of this</span><br><span class="hljs-comment"> *   worker was holding up termination</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rolls back the worker thread creation.</span><br><span class="hljs-comment"> * - removes worker from workers, if present</span><br><span class="hljs-comment"> * - decrements worker count</span><br><span class="hljs-comment"> * - rechecks for termination, in case the existence of this</span><br><span class="hljs-comment"> *   worker was holding up termination</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;addWorkerFailed 是 addWorker 的回滚逻辑，当 Worker 创建或启动失败时调用。</span><br><span class="hljs-comment"> * Javadoc 释义：</span><br><span class="hljs-comment"> * &lt;ul&gt;</span><br><span class="hljs-comment"> *   &lt;li&gt;「Rolls back」：回滚操作，补偿 addWorker 中已完成的部分工作&lt;/li&gt;</span><br><span class="hljs-comment"> *   &lt;li&gt;「removes worker from workers」：从 workers 集合移除（需加 mainLock）&lt;/li&gt;</span><br><span class="hljs-comment"> *   &lt;li&gt;「decrements worker count」：递减 workerCount，回滚之前的 CAS 增加&lt;/li&gt;</span><br><span class="hljs-comment"> *   &lt;li&gt;「rechecks for termination」：检查是否触发终止条件，此 Worker 可能是阻止线程池终止的最后一个&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;/ul&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)<br>            workers.remove(w);<br>        <span class="hljs-comment">// 不管 w 是否为 null，都修改 wc，因为进入之前，不管是否产生了 worker，wc 都增加过了</span><br>        decrementWorkerCount();<br>        <span class="hljs-comment">// 【为什么线程创建失败要调用 tryTerminate？】</span><br>        <span class="hljs-comment">// tryTerminate() 是条件检查而非强制关闭：内部检查 runState &gt;= SHUTDOWN 且 workerCount == 0 才执行终止。</span><br>        <span class="hljs-comment">// 此处调用的原因：decrementWorkerCount() 后 workerCount 可能变为 0，若线程池正处于关闭状态，</span><br>        <span class="hljs-comment">// 则满足终止条件，需触发 TIDYING → TERMINATED 转换。若条件不满足，tryTerminate() 直接返回，无副作用。</span><br>        <span class="hljs-comment">// 不调用则风险：线程池可能永远卡在 SHUTDOWN 状态（workerCount=0 但未触发终止流程）。</span><br>        tryTerminate();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Decrements the workerCount field of ctl. This is called only on</span><br><span class="hljs-comment"> * abrupt termination of a thread (see processWorkerExit). Other</span><br><span class="hljs-comment"> * decrements are performed within getTask.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 设计特点：无限自旋（do-while 空循环体），必须保证递减成功，不允许失败。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 实际调用场景（Javadoc 描述不完整）：</span><br><span class="hljs-comment"> * 1. addWorkerFailed：Worker 创建/启动失败时回滚</span><br><span class="hljs-comment"> * 2. getTask()：线程池 SHUTDOWN 且队列空，或 STOP 及以上状态时</span><br><span class="hljs-comment"> * 3. processWorkerExit：仅当 completedAbruptly=true（任务抛出未捕获异常）时</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrementWorkerCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 减 worker count 的操作必须自旋到成功，这种小成员的自旋修改不需要 sleep！</span><br>    <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndIncrementWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect)</span> &#123;<br>    <span class="hljs-comment">// 因为 wc 在 32 位整数的低位，所以直接对 expect + 1 即可。</span><br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="任务缓冲：阻塞队列">任务缓冲：阻塞队列</h3>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是 <strong>（阻塞的本质即为此）：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。</strong> 阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="阻塞队列的工作原理.png"></p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ArrayBlockingQueue</td>
<td style="text-align:center">一个用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序。<strong>支持公平锁和非公平锁</strong>。</td>
</tr>
<tr>
<td style="text-align:center">DelayQueue</td>
<td style="text-align:center">一个基于 <code>PriorityQueue</code>（非阻塞）实现延迟获取的无界队列，元素必须实现 <code>Delayed</code> 接口。在创建元素时可指定延迟时间，只有延时期满后才能从队列中获取元素。</td>
</tr>
<tr>
<td style="text-align:center">LinkedBlockingDeque</td>
<td style="text-align:center">一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，<strong>可以将锁的竞争最多降到一半</strong>。</td>
</tr>
<tr>
<td style="text-align:center">LinkedBlockingQueue</td>
<td style="text-align:center">一个由链表结构组成的有界队列，此队列按照先进先出(FIFO)的原则对元素进行排序。此队列的默认长度为Integer.MAX_VALUE，<strong>所以默认创建的该队列有容量危险</strong>。</td>
</tr>
<tr>
<td style="text-align:center">LinkedTransferQueue</td>
<td style="text-align:center">一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</td>
</tr>
<tr>
<td style="text-align:center">PriorityBlockingQueue</td>
<td style="text-align:center">一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</td>
</tr>
<tr>
<td style="text-align:center"><code>SynchronousQueue</code></td>
<td style="text-align:center">一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，<strong>线程空闲了60秒后会被回收</strong>。</td>
</tr>
<tr>
<td style="text-align:center"><code>DelayedWorkQueue</code></td>
<td style="text-align:center"><code>ScheduledThreadPoolExecutor</code> 的内部类，基于二叉堆实现。<strong>是延时线程池的刚需组件</strong>：只有通过 DelayedWorkQueue 的 <code>take()</code> 阻塞到任务到期，才能在复用 ThreadPoolExecutor Worker 机制的同时实现延时调度。不在公开 API 之列。</td>
</tr>
</tbody>
</table>
<blockquote>
<p>阻塞队列的详细选型指南（锁实现差异、使用示例、性能对比）见下文 <a href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B%E6%8C%87%E5%8D%97">阻塞队列选型指南</a> 章节。</p>
</blockquote>
<h4 id="阻塞队列选型指南">阻塞队列选型指南</h4>
<p><strong>锁实现差异分析</strong>：</p>
<p>各阻塞队列在锁策略上有本质差异，这直接影响并发性能和适用场景。</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>锁策略</th>
<th>锁数量</th>
<th>设计原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ArrayBlockingQueue</code></td>
<td>单锁</td>
<td>1 把 ReentrantLock</td>
<td>数组实现，put/take 需同时维护 count、head、tail，单锁保证原子性</td>
</tr>
<tr>
<td><code>LinkedBlockingQueue</code></td>
<td>双锁（读写分离）</td>
<td>2 把 ReentrantLock</td>
<td>链表实现，写操作修改 tail，读操作修改 head，互不干扰</td>
</tr>
<tr>
<td><code>LinkedBlockingDeque</code></td>
<td>单锁</td>
<td>1 把 ReentrantLock</td>
<td>双端操作可能同时涉及头尾，无法分离</td>
</tr>
<tr>
<td><code>PriorityBlockingQueue</code></td>
<td>单锁</td>
<td>1 把 ReentrantLock</td>
<td>堆调整涉及整个数组，读写无法分离</td>
</tr>
<tr>
<td><code>DelayQueue</code></td>
<td>单锁</td>
<td>1 把 ReentrantLock</td>
<td>基于 PriorityBlockingQueue，堆操作无法分离</td>
</tr>
<tr>
<td><code>SynchronousQueue</code></td>
<td>无锁 CAS</td>
<td>无显式锁</td>
<td>不存储元素，直接传递，CAS 实现匹配</td>
</tr>
<tr>
<td><code>LinkedTransferQueue</code></td>
<td>无锁 CAS</td>
<td>无显式锁</td>
<td>链表 + 松弛操作，CAS 实现无锁算法</td>
</tr>
</tbody>
</table>
<p><strong>为什么 LinkedBlockingQueue 能用双锁？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LinkedBlockingQueue 的核心结构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">takeLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <span class="hljs-comment">// 读锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">putLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();   <span class="hljs-comment">// 写锁</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> takeLock.newCondition();  <span class="hljs-comment">// 读条件</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> putLock.newCondition();    <span class="hljs-comment">// 写条件</span><br>    <br>    <span class="hljs-comment">// 写操作只操作 tail 节点</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> &#123;<br>        putLock.lockInterruptibly();  <span class="hljs-comment">// 只获取写锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 插入到链表尾部，修改 tail 引用</span><br>            <span class="hljs-comment">// 与读操作互不干扰</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            putLock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 读操作只操作 head 节点</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        takeLock.lockInterruptibly();  <span class="hljs-comment">// 只获取读锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 从链表头部取出，修改 head 引用</span><br>            <span class="hljs-comment">// 与写操作互不干扰</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            takeLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>链表的物理结构决定了读写操作修改的是<strong>不同的内存位置</strong>：</p>
<ul>
<li>写操作：修改 <code>tail.next</code> 和 <code>tail</code> 引用</li>
<li>读操作：修改 <code>head</code> 和 <code>head.next</code> 引用</li>
</ul>
<p>两者互不干扰，因此可以分离锁。这是<strong>数据结构特性决定的</strong>。</p>
<p><strong>为什么 ArrayBlockingQueue 不能用双锁？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ArrayBlockingQueue 的核心结构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">final</span> Object[] items;  <span class="hljs-comment">// 环形数组</span><br>    <span class="hljs-type">int</span> takeIndex;         <span class="hljs-comment">// 读指针</span><br>    <span class="hljs-type">int</span> putIndex;          <span class="hljs-comment">// 写指针</span><br>    <span class="hljs-type">int</span> count;             <span class="hljs-comment">// 元素计数（共享变量！）</span><br>    <span class="hljs-keyword">final</span> ReentrantLock lock;  <span class="hljs-comment">// 单锁</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> &#123;<br>        lock.lock();  <span class="hljs-comment">// 必须获取同一把锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            items[putIndex] = e;<br>            putIndex = inc(putIndex);  <span class="hljs-comment">// 可能与 takeIndex 重叠</span><br>            count++;                   <span class="hljs-comment">// 修改共享计数</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();  <span class="hljs-comment">// 必须获取同一把锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">E</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> items[takeIndex];<br>            items[takeIndex] = <span class="hljs-literal">null</span>;<br>            takeIndex = inc(takeIndex);  <span class="hljs-comment">// 可能与 putIndex 重叠</span><br>            count--;                     <span class="hljs-comment">// 修改共享计数</span><br>            <span class="hljs-keyword">return</span> x;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>数组的环形结构导致读写操作存在<strong>共享状态</strong>：</p>
<ol>
<li><strong>count 计数器</strong>：put 需要检查是否满（count == capacity），take 需要检查是否空（count == 0）</li>
<li><strong>指针回绕</strong>：putIndex 和 takeIndex 都会在数组末尾回绕到 0，可能相遇</li>
<li><strong>容量判断</strong>：判断满/空需要同时看到 count、takeIndex、putIndex 的一致状态</li>
</ol>
<p>如果用双锁，put 和 take 同时修改 count，会出现竞态条件。即使使用 AtomicInteger，也无法保证 count 与指针的一致性。</p>
<p><strong>SynchronousQueue 为什么不需要锁？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// SynchronousQueue 的核心机制</span><br><span class="hljs-comment">// 公平模式：TransferQueue（基于链表的队列）</span><br><span class="hljs-comment">// 非公平模式：TransferStack（基于栈的 LIFO 结构）</span><br><br><span class="hljs-comment">// 核心操作：匹配生产者和消费者</span><br><span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 尝试匹配一个等待的生产者</span><br>    <span class="hljs-comment">// 如果找到，直接交换数据，无需加锁</span><br>    <span class="hljs-comment">// 如果没找到，当前线程等待被匹配</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> &#123;<br>    <span class="hljs-comment">// 尝试匹配一个等待的消费者</span><br>    <span class="hljs-comment">// 如果找到，直接交换数据，无需加锁</span><br>    <span class="hljs-comment">// 如果没找到，当前线程等待被匹配</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>SynchronousQueue <strong>不存储任何元素</strong>，它的核心是&quot;直接传递&quot;：</p>
<ul>
<li>生产者线程将元素直接交给消费者线程</li>
<li>如果没有消费者，生产者等待</li>
<li>如果没有生产者，消费者等待</li>
<li>整个过程通过 CAS 操作完成线程间匹配，无需维护数据结构</li>
</ul>
<p><strong>选型建议</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐队列</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr>
<td>通用生产消费（首选）</td>
<td>ArrayBlockingQueue</td>
<td>预分配数组，缓存友好，无 GC 压力，实测性能稳定</td>
</tr>
<tr>
<td>高并发 + 队列长期非空</td>
<td>LinkedBlockingQueue（指定容量）</td>
<td>双锁优势显现，但须指定容量</td>
</tr>
<tr>
<td>任务直接执行，无缓冲</td>
<td>SynchronousQueue</td>
<td>无锁 CAS，直接传递</td>
</tr>
<tr>
<td>需要优先级</td>
<td>PriorityBlockingQueue</td>
<td>堆排序，无锁替代方案少</td>
</tr>
<tr>
<td>延迟调度</td>
<td>DelayQueue</td>
<td>时间排序，无可替代</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">flowchart TD
    A[选择阻塞队列] --&gt; B&#123;是否需要存储元素?&#125;
    B --&gt;|否| C[SynchronousQueue]
    B --&gt;|是| D&#123;是否需要延迟/优先级?&#125;
    
    D --&gt;|延迟| E[DelayQueue]
    D --&gt;|优先级| F[PriorityBlockingQueue]
    D --&gt;|否| G[ArrayBlockingQueue&lt;br/&gt;首选-缓存友好]
    
    G --&gt; H&#123;需要双锁?&#125;
    H --&gt;|否| I[使用 ArrayBlockingQueue]
    H --&gt;|是| J&#123;LinkedBlockingQueue&#125;
    
    J --&gt; K[指定容量-推荐]
    J --&gt; L[默认容量-OOM风险]
    
    style C fill:#F0E68C
    style E fill:#DDA0DD
    style F fill:#FFB6C1
    style G fill:#90EE90
    style I fill:#90EE90
    style K fill:#87CEEB
    style L fill:#FF6347</code></pre>
<h3 id="threadpoolexecutor-任务拒绝">ThreadPoolExecutor 任务拒绝</h3>
<p>当线程池的任务缓存队列已满并且线程池中的线程数目达到 maximumPoolSize 时，如果还有任务到来就会采取任务拒绝策略。</p>
<p><strong>拒绝策略的两种触发场景</strong>：</p>
<table>
<thead>
<tr>
<th>触发场景</th>
<th>描述</th>
<th>常见原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线程池饱和</strong></td>
<td>队列已满 + 线程数达到 maximumPoolSize</td>
<td>任务提交速率持续高于处理速率</td>
</tr>
<tr>
<td><strong>线程池关闭</strong></td>
<td>调用 <code>shutdown()</code> 或 <code>shutdownNow()</code> 后仍尝试提交任务</td>
<td>业务逻辑未正确检查线程池状态</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>常见误区</strong>：许多开发者认为拒绝策略只在&quot;线程池满了&quot;时触发，但实际上<strong>线程池关闭后</strong>尝试提交任务同样会触发拒绝策略。如果业务逻辑未正确检查线程池状态（通过 <code>isShutdown()</code> 或 <code>isTerminated()</code>），可能导致意外的任务丢失。</p>
</blockquote>
<blockquote>
<p><strong>强制触发线程中断与拒绝的完整场景汇总</strong>：</p>
</blockquote>
<p>根据Java线程池的实现，以下场景会强制触发线程中断或拒绝新任务：</p>
<p><strong>主动触发（用户代码显式调用）</strong>：</p>
<ol>
<li>shutdownNow()：强制中断所有工作线程</li>
<li>Future.cancel(true)：强制中断指定任务的执行线程</li>
</ol>
<p><strong>系统被动触发（内部机制自动触发）</strong>：</p>
<ol>
<li>线程池饱和：队列满+达最大线程数 -&gt; 触发 RejectedExecutionHandler</li>
<li>awaitTermination超时：shutdown后等待超时 -&gt; 强制关闭</li>
<li>ScheduledFutureTask异常：周期任务未捕获异常 -&gt; 终止调度</li>
<li>tryTerminate自旋中断：线程池终止过程中 -&gt; 中断空闲Worker</li>
</ol>
<p><strong>拒绝策略的四种内置实现</strong>：</p>
<ul>
<li>AbortPolicy：抛出 RejectedExecutionException</li>
<li>CallerRunsPolicy：由调用者线程执行</li>
<li>DiscardPolicy：静默丢弃</li>
<li>DiscardOldestPolicy：丢弃最老任务</li>
</ul>
<p><strong>最佳实践</strong>：</p>
<ul>
<li>不要依赖强制中断来停止任务，任务应支持检查中断标志</li>
<li>优先使用cancel(false)让任务自然完成</li>
<li>合理选择拒绝策略，根据业务对任务丢失的容忍度决定</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例：线程池关闭后仍被拒绝的任务</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()<br>);<br>executor.shutdown();  <span class="hljs-comment">// 关闭线程池</span><br><br><span class="hljs-comment">// 此任务会被拒绝策略拒绝（即使队列未满）</span><br>executor.execute(() -&gt; System.out.println(<span class="hljs-string">&quot;task&quot;</span>));<br></code></pre></td></tr></table></figure>
<p><strong>拒绝策略触发流程：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client as 客户端
    participant TPE as ThreadPoolExecutor
    participant Queue as 阻塞队列
    participant Handler as RejectedExecutionHandler
    
    Client-&gt;&gt;TPE: execute(task)
    TPE-&gt;&gt;TPE: 检查线程数 &lt; corePoolSize?
    
    alt 线程数 &lt; corePoolSize
        TPE-&gt;&gt;TPE: 创建核心线程执行
    else 线程数 &gt;= corePoolSize
        TPE-&gt;&gt;Queue: offer(task)
        alt 队列未满
            Queue--&gt;&gt;TPE: true
            TPE--&gt;&gt;Client: 任务入队成功
        else 队列已满
            Queue--&gt;&gt;TPE: false
            TPE-&gt;&gt;TPE: 检查线程数 &lt; maximumPoolSize?
            alt 线程数 &lt; maximumPoolSize
                TPE-&gt;&gt;TPE: 创建非核心线程执行
            else 线程数 &gt;= maximumPoolSize
                TPE-&gt;&gt;Handler: rejectedExecution(task, executor)
                Note over Handler: 执行拒绝策略
            end
        end
    end</code></pre>
<p><strong>拒绝策略对比图：</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph 拒绝策略对比
        A[AbortPolicy] --&gt; A1[抛出异常]
        A1 --&gt; A2[调用方感知]
        A2 --&gt; A3[适合：需要明确处理拒绝的场景]
        
        B[CallerRunsPolicy] --&gt; B1[调用者执行]
        B1 --&gt; B2[提供反压]
        B2 --&gt; B3[适合：不能丢弃任务的场景]
        
        C[DiscardPolicy] --&gt; C1[静默丢弃]
        C1 --&gt; C2[无感知]
        C2 --&gt; C3[适合：允许丢弃且无需感知]
        
        D[DiscardOldestPolicy] --&gt; D1[丢弃最老任务]
        D1 --&gt; D2[新任务优先]
        D2 --&gt; D3[适合：新任务更重要的场景]
    end
    
    style A fill:#FF6B6B
    style B fill:#4ECDC4
    style C fill:#95A5A6
    style D fill:#F39C12</code></pre>
<h2 id="threadpoolexecutor-如何管理线程">ThreadPoolExecutor 如何管理线程</h2>
<p>getTask() 返回 null 会让线程退出，走入 processWorkerExit。</p>
<p>ThreadPoolExecutor<strong>没有&quot;核心线程&quot;这种线程类型或线程属性</strong>。所有 Worker 结构相同，不存在标记某个线程为&quot;核心&quot;的字段。所谓的&quot;核心线程&quot;只是 <code>workerCount</code> 中属于 <code>corePoolSize</code> 范围内的计数——这是一个<strong>动态边界</strong>，同一个线程在不同时刻可能处于边界内或边界外。线程是否因 idle 退出是 <code>getTask()</code> 每次循环的动态决策：当 <code>workerCount &gt; corePoolSize</code> 时使用 <code>poll(keepAliveTime)</code>，超时返回 null 导致线程退出。可以认为这部分线程天然带超时，超时机制对其无条件生效，只受 keepAliveTime 控制。只要 getTask 得到 null，就不会回到 while 循环，而进入 processWorkerExit。当 <code>workerCount &lt;= corePoolSize</code> 时使用 <code>take()</code> 无限阻塞，线程不会因 idle 退出。若 <code>allowCoreThreadTimeOut=true</code>，则所有线程均会因 idle 超时退出。</p>
<h3 id="mainlock：线程池的全局互斥锁">mainLock：线程池的全局互斥锁</h3>
<p>ThreadPoolExecutor 使用 <code>mainLock</code>（<code>ReentrantLock</code>）保护线程池的核心数据结构和同步点。</p>
<p><strong>mainLock 保护的对象</strong>：</p>
<table>
<thead>
<tr>
<th>保护对象</th>
<th>类型</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>workers</code></td>
<td><code>HashSet&lt;Worker&gt;</code></td>
<td>HashSet 非线程安全，增删遍历需互斥</td>
</tr>
<tr>
<td><code>largestPoolSize</code></td>
<td><code>int</code></td>
<td>记录历史最大线程数，多线程更新需同步</td>
</tr>
<tr>
<td><code>completedTaskCount</code></td>
<td><code>long</code></td>
<td>任务完成总数累加，需原子性保证</td>
</tr>
<tr>
<td><code>termination</code></td>
<td><code>Condition</code></td>
<td>状态转换时的唤醒信号，需与锁配合</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph TB
    mainLock[mainLock&lt;br/&gt;ReentrantLock]

    subgraph 保护对象
        workers[workers&lt;br/&gt;HashSet Worker]
        largestPoolSize[largestPoolSize&lt;br/&gt;int]
        completedTaskCount[completedTaskCount&lt;br/&gt;long]
        termination[termination&lt;br/&gt;Condition]
    end

    subgraph 使用场景
        addWorker[addWorker&lt;br/&gt;创建线程]
        addWorkerFailed[addWorkerFailed&lt;br/&gt;创建失败]
        processWorkerExit[processWorkerExit&lt;br/&gt;线程退出]
        interruptIdleWorkers[interruptIdleWorkers&lt;br/&gt;中断空闲线程]
        tryTerminate[tryTerminate&lt;br/&gt;状态转换]
        getActiveCount[getActiveCount 等&lt;br/&gt;监控统计]
    end

    mainLock --&gt; workers
    mainLock --&gt; largestPoolSize
    mainLock --&gt; completedTaskCount
    mainLock --&gt; termination

    addWorker --&gt; mainLock
    addWorkerFailed --&gt; mainLock
    processWorkerExit --&gt; mainLock
    interruptIdleWorkers --&gt; mainLock
    tryTerminate --&gt; mainLock
    getActiveCount --&gt; mainLock</code></pre>
<p><strong>mainLock 的使用场景</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>方法</th>
<th>操作内容</th>
</tr>
</thead>
<tbody>
<tr>
<td>创建线程</td>
<td><code>addWorker()</code></td>
<td>Worker 加入 workers、更新 largestPoolSize、状态重检</td>
</tr>
<tr>
<td>创建失败</td>
<td><code>addWorkerFailed()</code></td>
<td>从 workers 移除、回滚 workerCount</td>
</tr>
<tr>
<td>线程退出</td>
<td><code>processWorkerExit()</code></td>
<td>累加 completedTaskCount、从 workers 移除</td>
</tr>
<tr>
<td>中断空闲线程</td>
<td><code>interruptIdleWorkers()</code></td>
<td>遍历 workers、tryLock 检测空闲</td>
</tr>
<tr>
<td>状态转换</td>
<td><code>tryTerminate()</code></td>
<td>TIDYING→TERMINATED、termination.signalAll()</td>
</tr>
<tr>
<td>监控统计</td>
<td><code>getActiveCount()</code> 等</td>
<td>遍历 workers 统计活跃线程数</td>
</tr>
</tbody>
</table>
<p><strong>TOCTOU 问题与状态重检</strong>：</p>
<p><code>addWorker()</code> 中，CAS 增加 workerCount 后、获取 mainLock 前，其他线程可能调用 <code>shutdown()</code> 或 <code>shutdownNow()</code> 改变状态。mainLock 作为同步点，允许加锁后重新检查状态，避免在 SHUTDOWN 后错误添加 Worker。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// addWorker 中的典型模式</span><br><span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c)) &#123;  <span class="hljs-comment">// CAS 成功</span><br>    <span class="hljs-comment">// ... 创建 Worker ...</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();  <span class="hljs-comment">// 获取全局锁</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());  <span class="hljs-comment">// 重检状态（TOCTOU）</span><br>        <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>            workers.add(w);              <span class="hljs-comment">// 保护 workers 修改</span><br>            largestPoolSize = Math.max(largestPoolSize, workers.size());<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为何不用读写锁</strong>：</p>
<ul>
<li><code>workers</code> 的修改操作（增删 Worker）主要发生在线程创建、退出、关闭阶段</li>
<li>遍历操作主要发生在监控方法（<code>getActiveCount</code>、<code>getPoolSize</code> 等）和关闭阶段</li>
<li>正常运行期间，这些操作竞争不频繁，读写锁的额外开销（维护读写状态、支持锁降级）不值得</li>
</ul>
<p><strong>mainLock 与 ctl 的分工</strong>：</p>
<ul>
<li><code>ctl</code>（AtomicInteger）：高 3 位运行状态 + 低 29 位线程数，使用 CAS 无锁更新，自身保证原子性</li>
<li><code>mainLock</code>：保护以下三类对象：
<ul>
<li><strong>非线程安全数据结构</strong>：<code>workers</code>（HashSet）</li>
<li><strong>volatile 变量的复合操作</strong>：<code>largestPoolSize</code>、<code>completedTaskCount</code> —— volatile 仅保证可见性，不保证复合操作（如 <code>max = Math.max(max, size)</code>）的原子性。实际上这种对 volatile 的复合操作需要使用同步块的设计大量遍布于 java 的日常实践中，是一种基础原则。</li>
<li><strong>同步原语</strong>：<code>termination</code>（Condition）—— 需与锁配合使用</li>
</ul>
</li>
</ul>
<p>两者协调：CAS 先更新 ctl，成功后再获取 mainLock 修改受保护对象。若 mainLock 获取后状态检查失败，则回滚 ctl（<code>decrementWorkerCount()</code>）。</p>
<h3 id="线程数保量机制">线程数保量机制</h3>
<h4 id="corepoolsize-的三重语义">corePoolSize 的三重语义</h4>
<p><code>corePoolSize</code> 在线程池中扮演三个角色：</p>
<ol>
<li><strong>创建阈值</strong>：<code>execute()</code> 方法中，当 <code>workerCount &lt; corePoolSize</code> 时，优先创建新线程直接执行任务，绕过入队。</li>
<li><strong>超时策略分界</strong>：<code>getTask()</code> 方法中，<code>workerCount &lt;= corePoolSize</code> 且 <code>allowCoreThreadTimeOut=false</code> 时使用 <code>take()</code> 无限阻塞（不会因超时返回 null，从而维持线程数量不低于 <code>corePoolSize</code>）；<code>workerCount &gt; corePoolSize</code> 时使用 <code>poll(keepAliveTime)</code>，超时则线程退出。</li>
<li><strong>退出检查下限</strong>：<code>processWorkerExit()</code> 方法中，正常退出时以 <code>corePoolSize</code> 作为最小保有量检查，低于此值则补充线程。</li>
</ol>
<h4 id="线程增加路径">线程增加路径</h4>
<table>
<thead>
<tr>
<th>路径</th>
<th>触发点</th>
<th><code>addWorker</code> 参数</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>正常增加-核心</td>
<td><code>execute()</code> 步骤1</td>
<td><code>(command, true)</code></td>
<td><code>workerCount &lt; corePoolSize</code> 时</td>
</tr>
<tr>
<td>正常增加-非核心</td>
<td><code>execute()</code> 步骤3</td>
<td><code>(command, false)</code></td>
<td>队列已满且 <code>workerCount &lt; maximumPoolSize</code> 时</td>
</tr>
<tr>
<td>正常增加-补偿</td>
<td><code>execute()</code> 步骤2</td>
<td><code>(null, false)</code></td>
<td>入队后发现 <code>workerCount == 0</code> 时</td>
</tr>
<tr>
<td>异常增加</td>
<td><code>processWorkerExit()</code></td>
<td><code>(null, false)</code></td>
<td>异常退出后补充，保量</td>
</tr>
</tbody>
</table>
<h4 id="线程退出路径">线程退出路径</h4>
<table>
<thead>
<tr>
<th>路径</th>
<th>触发点</th>
<th>是否检查 <code>min</code></th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>正常退出</td>
<td><code>getTask()</code> 返回 null</td>
<td>是</td>
<td>若 <code>workerCount &gt;= min</code> 则不补充，否则补充</td>
</tr>
<tr>
<td>异常退出</td>
<td>任务抛未捕获异常</td>
<td>否</td>
<td>直接调用 <code>addWorker(null, false)</code> 补充</td>
</tr>
</tbody>
</table>
<p><strong>即时补偿机制</strong>：异常退出时（<code>completedAbruptly=true</code>），<code>processWorkerExit()</code> 跳过 <code>min</code> 检查，立即调用 <code>addWorker(null, false)</code> 尝试补充线程。这是即时补偿而非延迟补偿——不等待下次任务提交。</p>
<p>即时补偿不等于保证达成。<code>addWorker</code> 可能因以下原因失败：线程工厂返回 null、CAS 竞争失败、已达 <code>maximumPoolSize</code>。此外，<code>allowCoreThreadTimeOut=true</code> 时核心线程可因空闲超时退出，不触发补偿。因此 <code>corePoolSize</code> 是目标保有量而非硬性下限，线程池在任何时刻都不保证 <code>workerCount &gt;= corePoolSize</code>。补偿失败时，线程数短暂低于 <code>corePoolSize</code>，由后续 <code>execute()</code> 步骤1（<code>workerCount &lt; corePoolSize</code> 时优先创建）作为兜底策略。</p>
<h4 id="allowcorethreadtimeout-的作用">allowCoreThreadTimeOut 的作用</h4>
<p><code>allowCoreThreadTimeOut</code> 是改变核心线程生命周期策略的关键开关：</p>
<ul>
<li><code>getTask()</code> 中的 <code>timed</code> 变量：<code>boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize</code></li>
<li><code>processWorkerExit()</code> 中的 <code>min</code> 变量：<code>int min = allowCoreThreadTimeOut ? 0 : corePoolSize</code></li>
</ul>
<p>当 <code>allowCoreThreadTimeOut=true</code> 时：</p>
<ul>
<li>所有线程（无论是否达到 <code>corePoolSize</code>）都使用 <code>poll(keepAliveTime)</code> 等待任务</li>
<li>正常退出时 <code>min=0</code>，不强制保有核心线程</li>
<li>队列非空时 <code>min=1</code>，至少保留一个消费者</li>
</ul>
<h4 id="结论">结论</h4>
<p><code>corePoolSize</code> 是目标保有量而非硬性下限。线程池在任何时刻都不保证 <code>workerCount &gt;= corePoolSize</code>，原因包括：</p>
<ul>
<li><code>allowCoreThreadTimeOut=true</code> 时核心线程可因空闲超时退出</li>
<li>任务执行异常导致线程退出，<code>processWorkerExit()</code> 虽会补充但可能失败</li>
<li>线程工厂返回 null 导致 <code>addWorker</code> 失败</li>
</ul>
<pre><code class="hljs mermaid">graph TB
    subgraph 增加路径[线程增加路径]
        exec1[&quot;execute() 步骤1&lt;br/&gt;wc &lt; corePoolSize&quot;]
        exec2[&quot;execute() 步骤2&lt;br/&gt;入队后 wc == 0&quot;]
        exec3[&quot;execute() 步骤3&lt;br/&gt;队列满&quot;]
        abrupt[&quot;processWorkerExit()&lt;br/&gt;异常退出&quot;]
        add1[&quot;addWorker(cmd, true)&lt;br/&gt;🆕 NEW → RUNNABLE&quot;]
        add2[&quot;addWorker(null, false)&lt;br/&gt;🆕 NEW → RUNNABLE&quot;]
        add3[&quot;addWorker(cmd, false)&lt;br/&gt;🆕 NEW → RUNNABLE&quot;]
        add4[&quot;addWorker(null, false)&lt;br/&gt;🆕 NEW → RUNNABLE&quot;]
        exec1 --&gt; add1
        exec2 --&gt; add2
        exec3 --&gt; add3
        abrupt --&gt; add4
    end

    subgraph 退出路径[线程退出路径]
        gettask[&quot;getTask() 返回 null&lt;br/&gt;🔚 即将 TERMINATED&quot;]
        process[&quot;processWorkerExit():&lt;br/&gt;if (!completedAbruptly) &#123;&lt;br/&gt;  min = allowCoreThreadTimeOut&lt;br/&gt;      ? 0 : corePoolSize&lt;br/&gt;  if (wc &gt;= min) return;&lt;br/&gt;&#125;&lt;br/&gt;addWorker(null, false)&quot;]
        result[&quot;补充成功: wc 恢复&lt;br/&gt;补充失败: wc &lt; min&lt;br/&gt;☠️ TERMINATED&quot;]
        gettask --&gt; process
        process --&gt; result
    end

    subgraph 配置影响[allowCoreThreadTimeOut 影响点]
        timed[&quot;getTask(): timed = allowCoreThreadTimeOut || wc &gt; corePoolSize&quot;]
        mincalc[&quot;processWorkerExit(): min = allowCoreThreadTimeOut ? 0 : corePoolSize&quot;]
        behavior_false[&quot;false (默认): workerCount &lt;= corePoolSize 时使用 take() 无限阻塞&lt;br/&gt;⏳ WAITING&quot;]
        behavior_true[&quot;true: 所有线程使用 poll(timeout)，核心线程可因空闲超时退出&lt;br/&gt;⏱️ TIMED_WAITING&quot;]
    end</code></pre>
<h3 id="线程执行">线程执行</h3>
<p><img src="%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png" alt="执行任务流程.png"></p>
<p>线程的执行强依赖于 Worker 本身的实现。</p>
<h4 id="worker-类定义与锁状态">Worker 类定义与锁状态</h4>
<p><strong>Worker 与 Thread 的关系</strong>：Worker 不是线程，它是一个包装器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 关键证据：Worker 构造函数</span><br>Worker(Runnable firstTask) &#123;<br>    <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// Worker 作为 Runnable 传给 Thread</span><br>    <span class="hljs-comment">// 这一步没有启动线程，由 addWorker 启动。</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>newThread(this)</code> 中，<code>this</code> 是 Worker 对象本身。因为 Worker 实现了 Runnable，所以 Worker 是 Thread 的 <code>target</code>。</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>实际角色</th>
</tr>
</thead>
<tbody>
<tr>
<td>Worker</td>
<td>包装器 + Runnable，封装任务获取和执行逻辑</td>
</tr>
<tr>
<td>Worker.thread</td>
<td>真正的线程对象，由 ThreadFactory 创建</td>
</tr>
<tr>
<td>Worker 与 Thread</td>
<td>组合关系：Worker 持有 Thread，同时也是 Thread 的 target</td>
</tr>
<tr>
<td>Worker 的锁</td>
<td><strong>不可重入</strong>互斥锁，基于 AQS 实现</td>
</tr>
</tbody>
</table>
<p><strong>互相引用关系</strong>：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph Worker[&quot;Worker&amp;lt;br&amp;gt;extends AQS&amp;lt;br&amp;gt;implements Runnable&quot;]
        W_FIELDS[&quot;Worker 字段:&quot;]
        W_THREAD[&quot;- thread: Thread&quot;]
        W_TASK[&quot;- firstTask: Runnable&quot;]
        W_STATE[&quot;- state: int&quot;]
        W_COMPLETED[&quot;- completedTasks: long&quot;]
        
        W_METHODS[&quot;Worker 方法:&quot;]
        W_RUN[&quot;+ run() &#123; runWorker(this) &#125;&quot;]
    end
    
    subgraph Thread[&quot;Thread&quot;]
        T_FIELDS[&quot;Thread 字段:&quot;]
        T_TARGET[&quot;- target: Runnable&quot;]
        
        T_METHODS[&quot;Thread 方法:&quot;]
        T_RUN[&quot;+ run() &#123; target.run() &#125;&quot;]
    end
    
    %% Worker 持有 Thread 引用
    W_THREAD --&gt;|持有| T_TARGET
    
    %% Thread.target 指向 Worker
    T_TARGET -.-&gt;|指向| W_FIELDS
    
    %% 构造流程
    W_FIELDS@&#123; shape: braces&#125;
    
    subgraph Construction[&quot;构造流程&quot;]
        C1[&quot;new Worker(firstTask)&quot;]
        C2[&quot;setState(-1)&quot;]
        C3[&quot;this.thread = getThreadFactory.newThread(this)&quot;]
        C4[&quot;Thread.target = this&quot;]
        
        C1 --&gt; C2 --&gt; C3 --&gt; C4
    end
    
    %% 执行链路
    C4 -.-&gt;|启动| T_RUN
    T_RUN -.-&gt;|调用| W_RUN</code></pre>
<p>Worker.thread → Thread（持有引用）<br>
Thread.target → Worker（持有引用，因为 Worker 实现了 Runnable）</p>
<p><strong>执行链路</strong>：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">addWorker</span><span class="hljs-params">(task, core)</span></span><br>    → new <span class="hljs-built_in">Worker</span>(task)<br>    → <span class="hljs-built_in">newThread</span>(this)      <span class="hljs-comment">// Worker 作为 Thread 的 target</span><br>    → thread<span class="hljs-selector-class">.start</span>()<br>    → Thread<span class="hljs-selector-class">.run</span>()<br>    → target<span class="hljs-selector-class">.run</span>()         <span class="hljs-comment">// target = Worker</span><br>    → Worker<span class="hljs-selector-class">.run</span>()<br>    → <span class="hljs-built_in">runWorker</span>(this)<br>    → while ((task = <span class="hljs-built_in">getTask</span>()) != null) task<span class="hljs-selector-class">.run</span>()<br></code></pre></td></tr></table></figure>
<p>这种设计让 Worker 既能控制线程的中断行为（通过 AQS 锁状态），又能将任务执行委托给线程池的 <code>runWorker</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Worker 类维护线程运行任务时的中断控制状态，以及其他次要的簿记工作。</span><br><span class="hljs-comment">  * 该类借助扩展 AbstractQueuedSynchronizer 来简化任务执行周围的锁获取和释放。</span><br><span class="hljs-comment">  * 这可以防止本来用于唤醒等待任务的工作线程的中断，却错误地中断正在执行的任务。</span><br><span class="hljs-comment">  * 我们实现了一个简单的不可重入互斥锁，而不是使用 ReentrantLock，</span><br><span class="hljs-comment">  * 因为不希望工作任务在调用 setCorePoolSize 等池控制方法时能够重新获取锁。</span><br><span class="hljs-comment">  * 此外，为了在线程实际开始运行任务之前抑制中断，将锁状态初始化为负值，并在 runWorker 中清除它。</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * Class Worker mainly maintains interrupt control state for</span><br><span class="hljs-comment">  * threads running tasks, along with other minor bookkeeping.</span><br><span class="hljs-comment">  * This class opportunistically extends AbstractQueuedSynchronizer</span><br><span class="hljs-comment">  * to simplify acquiring and releasing a lock surrounding each</span><br><span class="hljs-comment">  * task execution.  This protects against interrupts that are</span><br><span class="hljs-comment">  * intended to wake up a worker thread waiting for a task from</span><br><span class="hljs-comment">  * instead interrupting a task being run.  We implement a simple</span><br><span class="hljs-comment">  * non-reentrant mutual exclusion lock rather than use</span><br><span class="hljs-comment">  * ReentrantLock because we do not want worker tasks to be able to</span><br><span class="hljs-comment">  * reacquire the lock when they invoke pool control methods like</span><br><span class="hljs-comment">  * setCorePoolSize.  Additionally, to suppress interrupts until</span><br><span class="hljs-comment">  * the thread actually starts running tasks, we initialize lock</span><br><span class="hljs-comment">  * state to a negative value, and clear it upon start (in</span><br><span class="hljs-comment">  * runWorker).</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span><br>     <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>     <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><br> &#123;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * This class will never be serialized, but we provide a</span><br><span class="hljs-comment">      * serialVersionUID to suppress a javac warning.</span><br><span class="hljs-comment">      *</span><br><span class="hljs-comment">      * &lt;p&gt;此类永远不会被序列化，但提供 serialVersionUID 以抑制 javac 警告。</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6138294804551838833L</span>;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * Thread this worker is running in.  Null if factory fails.</span><br><span class="hljs-comment">      *</span><br><span class="hljs-comment">      * &lt;p&gt;Worker 运行所在的线程，如果工厂失败则为 null。</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-keyword">final</span> Thread thread;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * Initial task to run.  Possibly null.</span><br><span class="hljs-comment">      *</span><br><span class="hljs-comment">      * &lt;p&gt;初始任务，可能为 null。</span><br><span class="hljs-comment">      */</span><br>     Runnable firstTask;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * Per-thread task counter</span><br><span class="hljs-comment">      *</span><br><span class="hljs-comment">      * &lt;p&gt;每线程任务计数器。</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * Creates with given first task and thread from ThreadFactory.</span><br><span class="hljs-comment">      * <span class="hljs-doctag">@param</span> firstTask the first task (null if none)</span><br><span class="hljs-comment">      *</span><br><span class="hljs-comment">      * &lt;p&gt;使用给定的首个任务和 ThreadFactory 创建线程。</span><br><span class="hljs-comment">      */</span><br>     Worker(Runnable firstTask) &#123;<br>         <span class="hljs-comment">// setState(-1) 禁止中断，直到 runWorker 解锁</span><br>         setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>         <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>         <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>     &#125;<br><br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * Delegates main run loop to outer runWorker.</span><br><span class="hljs-comment">      *</span><br><span class="hljs-comment">      * &lt;p&gt;将主运行循环委托给外部的 runWorker。这个 runWorker 是线程池的方法，不是 worker 的方法。</span><br><span class="hljs-comment">      * 这样 worker 的 run 生命周期的修改其实是线程池负责的，worker 自身不负责任何 run 的业务逻辑。</span><br><span class="hljs-comment">      * 线程在 addWorker 中通过 t.start() 启动，JVM 调用 Thread.run()，再调用 Worker.run()。</span><br><span class="hljs-comment">      */</span><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>         runWorker(<span class="hljs-built_in">this</span>);<br>     &#125;<br><br>     <span class="hljs-comment">// Lock methods</span><br>     <span class="hljs-comment">// 锁状态：-1 = 初始化禁止中断，0 = 未锁定，1 = 已锁定</span><br>     <span class="hljs-comment">// -1: 构造时的初始状态，禁止中断</span><br>     <span class="hljs-comment">// 0: 未锁定状态（允许中断）</span><br>     <span class="hljs-comment">// 1: 已锁定状态（正在执行任务）</span><br>     <span class="hljs-comment">// The value 0 represents the unlocked state.</span><br>     <span class="hljs-comment">// The value 1 represents the locked state.</span><br><br>     <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>         <span class="hljs-comment">// state != 0 表示被持有（包括 -1 启动状态）</span><br>         <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>     &#125;<br>     <br>     <span class="hljs-comment">// AQS 加锁：CAS 0→1，成功则绑定当前线程</span><br>     <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>         <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>             setExclusiveOwnerThread(Thread.currentThread());<br>             <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>         &#125;<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>     &#125;<br><br>     <span class="hljs-comment">// AQS 解锁：清空持有者，设置 state=0（无 CAS，因为只有持有者能解锁）</span><br>     <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>         setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>         setState(<span class="hljs-number">0</span>);<br>         <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>     &#125;<br><br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>        &#123; acquire(<span class="hljs-number">1</span>); &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>      &#123; release(<span class="hljs-number">1</span>); &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br>     <br>     <span class="hljs-comment">// 中断已启动的 Worker（state &gt;= 0）</span><br>     <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;<br>         Thread t;<br>         <span class="hljs-comment">// state &gt;= 0 表示已启动（非 -1 初始状态）</span><br>         <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp; !t.isInterrupted()) &#123;<br>             <span class="hljs-keyword">try</span> &#123;<br>                 t.interrupt();<br>             &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>             &#125;<br>         &#125;<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Worker 锁对中断的保护机制：</strong></p>
<p><strong>核心结论</strong>：Worker 继承 AQS，利用 <code>state</code> 字段区分空闲/忙碌状态，实现对执行中任务的中断保护。</p>
<table>
<thead>
<tr>
<th>state</th>
<th>线程状态</th>
<th>tryLock</th>
<th>是否被中断</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>执行任务中</td>
<td>失败</td>
<td>不中断（受保护）</td>
</tr>
<tr>
<td>0</td>
<td>阻塞在 getTask() 等待任务</td>
<td>成功</td>
<td>可中断</td>
</tr>
</tbody>
</table>
<p>所谓&quot;空闲线程&quot;即阻塞在队列上等待任务的线程。<strong>Worker线程只有两种状态：执行任务中，或阻塞在<code>getTask()</code>等待任务，不存在&quot;空闲但不阻塞&quot;的第三种状态。</strong><code>shutdown()</code> 通过 <code>tryLock()</code> 识别空闲线程并发送中断，唤醒它们检查线程池状态后退出。执行中的线程因 <code>tryLock</code> 失败被跳过，任务得以正常完成。</p>
<p>Worker 类注释中提到&quot;这可以防止本来用于唤醒等待任务的工作线程的中断，却错误地中断正在执行的任务&quot;。具体保护机制如下：</p>
<p><code>shutdown()</code> 调用 <code>interruptIdleWorkers()</code> 时，通过 <code>tryLock()</code> 检测 Worker 锁状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// shutdown() 的中断逻辑</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (w.tryLock()) &#123;  <span class="hljs-comment">// tryLock 内部调用 tryAcquire，如果试锁不成功，就不是空闲线程</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                t.interrupt();  <span class="hljs-comment">// 只有 tryLock 成功才中断</span><br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// tryLock 失败 = state=1 = 正在执行任务 → 跳过，不中断</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>tryLock()</code> 调用 <code>tryAcquire()</code>，其实现决定了谁能被中断：</p>
<p><strong>这就是注释所说的&quot;防止错误中断&quot;</strong>：<code>shutdown()</code> 发送的中断信号只作用于空闲线程（唤醒它们检查池状态），不会干扰正在执行的任务。所谓唤醒，是唤醒阻塞在 <code>getTask()</code> 中的线程，让它们检查线程池状态后决定是否退出。被中断后，线程会检查 <code>runState</code>：若为 STOP 状态则直接退出；若为 SHUTDOWN 状态，队列为空时才退出，队列非空时可能继续处理完剩余任务。</p>
<p><strong>Worker 生命周期状态图：</strong></p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; Created: new Worker(firstTask)
    
    Created --&gt; Initialized: setState(-1)&lt;br/&gt;禁止中断
    Initialized --&gt; Started: thread.start()
    
    Started --&gt; Running: runWorker(this)
    Running --&gt; Unlocked: w.unlock()&lt;br/&gt;允许中断
    
    state Running &#123;
        Unlocked --&gt; WaitingTask: getTask()
        WaitingTask --&gt; GotTask: task != null
        WaitingTask --&gt; NoTask: task == null
        
        GotTask --&gt; Locked: w.lock()
        Locked --&gt; Executing: task.run()
        Executing --&gt; Unlocked: w.unlock()
    &#125;
    
    NoTask --&gt; Exiting: processWorkerExit()
    Exiting --&gt; [*]: 线程终止
    
    note right of Created
        Worker 构造时：
        1. setState(-1) 禁止中断
        2. 保存 firstTask
        3. 通过 ThreadFactory 创建线程
    end note
    
    note right of WaitingTask
        getTask() 返回 null 的情况：
        1. 线程数 &gt; maximumPoolSize
        2. 线程池 STOP 状态
        3. 线程池 SHUTDOWN 且队列空
        4. 等待超时
    end note</code></pre>
<p><strong>Worker 锁状态转换图：</strong></p>
<pre><code class="hljs mermaid">graph TD
    subgraph Worker锁状态
        A[state = -1&lt;br/&gt;初始化状态] --&gt;|w.unlock| B[state = 0&lt;br/&gt;空闲状态]
        B --&gt;|w.lock| C[state = 1&lt;br/&gt;执行任务中]
        C --&gt;|w.unlock| B
    end
    
    subgraph 锁状态含义
        D[-1: 禁止中断&lt;br/&gt;Worker刚创建] 
        E[0: 允许中断&lt;br/&gt;Worker空闲等待任务]
        F[1: 正在执行任务&lt;br/&gt;不应被中断]
    end
    
    subgraph 中断规则
        G[interruptIfStarted] --&gt; H&#123;getState &gt;= 0?&#125;
        H --&gt;|是| I[可以中断]
        H --&gt;|否| J[不能中断]
    end
    
    style A fill:#FFB6C1
    style B fill:#90EE90
    style C fill:#87CEEB</code></pre>
<p><strong>Worker 锁的三大功能：</strong></p>
<ol>
<li><strong>状态标记</strong>：<code>isLocked()</code> 判断 Worker 是否正在执行任务</li>
<li><strong>中断保护</strong>：<code>interruptIfStarted()</code> 检查 <code>state &gt;= 0</code> 才允许中断</li>
<li><strong>并发控制</strong>：<code>interruptIdleWorkers()</code> 用 <code>tryLock()</code> 判断是否可安全中断</li>
</ol>
<p><strong>为什么必须用不可重入锁？</strong></p>
<p>关键在于 <code>setCorePoolSize</code> 等池控制方法内部会调用 <code>interruptIdleWorkers</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCorePoolSize</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(ctl.get()) &gt; corePoolSize)<br>        interruptIdleWorkers();  <span class="hljs-comment">// ← 会调用！</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>假设用户任务中调用线程池控制方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">executor.submit(() -&gt; &#123;<br>    executor.setCorePoolSize(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 用户任务中调用池控制方法</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<p>如果用 <strong>ReentrantLock（可重入）</strong>：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">runWorker: w.lock() → <span class="hljs-keyword">state</span>=<span class="hljs-number">1</span><br>  task.run() → <span class="hljs-built_in">set</span>CorePoolSize() → interruptIdleWorkers()<br>    → w.tryLock() → 成功（可重入，<span class="hljs-keyword">state</span>=<span class="hljs-number">2</span>）→ t.interrupt()<br>    → 正在执行任务的线程被错误中断！<br></code></pre></td></tr></table></figure>
<p>使用 <strong>不可重入锁</strong>：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs pf">runWorker: w.lock() → <span class="hljs-keyword">state</span>=<span class="hljs-number">1</span><br>  task.run() → <span class="hljs-built_in">set</span>CorePoolSize() → interruptIdleWorkers()<br>    → w.tryLock() → CAS(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) 失败（<span class="hljs-keyword">state</span>=<span class="hljs-number">1</span>）→ 返回 false<br>    → 跳过这个 Worker，不中断 → 正确！<br></code></pre></td></tr></table></figure>
<p><strong>不可重入的实现原理：</strong></p>
<p>对比 Worker 与 ReentrantLock 的 <code>tryAcquire</code> 实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Worker.tryAcquire（不可重入）</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;  <span class="hljs-comment">// 只尝试 0→1</span><br>        setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 失败就是失败，不检查持有者</span><br>&#125;<br><br><span class="hljs-comment">// ReentrantLock.tryAcquire（可重入）</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ====== 关键差异：检查当前线程是否已持有锁 ======</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;  <span class="hljs-comment">// 增加重入计数</span><br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 同一线程可以再次获取</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>不可重入的实现</strong>：就是<strong>不写</strong> <code>else if (current == getExclusiveOwnerThread())</code> 这段代码。Worker 的 tryAcquire 只有前半部分。</p>
<p><strong>为什么选择 AQS 而非 volatile + CAS？</strong></p>
<p>AQS 的 <code>compareAndSetState</code> 本质就是 <code>volatile + Unsafe CAS</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS 源码</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>    <span class="hljs-keyword">return</span> UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以 Worker 实际上就在用 volatile int + CAS，AQS 只是做了封装。选择 AQS 是 Doug Lea 的工程风格——复用已有框架，避免手写 Unsafe 获取和反射。这不是&quot;必须&quot;，是&quot;够用且简洁&quot;。AQS 的 exclusiveOwnerThread 对 Worker 来说不重要（不可重入锁不需要记录持有者）。</p>
<p><strong>空闲线程的两种等待状态：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// getTask() 中的阻塞等待</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>    workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :  <span class="hljs-comment">// TIMED_WAITING</span><br>    workQueue.take();                                       <span class="hljs-comment">// WAITING</span><br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>场景</th>
<th>阻塞方法</th>
<th>Java Thread 状态</th>
<th>唤醒条件</th>
</tr>
</thead>
<tbody>
<tr>
<td>核心线程（不允许超时）</td>
<td><code>queue.take()</code></td>
<td>WAITING</td>
<td>队列有任务 或 被中断</td>
</tr>
<tr>
<td>非核心线程 / 允许超时</td>
<td><code>queue.poll(timeout)</code></td>
<td>TIMED_WAITING</td>
<td>队列有任务 或 超时 或 被中断</td>
</tr>
</tbody>
</table>
<p><strong>shutdown vs shutdownNow 的中断策略对比：</strong></p>
<p>两种关闭方法使用<strong>不同的中断函数</strong>，对 Worker 锁的态度截然不同：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>状态转换</th>
<th>中断函数</th>
<th>是否检查锁</th>
<th>state=1 能否中断</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shutdown()</code></td>
<td>RUNNING → SHUTDOWN</td>
<td><code>interruptIdleWorkers()</code></td>
<td><code>tryLock()</code> 检查</td>
<td>否</td>
</tr>
<tr>
<td><code>shutdownNow()</code></td>
<td>RUNNING → STOP</td>
<td><code>interruptWorkers()</code></td>
<td>不检查</td>
<td>是</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// shutdown() 使用 tryLock 检查，比较自律</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>        <span class="hljs-keyword">if</span> (w.tryLock()) &#123;  <span class="hljs-comment">// ← 只有 state=0 才能成功</span><br>            t.interrupt();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// shutdownNow() 不检查锁，只要不是刚初始化，就直接中断</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptWorkers</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>        w.interruptIfStarted();  <span class="hljs-comment">// ← 只要 state &gt;= 0 就中断</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Worker 中断决策流程图：</strong></p>
<pre><code class="hljs mermaid">flowchart TD
    subgraph shutdown决策
        A1[shutdown()] --&gt; B1[interruptIdleWorkers()]
        B1 --&gt; C1&#123;w.tryLock()?&#125;
        C1 --&gt;|state=0 成功| D1[t.interrupt()]
        C1 --&gt;|state=1 失败| E1[跳过，不中断]
        D1 --&gt; F1[空闲线程退出]
    end
    
    subgraph shutdownNow决策
        A2[shutdownNow()] --&gt; B2[interruptWorkers()]
        B2 --&gt; C2&#123;state &gt;= 0?&#125;
        C2 --&gt;|state=0 或 1| D2[t.interrupt()]
        C2 --&gt;|state=-1| E2[跳过，未启动]
        D2 --&gt; F2[所有已启动线程中断]
    end</code></pre>
<p><strong>关键洞察</strong>：Worker 的 AQS 锁只保护 <code>shutdown()</code> 的优雅关闭，不保护 <code>shutdownNow()</code> 的强制关闭。STOP 状态的&quot;更严厉&quot;体现在：<strong>无视 Worker 锁，强制中断所有已启动线程</strong>。</p>
<p><strong>runWorker 执行流程详解：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant TPE as ThreadPoolExecutor
    participant W as Worker
    participant T as Thread
    participant Q as BlockingQueue
    
    Note over W: 构造函数: setState(-1)
    TPE-&gt;&gt;W: addWorker(task, core)
    TPE-&gt;&gt;T: thread.start()
    T-&gt;&gt;W: run()
    W-&gt;&gt;TPE: runWorker(this)
    
    TPE-&gt;&gt;W: w.unlock() // setState(0)
    Note over W: 现在允许中断
    
    loop 任务循环
        alt 有 firstTask
            TPE-&gt;&gt;TPE: task = firstTask
        else 无 firstTask
            TPE-&gt;&gt;Q: getTask()
            Q--&gt;&gt;TPE: task 或 null
        end
        
        alt task != null
            TPE-&gt;&gt;W: w.lock() // setState(1)
            Note over W: 执行期间不应中断
            
            TPE-&gt;&gt;TPE: beforeExecute(thread, task)
            TPE-&gt;&gt;T: task.run()
            TPE-&gt;&gt;TPE: afterExecute(task, thrown)
            
            TPE-&gt;&gt;W: w.unlock() // setState(0)
            TPE-&gt;&gt;W: completedTasks++
        else task == null
            Note over TPE: 退出循环
        end
    end
    
    TPE-&gt;&gt;TPE: processWorkerExit(w, completedAbruptly)
    Note over W: Worker 生命周期结束</code></pre>
<h4 id="runworker-主循环">runWorker 主循环</h4>
<p>Worker 的 run 方法委托给线程池的 runWorker 执行。执行流程如图所示，包含以下关键步骤：</p>
<ol>
<li><strong>开始</strong>：线程启动-这个线程是在 addWorker 方法里被启动的。</li>
<li><strong>申请任务</strong>：首次使用 firstTask，后续通过 getTask() 获取</li>
<li><strong>是否申请到了新任务</strong>：判断 task 是否为 null</li>
<li><strong>申请Worker非重入锁</strong>：w.lock()，state 从 0 → 1</li>
<li><strong>线程池是否至少于STOP后状态</strong>：检查是否需要中断</li>
<li><strong>执行任务</strong>：调用 task.run()</li>
<li><strong>释放Worker非重入锁</strong>：w.unlock()，state 从 1 → 0</li>
<li><strong>任务结束</strong>：完成一次任务，继续循环或退出</li>
<li><strong>到线终线程</strong>：processWorkerExit()</li>
<li><strong>结束</strong>：线程终止</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Main worker run loop.  Repeatedly gets tasks from queue and executes them.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;Worker 主运行循环：反复从队列获取任务并执行。核心流程：</span><br><span class="hljs-comment"> * &lt;ol&gt;</span><br><span class="hljs-comment"> *   &lt;li&gt;初始任务：可能以 firstTask 开始，否则从 getTask() 获取。</span><br><span class="hljs-comment"> *       除了内部 addWorker 的几个补偿方法，firstTask 一开始总有&lt;/li&gt;</span><br><span class="hljs-comment"> *   &lt;li&gt;锁保护：执行前加锁防止中断干扰，确保 STOP 状态下线程被中断，</span><br><span class="hljs-comment"> *       非 STOP 状态下清除中断标志&lt;/li&gt;</span><br><span class="hljs-comment"> *   &lt;li&gt;生命周期钩子：beforeExecute → task.run → afterExecute，</span><br><span class="hljs-comment"> *       任一环节异常均导致线程死亡。会最终走进线程的 uncaughtExceptionHandler&lt;/li&gt;</span><br><span class="hljs-comment"> *   &lt;li&gt;异常处理：RuntimeException/Error 直接捕获，Throwable 包装为 Error </span><br><span class="hljs-comment"> *       交给 UncaughtExceptionHandler&lt;/li&gt;</span><br><span class="hljs-comment"> *   &lt;li&gt;退出逻辑：getTask() 返回 null 时正常退出(completedAbruptly=false)，</span><br><span class="hljs-comment"> *       异常退出时 processWorkerExit 替换线程&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;/ol&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 取出 firstTask 并置空</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 解除构造时的 setState(-1)，允许中断。这里在没有加锁的时候先调用 unlock 其实是和常规的加解锁语义不一样的，所以 w 并没有实现标准的 Lock 接口。也因此这种默认的 unlock 在 while 循环外只执行一次，while 循环里的 unlock 必须和 lock 对称。</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-comment">// completedAbruptly: 标记线程是否“突然退出”（因异常）</span><br>    <span class="hljs-comment">// - true: 默认值，可能因任务异常、beforeExecute/afterExecute 异常退出</span><br>    <span class="hljs-comment">// - false: 只有 while 循环正常退出（getTask 返回 null）时才设置</span><br>    <span class="hljs-comment">// 默认 true 是安全默认值：若遗漏设置，workerCount 少 1 可自动修复；</span><br>    <span class="hljs-comment">// 若默认 false 且遗漏，异常退出会导致 workerCount 多 1，计数永久错误</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// getTask 里封装了复杂的取任务流程，本线程只有在 getTask 取不到时才退出</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 步骤4：申请 Worker 非重入锁（对应图中&quot;申请 Worker 非重入锁&quot;）</span><br>            <span class="hljs-comment">// 只在 run 一个 task 的时候锁定自己一次，不可重入</span><br>            w.lock();<br>            <span class="hljs-comment">// 步骤5：线程池状态检查（对应图中“线程池是否至少于STOP后状态”）</span><br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 设计目标：池 &gt;= STOP 时确保 wt 被中断，池 &lt; STOP 时确保 wt 不被中断。</span><br>            <span class="hljs-comment">// 如果看不懂下面，只要看懂上面这句话即可。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 为什么不能只用一个 runStateAtLeast 检查？</span><br>            <span class="hljs-comment">// 因为 Thread.interrupted() 有清除中断位的副作用：</span><br>            <span class="hljs-comment">// - 池 &gt;= STOP 时：不应清除中断位，所以第一个条件短路跳过 interrupted()</span><br>            <span class="hljs-comment">// - 池 &lt; STOP 时：必须清除残留中断（任何来源），才调用 interrupted()</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 为什么清除后还要再检查一次 runStateAtLeast？</span><br>            <span class="hljs-comment">// 第一次 runStateAtLeast 检查到 interrupted() 调用之间存在窗口期，</span><br>            <span class="hljs-comment">// shutdownNow 可能在此期间执行（先更新 ctl 再设置中断）：</span><br>            <span class="hljs-comment">// - 若窗口期内 shutdownNow：interrupted() 清除了中断，重检 ctl 发现 &gt;= STOP，重新设置中断</span><br>            <span class="hljs-comment">// - 若残留中断（非 shutdownNow）：interrupted() 清除了中断，重检 ctl 仍 &lt; STOP，任务正常执行</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 本段代码与 interruptIfStarted() 的关系：</span><br>            <span class="hljs-comment">// - wt 的中断来源：getTask返回前、task.run()期间由 interruptIfStarted() 直接设置</span><br>            <span class="hljs-comment">// - 本段代码：在 task.run() 前建立正确的初始中断状态（设置或清除）</span><br>            <span class="hljs-comment">// - 重要结论：第二次检查+wt.interrupt()：补偿在 runStateAtLeast(ctl.get(), STOP) 和 Thread.interrupted() 之间被抹去的由 interruptIfStarted() 设置的中断</span><br>            <span class="hljs-comment">// 这是本段代码唯一的“主动设置中断”场景，其他时候要么短路跳过，要么清除残留</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// !wt.isInterrupted() 的作用：</span><br>            <span class="hljs-comment">// Thread.interrupt() 是幂等操作（每次调用设置中断标志为 true），</span><br>            <span class="hljs-comment">// 此检查避免对已中断线程的冗余调用</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                <span class="hljs-comment">// 对应图中&quot;是&quot;分支：线程中断</span><br>                wt.interrupt();<br>            <span class="hljs-comment">// 对应图中&quot;否&quot;分支：继续执行任务</span><br>            <span class="hljs-comment">// 线程的中断也不会影响接下来的 task.run()</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 钩子方法，默认空实现</span><br>                beforeExecute(wt, task);<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 步骤6：执行任务（对应图中&quot;执行任务&quot;）</span><br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    <span class="hljs-comment">// Throwable 无法在 Runnable.run 中重抛，包装为 Error</span><br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// thrown 传给 afterExecute</span><br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 步骤8：任务结束，清理并解锁</span><br>                task = <span class="hljs-literal">null</span>; <br>                <span class="hljs-comment">// 即使发生异常，completedTasks 也增加</span><br>                w.completedTasks++;<br>                <span class="hljs-comment">// 步骤7：释放Worker非重入锁（对应图中&quot;释放Worker非重入锁&quot;）</span><br>                w.unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// while 循环正常退出 = getTask 返回 null = 非异常退出</span><br>        <span class="hljs-comment">// 对应图中从&quot;是否申请到了新任务&quot;的&quot;否&quot;分支到&quot;到线终线程&quot;</span><br>        <span class="hljs-comment">// 注意：异常退出时不会执行此行，completedAbruptly 保持 true</span><br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 步骤9：到线终线程（对应图中&quot;到线终线程&quot;）</span><br>        processWorkerExit(w, completedAbruptly);<br>        <span class="hljs-comment">// 步骤10：结束（对应图中&quot;结束&quot;）</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="shutdown-与-stop-是两种平行的关闭策略">SHUTDOWN 与 STOP 是两种平行的关闭策略</h4>
<table>
<thead>
<tr>
<th>状态</th>
<th>设计意图</th>
<th>任务处理</th>
<th>中断策略</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHUTDOWN</td>
<td>优雅关闭</td>
<td>处理完队列中的任务</td>
<td>仅中断空闲线程</td>
</tr>
<tr>
<td>STOP</td>
<td>立即关闭</td>
<td>drainQueue() 并返回未执行任务</td>
<td>中断所有线程（包括执行中的）</td>
</tr>
</tbody>
</table>
<p>设计为平行状态的原因：</p>
<ul>
<li>使用场景不同：优雅退出 vs 紧急终止</li>
<li>shutdown() 无法中断正在执行的任务，shutdownNow() 则可以</li>
<li>用户根据业务需求选择：正常关闭用 <code>shutdown()</code>，异常/紧急情况用 <code>shutdownNow()</code></li>
</ul>
<p><strong>状态跃迁路径（按方法边界组织）：</strong></p>
<p>tryTerminate 触发关闭一个空闲线程，空闲线程退出时 processWorkerExit，又再触发 tryTerminate，周而复始。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph shutdown_method[&quot;shutdown() 方法内部&quot;]
        RUNNING1[RUNNING]
        RUNNING1 --&gt; |&quot;1. advanceRunState(SHUTDOWN)&quot;| SHUTDOWN1[SHUTDOWN]
        SHUTDOWN1 --&gt; |&quot;2. interruptIdleWorkers()&quot;| RETURN1[状态已变更&lt;br/&gt;方法返回]
    end
    
    RETURN1 --&gt; |&quot;Worker继续执行&lt;br/&gt;runWorker→getTask循环&lt;br/&gt;直到队列空&quot;| PROCESS1[processWorkerExit]
    
    subgraph processExit1[&quot;processWorkerExit() 方法内部&quot;]
        TRY1[tryTerminate]
        TRY1 --&gt; |&quot;workerCount &gt; 0&quot;| ONLY_ONE[&quot;interruptIdleWorkers(ONLY_ONE)&lt;br/&gt;只中断一个空闲线程&quot;]
        ONLY_ONE --&gt; |&quot;被中断线程退出&quot;| PROCESS1
        TRY1 --&gt; |&quot;workerCount = 0&quot;| TIDYING1[TIDYING]
        TIDYING1 --&gt; |&quot;terminated()&quot;| TERMINATED1[TERMINATED]
    end</code></pre>
<pre><code class="hljs mermaid">flowchart TB
    subgraph shutdownNow_method[&quot;shutdownNow() 方法内部&quot;]
        RUNNING2[RUNNING]
        RUNNING2 --&gt; |&quot;1. advanceRunState(STOP)&quot;| STOP[STOP]
        STOP --&gt; |&quot;2. interruptWorkers()&quot;| INTERRUPT[&quot;中断所有已启动线程&lt;br/&gt;无视锁&quot;]
        INTERRUPT --&gt; |&quot;3. drainQueue()&quot;| RETURN2[&quot;方法返回 List&amp;lt;Runnable&amp;gt;&lt;br/&gt;队列中未执行的任务。这个方法有返回值是很多人忽视，javadoc文档的例子也没有提示的&quot;]
    end
    
    RETURN2 --&gt; |&quot;被中断的Worker退出&quot;| PROCESS2[processWorkerExit]
    
    subgraph processExit2[&quot;processWorkerExit() 方法内部&quot;]
        TRY2[&quot;tryTerminate()&lt;br/&gt;同上，传播式关闭直到 workerCount=0&quot;]
    end</code></pre>
<p><strong>drainQueue()：队列任务的清空与返回</strong></p>
<p><code>drainQueue()</code> 将队列中所有未执行的任务转移到 List 中返回，使用 <code>BlockingQueue.drainTo()</code> 批量转移，避免迭代时的 <code>ConcurrentModificationException</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Runnable&gt; <span class="hljs-title function_">drainQueue</span><span class="hljs-params">()</span> &#123;<br>    BlockingQueue&lt;Runnable&gt; q = workQueue;<br>    List&lt;Runnable&gt; taskList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Runnable&gt;();<br>    q.drainTo(taskList);  <span class="hljs-comment">// 批量转移，高效且线程安全</span><br>    <span class="hljs-comment">// 处理 drainTo 漏掉的元素（某些队列实现可能不完整转移）</span><br>    <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> q.poll();<br>        <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>) taskList.add(r);<br>    &#125;<br>    <span class="hljs-keyword">return</span> taskList;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>返回的 List 包含所有未曾开始执行的任务，调用者可决定取消或重新提交。</p>
<p><strong>tryTerminate()：消亡机制的检查点</strong></p>
<p><code>tryTerminate()</code> 是条件检查而非强制关闭：内部判断 <code>runState &gt;= SHUTDOWN &amp;&amp; workerCount == 0</code> 才执行终止。每次 workerCount 可能变为 0 的操作后都会调用它，形成<strong>多次检查、最终触发</strong>的模式。</p>
<p><strong>tryTerminate() 的所有调用点</strong>：</p>
<table>
<thead>
<tr>
<th>调用位置</th>
<th>触发时机</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shutdown()</code></td>
<td>状态置为 SHUTDOWN 后</td>
<td>检查是否可立即终止（队列为空且无 Worker）</td>
</tr>
<tr>
<td><code>shutdownNow()</code></td>
<td>状态置为 STOP 且清空队列后</td>
<td>检查是否可立即终止（workerCount=0）</td>
</tr>
<tr>
<td><code>addWorkerFailed()</code></td>
<td>Worker 创建/启动失败</td>
<td>workerCount 可能变为 0，检查终止条件</td>
</tr>
<tr>
<td><code>processWorkerExit()</code></td>
<td>每个 Worker 退出时</td>
<td>传播终止信号，检查是否最后一个 Worker</td>
</tr>
</tbody>
</table>
<p><strong>自然消亡的推进链路</strong>：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs isbl"><span class="hljs-function"><span class="hljs-title">shutdown</span>() / <span class="hljs-title">shutdownNow</span>() 调用</span><br><span class="hljs-function">    │</span><br><span class="hljs-function">    ├─ 状态转换（<span class="hljs-variable">SHUTDOWN</span> 或 <span class="hljs-variable">STOP</span>）</span><br><span class="hljs-function">    ├─ 中断线程（<span class="hljs-variable">interruptIdleWorkers</span> 或 <span class="hljs-variable">interruptWorkers</span>）</span><br><span class="hljs-function">    └─ <span class="hljs-title">tryTerminate</span>()（首次检查）</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-variable">Worker</span> 线程被中断或任务完成</span><br><span class="hljs-function">    │</span><br><span class="hljs-function">    └─ <span class="hljs-title">getTask</span>() 返回 <span class="hljs-variable"><span class="hljs-literal">null</span></span></span><br><span class="hljs-function">        │</span><br><span class="hljs-function">        └─ <span class="hljs-title">runWorker</span>() 退出循环</span><br><span class="hljs-function">            │</span><br><span class="hljs-function">            └─ <span class="hljs-title">processWorkerExit</span>()</span><br>                │<br>                ├─ 从 <span class="hljs-variable">workers</span> 移除<br>                └─ <span class="hljs-function"><span class="hljs-title">tryTerminate</span>()（再次检查）</span><br><span class="hljs-function">                    │</span><br><span class="hljs-function">                    ├─ <span class="hljs-variable">workerCount</span> &gt; <span class="hljs-number">0</span> → <span class="hljs-title">interruptIdleWorkers</span>(<span class="hljs-variable">ONLY_ONE</span>) 传播</span><br><span class="hljs-function">                    └─ <span class="hljs-variable">workerCount</span> = <span class="hljs-number">0</span> → <span class="hljs-variable">TIDYING</span> → <span class="hljs-variable">TERMINATED</span></span><br></code></pre></td></tr></table></figure>
<p><strong>关键设计</strong>：最后一个退出的 Worker 会触发 TIDYING → TERMINATED 转换。<code>tryTerminate()</code> 确保任何导致 workerCount 减少的操作都有机会触发终止检查，避免线程池永远卡在 SHUTDOWN 状态。</p>
<p><strong>关闭机制关键点</strong>：</p>
<ol>
<li>
<p><strong><code>interruptIdleWorkers()</code> 会导致 idle 线程退出吗？</strong></p>
<p><strong>不一定</strong>。中断只是唤醒线程，线程被唤醒后在 <code>getTask()</code> 循环中检查状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这一段是 getTask 比较开头的地方，getTask 内部 take 是在结尾，被唤醒就会走入这一段</span><br><span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>    decrementWorkerCount();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 只有满足此条件才退出</span><br>&#125;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>状态</th>
<th>队列</th>
<th>线程行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>SHUTDOWN</td>
<td>非空</td>
<td>继续从队列取任务执行</td>
</tr>
<tr>
<td>SHUTDOWN</td>
<td>空</td>
<td>返回 null，线程退出</td>
</tr>
<tr>
<td>STOP</td>
<td>任意</td>
<td>返回 null，线程退出</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong><code>interruptIdleWorkers(ONLY_ONE)</code> 为什么只中断一个？</strong></p>
<p>这是补充机制，处理边缘情况：当所有线程都阻塞在 <code>queue.take()</code>/<code>poll()</code> 等待新任务时（队列空），中断一个来唤醒它。由于此时队列空且状态为 SHUTDOWN，被唤醒的线程会检查状态后退出，然后调用 <code>tryTerminate()</code> 形成连锁反应。</p>
<p>Javadoc 原文：“To guarantee eventual termination, it suffices to always interrupt only one idle worker.”——要保证最终终止，每次中断一个空闲线程就足够了。</p>
</li>
<li>
<p><strong>idle 线程如何响应中断？</strong></p>
<p>idle 线程阻塞在 <code>getTask()</code> 的队列等待上：<code>workQueue.take()</code> 或 <code>workQueue.poll()</code>。中断后 <code>take()</code>/<code>poll()</code> 抛出 <code>InterruptedException</code>，<strong>被 catch 捕获后继续循环，在循环开头检查状态：<code>if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty()))</code>，满足条件返回 null</strong>。</p>
<p>关键：中断只是唤醒线程，线程在循环中检查状态后决定是否退出。</p>
</li>
<li>
<p><strong><code>getTask()</code> 返回 null 后，Worker 如何退出？</strong></p>
<p><code>runWorker()</code> 的核心循环：<code>while (task != null || (task = getTask()) != null)</code>。<code>getTask()</code> 返回 null 后：</p>
<ul>
<li>while 循环条件不满足，退出循环</li>
<li>设置 <code>completedAbruptly = false</code>（标记为正常退出）</li>
<li>执行 <code>processWorkerExit(w, completedAbruptly)</code>：从 workers 集合移除 Worker、更新统计、调用 <code>tryTerminate()</code></li>
<li><code>runWorker()</code> 方法返回，线程结束</li>
</ul>
<p>Worker 线程的本质就是执行 <code>runWorker()</code> 方法。方法返回后，线程自然结束。</p>
</li>
</ol>
<p><strong>两种关闭路径对比：</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>shutdown()</th>
<th>shutdownNow()</th>
</tr>
</thead>
<tbody>
<tr>
<td>状态转换</td>
<td>RUNNING→SHUTDOWN</td>
<td>RUNNING→STOP</td>
</tr>
<tr>
<td>中断方法</td>
<td>interruptIdleWorkers()</td>
<td>interruptWorkers()</td>
</tr>
<tr>
<td>中断范围</td>
<td>仅空闲线程（tryLock检查）</td>
<td>所有已启动线程（无视锁）</td>
</tr>
<tr>
<td>队列处理</td>
<td>Worker继续执行直到空</td>
<td>drainQueue()直接清空</td>
</tr>
<tr>
<td>返回值</td>
<td>void</td>
<td>List<Runnable>（被丢弃的任务）</td>
</tr>
</tbody>
</table>
<h3 id="尝试关闭-threadpoolexecutor">尝试关闭 ThreadPoolExecutor</h3>
<p><strong>关闭流程的本质：状态先变、退出分散的异步模式</strong>。</p>
<p><code>advanceRunState(SHUTDOWN/STOP)</code> 后，调用方立即返回，不会被阻塞等待。线程池进入关闭状态（不可逆），各线程在自然执行节点逐步感知状态变化并退出：</p>
<table>
<thead>
<tr>
<th>退出触发点</th>
<th>触发机制</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>getTask()</code> 阻塞中被中断</td>
<td><code>interruptIdleWorkers()</code> 唤醒</td>
<td>检查状态后退出</td>
</tr>
<tr>
<td><code>getTask()</code> 队列空返回 null</td>
<td>自然感知</td>
<td>SHUTDOWN + 队列空 → 退出</td>
</tr>
<tr>
<td>任务执行完毕后回到 <code>getTask()</code></td>
<td>自然感知</td>
<td>检查状态后退出</td>
</tr>
<tr>
<td><code>processWorkerExit()</code> → <code>tryTerminate()</code></td>
<td>传播式关闭</td>
<td>中断下一个空闲线程</td>
</tr>
</tbody>
</table>
<p>这是<strong>最终一致性</strong>设计：不强制同步等待，而是让线程在自然执行节点逐步退出。优点：调用方快速返回、降低峰值压力、自然处理边缘情况（SHUTDOWN 下长任务正常完成）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Transitions to TERMINATED state if either (SHUTDOWN and pool</span><br><span class="hljs-comment"> * and queue empty) or (STOP and pool empty).  If otherwise</span><br><span class="hljs-comment"> * eligible to terminate but workerCount is nonzero, interrupts an</span><br><span class="hljs-comment"> * idle worker to ensure that shutdown signals propagate. This</span><br><span class="hljs-comment"> * method must be called following any action that might make</span><br><span class="hljs-comment"> * termination possible -- reducing worker count or removing tasks</span><br><span class="hljs-comment"> * from the queue during shutdown. The method is non-private to</span><br><span class="hljs-comment"> * allow access from ScheduledThreadPoolExecutor.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 状态转换条件：(SHUTDOWN &amp;&amp; 队列空) 或 (STOP &amp;&amp; workerCount=0)。</span><br><span class="hljs-comment"> * 若可终止但 workerCount &gt; 0，则中断一个空闲 worker 以确保关闭信号传播。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 调用时机：</span><br><span class="hljs-comment"> * - shutdown() / shutdownNow()：这是2个，而且调用会最终走入 processWorkerExit，进入循环</span><br><span class="hljs-comment"> * - addWorkerFailed()：worker 创建失败时</span><br><span class="hljs-comment"> * - processWorkerExit()：每个 worker 退出时，传播式关闭的关键触发点</span><br><span class="hljs-comment"> * - ScheduledThreadPoolExecutor.onShutdown()：子类重写的钩子，取消延迟任务后检查终止条件</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 无限循环用于处理 CAS 竞争失败；三个 return 分支分别对应不同的退出条件</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 第一阶段：前置拒绝检查：排除不能关闭的情况，可能退出</span><br>        <span class="hljs-comment">// 不能关闭的三种情况：</span><br>        <span class="hljs-comment">// 1. isRunning(c)：RUNNING 状态，线程池正常运行中。所以一般的线程消亡不会 terminate</span><br>        <span class="hljs-comment">// 2. runStateAtLeast(c, TIDYING)：已处于 TIDYING 或 TERMINATED，无需再关闭。竞态条件下已经有其他线程开始推进 TIDYING 流程，也不处理。</span><br>        <span class="hljs-comment">// 3. SHUTDOWN 但队列非空：需要先处理完队列中的任务。有任务仍需处理，静观其变。</span><br>        <span class="hljs-comment">// 注意：STOP 状态不在排除列表中——STOP 本身就是&quot;可关闭&quot;状态，其语义是&quot;不处理队列，中断所有线程&quot;</span><br>        <span class="hljs-comment">// 关闭条件：(SHUTDOWN &amp;&amp; 队列空) 或 (STOP)——两者都要求 workerCount 最终归零</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 第二阶段：确保 wc 降到 0    </span><br>        <span class="hljs-comment">// 传播式关闭：只要 wc &gt; 0，就只中断一个空闲线程后返回</span><br>        <span class="hljs-comment">// </span><br>        <span class="hljs-comment">// 【为什么是补充机制？】</span><br>        <span class="hljs-comment">// shutdown() 已调用 interruptIdleWorkers()（无参数版本）中断所有空闲线程。</span><br>        <span class="hljs-comment">// 此处 interruptIdleWorkers(ONLY_ONE) 处理后续仍有线程存活的情况</span><br>        <span class="hljs-comment">// （如队列非空时线程继续处理任务，处理完后阻塞在 getTask()）。</span><br>        <span class="hljs-comment">// </span><br>        <span class="hljs-comment">// 【为什么只中断一个而非全部？】</span><br>        <span class="hljs-comment">// - 锁持有时间短：只遍历找到一个空闲线程即释放 mainLock</span><br>        <span class="hljs-comment">// - 避免唤醒风暴：线程逐个退出，竞争分散；批量中断会导致大量线程同时苏醒竞争同一把锁</span><br>        <span class="hljs-comment">// - 符合渐进式终止：被中断线程退出后调用 processWorkerExit() → tryTerminate()，</span><br>        <span class="hljs-comment">//   形成连锁反应，逐步关闭所有线程，最终 wc=0 进入 TIDYING→TERMINATED</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 第三阶段：进入下一状态</span><br>        <span class="hljs-comment">// workerCount = 0，执行真正的状态转换：TIDYING → TERMINATED</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// CAS 将状态转换为 TIDYING，workerCount 保持为 0</span><br>            <span class="hljs-comment">// CAS 失败说明其他线程已修改 ctl，需重试外层循环</span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 通常是一个空钩子方法，这两个状态之间就差了一个钩子设计。所以 TIDYING 本身并没有做什么事。</span><br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 再设置为 TERMINATED</span><br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    <span class="hljs-comment">// 已关闭才做 signalAll()。termination 是一个 condition</span><br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// CAS 失败说明有其他线程抢先完成了状态转换，当前线程直接进入下一轮循环重试</span><br>        <span class="hljs-comment">// 注意：由于 workerCount=0 是进入此分支的前提，CAS 竞争只会发生在多个线程同时调用 tryTerminate 时</span><br>        <span class="hljs-comment">// 最终只有一个线程能成功将状态设为 TIDYING，其他线程在下一轮循环中会因 runStateAtLeast(c, TIDYING) 而返回</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="生命周期钩子方法：beforeexecute-afterexecute-terminated">生命周期钩子方法：beforeExecute / afterExecute / terminated</h3>
<p>ThreadPoolExecutor 提供了三个 protected 钩子方法，允许子类在任务执行的关键节点插入自定义逻辑。这是<strong>模板方法模式</strong>的经典应用。</p>
<h4 id="钩子方法定义与调用时机">钩子方法定义与调用时机</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任务执行前调用，在此处抛出异常则 task.run() 不会被执行</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> t 执行任务的线程</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> r 将要执行的任务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123; &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任务执行后调用，在 finally 中执行，无论是否抛出异常</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> r 已执行的任务</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> t task.run() 向外抛出的异常，分两种情况：</span><br><span class="hljs-comment"> *          &lt;ul&gt;</span><br><span class="hljs-comment"> *          &lt;li&gt;普通 Runnable：run() 抛 RuntimeException/Error 时 t 为该异常，正常完成时 t 为 null&lt;/li&gt;</span><br><span class="hljs-comment"> *          &lt;li&gt;FutureTask 包装（如通过 submit 提交）：t 始终为 null，</span><br><span class="hljs-comment"> *              因 FutureTask.run() 捕获 callable.call() 异常作为结果存储，不向外抛出&lt;/li&gt;</span><br><span class="hljs-comment"> *          &lt;/ul&gt;</span><br><span class="hljs-comment"> *          &lt;p&gt;&lt;b&gt;异常传播路径对比&lt;/b&gt;：task.run() 的异常由 Worker 线程捕获传给 afterExecute；</span><br><span class="hljs-comment"> *          future.get() 的异常（CancellationException/ExecutionException）由调用方捕获——</span><br><span class="hljs-comment"> *          二者发生时机、线程视角、异常类型均不同。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123; &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程池终止后调用（所有任务完成且所有 Worker 线程已退出）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">terminated</span><span class="hljs-params">()</span> &#123; &#125;<br></code></pre></td></tr></table></figure>
<p><strong>调用时机与执行保证：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant TPE as ThreadPoolExecutor
    participant W as Worker
    participant T as Thread
    participant Task as Runnable
    
    TPE-&gt;&gt;W: runWorker(this)
    loop 任务循环
        TPE-&gt;&gt;TPE: getTask()
        TPE-&gt;&gt;W: w.lock()
        
        Note over TPE: === 钩子调用开始 ===
        TPE-&gt;&gt;TPE: beforeExecute(thread, task)
        Note right of TPE: 默认空实现&lt;br/&gt;可抛出异常终止任务
        
        alt beforeExecute 正常完成
            TPE-&gt;&gt;Task: task.run()
            Task--&gt;&gt;TPE: 正常返回或抛出异常
            TPE-&gt;&gt;TPE: afterExecute(task, thrown)
            Note right of TPE: thrown = 捕获的异常&lt;br/&gt;正常完成时为 null
        else beforeExecute 抛出异常
            Note over TPE: 任务不会执行
            TPE-&gt;&gt;TPE: afterExecute(task, thrown)
            Note right of TPE: thrown = beforeExecute 的异常
        end
        
        TPE-&gt;&gt;W: w.unlock()
        TPE-&gt;&gt;W: completedTasks++
    end
    
    TPE-&gt;&gt;TPE: processWorkerExit()
    
    alt 线程池进入 TIDYING 状态
        TPE-&gt;&gt;TPE: terminated()
        Note right of TPE: 仅调用一次&lt;br/&gt;所有 Worker 已退出
    end</code></pre>
<h4 id="典型应用场景">典型应用场景</h4>
<p><strong>1. 任务执行时间监控与统计</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitoredThreadPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;Runnable, Long&gt; taskStartTimes = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">totalExecutionTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">taskCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MonitoredThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                               <span class="hljs-type">long</span> keepAliveTime, TimeUnit unit,</span><br><span class="hljs-params">                               BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>        <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>        <span class="hljs-built_in">super</span>.beforeExecute(t, r);<br>        <span class="hljs-comment">// 记录任务开始时间</span><br>        taskStartTimes.put(r, System.nanoTime());<br>        <br>        <span class="hljs-comment">// 可添加：线程上下文初始化</span><br>        MDC.put(<span class="hljs-string">&quot;taskStartTime&quot;</span>, String.valueOf(System.currentTimeMillis()));<br>        MDC.put(<span class="hljs-string">&quot;workerThread&quot;</span>, t.getName());<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 计算执行时间</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> taskStartTimes.remove(r);<br>            <span class="hljs-keyword">if</span> (startTime != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">executionTime</span> <span class="hljs-operator">=</span> System.nanoTime() - startTime;<br>                totalExecutionTime.addAndGet(executionTime);<br>                <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> taskCount.incrementAndGet();<br>                <br>                <span class="hljs-comment">// 记录慢任务</span><br>                <span class="hljs-keyword">if</span> (executionTime &gt; TimeUnit.MILLISECONDS.toNanos(<span class="hljs-number">100</span>)) &#123;<br>                    logger.warn(<span class="hljs-string">&quot;Slow task detected: &#123;&#125;ms, avg: &#123;&#125;ms&quot;</span>, <br>                        TimeUnit.NANOSECONDS.toMillis(executionTime),<br>                        TimeUnit.NANOSECONDS.toMillis(totalExecutionTime.get() / count));<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 异常处理</span><br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                logger.error(<span class="hljs-string">&quot;Task execution failed&quot;</span>, t);<br>                <span class="hljs-comment">// 可添加：失败计数、告警通知</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 必须调用父类方法（虽然父类是空实现，但保持好习惯）</span><br>            <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>            <span class="hljs-comment">// 清理线程上下文</span><br>            MDC.clear();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">terminated</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程池关闭后的清理工作</span><br>        logger.info(<span class="hljs-string">&quot;ThreadPool terminated. Total tasks: &#123;&#125;, avg execution time: &#123;&#125;ms&quot;</span>,<br>            taskCount.get(),<br>            TimeUnit.NANOSECONDS.toMillis(totalExecutionTime.get() / Math.max(<span class="hljs-number">1</span>, taskCount.get())));<br>        <br>        <span class="hljs-comment">// 可添加：资源释放、指标上报</span><br>        <span class="hljs-built_in">super</span>.terminated();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>2. 线程上下文传递（如 TraceId）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContextAwareThreadPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ContextAwareThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                                  <span class="hljs-type">long</span> keepAliveTime, TimeUnit unit,</span><br><span class="hljs-params">                                  BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>        <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>        <span class="hljs-comment">// 从任务中恢复上下文</span><br>        <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> ContextAwareTask) &#123;<br>            <span class="hljs-type">ContextAwareTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> (ContextAwareTask) r;<br>            TraceContext.setTraceId(task.getTraceId());<br>            TraceContext.setSpanId(task.getSpanId());<br>        &#125;<br>        <span class="hljs-built_in">super</span>.beforeExecute(t, r);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 清理上下文，防止线程复用时污染</span><br>            TraceContext.clear();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 包装任务以携带上下文</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContextAwareTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable task;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String traceId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String spanId;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ContextAwareTask</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-built_in">this</span>.task = task;<br>        <span class="hljs-built_in">this</span>.traceId = TraceContext.getTraceId();<br>        <span class="hljs-built_in">this</span>.spanId = TraceContext.generateSpanId();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        task.run();<br>    &#125;<br>    <br>    <span class="hljs-comment">// getters...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>3. 任务优先级动态调整</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityThreadPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityBlockingQueue&lt;Runnable&gt; priorityQueue;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize)</span> &#123;<br>        <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;&gt;(<span class="hljs-number">11</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskComparator</span>()));<br>        <span class="hljs-built_in">this</span>.priorityQueue = (PriorityBlockingQueue&lt;Runnable&gt;) getQueue();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>        <span class="hljs-built_in">super</span>.beforeExecute(t, r);<br>        <span class="hljs-comment">// 记录实际开始执行时间，用于计算等待时间</span><br>        <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> PrioritizedTask) &#123;<br>            ((PrioritizedTask) r).setActualStartTime(System.nanoTime());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> PrioritizedTask) &#123;<br>                <span class="hljs-type">PrioritizedTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> (PrioritizedTask) r;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> task.getActualStartTime() - task.getSubmitTime();<br>                <span class="hljs-type">long</span> <span class="hljs-variable">executionTime</span> <span class="hljs-operator">=</span> System.nanoTime() - task.getActualStartTime();<br>                <br>                <span class="hljs-comment">// 根据等待时间和执行时间动态调整优先级策略</span><br>                <span class="hljs-keyword">if</span> (waitTime &gt; TimeUnit.SECONDS.toNanos(<span class="hljs-number">1</span>)) &#123;<br>                    logger.warn(<span class="hljs-string">&quot;High priority task waited too long: &#123;&#125;ms&quot;</span>, <br>                        TimeUnit.NANOSECONDS.toMillis(waitTime));<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Runnable&gt; &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Runnable r1, Runnable r2)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> (r1 <span class="hljs-keyword">instanceof</span> PrioritizedTask) ? <br>                ((PrioritizedTask) r1).getPriority() : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (r2 <span class="hljs-keyword">instanceof</span> PrioritizedTask) ? <br>                ((PrioritizedTask) r2).getPriority() : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> Integer.compare(p2, p1); <span class="hljs-comment">// 高优先级在前</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="关键注意事项">关键注意事项</h4>
<p><strong>1. 异常处理原则</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>    <span class="hljs-comment">// 错误：直接吞掉异常</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 什么都不做</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 正确：记录并处理异常</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>        logger.error(<span class="hljs-string">&quot;Task failed: &#123;&#125;&quot;</span>, r, t);<br>        <span class="hljs-comment">// 可添加：失败重试、死信队列、告警通知</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>FutureTask 异常处理陷阱：</strong> 当提交的任务是 <code>FutureTask</code>（如 <code>submit()</code> 返回的对象）时，异常被封装在 <code>ExecutionException</code> 内部，<code>afterExecute</code> 收到的 <code>Throwable t</code> 参数可能为 <code>null</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>    <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>    <br>    <span class="hljs-comment">// 对于 FutureTask，需要额外检查内部异常</span><br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span> &amp;&amp; r <span class="hljs-keyword">instanceof</span> Future&lt;?&gt;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Future&lt;?&gt; future = (Future&lt;?&gt;) r;<br>            <span class="hljs-keyword">if</span> (future.isDone()) &#123;<br>                future.get(); <span class="hljs-comment">// 触发 ExecutionException</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ExecutionException ee) &#123;<br>            t = ee.getCause(); <span class="hljs-comment">// 获取真正的异常</span><br>        &#125; <span class="hljs-keyword">catch</span> (CancellationException ce) &#123;<br>            t = ce; <span class="hljs-comment">// 任务被取消</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>        logger.error(<span class="hljs-string">&quot;Task execution failed&quot;</span>, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>原因分析：</strong> <code>FutureTask.run()</code> 内部捕获了所有异常并存储在 <code>outcome</code> 字段中，对外表现为正常完成。只有调用 <code>Future.get()</code> 时才会抛出封装后的 <code>ExecutionException</code>。</p>
<p><strong>2. 阻塞风险</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>    <span class="hljs-comment">// 钩子方法在 Worker 线程中同步执行</span><br>    <span class="hljs-comment">// 应避免耗时操作，否则会阻塞任务执行</span><br>    <br>    <span class="hljs-comment">// 错误：同步调用外部服务</span><br>    <span class="hljs-comment">// externalService.syncCall(); // 阻塞！</span><br>    <br>    <span class="hljs-comment">// 正确：轻量级操作，异步发送指标</span><br>    metricsRecorder.recordTaskStart(r);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>3. 与 shutdown 的协作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">terminated</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 线程池已完全终止，所有 Worker 线程已退出</span><br>    <span class="hljs-comment">// 此时可以安全地释放资源</span><br>    <br>    <span class="hljs-comment">// 上报最终统计指标</span><br>    metricsReporter.reportFinalStats();<br>    <br>    <span class="hljs-comment">// 关闭关联的资源</span><br>    resourceManager.close();<br>    <br>    <span class="hljs-built_in">super</span>.terminated();<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>threadPool.shutdown();<br><span class="hljs-keyword">if</span> (threadPool.awaitTermination(<span class="hljs-number">60</span>, TimeUnit.SECONDS)) &#123;<br>    <span class="hljs-comment">// terminated() 已被调用，资源已清理</span><br>    System.out.println(<span class="hljs-string">&quot;Graceful shutdown completed&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>4. 入参操纵性说明</strong></p>
<p>各钩子方法的参数操纵能力不同：</p>
<table>
<thead>
<tr>
<th>钩子方法</th>
<th>参数</th>
<th>可操纵性</th>
<th>修改的影响范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>beforeExecute(Thread t, Runnable r)</code></td>
<td>Thread t</td>
<td>高</td>
<td>影响即将执行的任务线程属性</td>
</tr>
<tr>
<td></td>
<td>Runnable r</td>
<td>中</td>
<td>可读取任务信息、修改自定义任务内部状态</td>
</tr>
<tr>
<td><code>afterExecute(Runnable r, Throwable t)</code></td>
<td>Runnable r</td>
<td>低</td>
<td>任务已执行完，修改无运行时影响</td>
</tr>
<tr>
<td></td>
<td>Throwable t</td>
<td>低</td>
<td>参数是捕获结果的引用，修改不影响原异常传播</td>
</tr>
<tr>
<td><code>terminated()</code></td>
<td>无参数</td>
<td>-</td>
<td>可访问线程池字段进行清理</td>
</tr>
</tbody>
</table>
<p><strong>beforeExecute 入参操纵示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>    <span class="hljs-built_in">super</span>.beforeExecute(t, r);<br>    <br>    <span class="hljs-comment">// Thread 参数：可操纵线程属性</span><br>    t.setName(<span class="hljs-string">&quot;worker-&quot;</span> + taskIdGenerator.incrementAndGet());<br>    t.setPriority(Thread.NORM_PRIORITY + <span class="hljs-number">1</span>);<br>    t.setContextClassLoader(customClassLoader);<br>    <br>    <span class="hljs-comment">// Runnable 参数：类型检查与状态修改</span><br>    <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> TraceableTask) &#123;<br>        <span class="hljs-type">TraceableTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> (TraceableTask) r;<br>        task.setStartTime(System.nanoTime()); <span class="hljs-comment">// 修改任务内部状态</span><br>        TraceContext.setTraceId(task.getTraceId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键约束：</strong></p>
<ul>
<li><code>beforeExecute</code> 中抛出异常会导致任务不执行，<strong>但 <code>afterExecute</code> 仍会被调用（异常传递给 <code>Throwable</code> 参数）</strong></li>
<li>钩子方法在 Worker 线程中同步执行，修改入参后应避免耗时操作</li>
</ul>
<h4 id="钩子方法与状态机的关系">钩子方法与状态机的关系</h4>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; RUNNING: 创建线程池
    
    RUNNING --&gt; SHUTDOWN: shutdown()
    RUNNING --&gt; STOP: shutdownNow()
    
    SHUTDOWN --&gt; TIDYING: 队列为空且所有任务完成
    STOP --&gt; TIDYING: 所有任务完成
    
    TIDYING --&gt; TERMINATED: terminated() 执行完成
    
    note right of RUNNING
        beforeExecute / afterExecute
        在每个任务执行前后调用
    end note
    
    note right of TIDYING
        terminated() 调用点：
        1. 所有 Worker 已退出
        2. 队列已空
        3. 仅调用一次
    end note</code></pre>
<p><strong>核心要点：</strong></p>
<ul>
<li><code>beforeExecute</code> / <code>afterExecute</code>：每个任务执行前后调用，用于任务级监控和上下文管理</li>
<li><code>terminated</code>：线程池完全终止后调用一次，用于资源清理和最终统计</li>
<li><strong>所有钩子都在同步上下文中执行，应避免耗时操作</strong></li>
<li>异常处理要完善，避免影响线程池正常运行</li>
</ul>
<h4 id="gettask-获取任务">getTask 获取任务</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java">   <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  阻塞式获取任务。遇到异常情况给上游的返回值是 null：</span><br><span class="hljs-comment"> * 1. 有超过 maximumPoolSize 的线程数，返回 null 导致线程退出。</span><br><span class="hljs-comment"> * 2. 线程池 STOP 状态（由 shutdownNow 触发），返回 null 指示线程有序退出。此时即使queue还有任务也不管。</span><br><span class="hljs-comment"> * 3. 线程池 SHUTDOWN 且队列为空。如果仍然有队列任务，则把任务弹出来交给 wt。</span><br><span class="hljs-comment"> * 4. 线程超时：allowCoreThreadTimeOut=true 或 workerCount &gt; corePoolSize 且超时。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Performs blocking or timed wait for a task, depending on</span><br><span class="hljs-comment"> * current configuration settings, or returns null if this worker</span><br><span class="hljs-comment"> * must exit because of any of:</span><br><span class="hljs-comment"> * 1. There are more than maximumPoolSize workers (due to</span><br><span class="hljs-comment"> *    a call to setMaximumPoolSize).</span><br><span class="hljs-comment"> * 2. The pool is stopped.</span><br><span class="hljs-comment"> * 3. The pool is shutdown and the queue is empty.</span><br><span class="hljs-comment"> * 4. This worker timed out waiting for a task, and timed-out</span><br><span class="hljs-comment"> *    workers are subject to termination (that is,</span><br><span class="hljs-comment"> *    &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span><br><span class="hljs-comment"> *    both before and after the timed wait, and if the queue is</span><br><span class="hljs-comment"> *    non-empty, this worker is not the last thread in the pool.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> task, or null if the worker must exit, in which case</span><br><span class="hljs-comment"> *         workerCount is decremented</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// 上次 poll() 是否超时</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>        <br>        <span class="hljs-comment">// 情况 1-3：检查是否需要退出</span><br>        <span class="hljs-comment">// 仅在必要时检查队列是否为空</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// 是否需要超时等待？allowCoreThreadTimeOut 或线程数超过 corePoolSize</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>        <span class="hljs-comment">// 情况 4：超时或超过最大线程数时退出</span><br>        <span class="hljs-comment">// wc &gt; maximumPoolSize 只在 setMaximumPoolSize() 动态调小时发生</span><br>        <span class="hljs-comment">// addWorker 的原子检查保证正常流程不会超过 maximumPoolSize</span><br>        <span class="hljs-comment">// 调小后，多余线程在下次空闲时被回收</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-comment">// CAS 减线程数（可能失败）</span><br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// CAS 失败，继续循环重试</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// timed=true 使用 poll 超时等待，timed=false 使用 take 阻塞等待</span><br>            <span class="hljs-comment">// 进入 timed，就可能让空闲线程取到 null，取到 null 空闲线程就退出</span><br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            <span class="hljs-comment">// 被中断时重置超时标志，继续循环</span><br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="回收线程">回收线程</h3>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="线程池回收线程的过程.png"></p>
<h4 id="interruptidleworkers-中断空闲线程">interruptIdleWorkers 中断空闲线程</h4>
<p><strong>共 6 个方法调用</strong>：</p>
<table>
<thead>
<tr>
<th>调用方</th>
<th>调用形式</th>
<th>触发条件</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>shutdown()</code></td>
<td><code>interruptIdleWorkers()</code></td>
<td>显式关闭线程池</td>
<td>中断所有空闲线程，让它们检查池状态后退出</td>
</tr>
<tr>
<td><code>tryTerminate()</code></td>
<td><code>interruptIdleWorkers(ONLY_ONE)</code></td>
<td>终止条件满足但 workerCount &gt; 0</td>
<td>传播式关闭，唤醒一个线程形成退出连锁反应</td>
</tr>
<tr>
<td><code>setCorePoolSize()</code></td>
<td><code>interruptIdleWorkers()</code></td>
<td>新值 &lt; 当前线程数</td>
<td>回收超出新核心数的多余线程</td>
</tr>
<tr>
<td><code>setMaximumPoolSize()</code></td>
<td><code>interruptIdleWorkers()</code></td>
<td>新值 &lt; 当前线程数</td>
<td>回收超出新最大数的多余线程</td>
</tr>
<tr>
<td><code>setKeepAliveTime()</code></td>
<td><code>interruptIdleWorkers()</code></td>
<td>超时时间变更</td>
<td>让空闲线程重新计算超时，可能触发回收</td>
</tr>
<tr>
<td><code>allowCoreThreadTimeOut()</code></td>
<td><code>interruptIdleWorkers()</code></td>
<td>超时策略变更</td>
<td>让核心线程也参与超时回收</td>
</tr>
</tbody>
</table>
<p><strong>设计动因</strong>：通过 <code>tryLock()</code> 检测 Worker 锁状态，仅中断空闲线程，保护正在执行的任务不被错误中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Interrupts threads that might be waiting for tasks (as</span><br><span class="hljs-comment"> * indicated by not being locked) so they can check for</span><br><span class="hljs-comment"> * termination or configuration changes. Ignores</span><br><span class="hljs-comment"> * SecurityExceptions (in which case some threads may remain</span><br><span class="hljs-comment"> * uninterrupted).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> onlyOne If true, interrupt at most one worker. This is</span><br><span class="hljs-comment"> * called only from tryTerminate when termination is otherwise</span><br><span class="hljs-comment"> * enabled but there are still other workers.  In this case, at</span><br><span class="hljs-comment"> * most one waiting worker is interrupted to propagate shutdown</span><br><span class="hljs-comment"> * signals in case all threads are currently waiting.</span><br><span class="hljs-comment"> * Interrupting any arbitrary thread ensures that newly arriving</span><br><span class="hljs-comment"> * workers since shutdown began will also eventually exit.</span><br><span class="hljs-comment"> * To guarantee eventual termination, it suffices to always</span><br><span class="hljs-comment"> * interrupt only one idle worker, but shutdown() interrupts all</span><br><span class="hljs-comment"> * idle workers so that redundant workers exit promptly, not</span><br><span class="hljs-comment"> * waiting for a straggler task to finish.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;中断可能正在等待任务的线程（通过未锁定来指示），以便它们检查终止或配置变更。</span><br><span class="hljs-comment"> * 忽略 SecurityException（此时某些线程可能保持未中断）。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;参数 onlyOne 为 true 时最多中断一个 Worker，仅在 tryTerminate 中调用。</span><br><span class="hljs-comment"> * 此时终止条件已满足但仍有其他 Worker，最多中断一个等待中的 Worker 以传播关闭信号。</span><br><span class="hljs-comment"> * 为保证最终终止，始终只中断一个空闲 Worker 即可，</span><br><span class="hljs-comment"> * 但 shutdown() 会中断所有空闲 Worker，以便冗余 Worker 迅速退出。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;<br>    <span class="hljs-comment">// 步骤1：加锁保护 workers 集合遍历</span><br>    <span class="hljs-comment">// 设计动因：workers 是 HashSet，非线程安全，遍历时需加锁防止并发修改</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 步骤2：遍历所有 Worker，尝试中断空闲线程</span><br>        <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>            <span class="hljs-comment">// 步骤2.1：双重检查 - 线程未被中断 且 tryLock 成功</span><br>            <span class="hljs-comment">// - !t.isInterrupted()：避免重复中断已中断的线程</span><br>            <span class="hljs-comment">// - w.tryLock()：CAS 尝试获取锁，state=0 时成功（空闲），state=1 时失败（执行中）</span><br>            <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 步骤2.2：中断空闲线程，唤醒阻塞在 getTask() 中的等待</span><br>                    t.interrupt();<br>                &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                    <span class="hljs-comment">// 步骤2.3：忽略安全异常，某些线程可能保持未中断</span><br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 步骤2.4：释放 tryLock 获取的锁，恢复 state=0</span><br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 步骤3：onlyOne=true 时只中断一个，用于传播式关闭</span><br>            <span class="hljs-comment">// 调用场景：tryTerminate() 中，终止条件已满足但仍有其他 Worker</span><br>            <span class="hljs-comment">// 设计意图：唤醒一个空闲线程检查池状态，它会退出并触发下一轮 tryTerminate，形成连锁反应</span><br>            <span class="hljs-keyword">if</span> (onlyOne)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 步骤4：释放 mainLock，确保锁一定被释放</span><br>        mainLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="线程销毁">线程销毁</h3>
<p><img src="%E7%BA%BF%E7%A8%8B%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B.png" alt="线程销毁流程.png"></p>
<h4 id="processworkerexit-worker-退出处理">processWorkerExit Worker 退出处理</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs cleanup and bookkeeping for a dying worker. Only</span><br><span class="hljs-comment"> * called from worker threads. Unless completedAbruptly is set,</span><br><span class="hljs-comment"> * assumes that workerCount has already been adjusted to account</span><br><span class="hljs-comment"> * for exit.  This method removes thread from worker set, and</span><br><span class="hljs-comment"> * possibly terminates the pool or replaces the worker if either</span><br><span class="hljs-comment"> * it exited due to user task exception, or fewer workers</span><br><span class="hljs-comment"> * are running than are required to handle the queue.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;为即将退出的 Worker 执行清理和簿记工作。只能从 Worker 线程调用。</span><br><span class="hljs-comment"> * 除非 completedAbruptly 被设置，否则假设 workerCount 已经调整以计入退出。</span><br><span class="hljs-comment"> * 此方法从工作集中移除线程，并可能在以下情况下终止线程池或替换 Worker：</span><br><span class="hljs-comment"> * &lt;ul&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;因用户任务异常退出&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;运行中的 Worker 数少于 corePoolSize&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;li&gt;队列非空但没有 Worker&lt;/li&gt;</span><br><span class="hljs-comment"> * &lt;/ul&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> completedAbruptly if the worker died due to user exception</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;<br>        <span class="hljs-comment">// 步骤1：调整 workerCount</span><br>        <span class="hljs-comment">// 异常退出时 workerCount 还没调整，需要手动减一</span><br>        <span class="hljs-comment">// 正常退出时 getTask() 已经调用了 decrementWorkerCount()</span><br>        <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>            decrementWorkerCount();<br>        <br>        <span class="hljs-comment">// 步骤2：加锁移除 Worker，累加完成任务数</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 累加此 Worker 完成的任务数到线程池总数</span><br>            completedTaskCount += w.completedTasks;<br>            <span class="hljs-comment">// 从工作集中移除</span><br>            workers.remove(w);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 步骤1和步骤2是为了退出的线程，步骤3和步骤4是为了整个线程池</span><br>        <span class="hljs-comment">// ----------- 注意，这里是先终止再加线程 -----------</span><br><br>        <span class="hljs-comment">// 步骤3：尝试终止线程池（条件检查，非强制）</span><br>        <span class="hljs-comment">// 触发条件：(SHUTDOWN &amp;&amp; 队列空) 或 (STOP)，且 workerCount == 0</span><br>        <span class="hljs-comment">// 注：步骤3成功终止后状态变为 TERMINATED，步骤4的条件判断会直接跳过，两者激活条件互斥</span><br>        tryTerminate(); <br><br>        <span class="hljs-comment">// 步骤4：检查是否需要补充线程</span><br>        <span class="hljs-comment">// 设计意图：先检查终止条件，再决定补充线程，避免在即将终止时创建多余线程</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123; <span class="hljs-comment">// RUNNING 或 SHUTDOWN 状态</span><br>            <span class="hljs-comment">// 正常退出：检查是否需要补充线程</span><br>            <span class="hljs-comment">// 异常退出：跳过检查，必须创建新线程替换（线程数可能不足）</span><br>            <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>                <span class="hljs-comment">// 计算最小保有量：allowCoreThreadTimeOut=false 时为 corePoolSize，</span><br>                <span class="hljs-comment">// 否则核心线程数可以归零（min=0）</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>                <span class="hljs-comment">// 队列非空时至少保留 1 个线程处理-保证任务不被遗忘</span><br>                <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                    min = <span class="hljs-number">1</span>;<br>                <span class="hljs-comment">// 当前线程数已够，无需补充</span><br>                <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>            &#125;<br>            <span class="hljs-comment">// 补充线程：线程保有机制的最后一层兜底</span><br>            <span class="hljs-comment">// addWorker(null, false) 尝试添加非核心线程，但若 wc &lt; corePoolSize，</span><br>            <span class="hljs-comment">// 该线程实际承担核心线程角色——线程池不区分&quot;核心&quot;与&quot;非核心&quot;线程类型。</span><br>            <span class="hljs-comment">// 设计思想：损失一个尽量赔一个，让线程数尽量保持在 min 之上。</span><br>            <span class="hljs-comment">// min 在 allowCoreThreadTimeOut=false 时等于 corePoolSize。</span><br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="常见问题与替代方案">常见问题与替代方案</h2>
<h3 id="调参的核心原则">调参的核心原则</h3>
<p>线程池的调参有几个难点：</p>
<ol>
<li>如果核心线程数过小，则吞吐可能不够，遇到流量毛刺可能导致 RejectExecutionException；但值得警惕的是，如果核心线程数很大，可能导致频繁的上下文切换和过多的资源消耗（不管是 cpu 时间片还是操作系统的内核线程）。</li>
<li>如果队列过长，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。</li>
</ol>
<p>那么，如何计算这些参数呢？<br>
有一个基本的原则是：</p>
<ol>
<li>计算密集型的线程数本身应该尽量贴近 cpu 核数。</li>
<li>io 密集型的线程数要注意伸缩，要配合阻塞队列使用，要有承受拒绝失败的的准备。</li>
</ol>
<p>我们常见的计算方式主要来自于《Java Concurrency in Practice》§8.2（Sizing Thread Pools）：</p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="线程池计算公式.png"></p>
<table>
<thead>
<tr>
<th>方案</th>
<th>问题</th>
</tr>
</thead>
<tbody>
<tr>
<td>$ N_{cpu} = \text{number of CPUs} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>b</mi><mi>r</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;br&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span> U_{cpu} = \text{target CPU utilization}, 0 \leq U_{cpu} \leq 1 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>b</mi><mi>r</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;br&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span> \frac{W}{C} = \text{ratio of wait time to compute time} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>b</mi><mi>r</mi><mo>&gt;</mo><mo>&lt;</mo><mi>b</mi><mi>r</mi><mo>&gt;</mo><mo>∗</mo><mo>∗</mo><mi>T</mi><mi>h</mi><mi>e</mi><mi>o</mi><mi>p</mi><mi>t</mi><mi>i</mi><mi>m</mi><mi>a</mi><mi>l</mi><mi>p</mi><mi>o</mi><mi>o</mi><mi>l</mi><mi>s</mi><mi>i</mi><mi>z</mi><mi>e</mi><mi>f</mi><mi>o</mi><mi>r</mi><mi>k</mi><mi>e</mi><mi>e</mi><mi>p</mi><mi>i</mi><mi>n</mi><mi>g</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>p</mi><mi>r</mi><mi>o</mi><mi>c</mi><mi>e</mi><mi>s</mi><mi>s</mi><mi>o</mi><mi>r</mi><mi>s</mi><mi>a</mi><mi>t</mi><mi>t</mi><mi>h</mi><mi>e</mi><mi>d</mi><mi>e</mi><mi>s</mi><mi>i</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi>u</mi><mi>t</mi><mi>i</mi><mi>l</mi><mi>i</mi><mi>z</mi><mi>a</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi><mi>i</mi><mi>s</mi><mo>:</mo><mo>∗</mo><mo>∗</mo><mo>&lt;</mo><mi>b</mi><mi>r</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;br&gt;&lt;br&gt;**The optimal pool size for keeping the processors at the desired utilization is:**&lt;br&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.46528em;vertical-align:0em;"></span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">T</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">o</span><span class="mord mathdefault">p</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">m</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">p</span><span class="mord mathdefault">o</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mord mathdefault">e</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">o</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">s</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">s</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">t</span><span class="mord mathdefault">h</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault">e</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">e</span><span class="mord mathdefault">d</span><span class="mord mathdefault">u</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">i</span><span class="mord mathdefault" style="margin-right:0.04398em;">z</span><span class="mord mathdefault">a</span><span class="mord mathdefault">t</span><span class="mord mathdefault">i</span><span class="mord mathdefault">o</span><span class="mord mathdefault">n</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mord">∗</span><span class="mord">∗</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span> N_{threads} = N_{cpu} \ast U_{cpu} \ast (1 + \frac{W}{C}) $</td>
<td>出自《Java并发编程实践》<br><br>该方案偏理论化。首先，线程计算的时间和等待的时间要如何确定呢？这个在实际开发中很难得到确切的值。另外计算出来的线程个数逼近线程实体的个数，Java线程池可以利用线程切换的方式最大程度利用CPU核数，这样计算出来的结果是非常偏离业务场景的。</td>
</tr>
<tr>
<td>$ coreSize = 2 \ast N_{cpu} <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>b</mi><mi>r</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;br&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span> maxSize = 25 \ast N_{cpu} $</td>
<td>没有考虑应用中往往使用多个线程池的情况，统一的配置明显不符合多样的业务场景。</td>
</tr>
<tr>
<td>$ coreSize = tps \ast time <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>&lt;</mo><mi>b</mi><mi>r</mi><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&lt;br&gt;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">b</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span></span></span> maxSize = tps \ast time \ast (1.7 \sim 2) $</td>
<td>这种计算方式，考虑到了业务场景，但是该模型是在假定流量平均分布得出的。业务场景的流量往往是随机的，这样不符合真实情况。</td>
</tr>
</tbody>
</table>
<p>现实中可选的线程数计算公式最好是取一个并发 qps 数和 cpu 数的折中。通常可以认为 单任务的 rt/1ms 可以得到单一线程的吞吐数，qps 除以吞吐数可以得到 qps 相应的线程数，但这个方案没有考虑cpu 核数和上下文切换的问题。所以这样算出来的线程数的实际 qps 表现应该低于理论 qps，但可以通过估算和压测不断让理论值逼近实际值。</p>
<h3 id="替代方案对比">替代方案对比</h3>
<p>其他可替代方案，都不如线程池的调优方案成熟（<strong>在可以使用新技术的前提下，我们是否还有调优旧方案的魄力呢？</strong>）：</p>
<h4 id="传统替代方案对比">传统替代方案对比</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">优势</th>
<th style="text-align:center">劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Disruptor框架</td>
<td style="text-align:center">线程池内部是通过一个工作队列去维护任务的执行的，它有一个根本性的缺陷：连续争用问题。也就是多个线程在申请任务时，为了合理地分配任务要付出锁资源，对比快速的任务执行来说，这部分申请的损耗是巨大的。高性能进程间消息库LMAX使用了一个叫作环形缓冲的数据结构，用这种这个特殊的数据结构替代队列，将会避免申请任务时出现的连续争用状况。</td>
<td style="text-align:center">避免连续争用，性能更佳</td>
<td style="text-align:center">缺乏线程管理的能力，使用场景较少</td>
</tr>
<tr>
<td style="text-align:center">协程框架</td>
<td style="text-align:center">协程是一种用户态的轻量级线程，其拥有自己的寄存器上下文和栈，当调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。这种切换上下文的方式要小于线程的开销。在瓶颈侧重IO的情况，使用协程获得并发性要优于使用线程。</td>
<td style="text-align:center">侧重IO情况时，性能更佳。与多线程策略无冲突，可结合使用</td>
<td style="text-align:center">在Java中缺乏成熟的应用</td>
</tr>
<tr>
<td style="text-align:center">Actor框架</td>
<td style="text-align:center">Actor模型通过维护多个Actor去处理并发的任务，它放弃了直接使用线程去获取并发性，而是自己定义了一系列系统组件应该如何动作和交互的通用规则，不需要开发者直接使用线程。通过在原生的线程或协程的级别上做了更高层次的封装，只需要开发者关心每个Actor的逻辑即可实现并发操作。由于避免了直接使用锁，很大程度解决了传统并发编程模式下大量依赖悲观锁导致的资源竞争情况。</td>
<td style="text-align:center">无锁策略，性能更佳，避免直接使用线程，安全性更高</td>
<td style="text-align:center">在Java中缺乏成熟的应用，内部复杂，难以排查和调试</td>
</tr>
</tbody>
</table>
<h4 id="现代java并发框架对比">现代Java并发框架对比</h4>
<p>根据Java并发编程实践和各框架的Javadoc文档，以下是主流并发框架的详细对比：</p>
<table>
<thead>
<tr>
<th>框架</th>
<th>适用场景</th>
<th>核心优势</th>
<th>主要劣势</th>
<th>典型应用</th>
<th>成熟度</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ThreadPoolExecutor</strong></td>
<td>通用任务调度、CPU/IO混合负载</td>
<td>JDK内置、灵活配置、监控完善、社区成熟</td>
<td>配置复杂、需要调优经验</td>
<td>Web服务、批处理、定时任务</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>ForkJoinPool</strong></td>
<td>CPU密集型分治任务、并行计算</td>
<td>工作窃取算法、自动负载均衡、递归任务优化</td>
<td>不适合阻塞操作、调试困难</td>
<td>Stream.parallel()、大数据计算</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>ScheduledThreadPoolExecutor</strong></td>
<td>定时/周期任务调度</td>
<td>精确调度、多任务并发、内存高效</td>
<td>不支持cron表达式、时区处理弱</td>
<td>心跳检测、数据同步</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>Project Reactor</strong></td>
<td>响应式异步流处理、高并发服务</td>
<td>背压支持、组合能力强、非阻塞IO</td>
<td>学习曲线陡峭、调试复杂</td>
<td>WebFlux、消息驱动架构</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>RxJava</strong></td>
<td>异步事件流、UI编程</td>
<td>丰富的操作符、链式调用、易于组合</td>
<td>内存开销大、线程切换频繁</td>
<td>Android开发、事件驱动系统</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>Kotlin Coroutines</strong></td>
<td>轻量级协程、异步IO密集型</td>
<td>资源占用少、代码简洁、结构化并发</td>
<td>需要Kotlin环境、JVM协程非原生</td>
<td>Kotlin服务端、Android</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>Virtual Threads (JDK 21+)</strong></td>
<td>高并发IO密集型、阻塞API场景</td>
<td>轻量级、无需线程池、阻塞代码简化</td>
<td>新特性、生态不成熟、CPU密集型无优势</td>
<td>高并发Web服务、数据库连接</td>
<td>⭐⭐⭐</td>
</tr>
<tr>
<td><strong>Akka</strong></td>
<td>分布式Actor系统、高并发消息处理</td>
<td>无锁设计、容错性强、分布式原生</td>
<td>复杂度高、学习成本大、调试困难</td>
<td>实时系统、游戏服务器</td>
<td>⭐⭐⭐⭐</td>
</tr>
</tbody>
</table>
<h4 id="选择建议">选择建议</h4>
<p><strong>选择ThreadPoolExecutor的场景</strong>：</p>
<ul>
<li>通用的异步任务处理</li>
<li>需要精确控制线程数和队列大小</li>
<li>要求完善的监控和调优能力</li>
<li>团队熟悉传统并发模型</li>
</ul>
<p><strong>选择响应式框架（Reactor/RxJava）的场景</strong>：</p>
<ul>
<li>微服务架构，需要高并发非阻塞IO</li>
<li>数据流处理，需要背压和流量控制</li>
<li>复杂的异步组合逻辑</li>
<li>已有Spring WebFlux等响应式基础设施</li>
</ul>
<p><strong>选择Virtual Threads的场景</strong>：</p>
<ul>
<li>JDK 21+环境</li>
<li>大量阻塞IO操作（数据库、HTTP调用）</li>
<li>希望简化异步代码（避免回调地狱）</li>
<li>不需要精细的线程池调优</li>
</ul>
<p><strong>选择ForkJoinPool的场景</strong>：</p>
<ul>
<li>CPU密集型递归算法</li>
<li>并行数据处理（如Stream.parallel()）</li>
<li>需要工作窃取优化的场景</li>
</ul>
<p><strong>关键原则</strong>：</p>
<ol>
<li><strong>不要为了新而新</strong>：ThreadPoolExecutor 是传统同步阻塞模型下的首选，具备最精细的资源管控能力。只有明确的技术驱动因素才值得切换到其他方案。</li>
<li><strong>混合使用</strong>：可以在同一系统中混合使用不同框架（如ThreadPoolExecutor处理计算，Reactor处理IO）</li>
<li><strong>渐进式迁移</strong>：从ThreadPoolExecutor迁移到新框架需要充分测试和评估</li>
</ol>
<p>缺乏管控能力就不适合调优。</p>
<h2 id="threadpoolexecutor-监控与调优实践">ThreadPoolExecutor 监控与调优实践</h2>
<h3 id="监控指标采集">监控指标采集</h3>
<p>根据Java并发编程最佳实践和 ThreadPoolExecutor 的Javadoc，以下是关键的监控指标：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程池监控指标采集示例</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> magicliang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2026-01-24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolMonitor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(ThreadPoolMonitor.class);<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadPoolExecutor executor;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService scheduler;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">rejectedCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolMonitor</span><span class="hljs-params">(ThreadPoolExecutor executor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.executor = executor;<br>        <span class="hljs-built_in">this</span>.scheduler = Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;pool-monitor&quot;</span>);<br>            t.setDaemon(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 包装拒绝策略以统计拒绝次数</span><br>        wrapRejectedExecutionHandler();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动监控，每60秒采集一次指标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startMonitoring</span><span class="hljs-params">()</span> &#123;<br>        scheduler.scheduleAtFixedRate(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                logMetrics();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                logger.error(<span class="hljs-string">&quot;Failed to log thread pool metrics&quot;</span>, t);<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 采集并记录线程池指标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logMetrics</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">activeCount</span> <span class="hljs-operator">=</span> executor.getActiveCount();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">poolSize</span> <span class="hljs-operator">=</span> executor.getPoolSize();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span> <span class="hljs-operator">=</span> executor.getCorePoolSize();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maximumPoolSize</span> <span class="hljs-operator">=</span> executor.getMaximumPoolSize();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">completedTaskCount</span> <span class="hljs-operator">=</span> executor.getCompletedTaskCount();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">taskCount</span> <span class="hljs-operator">=</span> executor.getTaskCount();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">queueSize</span> <span class="hljs-operator">=</span> executor.getQueue().size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">queueRemainingCapacity</span> <span class="hljs-operator">=</span> executor.getQueue().remainingCapacity();<br>        <br>        <span class="hljs-comment">// 计算活跃度</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">activeRatio</span> <span class="hljs-operator">=</span> maximumPoolSize &gt; <span class="hljs-number">0</span> ? <br>            (<span class="hljs-type">double</span>) activeCount / maximumPoolSize : <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 计算队列使用率</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">queueCapacity</span> <span class="hljs-operator">=</span> queueSize + queueRemainingCapacity;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">queueUsageRatio</span> <span class="hljs-operator">=</span> queueCapacity &gt; <span class="hljs-number">0</span> ? <br>            (<span class="hljs-type">double</span>) queueSize / queueCapacity : <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 记录指标</span><br>        logger.info(<span class="hljs-string">&quot;ThreadPool Metrics: &quot;</span> +<br>            <span class="hljs-string">&quot;activeCount=&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;poolSize=&#123;&#125;/&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;activeRatio=&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;queueSize=&#123;&#125;/&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;queueUsageRatio=&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;completedTasks=&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;totalTasks=&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;rejectedCount=&#123;&#125;&quot;</span>,<br>            activeCount,<br>            poolSize, maximumPoolSize,<br>            String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, activeRatio),<br>            queueSize, queueCapacity,<br>            String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, queueUsageRatio),<br>            completedTaskCount,<br>            taskCount,<br>            rejectedCount.get());<br>        <br>        <span class="hljs-comment">// 告警检查</span><br>        checkAndAlert(activeRatio, queueUsageRatio);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查指标并触发告警</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndAlert</span><span class="hljs-params">(<span class="hljs-type">double</span> activeRatio, <span class="hljs-type">double</span> queueUsageRatio)</span> &#123;<br>        <span class="hljs-comment">// 活跃度超过90%告警</span><br>        <span class="hljs-keyword">if</span> (activeRatio &gt; <span class="hljs-number">0.9</span>) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Thread pool active ratio too high: &#123;&#125;&quot;</span>, activeRatio);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 队列使用率超过80%告警</span><br>        <span class="hljs-keyword">if</span> (queueUsageRatio &gt; <span class="hljs-number">0.8</span>) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Thread pool queue usage too high: &#123;&#125;&quot;</span>, queueUsageRatio);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 拒绝次数超过阈值告警</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">rejected</span> <span class="hljs-operator">=</span> rejectedCount.get();<br>        <span class="hljs-keyword">if</span> (rejected &gt; <span class="hljs-number">100</span>) &#123;<br>            logger.error(<span class="hljs-string">&quot;Thread pool rejected too many tasks: &#123;&#125;&quot;</span>, rejected);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 包装拒绝策略以统计拒绝次数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrapRejectedExecutionHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">originalHandler</span> <span class="hljs-operator">=</span> executor.getRejectedExecutionHandler();<br>        executor.setRejectedExecutionHandler((r, executor) -&gt; &#123;<br>            rejectedCount.incrementAndGet();<br>            originalHandler.rejectedExecution(r, executor);<br>        &#125;);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 停止监控</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stopMonitoring</span><span class="hljs-params">()</span> &#123;<br>        scheduler.shutdown();<br>        <span class="hljs-keyword">try</span> &#123;<br>            scheduler.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="调优建议">调优建议</h3>
<p><strong>1. 核心线程数设置</strong>：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">CPU</span>密集型：核心线程数 = <span class="hljs-meta">CPU</span>核数 + <span class="hljs-number">1</span><br>IO密集型：核心线程数 = <span class="hljs-meta">CPU</span>核数 * (<span class="hljs-number">1</span> + 平均等待时间/平均计算时间)<br></code></pre></td></tr></table></figure>
<p><strong>2. 队列大小设置</strong>：</p>
<ul>
<li>快速失败场景：小队列 + AbortPolicy</li>
<li>削峰填谷场景：中等队列 + CallerRunsPolicy</li>
<li>避免丢失场景：大队列（但要监控）</li>
</ul>
<p><strong>3. 拒绝策略选择</strong>：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>适用场景</th>
<th>风险</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbortPolicy</td>
<td>快速失败，允许丢任务</td>
<td>任务丢失</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>降级执行，不丢任务</td>
<td>调用线程阻塞</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>静默丢弃</td>
<td>无感知丢失</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃最老任务</td>
<td>优先级倒置</td>
</tr>
</tbody>
</table>
<p>如果还是解决不了问题，需要考虑全局动态扩容的方案。</p>
<p><strong>线程池监控指标体系：</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph 核心监控指标
        A[线程池监控] --&gt; B[线程指标]
        A --&gt; C[队列指标]
        A --&gt; D[任务指标]
        A --&gt; E[异常指标]
        
        B --&gt; B1[poolSize&lt;br/&gt;当前线程数]
        B --&gt; B2[activeCount&lt;br/&gt;活跃线程数]
        B --&gt; B3[largestPoolSize&lt;br/&gt;历史最大线程数]
        B --&gt; B4[corePoolSize&lt;br/&gt;核心线程数]
        B --&gt; B5[maximumPoolSize&lt;br/&gt;最大线程数]
        
        C --&gt; C1[queue.size&lt;br/&gt;队列当前大小]
        C --&gt; C2[queue.remainingCapacity&lt;br/&gt;队列剩余容量]
        C --&gt; C3[队列使用率&lt;br/&gt;size/capacity]
        
        D --&gt; D1[taskCount&lt;br/&gt;总任务数]
        D --&gt; D2[completedTaskCount&lt;br/&gt;已完成任务数]
        D --&gt; D3[待执行任务数&lt;br/&gt;taskCount-completedTaskCount]
        
        E --&gt; E1[rejectedCount&lt;br/&gt;拒绝任务数]
        E --&gt; E2[exceptionCount&lt;br/&gt;异常任务数]
    end
    
    style A fill:#4ECDC4
    style B fill:#87CEEB
    style C fill:#90EE90
    style D fill:#FFB6C1
    style E fill:#FF6B6B</code></pre>
<p><strong>完整的线程池监控实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 可监控的线程池实现</span><br><span class="hljs-comment"> * 提供完整的监控指标收集和告警能力</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitoredThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br>    <br>    <span class="hljs-comment">// ==================== 监控指标 ====================</span><br>    <br>    <span class="hljs-comment">/** 拒绝任务计数器 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">rejectedCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/** 异常任务计数器 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">exceptionCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/** 任务执行时间统计（纳秒） */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">totalExecutionTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/** 任务开始时间记录（用于计算执行时间） */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Runnable, Long&gt; taskStartTimes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-comment">/** 线程池名称（用于日志和监控标识） */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String poolName;<br>    <br>    <span class="hljs-comment">/** 告警阈值配置 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">double</span> <span class="hljs-variable">activeRatioThreshold</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.8</span>;      <span class="hljs-comment">// 活跃度告警阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">double</span> <span class="hljs-variable">queueUsageThreshold</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.8</span>;       <span class="hljs-comment">// 队列使用率告警阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">taskTimeoutMs</span> <span class="hljs-operator">=</span> <span class="hljs-number">30000</span>;             <span class="hljs-comment">// 任务超时阈值（毫秒）</span><br>    <br>    <span class="hljs-comment">// ==================== 构造函数 ====================</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MonitoredThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">            String poolName,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">            <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">            TimeUnit unit,</span><br><span class="hljs-params">            BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">            ThreadFactory threadFactory)</span> &#123;<br>        <br>        <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory,<br>            <span class="hljs-comment">// 使用自定义拒绝策略来统计拒绝次数</span><br>            (r, executor) -&gt; &#123;<br>                ((MonitoredThreadPoolExecutor) executor).rejectedCount.incrementAndGet();<br>                <span class="hljs-comment">// 记录拒绝日志</span><br>                System.err.printf(<span class="hljs-string">&quot;[%s] 任务被拒绝: queue=%d, active=%d, pool=%d%n&quot;</span>,<br>                    ((MonitoredThreadPoolExecutor) executor).poolName,<br>                    executor.getQueue().size(),<br>                    executor.getActiveCount(),<br>                    executor.getPoolSize());<br>                <span class="hljs-comment">// 默认行为：抛出异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task rejected from &quot;</span> + <br>                    ((MonitoredThreadPoolExecutor) executor).poolName);<br>            &#125;);<br>        <br>        <span class="hljs-built_in">this</span>.poolName = poolName;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 生命周期钩子 ====================</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>        <span class="hljs-built_in">super</span>.beforeExecute(t, r);<br>        <span class="hljs-comment">// 记录任务开始时间</span><br>        taskStartTimes.put(r, System.nanoTime());<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 计算任务执行时间</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> taskStartTimes.remove(r);<br>            <span class="hljs-keyword">if</span> (startTime != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">executionTime</span> <span class="hljs-operator">=</span> System.nanoTime() - startTime;<br>                totalExecutionTime.addAndGet(executionTime);<br>                <br>                <span class="hljs-comment">// 检查任务是否超时</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">executionTimeMs</span> <span class="hljs-operator">=</span> TimeUnit.NANOSECONDS.toMillis(executionTime);<br>                <span class="hljs-keyword">if</span> (executionTimeMs &gt; taskTimeoutMs) &#123;<br>                    System.err.printf(<span class="hljs-string">&quot;[%s] 任务执行超时: %dms &gt; %dms%n&quot;</span>,<br>                        poolName, executionTimeMs, taskTimeoutMs);<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 统计异常</span><br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                exceptionCount.incrementAndGet();<br>                System.err.printf(<span class="hljs-string">&quot;[%s] 任务执行异常: %s%n&quot;</span>, poolName, t.getMessage());<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 监控指标获取 ====================</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取线程池活跃度（0.0 ~ 1.0）</span><br><span class="hljs-comment">     * 活跃度 = 活跃线程数 / 最大线程数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getActiveRatio</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) getActiveCount() / getMaximumPoolSize();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取队列使用率（0.0 ~ 1.0）</span><br><span class="hljs-comment">     * 使用率 = 队列当前大小 / 队列总容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getQueueUsageRatio</span><span class="hljs-params">()</span> &#123;<br>        BlockingQueue&lt;Runnable&gt; queue = getQueue();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> size + queue.remainingCapacity();<br>        <span class="hljs-keyword">return</span> capacity &gt; <span class="hljs-number">0</span> ? (<span class="hljs-type">double</span>) size / capacity : <span class="hljs-number">0.0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取平均任务执行时间（毫秒）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getAverageExecutionTimeMs</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">completed</span> <span class="hljs-operator">=</span> getCompletedTaskCount();<br>        <span class="hljs-keyword">if</span> (completed == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">return</span> TimeUnit.NANOSECONDS.toMillis(totalExecutionTime.get()) / (<span class="hljs-type">double</span>) completed;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取拒绝任务数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getRejectedCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> rejectedCount.get();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取异常任务数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getExceptionCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> exceptionCount.get();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取待执行任务数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getPendingTaskCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getTaskCount() - getCompletedTaskCount();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取完整的监控快照</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ThreadPoolMetrics <span class="hljs-title function_">getMetrics</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolMetrics</span>(<br>            poolName,<br>            getCorePoolSize(),<br>            getMaximumPoolSize(),<br>            getPoolSize(),<br>            getActiveCount(),<br>            getLargestPoolSize(),<br>            getTaskCount(),<br>            getCompletedTaskCount(),<br>            getQueue().size(),<br>            getQueue().remainingCapacity(),<br>            rejectedCount.get(),<br>            exceptionCount.get(),<br>            getAverageExecutionTimeMs()<br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 告警检查 ====================</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查是否需要告警</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndAlert</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 检查活跃度</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">activeRatio</span> <span class="hljs-operator">=</span> getActiveRatio();<br>        <span class="hljs-keyword">if</span> (activeRatio &gt;= activeRatioThreshold) &#123;<br>            System.err.printf(<span class="hljs-string">&quot;[%s] 告警: 线程池活跃度过高 %.2f%% &gt;= %.2f%%%n&quot;</span>,<br>                poolName, activeRatio * <span class="hljs-number">100</span>, activeRatioThreshold * <span class="hljs-number">100</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 检查队列使用率</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">queueUsage</span> <span class="hljs-operator">=</span> getQueueUsageRatio();<br>        <span class="hljs-keyword">if</span> (queueUsage &gt;= queueUsageThreshold) &#123;<br>            System.err.printf(<span class="hljs-string">&quot;[%s] 告警: 队列使用率过高 %.2f%% &gt;= %.2f%%%n&quot;</span>,<br>                poolName, queueUsage * <span class="hljs-number">100</span>, queueUsageThreshold * <span class="hljs-number">100</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 检查拒绝任务</span><br>        <span class="hljs-keyword">if</span> (rejectedCount.get() &gt; <span class="hljs-number">0</span>) &#123;<br>            System.err.printf(<span class="hljs-string">&quot;[%s] 告警: 存在被拒绝的任务 count=%d%n&quot;</span>,<br>                poolName, rejectedCount.get());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 动态调参 ====================</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 动态调整核心线程数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustCorePoolSize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCorePoolSize)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldSize</span> <span class="hljs-operator">=</span> getCorePoolSize();<br>        setCorePoolSize(newCorePoolSize);<br>        System.out.printf(<span class="hljs-string">&quot;[%s] 核心线程数调整: %d -&gt; %d%n&quot;</span>, poolName, oldSize, newCorePoolSize);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 动态调整最大线程数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustMaximumPoolSize</span><span class="hljs-params">(<span class="hljs-type">int</span> newMaximumPoolSize)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldSize</span> <span class="hljs-operator">=</span> getMaximumPoolSize();<br>        setMaximumPoolSize(newMaximumPoolSize);<br>        System.out.printf(<span class="hljs-string">&quot;[%s] 最大线程数调整: %d -&gt; %d%n&quot;</span>, poolName, oldSize, newMaximumPoolSize);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 监控指标数据类 ====================</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolMetrics</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String poolName;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> corePoolSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maximumPoolSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> activeCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> largestPoolSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> taskCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> completedTaskCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> queueSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> queueRemainingCapacity;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> rejectedCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> exceptionCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> avgExecutionTimeMs;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolMetrics</span><span class="hljs-params">(String poolName, <span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                <span class="hljs-type">int</span> poolSize, <span class="hljs-type">int</span> activeCount, <span class="hljs-type">int</span> largestPoolSize, <span class="hljs-type">long</span> taskCount,</span><br><span class="hljs-params">                <span class="hljs-type">long</span> completedTaskCount, <span class="hljs-type">int</span> queueSize, <span class="hljs-type">int</span> queueRemainingCapacity,</span><br><span class="hljs-params">                <span class="hljs-type">long</span> rejectedCount, <span class="hljs-type">long</span> exceptionCount, <span class="hljs-type">double</span> avgExecutionTimeMs)</span> &#123;<br>            <span class="hljs-built_in">this</span>.poolName = poolName;<br>            <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>            <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>            <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>            <span class="hljs-built_in">this</span>.activeCount = activeCount;<br>            <span class="hljs-built_in">this</span>.largestPoolSize = largestPoolSize;<br>            <span class="hljs-built_in">this</span>.taskCount = taskCount;<br>            <span class="hljs-built_in">this</span>.completedTaskCount = completedTaskCount;<br>            <span class="hljs-built_in">this</span>.queueSize = queueSize;<br>            <span class="hljs-built_in">this</span>.queueRemainingCapacity = queueRemainingCapacity;<br>            <span class="hljs-built_in">this</span>.rejectedCount = rejectedCount;<br>            <span class="hljs-built_in">this</span>.exceptionCount = exceptionCount;<br>            <span class="hljs-built_in">this</span>.avgExecutionTimeMs = avgExecutionTimeMs;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> String.format(<br>                <span class="hljs-string">&quot;ThreadPoolMetrics&#123;pool=%s, core=%d, max=%d, current=%d, active=%d, &quot;</span> +<br>                <span class="hljs-string">&quot;largest=%d, tasks=%d, completed=%d, queue=%d/%d, rejected=%d, &quot;</span> +<br>                <span class="hljs-string">&quot;exceptions=%d, avgTime=%.2fms&#125;&quot;</span>,<br>                poolName, corePoolSize, maximumPoolSize, poolSize, activeCount,<br>                largestPoolSize, taskCount, completedTaskCount, queueSize,<br>                queueSize + queueRemainingCapacity, rejectedCount, exceptionCount,<br>                avgExecutionTimeMs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>定时监控任务示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolMonitorExample</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 创建可监控的线程池</span><br>        <span class="hljs-type">MonitoredThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MonitoredThreadPoolExecutor</span>(<br>            <span class="hljs-string">&quot;business-pool&quot;</span>,<br>            <span class="hljs-number">4</span>,                              <span class="hljs-comment">// corePoolSize</span><br>            <span class="hljs-number">8</span>,                              <span class="hljs-comment">// maximumPoolSize</span><br>            <span class="hljs-number">60L</span>, TimeUnit.SECONDS,          <span class="hljs-comment">// keepAliveTime</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>), <span class="hljs-comment">// workQueue</span><br>            r -&gt; &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>                t.setName(<span class="hljs-string">&quot;business-pool-&quot;</span> + t.getId());<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        );<br>        <br>        <span class="hljs-comment">// 启动监控任务（每5秒打印一次指标）</span><br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">monitor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadScheduledExecutor();<br>        monitor.scheduleAtFixedRate(() -&gt; &#123;<br>            <span class="hljs-comment">// 获取并打印监控指标</span><br>            MonitoredThreadPoolExecutor.<span class="hljs-type">ThreadPoolMetrics</span> <span class="hljs-variable">metrics</span> <span class="hljs-operator">=</span> executor.getMetrics();<br>            System.out.println(metrics);<br>            <br>            <span class="hljs-comment">// 检查告警</span><br>            executor.checkAndAlert();<br>            <br>            <span class="hljs-comment">// 可以在这里将指标上报到监控系统</span><br>            <span class="hljs-comment">// metricsReporter.report(metrics);</span><br>            <br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        <br>        <span class="hljs-comment">// 模拟提交任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">try</span> &#123;<br>                executor.execute(() -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 模拟任务执行</span><br>                        Thread.sleep((<span class="hljs-type">long</span>) (Math.random() * <span class="hljs-number">1000</span>));<br>                        System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + taskId + <span class="hljs-string">&quot;完成&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;);<br>            &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>                System.err.println(<span class="hljs-string">&quot;任务&quot;</span> + taskId + <span class="hljs-string">&quot;被拒绝&quot;</span>);<br>            &#125;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 等待任务完成</span><br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        <br>        <span class="hljs-comment">// 关闭</span><br>        executor.shutdown();<br>        monitor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>监控告警决策流程：</strong></p>
<pre><code class="hljs mermaid">flowchart TD
    A[定时采集指标] --&gt; B&#123;活跃度 &gt;= 80%?&#125;
    B --&gt;|是| C[告警: 线程池繁忙]
    B --&gt;|否| D&#123;队列使用率 &gt;= 80%?&#125;
    
    D --&gt;|是| E[告警: 队列积压]
    D --&gt;|否| F&#123;有拒绝任务?&#125;
    
    F --&gt;|是| G[告警: 任务被拒绝]
    F --&gt;|否| H&#123;平均执行时间过长?&#125;
    
    H --&gt;|是| I[告警: 任务执行慢]
    H --&gt;|否| J[正常]
    
    C --&gt; K&#123;是否自动扩容?&#125;
    E --&gt; K
    G --&gt; K
    
    K --&gt;|是| L[动态调整参数]
    K --&gt;|否| M[通知运维处理]
    
    L --&gt; N&#123;调整core?&#125;
    N --&gt;|是| O[setCorePoolSize]
    N --&gt;|否| P&#123;调整max?&#125;
    P --&gt;|是| Q[setMaximumPoolSize]
    P --&gt;|否| R[调整队列容量]
    
    style C fill:#FF6B6B
    style E fill:#FF6B6B
    style G fill:#FF6B6B
    style I fill:#FFB6C1
    style J fill:#90EE90
    style L fill:#4ECDC4</code></pre>
<p><strong>Spring Boot 集成监控示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.actuate.endpoint.annotation.*;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程池监控端点</span><br><span class="hljs-comment"> * 访问 /actuator/threadpool 获取所有线程池状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Endpoint(id = &quot;threadpool&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolEndpoint</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, MonitoredThreadPoolExecutor&gt; executors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String name, MonitoredThreadPoolExecutor executor)</span> &#123;<br>        executors.put(name, executor);<br>    &#125;<br>    <br>    <span class="hljs-meta">@ReadOperation</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">health</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, Object&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, MonitoredThreadPoolExecutor&gt; entry : executors.entrySet()) &#123;<br>            <span class="hljs-type">MonitoredThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> entry.getValue();<br>            Map&lt;String, Object&gt; poolInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <br>            <span class="hljs-comment">// 基础指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;corePoolSize&quot;</span>, executor.getCorePoolSize());<br>            poolInfo.put(<span class="hljs-string">&quot;maximumPoolSize&quot;</span>, executor.getMaximumPoolSize());<br>            poolInfo.put(<span class="hljs-string">&quot;poolSize&quot;</span>, executor.getPoolSize());<br>            poolInfo.put(<span class="hljs-string">&quot;activeCount&quot;</span>, executor.getActiveCount());<br>            poolInfo.put(<span class="hljs-string">&quot;largestPoolSize&quot;</span>, executor.getLargestPoolSize());<br>            <br>            <span class="hljs-comment">// 任务指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;taskCount&quot;</span>, executor.getTaskCount());<br>            poolInfo.put(<span class="hljs-string">&quot;completedTaskCount&quot;</span>, executor.getCompletedTaskCount());<br>            poolInfo.put(<span class="hljs-string">&quot;pendingTaskCount&quot;</span>, executor.getPendingTaskCount());<br>            <br>            <span class="hljs-comment">// 队列指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;queueSize&quot;</span>, executor.getQueue().size());<br>            poolInfo.put(<span class="hljs-string">&quot;queueRemainingCapacity&quot;</span>, executor.getQueue().remainingCapacity());<br>            <br>            <span class="hljs-comment">// 计算指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;activeRatio&quot;</span>, String.format(<span class="hljs-string">&quot;%.2f%%&quot;</span>, executor.getActiveRatio() * <span class="hljs-number">100</span>));<br>            poolInfo.put(<span class="hljs-string">&quot;queueUsageRatio&quot;</span>, String.format(<span class="hljs-string">&quot;%.2f%%&quot;</span>, executor.getQueueUsageRatio() * <span class="hljs-number">100</span>));<br>            poolInfo.put(<span class="hljs-string">&quot;avgExecutionTimeMs&quot;</span>, String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, executor.getAverageExecutionTimeMs()));<br>            <br>            <span class="hljs-comment">// 异常指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;rejectedCount&quot;</span>, executor.getRejectedCount());<br>            poolInfo.put(<span class="hljs-string">&quot;exceptionCount&quot;</span>, executor.getExceptionCount());<br>            <br>            result.put(entry.getKey(), poolInfo);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-meta">@WriteOperation</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">adjustPoolSize</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@Selector</span> String poolName,</span><br><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> Integer corePoolSize,</span><br><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> Integer maximumPoolSize)</span> &#123;<br>        <br>        <span class="hljs-type">MonitoredThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> executors.get(poolName);<br>        <span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程池不存在: &quot;</span> + poolName;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (corePoolSize != <span class="hljs-literal">null</span>) &#123;<br>            executor.adjustCorePoolSize(corePoolSize);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (maximumPoolSize != <span class="hljs-literal">null</span>) &#123;<br>            executor.adjustMaximumPoolSize(maximumPoolSize);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;调整成功&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的 activeCount 是每个 worker 是否互斥 held 的总数的统计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getActiveCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// workers 是一个 HashSet，它是非线程安全的。</span><br>getActiveCount 需要遍历这个集合，如果不加全局的 mainLock，在遍历过程中如果有线程销毁或创建，会抛出 ConcurrentModificationException 或者读到错误的数据。所以 mainLock 是为了保护 workers 集合的遍历安全。<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (Worker w : workers)<br>                <span class="hljs-comment">// 在 ThreadPoolExecutor 的设计中，Worker 只要开始执行任务（runWorker 方法中），就会把自己锁住（lock）。</span><br>                <span class="hljs-comment">// 当 Worker 没有任务做，正在 getTask() 方法里阻塞等待（即空闲状态）时，它是**不加锁（unlocked）**的。</span><br>                <span class="hljs-comment">// 所以，isLocked() == true 等价于 “这个线程正在干活”。</span><br>                <span class="hljs-comment">// getActiveCount 的目的就是统计“当前有多少个线程正在干活”，所以必须统计被锁住的 Worker。</span><br>                <span class="hljs-keyword">if</span> (w.isLocked())<br>                    ++n;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里的 isLocked 意味着这个工作线程正在跑  task 的 run，意味着可能是如下状态：RUNNABLE、BLOCKED、WAITING、TIMED_WAITING。</p>
<h3 id="最终解决方案">最终解决方案</h3>
<p>通过监控线程池负载，制定告警策略：</p>
<ol>
<li>线程池活跃度 = activeCount/maximumPoolSize。看看这个值是不是趋近于 1。</li>
<li>监控队列的capacity 和 size 的比例。</li>
<li>监控 RejectExecutionException 的出现。</li>
</ol>
<p>加引入线程池动态管控能力，基于告警制定 sop，确定是否要动态调节线程数和拒绝策略。</p>
<hr>
<h1>ScheduledThreadPoolExecutor 详解</h1>
<p>在第1章中，我们了解了 <code>ScheduledExecutorService</code> 接口的基本用法和常见陷阱。本章将深入其核心实现 <code>ScheduledThreadPoolExecutor</code>，探讨其内部机制和设计原理。</p>
<h2 id="延迟队列任务的标准实现模式">延迟队列任务的标准实现模式</h2>
<p>延迟队列任务通常包含一个代表 deadline 的时间字段，需要实现 <code>Delayed</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Delayed 接口继承 Comparable，因为延迟队列需要按时间排序取出最早到期的任务</span><br><span class="hljs-comment">// 二叉堆的入队/出队操作依赖 compareTo 确定任务优先级</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Delayed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Delayed&gt; &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>ScheduledFutureTask 的实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;V&gt; &#123;<br>    <span class="hljs-comment">// 纳秒级的时间戳，表示任务的 deadline（标准延迟队列设计模式）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> time;<br>    <br>    <span class="hljs-comment">// 周期任务的周期值</span><br>    <span class="hljs-comment">// 正数：fixed-rate模式，表示理论时间间隔</span><br>    <span class="hljs-comment">// 负数：fixed-delay模式，表示实际延迟时间  </span><br>    <span class="hljs-comment">// 零：一次性任务</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> period;<br>    <br>    <span class="hljs-comment">// 序列号，用于相同时间任务的排序（FIFO 保证）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> sequenceNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>        <span class="hljs-keyword">return</span> unit.convert(time - now(), NANOSECONDS);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br>        <span class="hljs-keyword">if</span> (other == <span class="hljs-built_in">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> ScheduledFutureTask) &#123;<br>            ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> time - x.time;<br>            <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &lt; x.sequenceNumber) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);<br>        <span class="hljs-keyword">return</span> (diff &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : (diff &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 周期任务的核心执行逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();<br>        <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic)) &#123;<br>            cancel(<span class="hljs-literal">false</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic) &#123;<br>            <span class="hljs-comment">// 一次性任务：正常执行</span><br>            <span class="hljs-built_in">super</span>.run();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">super</span>.runAndReset()) &#123;<br>            <span class="hljs-comment">// 周期任务：执行后重置状态，计算下次执行时间</span><br>            setNextRunTime();<br>            reExecutePeriodic(outerTask);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键设计点</strong>：</p>
<ul>
<li><strong>统一时间表示</strong>：所有任务都用纳秒级时间戳表示deadline</li>
<li><strong>周期任务复用</strong>：通过runAndReset()避免创建新对象，提高内存效率</li>
<li><strong>追赶机制</strong>：fixed-rate模式下，如果执行时间超过period，会在任务完成后立即执行下一次（不会并发），以追赶理论时间轴</li>
<li><strong>序列号排序</strong>：相同deadline的任务通过sequenceNumber保证FIFO顺序</li>
</ul>
<h2 id="delayedworkqueue-的数据结构选择">DelayedWorkQueue 的数据结构选择</h2>
<p>DelayedWorkQueue使用<strong>二叉堆（最小堆）</strong> 来实现延迟队列，而不是使用跳表或其他数据结构。</p>
<p><strong>为什么选择二叉堆？</strong></p>
<ol>
<li>
<p><strong>时间复杂度优势</strong>：</p>
<ul>
<li>入队（offer）：O(log n)</li>
<li>出队（take）：O(log n)</li>
<li>查看队首（peek）：O(1)</li>
</ul>
</li>
<li>
<p><strong>内存效率</strong>：基于数组实现，无需额外的指针开销</p>
</li>
<li>
<p><strong>适合单线程访问</strong>：DelayedWorkQueue 内部使用 ReentrantLock 保护，保证单线程访问，无需考虑并发访问的数据结构选择</p>
</li>
</ol>
<p><strong>二叉堆 vs Redis ZSET（跳表）的对比</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>二叉堆（Java DelayedWorkQueue）</th>
<th>跳表（Redis ZSET）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>数据结构</strong></td>
<td>数组实现的完全二叉树</td>
<td>多层链表 + 跳跃指针</td>
</tr>
<tr>
<td><strong>时间复杂度</strong></td>
<td>插入/删除 O(log n)，查找最小 O(1)</td>
<td>插入/删除/查找 O(log n)</td>
</tr>
<tr>
<td><strong>范围查询</strong></td>
<td>不支持（需 O(n log n) 排序）</td>
<td>支持（O(log n) 定位 + O(k) 遍历）</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>低（数组连续存储）</td>
<td>较高（多层链表指针）</td>
</tr>
<tr>
<td><strong>并发模型</strong></td>
<td>单线程 + 锁保护</td>
<td>单线程事件循环</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>单机延迟队列，只需获取最早任务</td>
<td>分布式排序集合，需要范围查询</td>
</tr>
</tbody>
</table>
<p><strong>为什么 Redis ZSET 不使用二叉堆？</strong></p>
<ol>
<li>
<p><strong>范围查询需求</strong>：Redis ZSET 需要支持 <code>ZRANGE</code>、<code>ZRANGEBYSCORE</code> 等范围查询操作，二叉堆无法高效支持（需要 O(n) 时间），而跳表天然支持 O(log n) 的范围查询</p>
</li>
<li>
<p><strong>有序遍历</strong>：Redis 需要按分数顺序遍历元素，跳表的中序遍历即可实现，而二叉堆需要额外的排序操作</p>
</li>
</ol>
<p><strong>为什么 Java DelayedWorkQueue 选择二叉堆而非跳表？</strong></p>
<p>核心原因是<strong>操作模式匹配</strong>：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>ScheduledThreadPoolExecutor</th>
<th>Redis ZSET</th>
</tr>
</thead>
<tbody>
<tr>
<td>入队</td>
<td>单个任务入队</td>
<td>单个元素入队</td>
</tr>
<tr>
<td>出队</td>
<td>取出最早到期的一个任务</td>
<td>取出范围/按分数查询</td>
</tr>
<tr>
<td>典型查询</td>
<td>“有没有任务到期了？”</td>
<td>“取出分数 100-200 的所有元素”</td>
</tr>
</tbody>
</table>
<p>二叉堆的 O(1) 查看堆顶精确匹配 Java 的场景：每次只需知道最早一个任务是否到期。跳表的范围查询能力在此场景无用武之地。</p>
<p>内存开销是次要因素：跳表的多层指针确实增加内存，但如果场景需要范围查询，Java 也不会因内存而放弃跳表。关键在于 Java 的延迟队列<strong>根本不需要</strong>范围查询。</p>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>Java DelayedWorkQueue</strong>：单机场景，只需获取最早任务，二叉堆是最佳选择（O(1) 查找最小值）</li>
<li><strong>Redis ZSET</strong>：分布式场景，需要范围查询和有序遍历，跳表是最佳选择（O(log n) 范围查询）</li>
</ul>
<h2 id="任务调度的完整流程">任务调度的完整流程</h2>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client as 客户端代码
    participant Service as ScheduledThreadPoolExecutor
    participant Queue as DelayedWorkQueue
    participant Task as ScheduledFutureTask
    participant Worker as Worker线程
    
    Client-&gt;&gt;Service: scheduleAtFixedRate(task, 0, 1, SECONDS)
    Service-&gt;&gt;Task: 创建ScheduledFutureTask实例
    Service-&gt;&gt;Queue: offer(task)入队
    Queue-&gt;&gt;Queue: 堆调整，维护时间顺序
    
    loop 任务执行循环
        Worker-&gt;&gt;Queue: take()获取到期任务
        Queue--&gt;&gt;Worker: 返回到期的ScheduledFutureTask
        Worker-&gt;&gt;Task: 执行run()方法
        
        alt 周期任务
            Worker-&gt;&gt;Task: runAndReset()执行并重置
            Task-&gt;&gt;Task: setNextRunTime()计算下次时间
            Task-&gt;&gt;Queue: reExecutePeriodic()重新入队
            Queue-&gt;&gt;Queue: 堆调整
        else 一次性任务
            Worker-&gt;&gt;Task: run()正常执行完成
            Task-&gt;&gt;Task: 设置完成状态
        end
    end</code></pre>
<h2 id="内存管理和性能优化">内存管理和性能优化</h2>
<p><strong>对象复用机制</strong>：</p>
<ul>
<li>周期任务复用同一个ScheduledFutureTask对象</li>
<li>避免频繁的对象创建和垃圾回收开销</li>
<li>通过runAndReset()方法重置任务状态而非创建新实例</li>
</ul>
<p><strong>时间精度处理</strong>：</p>
<ul>
<li>内部使用System.nanoTime()而非System.currentTimeMillis()</li>
<li>避免系统时钟调整对调度精度的影响</li>
<li>纳秒级精度确保高频调度的准确性</li>
</ul>
<p><strong>队列优化 - Leader-Follower 模式</strong>：</p>
<ul>
<li>基于堆的优先队列实现 O(log n) 的插入和删除</li>
<li>Leader-Follower 模式减少不必要的线程唤醒</li>
<li>支持快速的队首元素访问和批量操作</li>
</ul>
<p><strong>Leader-Follower 模式辨析</strong>：</p>
<p>DelayedWorkQueue 中的 Leader-Follower 是一种<strong>线程等待优化模式</strong>，与 Raft 等分布式一致性协议中的 Leader 概念完全不同：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>DelayedWorkQueue Leader-Follower</th>
<th>Raft Leader</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>领域</strong></td>
<td>单机并发编程</td>
<td>分布式一致性</td>
</tr>
<tr>
<td><strong>Leader 角色</strong></td>
<td>等待线程中的&quot;定时等待者&quot;</td>
<td>日志复制协调者</td>
</tr>
<tr>
<td><strong>Leader 选举</strong></td>
<td>自动轮换，先到先得</td>
<td>投票选举，多数派确认</td>
</tr>
<tr>
<td><strong>核心目的</strong></td>
<td>避免多线程同时定时等待的唤醒风暴</td>
<td>保证日志一致性</td>
</tr>
<tr>
<td><strong>角色数量</strong></td>
<td>任意时刻最多 1 个 leader</td>
<td>任意时刻最多 1 个 leader</td>
</tr>
</tbody>
</table>
<p><strong>DelayedWorkQueue 的 Leader-Follower 工作原理</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// DelayedWorkQueue.take() 的 Leader-Follower 逻辑</span><br><span class="hljs-keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>) &#123;<br>                available.await();  <span class="hljs-comment">// 无任务，无限等待</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> finishPoll(first);  <span class="hljs-comment">// 任务已到期，直接返回</span><br>                <br>                <span class="hljs-comment">// Leader-Follower 核心逻辑</span><br>                <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>) &#123;<br>                    available.await();  <span class="hljs-comment">// 已有 leader，当前线程作为 follower 无限等待</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                    leader = thisThread;  <span class="hljs-comment">// 当前线程成为 leader</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        available.awaitNanos(delay);  <span class="hljs-comment">// leader 定时等待到任务到期</span><br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-keyword">if</span> (leader == thisThread)<br>                            leader = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// leader 退出时清空</span><br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>)<br>            available.signal();  <span class="hljs-comment">// 唤醒一个 follower 成为新 leader</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么需要 Leader-Follower？</strong></p>
<p>假设没有此模式，10 个线程同时调用 <code>take()</code> 等待 5 秒后的任务：</p>
<ul>
<li>所有 10 个线程都调用 <code>awaitNanos(5s)</code></li>
<li>5 秒后，所有 10 个线程同时被唤醒</li>
<li>但只有 1 个线程能获取任务，其余 9 个线程空转</li>
<li>这就是&quot;惊群效应&quot;或&quot;唤醒风暴&quot;</li>
</ul>
<p>有了 Leader-Follower：</p>
<ul>
<li>只有 1 个 leader 线程定时等待</li>
<li>其余 9 个 follower 线程无限等待</li>
<li>任务到期后 leader 取走任务，唤醒 1 个 follower 成为新 leader</li>
<li>始终只有 1 个线程被唤醒，避免唤醒风暴</li>
</ul>
<p>这套实现既保证了定时任务调度的精确性，又通过巧妙的设计优化了内存使用和并发性能，体现了Doug Lea在并发编程方面的深厚功底。</p>
<blockquote>
<p><strong>三种线程池的队列对比</strong>：ScheduledThreadPoolExecutor 的 DelayedWorkQueue 与 ThreadPoolExecutor 的 BlockingQueue、ForkJoinPool 的 WorkQueue 有本质差异，详见 <a href="#%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84-workqueue-%E5%AF%B9%E6%AF%94">三种线程池的 WorkQueue 对比</a> 章节。</p>
<p><strong>三种线程池的 execute 对比</strong>：三者对 <code>execute(Runnable)</code> 的实现也有本质差异，详见 <a href="#%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84-execute-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%AF%94">三种线程池的 execute() 实现对比</a> 章节。</p>
</blockquote>
<h2 id="scheduledexecutorservice-与-abstractexecutorservice-的关系辨析">ScheduledExecutorService 与 AbstractExecutorService 的关系辨析</h2>
<h3 id="关键问题：api-之间是否也是-abstractexecutorservice-的调用关系？">关键问题：API 之间是否也是 AbstractExecutorService 的调用关系？</h3>
<p><strong>答案：submit/invokeAll/invokeAny 仍遵循 AbstractExecutorService，但 schedule 系列方法是独立实现。</strong></p>
<h4 id="api-分类">API 分类</h4>
<p>ScheduledExecutorService 的 API 可以分为两类：</p>
<table>
<thead>
<tr>
<th>API 类别</th>
<th>方法</th>
<th>是否遵循 AbstractExecutorService</th>
<th>实现路径</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>标准 API</strong></td>
<td><code>submit(Runnable)</code></td>
<td>是</td>
<td><code>submit()</code> → <code>newTaskFor()</code> → <code>execute()</code> → <code>DelayedWorkQueue</code></td>
</tr>
<tr>
<td><strong>标准 API</strong></td>
<td><code>submit(Callable)</code></td>
<td>是</td>
<td><code>submit()</code> → <code>newTaskFor()</code> → <code>execute()</code> → <code>DelayedWorkQueue</code></td>
</tr>
<tr>
<td><strong>标准 API</strong></td>
<td><code>invokeAll()</code></td>
<td>是</td>
<td><code>invokeAll()</code> → <code>newTaskFor()</code> × N → <code>execute()</code> × N</td>
</tr>
<tr>
<td><strong>标准 API</strong></td>
<td><code>invokeAny()</code></td>
<td>是</td>
<td><code>invokeAny()</code> → <code>newTaskFor()</code> × N → <code>execute()</code> × N</td>
</tr>
<tr>
<td><strong>定时 API</strong></td>
<td><code>schedule(Runnable)</code></td>
<td>否</td>
<td><code>schedule()</code> → <code>new ScheduledFutureTask()</code> → <code>DelayedWorkQueue</code></td>
</tr>
<tr>
<td><strong>定时 API</strong></td>
<td><code>schedule(Callable)</code></td>
<td>否</td>
<td><code>schedule()</code> → <code>new ScheduledFutureTask()</code> → <code>DelayedWorkQueue</code></td>
</tr>
<tr>
<td><strong>定时 API</strong></td>
<td><code>scheduleAtFixedRate()</code></td>
<td>否</td>
<td><code>scheduleAtFixedRate()</code> → <code>new ScheduledFutureTask()</code> → <code>DelayedWorkQueue</code></td>
</tr>
<tr>
<td><strong>定时 API</strong></td>
<td><code>scheduleWithFixedDelay()</code></td>
<td>否</td>
<td><code>scheduleWithFixedDelay()</code> → <code>new ScheduledFutureTask()</code> → <code>DelayedWorkQueue</code></td>
</tr>
</tbody>
</table>
<h4 id="实现对比">实现对比</h4>
<p><strong>标准 API（遵循 AbstractExecutorService）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractExecutorService 的默认实现</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);  <span class="hljs-comment">// 创建 FutureTask</span><br>    execute(ftask);  <span class="hljs-comment">// 调用 execute()</span><br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">// ScheduledThreadPoolExecutor.execute() 的实现</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    schedule(command, <span class="hljs-number">0</span>, NANOSECONDS);  <span class="hljs-comment">// 转换为 schedule(0)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计意图</strong>：<code>execute()</code> 的实现本质是<strong>语义转换</strong>——将&quot;立即执行&quot;转换为&quot;延迟为0的调度&quot;。这是API兼容性设计：<code>ScheduledThreadPoolExecutor</code> 继承自 <code>ThreadPoolExecutor</code>，必须实现 <code>execute()</code> 接口，但内部确保所有任务都走统一的调度路径（<code>DelayedWorkQueue</code>）。</p>
<p><strong>与传统 ThreadPoolExecutor.execute() 的区别</strong>：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>ThreadPoolExecutor</th>
<th>ScheduledThreadPoolExecutor</th>
</tr>
</thead>
<tbody>
<tr>
<td>语义</td>
<td>立即执行任务</td>
<td>延迟为0的调度任务</td>
</tr>
<tr>
<td>入队</td>
<td>直接入队</td>
<td>通过 <code>schedule()</code> → <code>delayedExecute()</code></td>
</tr>
<tr>
<td>任务包装</td>
<td>可选</td>
<td>强制包装为 <code>ScheduledFutureTask</code></td>
</tr>
<tr>
<td>队列</td>
<td>用户指定</td>
<td>强制 <code>DelayedWorkQueue</code></td>
</tr>
<tr>
<td>时间字段</td>
<td>无</td>
<td><code>time = now() + 0</code></td>
</tr>
</tbody>
</table>
<p><strong>定时 API（独立实现）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ScheduledThreadPoolExecutor 的独立实现</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">// 创建 ScheduledFutureTask，triggerTime 计算 deadline = now() + delay</span><br>    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>,<br>                                      triggerTime(delay, unit)));<br>    delayedExecute(t);  <span class="hljs-comment">// 直接提交到 DelayedWorkQueue</span><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 延迟任务入队的核心方法。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 【两次 isShutdown 检查的原因】</span><br><span class="hljs-comment"> * 这是典型的 TOCTOU（Time-Of-Check to Time-Of-Use）竞态处理：</span><br><span class="hljs-comment"> * - 第一次检查：快速路径，避免已关闭线程池的无意义入队</span><br><span class="hljs-comment"> * - 第二次检查：在 add(task) 期间，其他线程可能调用了 shutdown()，</span><br><span class="hljs-comment"> *             需要重新检查并决定是取消任务还是继续执行</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 【为什么不在 ensurePrestart 之后检查？】</span><br><span class="hljs-comment"> * - ensurePrestart() 会启动工作线程，若线程池已关闭则不应启动</span><br><span class="hljs-comment"> * - 若任务已被取消（因关闭策略），启动线程执行它是无意义的</span><br><span class="hljs-comment"> * - 将检查前置，避免不必要的线程创建和资源浪费</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (isShutdown())<br>        reject(task);  <span class="hljs-comment">// 第一次检查：快速拒绝</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.getQueue().add(task);  <span class="hljs-comment">// 入队到 DelayedWorkQueue</span><br>        <span class="hljs-comment">// 第二次检查：处理入队期间发生的关闭</span><br>        <span class="hljs-comment">// canRunInCurrentRunState 检查关闭策略配置：</span><br>        <span class="hljs-comment">// - 周期任务：continueExistingPeriodicTasksAfterShutdown</span><br>        <span class="hljs-comment">// - 非周期任务：executeExistingDelayedTasksAfterShutdown</span><br>        <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp;<br>            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;<br>            remove(task))  <span class="hljs-comment">// 尝试从队列移除</span><br>            task.cancel(<span class="hljs-literal">false</span>);  <span class="hljs-comment">// 移除成功则取消任务</span><br>        <span class="hljs-keyword">else</span><br>            ensurePrestart();  <span class="hljs-comment">// 确保至少有一个工作线程运行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="对比图示">对比图示</h4>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;标准 API（遵循 AbstractExecutorService）&quot;
        A1[submit Runnable] --&gt; B1[newTaskFor]
        B1 --&gt; C1[FutureTask]
        C1 --&gt; D1[execute]
        D1 --&gt; E1[schedule0]
        E1 --&gt; F1[DelayedWorkQueue]
        
        A2[submit Callable] --&gt; B2[newTaskFor]
        B2 --&gt; C2[FutureTask]
        C2 --&gt; D1
        
        A3[invokeAll] --&gt; B3[newTaskFor xN]
        B3 --&gt; C3[FutureTask xN]
        C3 --&gt; D3[execute xN]
        D3 --&gt; E3[schedule0 xN]
        E3 --&gt; F3[DelayedWorkQueue]
    end
    
    subgraph &quot;定时 API（独立实现）&quot;
        A4[schedule Runnable] --&gt; B4[new ScheduledFutureTask]
        B4 --&gt; C4[delayedExecute]
        C4 --&gt; D4[DelayedWorkQueue]
        
        A5[schedule Callable] --&gt; B5[new ScheduledFutureTask]
        B5 --&gt; C5[delayedExecute]
        C5 --&gt; D4
        
        A6[scheduleAtFixedRate] --&gt; B6[new ScheduledFutureTask periodic]
        B6 --&gt; C6[delayedExecute]
        C6 --&gt; D4
        
        A7[scheduleWithFixedDelay] --&gt; B7[new ScheduledFutureTask periodic]
        B7 --&gt; C7[delayedExecute]
        C7 --&gt; D4
    end
    
    style B4 fill:#FFD700
    style B5 fill:#FFD700
    style B6 fill:#FFD700
    style B7 fill:#FFD700
    style C4 fill:#FFD700
    style C5 fill:#FFD700
    style C6 fill:#FFD700
    style C7 fill:#FFD700</code></pre>
<h4 id="关键结论">关键结论</h4>
<ol>
<li>
<p><strong>标准 API</strong>：<code>submit()</code>、<code>invokeAll()</code>、<code>invokeAny()</code> 仍然遵循 AbstractExecutorService 的契约</p>
<ul>
<li>通过 <code>newTaskFor()</code> 创建 FutureTask</li>
<li>调用 <code>execute()</code>，最终转换为 <code>schedule(0)</code></li>
</ul>
</li>
<li>
<p><strong>定时 API</strong>：<code>schedule()</code> 系列方法是独立实现</p>
<ul>
<li>直接创建 ScheduledFutureTask（而非 FutureTask）</li>
<li>调用 <code>delayedExecute()</code>，直接提交到 DelayedWorkQueue</li>
<li>不经过 <code>execute()</code> 路径</li>
</ul>
</li>
<li>
<p><strong>任务类型差异</strong>：</p>
<ul>
<li>FutureTask：普通任务，执行一次即完成</li>
<li>ScheduledFutureTask：定时任务，支持延迟执行和周期执行，继承自 FutureTask</li>
</ul>
</li>
<li>
<p><strong>队列差异</strong>：</p>
<ul>
<li>标准 API：通过 <code>schedule(0)</code> 间接使用 DelayedWorkQueue</li>
<li>定时 API：直接使用 DelayedWorkQueue，支持基于时间的优先级排序</li>
</ul>
</li>
</ol>
<p>这个设计体现了 ScheduledExecutorService 的<strong>双重性质</strong>：既要兼容 ExecutorService 标准接口，又要为定时任务提供专门的实现。</p>
<h2 id="scheduledexecutorservice-核心机制详解">ScheduledExecutorService 核心机制详解</h2>
<h3 id="future-get-的语义差异：一次性任务-vs-周期任务">Future.get() 的语义差异：一次性任务 vs 周期任务</h3>
<p>根据 <code>ScheduledFuture</code> 的规范，<code>Future.get()</code> 方法在一次性任务和周期任务中的行为截然不同：</p>
<p><strong>一次性任务</strong>：</p>
<ul>
<li><code>get()</code> 会阻塞直到任务执行完成</li>
<li>可以正常获取任务执行结果或捕获异常</li>
<li>任务完成后立即返回，这是预期行为</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFuture&lt;String&gt; future = executor.schedule(() -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;task completed&quot;</span>;<br>&#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(); <span class="hljs-comment">// 阻塞直到任务完成，正常返回 &quot;task completed&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>周期任务</strong>：</p>
<ul>
<li><code>get()</code> 基本不会&quot;正常返回&quot;，因为周期任务的设计语义是&quot;无限期执行&quot;</li>
<li>只在以下两种情况返回：
<ol>
<li>任务被取消（<code>cancel()</code> 被调用）</li>
<li>任务执行过程中抛出未捕获的异常</li>
</ol>
</li>
<li>调用 <code>get()</code> 会导致调用线程永久阻塞（直到上述情况发生）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFuture&lt;?&gt; future = executor.scheduleAtFixedRate(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;tick&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// future.get(); // 永久阻塞！不要这样做</span><br></code></pre></td></tr></table></figure>
<p><strong>为什么这样设计？</strong><br>
这是有意为之的设计，强制用户通过 <code>cancel()</code> 来主动终止周期任务。周期任务没有自然的&quot;完成&quot;状态，因此 <code>get()</code> 无法判断何时应该返回。</p>
<h3 id="串行化铁律：单一任务串行-不同任务并行">串行化铁律：单一任务串行，不同任务并行</h3>
<p>根据 <code>ScheduledThreadPoolExecutor</code> 的源码实现，存在一个重要的&quot;串行化铁律&quot;：</p>
<p><strong>单一周期任务的串行化</strong>：</p>
<ul>
<li>同一个 <code>ScheduledFutureTask</code> 对象在 <code>run()</code> 方法完成后才会计算下次触发时间并重新入队</li>
<li>因此同一个周期任务实例不可能并发执行</li>
<li>这个铁律适用于 <code>scheduleAtFixedRate</code> 和 <code>scheduleWithFixedDelay</code> 两种模式</li>
</ul>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Worker as Worker线程
    participant Queue as DelayedWorkQueue
    participant Task as ScheduledFutureTask
    
    Note over Worker,Task: 周期任务的串行化执行
    Worker-&gt;&gt;Queue: take()
    Queue--&gt;&gt;Worker: 返回到期任务
    Worker-&gt;&gt;Task: 执行 run()
    Note over Worker: 执行任务逻辑
    Worker-&gt;&gt;Task: run() 完成
    Task-&gt;&gt;Task: setNextRunTime()
    Task-&gt;&gt;Queue: 重新入队（同一对象）
    
    Note over Worker,Task: 下一次执行
    Worker-&gt;&gt;Queue: take()
    Queue--&gt;&gt;Worker: 再次返回同一任务
    Worker-&gt;&gt;Task: 执行 run()</code></pre>
<p><strong>不同任务的并行化</strong>：</p>
<ul>
<li>多个独立的任务（即使执行相同的 Runnable）可以并行执行</li>
<li>只要线程池有足够线程，不同任务可以同时运行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任务1和任务2是不同的 ScheduledFutureTask 实例，可以并行执行</span><br>ScheduledFuture&lt;?&gt; future1 = executor.scheduleAtFixedRate(taskA, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>ScheduledFuture&lt;?&gt; future2 = executor.scheduleAtFixedRate(taskA, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// 但 future1 内部的执行是串行的，不会并发</span><br></code></pre></td></tr></table></figure>
<p><strong>设计原因</strong>：<br>
周期任务复用同一个 <code>ScheduledFutureTask</code> 对象，在执行期间不会创建新的任务对象入队，这天然保证了单一任务的串行化。</p>
<h3 id="漂移-drift-：线程池过小导致的执行延迟">漂移（Drift）：线程池过小导致的执行延迟</h3>
<p><strong>漂移的定义</strong>：<br>
漂移是指任务的实际执行时间偏离了理论调度时间。当线程池过小或任务执行时间过长时：</p>
<ul>
<li>到期的任务从 <code>DelayedWorkQueue</code> 中取出后，可能因为线程池繁忙而需要等待</li>
<li>即使任务已经&quot;到期&quot;，也无法立即执行，只能等待可用线程</li>
<li>这导致执行时间晚于理论时间，产生&quot;漂移&quot;效应</li>
</ul>
<pre><code class="hljs mermaid">gantt
    title 漂移效应示意图（period=1s，执行时间=1.5s）
    dateFormat X
    axisFormat %s
    
    section 理论时间轴
    执行1 : 0, 1
    执行2 : 1, 2
    执行3 : 2, 3
    
    section 实际执行（线程池过小）
    等待队列 : 0, 0.5
    执行1 : 0.5, 2
    等待队列 : 2, 2.5
    执行2 : 2.5, 4
    等待队列 : 4, 4.5
    执行3 : 4.5, 6</code></pre>
<p><strong>漂移的影响</strong>：</p>
<ul>
<li><strong>scheduleAtFixedRate</strong>：漂移会触发追赶机制，在短时间内执行更密集</li>
<li><strong>scheduleWithFixedDelay</strong>：漂移会延迟整个时间轴，不会追赶，表现为节奏变慢</li>
</ul>
<p><strong>避免漂移的建议</strong>：</p>
<ul>
<li>合理设置线程池大小，避免线程不足</li>
<li>控制任务执行时间，避免长时间阻塞</li>
<li>监控任务执行延迟，及时调整配置</li>
</ul>
<h3 id="api-参数语义：delay-vs-period">API 参数语义：delay vs period</h3>
<p><strong>统一的时间参数模式</strong>：<br>
所有 <code>ScheduledExecutorService</code> 的方法都采用 <code>(long time, TimeUnit unit)</code> 的参数模式，这是 JUC 的统一设计风格。</p>
<p><strong>delay 的语义</strong>：</p>
<ul>
<li>表示&quot;延迟多久后首次执行&quot;</li>
<li>只影响第一次执行</li>
<li>是一次性的时间偏移</li>
</ul>
<p><strong>period 的语义</strong>：</p>
<ul>
<li>表示&quot;周期性执行的间隔&quot;</li>
<li>决定后续执行的节奏</li>
<li>计算方式在不同 API 中有差异：</li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>period 计算</th>
<th>是否追赶</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>scheduleAtFixedRate</code></td>
<td><code>上次理论触发时间 + period</code></td>
<td>是</td>
<td>采样、心跳、metrics 上报</td>
</tr>
<tr>
<td><code>scheduleWithFixedDelay</code></td>
<td><code>上次实际结束时间 + period</code></td>
<td>否</td>
<td>拉取消息、轮询、清理任务</td>
</tr>
</tbody>
</table>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// delay=2s, period=1s</span><br><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br><span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;Task executed&quot;</span>);<br>executor.scheduleAtFixedRate(task, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><span class="hljs-comment">// 首次执行：延迟2秒后执行</span><br><span class="hljs-comment">// 后续执行：每隔1秒执行一次（基于理论时间轴）</span><br><br>executor.scheduleWithFixedDelay(task, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><span class="hljs-comment">// 首次执行：延迟2秒后执行</span><br><span class="hljs-comment">// 后续执行：上次执行结束后，再等待1秒执行（基于实际结束时间）</span><br></code></pre></td></tr></table></figure>
<h3 id="周期任务异常终止的深度解析">周期任务异常终止的深度解析</h3>
<h4 id="根本原因：任务对象不再重新入队">根本原因：任务对象不再重新入队</h4>
<p><strong>普通 ThreadPoolExecutor 的异常处理机制</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;());<br><br>executor.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Task execution failed&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>执行流程:</p>
<ol>
<li>Worker 线程执行任务,任务抛出未捕获异常</li>
<li>Worker 线程在 <code>Worker.run()</code> 的 finally 块中捕获异常</li>
<li>Worker 线程继续存活,从队列取下一个任务</li>
<li>若 Worker 线程数 &lt; corePoolSize,线程池补充新线程</li>
</ol>
<p><strong>周期任务的异常处理机制</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">4</span>);<br><br>executor.scheduleAtFixedRate(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Task execution failed&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>
<p>执行流程:</p>
<ol>
<li>Worker 线程执行 <code>ScheduledFutureTask.run()</code></li>
<li><code>ScheduledFutureTask.run()</code> 调用 <code>FutureTask.runAndReset()</code></li>
<li><code>runAndReset()</code> 捕获异常,设置异常状态,返回 <code>false</code></li>
<li><code>ScheduledFutureTask.run()</code> 检查返回值,仅当返回 <code>true</code> 时重新入队</li>
<li><code>ScheduledFutureTask</code> 对象不再重新入队,后续调度终止</li>
</ol>
<p><strong>核心源码分析</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FutureTask.runAndReset() (JDK 8 源码)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runAndReset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// CAS 抢占 runner：多个线程可能同时调用 run()，CAS 保证只有一个成功</span><br>    <span class="hljs-comment">// 比较 runnerOffset 位置的值是否为 null，是则设为当前线程</span><br>    <span class="hljs-keyword">if</span> (state != NEW ||<br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                     <span class="hljs-literal">null</span>, Thread.currentThread()))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ran</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Callable&lt;V&gt; c = callable;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; s == NEW) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                c.call(); <span class="hljs-comment">// don&#x27;t set result</span><br>                ran = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                setException(ex);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// runner must be non-null until state is settled to</span><br>        <span class="hljs-comment">// prevent concurrent calls to run()</span><br>        <span class="hljs-comment">// finally 中直接赋值：此时任务已执行完，当前线程是唯一持有 runner 的线程，无竞争</span><br>        runner = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// state must be re-read after nulling runner to prevent</span><br>        <span class="hljs-comment">// leaked interrupts</span><br>        s = state;<br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>            handlePossibleCancellationInterrupt(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ran &amp;&amp; s == NEW;<br>&#125;<br><br><span class="hljs-comment">// ScheduledFutureTask.run() (JDK 8 源码)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();                      <span class="hljs-comment">// 判断是否周期任务</span><br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))               <span class="hljs-comment">// 线程池状态检查</span><br>        cancel(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)                                   <span class="hljs-comment">// 一次性任务：调用父类 run()</span><br>        ScheduledFutureTask.<span class="hljs-built_in">super</span>.run();                  <span class="hljs-comment">//    正常执行并设置结果</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset()) &#123;   <span class="hljs-comment">// 周期任务：执行并重置状态</span><br>        setNextRunTime();                                 <span class="hljs-comment">//    计算下次执行时间</span><br>        reExecutePeriodic(outerTask);                     <span class="hljs-comment">//    重新入队同一任务对象</span><br>    &#125;                                                     <span class="hljs-comment">// 若 runAndReset() 返回 false（异常），不重新入队</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么 CAS 设置 runner，finally 中直接赋值？</strong></p>
<p><code>runner</code> 字段的两种操作场景：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>场景</th>
<th>并发风险</th>
<th>实现方式</th>
</tr>
</thead>
<tbody>
<tr>
<td>设置 runner</td>
<td>任务开始前，多线程可能同时调用 run()</td>
<td>多个线程竞争执行同一任务</td>
<td>CAS 原子操作</td>
</tr>
<tr>
<td>清空 runner</td>
<td>任务完成后，finally 块</td>
<td>当前线程独占，无竞争</td>
<td>直接赋值</td>
</tr>
</tbody>
</table>
<p>CAS 保证<strong>只有一个线程</strong>能成功设置 runner 并执行任务。finally 块中当前线程已持有 runner，不存在竞争，直接置 null 即可。</p>
<p><strong>深入理解：为什么 ThreadPoolExecutor 场景下仍需 CAS？</strong></p>
<p>从 ThreadPoolExecutor 的视角看，<code>getTask()</code> 从 BlockingQueue 取任务是独占的，不会有两个 Worker 拿到同一个 FutureTask。但 CAS 设置 runner 的必要性来自更广的场景：</p>
<ol>
<li><strong>FutureTask 是通用组件，不依赖 ThreadPoolExecutor 的队列语义</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; <span class="hljs-string">&quot;result&quot;</span>);<br><span class="hljs-comment">// 用户可以手动在多个线程中调用 run()</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task::run).start();<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task::run).start();  <span class="hljs-comment">// 第二次应被幂等拒绝</span><br></code></pre></td></tr></table></figure>
<ol start="2">
<li><strong>cancel(true) 与 run() 的竞争——这是核心场景</strong></li>
</ol>
<p><code>cancel(true)</code> 需要先 CAS 改状态再中断 runner，而 <code>run()</code> 需要先绑定 runner 再执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// cancel(true) 路径</span><br><span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, INTERRUPTING)) &#123;<br>    runner.interrupt();  <span class="hljs-comment">// 需要 runner 已被设置</span><br>&#125;<br><br><span class="hljs-comment">// run() 路径</span><br><span class="hljs-keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset, <span class="hljs-literal">null</span>, Thread.currentThread()))<br>    <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 若 cancel 已改状态，这里直接返回</span><br></code></pre></td></tr></table></figure>
<p>两者形成互斥：要么 <code>run()</code> 先 CAS 成功绑定 runner 再执行，要么 <code>cancel()</code> 先 CAS 改状态使 <code>run()</code> 的状态检查失败。</p>
<ol start="3">
<li><strong>runAndReset() 的重入场景</strong></li>
</ol>
<p>ScheduledThreadPoolExecutor 的周期任务会多次调用 <code>runAndReset()</code>，虽然是同一个 Worker，但每次执行仍需 CAS 来与潜在的 <code>cancel()</code> 竞争。</p>
<p>简言之：CAS runner 不是防多 Worker 竞争，而是防 <code>run()/runAndReset()</code> 与 <code>cancel()</code> 的并发竞争，同时保证 FutureTask 作为独立组件的幂等性。</p>
<p><strong>异常终止的根本原因</strong>：</p>
<p><code>runAndReset()</code> 仅在 <code>c.call()</code> 正常完成时返回 <code>true</code>。若抛出异常，<code>ran</code> 保持 <code>false</code>，最终返回 <code>false</code>，<code>ScheduledFutureTask.run()</code> 不会重新入队任务。</p>
<p>这解释了为什么周期任务中的未捕获异常会导致后续调度终止：任务对象不再入队。</p>
<p><strong>执行流程图</strong>:</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Worker as Worker线程
    participant Task as ScheduledFutureTask
    participant Queue as DelayedWorkQueue
    
    rect rgb(220, 255, 220)
    Note over Worker,Queue: 正常执行流程
    Worker-&gt;&gt;Task: run()
    Task-&gt;&gt;Task: runAndReset() 内部调用
    Task-&gt;&gt;Task: callable.call()
    Note right of Task: 返回 true
    Task-&gt;&gt;Task: setNextRunTime()
    Task-&gt;&gt;Queue: reExecutePeriodic() 重新入队
    Task--&gt;&gt;Worker: 完成
    Note over Queue: 等待下次执行
    end
    
    rect rgb(255, 220, 220)
    Note over Worker,Queue: 异常执行流程
    Worker-&gt;&gt;Task: run()
    Task-&gt;&gt;Task: runAndReset() 内部调用
    Task-&gt;&gt;Task: callable.call() 抛出异常
    Task-&gt;&gt;Task: setException(e)
    Note right of Task: 返回 false
    Task--&gt;&gt;Worker: 完成
    Note over Queue: 任务不再重新入队,后续调度终止
    end</code></pre>
<p><strong>异常处理机制对比</strong>:</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>普通任务</th>
<th>周期任务</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>任务类型</strong></td>
<td>每次是新 Runnable 对象</td>
<td>同一个 ScheduledFutureTask 对象重复执行</td>
</tr>
<tr>
<td><strong>异常处理位置</strong></td>
<td>Worker.run() 的 finally 块</td>
<td>FutureTask.runAndReset()</td>
</tr>
<tr>
<td><strong>异常后的行为</strong></td>
<td>Worker 线程继续,取下一个任务</td>
<td>任务对象不再重新入队</td>
</tr>
<tr>
<td><strong>线程池补充</strong></td>
<td>补充新线程(如需要)</td>
<td>Worker 线程正常,但任务不再调度</td>
</tr>
<tr>
<td><strong>后续任务影响</strong></td>
<td>不受影响(不同任务)</td>
<td><strong>同一任务的后继执行全部终止</strong></td>
</tr>
</tbody>
</table>
<p><strong>设计原理</strong>:</p>
<p>该行为属于有意为之的设计决策,基于以下考量:</p>
<ol>
<li><strong>语义明确性</strong>: 周期任务抛出异常表明任务逻辑存在问题，继续执行可能导致资源泄漏或数据不一致</li>
<li><strong>错误可见性</strong>: 若自动重试，异常将被静默吞掉，开发者难以发现潜在问题</li>
<li><strong>符合 Javadoc 规范</strong>: <code>scheduleAtFixedRate</code> 的 javadoc 明确说明 <em>“If any execution of the task encounters an exception, subsequent executions are suppressed”</em></li>
<li><strong>显式异常处理</strong>: 强制用户明确决定异常处理策略(重试、忽略、告警等)</li>
</ol>
<h4 id="其他分布式系统的异常处理策略">其他分布式系统的异常处理策略</h4>
<p>不同的分布式调度系统有不同的设计理念:</p>
<p><strong>Spring @Scheduled</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scheduled(fixedRate = 1000)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">scheduledTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 如果这里抛异常,后续执行会终止</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Oops!&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>默认行为</strong>: 与 JUC 一致,异常后终止调度</li>
<li><strong>最佳实践</strong>: 必须捕获异常</li>
</ul>
<p><strong>Quartz Scheduler</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyJob</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Job</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(JobExecutionContext context)</span> &#123;<br>        <span class="hljs-comment">// 异常后,Job 会标记为 FAILED</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Oops!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>默认行为</strong>: 异常后任务标记为 FAILED,但<strong>仍然会继续调度</strong>(默认)</li>
<li><strong>配置选项</strong>: 可以配置 <code>@DisallowConcurrentExecution</code> 等策略</li>
<li><strong>重试机制</strong>: 支持配置重试次数和间隔</li>
</ul>
<p><strong>XXL-Job</strong>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@XxlJob(&quot;demoJobHandler&quot;)</span><br><span class="hljs-keyword">public</span> ReturnT&lt;String&gt; <span class="hljs-title function_">demoJobHandler</span><span class="hljs-params">(String param)</span> &#123;<br>    <span class="hljs-comment">// 返回 FAIL 会导致任务失败,但仍然会继续调度</span><br>    <span class="hljs-keyword">return</span> ReturnT.FAIL;<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>默认行为</strong>: 异常后任务标记为失败,但<strong>仍然会继续调度</strong></li>
<li><strong>失败重试</strong>: 支持配置重试次数</li>
<li><strong>告警机制</strong>: 失败后会触发告警</li>
</ul>
<p><strong>Celery (Python)</strong>:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">@app.task(<span class="hljs-params">bind=<span class="hljs-literal">True</span>, max_retries=<span class="hljs-number">3</span></span>)</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">my_task</span>(<span class="hljs-params">self</span>):<br>    <span class="hljs-keyword">try</span>:<br>        <span class="hljs-comment"># 任务逻辑</span><br>        <span class="hljs-keyword">pass</span><br>    <span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> exc:<br>        <span class="hljs-comment"># 自动重试</span><br>        <span class="hljs-keyword">raise</span> <span class="hljs-variable language_">self</span>.retry(exc=exc, countdown=<span class="hljs-number">60</span>)<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>默认行为</strong>: 异常后任务失败,但<strong>仍然会继续调度</strong></li>
<li><strong>自动重试</strong>: 支持配置重试策略</li>
<li><strong>任务状态</strong>: 区分 PENDING、STARTED、SUCCESS、FAILURE、RETRY 等</li>
</ul>
<p><strong>对比总结</strong>:</p>
<table>
<thead>
<tr>
<th>系统</th>
<th>异常后行为</th>
<th>重试机制</th>
<th>设计理念</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>JUC ScheduledExecutorService</strong></td>
<td>终止调度</td>
<td>无</td>
<td>失败即停止,让用户显式处理</td>
</tr>
<tr>
<td><strong>Spring @Scheduled</strong></td>
<td>终止调度</td>
<td>无</td>
<td>遵循 JUC 规范</td>
</tr>
<tr>
<td><strong>Quartz</strong></td>
<td>继续调度</td>
<td>可配置</td>
<td>企业级,容错性强</td>
</tr>
<tr>
<td><strong>XXL-Job</strong></td>
<td>继续调度</td>
<td>可配置</td>
<td>分布式,高可用</td>
</tr>
<tr>
<td><strong>Celery</strong></td>
<td>继续调度</td>
<td>可配置</td>
<td>云原生,弹性伸缩</td>
</tr>
</tbody>
</table>
<p><strong>为什么 JUC 选择&quot;失败即停止&quot;?</strong></p>
<ol>
<li><strong>简洁性</strong>: 不引入复杂的重试逻辑</li>
<li><strong>可预测性</strong>: 行为明确,不会因为重试导致问题扩散</li>
<li><strong>灵活性</strong>: 用户可以自己实现重试逻辑</li>
<li><strong>符合 Unix 哲学</strong>: “提供机制而非策略”</li>
</ol>
<h4 id="分布式任务调度系统的设计思路对比">分布式任务调度系统的设计思路对比</h4>
<p>前文提到,JUC 的周期任务采用&quot;任务重复入队&quot;的设计思路,异常时打断入队会导致调度终止。但并非所有分布式任务调度系统都采用这种设计。不同系统的核心差异在于:<strong>任务调度的触发机制</strong>和<strong>任务状态的持久化方式</strong>。</p>
<h5 id="两种核心设计思路">两种核心设计思路</h5>
<p><strong>思路一:任务重复入队(自驱动模式)</strong></p>
<p>代表系统:JUC ScheduledExecutorService、Spring @Scheduled</p>
<ul>
<li><strong>设计原理</strong>:任务对象自身负责计算下次执行时间并重新入队</li>
<li><strong>触发机制</strong>:基于内存队列的延迟调度</li>
<li><strong>状态管理</strong>:任务状态存储在内存中,进程重启后丢失</li>
<li><strong>异常处理</strong>:异常时任务对象不再入队,调度终止</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JUC 的设计:任务对象自己管理重新入队</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (isPeriodic()) &#123;<br>        <span class="hljs-keyword">if</span> (runAndReset()) &#123;  <span class="hljs-comment">// 正常完成才重新入队</span><br>            setNextRunTime();<br>            reExecutePeriodic(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// 重新入队</span><br>        &#125;<br>        <span class="hljs-comment">// 异常时不重新入队,调度终止</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>思路二:调度中心驱动(中心化模式)</strong></p>
<p>代表系统:阿里 SchedulerX、美团 Crane、XXL-JOB、Quartz</p>
<ul>
<li><strong>设计原理</strong>:独立的调度中心负责任务触发,执行器仅负责执行</li>
<li><strong>触发机制</strong>:基于数据库/注册中心的定时触发</li>
<li><strong>状态管理</strong>:任务状态持久化到数据库,进程重启后可恢复</li>
<li><strong>异常处理</strong>:异常不影响调度中心下次触发,任务状态独立管理</li>
</ul>
<pre><code class="hljs mermaid">flowchart LR
    SC[调度中心&lt;br/&gt;Scheduler] --&gt;|触发| EX[执行器 A&lt;br/&gt;Executor]
    DB[数据库&lt;br/&gt;持久化] --&gt;|读取状态| EX
    EX --&gt;|更新状态| DB
    SC --&gt;|下次触发&lt;br/&gt;仍会执行| EX
    EX --&gt;|失败不影响| SC</code></pre>
<h5 id="阿里-schedulerx-的设计">阿里 SchedulerX 的设计</h5>
<p><strong>核心特性</strong>:</p>
<ol>
<li><strong>中心化调度架构</strong>:调度中心独立部署,负责任务触发和状态管理</li>
<li><strong>失败自动重试</strong>:支持实例级别和子任务级别的失败重试</li>
<li><strong>分布式执行</strong>:支持分片任务,多个执行器并行处理</li>
<li><strong>状态持久化</strong>:任务执行状态存储在数据库中</li>
</ol>
<p><strong>异常处理流程</strong>:</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant SC as 调度中心
    participant DB as 数据库
    participant EX as 执行器
    
    SC-&gt;&gt;DB: 查询待执行任务
    SC-&gt;&gt;EX: 触发任务执行
    EX-&gt;&gt;EX: 执行任务逻辑
    EX-&gt;&gt;DB: 更新执行状态
    
    alt 执行成功
        DB-&gt;&gt;SC: 标记为 SUCCESS
    else 执行失败
        DB-&gt;&gt;SC: 标记为 FAILED
        SC-&gt;&gt;SC: 检查重试策略
        alt 未达到重试上限
            SC-&gt;&gt;DB: 计算下次重试时间
            SC-&gt;&gt;EX: 重新触发任务
        else 达到重试上限
            DB-&gt;&gt;SC: 标记为最终失败
            SC-&gt;&gt;SC: 触发告警
        end
    end
    
    Note over SC,DB: 下次调度时间到达时,不论上次成功或失败,都会重新触发</code></pre>
<p><strong>关键点</strong>:</p>
<ul>
<li>调度中心根据 Cron 表达式或固定间隔计算下次触发时间</li>
<li>任务执行失败不影响调度中心的触发逻辑</li>
<li>支持配置重试次数和重试间隔</li>
<li>任务状态独立于调度触发</li>
</ul>
<h5 id="美团-crane-的设计">美团 Crane 的设计</h5>
<p><strong>核心特性</strong>:</p>
<ol>
<li><strong>分布式调度</strong>:基于 ZooKeeper 的分布式协调</li>
<li><strong>故障转移</strong>:执行器宕机时,任务自动转移到其他节点</li>
<li><strong>任务分片</strong>:支持大任务分片并行处理</li>
<li><strong>监控告警</strong>:集成 CAT 监控系统</li>
</ol>
<p><strong>异常处理流程</strong>:</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant ZK as ZooKeeper
    participant SC as 调度节点
    participant EX as 执行器
    participant DB as 数据库
    
    SC-&gt;&gt;ZK: 注册任务调度
    ZK-&gt;&gt;EX: 选举主执行器
    EX-&gt;&gt;EX: 执行任务
    EX-&gt;&gt;DB: 记录执行日志
    
    alt 执行成功
        DB-&gt;&gt;ZK: 更新任务状态为 SUCCESS
    else 执行失败
        DB-&gt;&gt;ZK: 更新任务状态为 FAILED
        ZK-&gt;&gt;ZK: 检查重试策略
        alt 支持重试
            ZK-&gt;&gt;EX: 重新分配任务
        else 不支持重试
            ZK-&gt;&gt;SC: 触发告警
        end
    end
    
    Note over ZK: 下次调度时间到达时,仍然会触发任务</code></pre>
<p><strong>关键点</strong>:</p>
<ul>
<li>基于 ZooKeeper 实现分布式协调和故障转移</li>
<li>任务调度和执行状态持久化到数据库</li>
<li>执行器宕机不影响调度,任务会自动转移到其他节点</li>
<li>支持任务分片和并行执行</li>
</ul>
<h5 id="两种设计思路的优缺点对比">两种设计思路的优缺点对比</h5>
<table>
<thead>
<tr>
<th>维度</th>
<th>任务重复入队(自驱动)</th>
<th>调度中心驱动(中心化)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>架构复杂度</strong></td>
<td>简单,单进程内完成</td>
<td>复杂,需要独立的调度中心</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>异常即终止,需手动重启</td>
<td>异常不影响调度,自动重试</td>
</tr>
<tr>
<td><strong>状态持久化</strong></td>
<td>无,进程重启丢失</td>
<td>有,数据库持久化</td>
</tr>
<tr>
<td><strong>分布式能力</strong></td>
<td>无,单机调度</td>
<td>有,支持分布式执行</td>
</tr>
<tr>
<td><strong>故障恢复</strong></td>
<td>无,进程崩溃任务丢失</td>
<td>有,任务可恢复和转移</td>
</tr>
<tr>
<td><strong>监控告警</strong></td>
<td>需自行实现</td>
<td>内置监控告警</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单定时任务,单机应用</td>
<td>企业级应用,分布式系统</td>
</tr>
<tr>
<td><strong>资源消耗</strong></td>
<td>低,仅内存队列</td>
<td>高,需要数据库和调度中心</td>
</tr>
<tr>
<td><strong>实时性</strong></td>
<td>高,内存队列延迟低</td>
<td>中,依赖数据库查询</td>
</tr>
<tr>
<td><strong>扩展性</strong></td>
<td>差,单机限制</td>
<td>好,可水平扩展</td>
</tr>
</tbody>
</table>
<h5 id="为什么-juc-采用任务重复入队设计">为什么 JUC 采用任务重复入队设计?</h5>
<p>JUC 的设计目标与分布式调度系统完全不同:</p>
<ol>
<li><strong>定位</strong>:本地进程内的轻量级调度,而非分布式调度</li>
<li><strong>性能</strong>:基于内存队列,避免数据库开销</li>
<li><strong>简单性</strong>:保持 API 简洁,不引入外部依赖</li>
<li><strong>可控性</strong>:异常终止让用户显式处理,避免隐式重试掩盖问题</li>
</ol>
<p><strong>典型适用场景</strong>:</p>
<ul>
<li>定期清理缓存</li>
<li>定期刷新配置</li>
<li>定期上报指标</li>
<li>定期检查状态</li>
</ul>
<p>这些场景的特点是:</p>
<ul>
<li>任务逻辑简单,失败即终止</li>
<li>不需要分布式执行</li>
<li>不需要持久化状态</li>
<li>需要高性能和低延迟</li>
</ul>
<p><strong>不适用场景</strong>:</p>
<ul>
<li>需要跨进程调度</li>
<li>需要任务持久化</li>
<li>需要自动故障恢复</li>
<li>需要分布式执行</li>
</ul>
<p>对于这些场景,应该使用分布式任务调度系统(如 SchedulerX、XXL-JOB 等)。</p>
<h5 id="设计模式总结">设计模式总结</h5>
<p>[PATTERN] <strong>自驱动 vs 中心驱动模式</strong></p>
<p><strong>自驱动模式</strong>:</p>
<ul>
<li><strong>定义</strong>:任务对象自身负责调度逻辑</li>
<li><strong>优点</strong>:简单、高效、低延迟</li>
<li><strong>缺点</strong>:无持久化、无故障恢复、不支持分布式</li>
<li><strong>适用</strong>:单机轻量级调度</li>
</ul>
<p><strong>中心驱动模式</strong>:</p>
<ul>
<li><strong>定义</strong>:独立的调度中心负责任务触发</li>
<li><strong>优点</strong>:持久化、故障恢复、分布式支持</li>
<li><strong>缺点</strong>:复杂度高、资源消耗大、延迟较高</li>
<li><strong>适用</strong>:企业级分布式调度</li>
</ul>
<p><strong>选择原则</strong>:</p>
<ul>
<li>单机简单场景 → 自驱动模式(JUC ScheduledExecutorService)</li>
<li>分布式复杂场景 → 中心驱动模式(SchedulerX、XXL-JOB)</li>
</ul>
<p><strong>如何实现自动重试?</strong></p>
<p>如需实现类似 Quartz 的行为，可自行封装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResilientScheduledExecutor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService executor;<br>    <br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithRetry(Runnable task, <span class="hljs-type">long</span> delay, <span class="hljs-type">long</span> period, TimeUnit unit) &#123;<br>        <span class="hljs-keyword">return</span> executor.scheduleAtFixedRate(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                task.run();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                <span class="hljs-comment">// 记录异常,但不影响后续调度</span><br>                logger.error(<span class="hljs-string">&quot;Task failed but will retry&quot;</span>, t);<br>            &#125;<br>        &#125;, delay, period, unit);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>铁律</strong>：周期任务必须捕获所有异常并记录，否则会出现“定时任务一段时间后不再执行”的现象。</p>
<h3 id="cancel-true-vs-cancel-false-的差异">cancel(true) vs cancel(false) 的差异</h3>
<p><code>Future.cancel(boolean mayInterruptIfRunning)</code> 的语义：一个 Future 对应一个任务，参数决定对该任务如何处理。</p>
<table>
<thead>
<tr>
<th>任务状态</th>
<th>cancel(false)</th>
<th>cancel(true)</th>
</tr>
</thead>
<tbody>
<tr>
<td>尚未开始</td>
<td>取消成功，不执行</td>
<td>取消成功，不执行</td>
</tr>
<tr>
<td>正在执行</td>
<td>不中断，让任务完成</td>
<td>调用 <code>Thread.interrupt()</code> 尝试中断</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 优雅取消：不中断正在执行的任务</span><br>future.cancel(<span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 强制取消：尝试中断正在执行的任务</span><br>future.cancel(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>
<p><strong>关键洞察</strong>：<code>mayInterruptIfRunning</code> 参数仅在任务<strong>正在执行</strong>时产生差异。任务未开始时，两参数效果相同；任务执行后，只有 <code>cancel(true)</code> 会额外设置中断标志。</p>
<p><strong>重要注意</strong>：</p>
<ul>
<li>中断只是设置中断标志，任务代码必须检查 <code>Thread.interrupted()</code> 或使用可中断方法才能真正终止</li>
<li>阻塞 IO、<code>synchronized</code> 锁等不一定响应中断</li>
<li>对于不可中断阻塞，需要使用底层超时机制（HTTP timeout、JDBC timeout 等）</li>
</ul>
<h4 id="setremoveoncancelpolicy-true-的重要性">setRemoveOnCancelPolicy(true) 的重要性</h4>
<p><strong>默认行为</strong>：</p>
<ul>
<li><code>cancel()</code> 只标记任务为&quot;已取消&quot;</li>
<li>任务对象仍留在 <code>DelayedWorkQueue</code> 中</li>
<li>直到到期取出时才发现已取消并跳过</li>
</ul>
<p><strong>问题场景</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每个请求都 schedule 一个超时任务</span><br><span class="hljs-keyword">for</span> (Request req : requests) &#123;<br>    ScheduledFuture&lt;?&gt; timeout = executor.schedule(() -&gt; &#123;<br>        handleTimeout(req);<br>    &#125;, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>    <br>    req.addTimeoutFuture(timeout);<br>&#125;<br><br><span class="hljs-comment">// 请求完成后取消</span><br>timeout.cancel(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 默认不移除，队列堆满已取消任务</span><br></code></pre></td></tr></table></figure>
<p><strong>开启移除策略</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">4</span>);<br>executor.setRemoveOnCancelPolicy(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 强烈建议开启</span><br></code></pre></td></tr></table></figure>
<p><strong>效果</strong>：</p>
<ul>
<li><code>cancel()</code> 时立即从队列移除任务</li>
<li>减少队列扫描开销和内存占用</li>
<li><strong>强烈推荐</strong>用于&quot;每个请求都 schedule 超时任务&quot;的场景</li>
</ul>
<h4 id="周期任务复用对象与串行化的设计原理">周期任务复用对象与串行化的设计原理</h4>
<p><strong>核心设计</strong>：<br>
周期任务不是每次都新建对象，而是复用同一个 <code>ScheduledFutureTask</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ScheduledFutureTask.runPeriodic() 的核心逻辑</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runPeriodic</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset();<br>    <span class="hljs-keyword">if</span> (ok) &#123;<br>        setNextRunTime();  <span class="hljs-comment">// 计算下次触发时间</span><br>        reExecutePeriodic(outerTask);  <span class="hljs-comment">// 重新入队同一个对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Worker as Worker线程
    participant Queue as DelayedWorkQueue
    participant Task as ScheduledFutureTask
    
    rect rgb(200, 220, 240)
        Note over Worker,Task: 第一次执行
        Worker-&gt;&gt;Queue: take() 取出任务
        Queue--&gt;&gt;Worker: 返回任务
        Worker-&gt;&gt;Task: 执行 run()
        Note over Worker: 执行任务逻辑
        Worker-&gt;&gt;Task: run() 完成
        Task-&gt;&gt;Task: setNextRunTime()
        Task-&gt;&gt;Queue: reExecutePeriodic(同一对象)
    end
    
    rect rgb(220, 200, 240)
        Note over Worker,Task: 第二次执行
        Worker-&gt;&gt;Queue: take() 取出同一任务
        Queue--&gt;&gt;Worker: 返回任务
        Worker-&gt;&gt;Task: 执行 run()
        Note over Worker: 执行任务逻辑
        Worker-&gt;&gt;Task: run() 完成
        Task-&gt;&gt;Task: setNextRunTime()
        Task-&gt;&gt;Queue: reExecutePeriodic(同一对象)
    end</code></pre>
<p><strong>设计原因</strong>：</p>
<ul>
<li><strong>内存效率</strong>：避免为每次执行创建新对象</li>
<li><strong>串行化保证</strong>：因为复用同一个对象，且只有在当前执行完成后才重新入队，所以不会存在&quot;同一个任务的多个实例同时待执行&quot;</li>
<li><strong>追赶机制</strong>：追赶逻辑在 <code>setNextRunTime()</code> 中根据时间戳计算，即使追赶多次，也是串行重新入队</li>
</ul>
<p><strong>这就是串行追赶的本质设计原因</strong>。</p>
<h3 id="time-字段的可复用设计">time 字段的可复用设计</h3>
<p><strong>DelayedWorkQueue 的核心机制</strong>：<br>
<code>DelayedWorkQueue</code> 基于 <code>Delayed</code> 接口的 <code>getDelay()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Delayed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Delayed&gt; &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>ScheduledFutureTask 的 time 字段</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;  <span class="hljs-comment">// 纳秒级 deadline</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>        <span class="hljs-keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br>        <span class="hljs-keyword">if</span> (other == <span class="hljs-built_in">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> ScheduledFutureTask) &#123;<br>            ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.time - x.time;<br>            <span class="hljs-keyword">return</span> diff &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : diff &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS);<br>        <span class="hljs-keyword">return</span> diff &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : diff &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>经典的可复用设计</strong>：</p>
<ul>
<li><code>time</code> 字段用于堆排序（<code>compareTo</code> 基于 <code>time</code>）</li>
<li><code>time</code> 字段用于判断是否到期（<code>getDelay()</code> 计算剩余时间）</li>
<li><strong>可复用</strong>：周期任务重新入队时，只需更新 <code>time</code> 字段，无需新建对象</li>
</ul>
<p>这是一个经典的时间轮/延迟队列设计模式，高效且内存友好。</p>
<h3 id="理论时间轴-vs-当下时间起点：rate-vs-delay-的根本差异">理论时间轴 vs 当下时间起点：Rate vs Delay 的根本差异</h3>
<p><strong>scheduleAtFixedRate（固定频率）</strong>：</p>
<ul>
<li>基于理论时间轴：<code>startTime + n * period</code></li>
<li>下次触发时间 = <code>上次理论触发时间 + period</code></li>
<li>如果执行延迟，会追赶：<code>nextTime = max(now, theoreticalTime)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> period;<br>    <span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)<br>        time += p;  <span class="hljs-comment">// 累加 period，基于理论时间轴</span><br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">gantt
    title scheduleAtFixedRate：理论时间轴（period=1s）
    dateFormat X
    axisFormat %s
    
    section 理论时间轴
    触发1 : 0, 1
    触发2 : 1, 2
    触发3 : 2, 3
    触发4 : 3, 4
    
    section 实际执行（执行慢）
    执行1 : 0, 1.5
    追赶 : 1.5, 2
    执行2 : 2, 3
    执行3 : 3, 4
    执行4 : 4, 5</code></pre>
<p><strong>scheduleWithFixedDelay（固定延迟）</strong>：</p>
<ul>
<li>基于当下时间起点：<code>endTime + period</code></li>
<li>下次触发时间 = <code>上次实际结束时间 + period</code></li>
<li>不会追赶：执行越慢，整个时间轴越往后推</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;<br>    time = now() + (-period);  <span class="hljs-comment">// 重新计算，基于当前时间</span><br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">gantt
    title scheduleWithFixedDelay：当下时间起点（delay=1s）
    dateFormat X
    axisFormat %s
    
    section 执行时间轴
    执行1 : 0, 1.5
    等待1s : 1.5, 2.5
    执行2 : 2.5, 3.5
    等待1s : 3.5, 4.5
    执行3 : 4.5, 6
    等待1s : 6, 7</code></pre>
<p><strong>核心差异</strong>：</p>
<ul>
<li><strong>Rate</strong>：基于理论时间轴，产生追赶效应</li>
<li><strong>Delay</strong>：基于当下时间起点，不产生追赶效应</li>
</ul>
<p>这就是两套 API 产生追赶或者不追赶的根本原因。</p>
<h3 id="工程级最佳实践">工程级最佳实践</h3>
<p><strong>周期任务的三条铁律</strong>：</p>
<ol>
<li>永远捕获 Throwable，避免任务因为异常而静默停止</li>
<li>永远加超时（IO/锁等待/远程调用）</li>
<li>永远可取消 + 可观测（日志/metrics/最后成功时间）</li>
</ol>
<p><strong>不要完全替代 cron</strong>：<br>
如需实现“每天 02:00”（墙上时钟语义、时区/DST/补偿错过的执行）等调度需求，<code>ScheduledExecutorService</code> 能力不足，更适合使用：</p>
<ul>
<li>Quartz</li>
<li>Spring <code>@Scheduled(cron=...)</code>（底层常用线程池，但语义更偏 cron）</li>
</ul>
<p><code>ScheduledExecutor</code> 更擅长：</p>
<ul>
<li>“从现在开始每隔 5 秒”</li>
<li>“延迟 200ms 后做一次”</li>
<li>“固定节拍采样/心跳”</li>
</ul>
<p><strong>任务隔离</strong>：<br>
不同性质任务分不同 scheduler：</p>
<ul>
<li>一个专门跑心跳/采样（轻量）</li>
<li>一个专门跑清理/同步（可能重 IO）<br>
否则重任务会把轻任务拖延，造成级联误判（比如心跳延迟导致误判下游故障）。</li>
</ul>
<p><strong>生产级配置示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生产级ScheduledExecutor配置示例</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 关键特性：</span><br><span class="hljs-comment"> * 1. 周期任务异常捕获</span><br><span class="hljs-comment"> * 2. 任务执行指标记录</span><br><span class="hljs-comment"> * 3. 优雅关闭机制</span><br><span class="hljs-comment"> * 4. 取消策略配置</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> magicliang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2026-01-24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SchedulerDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SchedulerDemo.class);<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledThreadPoolExecutor exec;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">successCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">failureCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ScheduledFuture&lt;?&gt; future;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SchedulerDemo</span><span class="hljs-params">()</span> &#123;<br>        exec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">2</span>, r -&gt; &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>            t.setName(<span class="hljs-string">&quot;biz-scheduler-&quot;</span> + t.getId());<br>            t.setDaemon(<span class="hljs-literal">false</span>);<br>            t.setUncaughtExceptionHandler((thread, throwable) -&gt; &#123;<br>                logger.error(<span class="hljs-string">&quot;Uncaught exception in thread: &#123;&#125;&quot;</span>, thread.getName(), throwable);<br>            &#125;);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;);<br><br>        <span class="hljs-comment">// 关键配置：取消时立即从队列移除</span><br>        exec.setRemoveOnCancelPolicy(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 关键配置：shutdown后不再执行延迟任务</span><br>        exec.setExecuteExistingDelayedTasksAfterShutdownPolicy(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 关键配置：shutdown后不再执行周期任务</span><br>        exec.setContinueExistingPeriodicTasksAfterShutdownPolicy(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        future = exec.scheduleWithFixedDelay(() -&gt; &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行实际任务（带超时控制）</span><br>                doWorkWithTimeout();<br>                successCount.incrementAndGet();<br>                recordSuccess();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                <span class="hljs-comment">// 必须捕获Throwable，防止周期任务静默停止</span><br>                failureCount.incrementAndGet();<br>                recordFailure(t);<br>                logger.error(<span class="hljs-string">&quot;Scheduled task failed, count: &#123;&#125;&quot;</span>, failureCount.get(), t);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">costMs</span> <span class="hljs-operator">=</span> (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span>;<br>                recordLatency(costMs);<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (future != <span class="hljs-literal">null</span>) &#123;<br>            future.cancel(<span class="hljs-literal">false</span>);<br>        &#125;<br>        exec.shutdown();<br>        <span class="hljs-keyword">if</span> (!exec.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS)) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Scheduler did not terminate in time, forcing shutdown&quot;</span>);<br>            exec.shutdownNow();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 模拟方法（实际项目中应替换为真实实现）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWorkWithTimeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 实际业务逻辑</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordSuccess</span><span class="hljs-params">()</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;Task succeeded, total success: &#123;&#125;&quot;</span>, successCount.get());<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>        logger.error(<span class="hljs-string">&quot;Task failed, total failures: &#123;&#125;&quot;</span>, failureCount.get());<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordLatency</span><span class="hljs-params">(<span class="hljs-type">long</span> costMs)</span> &#123;<br>        logger.debug(<span class="hljs-string">&quot;Task latency: &#123;&#125;ms&quot;</span>, costMs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<h1>ForkJoinPool详解：分治并行的执行引擎</h1>
<p><img src="java-thread-x-forkjoin-%E5%8F%AA%E5%8F%91%E7%94%9F%E5%9C%A8%E5%90%8C%E5%B1%82%E4%B9%8B%E9%97%B4.png" alt="java-thread-x-forkjoin-只发生在同层之间.png"></p>
<h2 id="前言：分治并行的诞生">前言：分治并行的诞生</h2>
<p>ForkJoinPool 不是为了通用&quot;并行&quot;而设计，而是专门为<strong>分治并行</strong>（Divide-and-Conquer Parallelism）这一特定模式量身定制。分治算法（如快速排序、归并排序、树遍历）具有独特的执行模式：</p>
<ul>
<li>任务天然形成树状结构</li>
<li>父任务派生子任务后需要等待结果</li>
<li>子任务之间通常无依赖关系</li>
<li>计算密集，无I/O阻塞</li>
</ul>
<p>理解分治算法的执行特性，是理解 ForkJoinPool 设计的关键。传统线程池在处理这类任务时遇到根本性挑战，ForkJoinPool 正是为解决这些挑战而诞生。</p>
<h2 id="核心数据结构：forkjoinpool的基石">核心数据结构：ForkJoinPool的基石</h2>
<h3 id="forkjoinpool：去中心化的调度器">ForkJoinPool：去中心化的调度器</h3>
<h4 id="数据结构定义">数据结构定义</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-comment">// 64位控制状态：编码活跃线程数、空闲线程数、任务计数</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> ctl;<br>    <br>    <span class="hljs-comment">// 工作队列数组：每个工作线程一个队列</span><br>    <span class="hljs-keyword">volatile</span> WorkQueue[] workQueues; <span class="hljs-comment">// 与TPE的关键区别：TPE用HashSet&lt;Worker&gt;直接持有线程引用，</span><br>                                     <span class="hljs-comment">// 而FJP通过WorkQueue数组间接管理线程——每个WorkQueue关联一个ForkJoinWorkerThread，</span><br>                                     <span class="hljs-comment">// 线程状态通过ctl字段的位操作管理，任务调度通过workQueues数组实现</span><br>    <br>    <span class="hljs-comment">// 专用线程工厂</span><br>    <span class="hljs-keyword">final</span> ForkJoinWorkerThreadFactory factory;<br>    <br>    <span class="hljs-comment">// 未捕获异常处理器</span><br>    <span class="hljs-keyword">final</span> UncaughtExceptionHandler ueh;<br>    <br>    <span class="hljs-comment">// 配置参数</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> config; <span class="hljs-comment">// 低16位：并行度（parallelism）</span><br>    <br>    <span class="hljs-comment">// 静态公共池</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ForkJoinPool <span class="hljs-title function_">commonPool</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="与threadpoolexecutor的本质区别">与ThreadPoolExecutor的本质区别</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadPoolExecutor的核心结构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue; <span class="hljs-comment">// 单一共享队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers;          <span class="hljs-comment">// 持有所有工作线程引用，用于遍历查找特定状态线程（如中断空闲线程）及统计监控</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;               <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;            <span class="hljs-comment">// 最大线程数</span><br>&#125;<br><br><span class="hljs-comment">// ForkJoinPool的核心结构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-keyword">volatile</span> WorkQueue[] workQueues;                <span class="hljs-comment">// 工作队列数组，每个 ForkjoinWokerThread 持有一个 workQueue，这个池就持有一个 workQueue 数组</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> ctl;                              <span class="hljs-comment">// 64位状态控制</span><br>    <span class="hljs-comment">// 无corePoolSize/maximumPoolSize概念</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="关键差异">关键差异</h4>
<ul>
<li><strong>队列模型</strong>：TPE使用单一共享队列，FJP使用每个线程私有队列</li>
<li><strong>线程管理</strong>：TPE有明确的core/max参数，FJP只有目标并行度</li>
<li><strong>调度策略</strong>：TPE基于生产者-消费者模型，FJP基于工作窃取模型</li>
</ul>
<h3 id="forkjoinworkerthreadfactory：专用线程工厂">ForkJoinWorkerThreadFactory：专用线程工厂</h3>
<h4 id="接口定义与对比">接口定义与对比</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 标准ThreadFactory接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建新线程</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r 线程要执行的Runnable</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 新线程</span><br><span class="hljs-comment">     */</span><br>    Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span>;<br>&#125;<br><br><span class="hljs-comment">// ForkJoinWorkerThreadFactory接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ForkJoinWorkerThreadFactory</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建新的ForkJoinWorkerThread</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pool 线程所属的ForkJoinPool</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 新的工作线程</span><br><span class="hljs-comment">     */</span><br>    ForkJoinWorkerThread <span class="hljs-title function_">newThread</span><span class="hljs-params">(ForkJoinPool pool)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="关键区别">关键区别</h4>
<ul>
<li>完全不同的接口：两者没有继承关系，签名完全不同</li>
<li>上下文差异：标准工厂只接收Runnable，即任务，负责包装出线程；FJP工厂接收 ForkJoinPool 即线程池。</li>
<li>线程定制能力：线程工厂通常可以设置：
<ul>
<li>线程名称（便于调试）</li>
<li>线程优先级（Thread.setPriority()）</li>
<li>守护状态（Thread.setDaemon()）</li>
<li>上下文类加载器（Thread.setContextClassLoader()）</li>
<li>异常处理器（Thread.setUncaughtExceptionHandler()）</li>
<li>为什么在工厂里创建，传统工厂使用这个接口把任务包装成进程，并且启动：<code>thread.start(); // 一旦 start()，大部分属性就无法修改了</code></li>
</ul>
</li>
</ul>
<h5 id="fjp-的扩展方法">FJP 的扩展方法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinPool;<br><span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinWorkerThread;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomForkJoinWorkerThreadFactory</span> <br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ForkJoinPool</span>.ForkJoinWorkerThreadFactory &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String poolName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> threadPriority;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader contextClassLoader;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomForkJoinWorkerThreadFactory</span><span class="hljs-params">(</span><br><span class="hljs-params">        String poolName, </span><br><span class="hljs-params">        <span class="hljs-type">int</span> threadPriority,</span><br><span class="hljs-params">        ClassLoader contextClassLoader</span><br><span class="hljs-params">    )</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolName = poolName;<br>        <span class="hljs-built_in">this</span>.threadPriority = threadPriority;<br>        <span class="hljs-built_in">this</span>.contextClassLoader = contextClassLoader;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ForkJoinWorkerThread <span class="hljs-title function_">newThread</span><span class="hljs-params">(ForkJoinPool pool)</span> &#123;<br>        <span class="hljs-comment">// 1. 使用默认工厂创建基础线程</span><br>        <span class="hljs-type">ForkJoinWorkerThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);<br>        <br>        <span class="hljs-comment">// 2. 自定义线程名称（便于调试）</span><br>        thread.setName(String.format(<span class="hljs-string">&quot;%s-worker-%d&quot;</span>, poolName, threadNumber.getAndIncrement()));<br>        <br>        <span class="hljs-comment">// 3. 设置线程优先级</span><br>        thread.setPriority(threadPriority);<br>        <br>        <span class="hljs-comment">// 4. 设置上下文类加载器</span><br>        thread.setContextClassLoader(contextClassLoader);<br>        <br>        <span class="hljs-comment">// 5. 设置未捕获异常处理器（线程级别的）</span><br>        thread.setUncaughtExceptionHandler((t, e) -&gt; &#123;<br>            System.err.printf(<span class="hljs-string">&quot;[%s] 线程 %s 发生未捕获异常: %s%n&quot;</span>, <br>                poolName, t.getName(), e.getMessage());<br>            e.printStackTrace();<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 6. 其他自定义设置</span><br>        thread.setDaemon(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 虽然ForkJoinPool会强制设置，但这里显式设置</span><br>        <br>        System.out.printf(<span class="hljs-string">&quot;创建工作线程: %s, 优先级: %d, 类加载器: %s%n&quot;</span>,<br>            thread.getName(), thread.getPriority(), contextClassLoader.getClass().getSimpleName());<br>        <br>        <span class="hljs-keyword">return</span> thread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="设计意义">设计意义</h4>
<blockquote>
<p>FJP的工作线程需要知道池的存在，才能参与工作窃取算法。标准ThreadFactory无法提供这种上下文，因此需要专用接口。</p>
</blockquote>
<h3 id="forkjoinworkerthread：协作式执行者">ForkJoinWorkerThread：协作式执行者</h3>
<h4 id="数据结构">数据结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinWorkerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">// 所属线程池</span><br>    <span class="hljs-keyword">final</span> ForkJoinPool pool;<br>    <br>    <span class="hljs-comment">// 专属工作队列（由池在registerWorker时分配，而非构造函数直接创建）</span><br>    <span class="hljs-keyword">final</span> WorkQueue workQueue;<br>    <br>    <span class="hljs-comment">// 构造函数（简化示意）</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">ForkJoinWorkerThread</span><span class="hljs-params">(ForkJoinPool pool)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pool = pool;<br>        <span class="hljs-comment">// 注意：WorkQueue 不是在这里直接 new 出来的</span><br>        <span class="hljs-comment">// 实际流程是调用 pool.registerWorker(this)，由池统一分配队列</span><br>        <span class="hljs-comment">// 这确保了 WorkQueue 在 workQueues 数组中的索引由池统一管理</span><br>        <span class="hljs-built_in">this</span>.workQueue = pool.registerWorker(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="与threadpoolexecutor-worker的对比">与ThreadPoolExecutor.Worker的对比</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadPoolExecutor.Worker（组合模式）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">final</span> Thread thread;       <span class="hljs-comment">// 通过组合持有Thread</span><br>    Runnable firstTask;        <span class="hljs-comment">// 初始任务。任务和执行线程解耦，是兄弟成员。这个成员只使用一次，就在 addWorker 的时候减少对拥塞队列的锁竞争</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks; <span class="hljs-comment">// 完成任务数</span><br>&#125;<br><br><span class="hljs-comment">// ForkJoinWorkerThread（继承模式）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinWorkerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">final</span> ForkJoinPool pool;   <span class="hljs-comment">// 直接持有池引用</span><br>    <span class="hljs-keyword">final</span> WorkQueue workQueue; <span class="hljs-comment">// 专属队列</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>Worker：“可以自锁定的 runnable，初始化是把自己装进 Thread 里，run 是在线程里自旋获取拥塞队列里的任务”。</li>
<li>ForkJoinWorkerThread：“具有自主窃取能力的协作线程，run 是在本地队列空闲时主动扫描并窃取其他工作队列任务的群体智能执行器”。</li>
</ol>
<h4 id="设计决策">设计决策</h4>
<ul>
<li><strong>Worker使用组合</strong>：TPE的工作线程只需执行任务，无需特殊行为</li>
<li><strong>FJP使用继承</strong>：需要重写run()实现工作窃取，且需要池上下文。继承意味着可以直接使用线程的生命周期方法。</li>
</ul>
<h4 id="线程安全特性：为什么forkjoinpool不会有线程泄露问题？">线程安全特性：为什么ForkJoinPool不会有线程泄露问题？</h4>
<p>ForkJoinPool 在线程管理上具有两个关键特性，使其天然避免了线程泄露问题：</p>
<p><strong>1. 所有工作线程都是 Daemon 线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinPool.registerWorker() 源码片段</span><br><span class="hljs-keyword">final</span> WorkQueue <span class="hljs-title function_">registerWorker</span><span class="hljs-params">(ForkJoinWorkerThread wt)</span> &#123;<br>    wt.setDaemon(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 强制设置为守护线程</span><br>    <span class="hljs-comment">// 正确</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这意味着：</p>
<ul>
<li>即使忘记调用 <code>shutdown()</code>，ForkJoinPool 的线程也<strong>不会阻止 JVM 退出</strong></li>
<li>当所有非 daemon 线程结束时，JVM 会自动终止，daemon 线程随之销毁</li>
<li>与 ThreadPoolExecutor 的关键区别：TPE 默认创建非 daemon 线程，忘记关闭会导致 JVM 无法退出</li>
</ul>
<p><strong>2. 空闲线程会被自动回收</strong></p>
<p>根据 Javadoc 文档：</p>
<blockquote>
<p>“Using the common pool normally reduces resource usage (its threads are slowly reclaimed during periods of non-use, and reinstated upon subsequent use).”</p>
</blockquote>
<p>ForkJoinPool 的线程回收机制：</p>
<ul>
<li>空闲线程不会立即销毁，而是先 <code>park()</code> 等待</li>
<li>空闲时间超过阈值后，线程主动退出 <code>run()</code> 循环</li>
<li>下次需要时重新创建，避免永久空闲线程占用资源</li>
</ul>
<p><strong>结论</strong>：由于 daemon 线程 + 自动回收机制的双重保障，ForkJoinPool 在实践中几乎不会出现线程泄露问题。但这<strong>不意味着可以忽略资源管理</strong>——对于自定义创建的 ForkJoinPool，仍建议使用 <code>try-with-resources</code>（JDK 19+）或 <code>try-finally</code> 显式关闭，以确保及时释放内部资源。</p>
<h3 id="workqueue：双端队列的实现">WorkQueue：双端队列的实现</h3>
<h4 id="数据结构">数据结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkQueue</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> base;          <span class="hljs-comment">// 队列头部索引（公开，供窃取）</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> top;           <span class="hljs-comment">// 队列尾部索引（虽主要由owner修改，但需volatile保证可见性）</span><br>    ForkJoinTask&lt;?&gt;[] array;    <span class="hljs-comment">// 任务数组（环形缓冲区）</span><br>    <span class="hljs-keyword">final</span> ForkJoinPool pool;    <span class="hljs-comment">// 所属池</span><br>    <span class="hljs-keyword">final</span> ForkJoinWorkerThread owner; <span class="hljs-comment">// 所属线程（外部提交队列的owner为null）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>术语定义</strong>：</p>
<ul>
<li>base = 队头（低索引端，存放最早入队的任务）</li>
<li>top = 队尾（高索引端，存放最新入队的任务）</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">数组布局：<br>base → <span class="hljs-selector-attr">[T1]</span> <span class="hljs-selector-attr">[T2]</span> <span class="hljs-selector-attr">[T3]</span> <span class="hljs-selector-attr">[T4]</span> <span class="hljs-selector-attr">[T5]</span> ← <span class="hljs-attribute">top</span><br>        ↑                       ↑<br>      队头                    队尾<br>    (最早任务)              (最新任务)<br></code></pre></td></tr></table></figure>
<h4 id="工作窃取-work-stealing-机制详解">工作窃取（Work-Stealing）机制详解</h4>
<p>工作窃取是 ForkJoinPool 的核心调度算法，通过让空闲线程主动从繁忙线程的队列中&quot;窃取&quot;任务，实现自动负载均衡。</p>
<p><strong>核心设计原则</strong>：</p>
<ol>
<li><strong>每个工作线程拥有独立的双端队列（Deque）</strong>：避免单一共享队列的竞争瓶颈</li>
<li><strong>窃取线程始终从队头（base）操作</strong>：无论 asyncMode 如何，窃取都是 FIFO</li>
<li><strong>本地线程的操作方向由 asyncMode 决定</strong>：
<ul>
<li>asyncMode=false（LIFO）：从队尾插入、队尾取出，与窃取者两端分离，无竞争</li>
<li>asyncMode=true（FIFO）：从队尾插入、队头取出，与窃取者同端竞争</li>
</ul>
</li>
<li><strong>竞争通过 CAS 快速失败处理</strong>：失败者继续扫描其他队列，不阻塞等待</li>
</ol>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;ForkJoinPool 工作窃取示意图&quot;
        direction TB
        
        subgraph &quot;Worker Thread 1 (繁忙)&quot;
            W1[Worker 1&lt;br/&gt;正在执行 Task A]
            W1Q[&quot;WorkQueue 1 (双端队列)&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;base → [T1][T2][T3][T4][T5] ← top&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&quot;]
            W1 -.-&gt;|&quot;push/pop&lt;br/&gt;(LIFO/FIFO)&quot;| W1Q
        end
        
        subgraph &quot;Worker Thread 2 (空闲)&quot;
            W2[Worker 2&lt;br/&gt;队列已空]
            W2Q[&quot;WorkQueue 2 (双端队列)&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;base → [ ] ← top&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;(空队列)&quot;]
            W2 -.-&gt;|&quot;尝试 pop&quot;| W2Q
        end
        
        subgraph &quot;Worker Thread 3 (繁忙)&quot;
            W3[Worker 3&lt;br/&gt;正在执行 Task B]
            W3Q[&quot;WorkQueue 3 (双端队列)&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;base → [T6][T7][T8] ← top&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&quot;]
            W3 -.-&gt;|&quot;push/pop&lt;br/&gt;(LIFO/FIFO)&quot;| W3Q
        end
        
        W2 ==&gt;|&quot;① 扫描其他队列&quot;| W1Q
        W2 ==&gt;|&quot;② 从 base 端窃取 T1&quot;| W1Q
        W1Q -.-&gt;|&quot;③ 窃取成功&lt;br/&gt;T1 移至 Worker 2&quot;| W2
        
        style W1 fill:#ffcdd2
        style W2 fill:#c8e6c9
        style W3 fill:#ffcdd2
        style W1Q fill:#fff3e0
        style W2Q fill:#e8f5e9
        style W3Q fill:#fff3e0
    end</code></pre>
<p><strong>工作窃取的执行流程</strong>：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> Worker 2 发现自己的队列为空<br><span class="hljs-bullet">   -</span> 进入扫描模式（scan phase）<br><br><span class="hljs-bullet">2.</span> 随机选择一个起始位置，遍历 workQueues 数组<br><span class="hljs-bullet">   -</span> 找到 Worker 1 的队列有任务<br><br><span class="hljs-bullet">3.</span> 尝试从 Worker 1 队列的 base 端窃取任务 T1<br><span class="hljs-bullet">   -</span> 使用 CAS 操作：compareAndSwapInt(base, base+1)<br><span class="hljs-bullet">   -</span> 成功：获得 T1，继续执行<br><span class="hljs-bullet">   -</span> 失败：继续扫描其他队列<br><br><span class="hljs-bullet">4.</span> Worker 2 执行窃取到的任务 T1<br><span class="hljs-bullet">   -</span> 如果 T1 又 fork 出子任务，放入 Worker 2 自己的队列<br><br><span class="hljs-bullet">5.</span> Worker 2 队列再次为空，重复步骤 1-4<br></code></pre></td></tr></table></figure>
<p><strong>关键技术细节</strong>：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>Owner 线程操作</th>
<th>Stealer 线程操作</th>
<th>竞争情况</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>LIFO</strong></td>
<td>队尾插入、队尾取出</td>
<td>队头取出</td>
<td>无竞争（两端分离）</td>
</tr>
<tr>
<td><strong>FIFO</strong></td>
<td>队尾插入、队头取出</td>
<td>队头取出</td>
<td>同端 CAS 竞争</td>
</tr>
</tbody>
</table>
<p><strong>竞争处理机制</strong>：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>机制</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无锁化</strong></td>
<td>volatile + CAS</td>
<td>避免重量级锁的开销</td>
</tr>
<tr>
<td><strong>快速失败</strong></td>
<td>CAS 失败返回 null</td>
<td>不阻塞、不重试、不等待</td>
</tr>
<tr>
<td><strong>转移扫描</strong></td>
<td>继续扫描其他队列</td>
<td>随机选择起始位置，避免多窃取者竞争同一队列</td>
</tr>
</tbody>
</table>
<p><strong>为什么工作窃取高效？</strong></p>
<ol>
<li><strong>LIFO 模式减少竞争</strong>：Owner 操作队尾，Stealer 操作队头，两端分离无竞争</li>
<li><strong>增强局部性</strong>：owner 线程优先处理自己最近产生的任务（LIFO 模式下），利用 CPU 缓存</li>
<li><strong>自动负载均衡</strong>：无需中央调度器，线程自主决定何时窃取，适应动态负载</li>
<li><strong>无锁化</strong>：使用 volatile + CAS，避免重量级锁的开销</li>
</ol>
<p><strong>与传统线程池的对比</strong>：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph TPE[ThreadPoolExecutor: 单一共享队列]
        Q1[BlockingQueue&lt;br/&gt;T1 T2 T3 T4 T5 T6]
        W1[Worker1] --&gt; Q1
        W2[Worker2] --&gt; Q1
        W3[Worker3] --&gt; Q1
        W4[Worker4] --&gt; Q1
        W5[Worker5] --&gt; Q1
        W6[Worker6] --&gt; Q1
    end
    
    subgraph FJP[ForkJoinPool: 每线程私有队列]
        Q2[Queue1&lt;br/&gt;T1 T2] --&gt; W7[Worker1]
        Q3[Queue2&lt;br/&gt;T3 T4] --&gt; W8[Worker2]
        Q4[Queue3&lt;br/&gt;T5 T6] --&gt; W9[Worker3]
        W7 -.-&gt;|窃取| Q3
        W8 -.-&gt;|窃取| Q4
    end</code></pre>
<p><strong>实际应用场景</strong>：</p>
<ul>
<li>正确 <strong>递归分解任务</strong>（如归并排序、快速排序）：子任务倾向于在同一线程执行，利用缓存局部性</li>
<li>正确 <strong>并行流处理</strong>（Java 8 Stream API）：<code>parallelStream()</code> 底层使用 ForkJoinPool.commonPool()</li>
<li>正确 <strong>CompletableFuture 异步编排</strong>：默认使用 ForkJoinPool.commonPool() 执行异步任务</li>
<li>错误 <strong>IO 密集型任务</strong>：工作窃取无法解决线程阻塞问题，应使用 ThreadPoolExecutor</li>
</ul>
<h4 id="核心操作">核心操作</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 本地push (LIFO)</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(ForkJoinTask&lt;?&gt; task)</span> &#123;<br>    ForkJoinTask&lt;?&gt;[] a = array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> top, cap = a.length;<br>    a[s &amp; (cap - <span class="hljs-number">1</span>)] = task;  <span class="hljs-comment">// 写入尾部</span><br>    top = s + <span class="hljs-number">1</span>;              <span class="hljs-comment">// 仅本线程修改，无锁</span><br>&#125;<br><br><span class="hljs-comment">// 本地pop (LIFO)</span><br><span class="hljs-keyword">final</span> ForkJoinTask&lt;?&gt; pop() &#123;<br>    ForkJoinTask&lt;?&gt;[] a = array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> top, cap = a.length;<br>    <span class="hljs-keyword">if</span> (s != base) &#123;          <span class="hljs-comment">// 队列非空</span><br>        ForkJoinTask&lt;?&gt; t = a[--s &amp; (cap - <span class="hljs-number">1</span>)]; <span class="hljs-comment">// 从尾部取</span><br>        a[s &amp; (cap - <span class="hljs-number">1</span>)] = <span class="hljs-literal">null</span>;<br>        top = s;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 窃取poll (FIFO)</span><br><span class="hljs-keyword">final</span> ForkJoinTask&lt;?&gt; poll() &#123;<br>    ForkJoinTask&lt;?&gt;[] a = array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> base, cap = a.length;<br>    <span class="hljs-keyword">if</span> (b != top) &#123;           <span class="hljs-comment">// 队列非空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b &amp; (cap - <span class="hljs-number">1</span>);<br>        ForkJoinTask&lt;?&gt; t = a[i];<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; <br>            base == b &amp;&amp;      <span class="hljs-comment">// 检查base未变</span><br>            UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, BASE, b, b + <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// CAS更新</span><br>            a[i] = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="lifo-fifo-的设计智慧：">LIFO + FIFO 的设计智慧：</h4>
<ul>
<li>本地LIFO：最近派生的任务最先执行，保持时间局部性（temporal locality）：
<ul>
<li>时间局部性：最近访问的数据很可能再次被访问</li>
<li>在分治算法中，最近派生的任务通常与父任务共享数据</li>
<li>保持这些数据在CPU缓存中，避免缓存失效惩罚</li>
</ul>
</li>
<li>窃取FIFO：最早派生的任务最先被窃取，保证窃取到&quot;大块&quot;任务
<ul>
<li>&quot;大块任务&quot;解释：这不是编程隐喻，而是指计算量大的任务。在分治算法中：
<ul>
<li>最早派生的任务通常是父任务分解的第一层子任务，包含大量工作</li>
<li>最近派生的任务通常是深层子任务，计算量较小</li>
</ul>
</li>
<li>例如快速排序中，根任务分解为左右子任务，这两个是&quot;大块任务&quot;；而叶子节点任务只处理几个元素，是&quot;小块任务&quot;</li>
<li>本地LIFO执行小任务（保持缓存），窃取FIFO获取大任务（避免任务碎片化）</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>三种线程池的队列对比</strong>：ForkJoinPool 的 WorkQueue 与 ThreadPoolExecutor 的 BlockingQueue、ScheduledThreadPoolExecutor 的 DelayedWorkQueue 有本质差异，详见 <a href="#%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84-workqueue-%E5%AF%B9%E6%AF%94">三种线程池的 WorkQueue 对比</a> 章节。</p>
<p><strong>三种线程池的 execute 对比</strong>：三者对 <code>execute(Runnable)</code> 的实现也有本质差异，详见 <a href="#%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84-execute-%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%AF%94">三种线程池的 execute() 实现对比</a> 章节。</p>
</blockquote>
<h4 id="forkjointask-join-与-thread-join-的本质差异">ForkJoinTask.join() 与 Thread.join() 的本质差异</h4>
<p>这是 ForkJoinPool 能够高效处理海量递归任务而不会死锁的关键机制。两种 join 有着根本性的不同。</p>
<p><strong>Thread.join() - 阻塞式等待</strong></p>
<p><code>Thread.join()</code> 的核心机制是：在一个 <code>synchronized</code> 方法中，通过 <code>while (isAlive())</code> 循环调用 <code>wait()</code>，让调用线程进入 WAITING 状态。当目标线程终止时，JVM 自动调用 <code>notifyAll()</code> 唤醒等待者。这是一种典型的<strong>操作系统级别的线程阻塞</strong>。</p>
<blockquote>
<p>关于 <code>Thread.join()</code> 的完整源码解析、设计哲学（三个关键角色的分离、接力式等待的本质、Thread 对象的特殊性等），请参阅<a href="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/#join">《Java 并发编程笔记》中的 join 章节</a>。</p>
</blockquote>
<p>当调用 <code>Thread.join()</code> 时：</p>
<ol>
<li>调用线程进入 <strong>WAITING</strong> 状态（由 <code>wait()</code> 方法决定）</li>
<li>线程被操作系统挂起，<strong>完全停止执行</strong></li>
<li>直到目标线程结束，JVM 调用 <code>notifyAll()</code> 唤醒等待的线程</li>
<li>这是<strong>操作系统级别的线程阻塞</strong></li>
</ol>
<p><strong>ForkJoinTask.join() - 协作式等待</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinTask.join() 的行为</span><br>RecursiveTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveTask</span>&lt;&gt;() &#123;<br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        RecursiveTask&lt;Integer&gt; subtask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveTask</span>&lt;&gt;() &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br>        subtask.fork();<br>        <span class="hljs-keyword">return</span> subtask.join();  <span class="hljs-comment">// 不会阻塞工作线程</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>当调用 <code>ForkJoinTask.join()</code> 时：</p>
<ol>
<li>工作线程<strong>不会进入 WAITING 状态</strong></li>
<li>线程继续执行其他任务（work-stealing）</li>
<li>定期检查等待的任务是否完成</li>
<li>这是<strong>用户态的协作式调度</strong></li>
</ol>
<p><strong>关键差异对比</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 A
    participant T2 as 线程 B
    participant OS as 操作系统
    
    Note over T1,OS: Thread.join() - 阻塞式
    T1-&gt;&gt;T2: 启动线程 B
    T1-&gt;&gt;T1: 调用 threadB.join()
    T1-&gt;&gt;OS: 进入 WAITING 状态
    OS-&gt;&gt;T1: 挂起线程 A
    Note over T1: 线程 A 停止执行
    T2-&gt;&gt;T2: 执行任务
    T2-&gt;&gt;OS: 线程 B 结束
    OS-&gt;&gt;T1: 唤醒线程 A
    T1-&gt;&gt;T1: 继续执行
    
    Note over T1,OS: ForkJoinTask.join() - 协作式
    T1-&gt;&gt;T1: 调用 task.join()
    alt 任务已完成
        T1-&gt;&gt;T1: 直接返回结果
    else 任务未完成
        T1-&gt;&gt;T1: 尝试 tryUnpush + doExec (本地队列执行)
        alt 本地执行成功
            T1-&gt;&gt;T1: 返回结果
        else 本地执行失败
            T1-&gt;&gt;T1: 调用 awaitJoin(w, this, 0L)
            Note right of T1: ⬅️ 此处让出 CPU（类似 yield）
            T1-&gt;&gt;T1: helpJoinOnce: 尝试从其他队列窃取任务
            alt 有任务可窃取
                T1-&gt;&gt;T1: 执行窃取的任务（保持 RUNNABLE）
                T1-&gt;&gt;T1: 定期检查原任务 status
            else 无任务可窃取
                T1-&gt;&gt;T1: 可能创建新线程（compensate）
                T1-&gt;&gt;T1: 忙等待检查 status
            end
            Note right of T1: 唤醒机制：其他线程完成任务后
            Note right of T1: 通过 CAS 修改 status，当前线程检测到后返回
        end
    end
    Note over T1: 线程 A 始终保持 RUNNABLE（用户态调度）</code></pre>
<p><strong>为什么 ForkJoinTask.join() 不会导致死锁</strong></p>
<p>考虑这个递归场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveSum</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Long&gt; &#123;<br>    <span class="hljs-keyword">protected</span> Long <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (size &lt;= THRESHOLD) &#123;<br>            <span class="hljs-keyword">return</span> computeDirectly();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 父任务等待子任务</span><br>        <span class="hljs-type">RecursiveSum</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveSum</span>(leftHalf);<br>        <span class="hljs-type">RecursiveSum</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveSum</span>(rightHalf);<br>        <br>        left.fork();   <span class="hljs-comment">// 提交到队列</span><br>        right.fork();  <span class="hljs-comment">// 提交到队列</span><br>        <br>        <span class="hljs-comment">// 父任务调用 join() 等待子任务</span><br>        <span class="hljs-keyword">return</span> left.join() + right.join();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果使用 <code>Thread.join()</code>，这种模式会导致问题：</p>
<ul>
<li>父线程阻塞等待子线程</li>
<li>但子任务可能还在队列中等待执行</li>
<li>如果所有线程都在等待，就会<strong>死锁</strong></li>
</ul>
<p>使用 <code>ForkJoinTask.join()</code>，不会死锁：</p>
<ul>
<li>父任务调用 <code>join()</code> 时，工作线程不会阻塞</li>
<li>工作线程会尝试执行等待的子任务</li>
<li>如果子任务在自己的队列中，直接执行</li>
<li>如果子任务在其他队列中，窃取其他任务继续工作</li>
<li>这样<strong>父子任务永远不会相互阻塞</strong></li>
</ul>
<p><strong>实现原理：ForkJoinTask.join() 的源码逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinTask.join() 的简化逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)<br>        reportException(s);<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doJoin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;<br>    <br>    <span class="hljs-comment">// 1. 如果任务已完成，直接返回</span><br>    <span class="hljs-keyword">return</span> (s = status) &lt; <span class="hljs-number">0</span> ? s :<br>        <br>        <span class="hljs-comment">// 2. 如果是 ForkJoinWorkerThread，尝试执行或窃取</span><br>        <span class="hljs-comment">// 这段代码类似于 yield，但更智能：不是简单地让出 CPU，而是尝试执行其他任务</span><br>        ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) ?<br>        (w = (wt = (ForkJoinWorkerThread)t).workQueue).<br>        <span class="hljs-comment">// 尝试从队列中移除并执行当前任务（如果任务在队列顶部）</span><br>        <span class="hljs-comment">// 如果成功执行（s &lt; 0 表示完成），直接返回</span><br>        tryUnpush(<span class="hljs-built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="hljs-number">0</span> ? s :<br>        <span class="hljs-comment">// ⬅️ 关键：这一行让出了 CPU，但不是真正的阻塞</span><br>        <span class="hljs-comment">// awaitJoin 方法内部会：</span><br>        <span class="hljs-comment">// 1. 尝试从其他队列窃取任务执行（work-stealing）</span><br>        <span class="hljs-comment">// 2. 如果没有任务可窃取，会调用 ForkJoinPool.compensate() 可能创建新线程</span><br>        <span class="hljs-comment">// 3. 最终会调用 ForkJoinPool.helpJoinOnce() 执行其他任务</span><br>        <span class="hljs-comment">// 4. 线程始终保持 RUNNABLE 状态，不会进入 WAITING</span><br>        <span class="hljs-comment">// 唤醒机制：</span><br>        <span class="hljs-comment">// - 当其他线程执行完这个任务后，会通过 CAS 操作修改任务的 status 字段</span><br>        <span class="hljs-comment">// - 当前线程在 awaitJoin 中会定期检查 status，发现完成后立即返回</span><br>        <span class="hljs-comment">// - 这是用户态的忙等待，不是操作系统级别的线程阻塞</span><br>        wt.pool.awaitJoin(w, <span class="hljs-built_in">this</span>, <span class="hljs-number">0L</span>) :<br>        <br>        <span class="hljs-comment">// 3. 外部线程，使用阻塞等待</span><br>        externalAwaitDone();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键点：</p>
<ol>
<li><strong>快速路径</strong>：任务已完成，直接返回</li>
<li><strong>工作线程路径</strong>：尝试执行任务或窃取其他任务</li>
<li><strong>外部线程路径</strong>：非 ForkJoinWorkerThread 才会阻塞</li>
</ol>
<p><strong>性能影响</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Thread.join()</th>
<th>ForkJoinTask.join()</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线程状态</strong></td>
<td>WAITING（阻塞）</td>
<td>RUNNABLE（继续工作）</td>
</tr>
<tr>
<td><strong>CPU 利用率</strong></td>
<td>降低（线程挂起）</td>
<td>保持（继续执行任务）</td>
</tr>
<tr>
<td><strong>上下文切换</strong></td>
<td>需要（操作系统调度）</td>
<td>不需要（用户态调度）</td>
</tr>
<tr>
<td><strong>死锁风险</strong></td>
<td>高（递归场景）</td>
<td>无（协作式调度）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>独立线程</td>
<td>分治递归任务</td>
</tr>
</tbody>
</table>
<p><strong>总结</strong></p>
<p>ForkJoinTask.join() 的协作式等待机制是 ForkJoinPool 的核心优势：</p>
<ol>
<li><strong>避免线程阻塞</strong>：工作线程永远不会因为等待而停止工作</li>
<li><strong>充分利用 CPU</strong>：等待期间继续执行其他任务</li>
<li><strong>避免死锁</strong>：父子任务可以在同一个线程中执行</li>
<li><strong>支持海量任务</strong>：可以提交远超线程数的任务而不会耗尽资源</li>
</ol>
<p>这种设计使得 ForkJoinPool 特别适合处理递归分治问题，如归并排序、快速排序、并行流等场景。</p>
<h3 id="forkjointask：任务抽象">ForkJoinTask：任务抽象</h3>
<h4 id="核心结构">核心结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Future</span>&lt;V&gt;, Serializable &#123;<br>    <span class="hljs-comment">// 32位状态字段</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> status;<br>    <br>    <span class="hljs-comment">// 状态常量（JDK 8实际定义）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DONE_MASK</span>   <span class="hljs-operator">=</span> <span class="hljs-number">0xf0000000</span>; <span class="hljs-comment">// 完成掩码</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>      <span class="hljs-operator">=</span> <span class="hljs-number">0xf0000000</span>; <span class="hljs-comment">// 正常完成（必须为负数）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>   <span class="hljs-operator">=</span> <span class="hljs-number">0xc0000000</span>; <span class="hljs-comment">// 已取消（必须小于NORMAL）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x80000000</span>; <span class="hljs-comment">// 异常完成（必须小于CANCELLED）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>      <span class="hljs-operator">=</span> <span class="hljs-number">0x00010000</span>; <span class="hljs-comment">// 需要信号（必须 &gt;= 1 &lt;&lt; 16）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SMASK</span>       <span class="hljs-operator">=</span> <span class="hljs-number">0x0000ffff</span>; <span class="hljs-comment">// 短整型位用于标签</span><br>    <span class="hljs-comment">// 注意：没有COMPLETING常量，COMPLETING是FutureTask的状态，不是ForkJoinTask的</span><br>    <br>    <span class="hljs-comment">// 核心方法</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异步提交当前任务到当前线程的本地队列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> this，支持链式调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 异步提交</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 等待当前任务完成并返回结果</span><br><span class="hljs-comment">     * 与 Thread.join()的关键区别：</span><br><span class="hljs-comment">     * - Thread.join()会阻塞当前线程，不做任何有用工作</span><br><span class="hljs-comment">     * - ForkJoinTask.join()会：</span><br><span class="hljs-comment">     *   1. 检查任务是否已完成</span><br><span class="hljs-comment">     *   2. 如果未完成，当前线程不会阻塞</span><br><span class="hljs-comment">     *   3. 而是执行&quot;协作式等待&quot;：</span><br><span class="hljs-comment">     *      a. 扫描其他工作队列窃取任务</span><br><span class="hljs-comment">     *      b. 如果窃取到的任务是目标任务的子任务，直接帮助执行</span><br><span class="hljs-comment">     *      c. 通过帮助执行，加速目标任务的完成</span><br><span class="hljs-comment">     *   4. 仅当全局无任务可做时才真正阻塞</span><br><span class="hljs-comment">     * - 可以从外部调用，但通常在FJ任务内部调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span>;               <span class="hljs-comment">// 等待完成</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务的核心计算逻辑，由子类实现</span><br><span class="hljs-comment">     * 与join()的区别：</span><br><span class="hljs-comment">     * - compute()包含任务的实际执行逻辑</span><br><span class="hljs-comment">     * - join()是等待其他任务完成的方法</span><br><span class="hljs-comment">     * - compute()在当前线程执行，join()触发协作执行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>;        <span class="hljs-comment">// 子类实现</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取原始结果（由compute()设置）</span><br><span class="hljs-comment">     * 满足Future&lt;V&gt;接口契约</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置原始结果</span><br><span class="hljs-comment">     * 通常由compute()内部调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(V value)</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试从当前线程的队列中移除任务</span><br><span class="hljs-comment">     * 用于任务取消</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryUnfork</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="标准子类">标准子类</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无返回值任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;Void&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 无返回值的计算逻辑</span><br><span class="hljs-comment">     * JLS允许将Void作为类型参数，虽然Void不可实例化</span><br><span class="hljs-comment">     * Void是不可实例化的占位符类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 为什么需要这个方法？</span><br><span class="hljs-comment">     * - 满足ForkJoinTask&lt;Void&gt;的接口契约</span><br><span class="hljs-comment">     * - 虽然返回Void，但类型系统需要具体实现</span><br><span class="hljs-comment">     * - 比RecursiveTask更轻量，因为不需要处理返回值</span><br><span class="hljs-comment">     * - 保持API一致性，避免特殊处理</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Void <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(Void mustBeNull)</span> &#123; &#125;<br>&#125;<br><br><span class="hljs-comment">// 有返回值任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveTask</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;V&gt; &#123;<br>    V result; <span class="hljs-comment">// 存储计算结果</span><br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 唯一需要子类实现的抽象方法</span><br>    <br>    <span class="hljs-comment">// 注意：以下方法是final的，不是abstract的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> result; &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(V value)</span> &#123; result = value; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="与futuretask的关键区别">与FutureTask的关键区别</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FutureTask.get()：可能完全阻塞</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>        <span class="hljs-comment">// s 的最终赋值是等待完成的结果</span><br>        s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>); <span class="hljs-comment">// 可能阻塞</span><br>    <span class="hljs-comment">// 最终 s 决定了 report 的行为</span><br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br><br><span class="hljs-comment">// ForkJoinTask.join()：协作式等待</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (doJoin() != NORMAL)       <span class="hljs-comment">// doJoin()包含帮助执行逻辑</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="关键api：与threadpoolexecutor的差异">关键API：与ThreadPoolExecutor的差异</h2>
<h3 id="forkjoinpool的核心api">ForkJoinPool的核心API</h3>
<h4 id="外部客户端api">外部客户端API</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重写的Executor.execute方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// 将Runnable包装为ForkJoinTask</span><br>    ForkJoinTask&lt;?&gt; job = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskAdaptor</span>(task);<br>    externalPush(job); <span class="hljs-comment">// 提交到外部队列</span><br>&#125;<br><br><span class="hljs-comment">// 针对ForkJoinTask的专用方法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为什么需要这个重载？</span><br><span class="hljs-comment"> * - 针对ForkJoinTask优化：避免包装开销</span><br><span class="hljs-comment"> * - 直接调用externalPush，性能更好</span><br><span class="hljs-comment"> * - 与父类的execute(Runnable)不是相互嵌套关系</span><br><span class="hljs-comment"> * - 两个方法针对不同类型的任务优化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ForkJoinTask&lt;?&gt; task)</span>;<br><br><span class="hljs-comment">// 同步执行并返回结果</span><br>&lt;T&gt; T <span class="hljs-title function_">invoke</span><span class="hljs-params">(ForkJoinTask&lt;T&gt; task)</span>;<br><br><span class="hljs-comment">// 提交任务并返回Future</span><br>&lt;T&gt; ForkJoinTask&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(ForkJoinTask&lt;T&gt; task)</span>;<br></code></pre></td></tr></table></figure>
<ol>
<li>对 TPE：<code>execute(Runnable)</code>是调度层的核心，不是最底层。最底层是 <code>runWorker()</code>。</li>
<li>对于外部提交，<code>externalPush()</code>或<code>externalSubmit()</code>是入口；但内部<code>fork()</code>调用的是<code>WorkQueue.push()</code>，两者是并行的入口路径，不是汇聚关系。</li>
</ol>
<h4 id="内部计算api">内部计算API</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内部API的访问控制：</span><br><span class="hljs-comment"> * - 虽然fork()/join()是public方法，但文档约定只在FJ任务内部调用</span><br><span class="hljs-comment"> * - 通过文档约定和性能惩罚来限制，不是通过访问控制</span><br><span class="hljs-comment"> * - 在外部调用fork()会回退到commonPool，性能较差</span><br><span class="hljs-comment"> * - 正确用法：外部客户端用invoke()，内部计算用fork()/join()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> ForkJoinTask.fork();    <span class="hljs-comment">// 异步派生子任务</span><br>V ForkJoinTask.join();       <span class="hljs-comment">// 等待子任务完成</span><br>V ForkJoinTask.invoke();     <span class="hljs-comment">// 执行并等待完成</span><br></code></pre></td></tr></table></figure>
<h4 id="监控与管理api">监控与管理API</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取全局窃取次数</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">getStealCount</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 等待池变为空闲</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitQuiescence</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>;<br><br><span class="hljs-comment">// 优雅关闭</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<h3 id="forkjoinpool-与-abstractexecutorservice-的关系辨析">ForkJoinPool 与 AbstractExecutorService 的关系辨析</h3>
<h4 id="关键问题：submit-和-execute-的关系是否改变了？">关键问题：submit 和 execute 的关系是否改变了？</h4>
<p><strong>答案：接口契约未变，但实现路径不同。</strong></p>
<p>根据 JSR-166 规范和 ForkJoinPool 的 Javadoc，需要区分两种情况：</p>
<h5 id="情况1：普通-runnable-callable-任务">情况1：普通 Runnable/Callable 任务</h5>
<p>对于普通 Runnable/Callable，ForkJoinPool <strong>完全遵循</strong> AbstractExecutorService 的契约：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractExecutorService 的默认实现（ForkJoinPool 继承）</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>    execute(ftask);  <span class="hljs-comment">// 调用 ForkJoinPool.execute()</span><br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">// ForkJoinPool.execute() 的实现</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    ForkJoinTask&lt;?&gt; job;<br>    <span class="hljs-keyword">if</span> (task <span class="hljs-keyword">instanceof</span> ForkJoinTask)  <span class="hljs-comment">// 不会进入此分支</span><br>        job = (ForkJoinTask&lt;?&gt;) task;<br>    <span class="hljs-keyword">else</span><br>        job = newTaskAdaptor(task);  <span class="hljs-comment">// 包装为 ForkJoinTask</span><br>    externalPush(job);  <span class="hljs-comment">// 提交到外部队列</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>调用链</strong>：<code>submit()</code> → <code>newTaskFor()</code> → <code>execute()</code> → <code>externalPush()</code> → WorkQueue</p>
<h5 id="情况2：forkjointask-任务">情况2：ForkJoinTask 任务</h5>
<p>对于 ForkJoinTask，ForkJoinPool 提供了<strong>重载方法</strong>，绕过 FutureTask 包装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinPool 专用方法</span><br><span class="hljs-keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(ForkJoinTask&lt;T&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    externalPush(task);  <span class="hljs-comment">// 直接提交，不包装为 FutureTask</span><br>    <span class="hljs-keyword">return</span> task;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ForkJoinTask&lt;?&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    externalPush(task);  <span class="hljs-comment">// 直接提交，不包装为 FutureTask</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>调用链</strong>：<code>submit()</code> → <code>externalPush()</code> → WorkQueue（跳过 FutureTask 包装）</p>
<h5 id="对比图示">对比图示</h5>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;ThreadPoolExecutor（标准实现）&quot;
        A1[submit Runnable] --&gt; B1[newTaskFor]
        B1 --&gt; C1[FutureTask]
        C1 --&gt; D1[execute]
        D1 --&gt; E1[WorkerQueue]
        
        A2[submit Callable] --&gt; B2[newTaskFor]
        B2 --&gt; C2[FutureTask]
        C2 --&gt; D1
    end
    
    subgraph &quot;ForkJoinPool（普通任务）&quot;
        A3[submit Runnable] --&gt; B3[newTaskFor]
        B3 --&gt; C3[FutureTask]
        C3 --&gt; D3[execute]
        D3 --&gt; E3[externalPush]
        E3 --&gt; F3[WorkQueue]
        
        A4[submit Callable] --&gt; B4[newTaskFor]
        B4 --&gt; C4[FutureTask]
        C4 --&gt; D3
    end
    
    subgraph &quot;ForkJoinPool（ForkJoinTask）&quot;
        A5[submit ForkJoinTask] --&gt; D5[externalPush]
        D5 --&gt; F5[WorkQueue]
        
        A6[execute ForkJoinTask] --&gt; D5
    end
    
    style A5 fill:#90EE90
    style A6 fill:#90EE90
    style D5 fill:#90EE90
    style F5 fill:#90EE90</code></pre>
<h5 id="关键结论">关键结论</h5>
<ol>
<li><strong>接口契约未变</strong>：ForkJoinPool 仍然继承 AbstractExecutorService，<code>submit()</code>、<code>invokeAll()</code>、<code>invokeAny()</code> 的契约保持不变</li>
<li><strong>实现路径不同</strong>：
<ul>
<li>普通任务：<code>submit()</code> → <code>FutureTask</code> → <code>execute()</code> → <code>externalPush()</code> → WorkQueue</li>
<li>ForkJoinTask：<code>submit()</code> → <code>externalPush()</code> → WorkQueue（跳过 FutureTask）</li>
</ul>
</li>
<li><strong>性能优化</strong>：ForkJoinTask 重载方法避免了不必要的 FutureTask 包装开销</li>
<li><strong>工作窃取</strong>：无论哪种路径，最终都通过 <code>externalPush()</code> 提交到 WorkQueue，支持工作窃取算法</li>
</ol>
<p>这个设计体现了 ForkJoinPool 的<strong>双重性质</strong>：既要兼容 ExecutorService 标准接口，又要为 ForkJoinTask 提供优化路径。</p>
<blockquote>
<p><strong>API 主次之分</strong>：与 ScheduledThreadPoolExecutor 类似，ForkJoinPool 的传统 execute/submit/invokeAll/invokeAny 是&quot;外部客户端 API&quot;，用于从非 fork/join 上下文提交任务。真正体现 ForkJoinPool 分治并行能力的核心 API 是 <code>ForkJoinPool.invoke(ForkJoinTask)</code> 和 <code>ForkJoinTask.fork()/join()</code>——前者是外部提交根任务的入口，后者是任务内部分解和合并的机制。在 fork/join 计算内部混用外部 API 会导致绕过工作窃取优化，详见 <a href="#api%E4%BD%BF%E7%94%A8%E8%BE%B9%E7%95%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%B7%B7%E7%94%A8">API使用边界</a> 章节。</p>
</blockquote>
<h3 id="api使用边界：为什么不能混用？">API使用边界：为什么不能混用？</h3>
<p>Javadoc 明确划分了 API 使用边界：</p>
<table>
<thead>
<tr>
<th>meannings</th>
<th>Call from non-fork/join clients</th>
<th>Call from within fork/join computations</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Arrange async execution</strong></td>
<td><code>execute(ForkJoinTask)</code></td>
<td><code>ForkJoinTask.fork()</code></td>
</tr>
<tr>
<td><strong>Await and obtain result</strong></td>
<td><code>invoke(ForkJoinTask)</code></td>
<td><code>ForkJoinTask.invoke()</code></td>
</tr>
<tr>
<td><strong>Arrange exec and obtain Future</strong></td>
<td><code>submit(ForkJoinTask)</code></td>
<td><code>ForkJoinTask.fork()</code> (ForkJoinTasks are Futures)</td>
</tr>
</tbody>
</table>
<p><strong>&quot;Arrange&quot;的含义：</strong><br>
此处的&quot;Arrange&quot;是英语动词，意为&quot;安排、组织&quot;，描述API的意图：</p>
<ul>
<li>Arrange async execution = “安排异步执行” → 任务提交后立即返回</li>
<li>Await and obtain result = “等待并获取结果” → 阻塞直到任务完成</li>
<li>Arrange exec and obtain Future = “安排执行并获取 Future” → 异步执行但保留结果句柄，通过 Future 获取结果。</li>
</ul>
<blockquote>
<p>原始文档强调<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/271521213">2</a>： “These methods are designed to be used primarily by clients<br>
not already engaged in fork/join computations in the current pool…<br>
tasks that are already executing in a pool should normally instead use<br>
the within-computation forms…”</p>
</blockquote>
<p><strong>混用API的代价</strong>：</p>
<ul>
<li><strong>性能下降</strong>：绕过工作窃取优化</li>
<li><strong>死锁风险</strong>：阻塞式等待导致资源浪费</li>
<li><strong>缓存失效</strong>：失去任务局部性</li>
</ul>
<h2 id="线程调度机制：动态适应的艺术">线程调度机制：动态适应的艺术</h2>
<h3 id="并行度：唯一的核心参数">并行度：唯一的核心参数</h3>
<h4 id="配置参数">配置参数</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism,</span><br><span class="hljs-params">                   ForkJoinWorkerThreadFactory factory,</span><br><span class="hljs-params">                   UncaughtExceptionHandler handler,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> asyncMode)</span>;<br></code></pre></td></tr></table></figure>
<p><strong>四个参数详解</strong>：</p>
<ol>
<li>
<p><strong>parallelism</strong>：目标并行度</p>
<ul>
<li>控制池中活跃工作线程的数量上限</li>
<li>默认值为<code>Runtime.getRuntime().availableProcessors()</code></li>
<li>实际线程数会根据负载动态调整</li>
</ul>
</li>
<li>
<p><strong>factory</strong>：工作线程工厂</p>
<ul>
<li>用于创建ForkJoinWorkerThread实例</li>
<li>默认使用<code>ForkJoinPool.defaultForkJoinWorkerThreadFactory</code></li>
<li>可自定义线程名称、优先级、上下文类加载器等属性</li>
</ul>
</li>
<li>
<p><strong>handler</strong>：未捕获异常处理器</p>
<ul>
<li>处理工作线程中未被捕获的异常</li>
<li>默认为null，异常会传播到<code>ThreadGroup.uncaughtException()</code></li>
<li>可设置自定义处理器进行统一异常处理</li>
</ul>
</li>
<li>
<p><strong>asyncMode</strong>：任务调度模式（核心设计决策）</p>
<ul>
<li><strong>false（默认）</strong>：LIFO模式 - 本地队列采用后进先出
<ul>
<li>适合递归分解任务（divide-and-conquer）</li>
<li>增强任务局部性，提高缓存命中率</li>
<li>Owner 从队尾取，Stealer 从队头窃取，两端分离无竞争</li>
</ul>
</li>
<li><strong>true</strong>：FIFO模式 - 本地队列采用先进先出
<ul>
<li>适合事件驱动任务（event-style tasks）</li>
<li>任务按顺序公平分发</li>
<li>Owner 和 Stealer 都从队头取，同端 CAS 竞争</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>设计哲学与JRE源码的深层考量</strong>：</p>
<p>表面上看，<code>newWorkStealingPool()</code>设置<code>asyncMode=true</code>似乎与&quot;递归分解适合LIFO&quot;的原则相矛盾。但实际上这是精心设计的结果：</p>
<ol>
<li>
<p><strong>使用场景区分</strong>：</p>
<ul>
<li>直接使用<code>ForkJoinPool</code>构造函数：通常是开发者明确知道在做分治算法</li>
<li>使用<code>newWorkStealingPool()</code>：面向通用并发任务，多数是非递归的独立任务</li>
</ul>
</li>
<li>
<p><strong>性能优化考量</strong>：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">asyncMode</span>=<span class="hljs-literal">true</span>的优势：<br>→ 任务按提交顺序执行，减少线程竞争<br>→ 适合大量独立小任务的并发执行<br>→ 避免递归深度导致的栈溢出风险<br>→ 更好的负载均衡效果<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>API设计意图</strong>：</p>
<ul>
<li><code>newWorkStealingPool()</code>旨在提供&quot;开箱即用&quot;的高性能并发池</li>
<li>默认FIFO模式对大多数应用更友好</li>
<li>需要专门的分治算法时，开发者会直接使用<code>ForkJoinPool</code>构造函数</li>
</ul>
</li>
<li>
<p><strong>Doug Lea的设计智慧</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK源码中的实际设计</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newWorkStealingPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(parallelism, <br>                           defaultForkJoinWorkerThreadFactory,<br>                           <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 故意设为true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种设计体现了&quot;默认最优&quot;的理念：为普通用户提供最适合大多数场景的配置，而将专业调优留给有明确需求的开发者。</p>
</li>
</ol>
<p><strong>关于工作窃取算法的澄清</strong>（回应读者核心疑问）：</p>
<p>这是一个非常重要的概念澄清：</p>
<p>正确 <strong>工作窃取算法始终启用</strong>：</p>
<ul>
<li>无论是<code>asyncMode=true</code>还是<code>false</code>，<strong>工作窃取机制都100%启用</strong></li>
<li>这是ForkJoinPool的核心特性，不因asyncMode而改变</li>
<li>Doug Lea设计的work-stealing算法是ForkJoinPool存在的根本</li>
</ul>
<p>错误 <strong>常见的误解纠正</strong>：</p>
<pre><code class="hljs mermaid">graph TD
    A[ForkJoinPool核心机制] --&gt; B[工作窃取算法&lt;br/&gt;始终启用]
    A --&gt; C[任务调度策略&lt;br/&gt;受asyncMode影响]
    B --&gt; D[线程空闲时&lt;br/&gt;从其他线程队列窃取任务]
    C --&gt; E[asyncMode=false: LIFO本地队列]
    C --&gt; F[asyncMode=true: FIFO本地队列]
    E --&gt; G[适合递归分解&lt;br/&gt;增强局部性]
    F --&gt; H[适合独立任务&lt;br/&gt;减少竞争]</code></pre>
<p><strong>递归分解 vs 工作窃取的关系</strong>：</p>
<p>这两个特性<strong>不是互斥的</strong>，而是<strong>互补的</strong>：</p>
<ol>
<li><strong>工作窃取是基础设施</strong>：提供线程间的负载均衡能力</li>
<li><strong>任务调度策略是优化手段</strong>：针对不同类型任务优化性能</li>
</ol>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">asyncMode=false（LIFO）：<br><span class="hljs-bullet">- </span>本地执行：LIFO（最新任务优先）<br><span class="hljs-bullet">- </span>窃取机制：从队头窃取<br><span class="hljs-bullet">- </span>优势：递归任务局部性好，缓存友好<br><br>asyncMode=true（FIFO）：<br><span class="hljs-bullet">- </span>本地执行：FIFO（按序执行）<br><span class="hljs-bullet">- </span>窃取机制：从队头窃取<br><span class="hljs-bullet">- </span>优势：独立任务公平分发<br></code></pre></td></tr></table></figure>
<p><strong>要点</strong>：</p>
<ul>
<li><strong>工作窃取 ≠ 任务调度策略</strong></li>
<li>工作窃取是&quot;怎么分任务&quot;，调度策略是&quot;按什么顺序执行任务&quot;</li>
<li><code>newWorkStealingPool()</code>名称强调的是&quot;使用工作窃取算法的池&quot;，而非&quot;积极启用工作窃取&quot;</li>
<li>asyncMode=true实际上是选择了更适合通用任务的执行顺序，但工作窃取机制从未关闭</li>
</ul>
<h4 id="公共池的系统属性">公共池的系统属性</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.concurrent.ForkJoinPool.common.parallelism<br>    - 目标并行度，控制活跃线程数<br>    - 默认 = Runtime.getRuntime().availableProcessors()<br>    <br>java.util.concurrent.ForkJoinPool.common.threadFactory<br>    - 自定义工作线程创建逻辑<br>    - 默认使用DefaultForkJoinWorkerThreadFactory<br>    <br>java.util.concurrent.ForkJoinPool.common.exceptionHandler<br>    - 处理未捕获异常<br>    - 默认使用系统默认异常处理器：<br>    <span class="hljs-comment">//   - 打印异常堆栈到System.err</span><br>    <span class="hljs-comment">//   - 不终止JVM</span><br>    <span class="hljs-comment">//   - 可通过Thread.setDefaultUncaughtExceptionHandler覆盖</span><br>    <br>java.util.concurrent.ForkJoinPool.common.maximumSpares<br>    - 额外线程上限，用于补偿阻塞<br>    - 默认 = <span class="hljs-number">256</span><br></code></pre></td></tr></table></figure>
<h4 id="各参数的实际影响：">各参数的实际影响：</h4>
<ul>
<li><strong>parallelism</strong>：直接影响CPU利用率，设置过大导致上下文切换开销</li>
<li><strong>threadFactory</strong>：可控制线程优先级、名称、守护状态</li>
<li><strong>exceptionHandler</strong>：确保异常不会静默失败</li>
<li><strong>maximumSpares</strong>：处理阻塞时的补偿机制，过小导致性能下降</li>
</ul>
<h3 id="无core-max参数的设计哲学">无core/max参数的设计哲学</h3>
<h4 id="threadpoolexecutor的线程管理">ThreadPoolExecutor的线程管理</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TPE的线程创建逻辑</span><br><span class="hljs-keyword">if</span> (当前线程数 &lt; corePoolSize) 创建核心线程<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (队列未满) 入队<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (当前线程数 &lt; maximumPoolSize) 创建非核心线程<br><span class="hljs-keyword">else</span> 拒绝策略<br></code></pre></td></tr></table></figure>
<h4 id="forkjoinpool的线程管理">ForkJoinPool的线程管理</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FJP的线程创建逻辑</span><br><span class="hljs-keyword">if</span> (活跃线程数 &lt; parallelism) 创建新线程<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (有线程阻塞且 spare线程数 &lt; maximumSpares) 创建spare线程<br><span class="hljs-keyword">else</span> 复用现有线程 <span class="hljs-comment">// 任务数超过线程数时：</span><br>                 <span class="hljs-comment">//   - 通过工作窃取实现负载均衡</span><br>                 <span class="hljs-comment">//   - 空闲线程会窃取其他队列的任务</span><br>                 <span class="hljs-comment">//   - 如果没有空闲线程：</span><br>                 <span class="hljs-comment">//     * 新任务入队到当前线程的本地队列</span><br>                 <span class="hljs-comment">//     * 队列会动态扩容（无界）</span><br>                 <span class="hljs-comment">//   - 不会创建新线程，除非有阻塞</span><br></code></pre></td></tr></table></figure>
<h4 id="parallelism-vs-corepoolsize-maximumspares-vs-maximumpoolsize：">parallelism vs corePoolSize, maximumSpares vs maximumPoolSize：</h4>
<ul>
<li>本质不同：
<ul>
<li>TPE：corePoolSize是静态下限（保持的最小线程数），maximumPoolSize是静态上限（允许的最大线程数）</li>
<li>FJP：parallelism是动态目标（期望的<strong>活跃线程数</strong>），maximumSpares是补偿上限（允许的额外线程数）：<strong>只要有任务，机制可以通过一个有限度的补偿拼命维持 active thread 的 count；ThreadPoolExecutor维持的是线程数量的边界范围（corePoolSize ≤ 线程数 ≤ maximumPoolSize），而不是特别关注线程的活跃状态。</strong></li>
<li>TPE的线程边界是硬性的，FJP的线程边界是软性的</li>
<li>TPE创建线程是为了处理更多任务，FJP创建spare线程是为了补偿阻塞</li>
</ul>
</li>
<li>关键区别：
<ul>
<li>线程数硬性上限：FJP的线程数永远不会超过 parallelism + maximumSpares</li>
<li>当达到上限后：
<ul>
<li>有线程阻塞时，无法创建spare线程</li>
<li>新任务入队到现有线程的队列（队列无界，会动态扩容）</li>
</ul>
</li>
<li>与TPE的核心区别：
<ul>
<li>TPE：有界队列满 + 线程=max 时触发拒绝策略（RejectedExecutionHandler）</li>
<li>FJP：<strong>无需配置拒绝策略</strong>，队列动态扩容，仅在 shutdown 或内部资源耗尽时抛出 RejectedExecutionException</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="线程回收机制对比">线程回收机制对比</h4>
<blockquote>
<p>Javadoc明确说明 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/271521213">2</a>： “Using the common pool normally reduces resource<br>
usage (its threads are slowly reclaimed during periods of non-use, and<br>
reinstated upon subsequent use).”</p>
</blockquote>
<h4 id="fjp线程回收细节">FJP线程回收细节</h4>
<ul>
<li>空闲线程不会立即销毁，而是park()</li>
<li>如果空闲时间超过阈值，标记为可回收</li>
<li>通过ctl字段的位操作，逐步减少活跃线程计数</li>
<li>下次需要时重新创建，避免频繁创建/销毁开销</li>
</ul>
<h3 id="为什么没有拒绝策略：无界队列与任务消费模型">为什么没有拒绝策略：无界队列与任务消费模型</h3>
<h4 id="forkjoinpool-构造器对比">ForkJoinPool 构造器对比</h4>
<p>查看 ForkJoinPool 的构造器签名，会发现一个显著的差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadPoolExecutor 构造器（7个参数）</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">    <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">    TimeUnit unit,</span><br><span class="hljs-params">    BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">    ThreadFactory threadFactory,</span><br><span class="hljs-params">    RejectedExecutionHandler handler  // 拒绝策略</span><br><span class="hljs-params">)</span><br><br><span class="hljs-comment">// ForkJoinPool 构造器（最完整版本，4个参数）</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> parallelism,</span><br><span class="hljs-params">    ForkJoinWorkerThreadFactory factory,</span><br><span class="hljs-params">    UncaughtExceptionHandler handler,  // 异常处理器，不是拒绝策略</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> asyncMode</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>
<p><strong>ForkJoinPool 没有 RejectedExecutionHandler 参数</strong>。这不是疏忽，而是有意为之的设计决策。</p>
<h4 id="为什么不需要拒绝策略？">为什么不需要拒绝策略？</h4>
<pre><code class="hljs mermaid">flowchart TB
    subgraph TPE[&quot;ThreadPoolExecutor 任务流&quot;]
        T1[新任务] --&gt; T2&#123;线程数 &lt; core?&#125;
        T2 --&gt;|是| T3[创建核心线程]
        T2 --&gt;|否| T4&#123;队列未满?&#125;
        T4 --&gt;|是| T5[入队等待]
        T4 --&gt;|否| T6&#123;线程数 &lt; max?&#125;
        T6 --&gt;|是| T7[创建非核心线程]
        T6 --&gt;|否| T8[触发拒绝策略]
        
        style T8 fill:#ff6b6b,color:#fff
    end
    
    subgraph FJP[&quot;ForkJoinPool 任务流&quot;]
        F1[新任务] --&gt; F2&#123;外部提交?&#125;
        F2 --&gt;|是| F3[放入共享提交队列]
        F2 --&gt;|否| F4[放入当前线程本地队列]
        F3 --&gt; F5[队列动态扩容]
        F4 --&gt; F5
        F5 --&gt; F6[工作窃取平衡负载]
        F6 --&gt; F7[join时帮助执行]
        
        style F5 fill:#51cf66,color:#fff
        style F7 fill:#51cf66,color:#fff
    end</code></pre>
<p><strong>原因一：队列是无界的</strong></p>
<p>每个 WorkQueue 内部使用 <code>ForkJoinTask&lt;?&gt;[] array</code> 存储任务：</p>
<p>根据 ForkJoinPool 的 Javadoc（Java SE 8+）：</p>
<blockquote>
<p>“This implementation rejects submitted tasks (that is, by throwing RejectedExecutionException) only when the pool is shut down or internal resources have been exhausted.”</p>
</blockquote>
<p>这意味着 ForkJoinPool <strong>不需要显式的拒绝策略参数</strong>，因为：</p>
<ul>
<li>正常运行时，任务总能被接受（队列会动态扩容）</li>
<li>只有在 shutdown 或内部资源耗尽时才会拒绝</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// WorkQueue 内部结构（来自 OpenJDK 8 源码）</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkQueue</span> &#123;<br>    ForkJoinTask&lt;?&gt;[] array;  <span class="hljs-comment">// 任务数组</span><br>    <span class="hljs-type">int</span> base;                  <span class="hljs-comment">// 窃取端索引（FIFO）</span><br>    <span class="hljs-type">int</span> top;                   <span class="hljs-comment">// 本地端索引（LIFO）</span><br>    <span class="hljs-comment">// 正确</span><br>    <br>    <span class="hljs-comment">// 数组容量范围（来自 OpenJDK 源码）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_QUEUE_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>;  <span class="hljs-comment">// 8192</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_QUEUE_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">26</span>;  <span class="hljs-comment">// 67,108,864（约 6700 万）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>当队列满时，会自动扩容（容量翻倍），直到达到 MAXIMUM_QUEUE_CAPACITY。这意味着：</p>
<ul>
<li>单个队列理论上可以容纳约 6700 万个任务</li>
<li>多个工作线程各有自己的队列</li>
<li>实际上，内存耗尽（OOM）会先于队列容量上限触发 “internal resources exhausted”</li>
</ul>
<p><strong>原因二：任务模型的本质差异</strong></p>
<p>ThreadPoolExecutor 处理的是<strong>独立任务</strong>：</p>
<ul>
<li>任务之间没有依赖关系</li>
<li>拒绝一个任务不影响其他任务</li>
<li>拒绝策略是合理的边界保护</li>
</ul>
<p>ForkJoinPool 处理的是<strong>可分解的递归任务</strong>：</p>
<ul>
<li>父任务 fork 出子任务</li>
<li>父任务必须 join 等待子任务完成</li>
<li><strong>如果拒绝子任务，父任务将永远无法完成，导致死锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果 ForkJoinPool 有拒绝策略，这段代码可能死锁</span><br><span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size &lt; THRESHOLD) &#123;<br>        <span class="hljs-keyword">return</span> directCompute();<br>    &#125;<br>    <br>    <span class="hljs-type">SubTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTask</span>(leftHalf);<br>    <span class="hljs-type">SubTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTask</span>(rightHalf);<br>    <br>    left.fork();   <span class="hljs-comment">// 如果这里被拒绝...</span><br>    right.fork();  <span class="hljs-comment">// 或者这里被拒绝...</span><br>    <br>    <span class="hljs-comment">// 父任务将永远阻塞在这里</span><br>    <span class="hljs-keyword">return</span> left.join() + right.join();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>原因三：join 的协作式消费</strong></p>
<p>ForkJoinPool 的 join 不是被动等待，而是主动帮助消费任务：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Parent as 父任务线程
    participant Queue as 本地队列
    participant Child as 子任务
    
    Parent-&gt;&gt;Queue: fork(子任务)
    Parent-&gt;&gt;Parent: 准备 join
    
    alt 子任务还在本地队列顶部
        Parent-&gt;&gt;Queue: tryUnpush(子任务)
        Parent-&gt;&gt;Child: 直接执行子任务
        Child--&gt;&gt;Parent: 返回结果
    else 子任务被窃取
        Parent-&gt;&gt;Queue: 执行队列中其他任务
        Note over Parent: 帮助消费，而非空等
        Child--&gt;&gt;Parent: 异步完成后返回结果
    end</code></pre>
<p>这种设计意味着：</p>
<ul>
<li>即使队列中有大量任务，线程也在持续消费</li>
<li>join 操作本身就是在帮助消费队列</li>
<li>任务的生产和消费是协作式的，不会出现&quot;生产远超消费&quot;的失控情况</li>
</ul>
<h4 id="队列无界会导致-oom-吗？">队列无界会导致 OOM 吗？</h4>
<p>理论上是的，但在正确使用 ForkJoinPool 的场景下，这不是问题：</p>
<p><strong>分治任务的&quot;菱形&quot;特征</strong>：</p>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;任务数量随时间变化&quot;
        A[根任务] --&gt; B1[子任务1]
        A --&gt; B2[子任务2]
        B1 --&gt; C1[孙任务1]
        B1 --&gt; C2[孙任务2]
        B2 --&gt; C3[孙任务3]
        B2 --&gt; C4[孙任务4]
        
        C1 --&gt; D1[结果1]
        C2 --&gt; D2[结果2]
        C3 --&gt; D3[结果3]
        C4 --&gt; D4[结果4]
        
        D1 --&gt; E1[合并1]
        D2 --&gt; E1
        D3 --&gt; E2[合并2]
        D4 --&gt; E2
        
        E1 --&gt; F[最终结果]
        E2 --&gt; F
    end
    
    style A fill:#4dabf7
    style B1 fill:#748ffc
    style B2 fill:#748ffc
    style C1 fill:#9775fa
    style C2 fill:#9775fa
    style C3 fill:#9775fa
    style C4 fill:#9775fa
    style D1 fill:#da77f2
    style D2 fill:#da77f2
    style D3 fill:#da77f2
    style D4 fill:#da77f2
    style E1 fill:#f783ac
    style E2 fill:#f783ac
    style F fill:#ff6b6b</code></pre>
<p>典型的分治任务呈现&quot;先增后减&quot;的菱形模式：</p>
<ol>
<li><strong>分解阶段</strong>：任务数量指数增长</li>
<li><strong>基准情况</strong>：到达阈值，开始直接计算</li>
<li><strong>合并阶段</strong>：任务数量指数减少</li>
</ol>
<p>工作窃取算法确保任务被及时消费，队列长度不会无限增长。</p>
<p><strong>如果滥用会怎样？</strong></p>
<p>如果把 ForkJoinPool 当作普通线程池，不断提交独立任务而不消费结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误用法：把 ForkJoinPool 当作无界队列使用</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ForkJoinPool.commonPool();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    pool.execute(() -&gt; &#123;<br>        <span class="hljs-comment">// 永远不结束的任务，或者生产速度远超消费速度</span><br>        Thread.sleep(Long.MAX_VALUE);<br>    &#125;);<br>&#125;<br><span class="hljs-comment">// 最终会 OOM</span><br></code></pre></td></tr></table></figure>
<p>这与使用 <code>new ThreadPoolExecutor(..., new LinkedBlockingQueue&lt;&gt;())</code> 的效果相同——都会因为无界队列导致 OOM。</p>
<h4 id="设计哲学总结">设计哲学总结</h4>
<table>
<thead>
<tr>
<th>维度</th>
<th>ThreadPoolExecutor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>任务模型</strong></td>
<td>独立任务</td>
<td>可分解的递归任务</td>
</tr>
<tr>
<td><strong>队列类型</strong></td>
<td>可配置（有界/无界）</td>
<td>动态扩容（无界）</td>
</tr>
<tr>
<td><strong>拒绝策略</strong></td>
<td>必需配置 RejectedExecutionHandler</td>
<td>无需配置，仅在 shutdown/资源耗尽时拒绝</td>
</tr>
<tr>
<td><strong>消费模式</strong></td>
<td>被动等待</td>
<td>协作式消费（join帮助执行）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>通用任务执行</td>
<td>分治并行计算</td>
</tr>
<tr>
<td><strong>OOM风险</strong></td>
<td>无界队列时存在</td>
<td>滥用时存在（触发 internal resources exhausted）</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>要点</strong>：ForkJoinPool 的构造器不需要 RejectedExecutionHandler 参数，是因为在分治并行模型中，拒绝子任务会导致父任务死锁。根据 Javadoc，ForkJoinPool 仅在 shutdown 或内部资源耗尽时抛出 RejectedExecutionException。动态扩容的队列配合工作窃取和协作式 join，形成了一个自平衡的任务消费系统。</p>
</blockquote>
<h3 id="工作线程生命周期">工作线程生命周期</h3>
<p>工作线程经历四个阶段：</p>
<ul>
<li><strong>初始化</strong>：首次提交任务时创建，初始活跃线程数不超过parallelism，但总线程数可能达到 parallelism + maximumSpares
<ul>
<li>与TPE的关键区别：TPE的核心线程即使空闲也不会回收（除非设置allowCoreThreadTimeOut），<strong>而FJP的所有线程在空闲时都会被回收</strong></li>
<li>FJP的设计哲学：按需创建，及时释放，适合间歇性负载</li>
</ul>
</li>
<li><strong>活跃期</strong>：执行任务 + 窃取任务，检测阻塞时触发spare线程
<ul>
<li>通过<code>ManagedBlocker</code>接口检测阻塞</li>
<li>当线程阻塞时，可能创建spare线程补偿</li>
</ul>
</li>
<li><strong>空闲期</strong>：无任务时park()，保持空闲状态
<ul>
<li>线程通过<code>awaitWork()</code>方法（内部实现）进入等待，使用<code>LockSupport.park()</code>挂起</li>
<li>有新任务时被唤醒</li>
</ul>
</li>
<li><strong>回收期</strong>：空闲超过阈值，逐步减少线程
<ul>
<li>通过ctl字段的位操作管理线程状态，空闲超时后线程主动退出run()循环</li>
<li>线程退出run()方法，被垃圾回收</li>
<li>下次需要时重新创建，避免永久空闲线程</li>
</ul>
</li>
</ul>
<p>根据 ForkJoinPool 源码注释和 Javadoc 文档：</p>
<blockquote>
<p>“The pool attempts to maintain enough active (or available) threads by dynamically adding, suspending, or resuming internal worker threads, even if some tasks are stalled waiting to join others.”</p>
</blockquote>
<p>这意味着 ForkJoinPool 会动态调整线程数以维持目标并行度，同时避免频繁的线程创建/销毁循环。与传统线程池不同，ForkJoinPool 会回收所有空闲线程以减少资源消耗。</p>
<h2 id="实战案例：并行文件搜索系统">实战案例：并行文件搜索系统</h2>
<h3 id="业务需求">业务需求</h3>
<ul>
<li>搜索指定目录下的所有文件</li>
<li>查找包含特定关键词的文件</li>
<li>统计匹配行数</li>
<li>处理大型目录（10万+文件）</li>
<li>要求高效利用多核CPU</li>
</ul>
<h3 id="数据结构定义">数据结构定义</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文件搜索任务：递归遍历目录树</span><br><span class="hljs-comment"> * 使用RecursiveTask，因为需要返回匹配结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSearchTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;List&lt;SearchResult&gt;&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 子任务阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Path directory;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String keyword;<br>    <br>    FileSearchTask(Path directory, String keyword) &#123;<br>        <span class="hljs-built_in">this</span>.directory = directory;<br>        <span class="hljs-built_in">this</span>.keyword = keyword;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> List&lt;SearchResult&gt; <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取目录下的所有路径（文件和子目录）</span><br>            List&lt;Path&gt; paths = Files.list(directory)<br>                                   .collect(Collectors.toList());<br>            <br>            <span class="hljs-comment">// 基本情况：小目录直接处理</span><br>            <span class="hljs-keyword">if</span> (paths.size() &lt;= THRESHOLD) &#123;<br>                <span class="hljs-keyword">return</span> searchDirectly(paths);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 递归情况：分解为子任务</span><br>            List&lt;FileSearchTask&gt; subtasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            List&lt;Path&gt; currentBatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <br>            <span class="hljs-keyword">for</span> (Path path : paths) &#123;<br>                currentBatch.add(path);<br>                <span class="hljs-comment">// 每THRESHOLD个路径创建一个子任务</span><br>                <span class="hljs-keyword">if</span> (currentBatch.size() &gt;= THRESHOLD) &#123;<br>                    subtasks.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(createTempDir(currentBatch), keyword));<br>                    currentBatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 处理剩余路径</span><br>            <span class="hljs-keyword">if</span> (!currentBatch.isEmpty()) &#123;<br>                subtasks.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(createTempDir(currentBatch), keyword));<br>            &#125;<br>            <br>            <span class="hljs-comment">// 优化：fork其他任务，直接执行最后一个任务（减少调度开销）</span><br>            <span class="hljs-keyword">if</span> (subtasks.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 将最后一个任务留给自己执行，它不进入 fork</span><br>                <span class="hljs-comment">// 因为 fork 是一次执行，compute 是另一次，计算并不一定是幂等的</span><br>                <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">lastTask</span> <span class="hljs-operator">=</span> subtasks.remove(subtasks.size() - <span class="hljs-number">1</span>);<br>                <br>                <span class="hljs-comment">// 异步fork其他任务</span><br>                <span class="hljs-keyword">for</span> (FileSearchTask task : subtasks) &#123;<br>                    task.fork(); <span class="hljs-comment">// 正确：无锁本地队列push</span><br>                &#125;<br>                <br>                <span class="hljs-comment">// 同步执行最后一个任务</span><br>                List&lt;SearchResult&gt; results = lastTask.compute(); <span class="hljs-comment">// 正确：保持缓存</span><br>                <br>                <span class="hljs-comment">// 等待其他任务完成</span><br>                <span class="hljs-keyword">for</span> (FileSearchTask task : subtasks) &#123;<br>                    results.addAll(task.join()); <span class="hljs-comment">// 正确：协作式等待</span><br>                &#125;<br>                <br>                <span class="hljs-keyword">return</span> results;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 只有一个子任务，直接执行</span><br>                <span class="hljs-keyword">return</span> subtasks.get(<span class="hljs-number">0</span>).compute();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UncheckedIOException</span>(e);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;SearchResult&gt; <span class="hljs-title function_">searchDirectly</span><span class="hljs-params">(List&lt;Path&gt; paths)</span> &#123;<br>        List&lt;SearchResult&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Path path : paths) &#123;<br>            <span class="hljs-keyword">if</span> (Files.isDirectory(path)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 递归处理子目录</span><br>                    results.addAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(path, keyword).compute());<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-comment">// 忽略无法访问的目录</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 处理文件</span><br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> Files.newBufferedReader(path)) &#123;<br>                    String line;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">lineNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (line.contains(keyword)) &#123;<br>                            results.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchResult</span>(path, lineNumber, line));<br>                        &#125;<br>                        lineNumber++;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-comment">// 忽略无法读取的文件</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Path <span class="hljs-title function_">createTempDir</span><span class="hljs-params">(List&lt;Path&gt; paths)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 创建临时目录的逻辑（简化）</span><br>        <span class="hljs-keyword">return</span> Files.createTempDirectory(<span class="hljs-string">&quot;search_&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 搜索结果封装</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SearchResult</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Path filePath;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> lineNumber;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String lineContent;<br>    <br>    SearchResult(Path filePath, <span class="hljs-type">int</span> lineNumber, String lineContent) &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>        <span class="hljs-built_in">this</span>.lineNumber = lineNumber;<br>        <span class="hljs-built_in">this</span>.lineContent = lineContent;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s:%d: %s&quot;</span>, filePath, lineNumber, lineContent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="线程池初始化与使用">线程池初始化与使用</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParallelFileSearch</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建自定义ForkJoinPool</span><br><span class="hljs-comment">     * 根据业务需求配置参数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ForkJoinPool <span class="hljs-title function_">createSearchPool</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parallelism</span> <span class="hljs-operator">=</span> Math.min(<br>            Runtime.getRuntime().availableProcessors(),<br>            <span class="hljs-number">16</span> <span class="hljs-comment">// 限制最大并行度，避免I/O瓶颈</span><br>        );<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<br>            parallelism,<br>            ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>            (thread, throwable) -&gt; &#123;<br>                <span class="hljs-comment">// 自定义异常处理：记录日志</span><br>                System.err.printf(<span class="hljs-string">&quot;Thread %s threw exception: %s%n&quot;</span>, <br>                                 thread.getName(), throwable.getMessage());<br>            &#125;,<br>            <span class="hljs-literal">false</span> <span class="hljs-comment">// asyncMode = false，使用LIFO模式</span><br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 搜索入口方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;SearchResult&gt; <span class="hljs-title function_">search</span><span class="hljs-params">(Path rootDir, String keyword)</span> &#123;<br>        <span class="hljs-comment">// 创建自定义池，避免使用公共池影响其他组件</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> createSearchPool()) &#123;<br>            <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">rootTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(rootDir, keyword);<br>            <br>            <span class="hljs-comment">// 正确：外部客户端使用invoke()</span><br>            <span class="hljs-keyword">return</span> pool.invoke(rootTask);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 错误用法示例（注释说明）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;SearchResult&gt; <span class="hljs-title function_">wrongApproach</span><span class="hljs-params">(Path rootDir, String keyword)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> createSearchPool()) &#123;<br>            <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">rootTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(rootDir, keyword);<br>            <br>            <span class="hljs-comment">// 错误1：在外部客户端使用fork()</span><br>            <span class="hljs-comment">// rootTask.fork(); // 这会在公共池执行，绕过自定义池配置</span><br>            <br>            <span class="hljs-comment">// 错误2：混用API</span><br>            <span class="hljs-comment">// 在compute()内部这样写是错误的：</span><br>            <span class="hljs-comment">// pool.submit(subtask); // 绕过工作窃取</span><br>            <span class="hljs-comment">// pool.invoke(anotherTask); // 阻塞当前线程</span><br>            <br>            <span class="hljs-comment">// 正确：外部客户端使用invoke()</span><br>            <span class="hljs-keyword">return</span> pool.invoke(rootTask);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">2</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Usage: java ParallelFileSearch &lt;directory&gt; &lt;keyword&gt;&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">Path</span> <span class="hljs-variable">rootDir</span> <span class="hljs-operator">=</span> Paths.get(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">keyword</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        List&lt;SearchResult&gt; results = search(rootDir, keyword);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <br>        System.out.printf(<span class="hljs-string">&quot;Found %d matches in %d ms%n&quot;</span>, <br>                         results.size(), endTime - startTime);<br>        <br>        <span class="hljs-comment">// 打印前10个结果</span><br>        results.stream().limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以正确的框架是：</p>
<pre><code class="hljs mermaid">graph TD
    A[ForkJoinPool任务执行] --&gt; B&#123;使用哪个API?&#125;
    B --&gt;|invoke()| C[正确方式]
    B --&gt;|submit()/execute()| D[错误方式]
    
    C --&gt; E[触发工作窃取机制]
    C --&gt; F[维护任务父子关系]
    C --&gt; G[支持fork()/join()调用链]
    C --&gt; H[同步等待结果]
    
    D --&gt; I[无法触发工作窃取]
    D --&gt; J[破坏任务分解结构]
    D --&gt; K[RecursiveTask无法正常工作]</code></pre>
<ol>
<li>
<p><strong>必须使用invoke()而非submit()/execute()</strong>：</p>
<ul>
<li><code>invoke()</code>是ForkJoinPool的专用API，专为工作窃取算法设计</li>
<li>只有通过<code>invoke()</code>提交的任务才能正确触发<code>fork()</code>和<code>join()</code>的执行机制</li>
<li><code>submit()/execute()</code>提交的任务无法参与工作窃取，违背了ForkJoinPool的设计初衷</li>
</ul>
</li>
<li>
<p>定义一个 RecursiveTask 或者 RecursiveAction，而不是直接使用 ForkJoinTask，然后让 ForkJoinPool 来 invoke 根 task。</p>
</li>
<li>
<p>每个任务内部：</p>
<ol>
<li>先检查任务大小，只有大任务才分解生成子任务，小任务直接计算。</li>
<li>从子任务列表中移除最后一个任务，保留给自己直接执行。</li>
<li>对其余子任务调用fork()（异步提交）。</li>
<li>对保留的任务调用compute()（同步执行）。</li>
</ol>
</li>
</ol>
<p><strong>Specification支撑</strong>：根据JSR 166规范和Doug Lea的设计原则，ForkJoinPool的<code>invoke()</code>方法是唯一能够正确激活工作窃取调度器的入口点。使用其他API会导致任务无法被正确分解和调度。<br>
5. 对其他任务进行 join 收集计算结果，合并进上一个计算结果里。<br>
6. 返回全部计算结果。<br>
3. 所以在任务外部使用 invoke，内部使用 fork/compute/join。外部不应该用fork()/join()，看上面的 arrange。</p>
<h3 id="关键设计决策解析">关键设计决策解析</h3>
<h4 id="为什么使用-recursivetask-而不是-recursiveaction？">为什么使用 RecursiveTask 而不是 RecursiveAction？</h4>
<ul>
<li>需要返回搜索结果（List）</li>
<li>RecursiveTask 提供类型安全的返回值</li>
<li>符合分治模式：子任务结果合并为父任务结果</li>
</ul>
<h4 id="为什么设置threshold-100？">为什么设置THRESHOLD=100？</h4>
<ul>
<li>任务分解粒度需要平衡：
<ul>
<li>太小：调度开销超过计算收益</li>
<li>
<ul>
<li>太大：负载不均衡，CPU核心利用率低</li>
</ul>
</li>
</ul>
</li>
<li>100是经验值，可根据文件大小调整</li>
<li>通过基准测试确定最优值</li>
</ul>
<h4 id="为什么fork其他任务-直接执行最后一个任务？">为什么fork其他任务，直接执行最后一个任务？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 优化：fork其他任务，直接执行最后一个任务（避免不必要的调度开销）</span><br><span class="hljs-keyword">if</span> (subtasks.size() &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">lastTask</span> <span class="hljs-operator">=</span> subtasks.remove(subtasks.size() - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (FileSearchTask task : subtasks) &#123;<br>        task.fork(); <span class="hljs-comment">// 异步提交</span><br>    &#125;<br>    <br>    List&lt;SearchResult&gt; results = lastTask.compute(); <span class="hljs-comment">// 同步执行</span><br>    <br>    <span class="hljs-keyword">for</span> (FileSearchTask task : subtasks) &#123;<br>        results.addAll(task.join()); <span class="hljs-comment">// 等待完成</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>设计理由：</p>
<ul>
<li><strong>避免调度开销</strong>：直接compute()比fork()后再join()少一次入队出队操作</li>
<li><strong>缓存局部性</strong>：直接执行的任务与父任务共享数据，保持CPU缓存热度</li>
<li><strong>栈深度控制</strong>：避免过深的递归导致StackOverflowError</li>
<li><strong>注意</strong>：这里的&quot;最后一个任务&quot;不是指&quot;最大的任务&quot;，而是任意选择一个任务直接执行以减少调度开销</li>
</ul>
<h4 id="为什么创建自定义池而不是使用公共池？">为什么创建自定义池而不是使用公共池？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> createSearchPool()) &#123;<br>    <span class="hljs-keyword">return</span> pool.invoke(rootTask);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计理由</strong>：</p>
<ul>
<li><strong>资源隔离</strong>：避免影响其他使用公共池的组件</li>
<li><strong>参数定制</strong>：限制并行度（16），避免I/O瓶颈</li>
<li><strong>异常处理</strong>：自定义异常处理器，确保错误可见</li>
<li><strong>生命周期管理</strong>：try-with-resources确保池关闭</li>
</ul>
<h4 id="为什么asyncmode-false？">为什么asyncMode=false？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(parallelism, ..., <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>
<p><strong>设计理由</strong>：</p>
<ul>
<li>
<p><strong>LIFO模式</strong>：适合分治算法，保持缓存局部性</p>
</li>
<li>
<p><strong>asyncMode=true</strong>：使用FIFO模式，适合事件处理</p>
</li>
<li>
<p>文件搜索是典型的分治场景，LIFO更高效</p>
</li>
</ul>
<h2 id="forkjoinpool-与-threadpoolexecutor-的对比及-commonpool-实践">ForkJoinPool 与 ThreadPoolExecutor 的对比及 commonPool 实践</h2>
<h3 id="forkjoinpool-vs-threadpoolexecutor-核心差异">ForkJoinPool vs ThreadPoolExecutor 核心差异</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>ForkJoinPool</th>
<th>ThreadPoolExecutor</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>队列架构</strong></td>
<td>每个工作线程一个双端队列</td>
<td>全局共享队列</td>
</tr>
<tr>
<td><strong>负载均衡</strong></td>
<td>工作窃取（主动，线程闲了就去偷）</td>
<td>队列分发（被动，线程从队列取）</td>
</tr>
<tr>
<td><strong>适合场景</strong></td>
<td>大量短任务、CPU 密集型</td>
<td>IO 密集型、混合任务</td>
</tr>
<tr>
<td><strong>线程数</strong></td>
<td>固定 = CPU 核心数</td>
<td>可动态扩缩容（core → max）</td>
</tr>
<tr>
<td><strong>拥塞队列</strong></td>
<td>无（直接入队到工作线程）</td>
<td>有（可配置容量，如 LinkedBlockingQueue）</td>
</tr>
<tr>
<td><strong>队列满时行为</strong></td>
<td>队列动态扩容，任务无限排队</td>
<td>RejectedExecutionHandler（4种策略）</td>
</tr>
<tr>
<td><strong>线程收缩</strong></td>
<td>自动收缩（无 core thread 空转）</td>
<td>依赖 keepAliveTime</td>
</tr>
<tr>
<td><strong>线程类型</strong></td>
<td>守护线程（默认）</td>
<td>非守护线程（默认）</td>
</tr>
</tbody>
</table>
<p><strong>何时选择 ForkJoinPool 而非 ThreadPoolExecutor（非递归分治场景）</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐选择</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>大量细粒度任务</strong>（如并行流处理、批量计算）</td>
<td>FJP</td>
<td>工作窃取机制减少线程空闲，任务短到可快速完成时全局队列竞争会成为瓶颈</td>
</tr>
<tr>
<td><strong>任务执行时间差异大</strong>（部分任务耗时极长，部分极短）</td>
<td>FJP</td>
<td>短任务可被其他空闲线程窃取执行，长任务不会阻塞短任务</td>
</tr>
<tr>
<td><strong>需要最大化 CPU 利用率</strong>（CPU 密集型混合任务）</td>
<td>FJP</td>
<td>线程数固定为 CPU 核心数，避免线程切换开销，且工作窃取保证所有核心 busy</td>
</tr>
<tr>
<td><strong>并行流（Parallel Stream）</strong></td>
<td>FJP（自动使用）</td>
<td><code>Arrays.parallelSort()</code>、<code>List.parallelStream()</code> 内部依赖 FJP</td>
</tr>
<tr>
<td><strong>CompletableFuture 编排大量计算任务</strong></td>
<td>FJP</td>
<td><code>CompletableFuture.runAsync()</code> 默认使用 commonPool，适合 CPU 密集型任务编排</td>
</tr>
<tr>
<td><strong>IO 密集型任务</strong></td>
<td>TPE</td>
<td>FJP 工作线程默认为<strong>守护线程</strong>——JVM 退出时不会等待守护线程执行完毕。如果守护线程长时间阻塞（如等待网络响应），JVM 可能在任务完成前退出，导致任务被&quot;截断&quot;；TPE 为非守护线程，JVM 会等待其执行完毕</td>
</tr>
<tr>
<td><strong>需要任务队列有界控制</strong></td>
<td>TPE</td>
<td>FJP 无队列容量控制，任务无限排队风险</td>
</tr>
</tbody>
</table>
<p><strong>简言之</strong>：当你的任务是<strong>大量 CPU 密集型的短任务</strong>，且任务执行时间<strong>相对均衡</strong>或<strong>差异不大</strong>时，FJP 的工作窃取机制能提供更高的吞吐量；否则（如 IO 密集型、任务时长差异极大、需要可控的队列容量），TPE 是更稳妥的选择。</p>
<h4 id="线程池的演进逻辑">线程池的演进逻辑</h4>
<p>从历史发展的角度看，Java 线程池经历了一个逐步演进的过程：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">TPE（ThreadPoolExecutor）<br>    ↓<br>FJP（ForkJoinPool）— 削弱了 TPE 在 CPU 密集型场景的优势<br>    ↓<br>虚拟线程（Virtual <span class="hljs-keyword">Thread</span>）— 进一步削弱了 TPE 在 IO 密集型场景的优势<br></code></pre></td></tr></table></figure>
<p><strong>没有虚拟线程的时代</strong>：</p>
<ul>
<li>IO 密集型业务 → TPE（可动态扩缩容）</li>
<li>CPU 密集型业务 → FJP（工作窃取）</li>
</ul>
<p><strong>虚拟线程出现后</strong>：</p>
<ul>
<li>虚拟线程让 IO 阻塞不再占用物理线程</li>
<li>大量 IO 密集型任务可以用极少的载体线程支撑海量并发</li>
<li>但 FJP 的守护线程问题仍然存在，不适合长时间阻塞</li>
</ul>
<p><strong>日常使用习惯</strong>：现实中 TPE 用得多，因为大多数业务是 IO 密集型。<strong>你对线程池的选择，只在追求资源利用率和性价比时才重要</strong>——只要任务能正确完成，用哪个线程池并无本质区别。</p>
<h3 id="commonpool-的并发控制机制">commonPool 的并发控制机制</h3>
<p><strong>关键问题：当大量外部线程涌入时，commonPool 会无限扩张吗？</strong></p>
<p><strong>答案：不会。commonPool 有固定的并行度限制。但需要注意：当线程被阻塞任务占用时，新任务将无限排队等待执行。</strong></p>
<p><strong>并行度计算</strong>：</p>
<ul>
<li><code>commonPool</code> 并行度 = <code>CPU 核心数 - 1</code>（至少为 1）</li>
<li>8 核 CPU → commonPool 并行度 = 7</li>
<li>可通过 <code>-Djava.util.concurrent.ForkJoinPool.common.parallelism=N</code> 覆盖</li>
</ul>
<p><strong>任务入队机制</strong>：当任务提交超过并行度时，ForkJoinPool 不会无限创建线程，而是：</p>
<ol>
<li><strong>任务入队</strong>：外部线程随机选择一个工作线程，将任务 push 到其双端队列</li>
<li><strong>工作窃取</strong>：闲线程从其他线程队列尾部窃取任务</li>
<li><strong>不会创建新线程</strong>：线程数固定为并行度，不会像 TPE 那样动态扩容</li>
</ol>
<p><strong>关键风险：线程数最终不可扩张 + 可调度资源稀缺性</strong></p>
<ol>
<li>队列几乎永远不会满：单个 WorkQueue 最大容量约 6700 万（<code>MAXIMUM_QUEUE_CAPACITY = 1 &lt;&lt; 26</code>），在达到这个上限之前，OOM 会先触发</li>
<li>不存在类似 CallerRunsPolicy 的机制：ForkJoinPool 的 Javadoc 明确说明，仅在 shutdown 或内部资源耗尽时抛出 RejectedExecutionException，不会让提交线程执行任务</li>
<li>真正的风险是任务无限排队：多个业务共用 commonPool 时，若部分任务执行阻塞操作（如 Thread.sleep、DB 查询），会占用有限的线程资源，导致其他任务无法及时执行——这正是许多生产环境事故的根本原因</li>
</ol>
<p><strong>核心机制：可调度单元 vs 不可调度单元</strong></p>
<p>commonPool 的根本问题在于<strong>线程数最终不可扩张</strong>，且<strong>可调度的线程比不可调度的队列元素更宝贵</strong>：</p>
<ul>
<li>线程是 OS 可调度的执行单元，拥有独立的执行上下文和 CPU 时间片</li>
<li>队列中的任务只是内存中的数据结构，无法主动获取 CPU 资源，必须依赖线程来执行</li>
<li>当工作线程阻塞时（如 Thread.sleep），它让出了 CPU，但<strong>没有让出线程的 runnable 位置</strong>——该线程仍被标记为&quot;活跃&quot;，继续占用 commonPool 的并行度名额</li>
<li>结果是：阻塞的线程无法执行新任务，新任务只能无限排队，而 commonPool 又不会创建新线程来补偿（maximumSpares 仅用于补偿 ForkJoinTask 的 join 等待，不用于补偿外部阻塞）</li>
</ul>
<p>任务无限排队的场景：commonPool 线程数 = CPU 核心数 - 1（8 核 CPU 只有 7 个线程），若 7 个线程都被阻塞任务占用，新提交的任务只能无限排队等待——队列本身不可调度，没有可用的可调度单元（线程），任务永远无法执行。</p>
<p><strong>生产环境最佳实践</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 短任务、CPU 密集：使用 commonPool</span><br>CompletableFuture.runAsync(() -&gt; &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> expensiveComputation();<br>&#125;);<br><br><span class="hljs-comment">// 需要控制并行度：自定义 ForkJoinPool</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">customPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);<br>CompletableFuture.runAsync(() -&gt; &#123; <span class="hljs-comment">/* ... */</span> &#125;, customPool);<br><br><span class="hljs-comment">// IO 密集型任务：使用专门的线程池，不要用 commonPool</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ioPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">50</span>);<br>CompletableFuture.runAsync(() -&gt; db.query(), ioPool);<br><br><span class="hljs-comment">// 危险：阻塞操作会占用 commonPool 线程</span><br>CompletableFuture.runAsync(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">10000</span>);  <span class="hljs-comment">// 会导致其他任务无限排队</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="对-completablefuture-的影响">对 CompletableFuture 的影响</h3>
<p><code>CompletableFuture.runAsync()</code> 默认使用 <code>commonPool()</code>（FIFO 模式），但若显式传入 LIFO 模式的线程池，任务执行顺序可能与提交顺序不同：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">lifoPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();  <span class="hljs-comment">// 默认 LIFO</span><br><br>CompletableFuture.runAsync(() -&gt; &#123;<span class="hljs-comment">/* Task 1 */</span>&#125;, lifoPool);<br>CompletableFuture.runAsync(() -&gt; &#123;<span class="hljs-comment">/* Task 2 */</span>&#125;, lifoPool);<br><span class="hljs-comment">// Task 2 可能先于 Task 1 执行（栈顶优先）</span><br></code></pre></td></tr></table></figure>
<p>需注意：<code>CompletableFuture</code> 的 happens-before 关系由回调链保证，与底层线程池调度策略无关。asyncMode 仅影响独立任务的入队/出队顺序，不影响 <code>CompletableFuture</code> 的语义正确性。</p>
<h2 id="forkjoinpool-常见错误模式">ForkJoinPool 常见错误模式</h2>
<h3 id="api混用错误">API混用错误</h3>
<p>在 <code>ForkJoinTask.compute()</code> 内部应使用 <code>fork()/join()</code> API，而非 <code>pool.submit()</code> 或 <code>pool.invoke()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误：绕过工作窃取优化</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    pool.submit(left);  <span class="hljs-comment">// 提交到共享队列，失去局部性</span><br>    pool.invoke(right); <span class="hljs-comment">// 完全阻塞当前线程</span><br>&#125;<br><br><span class="hljs-comment">// 正确：使用 fork/join API</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    left.fork();           <span class="hljs-comment">// 无锁本地队列 push</span><br>    right.compute();       <span class="hljs-comment">// 保持缓存局部性</span><br>    left.join();           <span class="hljs-comment">// 协作式等待</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="i-o阻塞错误与资源泄漏">I/O阻塞错误与资源泄漏</h3>
<p>详见 <a href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%95">线程池横切对比 - 常见错误用法</a>。</p>
<h2 id="父子任务死锁：传统线程池的致命缺陷与forkjoinpool的解决方案">父子任务死锁：传统线程池的致命缺陷与ForkJoinPool的解决方案</h2>
<h3 id="问题场景：线程池饥饿死锁">问题场景：线程池饥饿死锁</h3>
<p>在使用传统<code>ThreadPoolExecutor</code>时，一个经典的陷阱是<strong>父子任务使用同一线程池导致的死锁</strong>。</p>
<h4 id="死锁复现代码">死锁复现代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolDeadlockDemo</span> &#123;<br>    <span class="hljs-comment">// 固定大小的线程池，只有2个线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 提交2个父任务，恰好占满线程池</span><br>        Future&lt;Integer&gt; f1 = pool.submit(() -&gt; parentTask(<span class="hljs-string">&quot;Parent-1&quot;</span>));<br>        Future&lt;Integer&gt; f2 = pool.submit(() -&gt; parentTask(<span class="hljs-string">&quot;Parent-2&quot;</span>));<br>        <br>        <span class="hljs-comment">// 永远无法完成 -- 死锁</span><br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + f1.get() + <span class="hljs-string">&quot;, &quot;</span> + f2.get());<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">parentTask</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(name + <span class="hljs-string">&quot; started on &quot;</span> + Thread.currentThread().getName());<br>        <br>        <span class="hljs-comment">// 父任务提交子任务到同一个线程池</span><br>        Future&lt;Integer&gt; childFuture = pool.submit(() -&gt; childTask(name));<br>        <br>        <span class="hljs-comment">// 父任务阻塞等待子任务完成</span><br>        <span class="hljs-comment">// 但子任务在队列中等待线程，而所有线程都被父任务占用</span><br>        <span class="hljs-keyword">return</span> childFuture.get(); <span class="hljs-comment">// 死锁点</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">childTask</span><span class="hljs-params">(String parentName)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child of &quot;</span> + parentName + <span class="hljs-string">&quot; on &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="死锁分析">死锁分析</h4>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">时间线：<br>T1: Parent<span class="hljs-string">-1</span> 提交，获得 Thread<span class="hljs-string">-1</span>，开始执行<br>T2: Parent<span class="hljs-string">-2</span> 提交，获得 Thread<span class="hljs-string">-2</span>，开始执行<br>T3: Parent<span class="hljs-string">-1</span> 提交 Child<span class="hljs-string">-1</span> 到队列，调用 childFuture.get() 阻塞<br>T4: Parent<span class="hljs-string">-2</span> 提交 Child<span class="hljs-string">-2</span> 到队列，调用 childFuture.get() 阻塞<br>T5: 死锁形成<br>    - Thread<span class="hljs-string">-1</span> 被 Parent<span class="hljs-string">-1</span> 占用，等待 Child<span class="hljs-string">-1</span><br>    - Thread<span class="hljs-string">-2</span> 被 Parent<span class="hljs-string">-2</span> 占用，等待 Child<span class="hljs-string">-2</span><br>    - Child<span class="hljs-string">-1</span> 和 Child<span class="hljs-string">-2</span> 在队列中，等待空闲线程<br>    - 没有空闲线程，因为都被父任务占用<br></code></pre></td></tr></table></figure>
<p>这就是经典的<strong>线程池饥饿死锁</strong>（Thread Pool Starvation Deadlock）：</p>
<ul>
<li><strong>必要条件1</strong>：父任务持有线程资源</li>
<li><strong>必要条件2</strong>：父任务阻塞等待子任务</li>
<li><strong>必要条件3</strong>：子任务需要线程资源才能执行</li>
<li><strong>必要条件4</strong>：线程池容量有限</li>
</ul>
<h3 id="传统解决方案的局限性">传统解决方案的局限性</h3>
<h4 id="方案1：增大线程池容量">方案1：增大线程池容量</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>无法预知任务的嵌套深度</li>
<li>递归分治算法的任务数量呈指数增长</li>
<li>过大的线程池浪费资源，过小仍可能死锁</li>
</ul>
<h4 id="方案2：使用无界线程池">方案2：使用无界线程池</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>失去对并发度的控制</li>
<li>可能创建过多线程，导致OOM或上下文切换开销</li>
<li>不适合生产环境</li>
</ul>
<h4 id="方案3：父子任务使用不同线程池">方案3：父子任务使用不同线程池</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">parentPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">childPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>需要预知任务层级结构</li>
<li>多层嵌套需要多个线程池</li>
<li>资源利用率低，管理复杂</li>
</ul>
<h3 id="forkjoinpool的根本性解决：协作式等待">ForkJoinPool的根本性解决：协作式等待</h3>
<p>ForkJoinPool通过<strong>协作式等待</strong>（Cooperative Waiting）从根本上解决了这个问题。</p>
<h4 id="核心机制：join-不是真正的阻塞">核心机制：join()不是真正的阻塞</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinTask.join() 的简化逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)<br>        reportException(s);<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doJoin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;<br>    <br>    <span class="hljs-comment">// 1. 检查任务是否已完成</span><br>    <span class="hljs-keyword">if</span> ((s = status) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> s;<br>    <br>    <span class="hljs-comment">// 2. 如果当前线程是 ForkJoinWorkerThread</span><br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) &#123;<br>        wt = (ForkJoinWorkerThread)t;<br>        w = wt.workQueue;<br>        <br>        <span class="hljs-comment">// 3. 尝试从本地队列弹出并执行目标任务</span><br>        <span class="hljs-keyword">if</span> (w.tryUnpush(<span class="hljs-built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> s;<br>        <br>        <span class="hljs-comment">// 4. 如果目标任务不在本地队列顶部，进入协作等待</span><br>        <span class="hljs-keyword">return</span> wt.pool.awaitJoin(w, <span class="hljs-built_in">this</span>, <span class="hljs-number">0L</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 5. 非 ForkJoinWorkerThread，使用外部等待</span><br>    <span class="hljs-keyword">return</span> externalAwaitDone();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="协作等待的核心：awaitjoin">协作等待的核心：awaitJoin()</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinPool.awaitJoin() 的简化逻辑</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitJoin</span><span class="hljs-params">(WorkQueue w, ForkJoinTask&lt;?&gt; task, <span class="hljs-type">long</span> deadline)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 循环直到任务完成</span><br>        <span class="hljs-keyword">while</span> ((s = task.status) &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 关键：不是阻塞等待，而是尝试帮助执行</span><br>            <span class="hljs-keyword">if</span> (!tryHelpStealer(w, task))  <span class="hljs-comment">// 尝试帮助窃取者</span><br>                <span class="hljs-keyword">if</span> (!tryCompensate(w))      <span class="hljs-comment">// 尝试补偿（创建新线程）</span><br>                    LockSupport.park(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 仅当无事可做时才真正阻塞</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="帮助窃取者机制-help-stealer">帮助窃取者机制（Help Stealer）</h4>
<p>当线程A等待任务T完成时，如果T被线程B窃取：</p>
<ol>
<li>A不会阻塞等待</li>
<li>A会扫描B的工作队列</li>
<li>A帮助执行B队列中的任务（可能是T的子任务）</li>
<li>通过帮助B，间接加速T的完成</li>
</ol>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">场景：<span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span> 执行 <span class="hljs-variable">Parent</span>，<span class="hljs-variable">fork</span> 了 <span class="hljs-variable">Child</span>，然后 <span class="hljs-variable">join</span><span class="hljs-punctuation">(</span><span class="hljs-variable">Child</span><span class="hljs-punctuation">)</span><br>      <span class="hljs-variable">Child</span> 被 <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> 窃取<br><br>传统线程池：<br>  <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span>阻塞等待 <span class="hljs-variable">Child</span> 完成<span class="hljs-punctuation">]</span> <span class="hljs-operator">&lt;--</span> 线程资源浪费<br>  <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span>执行 <span class="hljs-variable">Child</span><span class="hljs-punctuation">]</span><br><br><span class="hljs-variable">ForkJoinPool</span>：<br>  <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span>发现 <span class="hljs-variable">Child</span> 被 <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> 窃取<span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">[</span>扫描 <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> 的队列<span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">[</span>帮助执行 <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> 队列中的其他任务<span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">[</span>间接加速 <span class="hljs-variable">Child</span> 完成<span class="hljs-punctuation">]</span><br>  <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span>执行 <span class="hljs-variable">Child</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>
<h3 id="为什么父子任务可以不相互阻塞？">为什么父子任务可以不相互阻塞？</h3>
<p>这个问题的答案涉及ForkJoinTask接口设计的精妙之处：</p>
<h4 id="接口层面的异步化解耦">接口层面的异步化解耦</h4>
<p><code>ForkJoinTask</code>的<code>fork()</code>和<code>join()</code>方法在接口设计上实现了<strong>计算与等待的解耦</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// fork() 只是将任务入队，不执行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">()</span> &#123;<br>    Thread t;<br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread)<br>        ((ForkJoinWorkerThread)t).workQueue.push(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">else</span><br>        ForkJoinPool.common.externalPush(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br><span class="hljs-comment">// join() 不是简单等待，而是&quot;参与式等待&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (doJoin() != NORMAL)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键设计点</strong>：</p>
<ol>
<li><strong>fork()是纯异步的</strong>：只负责将任务放入队列，立即返回</li>
<li><strong>join()是协作式的</strong>：不是被动等待，而是主动寻找可执行的工作</li>
<li><strong>compute()是可分解的</strong>：子类通过重写compute()定义分解逻辑</li>
</ol>
<h4 id="分治模式的天然适配">分治模式的天然适配</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (任务足够小) &#123;<br>        <span class="hljs-keyword">return</span> 直接计算();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 分解</span><br>    <span class="hljs-type">SubTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTask</span>(左半部分);<br>    <span class="hljs-type">SubTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTask</span>(右半部分);<br>    <br>    <span class="hljs-comment">// fork() 只是入队，不阻塞</span><br>    left.fork();<br>    <br>    <span class="hljs-comment">// 当前线程直接执行 right，不入队</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightResult</span> <span class="hljs-operator">=</span> right.compute();<br>    <br>    <span class="hljs-comment">// join() 时，如果 left 还在本地队列，直接弹出执行</span><br>    <span class="hljs-comment">// 如果被窃取，则帮助窃取者执行其他任务</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftResult</span> <span class="hljs-operator">=</span> left.join();<br>    <br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-keyword">return</span> leftResult + rightResult;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么不会死锁</strong>：</p>
<ol>
<li><code>right.compute()</code>直接在当前线程执行，不占用额外线程</li>
<li><code>left.join()</code>时，如果left还在本地队列顶部，直接弹出执行（tryUnpush）</li>
<li>如果left被窃取，当前线程不会阻塞，而是帮助执行其他任务</li>
<li>即使所有线程都在&quot;等待&quot;，它们实际上都在执行任务</li>
</ol>
<h3 id="线程补偿机制：有限度的弹性">线程补偿机制：有限度的弹性</h3>
<h4 id="线程可以无限补偿吗？">线程可以无限补偿吗？</h4>
<p><strong>答案是否定的</strong>。ForkJoinPool的线程补偿受到<code>maximumSpares</code>参数的严格限制。</p>
<h4 id="补偿机制的工作原理">补偿机制的工作原理</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// tryCompensate() 的简化逻辑</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryCompensate</span><span class="hljs-params">(WorkQueue w)</span> &#123;<br>    <span class="hljs-comment">// 检查是否可以创建补偿线程</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(ctl &amp; ~SMASK);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> config &amp; SMASK;  <span class="hljs-comment">// parallelism</span><br>    <br>    <span class="hljs-comment">// 计算当前spare线程数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(ctl &gt;&gt;&gt; TC_SHIFT);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(ctl &gt;&gt; AC_SHIFT);<br>    <br>    <span class="hljs-comment">// 如果spare线程数已达上限，不再创建</span><br>    <span class="hljs-keyword">if</span> (tc &gt;= pc + MAX_SPARES) <span class="hljs-comment">// MAX_SPARES 默认为 256</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 创建补偿线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 条件满足 */</span>) &#123;<br>        createWorker();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="线程数的硬性上限">线程数的硬性上限</h4>
<p>ForkJoinPool的线程数永远不会超过：<strong>parallelism + maximumSpares</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 系统属性配置</span><br>java.util.concurrent.ForkJoinPool.common.maximumSpares = <span class="hljs-number">256</span> <span class="hljs-comment">// 默认值</span><br></code></pre></td></tr></table></figure>
<h4 id="当达到上限后会发生什么？">当达到上限后会发生什么？</h4>
<ol>
<li><strong>无法创建新的补偿线程</strong></li>
<li><strong>tryCompensate()返回false</strong></li>
<li><strong>线程进入真正的阻塞等待</strong>（LockSupport.park）</li>
<li><strong>如果所有线程都阻塞，可能导致吞吐量下降</strong></li>
</ol>
<h4 id="为什么要限制补偿？">为什么要限制补偿？</h4>
<ol>
<li><strong>防止线程爆炸</strong>：无限补偿可能导致创建过多线程</li>
<li><strong>资源保护</strong>：每个线程都消耗栈内存（默认1MB）</li>
<li><strong>上下文切换开销</strong>：过多线程导致调度开销增加</li>
<li><strong>设计哲学</strong>：ForkJoinPool假设任务是CPU密集型的，不应频繁阻塞</li>
</ol>
<h4 id="最佳实践">最佳实践</h4>
<ol>
<li><strong>避免在ForkJoinTask中执行阻塞I/O</strong></li>
<li><strong>如果必须阻塞，使用ManagedBlocker接口</strong></li>
<li><strong>合理设置parallelism和maximumSpares</strong></li>
<li><strong>监控getPoolSize()和getActiveThreadCount()</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用ManagedBlocker处理阻塞操作</span><br>ForkJoinPool.managedBlock(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>.ManagedBlocker() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">block</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 执行阻塞操作</span><br>        result = blockingOperation();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReleasable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 检查是否已完成</span><br>        <span class="hljs-keyword">return</span> result != <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="对比验证">对比验证</h3>
<h4 id="forkjoinpool版本-不会死锁">ForkJoinPool版本（不会死锁）</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinNoDeadlockDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentTask</span>(<span class="hljs-string">&quot;Root&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result); <span class="hljs-comment">// 正常完成</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>        <br>        ParentTask(String name) &#123; <span class="hljs-built_in">this</span>.name = name; &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(name + <span class="hljs-string">&quot; on &quot;</span> + Thread.currentThread().getName());<br>            <br>            <span class="hljs-comment">// 创建子任务</span><br>            <span class="hljs-type">ChildTask</span> <span class="hljs-variable">child1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildTask</span>(name + <span class="hljs-string">&quot;-Child1&quot;</span>);<br>            <span class="hljs-type">ChildTask</span> <span class="hljs-variable">child2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildTask</span>(name + <span class="hljs-string">&quot;-Child2&quot;</span>);<br>            <br>            <span class="hljs-comment">// fork 子任务</span><br>            child1.fork();<br>            child2.fork();<br>            <br>            <span class="hljs-comment">// join 不会死锁</span><br>            <span class="hljs-comment">// 当前线程会帮助执行子任务，而不是阻塞等待</span><br>            <span class="hljs-keyword">return</span> child1.join() + child2.join();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>        <br>        ChildTask(String name) &#123; <span class="hljs-built_in">this</span>.name = name; &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(name + <span class="hljs-string">&quot; on &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">21</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="执行结果">执行结果</h4>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Root</span> <span class="hljs-literal">on</span> ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span><br><span class="hljs-attribute">Root</span>-Child1 <span class="hljs-literal">on</span> ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>  // 父线程帮助执行子任务<br><span class="hljs-attribute">Root</span>-Child2 <span class="hljs-literal">on</span> ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span><br><span class="hljs-attribute">Result</span>: <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure>
<p>注意：即使只有2个线程，父任务也能完成，因为父线程在<code>join()</code>时直接执行了<code>Child1</code>。</p>
<h3 id="设计启示">设计启示</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>ThreadPoolExecutor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td>等待语义</td>
<td>阻塞等待（浪费线程）</td>
<td>协作等待（帮助执行）</td>
</tr>
<tr>
<td>父子任务</td>
<td>可能死锁</td>
<td>天然支持</td>
</tr>
<tr>
<td>线程利用率</td>
<td>等待时为0</td>
<td>等待时仍在工作</td>
</tr>
<tr>
<td>线程补偿</td>
<td>无</td>
<td>有限度补偿（maximumSpares）</td>
</tr>
<tr>
<td>适用场景</td>
<td>独立任务</td>
<td>分治/递归任务</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>要点</strong>：ForkJoinPool的<code>join()</code>不是&quot;等待&quot;，而是&quot;参与&quot;。线程不会因为等待子任务而闲置，而是主动寻找可执行的工作。这种设计从根本上消除了父子任务死锁的可能性，同时通过有限度的线程补偿机制，在保证系统稳定性的前提下提供了额外的弹性。</p>
</blockquote>
<h2 id="结论：设计的本质">结论：设计的本质</h2>
<p>ForkJoinPool不是&quot;另一个线程池&quot;，而是<strong>为分治并行量身定制的执行引擎</strong>。其核心设计决策源于对问题域的深刻理解：</p>
<ol>
<li><strong>任务结构驱动执行模型</strong>：分治算法的&quot;父-子&quot;任务结构要求特殊的调度策略，工作窃取正是为这种结构优化。</li>
<li><strong>局部性优先于公平性</strong>：LIFO本地执行牺牲任务执行的公平性，换取时间局部性的显著提升。</li>
<li><strong>协作优于竞争</strong>：线程从&quot;竞争共享资源&quot;转变为&quot;协作完成任务&quot;，资源利用率显著提高。</li>
<li><strong>动态适应优于静态配置</strong>：与ThreadPoolExecutor的&quot;核心-最大&quot;静态模型不同，ForkJoinPool通过目标并行度+spare线程机制，动态适应工作负载。</li>
<li><strong>资源效率优于固定开销</strong>：与TPE保持核心线程不同，FJP回收所有空闲线程，适合间歇性负载。</li>
</ol>
<p>正如Doug Lea在论文结论中所述：</p>
<blockquote>
<p>“This paper has demonstrated that it is possible to support portable, efficient, scalable parallel processing in pure Java, with a programming model and framework that can be convenient for programmers.”</p>
<p>（本论文证明了，纯粹的Java语言也能够实现可移植、高效可伸缩的并行处理，并且能够为程序员提供便捷的编程模型和框架。）</p>
</blockquote>
<p>理解ForkJoinPool的核心数据结构和设计哲学，才能在正确场景发挥其价值。它不是万能的，但在分治并行领域，它代表了并发计算的理论最优解。</p>
<p><strong>ForkJoinPool参考文献</strong>：</p>
<ul>
<li>Doug Lea. “A Java Fork/Join Framework”. In Proceedings of the ACM 2000 conference on Java Grande, 2000. <a target="_blank" rel="noopener" href="https://gee.cs.oswego.edu/dl/papers/fj.pdf">https://gee.cs.oswego.edu/dl/papers/fj.pdf</a></li>
</ul>
<hr>
<h1>三种线程池的 execute() 实现对比</h1>
<p>Executor 接口只定义了一个方法 <code>execute(Runnable)</code>，但三种线程池实现赋予了它完全不同的语义。理解这些差异，有助于选择正确的线程池类型。</p>
<blockquote>
<p>本节聚焦 execute 方法实现差异。关于队列架构、异常处理、生命周期管理的全面对比，见 <a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%AA%E5%88%87%E5%AF%B9%E6%AF%94">线程池横切对比</a> 章节。</p>
</blockquote>
<h2 id="实现对比总览">实现对比总览</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>ThreadPoolExecutor</th>
<th>ScheduledThreadPoolExecutor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>execute 语义</strong></td>
<td>立即执行</td>
<td>延迟为0的调度</td>
<td>包装后提交外部队列</td>
</tr>
<tr>
<td><strong>是否调用父类 execute</strong></td>
<td>N/A（基类）</td>
<td>否，重写为 schedule(0)</td>
<td>N/A（独立实现）</td>
</tr>
<tr>
<td><strong>任务入队方式</strong></td>
<td>条件判断后入队或创建线程</td>
<td>直接 add + ensurePrestart</td>
<td>包装后 externalPush</td>
</tr>
<tr>
<td><strong>线程创建时机</strong></td>
<td>execute 中动态判断</td>
<td>ensurePrestart 预创建</td>
<td>懒加载</td>
</tr>
<tr>
<td><strong>队列访问</strong></td>
<td>通过 queue 成员</td>
<td>super.getQueue()</td>
<td>externalPush → 共享队列</td>
</tr>
</tbody>
</table>
<h2 id="threadpoolexecutor：经典的-三段式-判断">ThreadPoolExecutor：经典的&quot;三段式&quot;判断</h2>
<p>ThreadPoolExecutor 的 execute() 实现是最经典的线程池调度逻辑：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">任务到达 → workerCount &lt; core? → 创建核心线程<br>         → 队列未满? → 入队等待<br>         → workerCount &lt; <span class="hljs-built_in">max</span>? → 创建非核心线程<br>         → 触发拒绝策略<br></code></pre></td></tr></table></figure>
<p><strong>核心特点</strong>：</p>
<ol>
<li>execute 内部包含完整的调度逻辑（线程创建、入队、拒绝）</li>
<li>线程创建是动态的，根据当前状态实时决策</li>
<li>队列通过构造器注入，execute 只负责使用</li>
</ol>
<p>这是其他线程池设计的&quot;参照系&quot;——理解它才能理解其他实现为何不同。</p>
<h2 id="scheduledthreadpoolexecutor：语义转换-直接入队">ScheduledThreadPoolExecutor：语义转换 + 直接入队</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    schedule(command, <span class="hljs-number">0</span>, NANOSECONDS);  <span class="hljs-comment">// 重写为 schedule(0)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>schedule()</code> 内部调用 <code>delayedExecute()</code> 直接入队。<code>delayedExecute()</code> 的详细实现见 <a href="#scheduledexecutorservice-%E4%B8%8E-abstractexecutorservice-%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BE%A8%E6%9E%90">ScheduledExecutorService 与 AbstractExecutorService 的关系辨析</a> 章节。</p>
<p><strong>设计意图</strong>：</p>
<ol>
<li><strong>API 兼容</strong>：继承 ThreadPoolExecutor，必须实现 execute() 接口</li>
<li><strong>强制统一路径</strong>：所有任务都走 schedule → DelayedWorkQueue，确保延时语义一致</li>
<li><strong>跳过三段式判断</strong>：直接入队 + ensurePrestart，因为定时任务不适合&quot;队列满则创建线程&quot;的逻辑</li>
</ol>
<p><strong>为什么不调用 super.execute()?</strong></p>
<p>如果调用 <code>super.execute(command)</code>，任务会走父类的三段式判断。虽然 ScheduledThreadPoolExecutor 构造器已硬编码 DelayedWorkQueue，但 execute 也必须重写才能确保所有任务都走统一的 schedule 路径，而非父类的入队逻辑。</p>
<h2 id="forkjoinpool：包装-外部队列">ForkJoinPool：包装 + 外部队列</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    ForkJoinTask&lt;?&gt; job;<br>    <span class="hljs-keyword">if</span> (task <span class="hljs-keyword">instanceof</span> ForkJoinTask)<br>        job = (ForkJoinTask&lt;?&gt;) task;  <span class="hljs-comment">// 已是 ForkJoinTask，无需包装</span><br>    <span class="hljs-keyword">else</span><br>        job = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableExecuteAdapter</span>(task);  <span class="hljs-comment">// 包装为 ForkJoinTask</span><br>    externalPush(job);  <span class="hljs-comment">// 提交到外部队列</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计意图</strong>：</p>
<ol>
<li><strong>类型适配</strong>：Runnable 必须包装为 ForkJoinTask 才能进入工作窃取体系</li>
<li><strong>统一入口</strong>：无论外部提交还是内部 fork，最终都通过 externalPush 进入队列</li>
<li><strong>独立体系</strong>：ForkJoinPool 继承 AbstractExecutorService 而非 ThreadPoolExecutor，execute 是全新实现</li>
</ol>
<p><strong>externalPush vs super.execute</strong>：</p>
<p>ForkJoinPool 没有继承 ThreadPoolExecutor，所以不存在&quot;是否调用父类 execute&quot;的问题。它的 execute 实现是独立设计的，核心是：</p>
<ul>
<li>包装任务（如果需要）</li>
<li>提交到共享的 external queue</li>
<li>工作窃取机制负责后续调度</li>
</ul>
<h2 id="对比图示">对比图示</h2>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css">ThreadPoolExecutor:<br><span class="hljs-built_in">execute</span>(Runnable) ──┬── workerCount &lt; core? ──→ <span class="hljs-built_in">addWorker</span>() 创建核心线程<br>                    ├── 队列未满? ──→ queue.<span class="hljs-built_in">offer</span>() 入队<br>                    ├── workerCount &lt; max? ──→ <span class="hljs-built_in">addWorker</span>() 创建非核心线程<br>                    └── else ──→ <span class="hljs-built_in">reject</span>() 拒绝<br><br>ScheduledThreadPoolExecutor:<br><span class="hljs-built_in">execute</span>(Runnable) ──→ <span class="hljs-built_in">schedule</span>(<span class="hljs-number">0</span>) ──→ <span class="hljs-built_in">delayedExecute</span>()<br>                                            ├── super.<span class="hljs-built_in">getQueue</span>().<span class="hljs-built_in">add</span>(task)  // 直接入队<br>                                            └── <span class="hljs-built_in">ensurePrestart</span>()            // 确保线程存在<br><br>ForkJoinPool:<br><span class="hljs-built_in">execute</span>(Runnable) ──→ 包装为 ForkJoinTask ──→ <span class="hljs-built_in">externalPush</span>(job)<br>                                              └→ 提交到共享队列<br>                                                 └→ 工作窃取调度<br></code></pre></td></tr></table></figure>
<h2 id="核心洞察">核心洞察</h2>
<p>三种实现的差异源于各自的<strong>设计目标</strong>：</p>
<table>
<thead>
<tr>
<th>设计目标</th>
<th>execute 实现策略</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ThreadPoolExecutor</strong>：通用任务执行</td>
<td>execute 包含完整调度逻辑，灵活但复杂</td>
</tr>
<tr>
<td><strong>ScheduledThreadPoolExecutor</strong>：延时/周期调度</td>
<td>execute 语义转换，强制走延时队列</td>
</tr>
<tr>
<td><strong>ForkJoinPool</strong>：分治并行计算</td>
<td>execute 是适配层，核心在工作窃取</td>
</tr>
</tbody>
</table>
<p>一句话总结：<strong>ThreadPoolExecutor 的 execute 是调度中枢；ScheduledThreadPoolExecutor 的 execute 是语义转换；ForkJoinPool 的 execute 是类型适配</strong>。</p>
<hr>
<h2 id="三种线程池的-workqueue-对比">三种线程池的 WorkQueue 对比</h2>
<p>Java 线程池体系中的三种核心实现——ThreadPoolExecutor、ScheduledThreadPoolExecutor 和 ForkJoinPool——在任务队列的设计上有着根本性的差异。这些差异直接决定了它们各自的适用场景和性能特征。</p>
<blockquote>
<p>本节聚焦队列架构差异。关于异常处理、生命周期管理的全面对比，见 <a href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A8%AA%E5%88%87%E5%AF%B9%E6%AF%94">线程池横切对比</a> 章节。</p>
</blockquote>
<h3 id="队列架构对比">队列架构对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>ThreadPoolExecutor</th>
<th>ScheduledThreadPoolExecutor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>队列类型</strong></td>
<td>单一共享阻塞队列</td>
<td>单一共享延迟队列</td>
<td>每线程私有双端队列</td>
</tr>
<tr>
<td><strong>队列实现</strong></td>
<td><code>BlockingQueue&lt;Runnable&gt;</code>（可配置）</td>
<td><code>DelayedWorkQueue</code>（内置）</td>
<td><code>WorkQueue[]</code>（内置）</td>
</tr>
<tr>
<td><strong>数据结构</strong></td>
<td>链表/数组（依具体实现）</td>
<td>二叉堆（最小堆）</td>
<td>环形数组</td>
</tr>
<tr>
<td><strong>访问模式</strong></td>
<td>FIFO（先进先出）</td>
<td>按时间优先级</td>
<td>LIFO/FIFO（可配置）</td>
</tr>
<tr>
<td><strong>线程竞争</strong></td>
<td>高（所有线程共享）</td>
<td>高（所有线程共享）</td>
<td>低（本地操作无锁）</td>
</tr>
</tbody>
</table>
<h3 id="threadpoolexecutor-的-blockingqueue">ThreadPoolExecutor 的 BlockingQueue</h3>
<p>ThreadPoolExecutor 使用单一共享的 <code>BlockingQueue&lt;Runnable&gt;</code> 作为任务缓冲区，这是最经典的<strong>生产者-消费者</strong>模式。</p>
<p><strong>核心特性</strong>：</p>
<ul>
<li><strong>可配置性</strong>：允许用户在构造时传入任意 <code>BlockingQueue</code> 实现</li>
<li><strong>共享竞争</strong>：所有工作线程从同一队列获取任务，存在锁竞争</li>
<li><strong>容量可控</strong>：可选择有界队列（防止 OOM）或无界队列（提高吞吐）</li>
</ul>
<p><strong>常用队列选择</strong>：</p>
<table>
<thead>
<tr>
<th>队列类型</th>
<th>有界性</th>
<th>适用场景</th>
<th>风险</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ArrayBlockingQueue</code></td>
<td>有界</td>
<td>生产消费速率相近，需控制内存</td>
<td>无</td>
</tr>
<tr>
<td><code>LinkedBlockingQueue</code></td>
<td>可配置</td>
<td>IO 密集型，需要缓冲</td>
<td>默认无界，可能 OOM</td>
</tr>
<tr>
<td><code>SynchronousQueue</code></td>
<td>无容量</td>
<td>任务需立即执行，CachedThreadPool</td>
<td>可能创建大量线程</td>
</tr>
<tr>
<td><code>PriorityBlockingQueue</code></td>
<td>无界</td>
<td>任务有优先级区分</td>
<td>可能 OOM</td>
</tr>
</tbody>
</table>
<p><strong>任务调度流程</strong>：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade">新任务到达 → 线程数 &lt; core? → 创建核心线程<br>           → 线程数 ≥ core 且队列未满? → 入队等待<br>           → 线程数 ≥ core 且队列已满 且 线程数 &lt; <span class="hljs-built_in">max</span>? → 创建非核心线程<br>           → 线程数 = <span class="hljs-built_in">max</span> 且队列已满? → 触发拒绝策略<br></code></pre></td></tr></table></figure>
<blockquote>
<p>详细说明见 <a href="#threadpoolexecutor-%E4%BB%BB%E5%8A%A1%E7%BC%93%E5%86%B2">ThreadPoolExecutor 任务缓冲</a> 章节。</p>
</blockquote>
<h3 id="scheduledthreadpoolexecutor-的-delayedworkqueue">ScheduledThreadPoolExecutor 的 DelayedWorkQueue</h3>
<p>基于**二叉堆（最小堆）**实现的延迟队列，任务按执行时间排序，最早到期的任务位于堆顶。</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>时间复杂度</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>入队</td>
<td>O(log n)</td>
<td>堆调整</td>
</tr>
<tr>
<td>出队</td>
<td>O(log n)</td>
<td>取堆顶 + 堆调整</td>
</tr>
<tr>
<td>查看队首</td>
<td>O(1)</td>
<td>直接访问堆顶</td>
</tr>
</tbody>
</table>
<p><strong>核心机制</strong>：Leader-Follower 模式避免多线程同时等待导致的唤醒风暴。</p>
<blockquote>
<p>数据结构选择（二叉堆vs跳表）、Leader-Follower 工作原理详见 <a href="#delayedworkqueue-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9">DelayedWorkQueue 的数据结构选择</a>。</p>
</blockquote>
<h3 id="forkjoinpool-的-workqueue">ForkJoinPool 的 WorkQueue</h3>
<p>ForkJoinPool 采用<strong>每线程私有双端队列</strong>的架构，这是<strong>工作窃取</strong>算法的基础。</p>
<p><strong>核心特性</strong>：队列私有化（避免共享竞争）、双端操作（owner 用 top，stealer 用 base）、本地操作无锁化（仅窃取用 CAS）、动态扩容（最大约 6700 万任务）。</p>
<p><strong>数据结构</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkQueue</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> base;          <span class="hljs-comment">// 队列头部索引（窃取端）</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> top;           <span class="hljs-comment">// 队列尾部索引（本地端）</span><br>    ForkJoinTask&lt;?&gt;[] array;    <span class="hljs-comment">// 任务数组（环形缓冲区）</span><br>    <span class="hljs-keyword">final</span> ForkJoinWorkerThread owner; <span class="hljs-comment">// 所属线程</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>操作模式</strong>：owner 从 top 端 push/pop（LIFO/FIFO 由 asyncMode 决定），stealer 从 base 端 poll（始终 FIFO）。</p>
<blockquote>
<p>工作窃取的完整原理、LIFO/FIFO 设计智慧详见 <a href="#%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96work-stealing%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3">工作窃取机制详解</a> 章节。</p>
</blockquote>
<h3 id="三者对比总结">三者对比总结</h3>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs inform7">ThreadPoolExecutor:<br>┌─────────────────────────────────────┐<br>│         BlockingQueue (共享)         │<br>│   <span class="hljs-comment">[T1]</span><span class="hljs-comment">[T2]</span><span class="hljs-comment">[T3]</span><span class="hljs-comment">[T4]</span><span class="hljs-comment">[T5]</span><span class="hljs-comment">[T6]</span><span class="hljs-comment">[T7]</span>      │<br>└──────────────┬──────────────────────┘<br>               │ FIFO<br>     ┌─────────┼─────────┐<br>     ↓         ↓         ↓<br>  <span class="hljs-comment">[Worker1]</span> <span class="hljs-comment">[Worker2]</span> <span class="hljs-comment">[Worker3]</span><br>  (竞争锁)<br><br>ScheduledThreadPoolExecutor:<br>┌─────────────────────────────────────┐<br>│       DelayedWorkQueue (共享)        │<br>│   堆结构：按时间排序                 │<br>│      <span class="hljs-comment">[T1s后]</span>                        │<br>│     /      \                        │<br>│ <span class="hljs-comment">[T3s后]</span>  <span class="hljs-comment">[T2s后]</span>                    │<br>└──────────────┬──────────────────────┘<br>               │ 按到期时间<br>     ┌─────────┼─────────┐<br>     ↓         ↓         ↓<br>  <span class="hljs-comment">[Worker1]</span> <span class="hljs-comment">[Worker2]</span> <span class="hljs-comment">[Worker3]</span><br>  (Leader-Follower)<br><br>ForkJoinPool:<br>┌───────────┐ ┌───────────┐ ┌───────────┐<br>│ WorkQueue1 │ │ WorkQueue2 │ │ WorkQueue3 │<br>│ <span class="hljs-comment">[T1]</span><span class="hljs-comment">[T2]</span>  │ │ <span class="hljs-comment">[T3]</span><span class="hljs-comment">[T4]</span>  │ │ <span class="hljs-comment">[T5]</span><span class="hljs-comment">[T6]</span>  │<br>└─────┬─────┘ └─────┬─────┘ └─────┬─────┘<br>      │             │             │<br>      ↓             ↓             ↓<br>  <span class="hljs-comment">[Worker1]</span>     <span class="hljs-comment">[Worker2]</span>     <span class="hljs-comment">[Worker3]</span><br>      │             │             │<br>      └─────窃取────┴─────窃取────┘<br>        (无锁本地操作 + CAS窃取)<br></code></pre></td></tr></table></figure>
<p><strong>设计哲学对比</strong>：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>ThreadPoolExecutor</th>
<th>ScheduledThreadPoolExecutor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>调度模型</strong></td>
<td>生产者-消费者</td>
<td>定时调度</td>
<td>工作窃取</td>
</tr>
<tr>
<td><strong>队列目的</strong></td>
<td>解耦 + 缓冲</td>
<td>时间排序 + 延迟执行</td>
<td>负载均衡 + 局部性</td>
</tr>
<tr>
<td><strong>竞争点</strong></td>
<td>队列锁</td>
<td>队列锁</td>
<td>窃取时 CAS</td>
</tr>
<tr>
<td><strong>拒绝策略</strong></td>
<td>必须配置</td>
<td>继承自 TPE</td>
<td>无需配置（队列动态扩容）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>通用任务</td>
<td>定时/周期任务</td>
<td>分治并行计算</td>
</tr>
</tbody>
</table>
<hr>
<h1>线程池横切对比</h1>
<p>本章节横切对比 ThreadPoolExecutor、ScheduledThreadPoolExecutor、ForkJoinPool 三种线程池实现在异常处理、生命周期管理、监控指标等方面的差异。</p>
<h2 id="异常处理汇总">异常处理汇总</h2>
<h3 id="三种线程池的异常处理对比">三种线程池的异常处理对比</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>ThreadPoolExecutor</th>
<th>ScheduledThreadPoolExecutor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>任务异常传播</strong></td>
<td>Worker继续存活，取下一个任务</td>
<td>周期任务异常导致后续调度终止</td>
<td>任务状态记录异常，不影响其他任务</td>
</tr>
<tr>
<td><strong>异常捕获位置</strong></td>
<td>Worker.run() 的 finally 块</td>
<td>FutureTask.runAndReset()</td>
<td>ForkJoinTask.setException()</td>
</tr>
<tr>
<td><strong>异常后线程行为</strong></td>
<td>线程继续存活</td>
<td>线程继续存活，但任务不再调度</td>
<td>线程继续存活</td>
</tr>
<tr>
<td><strong>异常获取方式</strong></td>
<td>Future.get() 抛出 ExecutionException</td>
<td>Future.get() 永久阻塞（周期任务）</td>
<td>ForkJoinTask.get() 抛出 ExecutionException</td>
</tr>
</tbody>
</table>
<h3 id="threadpoolexecutor-异常处理">ThreadPoolExecutor 异常处理</h3>
<p>普通任务抛出未捕获异常后，Worker 线程继续存活，从队列取下一个任务。异常可通过 <code>Future.get()</code> 获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正确做法：任务内部捕获异常</span><br>executor.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        riskyOperation();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        logger.error(<span class="hljs-string">&quot;Task failed&quot;</span>, t);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="scheduledthreadpoolexecutor-异常处理">ScheduledThreadPoolExecutor 异常处理</h3>
<p><strong>铁律</strong>：周期任务必须用 <code>try-catch(Throwable)</code> 包裹全部逻辑，否则任务会在首次异常后停止后续调度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正确做法：周期任务必须捕获所有异常</span><br>scheduler.scheduleAtFixedRate(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        periodicTask();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        logger.error(<span class="hljs-string">&quot;Periodic task failed, will continue&quot;</span>, t);<br>    &#125;<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>
<blockquote>
<p>详细源码分析见 <a href="#%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90">周期任务异常终止的深度解析</a>。</p>
</blockquote>
<h3 id="forkjoinpool-异常处理">ForkJoinPool 异常处理</h3>
<p>ForkJoinTask 执行异常会通过 <code>setException()</code> 记录，不影响其他任务。异常可通过 <code>ForkJoinTask.get()</code> 或 <code>ForkJoinTask.exception()</code> 获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinTask 异常处理</span><br>ForkJoinTask&lt;?&gt; task = pool.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Task failed&quot;</span>);<br>&#125;);<br><br><span class="hljs-keyword">try</span> &#123;<br>    task.get();  <span class="hljs-comment">// 抛出 ExecutionException</span><br>&#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>    logger.error(<span class="hljs-string">&quot;Task failed&quot;</span>, e.getCause());<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="常见错误用法">常见错误用法</h3>
<h4 id="错误1-使用无界队列导致oom">错误1: 使用无界队列导致OOM</h4>
<p><code>newFixedThreadPool</code> 使用 <code>LinkedBlockingQueue</code>（默认容量 Integer.MAX_VALUE），任务积压会导致堆内存耗尽。</p>
<p><strong>正确做法</strong>：使用有界队列 + 拒绝策略。</p>
<h4 id="错误2-newcachedthreadpool导致线程爆炸">错误2: newCachedThreadPool导致线程爆炸</h4>
<p><code>newCachedThreadPool</code> 最大线程数为 Integer.MAX_VALUE，任务持续提交会无限创建线程。</p>
<p><strong>正确做法</strong>：限制最大线程数。</p>
<h4 id="错误3-不设置线程名称导致排查困难">错误3: 不设置线程名称导致排查困难</h4>
<p>默认线程名为 <code>pool-1-thread-1</code>，多个线程池时无法区分。</p>
<p><strong>正确做法</strong>：自定义 ThreadFactory 设置有意义的名称。</p>
<h4 id="错误4-shutdown-后立即-awaittermination">错误4: shutdown 后立即 awaitTermination</h4>
<p><code>shutdown()</code> 只是不再接受新任务，队列中的任务还在执行。立即 <code>awaitTermination</code> 可能导致任务丢失。</p>
<p><strong>正确做法</strong>：根据业务设置合理的等待时间，分阶段关闭。</p>
<h4 id="错误5-forkjoinpool-中执行阻塞i-o">错误5: ForkJoinPool 中执行阻塞I/O</h4>
<p>ForkJoinPool 设计用于 CPU 密集型计算，阻塞 I/O 会占用有限的线程资源，导致其他任务无限排队。</p>
<p><strong>正确做法</strong>：I/O 操作使用独立的线程池。</p>
<h4 id="错误6-forkjoinpool-不关闭">错误6: ForkJoinPool 不关闭</h4>
<p>ForkJoinPool 不会自动释放线程池实例持有的内部资源。</p>
<p><strong>正确做法</strong>：显式调用 <code>shutdown()</code> 或使用 try-with-resources（JDK 19+）。</p>
<h2 id="生命周期管理对比">生命周期管理对比</h2>
<h3 id="关闭机制对比">关闭机制对比</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>ThreadPoolExecutor</th>
<th>ScheduledThreadPoolExecutor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>关闭入口</strong></td>
<td>shutdown() / shutdownNow()</td>
<td>继承自 TPE</td>
<td>shutdown() / shutdownNow()</td>
</tr>
<tr>
<td><strong>优雅关闭</strong></td>
<td>awaitTermination()</td>
<td>继承自 TPE</td>
<td>awaitQuiescence()</td>
</tr>
<tr>
<td><strong>状态机</strong></td>
<td>RUNNING → SHUTDOWN/STOP → TIDYING → TERMINATED</td>
<td>继承自 TPE</td>
<td>无显式状态机，通过 ctl 字段管理</td>
</tr>
<tr>
<td><strong>线程回收</strong></td>
<td>依赖 keepAliveTime</td>
<td>继承自 TPE</td>
<td>所有线程空闲时自动回收</td>
</tr>
</tbody>
</table>
<h3 id="threadpoolexecutor-生命周期">ThreadPoolExecutor 生命周期</h3>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">RUNNING（接受新任务，处理队列任务）<br>    ↓ <span class="hljs-built_in">shutdown</span>()<br>SHUTDOWN（拒绝新任务，处理队列任务）<br>    ↓ <span class="hljs-built_in">shutdownNow</span>()<br><span class="hljs-selector-tag">STOP</span>（拒绝新任务，不处理队列任务，中断正在执行任务）<br>    ↓ 队列空且线程数为<span class="hljs-number">0</span><br>TIDYING（执行 <span class="hljs-built_in">terminated</span>() 钩子）<br>    ↓ <span class="hljs-built_in">terminated</span>() 完成<br>TERMINATED（终止完成）<br></code></pre></td></tr></table></figure>
<h3 id="forkjoinpool-生命周期">ForkJoinPool 生命周期</h3>
<p>ForkJoinPool 没有显式的状态机，通过 <code>ctl</code> 字段管理线程状态。所有线程在空闲时都会被回收，不存在 core thread 空转问题。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinPool 优雅关闭</span><br>pool.shutdown();<br><span class="hljs-keyword">if</span> (!pool.awaitTermination(<span class="hljs-number">60</span>, TimeUnit.SECONDS)) &#123;<br>    pool.shutdownNow();<br>&#125;<br><br><span class="hljs-comment">// JDK 19+ 可使用 try-with-resources</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>()) &#123;<br>    pool.invoke(task);<br>&#125; <span class="hljs-comment">// 自动调用 shutdown() 和 awaitTermination()</span><br></code></pre></td></tr></table></figure>
<h2 id="监控指标对比">监控指标对比</h2>
<h3 id="三种线程池的监控api">三种线程池的监控API</h3>
<table>
<thead>
<tr>
<th>指标</th>
<th>ThreadPoolExecutor</th>
<th>ScheduledThreadPoolExecutor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>当前线程数</strong></td>
<td>getPoolSize()</td>
<td>继承自 TPE</td>
<td>getPoolSize()</td>
</tr>
<tr>
<td><strong>活跃线程数</strong></td>
<td>getActiveCount()</td>
<td>继承自 TPE</td>
<td>getActiveThreadCount()</td>
</tr>
<tr>
<td><strong>最大线程数</strong></td>
<td>getMaximumPoolSize()</td>
<td>继承自 TPE</td>
<td>getParallelism()</td>
</tr>
<tr>
<td><strong>队列大小</strong></td>
<td>getQueue().size()</td>
<td>继承自 TPE</td>
<td>getQueuedSubmissionCount()</td>
</tr>
<tr>
<td><strong>已完成任务数</strong></td>
<td>getCompletedTaskCount()</td>
<td>继承自 TPE</td>
<td>getStealCount()（窃取次数）</td>
</tr>
<tr>
<td><strong>拒绝次数</strong></td>
<td>需自行包装 RejectedExecutionHandler</td>
<td>继承自 TPE</td>
<td>无（仅在 shutdown/资源耗尽时拒绝）</td>
</tr>
</tbody>
</table>
<h3 id="threadpoolexecutor-监控实践">ThreadPoolExecutor 监控实践</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心监控指标</span><br><span class="hljs-type">int</span> <span class="hljs-variable">activeCount</span> <span class="hljs-operator">=</span> executor.getActiveCount();<br><span class="hljs-type">int</span> <span class="hljs-variable">poolSize</span> <span class="hljs-operator">=</span> executor.getPoolSize();<br><span class="hljs-type">int</span> <span class="hljs-variable">queueSize</span> <span class="hljs-operator">=</span> executor.getQueue().size();<br><span class="hljs-type">long</span> <span class="hljs-variable">completedTasks</span> <span class="hljs-operator">=</span> executor.getCompletedTaskCount();<br><br><span class="hljs-comment">// 计算活跃度</span><br><span class="hljs-type">double</span> <span class="hljs-variable">activeRatio</span> <span class="hljs-operator">=</span> (<span class="hljs-type">double</span>) activeCount / executor.getMaximumPoolSize();<br><br><span class="hljs-comment">// 计算队列使用率</span><br><span class="hljs-type">int</span> <span class="hljs-variable">queueCapacity</span> <span class="hljs-operator">=</span> queueSize + executor.getQueue().remainingCapacity();<br><span class="hljs-type">double</span> <span class="hljs-variable">queueUsageRatio</span> <span class="hljs-operator">=</span> (<span class="hljs-type">double</span>) queueSize / queueCapacity;<br></code></pre></td></tr></table></figure>
<h3 id="forkjoinpool-监控实践">ForkJoinPool 监控实践</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinPool 特有指标</span><br><span class="hljs-type">long</span> <span class="hljs-variable">stealCount</span> <span class="hljs-operator">=</span> pool.getStealCount();           <span class="hljs-comment">// 总窃取次数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">queuedTasks</span> <span class="hljs-operator">=</span> pool.getQueuedSubmissionCount(); <span class="hljs-comment">// 外部队列任务数</span><br><span class="hljs-type">int</span> <span class="hljs-variable">activeThreads</span> <span class="hljs-operator">=</span> pool.getActiveThreadCount();   <span class="hljs-comment">// 活跃线程数</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isQuiescent</span> <span class="hljs-operator">=</span> pool.awaitQuiescence(<span class="hljs-number">1</span>, TimeUnit.SECONDS); <span class="hljs-comment">// 等待空闲</span><br></code></pre></td></tr></table></figure>
<hr>
<h1>The Executors</h1>
<blockquote>
<p>provides convenient factory methods for these Executors.</p>
</blockquote>
<h2 id="常用工厂方法详解">常用工厂方法详解</h2>
<p><code>java.util.concurrent.Executors</code> 类提供了多个工厂方法用于创建预配置的线程池实现。这些方法简化了常见场景下的线程池创建，但开发者必须理解其内部配置的适用场景和潜在风险。</p>
<pre><code class="hljs mermaid">graph TB
    A[Executors 工厂方法] --&gt; B[newFixedThreadPool]
    A --&gt; C[newCachedThreadPool]
    A --&gt; D[newSingleThreadExecutor]
    A --&gt; E[newSingleThreadScheduledExecutor]
    A --&gt; F[newScheduledThreadPool]
    A --&gt; G[newWorkStealingPool]
    
    B --&gt; B1[&quot;固定大小线程池&quot;]
    B --&gt; B2[&quot;无界队列&quot;]
    B --&gt; B3[&quot;适用于限流场景&quot;]
    
    C --&gt; C1[&quot;可缓存线程池&quot;]
    C --&gt; C2[&quot;SynchronousQueue&quot;]
    C --&gt; C3[&quot;适用于短任务&quot;]
    
    D --&gt; D1[&quot;单线程执行器&quot;]
    D --&gt; D2[&quot;无界队列&quot;]
    D --&gt; D3[&quot;顺序执行保证&quot;]
    
    E --&gt; E1[&quot;单线程调度器&quot;]
    E --&gt; E2[&quot;支持定时/周期&quot;]
    E --&gt; E3[&quot;顺序调度保证&quot;]
    
    F --&gt; F1[&quot;多线程调度器&quot;]
    F --&gt; F2[&quot;支持定时/周期&quot;]
    F --&gt; F3[&quot;固定大小&quot;]
    
    G --&gt; G1[&quot;工作窃取池&quot;]
    G --&gt; G2[&quot;ForkJoinPool&quot;]
    G --&gt; G3[&quot;并行任务优化&quot;]</code></pre>
<h3 id="newfixedthreadpool">newFixedThreadPool</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                  Executors.defaultThreadFactory(),<br>                                  defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>内部配置</strong>：</p>
<ul>
<li>核心线程数：<code>nThreads</code></li>
<li>最大线程数：<code>nThreads</code>（等于核心线程数）</li>
<li>空闲线程存活时间：0</li>
<li>工作队列：<code>LinkedBlockingQueue</code>（无界队列）</li>
<li>拒绝策略：<code>AbortPolicy</code>（抛出 <code>RejectedExecutionException</code>）</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>线程数量固定，资源消耗可预测，适合限流场景</li>
<li>通过无界队列保证任务不会丢失</li>
<li>核心线程不会回收，减少线程创建开销</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>无界队列风险</strong>：任务提交速度持续超过处理速度时，队列会无限增长，可能导致 <code>OutOfMemoryError</code></li>
<li>无法应对突发性任务高峰（因为最大线程数等于核心线程数）</li>
<li>队列积压会导致任务延迟增加</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>任务执行时间相对稳定</li>
<li>需要限制系统资源使用</li>
<li>任务可以接受排队等待</li>
<li>典型应用：数据库连接池辅助、限流的批处理任务</li>
</ul>
<h3 id="newcachedthreadpool">newCachedThreadPool</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;(),<br>                                  Executors.defaultThreadFactory(),<br>                                  defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>内部配置</strong>：</p>
<ul>
<li>核心线程数：0</li>
<li>最大线程数：<code>Integer.MAX_VALUE</code>（理论无界）</li>
<li>空闲线程存活时间：60秒</li>
<li>工作队列：<code>SynchronousQueue</code>（不存储元素，直接传递）</li>
<li>拒绝策略：<code>AbortPolicy</code></li>
</ul>
<p><strong>命名解析</strong>：<br>
&quot;cached&quot;源于其核心的线程缓存复用机制：</p>
<ul>
<li>线程执行完任务后进入60秒缓存期而非立即销毁</li>
<li>缓存期内的新任务可直接复用现有线程</li>
<li>减少线程创建/销毁开销，实现资源的有效利用<br>
这种设计使线程池能够在任务执行间隙实现线程复用，体现了&quot;缓存&quot;的核心语义。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>能够快速响应大量短时任务</li>
<li>空闲线程自动回收，节省资源</li>
<li>无队列积压，任务提交即执行（有空闲线程时）</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>线程数无界风险</strong>：任务提交速度持续超过处理速度时，线程数会无限增长，可能导致 <code>OutOfMemoryError</code> 或系统资源耗尽</li>
<li>不适合长时间运行的任务</li>
<li>线程创建和销毁有性能开销</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>大量短时异步任务</li>
<li>任务执行时间不可预测但通常很短</li>
<li>对响应速度要求高</li>
<li>典型应用：异步日志记录、HTTP 请求分发</li>
</ul>
<h3 id="newsinglethreadexecutor">newSingleThreadExecutor</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                Executors.defaultThreadFactory(),<br>                                defaultHandler));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>内部配置</strong>：</p>
<ul>
<li>核心线程数：1</li>
<li>最大线程数：1</li>
<li>空闲线程存活时间：0</li>
<li>工作队列：<code>LinkedBlockingQueue</code>（无界队列）</li>
<li>拒绝策略：<code>AbortPolicy</code></li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>保证任务按提交顺序执行（FIFO）</li>
<li>无并发安全问题（单线程）</li>
<li>不可重新配置（委托模式封装）</li>
</ul>
<p><strong>套壳机制解析</strong>：</p>
<p><code>FinalizableDelegatedExecutorService</code> 解决两个问题：</p>
<ol>
<li>
<p><strong>防止重新配置</strong>：<code>DelegatedExecutorService</code> 将 <code>ThreadPoolExecutor</code> 包装为仅暴露 <code>ExecutorService</code> 接口，调用者无法强转为 <code>ThreadPoolExecutor</code> 调用 <code>setCorePoolSize()</code> 等方法，从而保证 Javadoc 承诺的&quot;guaranteed not to be reconfigurable to use additional threads&quot;</p>
</li>
<li>
<p><strong>防止资源泄漏</strong>：<code>FinalizableDelegatedExecutorService</code> 在 <code>finalize()</code> 中自动调用 <code>shutdown()</code>，避免用户忘记关闭线程池导致的资源泄漏。JDK 9+ 将其重命名为 <code>AutoShutdownDelegatedExecutorService</code>，语义更清晰</p>
</li>
</ol>
<p>对比：<code>newFixedThreadPool(1)</code> 直接返回 <code>ThreadPoolExecutor</code>，可被强转后修改线程数</p>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>无界队列风险</strong>：任务积压可能导致 OOM</li>
<li>吞吐量受限于单线程性能</li>
<li>任务执行失败会影响后续任务</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>需要保证执行顺序的任务</li>
<li>避免并发竞争的场景</li>
<li>事务性操作（需要串行化）</li>
<li>典型应用：数据库事务操作、文件顺序写入</li>
</ul>
<h3 id="newsinglethreadscheduledexecutor">newSingleThreadScheduledExecutor</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newSingleThreadScheduledExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatedScheduledExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>内部配置</strong>：</p>
<ul>
<li>基于 <code>ScheduledThreadPoolExecutor</code>，核心线程数为1</li>
<li>支持 <code>schedule</code>、<code>scheduleAtFixedRate</code>、<code>scheduleWithFixedDelay</code></li>
<li>使用 <code>DelayedWorkQueue</code> 作为工作队列</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>支持定时和周期性任务</li>
<li>保证任务顺序执行</li>
<li>延迟任务调度精确</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>单线程限制吞吐量</li>
<li>周期任务执行时间过长会影响后续调度</li>
<li>任务异常会导致后续周期任务停止</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>定时任务（如心跳检测）</li>
<li>周期性数据清理</li>
<li>需要严格顺序的定时任务</li>
</ul>
<h3 id="newscheduledthreadpool">newScheduledThreadPool</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>内部配置</strong>：</p>
<ul>
<li>核心线程数：<code>corePoolSize</code></li>
<li>最大线程数：<code>Integer.MAX_VALUE</code></li>
<li>工作队列：<code>DelayedWorkQueue</code></li>
<li>支持延迟和周期性任务</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>支持定时和周期性任务</li>
<li>多线程提高吞吐量</li>
<li>延迟调度精确</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>最大线程数无界</li>
<li>周期任务执行时间过长会影响后续调度</li>
<li>相比 <code>newSingleThreadScheduledExecutor</code> 无顺序保证</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>多定时任务并发执行</li>
<li>周期性任务需要并行处理</li>
<li>批量定时调度</li>
</ul>
<h3 id="newworkstealingpool-jdk-8">newWorkStealingPool（JDK 8+）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newWorkStealingPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span><br>        (Runtime.getRuntime().availableProcessors(),<br>         ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>         <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newWorkStealingPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span><br>        (parallelism,<br>         ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>         <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>内部配置</strong>：</p>
<ul>
<li>基于 <code>ForkJoinPool</code></li>
<li>默认并行度：<code>Runtime.getRuntime().availableProcessors()</code></li>
<li>工作窃取算法优化任务分配</li>
<li>使用 <code>ForkJoinPool.WorkQueue</code></li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>工作窃取算法提高 CPU 利用率</li>
<li>适合分治并行任务</li>
<li>自动负载均衡</li>
<li>支持异步任务和递归任务</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不适合阻塞操作（会降低工作窃取效率）</li>
<li>任务粒度过小会增加调度开销</li>
<li>与传统 <code>ThreadPoolExecutor</code> 语义不同</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>分治算法（如归并排序）</li>
<li>递归并行任务</li>
<li>CPU 密集型并行计算</li>
<li>典型应用：并行流处理、大数据计算</li>
</ul>
<h2 id="工厂方法对比总结">工厂方法对比总结</h2>
<table>
<thead>
<tr>
<th>工厂方法</th>
<th>核心线程数</th>
<th>最大线程数</th>
<th>工作队列</th>
<th>主要风险</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>newFixedThreadPool</code></td>
<td>n</td>
<td>n</td>
<td>LinkedBlockingQueue（无界）</td>
<td>OOM（队列积压）</td>
<td>限流、稳定负载</td>
</tr>
<tr>
<td><code>newCachedThreadPool</code></td>
<td>0</td>
<td>MAX_VALUE</td>
<td>SynchronousQueue</td>
<td>OOM（线程爆炸）</td>
<td>短时任务、突发负载</td>
</tr>
<tr>
<td><code>newSingleThreadExecutor</code></td>
<td>1</td>
<td>1</td>
<td>LinkedBlockingQueue（无界）</td>
<td>OOM（队列积压）</td>
<td>顺序执行、事务操作</td>
</tr>
<tr>
<td><code>newSingleThreadScheduledExecutor</code></td>
<td>1</td>
<td>MAX_VALUE</td>
<td>DelayedWorkQueue</td>
<td>单点瓶颈</td>
<td>定时任务、顺序调度</td>
</tr>
<tr>
<td><code>newScheduledThreadPool</code></td>
<td>n</td>
<td>MAX_VALUE</td>
<td>DelayedWorkQueue</td>
<td>线程爆炸</td>
<td>并发定时任务</td>
</tr>
<tr>
<td><code>newWorkStealingPool</code></td>
<td>parallelism</td>
<td>parallelism</td>
<td>ForkJoinPool.WorkQueue</td>
<td>不适合阻塞任务</td>
<td>分治并行、CPU密集型</td>
</tr>
</tbody>
</table>
<h2 id="生产环境建议">生产环境建议</h2>
<p>根据 Java 并发实践专家的建议（基于 JSR-166 规范和 Javadoc）：</p>
<ol>
<li><strong>避免使用无界队列</strong>：生产环境应使用有界队列（如 <code>ArrayBlockingQueue</code>）或自定义拒绝策略</li>
<li><strong>避免使用无界线程数</strong>：明确设置合理的最大线程数</li>
<li><strong>为线程池命名</strong>：使用自定义 <code>ThreadFactory</code> 设置有意义的线程名称，便于问题排查</li>
<li><strong>显式指定拒绝策略</strong>：根据业务需求选择合适的拒绝策略</li>
<li><strong>监控线程池状态</strong>：通过 <code>ThreadPoolExecutor</code> 提供的监控方法跟踪活跃线程数、队列大小等指标</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 推荐的生产环境配置示例</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>,                              <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-number">20</span>,                              <span class="hljs-comment">// 最大线程数</span><br>    <span class="hljs-number">60L</span>, TimeUnit.SECONDS,           <span class="hljs-comment">// 空闲线程存活时间</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),   <span class="hljs-comment">// 有界队列</span><br>    Executors.defaultThreadFactory(), <span class="hljs-comment">// 默认线程工厂，生产环境建议自定义</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="hljs-comment">// 拒绝策略</span><br>);<br><br><span class="hljs-comment">// 自定义 ThreadFactory 示例（推荐）</span><br><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">customThreadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">namePrefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;worker-&quot;</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, namePrefix + threadNumber.getAndIncrement());<br>        t.setDaemon(<span class="hljs-literal">false</span>);  <span class="hljs-comment">// 非守护线程</span><br>        t.setPriority(Thread.NORM_PRIORITY);<br>        t.setUncaughtExceptionHandler((thread, throwable) -&gt; &#123;<br>            <span class="hljs-comment">// 自定义异常处理逻辑</span><br>            System.err.println(<span class="hljs-string">&quot;线程 &quot;</span> + thread.getName() + <span class="hljs-string">&quot; 发生异常: &quot;</span> + throwable.getMessage());<br>        &#125;);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;    <br><br>    <span class="hljs-comment">// 使用自定义 ThreadFactory 的完整配置</span><br>    <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">productionExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>        <span class="hljs-number">10</span>,<br>        <span class="hljs-number">20</span>,<br>        <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),<br>        customThreadFactory,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()<br>    );<br></code></pre></td></tr></table></figure>
<h2 id="包装方法：unconfigurableexecutorservice">包装方法：unconfigurableExecutorService</h2>
<p>Executors 还提供了一组包装方法，用于将任意线程池转换为不可配置的视图：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">unconfigurableExecutorService</span><span class="hljs-params">(ExecutorService executor)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">unconfigurableScheduledExecutorService</span><span class="hljs-params">(ScheduledExecutorService executor)</span><br></code></pre></td></tr></table></figure>
<p><strong>设计目的</strong>：</p>
<ol>
<li>
<p><strong>安全性</strong>：将线程池暴露给不可信代码时，防止调用者通过强转为 <code>ThreadPoolExecutor</code> 后修改核心参数（线程数、队列、拒绝策略等）</p>
</li>
<li>
<p><strong>API 边界保护</strong>：库/框架作者可向调用者提供线程池实例，同时保留配置控制权</p>
</li>
</ol>
<p><strong>典型场景</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 框架内部创建并配置线程池</span><br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">internalPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>));<br><br><span class="hljs-comment">// 暴露给外部使用，但禁止修改配置</span><br><span class="hljs-keyword">public</span> ExecutorService <span class="hljs-title function_">getExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> Executors.unconfigurableExecutorService(internalPool);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>调用者拿到的实例无法强转为 <code>ThreadPoolExecutor</code>，只能使用 <code>ExecutorService</code> 接口定义的方法。框架内部仍持有原始引用，可按需调整配置。</p>
<p><strong>与 newSingleThreadExecutor 的关系</strong>：<code>unconfigurableExecutorService</code> 返回 <code>DelegatedExecutorService</code>，而 <code>newSingleThreadExecutor</code> 返回其子类 <code>FinalizableDelegatedExecutorService</code>（增加了 finalize 自动关闭）</p>
<h2 id="构造器-vs-工厂方法：选择依据">构造器 vs 工厂方法：选择依据</h2>
<p>阿里巴巴代码规范要求<strong>强制</strong>使用 <code>ThreadPoolExecutor</code> 构造器创建线程池，禁止使用 <code>Executors</code> 工厂方法。这一规范的核心依据在于：</p>
<ol>
<li><strong>默认配置陷阱</strong>：工厂方法的预设参数（尤其是无界队列容量 <code>Integer.MAX_VALUE</code> 和无界最大线程数 <code>Integer.MAX_VALUE</code>）可能在生产环境中导致资源耗尽（OOM 或线程爆炸）</li>
<li><strong>强制思考原则</strong>：构造器强制开发者在实例化时必须明确指定核心参数（队列容量、最大线程数、拒绝策略），而非依赖隐式默认值</li>
</ol>
<p>然而，这一规范并非要求我们完全摒弃工厂方法。选择何种创建方式，应当基于<strong>具体线程池类型的语义特征</strong>做出判断。</p>
<h3 id="threadpoolexecutor：优先使用构造器">ThreadPoolExecutor：优先使用构造器</h3>
<p>对于通用目的的线程执行器，<strong>强烈建议</strong>使用构造器。理由如下：</p>
<ul>
<li>核心线程数和最大线程数需要根据业务负载特征（CPU 密集型 vs IO 密集型）精心配置，依赖默认值往往意味着未经思考的决策</li>
<li>队列容量必须设置上限，防止任务积压导致 <code>OutOfMemoryError</code></li>
<li>拒绝策略直接影响系统的容错行为和降级能力，需要显式选择而非接受默认的 <code>AbortPolicy</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 生产环境推荐写法</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    corePoolSize,      <span class="hljs-comment">// 根据负载特征计算</span><br>    maxPoolSize,       <span class="hljs-comment">// 必须设置上限</span><br>    keepAliveTime, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(queueCapacity),  <span class="hljs-comment">// 必须有界</span><br>    customThreadFactory,<br>    rejectionPolicy<br>);<br></code></pre></td></tr></table></figure>
<h3 id="scheduledthreadpoolexecutor：可以使用工厂方法">ScheduledThreadPoolExecutor：可以使用工厂方法</h3>
<p>对于定时任务调度器，在大多数场景下工厂方法是可接受的选择，理由如下：</p>
<ul>
<li><code>DelayedWorkQueue</code> 与 <code>LinkedBlockingQueue</code> 本质相同，内部数组按需翻倍扩容，上限为 <code>Integer.MAX_VALUE</code>，<strong>并非有界队列</strong></li>
<li><strong>真正的原因</strong>在于定时任务与普通任务的本质差异：
<ul>
<li>定时任务的提交频率由<strong>业务逻辑控制</strong>（如每日凌晨批量处理、每小时执行一次），而非由用户请求触发</li>
<li>用户对<strong>延时任务积压的容忍度远高于实时任务</strong>——队列中积压1000条待执行的定时任务通常可接受（它们只是在等待各自的延迟时间到期），而普通任务积压1000条则意味着系统已过载</li>
<li>定时任务的单次提交量通常较小，即使在大业务量系统中，单次调度请求也往往是数十至数百条级别，而非无限制地提交</li>
</ul>
</li>
<li><code>ScheduledThreadPoolExecutor</code> 的核心线程数通常较小（通常为 CPU 核数），即使队列积压，线程数的增长也受限于任务执行时长</li>
</ul>
<p><strong>关键区分</strong>：DelayedWorkQueue 的&quot;无界&quot;风险与 LinkedBlockingQueue 的&quot;无界&quot;风险<strong>完全相同</strong>。在高频调度场景下（如每秒数千次调度请求），同样可能导致 OOM。因此：</p>
<ul>
<li><strong>低频调度场景</strong>（每秒任务数 &lt; 100）：工厂方法可接受</li>
<li><strong>高频调度场景</strong>：应使用构造器，配置有界队列和合理的拒绝策略</li>
</ul>
<p>尽管如此，在高可靠性要求的系统中，仍推荐使用构造器进行精细化配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 更精细的配置（推荐用于关键业务系统）</span><br><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<br>    corePoolSize,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">CustomThreadFactory</span>(<span class="hljs-string">&quot;scheduler-&quot;</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>.DiscardOldestPolicy()<br>);<br></code></pre></td></tr></table></figure>
<h3 id="forkjoinpool：通用并行任务用工厂方法-递归分治任务用构造器">ForkJoinPool：通用并行任务用工厂方法，递归分治任务用构造器</h3>
<p><code>ForkJoinPool</code> 最初<strong>确实</strong>是为递归分治任务设计的（默认 LIFO 模式利于缓存局部性），但其工作窃取机制的应用范围已扩展到更广泛的并行任务场景。</p>
<p><code>Executors.newWorkStealingPool()</code> 工厂方法适用于<strong>非递归的通用并行任务</strong>：</p>
<ul>
<li>默认并行度 <code>Runtime.getRuntime().availableProcessors()</code> 正是该池设计的核心目标——充分利用系统 CPU 资源</li>
<li>内部传入 <code>asyncMode = true</code>（FIFO 模式），适合非递归的并行任务调度</li>
<li>工作窃取算法会自动平衡负载，过度手动调优往往适得其反</li>
</ul>
<blockquote>
<p><strong>关键区分</strong>：执行<strong>递归分治任务</strong>（如归并排序、树遍历、深度优先搜索）时，应使用 <code>ForkJoinPool</code> 构造器并指定 <code>asyncMode = false</code>（LIFO 模式）。LIFO 模式使子任务在同一个线程中顺序执行，减少线程切换开销；FIFO 模式则让任务更均匀地分配到各个线程，减少长任务阻塞短任务的风险。</p>
</blockquote>
<p>当存在以下<strong>特定</strong>需求时，应直接使用 <code>ForkJoinPool</code> 构造器：</p>
<ul>
<li><strong>需要 LIFO 模式</strong>（<code>asyncMode = false</code>）处理递归分治任务（如归并排序、树遍历）时，LIFO 利于缓存局部性</li>
<li><strong>需要自定义线程工厂</strong>以设置特定线程属性（如守护线程状态、优先级）</li>
<li><strong>需要限制最大线程数</strong>以控制资源占用（虽然通常不推荐，但某些隔离场景需要）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 场景1：递归分治任务，需要 LIFO 模式</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">forkJoinPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<br>    parallelism,<br>    ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>    <span class="hljs-literal">null</span>,<br>    <span class="hljs-literal">false</span>  <span class="hljs-comment">// LIFO 模式，适合递归任务</span><br>);<br><br><span class="hljs-comment">// 场景2：需要自定义线程工厂</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">customPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<br>    parallelism,<br>    customThreadFactory,<br>    handler,<br>    <span class="hljs-literal">true</span>   <span class="hljs-comment">// FIFO 模式</span><br>);<br></code></pre></td></tr></table></figure>
<h3 id="newcachedthreadpool-vs-newfixedthreadpool：选择依据">newCachedThreadPool vs newFixedThreadPool：选择依据</h3>
<p>这两个工厂方法<strong>均不推荐</strong>在生产环境直接使用，原因已在工厂方法对比总结中详述：</p>
<ul>
<li><code>newFixedThreadPool</code> 使用无界 <code>LinkedBlockingQueue</code>，队列积压会导致 OOM</li>
<li><code>newCachedThreadPool</code> 使用 <code>Integer.MAX_VALUE</code> 作为最大线程数，可能导致线程爆炸</li>
</ul>
<p>如需使用二者之一，应通过 <code>ThreadPoolExecutor</code> 构造器手动配置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 替代 newFixedThreadPool：有界队列 + 固定线程数</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">fixedExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    nThreads, nThreads,<br>    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(capacity),  <span class="hljs-comment">// 有界队列</span><br>    threadFactory,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortPolicy</span>()<br>);<br><br><span class="hljs-comment">// 替代 newCachedThreadPool：有界队列 + 有界最大线程数</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cachedExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">0</span>, maxThreads,  <span class="hljs-comment">// 核心线程为0，有界最大线程</span><br>    <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;(),  <span class="hljs-comment">// 无容量，直接传递</span><br>    threadFactory,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">AbortPolicy</span>()<br>);<br></code></pre></td></tr></table></figure>
<p>二者的选择依据：<strong>任务特征</strong></p>
<table>
<thead>
<tr>
<th>任务特征</th>
<th>推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td>任务量稳定可预测，期望限制并发数</td>
<td><code>newFixedThreadPool</code>（或等效构造器）</td>
</tr>
<tr>
<td>任务量波动大，存在明显空闲期</td>
<td><code>newCachedThreadPool</code>（或等效构造器）</td>
</tr>
<tr>
<td>任何生产环境</td>
<td><strong>均使用构造器</strong>，明确配置队列容量和线程数上限</td>
</tr>
</tbody>
</table>
<h5 id="总结">总结</h5>
<table>
<thead>
<tr>
<th>线程池类型</th>
<th>推荐创建方式</th>
<th>核心理由</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ThreadPoolExecutor</code>（通用）</td>
<td>构造器</td>
<td>队列容量和线程数必须有界，拒绝策略必须显式</td>
</tr>
<tr>
<td><code>newCachedThreadPool</code> / <code>newFixedThreadPool</code></td>
<td><strong>不推荐</strong></td>
<td>使用构造器替代，明确配置资源上限</td>
</tr>
<tr>
<td><code>ScheduledThreadPoolExecutor</code></td>
<td>工厂方法（低频调度）或构造器（高频调度）</td>
<td>调度频率通常可控，但高频场景需构造器配置有界队列</td>
</tr>
<tr>
<td><code>ForkJoinPool</code></td>
<td>工厂方法（默认），构造器（特定场景）</td>
<td>并行度应匹配 CPU 核心数，LIFO 模式需手动指定</td>
</tr>
</tbody>
</table>
<blockquote>
<p>阿里巴巴代码规范的真正目的不是&quot;禁止工厂方法&quot;，而是&quot;强制开发者思考关键配置&quot;。当我们充分理解了每种线程池类型的行为特征后，选择工厂方法或构造器就成为了一种有意识的工程决策，而非盲从或规避。</p>
</blockquote>
<h1>线程组</h1>
<p>线程组提供一个“集合”，可以把一群线程归于一处，可以批量 interrupt/stop/suspend。<br>
但这个方案是很危险的，使用线程池和并发安全的 Collection 都可以管理好线程。</p>
<h2 id="原本设计目的">原本设计目的</h2>
<ul>
<li>资源管理：将相关线程组织在一起，便于批量操作</li>
<li>安全隔离：不同线程组可以有不同的安全策略</li>
<li>异常处理：提供组级别的未捕获异常处理</li>
<li>层次结构：支持线程组的嵌套（parent-child关系）</li>
</ul>
<h2 id="缺陷">缺陷</h2>
<ul>
<li>API设计不一致且不完整</li>
<li>线程安全问题</li>
<li>功能缺失</li>
<li>安全模型过时</li>
</ul>
<h2 id="替代方案">替代方案</h2>
<ul>
<li>Executor框架</li>
<li>CompletableFuture</li>
<li>ForkJoinPool</li>
</ul>
<h2 id="官方态度">官方态度</h2>
<ul>
<li>Java 17+：线程组API标记为<code>@Deprecated(forRemoval = true)</code></li>
<li>JEP 411：移除SecurityManager，线程组失去最后的存在意义</li>
<li>OpenJDK邮件列表：多次讨论完全移除线程组</li>
</ul>
<h1>CompletionStage</h1>
<p>这是定义“可能是”异步计算的一个阶段，可能被其他阶段触发，也可以触发其他阶段。它是 CompletableFuture 的父接口。</p>
<p>它有一个特点，大量非 void 方法返回值都是 CompletionStage 类型，这样既允许 builder 模式，也允许各种 transformation 模式。</p>
<h2 id="completablefuture">CompletableFuture</h2>
<p>线程池的超时中断机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">invokeAll(tasks, <span class="hljs-number">300L</span>, TimeUnit.MILLISECONDS);<br></code></pre></td></tr></table></figure>
<p>会让这个类型中断提前返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">432369</span>-Caused by: java.lang.InterruptedException: <span class="hljs-literal">null</span><br><span class="hljs-number">432370</span>- at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:<span class="hljs-number">347</span>)<br><span class="hljs-number">432371</span>- at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:<span class="hljs-number">1915</span>)<br><span class="hljs-number">432372</span>- at org.apache.dubbo.rpc.AsyncRpcResult.get(AsyncRpcResult.java:<span class="hljs-number">196</span>)<br><span class="hljs-number">432373</span>- at org.apache.dubbo.rpc.protocol.AbstractInvoker.waitForResultIfSync(AbstractInvoker.java:<span class="hljs-number">266</span>)<br><span class="hljs-number">432374</span>- at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:<span class="hljs-number">186</span>)<br><span class="hljs-number">432375</span>- at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invokeWithContext(AbstractClusterInvoker.java:<span class="hljs-number">379</span>)<br><span class="hljs-number">432376</span>- at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:<span class="hljs-number">81</span>)<br></code></pre></td></tr></table></figure>
<h1>小技巧</h1>
<h2 id="如何处理任务超时问题">如何处理任务超时问题</h2>
<h3 id="方法1：使用-futuretask-的实现">方法1：使用 FutureTask 的实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">    Future&lt;Map&lt;String, Object&gt;&gt; future = executor.submit(() -&gt; getFeatures(context, zeusSceneId));<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 穷人版超时：最简单的超时不是使用 circuit breaker，而是使用 FutureTask 的缺省超时实现，这个方案取不到值的时候底层会返回 TimeoutException，只要捕获这个超时就可以走入 fallback 逻辑</span><br>                features.putAll(future.get(paramCollectTimeout, TimeUnit.MILLISECONDS));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;<br>                <span class="hljs-comment">// fallback logic</span><br>            &#125;<br>            <br>    <span class="hljs-comment">// 其中 FutureTask 的实现是：</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>        <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>        <span class="hljs-comment">// 等待结束后抛出异常而不是空指针，否则调用 report 方法</span><br>        <span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>            (s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>        <span class="hljs-keyword">return</span> report(s);<br>    &#125;<br>    <br><span class="hljs-comment">// 以下为简化的伪代码示意（实际实现使用 LockSupport.parkNanos）：</span><br>其中超时底层的最简单实现是：<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br>    <br>    <span class="hljs-comment">// 循环等待，直到任务完成或超时</span><br>    <span class="hljs-keyword">while</span> (state &lt;= COMPLETING) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> deadline - System.nanoTime();<br>        <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0L</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();  <span class="hljs-comment">// 超时了</span><br>        &#125;<br>        LockSupport.parkNanos(<span class="hljs-built_in">this</span>, remaining);  <span class="hljs-comment">// 等待指定时间</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> report(state);  <span class="hljs-comment">// 返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法2：使用条件变量">方法2：使用条件变量</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发出调用</span><br>condition.await<br><span class="hljs-comment">// 非阻塞地调用 isDone 方法，抛出异常或取值</span><br><span class="hljs-comment">// 这是方法1 的泛化实现</span><br></code></pre></td></tr></table></figure>
<h3 id="方法3：使用-countdownlatch-cyclicbarrier">方法3：使用 countDownLatch/CyclicBarrier</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发出调用</span><br>无锁的 await<br><span class="hljs-comment">// 非阻塞地调用 isDone 方法，抛出异常或取值，但要注意其他线程对 done 状态的维护</span><br></code></pre></td></tr></table></figure>
<p>这个方法不需要依赖于 ReentrantLock，是通过纯 AQS 实现的，见 CountDownLatch 源码。</p>
<h2 id="自定义线程池实现自定义中断">自定义线程池实现自定义中断</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">待补充<br></code></pre></td></tr></table></figure>
<h1>Java 异步执行中的异常处理与线程生命周期</h1>
<h2 id="从-futuretask-asyncuncaughtexceptionhandler-到-uncaughtexceptionhandler">从 FutureTask、AsyncUncaughtExceptionHandler 到 UncaughtExceptionHandler</h2>
<p>在 Java 并发和 Spring 异步执行模型中，异常处理涉及多个抽象层级：<br>
JVM 线程模型、JDK 并发工具以及 Spring 框架本身。</p>
<p>这些层级各自对异常承担不同职责，但它们的行为经常被混淆，典型问题包括：</p>
<ul>
<li>异步任务抛出的异常为何没有日志</li>
<li><code>UncaughtExceptionHandler</code> 在线程池中为何不生效</li>
<li><code>AsyncUncaughtExceptionHandler</code> 是否会影响线程生命周期</li>
</ul>
<p>本文从<strong>线程是否终止</strong>这一确定性问题出发，系统梳理三种机制的边界与协作方式。</p>
<hr>
<h2 id="一-线程是否终止的唯一判定标准">一、线程是否终止的唯一判定标准</h2>
<p>在 JVM 层面，线程是否终止只取决于一个条件：</p>
<blockquote>
<p><strong>是否存在未被捕获、并逃逸出 <code>Thread.run()</code> 的 <code>Throwable</code></strong>。从这个 run 出去以后，就进入 jvm 的cpp 代码的接管范围</p>
</blockquote>
<p>这一规则与使用何种框架无关。</p>
<h3 id="会导致线程终止的情况">会导致线程终止的情况</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<ul>
<li>异常未被捕获</li>
<li>异常逃逸出 run()</li>
<li>JVM 调用 UncaughtExceptionHandler</li>
<li>线程终止</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<p>源码位置：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chuyouyinghe/article/details/134306409">Thread 的实现</a><br>
还可以参考这个：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《01.崩溃捕获设计实践方案 crash方案》</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">JavaThread::exit</span><span class="hljs-params">(<span class="hljs-type">bool</span> destroy_vm)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_pending_exception</span>()) &#123;<br>        <span class="hljs-function">Handle <span class="hljs-title">exception</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, pending_exception())</span></span>;<br>        <span class="hljs-built_in">clear_pending_exception</span>();<br>        <br>        <span class="hljs-comment">// 直接内联处理，无单独 uncaught_exception 方法</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">threadObj</span>() != <span class="hljs-literal">NULL</span>) &#123;<br>            Klass* klass = SystemDictionary::<span class="hljs-built_in">Thread_klass</span>();<br>            <span class="hljs-comment">// ... 通过 JNI 调用 Java 层 uncaughtException</span><br>            JavaCalls::<span class="hljs-built_in">call_virtual</span>(&amp;result, klass, <br>                                   vmSymbols::<span class="hljs-built_in">uncaughtException_name</span>(),<br>                                   vmSymbols::<span class="hljs-built_in">thread_throwable_void_signature</span>(),<br>                                   &amp;args, <span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant JVM as JVM(C++)
    participant JavaThread as JavaThread(C++)
    participant ThreadJava as java.lang.Thread
    
    JVM-&gt;&gt;JavaThread: 线程执行中抛出异常
    JavaThread-&gt;&gt;JavaThread: set_pending_exception(exception)
    JVM-&gt;&gt;JavaThread: 线程退出调用 exit()
    JavaThread-&gt;&gt;JavaThread: has_pending_exception()
    JavaThread-&gt;&gt;JavaThread: 直接在 exit() 中处理
    JavaThread-&gt;&gt;ThreadJava: JNI call_virtual(&quot;uncaughtException&quot;)
    ThreadJava-&gt;&gt;ThreadJava: 实际调用 java.lang.Thread.uncaughtException
    ThreadJava-&gt;&gt;ThreadJava: dispatchUncaughtException(e)
    ThreadJava-&gt;&gt;ThreadGroup: getUncaughtExceptionHandler()
    ThreadGroup-&gt;&gt;SystemErr: 默认处理</code></pre>
<h3 id="不会导致线程终止的情况">不会导致线程终止的情况</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// handled</span><br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<ul>
<li>异常被捕获</li>
<li>JVM 不介入</li>
<li>线程继续运行</li>
</ul>
<p>结论：</p>
<ul>
<li>异常是否被捕获，决定了线程是否终止；</li>
<li>异常由谁处理，并不决定线程生死。</li>
</ul>
<h2 id="二-futuretask-对异常传播路径的改变">二、FutureTask 对异常传播路径的改变</h2>
<p>理解线程池与 Spring 异步行为，必须先理解 FutureTask。</p>
<h3 id="execute-与-submit-的根本差异">execute 与 submit 的根本差异</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">executor.execute(runnable);<br>executor.submit(callable);<br></code></pre></td></tr></table></figure>
<p>差异不在返回值，而在执行结构：</p>
<ul>
<li><code>execute</code>：<code>Runnable</code>直接在线程中执行</li>
<li><code>submit</code>：任务先被包装为<code>FutureTask</code>，再执行</li>
</ul>
<h3 id="futuretask-中的异常拦截点">FutureTask 中的异常拦截点</h3>
<p>FutureTask.run() 的核心逻辑如下（简化）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        callable.call();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        setException(ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键点：</p>
<ul>
<li>Throwable 被主动捕获</li>
<li>异常不会逃逸出 run()</li>
<li>JVM 不认为线程发生未捕获异常<br>
线程不会终止</li>
</ul>
<p>异常在这里已经脱离“线程异常”的语义。</p>
<h3 id="异常如何被重新抛出：report">异常如何被重新抛出：report()</h3>
<p>异常并未消失，而是作为执行结果存储：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">outcome = ex;<br>state = EXCEPTIONAL;<br></code></pre></td></tr></table></figure>
<p>在调用<code>Future.get()</code>时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;<br>    <span class="hljs-keyword">if</span> (s == NORMAL)<br>        <span class="hljs-keyword">return</span> (V) x;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable) x);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>report()</code>的职责是：</p>
<ul>
<li>将“执行结果状态”翻译为 Java 异常语义</li>
<li>将原始异常包装为 ExecutionException</li>
</ul>
<p>结论：</p>
<blockquote>
<p>FutureTask 将异常从“线程控制流”转移为“任务结果数据”。</p>
</blockquote>
<h2 id="三-uncaughtexceptionhandler-的职责边界">三、UncaughtExceptionHandler 的职责边界</h2>
<h3 id="触发条件">触发条件</h3>
<p><code>UncaughtExceptionHandler</code>仅在以下条件满足时被调用：</p>
<ul>
<li>异常未被捕获</li>
<li>异常逃逸出<code>Thread.run()</code></li>
<li>线程即将终止</li>
</ul>
<p>JVM 调用顺序为：</p>
<ol>
<li>Thread 自身的 handler</li>
<li>ThreadGroup</li>
<li>DefaultUncaughtExceptionHandler</li>
<li>JVM 默认 stderr</li>
</ol>
<h3 id="能力与限制">能力与限制</h3>
<p><code>UncaughtExceptionHandler</code>：</p>
<ul>
<li>无法阻止线程终止</li>
<li>无法恢复线程执行</li>
<li>仅用于日志、告警等系统级兜底</li>
</ul>
<p>在线程池中，只有 <code>execute()</code>且异常未被捕获时，才可能触发该 handler。</p>
<h2 id="四-spring-asyncuncaughtexceptionhandler-的作用范围">四、Spring AsyncUncaughtExceptionHandler 的作用范围</h2>
<h3 id="适用条件">适用条件</h3>
<p>Spring 明确限定：</p>
<ul>
<li>仅处理 @Async 标注的 void 方法</li>
<li>不处理返回 Future / CompletableFuture 的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Async</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="spring-的异常拦截方式">Spring 的异常拦截方式</h3>
<p>Spring 在异步调用边界处捕获异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    invokeMethod();<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>    asyncUncaughtExceptionHandler.handle(ex, method, params);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="对线程生命周期的影响">对线程生命周期的影响</h3>
<p><code>AsyncUncaughtExceptionHandler</code>：</p>
<ul>
<li>不会阻止线程终止</li>
<li>也不会导致线程终止</li>
</ul>
<p>原因是：</p>
<ul>
<li>异常已经被 Spring 捕获</li>
<li>JVM 无法感知未捕获异常</li>
<li>线程本身没有死亡条件</li>
</ul>
<p>结论：</p>
<ul>
<li>AsyncUncaughtExceptionHandler 只影响异常的业务处理路径，不影响线程生命周期。</li>
</ul>
<h2 id="五-三种异常路径的对比">五、三种异常路径的对比</h2>
<h3 id="async-void-方法">@Async void 方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Async</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">方法执行<br> → Spring 捕获<br> → AsyncUncaughtExceptionHandler<br> → 线程继续运行<br></code></pre></td></tr></table></figure>
<h3 id="线程池execute">线程池<code>execute</code></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">executor.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable.run<br> → 异常逃逸<br> → JVM<br> → UncaughtExceptionHandler<br> → 线程终止<br></code></pre></td></tr></table></figure>
<h3 id="线程池-submit">线程池 submit</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;?&gt; future = executor.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask.run<br> → <span class="hljs-keyword">catch</span> Throwable<br> → 异常存入 Future<br> → get() 时抛 ExecutionException<br></code></pre></td></tr></table></figure>
<h2 id="六-两种-handler-的推荐使用方式">六、两种 Handler 的推荐使用方式</h2>
<h3 id="asyncuncaughtexceptionhandler-业务层">AsyncUncaughtExceptionHandler（业务层）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AsyncConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> AsyncUncaughtExceptionHandler <span class="hljs-title function_">getAsyncUncaughtExceptionHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (ex, method, params) -&gt; &#123;<br>            log.error(<span class="hljs-string">&quot;Async void method failed: &#123;&#125;&quot;</span>, method.getName(), ex);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li>@Async void 方法</li>
<li>业务补偿、告警、日志</li>
</ul>
<h3 id="uncaughtexceptionhandler-系统层">UncaughtExceptionHandler（系统层）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> r -&gt; &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>    t.setUncaughtExceptionHandler((thread, ex) -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Thread &#123;&#125; terminated&quot;</span>, thread.getName(), ex);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;;<br><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(),<br>    factory<br>);<br></code></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li><code>execute()</code>执行的任务</li>
<li>系统级兜底监控</li>
</ul>
<h3 id="有返回值的异步任务">有返回值的异步任务</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture<br>    .supplyAsync(<span class="hljs-built_in">this</span>::work, executor)<br>    .exceptionally(ex -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Async failed&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<p>必须显式消费异常，否则异常不会被观察到。</p>
<h2 id="结论">结论</h2>
<ol>
<li>线程是否终止，仅由异常是否逃逸到 JVM 决定</li>
<li>FutureTask 和 Spring 已在更高层捕获异常，因此不会触发 JVM 机制</li>
<li>AsyncUncaughtExceptionHandler 不控制线程生死，仅提供业务回调</li>
<li>UncaughtExceptionHandler 只用于处理线程终止前的系统级事件</li>
</ol>
<h1>Spring 的异步支持</h1>
<ul>
<li>如果只是<code>@EnableAsync</code>，Spring 会创建一个默认的 SimpleAsyncTaskExecutor（注意不是 ThreadPoolTaskExecutor）：
<ul>
<li><strong>每个任务都会创建新线程</strong></li>
<li>没有线程池复用</li>
<li>性能较差，不适合生产环境</li>
</ul>
</li>
<li>在这个基础上，再实现<code>AsyncConfigurer.getAsyncExecutor()</code>就可以让自己的线程池替代框架的 Bean。</li>
</ul>
<h2 id="threadpooltaskexecutor">ThreadPoolTaskExecutor</h2>
<p>ThreadPoolTaskExecutor 是 ExecutorConfigurationSupport 的子类，也包装了一个 ThreadPoolExecutor。</p>
<ul>
<li>ExecutorConfigurationSupport 作为基类提供了：
<ul>
<li>生命周期管理：实现了 InitializingBean, DisposableBean</li>
<li>配置管理：线程工厂、拒绝策略、优雅关闭等配置</li>
<li>模板方法：定义了初始化和销毁的标准流程</li>
</ul>
</li>
</ul>
<p>特别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>    initialize();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isInfoEnabled()) &#123;<br>        <span class="hljs-built_in">this</span>.logger.info(<span class="hljs-string">&quot;Initializing ExecutorService &quot;</span> + (<span class="hljs-built_in">this</span>.beanName != <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot; &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.beanName + <span class="hljs-string">&quot;&#x27;&quot;</span> : <span class="hljs-string">&quot;&quot;</span>));<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.threadNamePrefixSet &amp;&amp; <span class="hljs-built_in">this</span>.beanName != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.setThreadNamePrefix(<span class="hljs-built_in">this</span>.beanName + <span class="hljs-string">&quot;-&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 调用子类的具体实现</span><br>    <span class="hljs-built_in">this</span>.executor = <span class="hljs-built_in">this</span>.initializeExecutor(<span class="hljs-built_in">this</span>.threadFactory, <span class="hljs-built_in">this</span>.rejectedExecutionHandler);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以在这个 bean 被使用以前，内部线程池要经过一个 afterPropertiesSet 驱动进行初始化和注入这个 ThreadPoolTaskExecutor 线程池外壳。</p>
<h2 id="threadpooltaskexecutor-内部线程池的替换">ThreadPoolTaskExecutor 内部线程池的替换</h2>
<h3 id="推荐：使用初始化器装饰">推荐：使用初始化器装饰</h3>
<p>initializeExecutor 初始化过程里会允许我们装饰这个线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> ExecutorService <span class="hljs-title function_">initializeExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">        ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;<br><br>    BlockingQueue&lt;Runnable&gt; queue = createQueue(<span class="hljs-built_in">this</span>.queueCapacity);<br><br>    ThreadPoolExecutor executor;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.taskDecorator != <span class="hljs-literal">null</span>) &#123;<br>        executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-built_in">this</span>.corePoolSize, <span class="hljs-built_in">this</span>.maxPoolSize, <span class="hljs-built_in">this</span>.keepAliveSeconds, TimeUnit.SECONDS,<br>                queue, threadFactory, rejectedExecutionHandler) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>                <span class="hljs-type">Runnable</span> <span class="hljs-variable">decorated</span> <span class="hljs-operator">=</span> taskDecorator.decorate(command);<br>                <span class="hljs-keyword">if</span> (decorated != command) &#123;<br>                    decoratedTaskMap.put(decorated, command);<br>                &#125;<br>                <span class="hljs-built_in">super</span>.execute(decorated);<br>            &#125;<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-built_in">this</span>.corePoolSize, <span class="hljs-built_in">this</span>.maxPoolSize, <span class="hljs-built_in">this</span>.keepAliveSeconds, TimeUnit.SECONDS,<br>                queue, threadFactory, rejectedExecutionHandler);<br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.allowCoreThreadTimeOut) &#123;<br>        executor.allowCoreThreadTimeOut(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.threadPoolExecutor = executor;<br>    <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>java 线程池的装饰逻辑就是<strong>只覆盖一个</strong><code>public void execute(Runnable command)</code>即可。</p>
<p>这个方法本质上是<strong>一切线程池外部提交/执行操作的入口</strong>，所以<strong>它的执行线程是外部线程而已不是工作线程</strong>。</p>
<p>可以说<strong>这个壳的其他方法都只是包装一下普通线程的成员方法，但是这个 initializeExecutor 和 decorate 是这个壳特有的，是它存在的意义</strong>。</p>
<p>所有外部 command 在执行前都要被 decorate 一下，而且存在 decoratedTaskMap 里，模式是装饰后-&gt;原始命令。目前这个map没有用处，未来可能在用修饰后的任务找原始 Runnable 的时候会有用。</p>
<h3 id="其他代理">其他代理</h3>
<p>其他方法都是用<strong>类似的模式来代理的，而且不支持多态</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> getThreadPoolExecutor();<br>    <span class="hljs-keyword">try</span> &#123;<br>        executor.execute(task);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskRejectedException</span>(<span class="hljs-string">&quot;Executor [&quot;</span> + executor + <span class="hljs-string">&quot;] did not accept task: &quot;</span> + task, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="如果我们要替换线程池实现">如果我们要替换线程池实现</h3>
<p>我们只能用反射来替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;bizCommonTaskExecutor&quot;)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ThreadPoolTaskExecutor <span class="hljs-title function_">getAsyncExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建支持EagleEye上下文传递的ThreadPoolTaskExecutor</span><br>    <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">taskExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> ThreadPoolExecutor <span class="hljs-title function_">initializeExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">                ThreadFactory threadFactory,</span><br><span class="hljs-params">                RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;<br>            <span class="hljs-comment">// 创建阻塞队列</span><br>            BlockingQueue&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY);<br>            <br>            <span class="hljs-comment">// 创建支持EagleEye上下文传递的线程池</span><br>            <span class="hljs-type">EagleEyeContextAwareThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EagleEyeContextAwareThreadPoolExecutor</span>(<br>                CORE_POOL_SIZE,<br>                MAX_POOL_SIZE,<br>                KEEP_ALIVE_SECONDS,<br>                TimeUnit.SECONDS,<br>                queue,<br>                threadFactory,<br>                rejectedExecutionHandler<br>            );<br><br>            <span class="hljs-comment">// 使用反射将executor赋值给父类的private threadPoolExecutor字段，这是目前唯一的方法</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                java.lang.reflect.<span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> ThreadPoolTaskExecutor.class.getDeclaredField(<span class="hljs-string">&quot;threadPoolExecutor&quot;</span>);<br>                field.setAccessible(<span class="hljs-literal">true</span>);<br>                field.set(<span class="hljs-built_in">this</span>, executor);<br>                <span class="hljs-comment">// 如果有必要，要存储老的 accessible，在 set 完了以后要还原</span><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LoggerUtils.error(LOGGER, <span class="hljs-string">&quot;Failed to set threadPoolExecutor via reflection&quot;</span>, e);<br>            &#125;<br>            <br>            <span class="hljs-keyword">return</span> executor;<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-comment">// 配置线程名前缀</span><br>    taskExecutor.setThreadNamePrefix(<span class="hljs-string">&quot;bd-common-async-&quot;</span>);<br>    <br>    <span class="hljs-comment">// 配置优雅停机</span><br>    taskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="hljs-literal">true</span>);<br>    taskExecutor.setAwaitTerminationSeconds(AWAIT_TERMINATION_SECONDS);<br>    <br>    <span class="hljs-keyword">return</span> taskExecutor;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们不推荐使用这种做法，除非我们真的<strong>有增强 execute 以外的诉求</strong>。</p>
<h2 id="对线程池实行-trace-传递">对线程池实行 trace 传递</h2>
<h3 id="如果使用统一包装器">如果使用统一包装器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法的第一层参数是 ThreadPoolTaskExecutor 的 execute 执行的时候的这个 command：</span><br><span class="hljs-comment">//              public void execute(Runnable command) &#123;</span><br><span class="hljs-comment">//                  Runnable decorated = taskDecorator.decorate(command);</span><br> taskExecutor.setTaskDecorator(runnable -&gt; &#123;<br>            <br>            <span class="hljs-comment">// 这里获取外部提交的时候的线程和上下文</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">submitThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <br>            <span class="hljs-comment">// 这里返回一个 runnable，给外部的 super.execute(decorated); 使用，这个方法就是原始线程池的 execute 了</span><br>            <span class="hljs-keyword">return</span> () -&gt; &#123;<br>                <span class="hljs-comment">// 这里开始执行的时候通常已经进入线程池的 worker 内部了</span><br>                <br>                <span class="hljs-comment">// 当拒绝策略为 CallerRunsPolicy 且在提交线程中执行时，直接运行即可</span><br>                <span class="hljs-keyword">if</span> (submitThread == Thread.currentThread()) &#123;<br>                    runnable.run();<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">oldContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (oldContext == <span class="hljs-literal">null</span>) &#123;<br>                        needClean = <span class="hljs-literal">true</span>;<br>                        EagleEye.setRpcContext(rpcContext);<br>                    &#125;<br>                    <span class="hljs-comment">// 这是在内部线程 run 之前执行的围绕操作</span><br>                    runnable.run();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span> (needClean) &#123;<br>                        EagleEye.clearRpcContext();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>        &#125;);<br></code></pre></td></tr></table></figure>
<p>其中装饰器被调用的地方是就是上面的<a href="#%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E8%A3%85%E9%A5%B0">使用初始化器装饰</a>。</p>
<p>本质上 executor 共有三个入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (EagleEye.currentRpcContext() == <span class="hljs-literal">null</span>) &#123;<br>                needClean = <span class="hljs-literal">true</span>;<br>                EagleEye.setRpcContext(rpcContext);<br>            &#125;<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (needClean) &#123;<br>                    EagleEye.clearRpcContext();<br>                &#125;<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (EagleEye.currentRpcContext() == <span class="hljs-literal">null</span>) &#123;<br>                needClean = <span class="hljs-literal">true</span>;<br>                EagleEye.setRpcContext(rpcContext);<br>            &#125;<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (needClean) &#123;<br>                    EagleEye.clearRpcContext();<br>                &#125;<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>    <span class="hljs-keyword">if</span> (command <span class="hljs-keyword">instanceof</span> FutureTask) &#123;<br>        <span class="hljs-built_in">super</span>.execute(command);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.execute(() -&gt; &#123;<br>            EagleEye.setRpcContext(rpcContext);<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                command.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                EagleEye.clearRpcContext();<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>前两个 newTaskFor 是其他 submit 方法到 execute 之前的底层方法。因为前两个入口最终都会调到<code>execute(Runnable command)</code>，所以它的内部要避开<code>if (command instanceof FutureTask) {</code>的场景。这个设计因此显得比较累赘。</p>
<p>实际上 decorator 的实现就是最佳的，最终只要实现一个 execute 的包装提交就行了。</p>
<p>这个实现里有一个地方要注意：执行完当前的 runnable 需要 clear，否则可能会出现以前有的遗留 traceId 污染的问题。</p>
<p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">《一行一行源码分析清楚AbstractQueuedSynchronizer》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《Java线程池实现原理及其在美团业务中的实践》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">《CompletableFuture原理与实践-外卖商家端API的异步化》</a></li>
</ol>
<hr>
<h1>异步编程的进化</h1>
<p>本章节一部分来自于qwen，一部分来自于以下文章：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">《CompletableFuture原理与实践-外卖商家端API的异步化》</a></li>
</ol>
<h2 id="演进本质">演进本质</h2>
<pre><code class="hljs mermaid">graph LR
    A[Java 5 Future] --&gt;|阻塞痛点| B[Guava ListenableFuture]
    B --&gt;|回调地狱| C[CompletableFuture]
    C --&gt;|流处理需求| D[RxJava]
    D --&gt;|Spring整合| E[Reactor]
    
    A --&gt;|范式转变| F[命令式-&gt;声明式]
    B --&gt;|抽象提升| G[事件驱动-&gt;数据流]
    C --&gt;|能力增强| H[组合-&gt;背压]
    D &amp; E --&gt;|统一理念| I[异步即数据流]</code></pre>
<ul>
<li>控制流：阻塞等待 → 回调响应 → 声明式组合 → 响应式流</li>
<li>错误处理：分散try-catch → 回调onFailure → 链式exceptionally → 流式onError</li>
<li>组合能力：无 → 有限transform → 丰富组合操作符 → 完整流处理</li>
<li>背压支持：无 → 无 → 有限 → 完整内建支持</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">核心特征</th>
<th style="text-align:left">编程范式</th>
<th style="text-align:left">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Java 5 Future</td>
<td style="text-align:left">阻塞等待</td>
<td style="text-align:left">命令式</td>
<td style="text-align:left">简单异步任务，兼容性要求高</td>
</tr>
<tr>
<td style="text-align:left">Guava ListenableFuture</td>
<td style="text-align:left">回调驱动</td>
<td style="text-align:left">事件驱动</td>
<td style="text-align:left">中等复杂度，需要非阻塞回调</td>
</tr>
<tr>
<td style="text-align:left">CompletableFuture</td>
<td style="text-align:left">链式组合</td>
<td style="text-align:left">声明式</td>
<td style="text-align:left">复杂异步流程，需要组合和错误处理</td>
</tr>
<tr>
<td style="text-align:left">RxJava</td>
<td style="text-align:left">响应式流</td>
<td style="text-align:left">函数式响应式</td>
<td style="text-align:left">事件流处理，背压支持，复杂数据转换</td>
</tr>
<tr>
<td style="text-align:left">Reactor</td>
<td style="text-align:left">响应式流</td>
<td style="text-align:left">函数式响应式</td>
<td style="text-align:left">Spring生态，高性能流处理，背压内建</td>
</tr>
</tbody>
</table>
<h2 id="传统调用时序">传统调用时序</h2>
<h3 id="java-5-future">Java 5 Future</h3>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#FFF5E1&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant Executor as ExecutorService
    participant Future as Future&lt;T&gt;
    participant Task as Callable&lt;T&gt;

    Note over Client,Task: Java 5 Future (阻塞式)
    Client-&gt;&gt;Executor: submit(Callable)
    Executor-&gt;&gt;Future: 创建Future
    Executor--&gt;&gt;Client: 返回Future
    Note right of Client: 非阻塞返回

    Executor-&gt;&gt;Task: 执行任务
    Task--&gt;&gt;Executor: 返回结果

    Client-&gt;&gt;Future: get() / get(timeout)
    Note right of Client: 阻塞等待
    Future--&gt;&gt;Client: 返回结果或抛出异常
    Note over Client: 阻塞式: submit/get</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心特点：阻塞等待结果</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;String&gt; future = executor.submit(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello Future&quot;</span>;<br>&#125;);<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// [注意] 阻塞当前线程等待结果</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(<span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>    System.out.println(result);<br>&#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>    System.err.println(<span class="hljs-string">&quot;超时了!&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="guava-listenablefuture">Guava ListenableFuture</h3>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#D5E8D4&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant Executor as ListeningExecutorService
    participant Future as ListenableFuture&lt;T&gt;
    participant Callback as FutureCallback&lt;T&gt;
    participant Task as Callable&lt;T&gt;

    Note over Client,Task: Guava ListenableFuture (回调式)
    Client-&gt;&gt;Executor: submit(Callable)
    Executor-&gt;&gt;Future: 创建ListenableFuture
    Executor--&gt;&gt;Client: 返回ListenableFuture
    Note right of Client: 非阻塞返回

    Client-&gt;&gt;Future: addCallback(FutureCallback)
    Note right of Client: 注册回调，非阻塞

    Executor-&gt;&gt;Task: 执行任务
    Task--&gt;&gt;Executor: 返回结果

    Future-&gt;&gt;Callback: onSuccess(result) 或 onFailure(ex)
    Note over Client: 回调式: submit/addCallback</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心特点：回调处理结果</span><br><span class="hljs-type">ListeningExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> MoreExecutors.listeningDecorator(<br>    Executors.newSingleThreadExecutor()<br>);<br><br>ListenableFuture&lt;String&gt; future = executor.submit(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello ListenableFuture&quot;</span>;<br>&#125;);<br><br><span class="hljs-comment">// [正确] 非阻塞：注册回调处理结果</span><br>Futures.addCallback(future, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(String result)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;成功: &quot;</span> + result);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>        System.err.println(<span class="hljs-string">&quot;失败: &quot;</span> + t.getMessage());<br>    &#125;<br>&#125;, executor);<br><br><span class="hljs-comment">// [注意] 需要手动关闭executor</span><br>executor.shutdown();<br></code></pre></td></tr></table></figure>
<p>这个方案是很容易产生回调地狱的，因为总是会有 addCallback + onSuccess 这种不可编排、组合 api 不适合把大型并发结果组合在一起的缺陷：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回调地狱示例</span><br>ListenableFuture&lt;User&gt; userFuture = userService.getUser(userId);<br><br><span class="hljs-comment">// 第一层回调</span><br>Futures.addCallback(userFuture, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;User&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-comment">// 第二层回调：需要 user 结果</span><br>        ListenableFuture&lt;List&lt;Order&gt;&gt; ordersFuture = orderService.getOrders(user.getId());<br>        <br>        Futures.addCallback(ordersFuture, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;List&lt;Order&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(List&lt;Order&gt; orders)</span> &#123;<br>                <span class="hljs-comment">// 第三层回调：需要 orders 结果</span><br>                ListenableFuture&lt;List&lt;Product&gt;&gt; productsFuture = <br>                    productService.getProducts(orders.stream()<br>                        .map(Order::getProductId)<br>                        .collect(Collectors.toList()));<br>                <br>                Futures.addCallback(productsFuture, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;List&lt;Product&gt;&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(List&lt;Product&gt; products)</span> &#123;<br>                        <span class="hljs-comment">// 第四层回调：需要 products 结果</span><br>                        <span class="hljs-comment">// 终于可以组装最终结果了...</span><br>                        <span class="hljs-type">OrderDetails</span> <span class="hljs-variable">details</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDetails</span>(user, orders, products);<br>                        log.info(<span class="hljs-string">&quot;订单详情: &#123;&#125;&quot;</span>, details);<br>                    &#125;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>                        log.error(<span class="hljs-string">&quot;Products retrieval failed&quot;</span>, t);<br>                        auditService.logFailure(<span class="hljs-string">&quot;products&quot;</span>, t);<br>                    &#125;<br>                &#125;, executor);<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>                log.error(<span class="hljs-string">&quot;Orders retrieval failed&quot;</span>, t);<br>                auditService.logFailure(<span class="hljs-string">&quot;orders&quot;</span>, t);<br>            &#125;<br>        &#125;, executor);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>        log.error(<span class="hljs-string">&quot;User retrieval failed&quot;</span>, t);<br>        auditService.logFailure(<span class="hljs-string">&quot;user&quot;</span>, t);<br>    &#125;<br>&#125;, executor);<br></code></pre></td></tr></table></figure>
<h3 id="completablefuture">CompletableFuture</h3>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#DAE8FC&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant CF1 as CompletableFuture&lt;T&gt;
    participant CF2 as CompletableFuture&lt;U&gt;
    participant Executor as Executor

    Note over Client,Executor: CompletableFuture (链式组合)
    Client-&gt;&gt;CF1: supplyAsync(Supplier)
    CF1--&gt;&gt;Client: 返回CompletableFuture
    Note right of Client: 非阻塞返回

    Client-&gt;&gt;CF1: thenApply(Function)
    CF1-&gt;&gt;CF2: 创建新的CompletableFuture
    CF2--&gt;&gt;Client: 返回新的CompletableFuture
    Note right of Client: 链式组合，非阻塞

    Executor-&gt;&gt;CF1: 执行任务
    CF1-&gt;&gt;CF2: 传递结果
    CF2--&gt;&gt;Client: 完成时通知
    Note over Client: 链式: supplyAsync/thenApply/thenCompose</code></pre>
<p>CompletableFuture 和 ListenableFuture 的设计哲学差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ListenableFuture 设计哲学：</span><br><span class="hljs-comment">// &quot;当异步操作完成时，通知我&quot;</span><br>future.addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;T&gt;() &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(T result)</span>;    <span class="hljs-comment">// 回调处理成功</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span>; <span class="hljs-comment">// 回调处理失败</span><br>&#125;);<br><br><span class="hljs-comment">// CompletableFuture 设计哲学：</span><br><span class="hljs-comment">// &quot;将这个异步操作与下一个操作组合起来&quot;</span><br>future.thenCompose(result -&gt; nextOperation(result))<br>      .thenApply(transformed -&gt; process(transformed))<br>      .exceptionally(ex -&gt; handle(ex));<br></code></pre></td></tr></table></figure>
<h4 id="执行树">执行树</h4>
<p><img src="CompletableFuture%E6%89%A7%E8%A1%8C%E6%A0%91.png" alt="CompletableFuture执行树.png"></p>
<h4 id="核心-api">核心 API</h4>
<pre><code class="hljs mermaid">classDiagram
    class CompletableFuture~T~ &#123;
        &lt;&lt;核心类&gt;&gt;
        +T result
        +Throwable exception
        +Object stack
        
        %% 创建方法
        +supplyAsync(Supplier~T~) CompletableFuture~T~
        +runAsync(Runnable) CompletableFuture~Void~
        +completedFuture(T) CompletableFuture~T~
        
        %% 转换方法
        +thenApply(Function) CompletableFuture~U~
        +thenApplyAsync(Function) CompletableFuture~U~
        +thenCompose(Function) CompletableFuture~U~
        
        %% 消费方法
        +thenAccept(Consumer) CompletableFuture~Void~
        +thenRun(Runnable) CompletableFuture~Void~
        
        %% 组合方法
        +thenCombine(CompletableFuture, BiFunction) CompletableFuture~V~
        +allOf(CompletableFuture...) CompletableFuture~Void~
        +anyOf(CompletableFuture...) CompletableFuture~Object~
        
        %% 异常处理
        +exceptionally(Function) CompletableFuture~T~
        +handle(BiFunction) CompletableFuture~U~
        +whenComplete(BiConsumer) CompletableFuture~T~
        
        %% 完成方法
        +complete(T) boolean
        +completeExceptionally(Throwable) boolean
        
        %% 获取结果
        +get() T
        +join() T
        +getNow(T) T
    &#125;
    
    class CompletionStage~T~ &#123;
        &lt;&lt;接口&gt;&gt;
        +thenApply(Function) CompletionStage~U~
        +thenCompose(Function) CompletionStage~U~
        +thenCombine(CompletionStage, BiFunction) CompletionStage~V~
        +exceptionally(Function) CompletionStage~T~
    &#125;
    
    class Future~T~ &#123;
        &lt;&lt;接口&gt;&gt;
        +get() T
        +get(long, TimeUnit) T
        +cancel(boolean) boolean
        +isDone() boolean
        +isCancelled() boolean
    &#125;
    
    CompletableFuture ..|&gt; CompletionStage : implements
    CompletableFuture ..|&gt; Future : implements</code></pre>
<h4 id="使用原则">使用原则</h4>
<p><strong>六大原则速览</strong>：</p>
<table>
<thead>
<tr>
<th>原则</th>
<th>核心要点</th>
<th>常见错误</th>
</tr>
</thead>
<tbody>
<tr>
<td>一：传线程池</td>
<td>异步回调必须显式指定线程池</td>
<td>使用默认 commonPool</td>
</tr>
<tr>
<td>二：不吞异常</td>
<td>用 exceptionally/handle 处理异常</td>
<td>不调用 get/join 导致异常被吞</td>
</tr>
<tr>
<td>三：饱和策略</td>
<td>有界队列 + 合适拒绝策略</td>
<td>无界队列导致 OOM</td>
</tr>
<tr>
<td>四：异常处理</td>
<td>链末端统一处理，或用 handle</td>
<td>只处理部分异常</td>
</tr>
<tr>
<td>五：设超时</td>
<td>用 orTimeout 或 get(timeout)</td>
<td>永远阻塞</td>
</tr>
<tr>
<td>六：不阻塞回调</td>
<td>用 thenCompose 替代阻塞调用</td>
<td>回调中调用同步阻塞方法</td>
</tr>
</tbody>
</table>
<h5 id="原则一：异步回调要传线程池">原则一：异步回调要传线程池</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 不指定线程池，使用默认的ForkJoinPool.commonPool()</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))  <span class="hljs-comment">// 可能在commonPool线程执行</span><br>    .thenAccept(result -&gt; save(result)); <span class="hljs-comment">// 可能在调用线程执行</span><br><br><span class="hljs-comment">// [正确] 明确指定线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ioExecutor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuExecutor</span> <span class="hljs-operator">=</span> Executors.newWorkStealingPool();<br><br>CompletableFuture.supplyAsync(() -&gt; fetchData(), ioExecutor)<br>    .thenApplyAsync(data -&gt; process(data), cpuExecutor)<br>    .thenAcceptAsync(result -&gt; save(result), ioExecutor);<br></code></pre></td></tr></table></figure>
<h5 id="原则二：completablefuture-中不要吞异常">原则二：CompletableFuture 中不要吞异常</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 异常被吞掉，无法感知</span><br>CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;出错了&quot;</span>);<br>&#125;).thenApply(result -&gt; result + <span class="hljs-string">&quot;processed&quot;</span>);<br><span class="hljs-comment">// 如果不调用get/join，异常永远不会被发现</span><br><br><span class="hljs-comment">// [正确] 使用exceptionally或handle处理异常</span><br>CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;出错了&quot;</span>);<br>&#125;).exceptionally(ex -&gt; &#123;<br>    log.error(<span class="hljs-string">&quot;任务执行失败&quot;</span>, ex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;默认值&quot;</span>;<br>&#125;).thenApply(result -&gt; result + <span class="hljs-string">&quot;processed&quot;</span>);<br><br><span class="hljs-comment">// [更好] 使用whenComplete记录日志，不影响异常传播</span><br>CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;出错了&quot;</span>);<br>&#125;).whenComplete((result, ex) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (ex != <span class="hljs-literal">null</span>) &#123;<br>        log.error(<span class="hljs-string">&quot;任务执行失败&quot;</span>, ex);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h5 id="原则三：自定义线程池时-注意饱和策略">原则三：自定义线程池时，注意饱和策略</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 使用无界队列，可能导致OOM</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;()  <span class="hljs-comment">// 无界队列</span><br>);<br><br><span class="hljs-comment">// [正确] 使用有界队列 + 合适的拒绝策略</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="hljs-comment">// 调用者执行策略</span><br>);<br></code></pre></td></tr></table></figure>
<h5 id="原则四：正确进行异常处理">原则四：正确进行异常处理</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 只处理部分异常</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))<br>    .exceptionally(ex -&gt; handleFetchError(ex));  <span class="hljs-comment">// 只能处理fetchData的异常</span><br><br><span class="hljs-comment">// [正确] 在链的末端统一处理异常</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))<br>    .thenApply(result -&gt; transform(result))<br>    .exceptionally(ex -&gt; &#123;<br>        <span class="hljs-comment">// 处理整个链中的任何异常</span><br>        log.error(<span class="hljs-string">&quot;处理失败&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> defaultValue;<br>    &#125;);<br><br><span class="hljs-comment">// [更好] 使用handle同时处理结果和异常</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))<br>    .handle((result, ex) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (ex != <span class="hljs-literal">null</span>) &#123;<br>            log.error(<span class="hljs-string">&quot;处理失败&quot;</span>, ex);<br>            <span class="hljs-keyword">return</span> defaultValue;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<h5 id="原则五：合理设置超时">原则五：合理设置超时</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 没有超时控制</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-comment">// 可能永远阻塞</span><br>    <span class="hljs-keyword">return</span> slowService.call();<br>&#125;);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.join();  <span class="hljs-comment">// 可能永远阻塞</span><br><br><span class="hljs-comment">// [正确] Java 9+ 使用orTimeout</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">return</span> slowService.call();<br>&#125;).orTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// [正确] Java 8 使用get with timeout</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>&#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>    future.cancel(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 处理超时</span><br>&#125;<br><br><span class="hljs-comment">// [更好] 使用completeOnTimeout提供默认值 (Java 9+)</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">return</span> slowService.call();<br>&#125;).completeOnTimeout(<span class="hljs-string">&quot;默认值&quot;</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>
<h5 id="completablefuture-allof-的超时控制">CompletableFuture.allOf 的超时控制</h5>
<p><code>CompletableFuture.allOf</code> 提供了一种更现代的批量任务等待方式，其核心优势体现在以下几个方面：</p>
<p><strong>统一异常处理</strong></p>
<p>传统的 <code>Future.get</code> 方式需要对每个任务单独捕获异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传统方式：重复的 try-catch</span><br><span class="hljs-keyword">for</span> (Future&lt;Response&gt; future : futures) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        future.get(<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>        log.error(<span class="hljs-string">&quot;Task timeout&quot;</span>, e);<br>    &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        log.error(<span class="hljs-string">&quot;Task failed&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>而 <code>CompletableFuture.allOf</code> 可以通过调用链统一处理所有子任务的异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 现代方式：统一的异常处理</span><br>CompletableFuture.allOf(completableFutures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>]))<br>    .exceptionally(e -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;One or more tasks failed:&quot;</span>, e);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;)<br>    .join();<br></code></pre></td></tr></table></figure>
<p>这种方式的优势在于：</p>
<ul>
<li><strong>单一职责</strong>：异常处理逻辑集中在一处，易于维护</li>
<li><strong>避免重复</strong>：不需要为每个任务写相同的 try-catch</li>
<li><strong>声明式风格</strong>：通过函数式编程链表达&quot;等待所有完成，统一处理异常&quot;的意图</li>
</ul>
<p><strong>组合式编程</strong></p>
<p><code>CompletableFuture.allOf</code> 支持链式调用，可以轻松组合多个异步操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture.allOf(futures)<br>    .thenRun(() -&gt; log.info(<span class="hljs-string">&quot;All tasks completed&quot;</span>))<br>    .exceptionally(e -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Some tasks failed&quot;</span>, e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;)<br>    .orTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS)  <span class="hljs-comment">// 整体超时</span><br>    .join();<br></code></pre></td></tr></table></figure>
<p><strong>与 Future.get 的关键区别</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Future.get 逐个等待</th>
<th>CompletableFuture.allOf</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>等待策略</strong></td>
<td>串行等待，总时间 = N x timeout</td>
<td>并行等待，总时间 = max(各任务时间)</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>每个任务单独 try-catch</td>
<td>统一的 exceptionally 处理</td>
</tr>
<tr>
<td><strong>超时语义</strong></td>
<td>每个任务独立的超时</td>
<td>整体超时（所有任务的总时间）</td>
</tr>
<tr>
<td><strong>代码风格</strong></td>
<td>命令式，循环 + try-catch</td>
<td>声明式，链式调用</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>可以中途退出（break/continue）</td>
<td>必须等待所有任务完成</td>
</tr>
</tbody>
</table>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>超时控制</strong>：<code>allOf</code> 本身不提供超时功能，需要配合 <code>get(timeout)</code> 或 <code>orTimeout</code> 使用</li>
<li><strong>无法中途退出</strong>：一旦调用 <code>allOf</code>，必须等待所有任务完成（即使部分任务已经失败）</li>
<li><strong>异常传播</strong>：任何一个子任务失败，<code>allOf</code> 都会失败，异常会被封装在 <code>CompletionException</code> 中</li>
</ol>
<h5 id="completablefuture-ortimeout-底层实现深入分析">CompletableFuture.orTimeout 底层实现深入分析</h5>
<p><code>CompletableFuture.orTimeout()</code> 和 JavaScript 的 <code>Promise.race + setTimeout</code> 在表面上实现了相同的功能——为异步操作附加超时控制。但二者的底层机制截然不同，这种差异根植于两种语言完全不同的并发模型。</p>
<p><strong>orTimeout 源码剖析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java: CompletableFuture.orTimeout 的底层实现 (JDK 9+, 简化)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">orTimeout</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>    <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// Delayer 是一个静态内部类，持有一个 ScheduledThreadPoolExecutor</span><br>        <span class="hljs-comment">// 本质上是向线程池提交了一个延迟任务</span><br>        whenComplete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Canceller</span>(<br>            Delayer.delay(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timeout</span>(<span class="hljs-built_in">this</span>), timeout, unit)));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br><span class="hljs-comment">// Delayer 的实现</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Delayer</span> &#123;<br>    <span class="hljs-comment">// 守护线程池，全局共享，负责所有 CompletableFuture 的超时调度</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScheduledThreadPoolExecutor delayer;<br>    <span class="hljs-keyword">static</span> &#123;<br>        delayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaemonThreadFactory</span>());<br>        delayer.setRemoveOnCancelPolicy(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> ScheduledFuture&lt;?&gt; delay(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>        <span class="hljs-keyword">return</span> delayer.schedule(command, delay, unit);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Timeout 任务：超时后将 Future 以 TimeoutException 完成</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Timeout</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">final</span> CompletableFuture&lt;?&gt; future;<br>    Timeout(CompletableFuture&lt;?&gt; future) &#123; <span class="hljs-built_in">this</span>.future = future; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (future != <span class="hljs-literal">null</span> &amp;&amp; !future.isDone())<br>            future.completeExceptionally(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>与 JavaScript setTimeout 的对比</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// JavaScript: Promise.race + setTimeout 的等价实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">orTimeout</span>(<span class="hljs-params">promise, timeoutMs</span>) &#123;<br>    <span class="hljs-keyword">const</span> timeoutPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// setTimeout 将回调注册到事件循环的定时器队列</span><br>        <span class="hljs-comment">// 由 libuv (Node.js) 或浏览器引擎的定时器机制管理</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;TimeoutException&#x27;</span>));<br>        &#125;, timeoutMs);<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise, timeoutPromise]);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>二者的关键差异可以从以下维度理解：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph Java[&quot;Java CompletableFuture.orTimeout&quot;]
        J1[&quot;ScheduledThreadPoolExecutor&lt;br/&gt;(守护线程池，全局共享)&quot;]
        J2[&quot;DelayQueue (最小堆)&lt;br/&gt;O(log n) 插入/取消&quot;]
        J3[&quot;独立线程执行超时回调&quot;]
        J4[&quot;多线程环境：需要 CAS/volatile&lt;br/&gt;保证 completeExceptionally 的线程安全&quot;]
        J1 --&gt; J2 --&gt; J3 --&gt; J4
    end
    
    subgraph JS[&quot;JavaScript setTimeout&quot;]
        JS1[&quot;事件循环定时器队列&lt;br/&gt;(libuv / 浏览器引擎)&quot;]
        JS2[&quot;红黑树或最小堆&lt;br/&gt;O(log n) 管理&quot;]
        JS3[&quot;主线程在下一个 tick 执行回调&quot;]
        JS4[&quot;单线程环境：天然无竞态&lt;br/&gt;无需同步原语&quot;]
        JS1 --&gt; JS2 --&gt; JS3 --&gt; JS4
    end
    
    style Java fill:#FFF3E0
    style JS fill:#FFFDE7</code></pre>
<table>
<thead>
<tr>
<th>维度</th>
<th>Java <code>CompletableFuture.orTimeout</code></th>
<th>JavaScript <code>Promise.race + setTimeout</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定时器实现</strong></td>
<td><code>ScheduledThreadPoolExecutor</code>（线程池 + DelayQueue）</td>
<td>事件循环内置定时器（libuv 红黑树 / 浏览器最小堆）</td>
</tr>
<tr>
<td><strong>回调执行线程</strong></td>
<td>ScheduledThreadPoolExecutor 的工作线程</td>
<td>主线程（事件循环的下一个 tick）</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>需要 CAS 保证 <code>completeExceptionally</code> 的原子性</td>
<td>单线程，天然无竞态</td>
</tr>
<tr>
<td><strong>取消机制</strong></td>
<td><code>Canceller</code> 在 Future 正常完成时取消定时任务；<code>setRemoveOnCancelPolicy(true)</code> 避免队列堆积</td>
<td><code>clearTimeout</code> 从定时器队列移除；但 <code>Promise.race</code> 无法自动取消</td>
</tr>
<tr>
<td><strong>精度</strong></td>
<td>依赖 <code>ScheduledThreadPoolExecutor</code> 的调度精度（通常毫秒级）</td>
<td>依赖事件循环 tick 频率（通常毫秒级，但受主线程阻塞影响）</td>
</tr>
<tr>
<td><strong>资源开销</strong></td>
<td>全局共享 1 个守护线程 + DelayQueue 堆操作</td>
<td>零额外线程，定时器由运行时管理</td>
</tr>
<tr>
<td><strong>任务真正取消</strong></td>
<td><code>orTimeout</code> 不会取消原始任务的执行线程</td>
<td><code>setTimeout</code> 不会取消原始 <code>fetch</code> 请求</td>
</tr>
</tbody>
</table>
<p><strong>共同缺陷：超时不等于取消</strong></p>
<p>无论是 Java 的 <code>orTimeout</code> 还是 JavaScript 的 <code>Promise.race</code>，超时后<strong>原始任务都不会被真正取消</strong>。Java 中 <code>supplyAsync</code> 提交的任务仍在线程池中运行；JavaScript 中 <code>fetch</code> 请求仍在进行网络 IO。要实现真正的取消，Java 需要配合 <code>cancel(true)</code> + 中断检查，JavaScript 需要使用 <code>AbortController</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java: 正确的超时 + 取消模式</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-comment">// 任务内部必须检查中断</span><br>    <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>        <span class="hljs-comment">// 执行工作...</span><br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>(<span class="hljs-string">&quot;interrupted&quot;</span>);<br>&#125;);<br><br>future.orTimeout(<span class="hljs-number">3</span>, TimeUnit.SECONDS)<br>      .whenComplete((result, ex) -&gt; &#123;<br>          <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> TimeoutException) &#123;<br>              future.cancel(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 尝试中断底层线程</span><br>          &#125;<br>      &#125;);<br></code></pre></td></tr></table></figure>
<p><strong>本质差异</strong>：Java 的 <code>CompletableFuture</code> 是在多线程模型上构建的异步抽象，超时调度需要额外的线程池和同步机制；JavaScript 的 <code>Promise</code> 是在单线程事件循环上构建的异步抽象，超时调度由运行时内置的定时器队列完成，无需额外线程。二者在 API 层面趋于一致（都是&quot;给异步操作附加超时&quot;），但底层的复杂度差异巨大——这正是并发模型选择对上层 API 设计的深远影响。</p>
<h5 id="原则六：避免在回调中阻塞">原则六：避免在回调中阻塞</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 在回调中阻塞</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; &#123;<br>        <span class="hljs-comment">// 阻塞操作，会占用线程池线程</span><br>        <span class="hljs-keyword">return</span> anotherService.syncCall(data);<br>    &#125;);<br><br><span class="hljs-comment">// [正确] 使用thenCompose处理嵌套的异步操作</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenCompose(data -&gt; &#123;<br>        <span class="hljs-comment">// 返回新的CompletableFuture，不阻塞</span><br>        <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(<br>            () -&gt; anotherService.syncCall(data), <br>            ioExecutor<br>        );<br>    &#125;);<br></code></pre></td></tr></table></figure>
<h4 id="完成保证原则">完成保证原则</h4>
<p>完成保证原则（Completion Guarantee Principle）是 CompletableFuture 编程中的一个核心设计模式，其核心思想是：</p>
<blockquote>
<p><strong>在调用 <code>join()</code> 或 <code>get()</code> 之前，确保目标 Future 已经完成，从而将阻塞操作转化为非阻塞的结果获取。</strong></p>
</blockquote>
<h5 id="为什么需要完成保证原则？">为什么需要完成保证原则？</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [问题] 直接调用join()会阻塞当前线程</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;result&quot;</span>;<br>&#125;);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.join();  <span class="hljs-comment">// 阻塞1秒</span><br><br><span class="hljs-comment">// [解决] 使用allOf确保完成后再join</span><br>CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(future);<br>allDone.thenApply(v -&gt; &#123;<br>    <span class="hljs-comment">// 此时future已完成，join()立即返回，不阻塞</span><br>    <span class="hljs-keyword">return</span> future.join();<br>&#125;);<br></code></pre></td></tr></table></figure>
<h5 id="完成保证原则的核心模式">完成保证原则的核心模式</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 模式：allOf() + thenApplyAsync() + join()</span><br>List&lt;CompletableFuture&lt;String&gt;&gt; futures = services.stream()<br>    .map(service -&gt; CompletableFuture.supplyAsync(() -&gt; service.call(), ioExecutor))<br>    .collect(Collectors.toList());<br><br>CompletableFuture&lt;List&lt;String&gt;&gt; resultFuture = CompletableFuture<br>    .allOf(futures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>]))  <span class="hljs-comment">// 1. 等待所有完成</span><br>    .thenApplyAsync(v -&gt; &#123;                              <span class="hljs-comment">// 2. 完成后执行回调</span><br>        <span class="hljs-keyword">return</span> futures.stream()<br>            .map(CompletableFuture::join)               <span class="hljs-comment">// 3. join()不阻塞</span><br>            .collect(Collectors.toList());<br>    &#125;, cpuExecutor);<br></code></pre></td></tr></table></figure>
<h5 id="完整示例">完整示例</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完成保证原则示例</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 核心思想：在调用join()之前，确保Future已完成</span><br><span class="hljs-comment"> * 模式：allOf() + thenApplyAsync() + join()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompletionGuaranteeExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建IO线程池（用于网络调用等IO密集型任务）</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ioPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>, r -&gt; &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;io-pool-&quot;</span> + System.nanoTime());<br>            t.setDaemon(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 创建CPU线程池（用于结果聚合等CPU密集型任务）</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<br>            Runtime.getRuntime().availableProcessors(),<br>            r -&gt; &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;cpu-pool-&quot;</span> + System.nanoTime());<br>                t.setDaemon(<span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        );<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;] 开始执行&quot;</span>);<br>            <br>            <span class="hljs-comment">// 1. 创建多个异步任务（模拟30个服务调用）</span><br>            List&lt;CompletableFuture&lt;String&gt;&gt; serviceFutures = IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">30</span>)<br>                .mapToObj(i -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;] 调用服务 &quot;</span> + i);<br>                    simulateIoOperation(i);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;result-&quot;</span> + i;<br>                &#125;, ioPool))<br>                .collect(Collectors.toList());<br><br>            <span class="hljs-comment">// 2. 应用完成保证原则：allOf() + thenApplyAsync() + join()</span><br>            CompletableFuture&lt;List&lt;String&gt;&gt; resultFuture = CompletableFuture<br>                .allOf(serviceFutures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>])) <span class="hljs-comment">// 等待所有完成</span><br>                .thenApplyAsync(v -&gt; &#123; <span class="hljs-comment">// 所有future完成后才执行此回调</span><br>                    System.out.println(<span class="hljs-string">&quot;\n[正确] 原则验证: 所有服务调用已完成，开始聚合结果&quot;</span>);<br>                    System.out.println(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;] 聚合阶段启动（CPU密集型）&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// 关键点：此处join() 100% 不阻塞！</span><br>                    List&lt;String&gt; results = serviceFutures.stream()<br>                        .map(future -&gt; &#123;<br>                            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                            <br>                            <span class="hljs-comment">// [要点] 完成保证原则核心：</span><br>                            <span class="hljs-comment">// 由于 allOf() 确保所有 future 已完成，</span><br>                            <span class="hljs-comment">// future.join() 直接返回内部存储的 result 字段</span><br>                            <span class="hljs-comment">// 无锁竞争、无上下文切换、无阻塞</span><br>                            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.join(); <br>                            <br>                            <span class="hljs-type">long</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> System.nanoTime() - start;<br>                            System.out.printf(<br>                                <span class="hljs-string">&quot;[%s] join() 耗时: %d ns, 结果: %s\n&quot;</span>, <br>                                Thread.currentThread().getName(), <br>                                duration, <br>                                result<br>                            );<br>                            <br>                            <span class="hljs-comment">// [注意] 重要验证：join() 耗时应接近 0（通常 &lt; 1000 ns）</span><br>                            <span class="hljs-comment">// 如果耗时 &gt; 10000 ns，说明存在阻塞（违反完成保证原则）</span><br>                            <span class="hljs-keyword">return</span> result;<br>                        &#125;)<br>                        .collect(Collectors.toList());<br>                    <br>                    <span class="hljs-keyword">return</span> results;<br>                &#125;, cpuPool) <span class="hljs-comment">// 显式指定CPU线程池，避免在IO线程执行计算</span><br>                .exceptionally(ex -&gt; &#123;<br>                    System.err.println(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;] [错误] 全局异常: &quot;</span> + ex.getMessage());<br>                    <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;GLOBAL_FALLBACK&quot;</span>);<br>                &#125;);<br><br>            <span class="hljs-comment">// 3. 获取最终结果（末端阻塞，由主线程执行）</span><br>            List&lt;String&gt; results = resultFuture.join();<br>            System.out.println(<span class="hljs-string">&quot;\n最终聚合结果: &quot;</span> + results.size() + <span class="hljs-string">&quot; 个结果&quot;</span>);<br>            results.forEach(r -&gt; System.out.println(<span class="hljs-string">&quot;  - &quot;</span> + r));<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ioPool.shutdown();<br>            cpuPool.shutdown();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟IO操作（可变延迟）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simulateIoOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 不同服务不同延迟，模拟真实场景</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span> + (id * <span class="hljs-number">10</span>) % <span class="hljs-number">200</span>;<br>            Thread.sleep(delay);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;IO操作被中断&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="对传统的线程池的效率改进">对传统的线程池的效率改进</h4>
<p>CompletableFuture 相对于一般线程池的改进主要来自于对于<strong>复杂结果编排的 API 优化，本身并不提供性能优化</strong>。</p>
<p>如果要实现性能优化，可以</p>
<ol>
<li>基于 Netty/NIO 实现了真正的异步 RPC：</li>
</ol>
<ul>
<li>发起调用后立即返回，不阻塞线程；</li>
<li>结果由 Netty 的 IO 线程（或专用回调线程）在数据到达时触发；</li>
<li>一个 IO 线程可同时管理成千上万个连接（C10K+）。</li>
</ul>
<ol start="2">
<li>CompletableFuture 被用作&quot;胶水层&quot;：</li>
</ol>
<ul>
<li>将 NIO 回调封装为 CompletableFuture（如 toCompletableFuture 工具方法）；</li>
<li>用 thenCompose / allOf 等组合多个异步 RPC；</li>
<li>业务逻辑不再关心回调注册，只关注数据流依赖。</li>
</ul>
<pre><code class="hljs mermaid">graph TD
    A[&quot;Client Request&quot;] --&gt; B[&quot;Inbound IO Thread&lt;br&gt;Netty EventLoop&quot;]
    B --&gt; C[&quot;Business Worker Thread&lt;br&gt;from biz-pool&quot;]

    C --&gt; d1[&quot;Create CF1 = new CompletableFuture()&quot;]
    C --&gt; d2[&quot;Create CF2 = new CompletableFuture()&quot;]
    C --&gt; d3[&quot;Create CF3 = new CompletableFuture()&quot;]

    d1 --&gt; e1[&quot;Register Observer1:&lt;br&gt;onSuccess → CF1.complete(...)&lt;br&gt;onFailure → CF1.completeEx(...)&quot;]
    d2 --&gt; e2[&quot;Register Observer2:&lt;br&gt;onSuccess → CF2.complete(...)&lt;br&gt;onFailure → CF2.completeEx(...)&quot;]
    d3 --&gt; e3[&quot;Register Observer3:&lt;br&gt;onSuccess → CF3.complete(...)&lt;br&gt;onFailure → CF3.completeEx(...)&quot;]

    e1 --&gt; f1[&quot;Call mtthrift.async(orderService, Observer1)&quot;]
    e2 --&gt; f2[&quot;Call mtthrift.async(productService, Observer2)&quot;]
    e3 --&gt; f3[&quot;Call mtthrift.async(deliveryService, Observer3)&quot;]

    f1 --&gt; g[&quot;Outbound IO Thread&lt;br&gt;Netty Client EventLoop&quot;]
    f2 --&gt; g
    f3 --&gt; g

    g --&gt; h1[&quot;(orderService)&quot;]
    g --&gt; h2[&quot;(productService)&quot;]
    g --&gt; h3[&quot;(deliveryService)&quot;]

    h1 --&gt;|Response| i1[&quot;Outbound IO Thread invokes&lt;br&gt;Observer1.onSuccess(result)&quot;]
    h2 --&gt;|Response| i2[&quot;Outbound IO Thread invokes&lt;br&gt;Observer2.onSuccess(result)&quot;]
    h3 --&gt;|Error| i3[&quot;Outbound IO Thread invokes&lt;br&gt;Observer3.onFailure(ex)&quot;]

    i1 --&gt; j1[&quot;CF1.complete(result)&quot;]
    i2 --&gt; j2[&quot;CF2.complete(result)&quot;]
    i3 --&gt; j3[&quot;CF3.completeExceptionally(ex)&quot;]

    j1 --&gt; k1[&quot;CF1.thenApplyAsync(enrichOrder, cpu-pool)&quot;]
    j2 --&gt; k2[&quot;CF2.thenApplyAsync(enrichProduct, cpu-pool)&quot;]
    j3 --&gt; k3[&quot;CF3.exceptionally(handleFallback)&quot;]

    k1 --&gt; l[&quot;CF4 = CF1.thenCombine(CF2, merge)&quot;]
    k2 --&gt; l
    k1 --&gt; m[&quot;CompletableFuture.allOf(CF1..CF30)&quot;]
    k2 --&gt; m
    k3 --&gt; m

    m --&gt; n[&quot;m.thenApplyAsync(aggregateAll, cpu-pool)&quot;]
    n --&gt; o[&quot;Final Result&quot;]
    o --&gt; p[&quot;Write Response via Inbound IO Thread&quot;]
    p --&gt; q[&quot;Client&quot;]

    classDef io fill:#d5e8d4,stroke:#82b366;
    classDef worker fill:#dae8fc,stroke:#6c8ebf;
    classDef outbound fill:#e1d5e7,stroke:#9673a6;
    classDef cf fill:#fff2cc,stroke:#d6b656;
    classDef service fill:#f8cecc,stroke:#b85450;
    classDef observer fill:#e6e6fa,stroke:#999;

    class B,p io
    class C,d1,d2,d3,e1,e2,e3,f1,f2,f3,k1,k2,k3,l,m,n worker
    class g,i1,i2,i3 outbound
    class j1,j2,j3,o cf
    class h1,h2,h3 service
    class e1,e2,e3 observer</code></pre>
<h2 id="rxjava">RxJava</h2>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#E1D5E7&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant Observable as Observable
    participant Operator1 as map
    participant Operator2 as filter
    participant Subscriber as Subscriber

    Note over Client,Subscriber: RxJava (响应式流)
    Client-&gt;&gt;Observable: create(emitter)
    Observable--&gt;&gt;Operator1: 注册操作符
    Operator1-&gt;&gt;Observable: map(transform)
    Observable--&gt;&gt;Operator2: 注册操作符
    Operator2-&gt;&gt;Observable: filter(predicate)
    Observable--&gt;&gt;Subscriber: subscribe(Subscriber)
    Note right of Client: 非阻塞订阅

    par 数据流处理
        Observable-&gt;&gt;Operator1: onNext(item)
        Operator1-&gt;&gt;Operator2: onNext(mapped)
        Operator2-&gt;&gt;Subscriber: onNext(filtered)
    end

    Observable-&gt;&gt;Subscriber: onComplete()
    Note over Client: 响应式: map/filter/subscribe</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心特点：数据流处理，背压支持</span><br>Observable&lt;String&gt; observable1 = Observable.fromCallable(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;).subscribeOn(Schedulers.io());<br><br>Observable&lt;String&gt; observable2 = Observable.fromCallable(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RxJava&quot;</span>;<br>&#125;).subscribeOn(Schedulers.io());<br><br><span class="hljs-comment">// [正确] 非阻塞：流式处理</span><br>Observable.zip(observable1, observable2, (s1, s2) -&gt; s1 + <span class="hljs-string">&quot; &quot;</span> + s2)<br>    .map(String::toUpperCase)<br>    .timeout(<span class="hljs-number">2</span>, TimeUnit.SECONDS)<br>    .onErrorReturn(ex -&gt; <span class="hljs-string">&quot;FALLBACK: &quot;</span> + ex.getMessage())<br>    .subscribe(<br>        result -&gt; System.out.println(<span class="hljs-string">&quot;结果: &quot;</span> + result),<br>        error -&gt; System.err.println(<span class="hljs-string">&quot;错误: &quot;</span> + error.getMessage())<br>    );<br><br><span class="hljs-comment">// [注意] RxJava通常不需要手动关闭调度器</span><br></code></pre></td></tr></table></figure>
<h2 id="reactor">Reactor</h2>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#9DC3E6&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant Flux as Flux
    participant Operator1 as map
    participant Operator2 as flatMap
    participant Subscriber as Subscriber

    Note over Client,Subscriber: Reactor (响应式流)
    Client-&gt;&gt;Flux: create(sink)
    Flux--&gt;&gt;Operator1: 注册操作符
    Operator1-&gt;&gt;Flux: map(transform)
    Flux--&gt;&gt;Operator2: 注册操作符
    Operator2-&gt;&gt;Flux: flatMap(asyncOp)
    Flux--&gt;&gt;Subscriber: subscribe(Subscriber)
    Note right of Client: 非阻塞订阅

    par 数据流处理
        Flux-&gt;&gt;Operator1: onNext(item)
        Operator1-&gt;&gt;Operator2: onNext(mapped)
        Operator2-&gt;&gt;Subscriber: onNext(result)
    end

    Flux-&gt;&gt;Subscriber: onComplete()
    Note over Client: 响应式: map/flatMap/subscribe</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心特点：响应式流，背压内建，Spring集成</span><br>Flux&lt;String&gt; flux1 = Flux.fromCallable(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;).subscribeOn(Schedulers.boundedElastic());<br><br>Flux&lt;String&gt; flux2 = Flux.fromCallable(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Reactor&quot;</span>;<br>&#125;).subscribeOn(Schedulers.boundedElastic());<br><br><span class="hljs-comment">// [正确] 非阻塞：声明式流处理</span><br>Flux.zip(flux1, flux2, (s1, s2) -&gt; s1 + <span class="hljs-string">&quot; &quot;</span> + s2)<br>    .map(String::toUpperCase)<br>    .timeout(Duration.ofSeconds(<span class="hljs-number">2</span>))<br>    .onErrorResume(ex -&gt; Mono.just(<span class="hljs-string">&quot;FALLBACK: &quot;</span> + ex.getMessage()))<br>    .subscribe(<br>        result -&gt; System.out.println(<span class="hljs-string">&quot;结果: &quot;</span> + result),<br>        error -&gt; System.err.println(<span class="hljs-string">&quot;错误: &quot;</span> + error.getMessage()),<br>        () -&gt; System.out.println(<span class="hljs-string">&quot;完成&quot;</span>)<br>    );<br><br><span class="hljs-comment">// [注意] Reactor通常由Spring管理生命周期</span><br></code></pre></td></tr></table></figure>
<hr>
<h1>虚拟线程：Java 并发模型的未来</h1>
<p>虚拟线程（Virtual Threads）是 JDK 21 正式引入的重要特性（JEP 444），代表了 Java 并发模型的未来方向。理解虚拟线程与传统线程池的差异，对架构决策至关重要。</p>
<h2 id="为什么需要虚拟线程？">为什么需要虚拟线程？</h2>
<h3 id="传统线程模型的困境">传统线程模型的困境</h3>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;传统平台线程模型&quot;
        A[Java Thread] --&gt;|1:1 映射| B[OS Thread]
        B --&gt; C[内核调度]
        C --&gt; D[上下文切换开销大]
        D --&gt; E[线程数受限于内存]
        E --&gt; F[线程池成为必需品]
    end
    
    subgraph &quot;问题&quot;
        F --&gt; G[线程池大小难以调优]
        F --&gt; H[阻塞操作浪费线程]
        F --&gt; I[高并发场景受限]
    end</code></pre>
<p>传统 Java 线程（平台线程）的问题：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
<th>影响</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>内存开销大</strong></td>
<td>每个线程默认栈大小 1MB</td>
<td>10000 线程 ≈ 10GB 内存</td>
</tr>
<tr>
<td><strong>创建成本高</strong></td>
<td>需要 OS 内核参与</td>
<td>创建/销毁耗时约 1ms</td>
</tr>
<tr>
<td><strong>上下文切换昂贵</strong></td>
<td>内核态切换</td>
<td>约 1-10μs 每次切换</td>
</tr>
<tr>
<td><strong>数量受限</strong></td>
<td>受 OS 和内存限制</td>
<td>通常数千到数万</td>
</tr>
</tbody>
</table>
<h3 id="虚拟线程的解决方案">虚拟线程的解决方案</h3>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;虚拟线程模型&quot;
        A1[Virtual Thread 1] --&gt; B1[Carrier Thread 1]
        A2[Virtual Thread 2] --&gt; B1
        A3[Virtual Thread 3] --&gt; B1
        A4[Virtual Thread 4] --&gt; B2[Carrier Thread 2]
        A5[Virtual Thread ...] --&gt; B2
        A6[Virtual Thread N] --&gt; B2
        
        B1 --&gt; C1[OS Thread 1]
        B2 --&gt; C2[OS Thread 2]
    end
    
    subgraph &quot;优势&quot;
        D[M:N 调度模型]
        E[JVM 管理调度]
        F[阻塞时自动让出]
        G[百万级并发]
    end</code></pre>
<h2 id="虚拟线程-vs-平台线程">虚拟线程 vs 平台线程</h2>
<h3 id="核心差异对比">核心差异对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>平台线程 (Platform Thread)</th>
<th>虚拟线程 (Virtual Thread)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>映射关系</strong></td>
<td>1:1 映射到 OS 线程</td>
<td>M:N 映射（多对少）</td>
</tr>
<tr>
<td><strong>调度者</strong></td>
<td>OS 内核</td>
<td>JVM（用户态调度）</td>
</tr>
<tr>
<td><strong>栈大小</strong></td>
<td>固定（默认 1MB）</td>
<td>动态增长（初始 KB 级）</td>
</tr>
<tr>
<td><strong>创建成本</strong></td>
<td>高（~1ms）</td>
<td>极低（~1μs）</td>
</tr>
<tr>
<td><strong>数量上限</strong></td>
<td>数千到数万</td>
<td>数百万</td>
</tr>
<tr>
<td><strong>阻塞行为</strong></td>
<td>阻塞 OS 线程</td>
<td>自动挂起，让出载体线程</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>CPU 密集型</td>
<td>IO 密集型</td>
</tr>
</tbody>
</table>
<h3 id="代码对比">代码对比</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ========== 传统平台线程池方式 ==========</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">platformPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">200</span>);<br><br><span class="hljs-comment">// 问题：200个线程处理10000个请求，大量时间浪费在等待IO</span><br>List&lt;Future&lt;String&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>    futures.add(platformPool.submit(() -&gt; &#123;<br>        <span class="hljs-comment">// 模拟IO操作（数据库查询、HTTP调用等）</span><br>        Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 线程被阻塞，无法处理其他请求</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result-&quot;</span> + id;<br>    &#125;));<br>&#125;<br><br><span class="hljs-comment">// ========== 虚拟线程方式 (JDK 21+) ==========</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">virtualPool</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    <span class="hljs-comment">// 优势：可以创建10000个虚拟线程，每个请求一个线程</span><br>    List&lt;Future&lt;String&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>        futures.add(virtualPool.submit(() -&gt; &#123;<br>            <span class="hljs-comment">// 虚拟线程阻塞时自动让出载体线程</span><br>            Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 不会阻塞载体线程！</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result-&quot;</span> + id;<br>        &#125;));<br>    &#125;<br>    <br>    <span class="hljs-comment">// 收集结果</span><br>    <span class="hljs-keyword">for</span> (Future&lt;String&gt; future : futures) &#123;<br>        System.out.println(future.get());<br>    &#125;<br>&#125; <span class="hljs-comment">// try-with-resources 自动关闭</span><br></code></pre></td></tr></table></figure>
<h2 id="虚拟线程的工作原理">虚拟线程的工作原理</h2>
<h3 id="挂载与卸载机制">挂载与卸载机制</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant VT as Virtual Thread
    participant CT as Carrier Thread
    participant OS as OS Thread
    participant IO as IO Operation

    Note over VT,OS: 虚拟线程执行流程
    
    VT-&gt;&gt;CT: 挂载 (mount)
    CT-&gt;&gt;OS: 执行用户代码
    
    VT-&gt;&gt;IO: 发起阻塞IO
    Note over VT: 检测到阻塞操作
    VT-&gt;&gt;CT: 卸载 (unmount)
    Note over CT: 载体线程空闲，可执行其他虚拟线程
    
    IO--&gt;&gt;VT: IO完成
    VT-&gt;&gt;CT: 重新挂载 (remount)
    CT-&gt;&gt;OS: 继续执行</code></pre>
<h3 id="虚拟线程调度模型：与-go-gpm-的对比">虚拟线程调度模型：与 Go GPM 的对比</h3>
<p>理解虚拟线程的调度机制，需要与 Go 语言的 GPM 模型进行对比。两者都实现了 M:N 调度，但设计哲学有所不同。</p>
<p><strong>Go 的 GPM 模型</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Go Runtime&quot;
        G1[Goroutine 1]
        G2[Goroutine 2]
        G3[Goroutine 3]
        G4[Goroutine 4]
        
        P1[P: Processor 1&lt;br/&gt;本地队列]
        P2[P: Processor 2&lt;br/&gt;本地队列]
        
        M1[M: OS Thread 1]
        M2[M: OS Thread 2]
        
        GQ[Global Queue&lt;br/&gt;全局队列]
        
        G1 --&gt; P1
        G2 --&gt; P1
        G3 --&gt; P2
        G4 --&gt; GQ
        
        P1 --&gt; M1
        P2 --&gt; M2
        
        M1 --&gt; OS1[OS Scheduler]
        M2 --&gt; OS1
    end
    
    style P1 fill:#90EE90
    style P2 fill:#90EE90</code></pre>
<p><strong>Java 虚拟线程模型</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;JVM&quot;
        VT1[Virtual Thread 1]
        VT2[Virtual Thread 2]
        VT3[Virtual Thread 3]
        VT4[Virtual Thread 4]
        
        WQ1[WorkQueue 1]
        WQ2[WorkQueue 2]
        
        CT1[Carrier Thread 1&lt;br/&gt;ForkJoinWorkerThread]
        CT2[Carrier Thread 2&lt;br/&gt;ForkJoinWorkerThread]
        
        VT1 -.unmounted.-&gt; WQ1
        VT2 --&gt; CT1
        VT3 --&gt; CT2
        VT4 -.unmounted.-&gt; WQ2
        
        CT1 --&gt; OS1[OS Thread 1]
        CT2 --&gt; OS2[OS Thread 2]
        
        OS1 --&gt; OSS[OS Scheduler]
        OS2 --&gt; OSS
    end
    
    style CT1 fill:#87CEEB
    style CT2 fill:#87CEEB</code></pre>
<p><strong>核心差异对比</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Go GPM</th>
<th>Java Virtual Thread</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>G (Goroutine)</strong></td>
<td>用户态协程</td>
<td>虚拟线程 (Virtual Thread)</td>
</tr>
<tr>
<td><strong>P (Processor)</strong></td>
<td>逻辑处理器，持有 G 的本地队列</td>
<td>无显式 P 概念，使用 ForkJoinPool 的 WorkQueue</td>
</tr>
<tr>
<td><strong>M (Machine)</strong></td>
<td>OS 线程</td>
<td>Carrier Thread (载体线程)</td>
</tr>
<tr>
<td><strong>调度器</strong></td>
<td>Go Runtime Scheduler</td>
<td>ForkJoinPool (work-stealing)</td>
</tr>
<tr>
<td><strong>队列模型</strong></td>
<td>本地队列 + 全局队列</td>
<td>每个 Carrier Thread 的 WorkQueue</td>
</tr>
<tr>
<td><strong>Work Stealing</strong></td>
<td>P 之间窃取 G</td>
<td>Carrier Thread 之间窃取任务</td>
</tr>
<tr>
<td><strong>阻塞处理</strong></td>
<td>M 阻塞时创建新 M</td>
<td>正常情况：Carrier Thread 不阻塞，虚拟线程 unmount；<strong>Pinning 场景</strong>（synchronized/JNI）：Carrier Thread 被阻塞</td>
</tr>
</tbody>
</table>
<p><strong>关键设计差异</strong></p>
<ol>
<li>
<p><strong>Go 的 P (Processor)</strong>：</p>
<ul>
<li>Go 显式引入了 P 的概念，作为 G 和 M 之间的中介</li>
<li>P 的数量通常等于 CPU 核心数（GOMAXPROCS）</li>
<li>P 持有本地队列，减少全局队列的竞争</li>
</ul>
</li>
<li>
<p><strong>Java 的简化模型</strong>：</p>
<ul>
<li>Java 没有显式的 P 概念</li>
<li>直接使用 ForkJoinPool 的 work-stealing 机制</li>
<li>Carrier Thread 数量默认等于 CPU 核心数</li>
<li>每个 Carrier Thread 有自己的 WorkQueue</li>
</ul>
</li>
</ol>
<p><strong>为什么 Java 不需要 P？</strong></p>
<p>Go 的 P 设计是为了解决以下问题：</p>
<ul>
<li>减少全局队列的锁竞争</li>
<li>支持 work-stealing</li>
<li>管理 G 的本地缓存</li>
</ul>
<p>Java 虚拟线程通过 <strong>ForkJoinPool</strong> 已经实现了这些功能：</p>
<ul>
<li>ForkJoinPool 本身就是为 work-stealing 设计的</li>
<li>每个 ForkJoinWorkerThread 有自己的双端队列</li>
<li>无需额外的 P 抽象层</li>
</ul>
<h3 id="虚拟线程的-continuation-机制：unmount-mount-的本质">虚拟线程的 Continuation 机制：unmount/mount 的本质</h3>
<p>虚拟线程的核心是 <strong>Continuation</strong>（延续）机制。这是理解 unmount/mount 行为的关键。</p>
<p><strong>什么是 Continuation？</strong></p>
<p>Continuation 是一种可以暂停和恢复执行的程序抽象。在 Java 中，它是 <code>jdk.internal.vm.Continuation</code> 类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简化的 Continuation 概念示例（实际是 JVM 内部实现）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Continuation</span> &#123;<br>    <span class="hljs-keyword">private</span> Object[] stack;  <span class="hljs-comment">// 保存的栈帧</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pc;          <span class="hljs-comment">// 程序计数器</span><br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行到 yield 点</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 保存当前栈帧和 PC</span><br>        <span class="hljs-comment">// 返回到调用者</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">resume</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 恢复栈帧和 PC</span><br>        <span class="hljs-comment">// 继续执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>虚拟线程的 unmount/mount 流程</strong></p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; Unmounted: 创建虚拟线程
    
    Unmounted --&gt; Mounted: mount()&lt;br/&gt;分配 Carrier Thread
    
    Mounted --&gt; Running: 开始执行
    
    Running --&gt; Unmounted: unmount()&lt;br/&gt;遇到阻塞操作
    
    Running --&gt; Pinned: 遇到 synchronized&lt;br/&gt;或 native 方法
    
    Pinned --&gt; Running: 阻塞操作完成&lt;br/&gt;(Carrier Thread 被阻塞)
    
    Unmounted --&gt; Mounted: IO 完成&lt;br/&gt;重新调度
    
    Running --&gt; [*]: 任务完成
    
    note right of Unmounted
        虚拟线程状态保存在堆中
        Continuation 保存栈帧
        不占用 Carrier Thread
    end note
    
    note right of Mounted
        虚拟线程在 Carrier Thread 上执行
        栈帧在 Carrier Thread 的栈上
    end note
    
    note right of Pinned
        无法 unmount
        Carrier Thread 被阻塞
        降级为平台线程行为
    end note</code></pre>
<p><strong>自动 unmount 的场景</strong></p>
<p>根据 JEP 444 和 JDK 源码，虚拟线程在以下场景会自动 unmount：</p>
<table>
<thead>
<tr>
<th>阻塞操作</th>
<th>是否 unmount</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>Thread.sleep()</code></strong></td>
<td>是</td>
<td>JDK 内部实现为 <code>Continuation.yield()</code></td>
</tr>
<tr>
<td><strong><code>Object.wait()</code></strong></td>
<td>是</td>
<td>不在 synchronized 块内时</td>
</tr>
<tr>
<td><strong><code>LockSupport.park()</code></strong></td>
<td>是</td>
<td>虚拟线程的标准阻塞原语</td>
</tr>
<tr>
<td><strong><code>BlockingQueue.take()</code></strong></td>
<td>是</td>
<td>内部使用 <code>LockSupport.park()</code></td>
</tr>
<tr>
<td><strong><code>Semaphore.acquire()</code></strong></td>
<td>是</td>
<td>内部使用 <code>LockSupport.park()</code></td>
</tr>
<tr>
<td><strong><code>ReentrantLock.lock()</code></strong></td>
<td>是</td>
<td>阻塞时使用 <code>LockSupport.park()</code></td>
</tr>
<tr>
<td><strong>Socket I/O</strong></td>
<td>是</td>
<td>JDK 改造为非阻塞实现</td>
</tr>
<tr>
<td><strong>File I/O</strong></td>
<td>是</td>
<td>JDK 改造为非阻塞实现</td>
</tr>
<tr>
<td><strong><code>synchronized</code> 块</strong></td>
<td>否</td>
<td><strong>Pinning 问题</strong></td>
</tr>
<tr>
<td><strong>JNI 调用</strong></td>
<td>否</td>
<td><strong>Pinning 问题</strong></td>
</tr>
<tr>
<td><strong>CPU 密集计算</strong></td>
<td>否</td>
<td>无阻塞点，无法 unmount</td>
</tr>
</tbody>
</table>
<p><strong>unmount 的实现原理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 虚拟线程阻塞时的简化流程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadBlocking</span> &#123;<br>    <br>    <span class="hljs-comment">// 当虚拟线程调用 Thread.sleep() 时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;<br>        <span class="hljs-comment">// 1. 检查当前线程是否是虚拟线程</span><br>        <span class="hljs-keyword">if</span> (Thread.currentThread().isVirtual()) &#123;<br>            <span class="hljs-comment">// 2. 调用 Continuation.yield()</span><br>            <span class="hljs-comment">//    - 保存当前栈帧到堆中</span><br>            <span class="hljs-comment">//    - 释放 Carrier Thread</span><br>            <span class="hljs-comment">//    - 注册唤醒回调（定时器）</span><br>            Continuation.<span class="hljs-keyword">yield</span>(SLEEP_SCOPE);<br>            <br>            <span class="hljs-comment">// 3. 当定时器触发时</span><br>            <span class="hljs-comment">//    - 虚拟线程被重新调度</span><br>            <span class="hljs-comment">//    - 分配新的 Carrier Thread</span><br>            <span class="hljs-comment">//    - 恢复栈帧，继续执行</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 平台线程：直接调用 OS sleep</span><br>            Thread0.sleep(millis);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>与 C 协程的差异：隐式 vs 显式调度</strong></p>
<p>这是一个关键的设计差异：</p>
<p><strong>C 协程（如 libco）</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C 协程支持显式 yield</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">coroutine_func</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Step 1\n&quot;</span>);<br>    co_yield();  <span class="hljs-comment">// 显式让出 CPU</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Step 2\n&quot;</span>);<br>    co_yield();  <span class="hljs-comment">// 再次显式让出</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Step 3\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Java 虚拟线程</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java 虚拟线程是隐式调度</span><br>Thread.ofVirtual().start(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Step 1&quot;</span>);<br>    <span class="hljs-comment">// 无法显式 yield！</span><br>    <span class="hljs-comment">// 只能通过阻塞操作触发 unmount</span><br>    Thread.sleep(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 隐式 yield</span><br>    System.out.println(<span class="hljs-string">&quot;Step 2&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>为什么 Java 选择隐式调度？</strong></p>
<ol>
<li><strong>向后兼容</strong>：现有的阻塞 API 无需修改即可工作</li>
<li><strong>简化编程</strong>：开发者无需关心调度细节</li>
<li><strong>安全性</strong>：避免程序员错误使用 yield 导致的问题</li>
<li><strong>性能</strong>：JVM 可以优化 unmount 时机</li>
</ol>
<p><strong>unmount 的性能开销</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// unmount 的成本分析</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnmountCost</span> &#123;<br>    <br>    <span class="hljs-comment">// 1. 保存栈帧到堆（几百纳秒）</span><br>    <span class="hljs-comment">//    - 拷贝栈帧数据</span><br>    <span class="hljs-comment">//    - 保存程序计数器</span><br>    <br>    <span class="hljs-comment">// 2. 释放 Carrier Thread（几十纳秒）</span><br>    <span class="hljs-comment">//    - 从 Carrier Thread 解绑</span><br>    <br>    <span class="hljs-comment">// 3. 重新调度（微秒级）</span><br>    <span class="hljs-comment">//    - 等待 IO 完成</span><br>    <span class="hljs-comment">//    - 分配新的 Carrier Thread</span><br>    <span class="hljs-comment">//    - 恢复栈帧</span><br>    <br>    <span class="hljs-comment">// 总开销：约 1-10 微秒</span><br>    <span class="hljs-comment">// 对比：平台线程上下文切换约 1-10 微秒</span><br>    <span class="hljs-comment">// 但虚拟线程的优势在于不阻塞 Carrier Thread</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>要点</strong></p>
<ol>
<li>
<p><strong>Java 虚拟线程不是&quot;完全&quot;的协程</strong>：</p>
<ul>
<li>无法在任意点 yield</li>
<li>只能在特定的阻塞点 unmount</li>
<li>这是设计选择，不是技术限制</li>
</ul>
</li>
<li>
<p><strong>unmount 是自动的，不是手动的</strong>：</p>
<ul>
<li>JVM 检测到阻塞操作时自动触发</li>
<li>开发者无需（也无法）显式控制</li>
</ul>
</li>
<li>
<p><strong>Pinning 是虚拟线程的限制</strong>：</p>
<ul>
<li><code>synchronized</code> 和 JNI 调用无法 unmount</li>
<li>这是当前实现的限制，未来可能改进</li>
</ul>
</li>
<li>
<p><strong>虚拟线程的价值不在于&quot;任意点切换&quot;</strong>：</p>
<ul>
<li>而在于&quot;阻塞时不浪费 Carrier Thread&quot;</li>
<li>这对 IO 密集型应用已经足够</li>
</ul>
</li>
</ol>
<h3 id="关键概念">关键概念</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 虚拟线程核心概念示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadConcepts</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 创建虚拟线程的三种方式</span><br>        <br>        <span class="hljs-comment">// 方式一：Thread.ofVirtual()</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">vt1</span> <span class="hljs-operator">=</span> Thread.ofVirtual()<br>            .name(<span class="hljs-string">&quot;virtual-thread-1&quot;</span>)<br>            .start(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;Running on: &quot;</span> + Thread.currentThread());<br>                System.out.println(<span class="hljs-string">&quot;Is virtual: &quot;</span> + Thread.currentThread().isVirtual());<br>            &#125;);<br>        <br>        <span class="hljs-comment">// 方式二：Thread.startVirtualThread()</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">vt2</span> <span class="hljs-operator">=</span> Thread.startVirtualThread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Quick virtual thread&quot;</span>);<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 方式三：Executors.newVirtualThreadPerTaskExecutor()</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;Virtual thread from executor&quot;</span>);<br>            &#125;);<br>        &#125;<br>        <br>        vt1.join();<br>        vt2.join();<br>        <br>        <span class="hljs-comment">// 2. 虚拟线程的特性</span><br>        Thread.ofVirtual().start(() -&gt; &#123;<br>            <span class="hljs-comment">// 获取载体线程（仅用于调试）</span><br>            <span class="hljs-comment">// 注意：生产代码不应依赖载体线程</span><br>            System.out.println(<span class="hljs-string">&quot;Virtual thread running&quot;</span>);<br>            <br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 阻塞操作会触发卸载</span><br>                Thread.sleep(<span class="hljs-number">100</span>);<br>                <span class="hljs-comment">// sleep 期间，载体线程可以执行其他虚拟线程</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;).join();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="虚拟线程的使用原则">虚拟线程的使用原则</h2>
<h3 id="原则一：不要池化虚拟线程">原则一：不要池化虚拟线程</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 不要池化虚拟线程！</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">wrongPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">100</span>, <br>    Thread.ofVirtual().factory()); <span class="hljs-comment">// 错误：限制了虚拟线程数量</span><br><br><span class="hljs-comment">// [正确] 每个任务一个虚拟线程</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">correctPool</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor();<br><span class="hljs-comment">// 虚拟线程非常轻量，无需池化</span><br></code></pre></td></tr></table></figure>
<p><strong>为什么虚拟线程无需池化？</strong></p>
<p>传统线程池的设计目的是<strong>复用昂贵的操作系统线程资源</strong>。理解这一点是理解虚拟线程设计哲学的关键。</p>
<p><strong>平台线程的成本结构</strong>：</p>
<table>
<thead>
<tr>
<th>成本项</th>
<th>平台线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>创建成本</strong></td>
<td>~1ms（需要 OS 内核参与）</td>
<td>~1μs（纯 JVM 对象创建）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>固定 1MB 栈空间</td>
<td>初始几 KB，按需增长</td>
</tr>
<tr>
<td><strong>调度开销</strong></td>
<td>内核态切换（~1-10μs）</td>
<td>用户态切换（纳秒级）</td>
</tr>
<tr>
<td><strong>数量上限</strong></td>
<td>数千到数万（受内存限制）</td>
<td>数百万（受堆内存限制）</td>
</tr>
</tbody>
</table>
<p><strong>虚拟线程的&quot;用完即弃&quot;设计</strong>：</p>
<p>根据 JEP 444，虚拟线程被设计为 <strong>use-and-throw-away</strong>（用完即弃）资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 虚拟线程的创建成本接近普通对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">vt</span> <span class="hljs-operator">=</span> Thread.ofVirtual().start(() -&gt; &#123;<br>    <span class="hljs-comment">// 执行任务</span><br>&#125;);<br><span class="hljs-comment">// 任务完成后，虚拟线程被 GC 回收，无需复用</span><br></code></pre></td></tr></table></figure>
<p><strong>池化虚拟线程的问题</strong>：</p>
<ol>
<li><strong>违背设计初衷</strong>：虚拟线程本身就是为了避免池化的复杂性</li>
<li><strong>限制并发能力</strong>：池化会人为限制虚拟线程数量，失去其核心优势</li>
<li><strong>增加复杂性</strong>：需要管理池的生命周期、任务队列等</li>
<li><strong>状态清理开销</strong>：复用线程需要清理 ThreadLocal 等状态，反而增加开销</li>
</ol>
<p><strong>对比示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 平台线程：必须池化</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">platformPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">200</span>);<br><span class="hljs-comment">// 原因：创建 10000 个平台线程会耗尽内存（10GB+）</span><br><br><span class="hljs-comment">// 虚拟线程：无需池化</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">virtualPool</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    <span class="hljs-comment">// 可以轻松创建 10000 个虚拟线程（仅需 ~20MB）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>        virtualPool.submit(() -&gt; doWork());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>要点</strong>：虚拟线程将&quot;线程&quot;从&quot;昂贵的需要复用的资源&quot;变成了&quot;廉价的可随意创建的对象&quot;。这是并发编程范式的重大转变。</p>
<h3 id="原则二：避免在虚拟线程中执行-cpu-密集型任务">原则二：避免在虚拟线程中执行 CPU 密集型任务</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] CPU密集型任务不适合虚拟线程</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    executor.submit(() -&gt; &#123;<br>        <span class="hljs-comment">// CPU密集型计算</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10_000_000_000L</span>; i++) &#123;<br>            result += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// [正确] CPU密集型任务使用平台线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<br>    Runtime.getRuntime().availableProcessors()<br>);<br>cpuPool.submit(() -&gt; &#123;<br>    <span class="hljs-comment">// CPU密集型计算</span><br>    <span class="hljs-keyword">return</span> heavyComputation();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>原因</strong>：虚拟线程的优势在于 IO 等待期间让出载体线程。CPU 密集型任务没有等待，无法发挥虚拟线程优势。</p>
<h3 id="原则三：注意-synchronized-和-native-方法的-pinning-问题">原则三：注意 synchronized 和 native 方法的 Pinning 问题</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [问题] synchronized 会导致虚拟线程 &quot;pinning&quot;（钉住载体线程）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PinningExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-comment">// [错误] synchronized 块内的阻塞操作会钉住载体线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">badMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 载体线程被钉住！</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// [正确] 使用 ReentrantLock 替代 synchronized</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodMethod</span><span class="hljs-params">()</span> &#123;<br>        reentrantLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 虚拟线程可以正常卸载</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            reentrantLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Pinning（钉住）</strong>：当虚拟线程执行 <code>synchronized</code> 块或 native 方法时，无法从载体线程卸载，导致载体线程被阻塞。</p>
<h3 id="原则四：正确使用-threadlocal">原则四：正确使用 ThreadLocal</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [注意] 虚拟线程与 ThreadLocal 的交互</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalWithVirtualThreads</span> &#123;<br>    <br>    <span class="hljs-comment">// 传统 ThreadLocal 在虚拟线程中仍然有效</span><br>    <span class="hljs-comment">// 但要注意：百万虚拟线程 × ThreadLocal 数据 = 巨大内存开销</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;ExpensiveObject&gt; threadLocal = <br>        ThreadLocal.withInitial(ExpensiveObject::<span class="hljs-keyword">new</span>);<br>    <br>    <span class="hljs-comment">// [推荐] 对于虚拟线程，考虑使用 ScopedValue (JDK 21 Preview)</span><br>    <span class="hljs-comment">// ScopedValue 是不可变的，更适合虚拟线程场景</span><br>    <span class="hljs-comment">// private static final ScopedValue&lt;String&gt; SCOPED_VALUE = ScopedValue.newInstance();</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 使用 ThreadLocal</span><br>        <span class="hljs-type">ExpensiveObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> threadLocal.get();<br>        <span class="hljs-comment">// ... 使用 obj</span><br>        <br>        <span class="hljs-comment">// [重要] 虚拟线程结束后，ThreadLocal 会被清理</span><br>        <span class="hljs-comment">// 但如果虚拟线程数量巨大，仍需注意内存</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="threadlocal-在虚拟线程中为何仍然有效？">ThreadLocal 在虚拟线程中为何仍然有效？</h3>
<p>这是一个重要的设计决策，需要从JVM实现层面理解：</p>
<pre><code class="hljs mermaid">graph LR
    A[虚拟线程创建] --&gt; B[继承载体线程ThreadLocal]
    B --&gt; C[创建独立ThreadLocal映射]
    C --&gt; D[执行期间访问本地数据]
    D --&gt; E[虚拟线程结束]
    E --&gt; F[自动清理ThreadLocal]
    
    subgraph &quot;载体线程&quot;
        G[ThreadLocal Map]
    end
    
    subgraph &quot;虚拟线程&quot;
        H[独立ThreadLocal Map]
        I[执行任务]
    end
    
    G -.-&gt; B
    B --&gt; H
    H --&gt; D
    H --&gt; F</code></pre>
<p><strong>Technical Details</strong>：</p>
<ol>
<li><strong>继承机制</strong>：虚拟线程创建时会继承载体线程的ThreadLocal值副本</li>
<li><strong>独立存储</strong>：每个虚拟线程维护自己的ThreadLocal映射表，与载体线程隔离</li>
<li><strong>生命周期管理</strong>：虚拟线程结束时，JVM会自动清理其ThreadLocal变量，防止内存泄漏</li>
</ol>
<p><strong>JDK实现改进</strong>：</p>
<ul>
<li>增加了针对大量虚拟线程的内存优化策略</li>
<li>改进了ThreadLocal清理机制的性能</li>
<li>添加了虚拟线程专用的ThreadLocal访问路径</li>
</ul>
<h3 id="scopedvalue-为什么优于-threadlocal？">ScopedValue 为什么优于 ThreadLocal？</h3>
<p>对于虚拟线程场景，ScopedValue是更好的选择：</p>
<pre><code class="hljs mermaid">graph TD
    A[并发数据传递需求] --&gt; B&#123;选择哪种机制?&#125;
    B --&gt;|传统场景| C[ThreadLocal]
    B --&gt;|虚拟线程场景| D[ScopedValue]
    
    C --&gt; E[可变状态]
    C --&gt; F[潜在内存泄漏]
    C --&gt; G[性能开销]
    
    D --&gt; H[不可变数据]
    D --&gt; I[明确作用域]
    D --&gt; J[零内存泄漏风险]
    D --&gt; K[更高性能]</code></pre>
<p><strong>ScopedValue的核心优势</strong>：</p>
<ol>
<li><strong>不可变性保证</strong>：一旦设置就无法修改，避免并发修改问题</li>
<li><strong>作用域明确</strong>：具有清晰的生命周期边界，不会跨作用域泄漏</li>
<li><strong>M:N调度友好</strong>：不依赖具体线程身份，在虚拟线程的载体线程切换中表现更好</li>
<li><strong>性能优势</strong>：避免了ThreadLocal的哈希表查找和冲突处理开销</li>
</ol>
<p><strong>Specification依据</strong>：根据JEP 429和JEP 446规范，ScopedValue专为结构化并发和虚拟线程场景设计，解决了ThreadLocal在大规模并发下的根本性问题。</p>
<h2 id="虚拟线程与传统线程池的选择">虚拟线程与传统线程池的选择</h2>
<h3 id="决策流程图">决策流程图</h3>
<pre><code class="hljs mermaid">flowchart TD
    A[新任务] --&gt; B&#123;任务类型?&#125;
    
    B --&gt;|IO密集型| C&#123;JDK版本?&#125;
    C --&gt;|JDK 21+| D[使用虚拟线程]
    C --&gt;|JDK 21以下| E[使用传统IO线程池]
    
    B --&gt;|CPU密集型| F[使用平台线程池]
    F --&gt; G[线程数 = CPU核心数]
    
    B --&gt;|混合型| H&#123;主要瓶颈?&#125;
    H --&gt;|IO等待| D
    H --&gt;|CPU计算| F
    
    D --&gt; I[newVirtualThreadPerTaskExecutor]
    E --&gt; J[newCachedThreadPool 或 自定义线程池]
    
    style D fill:#90EE90
    style F fill:#87CEEB
    style E fill:#FFE4B5</code></pre>
<h3 id="场景对比">场景对比</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Web 服务器处理 HTTP 请求</strong></td>
<td>虚拟线程</td>
<td>大量 IO 等待（数据库、外部 API）</td>
</tr>
<tr>
<td><strong>批量数据处理/ETL</strong></td>
<td>虚拟线程</td>
<td>文件 IO、网络传输</td>
</tr>
<tr>
<td><strong>图像/视频处理</strong></td>
<td>平台线程池</td>
<td>CPU 密集型计算</td>
</tr>
<tr>
<td><strong>科学计算/机器学习</strong></td>
<td>平台线程池 + ForkJoinPool</td>
<td>CPU 密集型，需要并行计算</td>
</tr>
<tr>
<td><strong>实时交易系统</strong></td>
<td>平台线程池</td>
<td>低延迟要求，避免 JVM 调度开销</td>
</tr>
<tr>
<td><strong>微服务间调用</strong></td>
<td>虚拟线程</td>
<td>大量网络 IO 等待</td>
</tr>
</tbody>
</table>
<h3 id="迁移示例">迁移示例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从传统线程池迁移到虚拟线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MigrationExample</span> &#123;<br><br>    <span class="hljs-comment">// ========== 迁移前：传统线程池 ==========</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">legacyPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>        <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()<br>    );<br>    <br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">fetchDataLegacy</span><span class="hljs-params">(String url)</span> &#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;<br>            <span class="hljs-comment">// 模拟 HTTP 调用</span><br>            <span class="hljs-keyword">return</span> httpClient.get(url);<br>        &#125;, legacyPool);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ========== 迁移后：虚拟线程 ==========</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">virtualPool</span> <span class="hljs-operator">=</span> <br>        Executors.newVirtualThreadPerTaskExecutor();<br>    <br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">fetchDataVirtual</span><span class="hljs-params">(String url)</span> &#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;<br>            <span class="hljs-comment">// 相同的业务逻辑，无需修改</span><br>            <span class="hljs-keyword">return</span> httpClient.get(url);<br>        &#125;, virtualPool);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ========== 混合模式：IO 用虚拟线程，CPU 用平台线程 ==========</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ioPool</span> <span class="hljs-operator">=</span> <br>        Executors.newVirtualThreadPerTaskExecutor();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuPool</span> <span class="hljs-operator">=</span> <br>        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br>    <br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;ProcessedData&gt; <span class="hljs-title function_">fetchAndProcess</span><span class="hljs-params">(String url)</span> &#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture<br>            .supplyAsync(() -&gt; httpClient.get(url), ioPool)      <span class="hljs-comment">// IO：虚拟线程</span><br>            .thenApplyAsync(data -&gt; heavyProcess(data), cpuPool); <span class="hljs-comment">// CPU：平台线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="虚拟线程的性能特征">虚拟线程的性能特征</h2>
<h3 id="吞吐量对比">吞吐量对比</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 虚拟线程 vs 平台线程性能对比示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PerformanceComparison</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TASK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">100_000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">IO_DELAY_MS</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 平台线程池（200线程）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">platformTime</span> <span class="hljs-operator">=</span> benchmarkPlatformThreads();<br>        System.out.println(<span class="hljs-string">&quot;Platform threads: &quot;</span> + platformTime + <span class="hljs-string">&quot; ms&quot;</span>);<br>        <br>        <span class="hljs-comment">// 虚拟线程</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">virtualTime</span> <span class="hljs-operator">=</span> benchmarkVirtualThreads();<br>        System.out.println(<span class="hljs-string">&quot;Virtual threads: &quot;</span> + virtualTime + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">benchmarkPlatformThreads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">200</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <br>        List&lt;Future&lt;?&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; TASK_COUNT; i++) &#123;<br>            futures.add(pool.submit(() -&gt; &#123;<br>                Thread.sleep(IO_DELAY_MS);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;));<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (Future&lt;?&gt; f : futures) f.get();<br>        pool.shutdown();<br>        <br>        <span class="hljs-keyword">return</span> System.currentTimeMillis() - start;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">benchmarkVirtualThreads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>            List&lt;Future&lt;?&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; TASK_COUNT; i++) &#123;<br>                futures.add(pool.submit(() -&gt; &#123;<br>                    Thread.sleep(IO_DELAY_MS);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;));<br>            &#125;<br>            <br>            <span class="hljs-keyword">for</span> (Future&lt;?&gt; f : futures) f.get();<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> System.currentTimeMillis() - start;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 典型结果（100,000 任务，50ms IO 延迟）：</span><br><span class="hljs-comment">// Platform threads (200): ~25,000 ms</span><br><span class="hljs-comment">// Virtual threads: ~100 ms</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 虚拟线程快 250 倍！</span><br><span class="hljs-comment">// 原因：平台线程受限于 200 个线程，需要排队</span><br><span class="hljs-comment">//       虚拟线程可以同时处理所有任务</span><br></code></pre></td></tr></table></figure>
<h3 id="内存占用对比">内存占用对比</h3>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>10,000 线程内存</th>
<th>100,000 线程内存</th>
<th>1,000,000 线程内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>平台线程</td>
<td>~10 GB</td>
<td>~100 GB（不可行）</td>
<td>不可能</td>
</tr>
<tr>
<td>虚拟线程</td>
<td>~20 MB</td>
<td>~200 MB</td>
<td>~2 GB</td>
</tr>
</tbody>
</table>
<h2 id="总结：线程池技术的演进">总结：线程池技术的演进</h2>
<pre><code class="hljs mermaid">timeline
    title Java 并发模型演进
    
    section JDK 1.0-1.4
        1996 : Thread 类
             : 手动管理线程
    
    section JDK 5
        2004 : ExecutorService
             : ThreadPoolExecutor
             : 线程池标准化
    
    section JDK 7
        2011 : ForkJoinPool
             : 工作窃取算法
             : 分治并行
    
    section JDK 8
        2014 : CompletableFuture
             : 异步编程
             : 链式组合
    
    section JDK 21
        2023 : Virtual Threads
             : 百万级并发
             : 简化异步编程</code></pre>
<h3 id="技术选型总结">技术选型总结</h3>
<table>
<thead>
<tr>
<th>技术</th>
<th>适用场景</th>
<th>核心优势</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ThreadPoolExecutor</strong></td>
<td>通用任务执行</td>
<td>成熟稳定，参数可控</td>
<td>需要调优线程池参数</td>
</tr>
<tr>
<td><strong>ForkJoinPool</strong></td>
<td>分治/递归任务</td>
<td>工作窃取，高效并行</td>
<td>任务需可分解</td>
</tr>
<tr>
<td><strong>CompletableFuture</strong></td>
<td>异步编排</td>
<td>链式组合，声明式</td>
<td>注意线程池选择</td>
</tr>
<tr>
<td><strong>Virtual Threads</strong></td>
<td>IO 密集型高并发</td>
<td>轻量级，简化编程</td>
<td>JDK 21+，避免 Pinning</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>要点</strong>：虚拟线程不是要取代线程池，而是为 IO 密集型场景提供更简单、更高效的解决方案。在 CPU 密集型场景，传统线程池仍然是最佳选择。理解每种技术的适用场景，才能做出正确的架构决策。</p>
</blockquote>
<hr>
<h2 id="结构化并发-structured-concurrency">结构化并发 (Structured Concurrency)</h2>
<p>结构化并发的完整内容已独立成文，详见 <a href="https://magicliang.github.io/2026/02/07/Java-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91">Java 结构化并发</a>。</p>
<p>结构化并发（Structured Concurrency）借鉴结构化编程的思想，将并发任务的生命周期与代码的词法作用域绑定，解决传统并发编程中的线程泄漏、错误处理困难和取消传播困难三大问题。Java 从 JDK 19 开始引入 <code>StructuredTaskScope</code> API，经过多轮孵化和预览，提供了 <code>ShutdownOnFailure</code> 和 <code>ShutdownOnSuccess</code> 两种内置策略，与虚拟线程紧密协同。</p>
<h2 id="spring框架中的线程池实现与最佳实践">Spring框架中的线程池实现与最佳实践</h2>
<h3 id="spring线程池体系概述">Spring线程池体系概述</h3>
<p>Spring框架提供了多层次的线程池抽象，从底层的JDK线程池封装到高层的应用级线程池管理：</p>
<pre><code class="hljs mermaid">graph TD
    A[Spring线程池体系] --&gt; B&#123;抽象层级&#125;
    B --&gt;|底层封装| C[TaskExecutor接口]
    B --&gt;|中层实现| D[ThreadPoolTaskExecutor]
    B --&gt;|高层管理| E[TaskScheduler]
    B --&gt;|应用集成| F[@Async注解支持]
    
    C --&gt; G[SimpleAsyncTaskExecutor]
    C --&gt; H[ConcurrentTaskExecutor]
    C --&gt; I[ThreadPoolTaskExecutor]
    
    D --&gt; J[配置属性]
    D --&gt; K[生命周期管理]
    D --&gt; L[监控指标]
    
    E --&gt; M[定时任务]
    E --&gt; N[Cron表达式]
    E --&gt; O[延迟执行]</code></pre>
<h3 id="核心组件详解">核心组件详解</h3>
<h4 id="taskexecutor接口设计">TaskExecutor接口设计</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Spring的线程池抽象接口</span><br><span class="hljs-comment"> * 基于命令模式，提供统一的异步执行契约</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TaskExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行给定的Runnable任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> task 要执行的任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计优势</strong>：</p>
<ul>
<li>解耦了应用代码与具体线程池实现</li>
<li>提供了统一的异常处理机制</li>
<li>支持任务装饰器模式</li>
</ul>
<h4 id="threadpooltaskexecutor实现">ThreadPoolTaskExecutor实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolConfig</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title function_">taskExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>        <br>        <span class="hljs-comment">// 核心配置参数</span><br>        executor.setCorePoolSize(<span class="hljs-number">10</span>);           <span class="hljs-comment">// 核心线程数</span><br>        executor.setMaxPoolSize(<span class="hljs-number">50</span>);            <span class="hljs-comment">// 最大线程数</span><br>        executor.setQueueCapacity(<span class="hljs-number">200</span>);         <span class="hljs-comment">// 队列容量</span><br>        executor.setKeepAliveSeconds(<span class="hljs-number">60</span>);       <span class="hljs-comment">// 空闲线程存活时间</span><br>        <br>        <span class="hljs-comment">// 线程命名和拒绝策略</span><br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;spring-task-&quot;</span>);<br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>        <br>        <span class="hljs-comment">// 等待所有任务完成</span><br>        executor.setWaitForTasksToCompleteOnShutdown(<span class="hljs-literal">true</span>);<br>        executor.setAwaitTerminationSeconds(<span class="hljs-number">30</span>);<br>        <br>        <span class="hljs-comment">// 初始化线程池</span><br>        <span class="hljs-comment">// 注意: initialize()会立即创建corePoolSize个线程</span><br>        <span class="hljs-comment">// 如果希望延迟创建线程，可以设置:</span><br>        <span class="hljs-comment">// executor.setAllowCoreThreadTimeOut(true);</span><br>        executor.initialize();<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="与原生线程池的映射关系">与原生线程池的映射关系</h3>
<table>
<thead>
<tr>
<th>Spring组件</th>
<th>JDK原生组件</th>
<th>配置映射</th>
</tr>
</thead>
<tbody>
<tr>
<td>ThreadPoolTaskExecutor</td>
<td>ThreadPoolExecutor</td>
<td>1:1直接映射</td>
</tr>
<tr>
<td>SimpleAsyncTaskExecutor</td>
<td>ThreadFactory</td>
<td>每次创建新线程</td>
</tr>
<tr>
<td>ConcurrentTaskExecutor</td>
<td>ExecutorService</td>
<td>适配器模式</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph LR
    A[ThreadPoolTaskExecutor] --&gt; B[ThreadPoolExecutor]
    A --&gt; C[配置参数映射]
    
    C --&gt; D[corePoolSize]
    C --&gt; E[maxPoolSize]
    C --&gt; F[keepAliveTime]
    C --&gt; G[workQueue]
    
    B --&gt; H[实际执行]</code></pre>
<h3 id="定时任务：scheduledexecutorservice-vs-timer">定时任务：ScheduledExecutorService vs Timer</h3>
<h4 id="为什么不推荐使用-timer？">为什么不推荐使用 Timer？</h4>
<p>在 Java 5（2004年）引入 <code>ScheduledExecutorService</code> 之前，<code>java.util.Timer</code> 是实现定时任务的标准方式。但 <code>Timer</code> 有以下严重缺陷：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Timer</th>
<th>ScheduledExecutorService</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线程模型</strong></td>
<td>单线程执行所有任务</td>
<td>线程池，支持并行执行</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>任何任务抛出异常会导致 Timer 线程终止，所有后续任务停止</td>
<td>异常只影响当前任务，不影响其他任务</td>
</tr>
<tr>
<td><strong>时间精度</strong></td>
<td>系统时钟敏感，受系统时间调整影响</td>
<td>相对稳定，使用 <code>System.nanoTime()</code></td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>功能有限（仅支持固定延迟和固定频率）</td>
<td>支持更丰富的调度策略</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>非线程安全，创建后无法修改</td>
<td>线程安全，支持动态调整</td>
</tr>
</tbody>
</table>
<p><strong>Timer 的致命缺陷示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>();<br><br>timer.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Task 1 running&quot;</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Task 1 failed&quot;</span>);<br>    &#125;<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>);<br><br>timer.scheduleAtFixedRate(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Task 2 running&quot;</span>);  <span class="hljs-comment">// 永远不会执行！</span><br>    &#125;<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">Task</span> <span class="hljs-number">1</span> running<br><span class="hljs-keyword">Exception</span> <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;Timer-0&quot;</span> java.lang.RuntimeException: <span class="hljs-keyword">Task</span> <span class="hljs-number">1</span> failed<br>    <span class="hljs-keyword">at</span> ...<br>Timer-<span class="hljs-number">0</span> 线程终止，所有后续任务停止<br></code></pre></td></tr></table></figure>
<p><strong>ScheduledExecutorService 的正确行为</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br><br>executor.scheduleAtFixedRate(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Task 1 running&quot;</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Task 1 failed&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, SECONDS);<br><br>executor.scheduleAtFixedRate(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Task 2 running&quot;</span>);  <span class="hljs-comment">// 仍然会执行！</span><br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, SECONDS);<br></code></pre></td></tr></table></figure>
<p><strong>输出</strong>：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">Task</span> <span class="hljs-number">1</span> running<br><span class="hljs-built_in">Task</span> <span class="hljs-number">2</span> running<br><span class="hljs-built_in">Task</span> <span class="hljs-number">2</span> running<br>... (<span class="hljs-built_in">Task</span> <span class="hljs-number">2</span> 持续执行)<br></code></pre></td></tr></table></figure>
<p><strong>结论</strong>：<strong>永远不要在生产环境使用 Timer</strong>，它已经被 <code>ScheduledExecutorService</code> 完全取代。</p>
<h3 id="spring-scheduled-的默认陷阱：单线程调度器">Spring @Scheduled 的默认陷阱：单线程调度器</h3>
<h4 id="问题描述">问题描述</h4>
<p>在 Spring 中，<code>@Scheduled</code> 的执行由 <code>TaskScheduler</code>/<code>ScheduledTaskRegistrar</code> 驱动。<strong>未显式配置时，很多场景会退化到单线程调度器</strong>。</p>
<p>这是一个长期存在的坑，不同 Spring Boot 版本与配置路径略有差异：</p>
<ul>
<li><strong>Spring Boot 2.x</strong>: 默认使用单线程的 <code>ConcurrentTaskScheduler</code></li>
<li><strong>Spring Boot 3.x</strong>: 仍然是单线程，但提供了更好的配置支持（<code>spring.task.scheduling.pool.size</code>）</li>
<li><strong>核心问题</strong>: 无论哪个版本，<strong>默认调度器线程池大小都是1</strong>，需要显式配置才能并行执行</li>
</ul>
<p>但&quot;默认不一定是你想要的并行度&quot;是核心问题。</p>
<h4 id="问题影响">问题影响</h4>
<p><strong>结果</strong>：一个定时任务慢了，会拖住其他任务的触发/执行。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as Task1 (慢任务)
    participant T2 as Task2 (正常任务)
    participant T3 as Task3 (正常任务)
    participant S as 单线程调度器
    
    Note over S: 默认配置：单线程
    S-&gt;&gt;T1: 执行 Task1
    T1-&gt;&gt;T1: 执行中...（耗时5秒）
    
    Note over T2,T3: Task2 和 Task3 等待
    T2--xS: 无法执行
    T3--xS: 无法执行
    
    T1-&gt;&gt;S: 完成
    S-&gt;&gt;T2: 执行 Task2
    T2-&gt;&gt;S: 完成
    S-&gt;&gt;T3: 执行 Task3
    T3-&gt;&gt;S: 完成</code></pre>
<h4 id="正确做法：显式配置">正确做法：显式配置</h4>
<p><strong>方式一：实现 SchedulingConfigurer（最可控）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SchedulingConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SchedulingConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span><br>    <span class="hljs-keyword">public</span> ScheduledThreadPoolExecutor <span class="hljs-title function_">taskScheduler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">4</span>, r -&gt; &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>            t.setName(<span class="hljs-string">&quot;spring-scheduler-&quot;</span> + t.getId());<br>            t.setDaemon(<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;);<br>        exec.setRemoveOnCancelPolicy(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 注意: 以下配置会在shutdown时立即取消所有任务</span><br>        <span class="hljs-comment">// 如果需要优雅关闭，考虑设置为true或配合waitForTasksToCompleteOnShutdown使用</span><br>        exec.setExecuteExistingDelayedTasksAfterShutdownPolicy(<span class="hljs-literal">false</span>);<br>        exec.setContinueExistingPeriodicTasksAfterShutdownPolicy(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span> exec;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureTasks</span><span class="hljs-params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;<br>        taskRegistrar.setScheduler(taskScheduler());<br><br>        <span class="hljs-comment">// Spring 的错误处理钩子：防止异常导致任务静默停止/没人知道</span><br>        taskRegistrar.setErrorHandler(t -&gt;<br>            System.err.println(<span class="hljs-string">&quot;scheduled task error: &quot;</span> + t)<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>对应的任务</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Jobs</span> &#123;<br><br>    <span class="hljs-meta">@Scheduled(fixedDelayString = &quot;2000&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 永远 catch，ErrorHandler 是兜底，不是主策略</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            doCleanup();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-comment">// log + metrics</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>方式二：使用 ThreadPoolTaskScheduler（Spring 的包装）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ThreadPoolTaskScheduler <span class="hljs-title function_">threadPoolTaskScheduler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ThreadPoolTaskScheduler</span> <span class="hljs-variable">ts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskScheduler</span>();<br>    ts.setPoolSize(<span class="hljs-number">4</span>);<br>    ts.setThreadNamePrefix(<span class="hljs-string">&quot;spring-ts-&quot;</span>);<br>    ts.setRemoveOnCancelPolicy(<span class="hljs-literal">true</span>);<br>    ts.setErrorHandler(t -&gt; System.err.println(<span class="hljs-string">&quot;task error: &quot;</span> + t));<br>    ts.initialize();<br>    <span class="hljs-keyword">return</span> ts;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="关键要点">关键要点</h4>
<ul>
<li><strong>线程名很重要</strong>：排查线程栈、日志定位、告警归因都靠它</li>
<li><strong>ErrorHandler 更像&quot;集中兜底记录&quot;</strong>：你仍应在任务内部捕获异常并做业务级处理</li>
<li><strong>显式配置是必须的</strong>：不要依赖默认值，因为它可能不是你想要的</li>
</ul>
<h4 id="spring-的-fixedrate-fixeddelay-与-juc-的对应关系">Spring 的 fixedRate/fixedDelay 与 JUC 的对应关系</h4>
<table>
<thead>
<tr>
<th>Spring 注解</th>
<th>JUC 方法</th>
<th>语义</th>
<th>时间计算基准</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Scheduled(fixedRate=1000)</code></td>
<td><code>scheduleAtFixedRate</code></td>
<td>固定频率（理论上每1s执行）</td>
<td>上次<strong>开始时间</strong> + period</td>
</tr>
<tr>
<td><code>@Scheduled(fixedDelay=1000)</code></td>
<td><code>scheduleWithFixedDelay</code></td>
<td>固定延迟（完成后延迟1s再执行）</td>
<td>上次<strong>完成时间</strong> + delay</td>
</tr>
<tr>
<td><code>@Scheduled(cron=...)</code></td>
<td>无直接对应</td>
<td>Cron 语义（墙上时钟）</td>
<td>绝对时间点</td>
</tr>
</tbody>
</table>
<p><strong>关键差异</strong>：</p>
<ul>
<li><code>fixedRate</code>: 努力维持固定频率，但如果任务执行时间超过period，会等待任务完成后立即执行下一次</li>
<li><code>fixedDelay</code>: 严格保证任务间隔，每次都在完成后等待delay时间</li>
<li><code>cron</code>: 按照cron表达式的绝对时间执行，与任务执行时间无关</li>
</ul>
<p><strong>注意</strong>：<code>@Scheduled(cron=...)</code> 是 cron 语义（墙上时钟），通常更像 Quartz 的使用体验；但底层执行仍依赖 scheduler/线程池，仍会受线程池大小影响。</p>
<h4 id="避免-任务重入-的手段">避免&quot;任务重入&quot;的手段</h4>
<p>在 Spring 集群中，<code>@Scheduled</code> 默认每个实例都会跑一遍。常见做法：</p>
<ul>
<li>用 DB/Redis 分布式锁（ShedLock 是常用库）保证同一时刻只有一个实例执行</li>
<li>或用 leader election（K8s lease / ZK / etcd）</li>
</ul>
<p>此外即便单机，也可能因为任务慢造成&quot;下一次触发时上一次还没结束&quot;的重入风险（cron 语义更常见）。处理方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-meta">@Scheduled(cron = &quot;0 */1 * * * *&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!lock.tryLock()) &#123;<br>        <span class="hljs-comment">// 记录跳过执行，便于排查问题</span><br>        logger.warn(<span class="hljs-string">&quot;Previous job is still running, skipping this execution&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123; <br>        doJob(); <br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 捕获所有异常，防止任务静默停止</span><br>        logger.error(<span class="hljs-string">&quot;Job execution failed&quot;</span>, t);<br>    &#125; <span class="hljs-keyword">finally</span> &#123; <br>        lock.unlock(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="生产环境最佳实践">生产环境最佳实践</h3>
<h4 id="参数调优指南">参数调优指南</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductionThreadPoolConfig</span> &#123;<br>    <br>    <span class="hljs-comment">// IO密集型任务配置</span><br>    <span class="hljs-meta">@Bean(&quot;ioTaskExecutor&quot;)</span><br>    <span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title function_">ioTaskExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>        <br>        <span class="hljs-comment">// IO密集型：线程数 = CPU核心数 × (1 + IO等待时间/CPU计算时间)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">processors</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br>        executor.setCorePoolSize(processors * <span class="hljs-number">8</span>);    <span class="hljs-comment">// 假设IO/CPU = 7:1</span><br>        executor.setMaxPoolSize(processors * <span class="hljs-number">16</span>);<br>        executor.setQueueCapacity(<span class="hljs-number">1000</span>);<br>        <br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;io-worker-&quot;</span>);<br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>    <br>    <span class="hljs-comment">// CPU密集型任务配置</span><br>    <span class="hljs-meta">@Bean(&quot;cpuTaskExecutor&quot;)</span><br>    <span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title function_">cpuTaskExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>        <br>        <span class="hljs-comment">// CPU密集型：线程数 ≈ CPU核心数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">processors</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br>        executor.setCorePoolSize(processors);<br>        executor.setMaxPoolSize(processors);<br>        executor.setQueueCapacity(<span class="hljs-number">50</span>);<br>        <br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;cpu-worker-&quot;</span>);<br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="与其他框架组件的集成">与其他框架组件的集成</h3>
<h4 id="与-async注解集成">与@Async注解集成</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncBusinessService</span> &#123;<br>    <br>    <span class="hljs-meta">@Async(&quot;ioTaskExecutor&quot;)</span><br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">processIoTask</span><span class="hljs-params">(String taskId)</span> &#123;<br>        <span class="hljs-comment">// @Async已经将方法异步化到ioTaskExecutor，直接执行业务逻辑</span><br>        <span class="hljs-comment">// 不要再使用CompletableFuture.supplyAsync()，避免双重异步化</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 模拟IO操作</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(<span class="hljs-string">&quot;Processed: &quot;</span> + taskId);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>            <span class="hljs-comment">// Java 9+ 可用 CompletableFuture.failedFuture(e)</span><br>            CompletableFuture&lt;String&gt; failedFuture = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>&lt;&gt;();<br>            failedFuture.completeExceptionally(e);<br>            <span class="hljs-keyword">return</span> failedFuture;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Async(&quot;cpuTaskExecutor&quot;)</span><br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;Integer&gt; <span class="hljs-title function_">processCpuTask</span><span class="hljs-params">(List&lt;Integer&gt; numbers)</span> &#123;<br>        <span class="hljs-comment">// CPU密集型并行计算</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> numbers.parallelStream()<br>                           .mapToInt(Integer::intValue)<br>                           .sum();<br>        <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
<p>关于 JVM 内存模型（JMM）、volatile 语义、happens-before 规则等内容，请参阅<a href="/2026/02/07/JVM-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">《JVM 的内存模型与线程》</a>。</p>
<hr>
<h2 id="模式速查表">模式速查表</h2>
<table>
<thead>
<tr>
<th>模式</th>
<th>核心要点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线程池选型三板斧</strong></td>
<td>CPU 密集型：核心数+1；IO 密集型：核心数×2 或 核心数/(1-阻塞系数)；混合型：拆分为独立池</td>
<td>所有需要线程池的场景</td>
</tr>
<tr>
<td><strong>有界队列+明确拒绝策略</strong></td>
<td>永远不用无界队列（<code>Executors.newFixedThreadPool</code> 的 <code>LinkedBlockingQueue</code> 是无界的），必须设置队列容量和拒绝策略</td>
<td>生产环境线程池配置</td>
</tr>
<tr>
<td><strong>周期任务防御性编程</strong></td>
<td>周期任务必须 <code>try-catch(Throwable)</code> 包裹全部逻辑，否则首次异常后静默终止</td>
<td><code>scheduleAtFixedRate</code> / <code>scheduleWithFixedDelay</code></td>
</tr>
<tr>
<td><strong>cancel 后清理队列</strong></td>
<td>高频 cancel 场景必须 <code>setRemoveOnCancelPolicy(true)</code>，否则已取消任务堆积导致内存泄漏</td>
<td>超时控制、请求级定时任务</td>
</tr>
<tr>
<td><strong>shutdown 优雅关闭</strong></td>
<td><code>shutdown()</code> → <code>awaitTermination()</code> → <code>shutdownNow()</code> 三步走，给足等待时间</td>
<td>应用关闭、线程池生命周期管理</td>
</tr>
<tr>
<td><strong>FutureTask 状态机</strong></td>
<td>7 种状态单向流转（NEW→COMPLETING→NORMAL/EXCEPTIONAL/CANCELLED/INTERRUPTING/INTERRUPTED），CAS 保证线程安全</td>
<td>理解 Future 取消/异常行为</td>
</tr>
<tr>
<td><strong>execute vs submit</strong></td>
<td><code>execute</code> 异常由 <code>UncaughtExceptionHandler</code> 处理；<code>submit</code> 异常被 Future 吞掉，需 <code>get()</code> 才能感知</td>
<td>选择任务提交方式</td>
</tr>
<tr>
<td><strong>Rate vs Delay</strong></td>
<td><code>scheduleAtFixedRate</code>：基于理论时间轴，有追赶机制；<code>scheduleWithFixedDelay</code>：基于实际结束时间，无追赶</td>
<td>选择周期调度策略</td>
</tr>
<tr>
<td><strong>ThreadFactory 命名</strong></td>
<td>自定义 <code>ThreadFactory</code> 设置有意义的线程名前缀 + <code>UncaughtExceptionHandler</code></td>
<td>所有自建线程池</td>
</tr>
<tr>
<td><strong>CompletableFuture 异步编排</strong></td>
<td>优先用 <code>thenCompose</code> 替代 <code>thenApply</code> + <code>join</code> 嵌套；注意默认使用 <code>ForkJoinPool.commonPool()</code> 的风险</td>
<td>异步任务编排</td>
</tr>
<tr>
<td><strong>池隔离原则</strong></td>
<td>不同类型任务（CPU/IO/定时）使用独立线程池，避免相互影响</td>
<td>多类型任务并存的系统</td>
</tr>
<tr>
<td><strong>CAS + 锁分层</strong></td>
<td>高频操作（线程计数）用 CAS 无锁化，低频操作（workers 集合修改）用 mainLock 互斥</td>
<td>高并发状态管理（ThreadPoolExecutor 的 ctl 设计）</td>
</tr>
<tr>
<td><strong>Worker 不可重入锁</strong></td>
<td>Worker 继承 AQS 实现不可重入锁，<code>tryLock()</code> 失败说明线程正在执行任务，<code>shutdown()</code> 不应中断</td>
<td>区分空闲线程与工作线程</td>
</tr>
<tr>
<td><strong>CompletableFuture 完成保证</strong></td>
<td>每个 CompletableFuture 必须最终被完成（normal/exceptional/cancel），否则下游永久阻塞</td>
<td>异步编排中的资源泄漏防护</td>
</tr>
<tr>
<td><strong>虚拟线程使用原则</strong></td>
<td>不池化（每次创建新实例）、避免 CPU 密集型任务、注意 <code>synchronized</code> 导致的 Pinning</td>
<td>JDK 21+ IO 密集型高并发场景</td>
</tr>
<tr>
<td><strong>Spring @Scheduled 单线程陷阱</strong></td>
<td>Spring <code>@Scheduled</code> 默认使用单线程调度器，一个任务阻塞会影响所有定时任务，必须显式配置线程池</td>
<td>Spring 定时任务配置</td>
</tr>
</tbody>
</table>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/">https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="Java 并发编程笔记"><img class="cover" src="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-12</div><div class="info-item-2">Java 并发编程笔记</div></div><div class="info-2"><div class="info-item-1"> juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。高层语言的并发模型都要基于底层系统对硬件抽象和并发的设计来设计和实现，不能超出操作系统允许的范围。所谓的高级抽象总体上是简化对 OS 底层机制的复杂调用。 并发与异步 本文聚焦并发（Concurrency），即多任务在同一时间段内的交替或并行执行，核心问题是资源共享、线程同步与协作。 **异步（Asynchronous）**是另一维度：调用方发起操作后不等结果返回即继续执行，通过回调、Future或事件机制获取结果。异步可通过单线程事件循环实现，也可依托多线程并发实现。 二者关系：并发关注&quot;多任务如何执行与协调&quot;，异步关注&quot;调用是否阻塞等待&quot;。并发编程常涉及异步，但本文不展开异步编程模式（如响应式流、协程），相关内容请参阅《Java 线程池笔记》。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本...</div></div></div></a><a class="pagination-related" href="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" title="无锁队列"><img class="cover" src="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">无锁队列</div></div><div class="info-2"><div class="info-item-1">Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。 * * &lt;p&gt;原理说明： * - 仅允许一个线程调用 &#123;@code offer()&#125;，一个线程调用 &#123;@code poll()&#125;。 * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。 * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系： *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。 * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad）， *   ...</div></div></div></a><a class="pagination-related" href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-19</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1"> 版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374）。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级。但在深入讨论线程安全的分类之前，我们需要先理解 Java 内存模型——它是理解线程安全问题的理论基础。 Java 内存模型基础 Java 内存模型（Java Memory Model，JMM）是 Java 语言规范的一部分，定义了多线程程序中共享变量的访问规则。理解 JMM 是理解线程安全问题的基础。 为什么需要内存模型？ 现代计算机系统中，CPU 与主内存之间存在巨大的速度差异。为了弥补这一差距，硬件层面引入了多级缓存（L1、L2、L3 Cache）。这带来了一个问...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-135.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-69.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">卡表和 RSet 问题定义：为什么需要跨区域引用记录 JVM 垃圾收集器的核心工作之一是确定 live set——哪些对象仍然存活、不可回收。确定 live set 的标准做法是从 GC Roots（栈帧中的局部变量、静态字段等）出发，沿引用链遍历所有可达对象。 问题在于：当堆被划分为多个区域（代、Region）并且只回收其中一部分时，如何高效地找到从&quot;不回收区域&quot;指向&quot;回收区域&quot;的引用？ 以 Young GC 为例：只回收新生代，但老年代中可能持有指向新生代对象的引用。如果不处理这些跨代引用，就会错误地回收仍被老年代引用的新生代对象。最朴素的做法是扫描整个老年代来找出这些引用——但老年代通常远大于新生代，这样做的代价过高，违背了分代收集&quot;只回收一部分堆&quot;的初衷。 卡表（Card Table）和 RSet（Remembered Set）正是为解决这个问题而设计的辅助数据结构。二者的关系并非互相替代，而是层次不同、协作互补：卡表是底层的脏标记机制，RSet 是建立在卡表之上的更高层索引结构。 核心概念速览 在深入细节之前，...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-132.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">从执行器到线程池（from executor interface to thread pool implementation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%AC%E6%96%87%E6%A8%A1%E5%BC%8F%E6%80%BB%E8%A7%88"><span class="toc-number">1.1.</span> <span class="toc-text">本文模式总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">执行器继承体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E5%AD%99"><span class="toc-number">1.2.1.</span> <span class="toc-text">父子孙</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#executor-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">Executor 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#executorservice-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.3.</span> <span class="toc-text">ExecutorService 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abstractexecutorservice"><span class="toc-number">1.2.4.</span> <span class="toc-text">AbstractExecutorService</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadpoolexecutor"><span class="toc-number">1.2.5.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduledexecutorservice-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.6.</span> <span class="toc-text">ScheduledExecutorService 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduledthreadpoolexecutor-%E5%AF%B9-threadpoolexecutor-%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">1.2.7.</span> <span class="toc-text">ScheduledThreadPoolExecutor 对 ThreadPoolExecutor 的扩展</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinpool"><span class="toc-number">1.2.8.</span> <span class="toc-text">ForkJoinPool</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.3.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">AbstractExecutorService 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#newtaskfor%EF%BC%9A%E4%BB%BB%E5%8A%A1%E5%8C%85%E8%A3%85%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text">newTaskFor：任务包装的核心工厂方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#futuretask%EF%BC%9A%E4%BB%BB%E5%8A%A1%E5%8C%85%E8%A3%85%E7%9A%84%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">FutureTask：任务包装的标准实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E4%BD%93%E7%B3%BB%E4%B8%8E%E8%AE%BE%E8%AE%A1%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">类型体系与设计定位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%AD%97%E6%AE%B5%E4%B8%8E%E6%9E%84%E9%80%A0"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">成员字段与构造</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">状态机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%85%A5%E5%8F%A3%EF%BC%9Arun-%E4%B8%8E-runandreset"><span class="toc-number">2.1.1.4.</span> <span class="toc-text">执行入口：run() 与 runAndReset()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#run"><span class="toc-number">2.1.1.4.1.</span> <span class="toc-text">run()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#runner-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.1.4.2.</span> <span class="toc-text">runner 的生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#runandreset"><span class="toc-number">2.1.1.4.3.</span> <span class="toc-text">runAndReset()</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%B1%BB%E7%BB%88%E6%80%81%E6%96%B9%E6%B3%95%EF%BC%9Aset-setexception-cancel"><span class="toc-number">2.1.1.5.</span> <span class="toc-text">三类终态方法：set &#x2F; setException &#x2F; cancel</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#set-%EF%BC%9A%E6%AD%A3%E5%B8%B8%E5%AE%8C%E6%88%90"><span class="toc-number">2.1.1.5.1.</span> <span class="toc-text">set()：正常完成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#setexception-%EF%BC%9A%E5%BC%82%E5%B8%B8%E5%AE%8C%E6%88%90"><span class="toc-number">2.1.1.5.2.</span> <span class="toc-text">setException()：异常完成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cancel-%EF%BC%9A%E5%8F%96%E6%B6%88-%E4%B8%AD%E6%96%AD"><span class="toc-number">2.1.1.5.3.</span> <span class="toc-text">cancel()：取消&#x2F;中断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#finishcompletion-%EF%BC%9A%E7%BB%88%E6%80%81%E6%94%B6%E5%B0%BE"><span class="toc-number">2.1.1.5.4.</span> <span class="toc-text">finishCompletion()：终态收尾</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%9C%E8%8E%B7%E5%8F%96%EF%BC%9Aget-awaitdone-report"><span class="toc-number">2.1.1.6.</span> <span class="toc-text">结果获取：get() &#x2F; awaitDone() &#x2F; report()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#awaitdone-%EF%BC%9A%E8%87%AA%E6%97%8B-locksupport-park-%E7%9A%84%E9%98%BB%E5%A1%9E%E7%AD%89%E5%BE%85"><span class="toc-number">2.1.1.6.1.</span> <span class="toc-text">awaitDone()：自旋 + LockSupport.park 的阻塞等待</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#waitnode%EF%BC%9Atreiber-stack-%E8%8A%82%E7%82%B9"><span class="toc-number">2.1.1.6.2.</span> <span class="toc-text">WaitNode：Treiber Stack 节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#removewaiter-%EF%BC%9A%E6%B8%85%E7%90%86%E8%B6%85%E6%97%B6-%E4%B8%AD%E6%96%AD%E7%9A%84%E7%AD%89%E5%BE%85%E8%8A%82%E7%82%B9"><span class="toc-number">2.1.1.6.3.</span> <span class="toc-text">removeWaiter()：清理超时&#x2F;中断的等待节点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#report-%EF%BC%9A%E7%BB%88%E6%80%81%E5%88%B0%E8%BF%94%E5%9B%9E%E5%80%BC-%E5%BC%82%E5%B8%B8%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.1.1.6.4.</span> <span class="toc-text">report()：终态到返回值&#x2F;异常的转换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#futuretask-%E5%9C%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE%E8%B7%AF"><span class="toc-number">2.1.1.7.</span> <span class="toc-text">FutureTask 在线程池中的调用链路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#invokeall"><span class="toc-number">2.1.2.</span> <span class="toc-text">invokeAll</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%92%88%E5%AF%B9-runnable-%E7%9A%84-submit"><span class="toc-number">2.1.3.</span> <span class="toc-text">两种针对 Runnable 的 submit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E9%80%82%E9%85%8D%E5%99%A8%E4%B8%80%E8%A7%88"><span class="toc-number">2.1.4.</span> <span class="toc-text">相关适配器一览</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">ThreadPoolExecutor</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9E%B6%E6%9E%84%EF%BC%9Actl-%E4%B8%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">3.1.</span> <span class="toc-text">核心架构：ctl 与线程池状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpoolexecutor-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.2.</span> <span class="toc-text">ThreadPoolExecutor 如何管理任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%EF%BC%9A%E4%BB%BB%E5%8A%A1%E4%B8%8E%E7%BA%BF%E7%A8%8B%E8%A7%A3%E8%80%A6"><span class="toc-number">3.2.1.</span> <span class="toc-text">设计哲学：任务与线程解耦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8F%90%E4%BA%A4%E5%85%A5%E5%8F%A3%EF%BC%9Asubmit-%E4%B8%8E-execute"><span class="toc-number">3.2.2.</span> <span class="toc-text">任务提交入口：submit 与 execute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%EF%BC%9Aaddworker"><span class="toc-number">3.2.3.</span> <span class="toc-text">创建工作线程：addWorker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%BC%93%E5%86%B2%EF%BC%9A%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97"><span class="toc-number">3.2.4.</span> <span class="toc-text">任务缓冲：阻塞队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B%E6%8C%87%E5%8D%97"><span class="toc-number">3.2.4.1.</span> <span class="toc-text">阻塞队列选型指南</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadpoolexecutor-%E4%BB%BB%E5%8A%A1%E6%8B%92%E7%BB%9D"><span class="toc-number">3.2.5.</span> <span class="toc-text">ThreadPoolExecutor 任务拒绝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpoolexecutor-%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text">ThreadPoolExecutor 如何管理线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mainlock%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%85%A8%E5%B1%80%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">3.3.1.</span> <span class="toc-text">mainLock：线程池的全局互斥锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%95%B0%E4%BF%9D%E9%87%8F%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.2.</span> <span class="toc-text">线程数保量机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#corepoolsize-%E7%9A%84%E4%B8%89%E9%87%8D%E8%AF%AD%E4%B9%89"><span class="toc-number">3.3.2.1.</span> <span class="toc-text">corePoolSize 的三重语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%A2%9E%E5%8A%A0%E8%B7%AF%E5%BE%84"><span class="toc-number">3.3.2.2.</span> <span class="toc-text">线程增加路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%80%80%E5%87%BA%E8%B7%AF%E5%BE%84"><span class="toc-number">3.3.2.3.</span> <span class="toc-text">线程退出路径</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#allowcorethreadtimeout-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">3.3.2.4.</span> <span class="toc-text">allowCoreThreadTimeOut 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">3.3.2.5.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="toc-number">3.3.3.</span> <span class="toc-text">线程执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#worker-%E7%B1%BB%E5%AE%9A%E4%B9%89%E4%B8%8E%E9%94%81%E7%8A%B6%E6%80%81"><span class="toc-number">3.3.3.1.</span> <span class="toc-text">Worker 类定义与锁状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#runworker-%E4%B8%BB%E5%BE%AA%E7%8E%AF"><span class="toc-number">3.3.3.2.</span> <span class="toc-text">runWorker 主循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shutdown-%E4%B8%8E-stop-%E6%98%AF%E4%B8%A4%E7%A7%8D%E5%B9%B3%E8%A1%8C%E7%9A%84%E5%85%B3%E9%97%AD%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.3.3.</span> <span class="toc-text">SHUTDOWN 与 STOP 是两种平行的关闭策略</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%85%B3%E9%97%AD-threadpoolexecutor"><span class="toc-number">3.3.4.</span> <span class="toc-text">尝试关闭 ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%EF%BC%9Abeforeexecute-afterexecute-terminated"><span class="toc-number">3.3.5.</span> <span class="toc-text">生命周期钩子方法：beforeExecute &#x2F; afterExecute &#x2F; terminated</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%E5%AE%9A%E4%B9%89%E4%B8%8E%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">3.3.5.1.</span> <span class="toc-text">钩子方法定义与调用时机</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.5.2.</span> <span class="toc-text">典型应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.3.5.3.</span> <span class="toc-text">关键注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.3.5.4.</span> <span class="toc-text">钩子方法与状态机的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gettask-%E8%8E%B7%E5%8F%96%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.3.5.5.</span> <span class="toc-text">getTask 获取任务</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.3.6.</span> <span class="toc-text">回收线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#interruptidleworkers-%E4%B8%AD%E6%96%AD%E7%A9%BA%E9%97%B2%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.3.6.1.</span> <span class="toc-text">interruptIdleWorkers 中断空闲线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%94%80%E6%AF%81"><span class="toc-number">3.3.7.</span> <span class="toc-text">线程销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#processworkerexit-worker-%E9%80%80%E5%87%BA%E5%A4%84%E7%90%86"><span class="toc-number">3.3.7.1.</span> <span class="toc-text">processWorkerExit Worker 退出处理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E4%B8%8E%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">3.4.</span> <span class="toc-text">常见问题与替代方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%8F%82%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99"><span class="toc-number">3.4.1.</span> <span class="toc-text">调参的核心原则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="toc-number">3.4.2.</span> <span class="toc-text">替代方案对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">传统替代方案对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3java%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">现代Java并发框架对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.4.2.3.</span> <span class="toc-text">选择建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpoolexecutor-%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.5.</span> <span class="toc-text">ThreadPoolExecutor 监控与调优实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E9%87%87%E9%9B%86"><span class="toc-number">3.5.1.</span> <span class="toc-text">监控指标采集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.5.2.</span> <span class="toc-text">调优建议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.5.3.</span> <span class="toc-text">最终解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">ScheduledThreadPoolExecutor 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%A0%87%E5%87%86%E5%AE%9E%E7%8E%B0%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">延迟队列任务的标准实现模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#delayedworkqueue-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E6%8B%A9"><span class="toc-number">4.2.</span> <span class="toc-text">DelayedWorkQueue 的数据结构选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.</span> <span class="toc-text">任务调度的完整流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">4.4.</span> <span class="toc-text">内存管理和性能优化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scheduledexecutorservice-%E4%B8%8E-abstractexecutorservice-%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BE%A8%E6%9E%90"><span class="toc-number">4.5.</span> <span class="toc-text">ScheduledExecutorService 与 AbstractExecutorService 的关系辨析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%EF%BC%9Aapi-%E4%B9%8B%E9%97%B4%E6%98%AF%E5%90%A6%E4%B9%9F%E6%98%AF-abstractexecutorservice-%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">4.5.1.</span> <span class="toc-text">关键问题：API 之间是否也是 AbstractExecutorService 的调用关系？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#api-%E5%88%86%E7%B1%BB"><span class="toc-number">4.5.1.1.</span> <span class="toc-text">API 分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%AF%94"><span class="toc-number">4.5.1.2.</span> <span class="toc-text">实现对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%9B%BE%E7%A4%BA"><span class="toc-number">4.5.1.3.</span> <span class="toc-text">对比图示</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA"><span class="toc-number">4.5.1.4.</span> <span class="toc-text">关键结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scheduledexecutorservice-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">4.6.</span> <span class="toc-text">ScheduledExecutorService 核心机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#future-get-%E7%9A%84%E8%AF%AD%E4%B9%89%E5%B7%AE%E5%BC%82%EF%BC%9A%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BB%BB%E5%8A%A1-vs-%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.6.1.</span> <span class="toc-text">Future.get() 的语义差异：一次性任务 vs 周期任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E8%A1%8C%E5%8C%96%E9%93%81%E5%BE%8B%EF%BC%9A%E5%8D%95%E4%B8%80%E4%BB%BB%E5%8A%A1%E4%B8%B2%E8%A1%8C-%E4%B8%8D%E5%90%8C%E4%BB%BB%E5%8A%A1%E5%B9%B6%E8%A1%8C"><span class="toc-number">4.6.2.</span> <span class="toc-text">串行化铁律：单一任务串行，不同任务并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%82%E7%A7%BB-drift-%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%87%E5%B0%8F%E5%AF%BC%E8%87%B4%E7%9A%84%E6%89%A7%E8%A1%8C%E5%BB%B6%E8%BF%9F"><span class="toc-number">4.6.3.</span> <span class="toc-text">漂移（Drift）：线程池过小导致的执行延迟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#api-%E5%8F%82%E6%95%B0%E8%AF%AD%E4%B9%89%EF%BC%9Adelay-vs-period"><span class="toc-number">4.6.4.</span> <span class="toc-text">API 参数语义：delay vs period</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2%E7%9A%84%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90"><span class="toc-number">4.6.5.</span> <span class="toc-text">周期任务异常终止的深度解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E6%9C%AC%E5%8E%9F%E5%9B%A0%EF%BC%9A%E4%BB%BB%E5%8A%A1%E5%AF%B9%E8%B1%A1%E4%B8%8D%E5%86%8D%E9%87%8D%E6%96%B0%E5%85%A5%E9%98%9F"><span class="toc-number">4.6.5.1.</span> <span class="toc-text">根本原因：任务对象不再重新入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">4.6.5.2.</span> <span class="toc-text">其他分布式系统的异常处理策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">4.6.5.3.</span> <span class="toc-text">分布式任务调度系统的设计思路对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF"><span class="toc-number">4.6.5.3.1.</span> <span class="toc-text">两种核心设计思路</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BF%E9%87%8C-schedulerx-%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.6.5.3.2.</span> <span class="toc-text">阿里 SchedulerX 的设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BE%8E%E5%9B%A2-crane-%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.6.5.3.3.</span> <span class="toc-text">美团 Crane 的设计</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E5%AF%B9%E6%AF%94"><span class="toc-number">4.6.5.3.4.</span> <span class="toc-text">两种设计思路的优缺点对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-juc-%E9%87%87%E7%94%A8%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%A4%8D%E5%85%A5%E9%98%9F%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.6.5.3.5.</span> <span class="toc-text">为什么 JUC 采用任务重复入队设计?</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93"><span class="toc-number">4.6.5.3.6.</span> <span class="toc-text">设计模式总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cancel-true-vs-cancel-false-%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">4.6.6.</span> <span class="toc-text">cancel(true) vs cancel(false) 的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#setremoveoncancelpolicy-true-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">4.6.6.1.</span> <span class="toc-text">setRemoveOnCancelPolicy(true) 的重要性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%A4%8D%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%B2%E8%A1%8C%E5%8C%96%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="toc-number">4.6.6.2.</span> <span class="toc-text">周期任务复用对象与串行化的设计原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#time-%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%AF%E5%A4%8D%E7%94%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.6.7.</span> <span class="toc-text">time 字段的可复用设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA%E6%97%B6%E9%97%B4%E8%BD%B4-vs-%E5%BD%93%E4%B8%8B%E6%97%B6%E9%97%B4%E8%B5%B7%E7%82%B9%EF%BC%9Arate-vs-delay-%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%B7%AE%E5%BC%82"><span class="toc-number">4.6.8.</span> <span class="toc-text">理论时间轴 vs 当下时间起点：Rate vs Delay 的根本差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E7%BA%A7%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">4.6.9.</span> <span class="toc-text">工程级最佳实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">ForkJoinPool详解：分治并行的执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A%E5%88%86%E6%B2%BB%E5%B9%B6%E8%A1%8C%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-number">5.1.</span> <span class="toc-text">前言：分治并行的诞生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Aforkjoinpool%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-number">5.2.</span> <span class="toc-text">核心数据结构：ForkJoinPool的基石</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinpool%EF%BC%9A%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">5.2.1.</span> <span class="toc-text">ForkJoinPool：去中心化的调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">数据结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Ethreadpoolexecutor%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">与ThreadPoolExecutor的本质区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%B7%AE%E5%BC%82"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">关键差异</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinworkerthreadfactory%EF%BC%9A%E4%B8%93%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82"><span class="toc-number">5.2.2.</span> <span class="toc-text">ForkJoinWorkerThreadFactory：专用线程工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">接口定义与对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">关键区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fjp-%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.2.1.</span> <span class="toc-text">FJP 的扩展方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%84%8F%E4%B9%89"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">设计意义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinworkerthread%EF%BC%9A%E5%8D%8F%E4%BD%9C%E5%BC%8F%E6%89%A7%E8%A1%8C%E8%80%85"><span class="toc-number">5.2.3.</span> <span class="toc-text">ForkJoinWorkerThread：协作式执行者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Ethreadpoolexecutor-worker%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">与ThreadPoolExecutor.Worker的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">设计决策</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88forkjoinpool%E4%B8%8D%E4%BC%9A%E6%9C%89%E7%BA%BF%E7%A8%8B%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">5.2.3.4.</span> <span class="toc-text">线程安全特性：为什么ForkJoinPool不会有线程泄露问题？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#workqueue%EF%BC%9A%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.4.</span> <span class="toc-text">WorkQueue：双端队列的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96-work-stealing-%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.2.4.2.</span> <span class="toc-text">工作窃取（Work-Stealing）机制详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.4.3.</span> <span class="toc-text">核心操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lifo-fifo-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%99%BA%E6%85%A7%EF%BC%9A"><span class="toc-number">5.2.4.4.</span> <span class="toc-text">LIFO + FIFO 的设计智慧：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjointask-join-%E4%B8%8E-thread-join-%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%B7%AE%E5%BC%82"><span class="toc-number">5.2.4.5.</span> <span class="toc-text">ForkJoinTask.join() 与 Thread.join() 的本质差异</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjointask%EF%BC%9A%E4%BB%BB%E5%8A%A1%E6%8A%BD%E8%B1%A1"><span class="toc-number">5.2.5.</span> <span class="toc-text">ForkJoinTask：任务抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">核心结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%AD%90%E7%B1%BB"><span class="toc-number">5.2.5.2.</span> <span class="toc-text">标准子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Efuturetask%E7%9A%84%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.5.3.</span> <span class="toc-text">与FutureTask的关键区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AEapi%EF%BC%9A%E4%B8%8Ethreadpoolexecutor%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">5.3.</span> <span class="toc-text">关键API：与ThreadPoolExecutor的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinpool%E7%9A%84%E6%A0%B8%E5%BF%83api"><span class="toc-number">5.3.1.</span> <span class="toc-text">ForkJoinPool的核心API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%AE%A2%E6%88%B7%E7%AB%AFapi"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">外部客户端API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E8%AE%A1%E7%AE%97api"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">内部计算API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E4%B8%8E%E7%AE%A1%E7%90%86api"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">监控与管理API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinpool-%E4%B8%8E-abstractexecutorservice-%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BE%A8%E6%9E%90"><span class="toc-number">5.3.2.</span> <span class="toc-text">ForkJoinPool 与 AbstractExecutorService 的关系辨析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%EF%BC%9Asubmit-%E5%92%8C-execute-%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E5%90%A6%E6%94%B9%E5%8F%98%E4%BA%86%EF%BC%9F"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">关键问题：submit 和 execute 的关系是否改变了？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B51%EF%BC%9A%E6%99%AE%E9%80%9A-runnable-callable-%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.3.2.1.1.</span> <span class="toc-text">情况1：普通 Runnable&#x2F;Callable 任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B52%EF%BC%9Aforkjointask-%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.3.2.1.2.</span> <span class="toc-text">情况2：ForkJoinTask 任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%9B%BE%E7%A4%BA"><span class="toc-number">5.3.2.1.3.</span> <span class="toc-text">对比图示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA"><span class="toc-number">5.3.2.1.4.</span> <span class="toc-text">关键结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#api%E4%BD%BF%E7%94%A8%E8%BE%B9%E7%95%8C%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%B7%B7%E7%94%A8%EF%BC%9F"><span class="toc-number">5.3.3.</span> <span class="toc-text">API使用边界：为什么不能混用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8A%A8%E6%80%81%E9%80%82%E5%BA%94%E7%9A%84%E8%89%BA%E6%9C%AF"><span class="toc-number">5.4.</span> <span class="toc-text">线程调度机制：动态适应的艺术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E5%BA%A6%EF%BC%9A%E5%94%AF%E4%B8%80%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.1.</span> <span class="toc-text">并行度：唯一的核心参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">配置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E6%B1%A0%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">公共池的系统属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%9E%E9%99%85%E5%BD%B1%E5%93%8D%EF%BC%9A"><span class="toc-number">5.4.1.3.</span> <span class="toc-text">各参数的实际影响：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0core-max%E5%8F%82%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">5.4.2.</span> <span class="toc-text">无core&#x2F;max参数的设计哲学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#threadpoolexecutor%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">ThreadPoolExecutor的线程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjoinpool%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">ForkJoinPool的线程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parallelism-vs-corepoolsize-maximumspares-vs-maximumpoolsize%EF%BC%9A"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">parallelism vs corePoolSize, maximumSpares vs maximumPoolSize：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.2.4.</span> <span class="toc-text">线程回收机制对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fjp%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6%E7%BB%86%E8%8A%82"><span class="toc-number">5.4.2.5.</span> <span class="toc-text">FJP线程回收细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9A%E6%97%A0%E7%95%8C%E9%98%9F%E5%88%97%E4%B8%8E%E4%BB%BB%E5%8A%A1%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.4.3.</span> <span class="toc-text">为什么没有拒绝策略：无界队列与任务消费模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjoinpool-%E6%9E%84%E9%80%A0%E5%99%A8%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">ForkJoinPool 构造器对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">为什么不需要拒绝策略？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%97%A0%E7%95%8C%E4%BC%9A%E5%AF%BC%E8%87%B4-oom-%E5%90%97%EF%BC%9F"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">队列无界会导致 OOM 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E6%80%BB%E7%BB%93"><span class="toc-number">5.4.3.4.</span> <span class="toc-text">设计哲学总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.4.4.</span> <span class="toc-text">工作线程生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B9%B6%E8%A1%8C%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.5.</span> <span class="toc-text">实战案例：并行文件搜索系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82"><span class="toc-number">5.5.1.</span> <span class="toc-text">业务需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.5.2.</span> <span class="toc-text">数据结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">5.5.3.</span> <span class="toc-text">线程池初始化与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96%E8%A7%A3%E6%9E%90"><span class="toc-number">5.5.4.</span> <span class="toc-text">关键设计决策解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-recursivetask-%E8%80%8C%E4%B8%8D%E6%98%AF-recursiveaction%EF%BC%9F"><span class="toc-number">5.5.4.1.</span> <span class="toc-text">为什么使用 RecursiveTask 而不是 RecursiveAction？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E7%BD%AEthreshold-100%EF%BC%9F"><span class="toc-number">5.5.4.2.</span> <span class="toc-text">为什么设置THRESHOLD&#x3D;100？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88fork%E5%85%B6%E4%BB%96%E4%BB%BB%E5%8A%A1-%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-number">5.5.4.3.</span> <span class="toc-text">为什么fork其他任务，直接执行最后一个任务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B1%A0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%BD%BF%E7%94%A8%E5%85%AC%E5%85%B1%E6%B1%A0%EF%BC%9F"><span class="toc-number">5.5.4.4.</span> <span class="toc-text">为什么创建自定义池而不是使用公共池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88asyncmode-false%EF%BC%9F"><span class="toc-number">5.5.4.5.</span> <span class="toc-text">为什么asyncMode&#x3D;false？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forkjoinpool-%E4%B8%8E-threadpoolexecutor-%E7%9A%84%E5%AF%B9%E6%AF%94%E5%8F%8A-commonpool-%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.6.</span> <span class="toc-text">ForkJoinPool 与 ThreadPoolExecutor 的对比及 commonPool 实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinpool-vs-threadpoolexecutor-%E6%A0%B8%E5%BF%83%E5%B7%AE%E5%BC%82"><span class="toc-number">5.6.1.</span> <span class="toc-text">ForkJoinPool vs ThreadPoolExecutor 核心差异</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%BC%94%E8%BF%9B%E9%80%BB%E8%BE%91"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">线程池的演进逻辑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#commonpool-%E7%9A%84%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">5.6.2.</span> <span class="toc-text">commonPool 的并发控制机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9-completablefuture-%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">5.6.3.</span> <span class="toc-text">对 CompletableFuture 的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forkjoinpool-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.7.</span> <span class="toc-text">ForkJoinPool 常见错误模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#api%E6%B7%B7%E7%94%A8%E9%94%99%E8%AF%AF"><span class="toc-number">5.7.1.</span> <span class="toc-text">API混用错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i-o%E9%98%BB%E5%A1%9E%E9%94%99%E8%AF%AF%E4%B8%8E%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F"><span class="toc-number">5.7.2.</span> <span class="toc-text">I&#x2F;O阻塞错误与资源泄漏</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E4%BB%BB%E5%8A%A1%E6%AD%BB%E9%94%81%EF%BC%9A%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%87%B4%E5%91%BD%E7%BC%BA%E9%99%B7%E4%B8%8Eforkjoinpool%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.8.</span> <span class="toc-text">父子任务死锁：传统线程池的致命缺陷与ForkJoinPool的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%A5%A5%E9%A5%BF%E6%AD%BB%E9%94%81"><span class="toc-number">5.8.1.</span> <span class="toc-text">问题场景：线程池饥饿死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%8D%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">5.8.1.1.</span> <span class="toc-text">死锁复现代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-number">5.8.1.2.</span> <span class="toc-text">死锁分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">5.8.2.</span> <span class="toc-text">传统解决方案的局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%881%EF%BC%9A%E5%A2%9E%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%B9%E9%87%8F"><span class="toc-number">5.8.2.1.</span> <span class="toc-text">方案1：增大线程池容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%882%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%97%A0%E7%95%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.8.2.2.</span> <span class="toc-text">方案2：使用无界线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%883%EF%BC%9A%E7%88%B6%E5%AD%90%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.8.2.3.</span> <span class="toc-text">方案3：父子任务使用不同线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinpool%E7%9A%84%E6%A0%B9%E6%9C%AC%E6%80%A7%E8%A7%A3%E5%86%B3%EF%BC%9A%E5%8D%8F%E4%BD%9C%E5%BC%8F%E7%AD%89%E5%BE%85"><span class="toc-number">5.8.3.</span> <span class="toc-text">ForkJoinPool的根本性解决：协作式等待</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9Ajoin-%E4%B8%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%98%BB%E5%A1%9E"><span class="toc-number">5.8.3.1.</span> <span class="toc-text">核心机制：join()不是真正的阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C%E7%AD%89%E5%BE%85%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%9Aawaitjoin"><span class="toc-number">5.8.3.2.</span> <span class="toc-text">协作等待的核心：awaitJoin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E7%AA%83%E5%8F%96%E8%80%85%E6%9C%BA%E5%88%B6-help-stealer"><span class="toc-number">5.8.3.3.</span> <span class="toc-text">帮助窃取者机制（Help Stealer）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%88%B6%E5%AD%90%E4%BB%BB%E5%8A%A1%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%9B%B8%E4%BA%92%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-number">5.8.4.</span> <span class="toc-text">为什么父子任务可以不相互阻塞？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B1%82%E9%9D%A2%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8C%96%E8%A7%A3%E8%80%A6"><span class="toc-number">5.8.4.1.</span> <span class="toc-text">接口层面的异步化解耦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A4%A9%E7%84%B6%E9%80%82%E9%85%8D"><span class="toc-number">5.8.4.2.</span> <span class="toc-text">分治模式的天然适配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%9C%89%E9%99%90%E5%BA%A6%E7%9A%84%E5%BC%B9%E6%80%A7"><span class="toc-number">5.8.5.</span> <span class="toc-text">线程补偿机制：有限度的弹性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%97%A0%E9%99%90%E8%A1%A5%E5%81%BF%E5%90%97%EF%BC%9F"><span class="toc-number">5.8.5.1.</span> <span class="toc-text">线程可以无限补偿吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.8.5.2.</span> <span class="toc-text">补偿机制的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84%E7%A1%AC%E6%80%A7%E4%B8%8A%E9%99%90"><span class="toc-number">5.8.5.3.</span> <span class="toc-text">线程数的硬性上限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E8%BE%BE%E5%88%B0%E4%B8%8A%E9%99%90%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.8.5.4.</span> <span class="toc-text">当达到上限后会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%99%90%E5%88%B6%E8%A1%A5%E5%81%BF%EF%BC%9F"><span class="toc-number">5.8.5.5.</span> <span class="toc-text">为什么要限制补偿？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.8.5.6.</span> <span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E9%AA%8C%E8%AF%81"><span class="toc-number">5.8.6.</span> <span class="toc-text">对比验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjoinpool%E7%89%88%E6%9C%AC-%E4%B8%8D%E4%BC%9A%E6%AD%BB%E9%94%81"><span class="toc-number">5.8.6.1.</span> <span class="toc-text">ForkJoinPool版本（不会死锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">5.8.6.2.</span> <span class="toc-text">执行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%90%AF%E7%A4%BA"><span class="toc-number">5.8.7.</span> <span class="toc-text">设计启示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA%EF%BC%9A%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">5.9.</span> <span class="toc-text">结论：设计的本质</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">三种线程池的 execute() 实现对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%AF%94%E6%80%BB%E8%A7%88"><span class="toc-number">6.1.</span> <span class="toc-text">实现对比总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpoolexecutor%EF%BC%9A%E7%BB%8F%E5%85%B8%E7%9A%84-%E4%B8%89%E6%AE%B5%E5%BC%8F-%E5%88%A4%E6%96%AD"><span class="toc-number">6.2.</span> <span class="toc-text">ThreadPoolExecutor：经典的&quot;三段式&quot;判断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#scheduledthreadpoolexecutor%EF%BC%9A%E8%AF%AD%E4%B9%89%E8%BD%AC%E6%8D%A2-%E7%9B%B4%E6%8E%A5%E5%85%A5%E9%98%9F"><span class="toc-number">6.3.</span> <span class="toc-text">ScheduledThreadPoolExecutor：语义转换 + 直接入队</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#forkjoinpool%EF%BC%9A%E5%8C%85%E8%A3%85-%E5%A4%96%E9%83%A8%E9%98%9F%E5%88%97"><span class="toc-number">6.4.</span> <span class="toc-text">ForkJoinPool：包装 + 外部队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%9B%BE%E7%A4%BA"><span class="toc-number">6.5.</span> <span class="toc-text">对比图示</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%B4%9E%E5%AF%9F"><span class="toc-number">6.6.</span> <span class="toc-text">核心洞察</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84-workqueue-%E5%AF%B9%E6%AF%94"><span class="toc-number">6.7.</span> <span class="toc-text">三种线程池的 WorkQueue 对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%9E%B6%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">6.7.1.</span> <span class="toc-text">队列架构对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadpoolexecutor-%E7%9A%84-blockingqueue"><span class="toc-number">6.7.2.</span> <span class="toc-text">ThreadPoolExecutor 的 BlockingQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduledthreadpoolexecutor-%E7%9A%84-delayedworkqueue"><span class="toc-number">6.7.3.</span> <span class="toc-text">ScheduledThreadPoolExecutor 的 DelayedWorkQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinpool-%E7%9A%84-workqueue"><span class="toc-number">6.7.4.</span> <span class="toc-text">ForkJoinPool 的 WorkQueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E8%80%85%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">6.7.5.</span> <span class="toc-text">三者对比总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">线程池横切对比</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%B1%87%E6%80%BB"><span class="toc-number">7.1.</span> <span class="toc-text">异常处理汇总</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E5%AF%B9%E6%AF%94"><span class="toc-number">7.1.1.</span> <span class="toc-text">三种线程池的异常处理对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadpoolexecutor-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">7.1.2.</span> <span class="toc-text">ThreadPoolExecutor 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduledthreadpoolexecutor-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">7.1.3.</span> <span class="toc-text">ScheduledThreadPoolExecutor 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinpool-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">7.1.4.</span> <span class="toc-text">ForkJoinPool 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%95"><span class="toc-number">7.1.5.</span> <span class="toc-text">常见错误用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF1-%E4%BD%BF%E7%94%A8%E6%97%A0%E7%95%8C%E9%98%9F%E5%88%97%E5%AF%BC%E8%87%B4oom"><span class="toc-number">7.1.5.1.</span> <span class="toc-text">错误1: 使用无界队列导致OOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF2-newcachedthreadpool%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E7%88%86%E7%82%B8"><span class="toc-number">7.1.5.2.</span> <span class="toc-text">错误2: newCachedThreadPool导致线程爆炸</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF3-%E4%B8%8D%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0%E5%AF%BC%E8%87%B4%E6%8E%92%E6%9F%A5%E5%9B%B0%E9%9A%BE"><span class="toc-number">7.1.5.3.</span> <span class="toc-text">错误3: 不设置线程名称导致排查困难</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF4-shutdown-%E5%90%8E%E7%AB%8B%E5%8D%B3-awaittermination"><span class="toc-number">7.1.5.4.</span> <span class="toc-text">错误4: shutdown 后立即 awaitTermination</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF5-forkjoinpool-%E4%B8%AD%E6%89%A7%E8%A1%8C%E9%98%BB%E5%A1%9Ei-o"><span class="toc-number">7.1.5.5.</span> <span class="toc-text">错误5: ForkJoinPool 中执行阻塞I&#x2F;O</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF6-forkjoinpool-%E4%B8%8D%E5%85%B3%E9%97%AD"><span class="toc-number">7.1.5.6.</span> <span class="toc-text">错误6: ForkJoinPool 不关闭</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%AE%A1%E7%90%86%E5%AF%B9%E6%AF%94"><span class="toc-number">7.2.</span> <span class="toc-text">生命周期管理对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%AD%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">7.2.1.</span> <span class="toc-text">关闭机制对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadpoolexecutor-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">7.2.2.</span> <span class="toc-text">ThreadPoolExecutor 生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinpool-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">7.2.3.</span> <span class="toc-text">ForkJoinPool 生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E5%AF%B9%E6%AF%94"><span class="toc-number">7.3.</span> <span class="toc-text">监控指标对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%9B%91%E6%8E%A7api"><span class="toc-number">7.3.1.</span> <span class="toc-text">三种线程池的监控API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadpoolexecutor-%E7%9B%91%E6%8E%A7%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.3.2.</span> <span class="toc-text">ThreadPoolExecutor 监控实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinpool-%E7%9B%91%E6%8E%A7%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.3.3.</span> <span class="toc-text">ForkJoinPool 监控实践</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">The Executors</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">8.1.</span> <span class="toc-text">常用工厂方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#newfixedthreadpool"><span class="toc-number">8.1.1.</span> <span class="toc-text">newFixedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newcachedthreadpool"><span class="toc-number">8.1.2.</span> <span class="toc-text">newCachedThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newsinglethreadexecutor"><span class="toc-number">8.1.3.</span> <span class="toc-text">newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newsinglethreadscheduledexecutor"><span class="toc-number">8.1.4.</span> <span class="toc-text">newSingleThreadScheduledExecutor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newscheduledthreadpool"><span class="toc-number">8.1.5.</span> <span class="toc-text">newScheduledThreadPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newworkstealingpool-jdk-8"><span class="toc-number">8.1.6.</span> <span class="toc-text">newWorkStealingPool（JDK 8+）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">8.2.</span> <span class="toc-text">工厂方法对比总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%BB%BA%E8%AE%AE"><span class="toc-number">8.3.</span> <span class="toc-text">生产环境建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E6%96%B9%E6%B3%95%EF%BC%9Aunconfigurableexecutorservice"><span class="toc-number">8.4.</span> <span class="toc-text">包装方法：unconfigurableExecutorService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8-vs-%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%EF%BC%9A%E9%80%89%E6%8B%A9%E4%BE%9D%E6%8D%AE"><span class="toc-number">8.5.</span> <span class="toc-text">构造器 vs 工厂方法：选择依据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#threadpoolexecutor%EF%BC%9A%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.5.1.</span> <span class="toc-text">ThreadPoolExecutor：优先使用构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduledthreadpoolexecutor%EF%BC%9A%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">8.5.2.</span> <span class="toc-text">ScheduledThreadPoolExecutor：可以使用工厂方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinpool%EF%BC%9A%E9%80%9A%E7%94%A8%E5%B9%B6%E8%A1%8C%E4%BB%BB%E5%8A%A1%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95-%E9%80%92%E5%BD%92%E5%88%86%E6%B2%BB%E4%BB%BB%E5%8A%A1%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">8.5.3.</span> <span class="toc-text">ForkJoinPool：通用并行任务用工厂方法，递归分治任务用构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#newcachedthreadpool-vs-newfixedthreadpool%EF%BC%9A%E9%80%89%E6%8B%A9%E4%BE%9D%E6%8D%AE"><span class="toc-number">8.5.4.</span> <span class="toc-text">newCachedThreadPool vs newFixedThreadPool：选择依据</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.5.4.1.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">线程组</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E6%9C%AC%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84"><span class="toc-number">9.1.</span> <span class="toc-text">原本设计目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-number">9.2.</span> <span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">9.3.</span> <span class="toc-text">替代方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%80%81%E5%BA%A6"><span class="toc-number">9.4.</span> <span class="toc-text">官方态度</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">CompletionStage</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#completablefuture"><span class="toc-number">10.1.</span> <span class="toc-text">CompletableFuture</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98"><span class="toc-number">11.1.</span> <span class="toc-text">如何处理任务超时问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E4%BD%BF%E7%94%A8-futuretask-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">11.1.1.</span> <span class="toc-text">方法1：使用 FutureTask 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">11.1.2.</span> <span class="toc-text">方法2：使用条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E4%BD%BF%E7%94%A8-countdownlatch-cyclicbarrier"><span class="toc-number">11.1.3.</span> <span class="toc-text">方法3：使用 countDownLatch&#x2F;CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E6%96%AD"><span class="toc-number">11.2.</span> <span class="toc-text">自定义线程池实现自定义中断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">Java 异步执行中的异常处理与线程生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-futuretask-asyncuncaughtexceptionhandler-%E5%88%B0-uncaughtexceptionhandler"><span class="toc-number">12.1.</span> <span class="toc-text">从 FutureTask、AsyncUncaughtExceptionHandler 到 UncaughtExceptionHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%88%E6%AD%A2%E7%9A%84%E5%94%AF%E4%B8%80%E5%88%A4%E5%AE%9A%E6%A0%87%E5%87%86"><span class="toc-number">12.2.</span> <span class="toc-text">一、线程是否终止的唯一判定标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">12.2.1.</span> <span class="toc-text">会导致线程终止的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">12.2.2.</span> <span class="toc-text">不会导致线程终止的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-futuretask-%E5%AF%B9%E5%BC%82%E5%B8%B8%E4%BC%A0%E6%92%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">12.3.</span> <span class="toc-text">二、FutureTask 对异常传播路径的改变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#execute-%E4%B8%8E-submit-%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%B7%AE%E5%BC%82"><span class="toc-number">12.3.1.</span> <span class="toc-text">execute 与 submit 的根本差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#futuretask-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA%E7%82%B9"><span class="toc-number">12.3.2.</span> <span class="toc-text">FutureTask 中的异常拦截点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A6%82%E4%BD%95%E8%A2%AB%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%EF%BC%9Areport"><span class="toc-number">12.3.3.</span> <span class="toc-text">异常如何被重新抛出：report()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-uncaughtexceptionhandler-%E7%9A%84%E8%81%8C%E8%B4%A3%E8%BE%B9%E7%95%8C"><span class="toc-number">12.4.</span> <span class="toc-text">三、UncaughtExceptionHandler 的职责边界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">12.4.1.</span> <span class="toc-text">触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%83%BD%E5%8A%9B%E4%B8%8E%E9%99%90%E5%88%B6"><span class="toc-number">12.4.2.</span> <span class="toc-text">能力与限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-spring-asyncuncaughtexceptionhandler-%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">12.5.</span> <span class="toc-text">四、Spring AsyncUncaughtExceptionHandler 的作用范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">12.5.1.</span> <span class="toc-text">适用条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA%E6%96%B9%E5%BC%8F"><span class="toc-number">12.5.2.</span> <span class="toc-text">Spring 的异常拦截方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">12.5.3.</span> <span class="toc-text">对线程生命周期的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E4%B8%89%E7%A7%8D%E5%BC%82%E5%B8%B8%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">12.6.</span> <span class="toc-text">五、三种异常路径的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#async-void-%E6%96%B9%E6%B3%95"><span class="toc-number">12.6.1.</span> <span class="toc-text">@Async void 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0execute"><span class="toc-number">12.6.2.</span> <span class="toc-text">线程池execute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0-submit"><span class="toc-number">12.6.3.</span> <span class="toc-text">线程池 submit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E4%B8%A4%E7%A7%8D-handler-%E7%9A%84%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">12.7.</span> <span class="toc-text">六、两种 Handler 的推荐使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#asyncuncaughtexceptionhandler-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">12.7.1.</span> <span class="toc-text">AsyncUncaughtExceptionHandler（业务层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#uncaughtexceptionhandler-%E7%B3%BB%E7%BB%9F%E5%B1%82"><span class="toc-number">12.7.2.</span> <span class="toc-text">UncaughtExceptionHandler（系统层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">12.7.3.</span> <span class="toc-text">有返回值的异步任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">12.8.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">Spring 的异步支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpooltaskexecutor"><span class="toc-number">13.1.</span> <span class="toc-text">ThreadPoolTaskExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpooltaskexecutor-%E5%86%85%E9%83%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-number">13.2.</span> <span class="toc-text">ThreadPoolTaskExecutor 内部线程池的替换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E8%A3%85%E9%A5%B0"><span class="toc-number">13.2.1.</span> <span class="toc-text">推荐：使用初始化器装饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BB%A3%E7%90%86"><span class="toc-number">13.2.2.</span> <span class="toc-text">其他代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%A6%81%E6%9B%BF%E6%8D%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="toc-number">13.2.3.</span> <span class="toc-text">如果我们要替换线程池实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E8%A1%8C-trace-%E4%BC%A0%E9%80%92"><span class="toc-number">13.3.</span> <span class="toc-text">对线程池实行 trace 传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%E7%BB%9F%E4%B8%80%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">13.3.1.</span> <span class="toc-text">如果使用统一包装器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">异步编程的进化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%94%E8%BF%9B%E6%9C%AC%E8%B4%A8"><span class="toc-number">14.1.</span> <span class="toc-text">演进本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%B0%83%E7%94%A8%E6%97%B6%E5%BA%8F"><span class="toc-number">14.2.</span> <span class="toc-text">传统调用时序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-5-future"><span class="toc-number">14.2.1.</span> <span class="toc-text">Java 5 Future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#guava-listenablefuture"><span class="toc-number">14.2.2.</span> <span class="toc-text">Guava ListenableFuture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#completablefuture"><span class="toc-number">14.2.3.</span> <span class="toc-text">CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%A0%91"><span class="toc-number">14.2.3.1.</span> <span class="toc-text">执行树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-api"><span class="toc-number">14.2.3.2.</span> <span class="toc-text">核心 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">14.2.3.3.</span> <span class="toc-text">使用原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%80%EF%BC%9A%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E8%A6%81%E4%BC%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">14.2.3.3.1.</span> <span class="toc-text">原则一：异步回调要传线程池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%BA%8C%EF%BC%9Acompletablefuture-%E4%B8%AD%E4%B8%8D%E8%A6%81%E5%90%9E%E5%BC%82%E5%B8%B8"><span class="toc-number">14.2.3.3.2.</span> <span class="toc-text">原则二：CompletableFuture 中不要吞异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%B6-%E6%B3%A8%E6%84%8F%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-number">14.2.3.3.3.</span> <span class="toc-text">原则三：自定义线程池时，注意饱和策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E5%9B%9B%EF%BC%9A%E6%AD%A3%E7%A1%AE%E8%BF%9B%E8%A1%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">14.2.3.3.4.</span> <span class="toc-text">原则四：正确进行异常处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%BA%94%EF%BC%9A%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE%E8%B6%85%E6%97%B6"><span class="toc-number">14.2.3.3.5.</span> <span class="toc-text">原则五：合理设置超时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#completablefuture-allof-%E7%9A%84%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">14.2.3.3.6.</span> <span class="toc-text">CompletableFuture.allOf 的超时控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#completablefuture-ortimeout-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="toc-number">14.2.3.3.7.</span> <span class="toc-text">CompletableFuture.orTimeout 底层实现深入分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E5%85%AD%EF%BC%9A%E9%81%BF%E5%85%8D%E5%9C%A8%E5%9B%9E%E8%B0%83%E4%B8%AD%E9%98%BB%E5%A1%9E"><span class="toc-number">14.2.3.3.8.</span> <span class="toc-text">原则六：避免在回调中阻塞</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%88%99"><span class="toc-number">14.2.3.4.</span> <span class="toc-text">完成保证原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AE%8C%E6%88%90%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">14.2.3.4.1.</span> <span class="toc-text">为什么需要完成保证原则？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%88%99%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">14.2.3.4.2.</span> <span class="toc-text">完成保证原则的核心模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-number">14.2.3.4.3.</span> <span class="toc-text">完整示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BC%A0%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%95%88%E7%8E%87%E6%94%B9%E8%BF%9B"><span class="toc-number">14.2.3.5.</span> <span class="toc-text">对传统的线程池的效率改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rxjava"><span class="toc-number">14.3.</span> <span class="toc-text">RxJava</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reactor"><span class="toc-number">14.4.</span> <span class="toc-text">Reactor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">虚拟线程：Java 并发模型的未来</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">15.1.</span> <span class="toc-text">为什么需要虚拟线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9B%B0%E5%A2%83"><span class="toc-number">15.1.1.</span> <span class="toc-text">传统线程模型的困境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">15.1.2.</span> <span class="toc-text">虚拟线程的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B-vs-%E5%B9%B3%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">15.2.</span> <span class="toc-text">虚拟线程 vs 平台线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%B7%AE%E5%BC%82%E5%AF%B9%E6%AF%94"><span class="toc-number">15.2.1.</span> <span class="toc-text">核心差异对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AF%B9%E6%AF%94"><span class="toc-number">15.2.2.</span> <span class="toc-text">代码对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">15.3.</span> <span class="toc-text">虚拟线程的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">15.3.1.</span> <span class="toc-text">挂载与卸载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%8E-go-gpm-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">15.3.2.</span> <span class="toc-text">虚拟线程调度模型：与 Go GPM 的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84-continuation-%E6%9C%BA%E5%88%B6%EF%BC%9Aunmount-mount-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">15.3.3.</span> <span class="toc-text">虚拟线程的 Continuation 机制：unmount&#x2F;mount 的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="toc-number">15.3.4.</span> <span class="toc-text">关键概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">15.4.</span> <span class="toc-text">虚拟线程的使用原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%80%EF%BC%9A%E4%B8%8D%E8%A6%81%E6%B1%A0%E5%8C%96%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B"><span class="toc-number">15.4.1.</span> <span class="toc-text">原则一：不要池化虚拟线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%BA%8C%EF%BC%9A%E9%81%BF%E5%85%8D%E5%9C%A8%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C-cpu-%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1"><span class="toc-number">15.4.2.</span> <span class="toc-text">原则二：避免在虚拟线程中执行 CPU 密集型任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%89%EF%BC%9A%E6%B3%A8%E6%84%8F-synchronized-%E5%92%8C-native-%E6%96%B9%E6%B3%95%E7%9A%84-pinning-%E9%97%AE%E9%A2%98"><span class="toc-number">15.4.3.</span> <span class="toc-text">原则三：注意 synchronized 和 native 方法的 Pinning 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E5%9B%9B%EF%BC%9A%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8-threadlocal"><span class="toc-number">15.4.4.</span> <span class="toc-text">原则四：正确使用 ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadlocal-%E5%9C%A8%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BB%8D%E7%84%B6%E6%9C%89%E6%95%88%EF%BC%9F"><span class="toc-number">15.4.5.</span> <span class="toc-text">ThreadLocal 在虚拟线程中为何仍然有效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scopedvalue-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%98%E4%BA%8E-threadlocal%EF%BC%9F"><span class="toc-number">15.4.6.</span> <span class="toc-text">ScopedValue 为什么优于 ThreadLocal？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">15.5.</span> <span class="toc-text">虚拟线程与传统线程池的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">15.5.1.</span> <span class="toc-text">决策流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">15.5.2.</span> <span class="toc-text">场景对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB%E7%A4%BA%E4%BE%8B"><span class="toc-number">15.5.3.</span> <span class="toc-text">迁移示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E7%89%B9%E5%BE%81"><span class="toc-number">15.6.</span> <span class="toc-text">虚拟线程的性能特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">15.6.1.</span> <span class="toc-text">吞吐量对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%AF%B9%E6%AF%94"><span class="toc-number">15.6.2.</span> <span class="toc-text">内存占用对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">15.7.</span> <span class="toc-text">总结：线程池技术的演进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="toc-number">15.7.1.</span> <span class="toc-text">技术选型总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91-structured-concurrency"><span class="toc-number">15.8.</span> <span class="toc-text">结构化并发 (Structured Concurrency)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">15.9.</span> <span class="toc-text">Spring框架中的线程池实现与最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#spring%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">15.9.1.</span> <span class="toc-text">Spring线程池体系概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">15.9.2.</span> <span class="toc-text">核心组件详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#taskexecutor%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">15.9.2.1.</span> <span class="toc-text">TaskExecutor接口设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#threadpooltaskexecutor%E5%AE%9E%E7%8E%B0"><span class="toc-number">15.9.2.2.</span> <span class="toc-text">ThreadPoolTaskExecutor实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%8E%9F%E7%94%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">15.9.3.</span> <span class="toc-text">与原生线程池的映射关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%EF%BC%9Ascheduledexecutorservice-vs-timer"><span class="toc-number">15.9.4.</span> <span class="toc-text">定时任务：ScheduledExecutorService vs Timer</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8-timer%EF%BC%9F"><span class="toc-number">15.9.4.1.</span> <span class="toc-text">为什么不推荐使用 Timer？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-scheduled-%E7%9A%84%E9%BB%98%E8%AE%A4%E9%99%B7%E9%98%B1%EF%BC%9A%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">15.9.5.</span> <span class="toc-text">Spring @Scheduled 的默认陷阱：单线程调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">15.9.5.1.</span> <span class="toc-text">问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BD%B1%E5%93%8D"><span class="toc-number">15.9.5.2.</span> <span class="toc-text">问题影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95%EF%BC%9A%E6%98%BE%E5%BC%8F%E9%85%8D%E7%BD%AE"><span class="toc-number">15.9.5.3.</span> <span class="toc-text">正确做法：显式配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%A6%81%E7%82%B9"><span class="toc-number">15.9.5.4.</span> <span class="toc-text">关键要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-%E7%9A%84-fixedrate-fixeddelay-%E4%B8%8E-juc-%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">15.9.5.5.</span> <span class="toc-text">Spring 的 fixedRate&#x2F;fixedDelay 与 JUC 的对应关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D-%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%85%A5-%E7%9A%84%E6%89%8B%E6%AE%B5"><span class="toc-number">15.9.5.6.</span> <span class="toc-text">避免&quot;任务重入&quot;的手段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">15.9.6.</span> <span class="toc-text">生产环境最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97"><span class="toc-number">15.9.6.1.</span> <span class="toc-text">参数调优指南</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E9%9B%86%E6%88%90"><span class="toc-number">15.9.7.</span> <span class="toc-text">与其他框架组件的集成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-async%E6%B3%A8%E8%A7%A3%E9%9B%86%E6%88%90"><span class="toc-number">15.9.7.1.</span> <span class="toc-text">与@Async注解集成</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%BC%8F%E9%80%9F%E6%9F%A5%E8%A1%A8"><span class="toc-number">15.10.</span> <span class="toc-text">模式速查表</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        loader: {
          load: [
            // Four font extension packages (optional)
            //- '[tex]/bbm',
            //- '[tex]/bboldx',
            //- '[tex]/dsfont',
            '[tex]/mhchem'
          ],
          paths: {
            'mathjax-newcm': '[mathjax]/../@mathjax/mathjax-newcm-font',

            //- // Four font extension packages (optional)
            //- 'mathjax-bbm-extension': '[mathjax]/../@mathjax/mathjax-bbm-font-extension',
            //- 'mathjax-bboldx-extension': '[mathjax]/../@mathjax/mathjax-bboldx-font-extension',
            //- 'mathjax-dsfont-extension': '[mathjax]/../@mathjax/mathjax-dsfont-font-extension',
            'mathjax-mhchem-extension': '[mathjax]/../@mathjax/mathjax-mhchem-font-extension'
          }
        },
        output: {
          font: 'mathjax-newcm',
        },
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
          packages: {
            '[+]': [
              'mhchem'
            ]
          }
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          menuOptions: {
            settings: {
              enrich: false  // Turn off Braille and voice narration text automatic generation
            }
          },
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax@4.0.0/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>