<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 线程池笔记 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从执行器到线程池  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finan">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 线程池笔记">
<meta property="og:url" content="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="从执行器到线程池  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finan">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png">
<meta property="article:published_time" content="2026-01-24T13:50:09.000Z">
<meta property="article:modified_time" content="2026-02-07T04:43:43.166Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta property="article:tag" content="线程池">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 线程池笔记",
  "url": "https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/",
  "image": "https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png",
  "datePublished": "2026-01-24T13:50:09.000Z",
  "dateModified": "2026-02-07T04:43:43.166Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 线程池笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 线程池笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java 线程池笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-24T13:50:09.000Z" title="Created 2026-01-24 21:50:09">2026-01-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-07T04:43:43.166Z" title="Updated 2026-02-07 12:43:43">2026-02-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">71.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>298mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>从执行器到线程池</h1>
<blockquote>
<p>Pooling is the grouping together of resources (assets, equipment,<br>
personnel, effort, etc.) for the purposes of maximizing advantage or<br>
minimizing risk to the users. The term is used in finance, computing<br>
and equipment management.——wikipedia</p>
<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p>
<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p>
<p>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection<br>
Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池(Object<br>
Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</p>
</blockquote>
<p>Doug Lea 对线程池的期待有：</p>
<ol>
<li>改善性能。</li>
<li>有界地利用资源（多次强调 bounds）。</li>
<li>提供统计。</li>
</ol>
<h2 id="执行器继承体系">执行器继承体系</h2>
<p>“设计良好的API应该简单、一致、可扩展。”</p>
<p><img src="ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="ThreadPoolExecutorUML类图.png"></p>
<p>我们将任务交给执行器，于是有了执行器（executor）；我们将执行器内部用 FutureTask 包装任务，于是有了同步转异步，异步转同步的设计，和多种 API（ExecutorService 和 AbstractExecutorService）；我们将执行器用线程池来实现，于是我们得到了线程池执行器（ThreadPoolExecutor）。</p>
<ul>
<li>Executor：只定义&quot;执行&quot;契约</li>
<li>ExecutorService：定义生命周期、 多种任务类型（Runnable/Callable）、批量任务契约</li>
</ul>
<p><strong>这两层都是契约层，方法之间没有明确关联</strong>。</p>
<ul>
<li>AbstractExecutorService：只提供算法模板-这一层提供了方法在 execute 之上的实现，把 api 关联起来。但是唯独 execute 的实现空余了。</li>
<li>ThreadPoolExecutor：只实现 execute，并且围绕它搭建了一整套线程池的参考实现：Worker + 状态机 + 队列 + 拒绝策略 + 线程工厂。</li>
<li>FutureTask：只负责任务包装。但是它的<strong>两个父接口让它成为连接了 <code>execute(Runnable)</code>和<code>Future.get()</code>两个世界的桥梁</strong>。</li>
</ul>
<pre><code class="hljs mermaid">classDiagram
    class Executor &#123;
        &lt;&lt;interface&gt;&gt;
        +execute(Runnable command) void  // 基础执行契约
    &#125;
    
    class ExecutorService &#123;
        &lt;&lt;interface&gt;&gt;
        +submit(Callable~T~ task) Future~T~  // 新增：结果获取API
        +invokeAll(Collection~Callable~T~~ tasks) List~Future~T~~  // 新增：批量处理API
        +shutdown() void  // 新增：生命周期API
        +awaitTermination(long timeout, TimeUnit unit) boolean  // 新增：等待关闭API
    &#125;
    
    class AbstractExecutorService &#123;
        &lt;&lt;abstract&gt;&gt;
        # 所有高级功能都围绕 newTaskFor（有返回值和无返回值的任务类型） + execute 构建
        #newTaskFor(Callable~T~ callable) RunnableFuture~T~  // 新增：任务包装工厂API
        #newTaskFor(Runnable runnable, T value) RunnableFuture~T~  // 新增：任务包装工厂API
        
        +submit(Callable~T~ task) Future~T~  // 实现：包装+提交算法
        +invokeAll(Collection~Callable~T~~ tasks) List~Future~T~~  // 实现：批量包装+提交算法
        +invokeAny(Collection~Callable~T~~ tasks) T  // 实现：任意完成算法
        
        // 关键：execute() 是抽象的，留给子类实现
        ~execute(Runnable command) void
    &#125;
    
    class ThreadPoolExecutor &#123;
        -corePoolSize: int
        -maximumPoolSize: int
        -workQueue: BlockingQueue~Runnable~
        -workers: HashSet~Worker~
        -ctl: AtomicInteger          // 原子状态控制：高3位存状态，低29位存线程数
        -threadFactory: ThreadFactory  // 线程工厂
        -handler: RejectedExecutionHandler  // 拒绝策略
        
        +execute(Runnable command) void
        +shutdown() void
        +shutdownNow() List~Runnable~
        +beforeExecute(Thread t, Runnable r) void  // 钩子：任务执行前
        +afterExecute(Runnable r, Throwable t) void  // 钩子：任务执行后
        #terminated() void  // 钩子：线程池终止后
    &#125;
    
    class ForkJoinPool &#123;
        &lt;&lt;concrete&gt;&gt;
        -parallelism: int
        -workQueues: WorkQueue[]  // 工作窃取队列数组
        -commonPool: ForkJoinPool  // 静态共享池
        
        +execute(ForkJoinTask~?~ task) void  // 重载 execute，专用于 ForkJoinTask
        +submit(ForkJoinTask~T~ task) ForkJoinTask~T~  // 支持 ForkJoinTask 的 submit
        +invoke(ForkJoinTask~T~ task) T  // 同步调用并返回结果（核心方法）
        +shutdown() void
        +awaitTermination(...) boolean
        
        // 内部线程继承 ForkJoinWorkerThread
    &#125;
    
    class ScheduledExecutorService &#123;
        &lt;&lt;interface&gt;&gt;
        +schedule(Runnable command, long delay, TimeUnit unit) ScheduledFuture~?~  // 延迟执行
        +schedule(Callable~V~ callable, long delay, TimeUnit unit) ScheduledFuture~V~  // 延迟执行带返回值
        +scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) ScheduledFuture~?~  // 固定频率
        +scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) ScheduledFuture~?~  // 固定延迟
    &#125;
    
    class ScheduledThreadPoolExecutor &#123;
        &lt;&lt;concrete&gt;&gt;
        -corePoolSize: int                           // 核心线程数
        -delayedWorkQueue: DelayedWorkQueue          // 基于堆的延迟队列
        -continueExistingPeriodicTasksAfterShutdown: boolean  // 关闭后是否继续周期任务
        -executeExistingDelayedTasksAfterShutdown: boolean    // 关闭后是否执行延迟任务
        -removeOnCancel: boolean                     // 取消时是否从队列移除
        -decorator: ReentrantLock                    // 装饰器锁
        
        +schedule(Runnable command, long delay, TimeUnit unit) ScheduledFuture~?~
        +schedule(Callable~V~ callable, long delay, TimeUnit unit) ScheduledFuture~V~
        +scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit) ScheduledFuture~?~
        +scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit) ScheduledFuture~?~
        +shutdown() void
        +setRemoveOnCancelPolicy(boolean removeOnCancel) void
        +decorateTask(Runnable runnable, RunnableScheduledFuture~?~ task) RunnableScheduledFuture~?~
        +decorateTask(Callable~V~ callable, RunnableScheduledFuture~V~ task) RunnableScheduledFuture~V~
    &#125;
    
    class ScheduledFutureTask &#123;
        &lt;&lt;concrete&gt;&gt;
        -time: long  // 纳秒级 deadline 时间戳
        -sequenceNumber: long  // 序列号，用于相同时间的任务排序
        -period: long  // 周期（正数为 fixed-rate，负数为 fixed-delay）
        -outerTask: RunnableScheduledFuture~V~  // 周期任务的外层引用
        
        +run() void  // 一次性任务执行
        +runAndReset() boolean  // 周期任务执行（不设置完成状态）
        +getDelay(TimeUnit unit) long  // Delayed 接口实现
        +compareTo(Delayed other) int  // Delayed 接口实现
        +isPeriodic() boolean  // 判断是否周期任务
        
        -setNextRunTime() void  // 计算下次执行时间
        -reExecutePeriodic(RunnableScheduledFuture~?~ task) void  // 重新入队周期任务
    &#125;
    
    class DelayedWorkQueue &#123;
        &lt;&lt;concrete&gt;&gt;
        -queue: RunnableScheduledFuture~?~[]  // 基于堆的数组实现
        -size: int  // 当前队列大小
        -leader: Thread  // Leader-Follower 模式的领导者线程
        -lock: ReentrantLock  // 队列锁
        -available: Condition  // 条件变量
        
        +offer(RunnableScheduledFuture~?~ e) boolean  // 入队
        +take() RunnableScheduledFuture~?~  // 出队（阻塞直到到期）
        +poll() RunnableScheduledFuture~?~  // 立即出队（非阻塞）
        +poll(long timeout, TimeUnit unit) RunnableScheduledFuture~?~  // 超时出队
        +peek() RunnableScheduledFuture~?~  // 查看队首元素
        +size() int  // 获取队列大小
        +clear() void  // 清空队列
    &#125;
    
    class ScheduledWorker &#123;
        &lt;&lt;concrete&gt;&gt;
        -thread: Thread
        -firstTask: Runnable
        -pool: ScheduledThreadPoolExecutor
        
        +run() void  // 执行任务循环
        +afterExecute(Runnable r, Throwable t) void  // 任务后处理
    &#125;
    
    %% 基础接口定义
    class Runnable &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    
    class Callable &#123;
        &lt;&lt;interface&gt;&gt;
        +call() V
    &#125;
    
    class Future &#123;
        &lt;&lt;interface&gt;&gt;
        +cancel(boolean mayInterruptIfRunning) boolean
        +isCancelled() boolean
        +isDone() boolean
        +get() V
        +get(long timeout, TimeUnit unit) V
    &#125;
    
    class RunnableFuture &#123;
        &lt;&lt;interface&gt;&gt;
    &#125;
    
    class WorkQueue &#123;
        &lt;&lt;concrete&gt;&gt;
        -array: ForkJoinTask~?~[]  // 任务数组，初始容量8192，最大6700万
        -base: int                 // 窃取端索引（FIFO）
        -top: int                  // 本地端索引（LIFO）
        -ctl: int                  // 控制状态
        -pool: ForkJoinPool        // 所属线程池
        -owner: ForkJoinWorkerThread  // 拥有者线程
        
        +push(ForkJoinTask~?~ task) int    // 本地入队（LIFO）
        +pop() ForkJoinTask~?~             // 本地出队（LIFO）
        +poll() ForkJoinTask~?~            // 窃取出队（FIFO）
        +tryUnpush(ForkJoinTask~?~ task) boolean  // 尝试移除任务
        +growArray() ForkJoinTask~?~[]     // 扩容数组
    &#125;
    
    class ScheduledFuture &#123;
        &lt;&lt;interface&gt;&gt;
        // 继承自 Future&lt;V&gt; 和 Delayed 接口的所有方法
        // 无额外方法，是标记接口
    &#125;
    
    class RunnableScheduledFuture &#123;
        &lt;&lt;interface&gt;&gt;
        +isPeriodic() boolean
    &#125;
    
    class Delayed &#123;
        &lt;&lt;interface&gt;&gt;
        +getDelay(TimeUnit unit) long
    &#125;
    
    class Comparable &#123;
        &lt;&lt;interface&gt;&gt;
        +compareTo(T o) int
    &#125;
    
    class ForkJoinTask &#123;
        &lt;&lt;abstract&gt;&gt;
        -status: int
        +fork() ForkJoinTask~T~  // 异步执行（入队到当前线程的队列）
        +join() T  // 阻塞等待结果
        +invoke() T  // fork + join 的快捷方式
        +tryUnfork() boolean
        +quietlyComplete()
    &#125;
    
    class RecursiveTask &#123;
        &lt;&lt;abstract&gt;&gt;
        +compute() V  // 用户实现逻辑，返回结果
    &#125;
    
    class RecursiveAction &#123;
        &lt;&lt;abstract&gt;&gt;
        +compute() void  // 用户实现逻辑，无返回值
    &#125;
    
    class FutureTask &#123;
        &lt;&lt;concrete&gt;&gt;
        -callable: Callable~V~    // 包装的任务
        -outcome: Object          // 执行结果或异常（通过state的volatile写保证可见性）
        -state: int               // 任务状态（NEW=0/RUNNING=1/COMPLETING=2/NORMAL=3/EXCEPTIONAL=4/CANCELLED=5/INTERRUPTING=6/INTERRUPTED=7）
        -runner: Thread           // 执行线程
        -waiters: WaitNode        // 等待节点链表
        
        +run() void              // 执行任务：捕获异常存入outcome
        +get() V                 // 阻塞获取结果：通过report()抛出存储的异常
        +get(long timeout, TimeUnit unit) V  // 超时获取结果
        +cancel(boolean mayInterruptIfRunning) boolean  // 取消任务
        +isCancelled() boolean   // 是否已取消
        +isDone() boolean        // 是否已完成
        -set(V v) boolean        // 设置正常结果
        -setException(Throwable t) void  // 设置异常结果
        -report(int s) V         // 根据state返回结果或抛出异常
    &#125;
    
    class Worker &#123;
        &lt;&lt;concrete&gt;&gt;
        -thread: Thread           // 工作线程
        -firstTask: Runnable      // 初始任务
        -completedTasks: long     // 完成任务数
        
        +run() void              // 执行任务循环
        +lock() void             // 获取锁（AQS实现）
        +unlock() void           // 释放锁（AQS实现）
        +isLocked() boolean      // 是否持有锁
        +tryLock() boolean       // 尝试获取锁
    &#125;
    
    %% 辅助接口与工具类
    class ThreadFactory &#123;
        &lt;&lt;interface&gt;&gt;
        +newThread(Runnable r) Thread  // 创建新线程
    &#125;
    
    class RejectedExecutionHandler &#123;
        &lt;&lt;interface&gt;&gt;
        +rejectedExecution(Runnable r, ThreadPoolExecutor executor) void  // 拒绝策略契约
    &#125;
    
    class AbortPolicy &#123;
        &lt;&lt;concrete&gt;&gt;
        +rejectedExecution(Runnable r, ThreadPoolExecutor executor) void  // 抛出异常
    &#125;
    
    class CallerRunsPolicy &#123;
        &lt;&lt;concrete&gt;&gt;
        +rejectedExecution(Runnable r, ThreadPoolExecutor executor) void  // 调用者执行
    &#125;
    
    class DiscardPolicy &#123;
        &lt;&lt;concrete&gt;&gt;
        +rejectedExecution(Runnable r, ThreadPoolExecutor executor) void  // 静默丢弃
    &#125;
    
    class DiscardOldestPolicy &#123;
        &lt;&lt;concrete&gt;&gt;
        +rejectedExecution(Runnable r, ThreadPoolExecutor executor) void  // 丢弃最老任务
    &#125;
    
    class TimeUnit &#123;
        &lt;&lt;enum&gt;&gt;
        NANOSECONDS   // 纳秒
        MICROSECONDS  // 微秒
        MILLISECONDS  // 毫秒
        SECONDS       // 秒
        MINUTES       // 分钟
        HOURS         // 小时
        DAYS          // 天
        
        +toNanos(long d) long
        +toMillis(long d) long
        +toSeconds(long d) long
        +convert(long d, TimeUnit u) long
        +sleep(long timeout) void  // 休眠指定时间单位
        +timedWait(Object obj, long timeout) void  // 限时等待
        +timedJoin(Thread thread, long timeout) void  // 限时join
    &#125;
    
    class Executors &#123;
        &lt;&lt;utility&gt;&gt;
        +newFixedThreadPool(int nThreads) ExecutorService
        +newCachedThreadPool() ExecutorService
        +newSingleThreadExecutor() ExecutorService
        +newScheduledThreadPool(int corePoolSize) ScheduledExecutorService
        +newWorkStealingPool() ExecutorService
        +defaultThreadFactory() ThreadFactory
        +callable(Runnable task, T result) Callable~T~
        +unconfigurableExecutorService(ExecutorService exec) ExecutorService
    &#125;
    
    %% ctl 位运算常量说明
    class ThreadPoolState &#123;
        &lt;&lt;enumeration&gt;&gt;
        RUNNING    = -1 &lt;&lt; COUNT_BITS  // 111...000 接受新任务，处理队列任务
        SHUTDOWN   =  0 &lt;&lt; COUNT_BITS  // 000...000 不接受新任务，但处理队列任务  
        STOP       =  1 &lt;&lt; COUNT_BITS  // 001...000 不接受新任务，不处理队列，中断进行中任务
        TIDYING    =  2 &lt;&lt; COUNT_BITS  // 010...000 所有任务终止，workerCount=0，过渡到terminated()
        TERMINATED =  3 &lt;&lt; COUNT_BITS  // 011...000 terminated()钩子已完成
        
        +COUNT_BITS = 29  // 用于workerCount的位数
        +CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1  // 最大线程数：536870911
    &#125;
    
    class ForkJoinWorkerThread &#123;
        &lt;&lt;concrete&gt;&gt;
        -pool: ForkJoinPool       // 所属线程池
        -workQueue: WorkQueue     // 专属工作队列
        
        +run() void              // 执行工作窃取循环
        +onStart() void          // 启动回调
        +onTermination(Throwable exception) void  // 终止回调
    &#125;
    
    %% 关系
    Executor &lt;|-- ExecutorService : &quot;adds lifecycle+results API&quot;
    ExecutorService &lt;|-- ScheduledExecutorService : &quot;adds scheduling capabilities&quot;
    ExecutorService &lt;|-- AbstractExecutorService : &quot;adds algorithm implementation&quot;
    ScheduledExecutorService &lt;|-- ScheduledThreadPoolExecutor : &quot;adds delayed queue implementation&quot;
    AbstractExecutorService &lt;|-- ThreadPoolExecutor : &quot;adds thread pool strategy&quot;
    AbstractExecutorService &lt;|-- ForkJoinPool : &quot;adds work-stealing strategy&quot;
    
    AbstractExecutorService ..&gt; FutureTask : &quot;creates via newTaskFor()&quot;
    
    ThreadPoolExecutor o-- Worker : &quot;manages pool of&quot;
    Worker ..&gt; Runnable : &quot;executes tasks&quot;
    ThreadPoolExecutor ..&gt; FutureTask : &quot;executes via workers&quot;
    
    ScheduledThreadPoolExecutor o-- ScheduledWorker : &quot;manages scheduled workers&quot;
    ScheduledThreadPoolExecutor --&gt; DelayedWorkQueue : &quot;uses delayed queue&quot;
    DelayedWorkQueue --&gt; ScheduledFutureTask : &quot;holds scheduled tasks&quot;
    ScheduledWorker ..&gt; ScheduledFutureTask : &quot;executes scheduled tasks&quot;
    
    ScheduledFutureTask ..|&gt; RunnableScheduledFuture : &quot;implements&quot;
    RunnableScheduledFuture --|&gt; ScheduledFuture : &quot;extends&quot;
    ScheduledFuture --|&gt; Future : &quot;extends&quot;
    RunnableScheduledFuture --|&gt; Runnable : &quot;extends&quot;
    ScheduledFutureTask ..&gt; Delayed : &quot;implements&quot;
    Delayed ..&gt; Comparable : &quot;extends&quot;
    
    ForkJoinPool o-- ForkJoinWorkerThread : &quot;manages pool of&quot;
    ForkJoinWorkerThread --&gt; WorkQueue : &quot;owns dedicated&quot;
    WorkQueue --&gt; ForkJoinTask : &quot;stores tasks&quot;
    ForkJoinPool ..&gt; ForkJoinTask : &quot;executes via work-stealing&quot;
    
    ForkJoinTask &lt;|-- RecursiveTask : &quot;returns result&quot;
    ForkJoinTask &lt;|-- RecursiveAction : &quot;no result&quot;
    
    FutureTask ..|&gt; RunnableFuture : &quot;implements&quot;
    RunnableFuture --|&gt; Runnable : &quot;extends&quot;
    RunnableFuture --|&gt; Future : &quot;extends&quot;
    
    ForkJoinTask ..|&gt; Future : &quot;implements (indirectly via ForkJoinTask&lt;V&gt; extends Future&lt;V&gt;)&quot;
    ForkJoinTask ..|&gt; Serializable : &quot;implements&quot;
    
    %% 新增关系：辅助接口与工具类
    ThreadPoolExecutor --&gt; ThreadFactory : &quot;uses to create workers&quot;
    ThreadPoolExecutor --&gt; RejectedExecutionHandler : &quot;uses when saturated&quot;
    RejectedExecutionHandler &lt;|.. AbortPolicy : &quot;implements&quot;
    RejectedExecutionHandler &lt;|.. CallerRunsPolicy : &quot;implements&quot;
    RejectedExecutionHandler &lt;|.. DiscardPolicy : &quot;implements&quot;
    RejectedExecutionHandler &lt;|.. DiscardOldestPolicy : &quot;implements&quot;
    
    %% TimeUnit 关系
    ScheduledExecutorService ..&gt; TimeUnit : &quot;uses for delays/periods&quot;
    ThreadPoolExecutor ..&gt; TimeUnit : &quot;uses for keepAliveTime&quot;
    FutureTask ..&gt; TimeUnit : &quot;uses for timeouts&quot;
    
    %% Executors 工厂类关系
    Executors ..&gt; ThreadPoolExecutor : &quot;creates&quot;
    Executors ..&gt; ScheduledThreadPoolExecutor : &quot;creates&quot;
    Executors ..&gt; ForkJoinPool : &quot;creates&quot;
    Executors ..&gt; ThreadFactory : &quot;provides default&quot;
    
    %% ctl 状态机关系
    ThreadPoolState ..&gt; ThreadPoolExecutor : &quot;defines states for ctl field&quot;
    
    %% FutureTask 异常处理说明
    FutureTask ..&gt; Throwable : &quot;catches and stores in outcome&quot;</code></pre>
<h3 id="executor-接口">Executor 接口</h3>
<p>将任务提交和任务执行进行解耦（<strong>decoupling the execution mechanic</strong>）。用户无需关注如何创建线程，如何调度线程（scheduling）来执行任务，用户只需提供 Runnable 对象，将任务的运行逻辑提交到执行器(Executor)中，由 Executor 框架完成线程的调配和任务的执行部分。</p>
<p>JUC 里所有的解耦设计都不一定是异步的，它只是<strong>解耦</strong>，所以执行器本身也是可以同步执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-comment">// 这个类型只有这一个核心方法</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable r)</span> &#123;<br>     r.run();<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>一般而言可以认为，executor 会 spawns a new thread for each task.</p>
<h3 id="executorservice-接口">ExecutorService 接口</h3>
<p>增加了一些能力：</p>
<p>扩充执行任务的能力，补充可以为一个或一批异步任务<strong>生成 Future 的方法</strong>（），<strong>从这里开始执行器开始可以执行异步任务</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 立即返回：Future.get 不一定可用</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task)<br><span class="hljs-comment">// 这个 api 是很神奇的，本质上 runnable 是没有返回值的，这相当于帮我们给一个 runnable 带上一个线程运行结束的结果</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span><br><span class="hljs-comment">// 阻塞返回，Future.get 已经可用了：这个接口有一个神奇的特性，只有所有异步流程都执行完，才会返回，否则会 hang 住</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="hljs-comment">// 这个接口的超时并不准</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br></code></pre></td></tr></table></figure>
<p>在上面的方法里，submit 能接收无结果的 Runnable、有结果的 Runnable、能返回结果的 Callable，再加上底层无返回结果的 execute，构成了4个基础的单任务api。</p>
<p>ExecutorService 还提供了管控线程池的方法，比如停止线程池的运行。</p>
<ul>
<li>shutdown 拒绝接收任务，触发 rejection policy。</li>
<li>shutdownNow 除了 shutdown 的功能以外，还会强制触发线程中断。</li>
</ul>
<p><strong>内存一致性保证（Memory Consistency Effects）</strong>：</p>
<p>根据 JLS §17.4.5 规范，Future.get() 的内存可见性保证如下：</p>
<ol>
<li>
<p><strong>happens-before 传递链</strong>：</p>
<ul>
<li>任务执行线程对共享变量的写操作 happens-before FutureTask.set(result)</li>
<li>FutureTask.set(result) happens-before state的volatile写（NORMAL/EXCEPTIONAL状态）</li>
<li>state的volatile写 happens-before Future.get()中对state的volatile读</li>
<li>传递性：任务执行的所有操作 happens-before Future.get()的返回</li>
</ul>
</li>
<li>
<p><strong>实际调用链中的happens-before关系</strong>：</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs autoit">executor.<span class="hljs-built_in">execute</span>(task) <br>  → Worker线程执行task.<span class="hljs-built_in">run</span>() <br>  → callable.<span class="hljs-built_in">call</span>()的所有写操作<br>  → FutureTask状态转换（<span class="hljs-keyword">volatile</span>写）<br>  → future.get()读取结果（<span class="hljs-keyword">volatile</span>读）<br>  → 调用线程可见所有之前的写操作<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>关键规范依据</strong>：</p>
<ul>
<li>程序顺序规则（JLS §17.4.3）：同一线程内，前面的操作happens-before后面的操作</li>
<li>volatile变量规则（JLS §17.4.4）：volatile写happens-before后续的volatile读</li>
<li>传递性规则（JLS §17.4.5）：A happens-before B，B happens-before C，则A happens-before C</li>
</ul>
</li>
</ol>
<p>理解 happens-before relation 一定不要按照硬件的工作方式来理解（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/67472344/java-volatile-and-final-volatile-as-flushing-all-memory-content">Flushing model is fundamentally flawed (it is just not how hardware works)</a>），最好从 JLS 的规范出发。</p>
<h3 id="abstractexecutorservice">AbstractExecutorService</h3>
<p>将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法<code>execute</code>即可。其他契约的接口全都在这一层实现了：</p>
<ul>
<li>大部分的任务接口在这一层有了实现，它们最终都调向了 execute() 接口。</li>
<li>生命周期接口留给下一层。</li>
</ul>
<p>这一层大部分的方法实现都是这样的：</p>
<ol>
<li>把任务包装成 FutureTask。</li>
<li>用 execute 执行这个 FutureTask。因为这个 FutureTask 包住了原始的 run 方法，所以它的 exception 处理机制会比 UncaughtExceptionHandler 更快一步拦截异常-基于 state 的 report 一个常用机制。而且这种 exception 处理机制是不可覆写的，不像 UncaughtExceptionHandler。</li>
<li>把 FutureTask 实例阻塞或者不阻塞地在同步流程里直接返回：<code>future.get()</code>阻塞等待结果，或直接返回future引用供异步处理。例如<code>submit(runnable)</code>返回<code>Future&lt;?&gt;</code>可直接使用，而<code>invokeAll()</code>则批量阻塞等待所有任务完成-得不到 task 则无法 cancel task。</li>
<li>外部调用者不断与这些 task 通讯决定任务是否进入完成状态。</li>
</ol>
<h4 id="newtaskfor：任务包装的核心工厂方法">newTaskFor：任务包装的核心工厂方法</h4>
<p><code>newTaskFor</code> 是 AbstractExecutorService 的核心工厂方法，它负责将用户提交的任务（Runnable 或 Callable）包装成 <code>RunnableFuture</code>，默认返回FutureTask实例，但子类可以override提供自定义实现。</p>
<p><strong>方法签名</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractExecutorService.java</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为给定的 Callable 任务返回一个 RunnableFuture</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> callable 有返回值的任务</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 包装后的 RunnableFuture</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为给定的 Runnable 任务返回一个 RunnableFuture。</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> runnable 无返回值的任务</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> value 任务完成后的返回值（可为 null）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> 包装后的 RunnableFuture</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span>;<br></code></pre></td></tr></table></figure>
<p>Runnable变成 Future，总要配一个 Value，这是一个好的设计模式。</p>
<p><strong>封装关系：把什么东西封装成什么东西？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. Callable&lt;T&gt; -&gt; FutureTask&lt;T&gt;</span><br>Callable&lt;String&gt; callable = () -&gt; <span class="hljs-string">&quot;Hello&quot;</span>;<br>RunnableFuture&lt;String&gt; future = newTaskFor(callable);<br><span class="hljs-comment">// 封装关系：Callable 被封装为 FutureTask</span><br><span class="hljs-comment">// - Callable.call() 提供计算逻辑</span><br><span class="hljs-comment">// - FutureTask 提供 Future 接口（get()、cancel() 等）</span><br><span class="hljs-comment">// - FutureTask 同时实现 Runnable，可以提交给 execute()</span><br><br><span class="hljs-comment">// 2. Runnable + T -&gt; FutureTask&lt;T&gt;</span><br><span class="hljs-type">Runnable</span> <span class="hljs-variable">runnable</span> <span class="hljs-operator">=</span> () -&gt; System.out.println(<span class="hljs-string">&quot;Task&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;Done&quot;</span>;<br>RunnableFuture&lt;String&gt; future = newTaskFor(runnable, result);<br><span class="hljs-comment">// 封装关系：Runnable + result 被封装为 FutureTask</span><br><span class="hljs-comment">// - Runnable.run() 提供执行逻辑</span><br><span class="hljs-comment">// - result 提供&quot;虚拟&quot;返回值</span><br><span class="hljs-comment">// - FutureTask 提供 Future 接口</span><br></code></pre></td></tr></table></figure>
<p><strong>默认实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractExecutorService 的默认实现</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable);<br>&#125;<br><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么需要 newTaskFor？</strong></p>
<ol>
<li>
<p><strong>解耦任务类型</strong>：</p>
<ul>
<li>用户提交的是 <code>Callable&lt;T&gt;</code> 或 <code>Runnable</code></li>
<li>Executor 接收的是 <code>Runnable</code></li>
<li>Future 接口提供 <code>get()</code> 获取结果</li>
<li><code>newTaskFor</code> 将这三者统一起来</li>
</ul>
</li>
<li>
<p><strong>支持自定义扩展</strong>：<br>
子类可以重写 <code>newTaskFor</code> 来添加自定义逻辑：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义实现示例：添加 RPC 上下文传递</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;<br>    <span class="hljs-comment">// 这一行写在这里更加闭包，但是匿名类就不带有 rpcContext 的成员了，不一定利于调试</span><br>    <span class="hljs-comment">// private final Object rpcContext = RpcContext.getCurrent();</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable) &#123;<br>        <span class="hljs-comment">// 这里是匿名类的构造器里面的 initializer 过程，此时执行的上下文/线程就是调用 newTaskFor 的线程</span><br>        <span class="hljs-comment">// 这一行写在</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> RpcContext.getCurrent();<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 而 run 的线程则在后面的另一个线程里，这里利用了闭包的闭合机制</span><br>            RpcContext.set(rpcContext);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                RpcContext.clear();<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li><strong>统一任务包装</strong>：<br>
所有高级方法都依赖 <code>newTaskFor</code>：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// submit() 的实现</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);  <span class="hljs-comment">// 使用 newTaskFor</span><br>    execute(ftask);                                <span class="hljs-comment">// 提交给 execute</span><br>    <span class="hljs-keyword">return</span> ftask;                                  <span class="hljs-comment">// 返回 Future</span><br>&#125;<br><br><span class="hljs-comment">// invokeAll() 的实现</span><br><span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tasks == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    List&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(tasks.size());<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">done</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks) &#123;<br>            RunnableFuture&lt;T&gt; f = newTaskFor(t);  <span class="hljs-comment">// 使用 newTaskFor</span><br>            futures.add(f);<br>            execute(f);<br>        &#125;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这两个方法的实现透露了得到 future 的诀窍，因为 execute 不带有返回值，所以要保持 newTaskFor 的返回值引用，然后任由 execute 去执行，可以说<strong>凡是需要 execute 的最底层，要得到最后的 future 都需要抓住 newTaskFor 的返回值</strong>。</p>
<p><strong>封装的核心价值</strong></p>
<table>
<thead>
<tr>
<th>输入</th>
<th>封装过程</th>
<th>输出</th>
<th>价值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Callable&lt;T&gt;</code></td>
<td><code>newTaskFor()</code></td>
<td><code>FutureTask&lt;T&gt;</code></td>
<td>获得异步结果获取能力</td>
</tr>
<tr>
<td><code>Runnable</code> + <code>T</code></td>
<td><code>newTaskFor()</code></td>
<td><code>FutureTask&lt;T&gt;</code></td>
<td>无返回值任务也能返回结果</td>
</tr>
<tr>
<td>计算逻辑</td>
<td>包装为 <code>Runnable</code> + <code>Future</code></td>
<td>可提交、可等待</td>
<td>统一的异步编程模型</td>
</tr>
</tbody>
</table>
<p><strong>设计模式：工厂方法模式</strong></p>
<pre><code class="hljs mermaid">classDiagram
    class AbstractExecutorService &#123;
        &lt;&lt;abstract&gt;&gt;
        #newTaskFor(Callable~T~) RunnableFuture~T~
        #newTaskFor(Runnable, T) RunnableFuture~T~
        +submit(Callable~T~) Future~T~
        +invokeAll(...) List~Future~T~~
    &#125;
    
    class ThreadPoolExecutor &#123;
        #newTaskFor(Callable~T~) RunnableFuture~T~
        #newTaskFor(Runnable, T) RunnableFuture~T~
    &#125;
    
    class CustomExecutor &#123;
        #newTaskFor(Callable~T~) RunnableFuture~T~ &#123;
            return new EnhancedFutureTask(task);
        &#125;
    &#125;
    
    class RunnableFuture &#123;
        &lt;&lt;interface&gt;&gt;
        &lt;&lt;extends&gt;&gt;
        Future~T~
        +run() void
    &#125;
    
    class FutureTask &#123;
        +run()
        +get() T
        +cancel()
    &#125;
    
    AbstractExecutorService &lt;|-- ThreadPoolExecutor
    AbstractExecutorService &lt;|-- CustomExecutor
    AbstractExecutorService ..&gt; RunnableFuture : creates via
    FutureTask ..|&gt; RunnableFuture : implements</code></pre>
<p><strong>核心洞察</strong></p>
<p><code>newTaskFor</code> 是连接&quot;同步任务&quot;和&quot;异步执行&quot;的桥梁：</p>
<ol>
<li>它将<strong>计算任务</strong>（Callable/Runnable）封装为<strong>可执行可等待的对象</strong>（FutureTask）</li>
<li>它是 AbstractExecutorService 所有高级方法的基础</li>
<li>它提供了扩展点，允许子类自定义任务包装逻辑</li>
<li>它体现了&quot;模板方法模式&quot;：定义算法骨架，子类实现具体步骤</li>
</ol>
<p>其中多种调用模式的层叠大概是这样的：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant User
    participant AbstractExecutorService
    participant ThreadPoolExecutor
    participant WorkerThread
    participant FutureTask
    
    User-&gt;&gt;AbstractExecutorService: invokeAll(tasks)
    loop for each task
        AbstractExecutorService-&gt;&gt;AbstractExecutorService: newTaskFor(task)
        AbstractExecutorService-&gt;&gt;FutureTask: new FutureTask(task)
        AbstractExecutorService-&gt;&gt;ThreadPoolExecutor: execute(futureTask)
        ThreadPoolExecutor-&gt;&gt;WorkerThread: 分配任务
        WorkerThread-&gt;&gt;FutureTask: futureTask.run()
        FutureTask-&gt;&gt;Task: callable.call()
        Task--&gt;&gt;FutureTask: 返回结果
        FutureTask-&gt;&gt;FutureTask: set(result)
    end
    
    AbstractExecutorService-&gt;&gt;AbstractExecutorService: for each future: future.get()
    loop for each future
        AbstractExecutorService-&gt;&gt;FutureTask: future.get()
        alt 任务已完成
            FutureTask--&gt;&gt;AbstractExecutorService: 立即返回结果
        else 任务未完成
            FutureTask--&gt;&gt;FutureTask: 挂起等待
            FutureTask-&gt;&gt;FutureTask: 任务完成后唤醒
            FutureTask--&gt;&gt;AbstractExecutorService: 返回结果
        end
    end
    
    AbstractExecutorService--&gt;&gt;User: 返回所有Future结果</code></pre>
<h4 id="threadpoolexecutor">ThreadPoolExecutor</h4>
<p>实现了 execute，围绕 execute 的批量和异步化给出了一个经典的线程池执行器实现。</p>
<p>将会一方面维护自身的生命周期，另一方面同时管理线程（Thread）和任务（Task，也就是 Runnable），使两者良好的结合从而执行并行任务。</p>
<p><img src="ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="ThreadPoolExecutor运行流程.png"></p>
<h4 id="forkjoinpool">ForkJoinPool</h4>
<p>这个线程池本身就是一个复杂框架，为 JDK 其他组件提供 yet another executor alternative。</p>
<p>这个框架有个特点：</p>
<ol>
<li>产生的线程默认是守护线程。</li>
<li>产生的线程会自动收缩-不存在空转的 core thread 问题。</li>
<li>公共线程池的名字一般叫“ForkJoinPool.commonPool-worker-1”。</li>
</ol>
<p>这里就要讨论到一个很多人忽略的问题：我们如何决定何时使用守护类线程。这类线程可以用来执行一些：</p>
<ol>
<li>临时执行的任务，这些任务之间如果存在父子关系更好。</li>
<li>后台监控类任务。</li>
<li>可以被中断的计算任务。</li>
</ol>
<blockquote>
<p><strong>规范说明</strong>：根据Java Language Specification §12.8，守护线程的关键特性是&quot;不阻止JVM退出&quot;。因此判断是否使用守护线程的标准应该是：</p>
<ul>
<li>任务是否可以在JVM退出时被安全中断</li>
<li>任务是否需要确保完成（如数据持久化、事务提交）</li>
<li>任务失败是否可以接受或能够重试恢复</li>
</ul>
<pre><code class="hljs mermaid">graph TD
    A[任务分析] --&gt; B&#123;任务可否中断?&#125;
    B --&gt;|可以中断| C&#123;需要确保完成?&#125;
    B --&gt;|不可中断| D[使用非守护线程]
    C --&gt;|不需要确保| E[使用守护线程]
    C --&gt;|需要确保| F[使用非守护线程]
    E --&gt; G[适合场景: 监控/日志/缓存清理]
    F --&gt; H[适合场景: 文件写入/数据库操作/网络传输]
    D --&gt; H</code></pre>
</blockquote>
<ol start="3">
<li>典型的工作线程池包括两类：
<ul>
<li><strong>IO线程池</strong>：平台线程池的一种，专门处理IO密集型任务（如文件读写、网络请求），通常使用固定大小的线程池</li>
<li><strong>计算线程池</strong>：平台线程池的一种，专门处理CPU密集型任务（如数值计算、数据处理），可使用ForkJoinPool等工作窃取线程池</li>
</ul>
</li>
</ol>
<p>初始化这类线程池有一些简单的工厂方法，比原始构造器更加可用：<code>Executors.newWorkStealingPool(int parallelism)</code>。</p>
<p><strong>ForkJoinPool 的 asyncMode 参数</strong>：</p>
<p>ForkJoinPool 构造器中的 <code>asyncMode</code> 参数决定了工作队列的调度模式，对性能和适用场景有重要影响：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism,</span><br><span class="hljs-params">                    ForkJoinWorkerThreadFactory factory,</span><br><span class="hljs-params">                    UncaughtExceptionHandler handler,</span><br><span class="hljs-params">                    <span class="hljs-type">boolean</span> asyncMode)</span>  <span class="hljs-comment">// 关键参数</span><br></code></pre></td></tr></table></figure>
<p><strong>两种模式对比</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>asyncMode=false（默认，LIFO）</th>
<th>asyncMode=true（FIFO）</th>
</tr>
</thead>
<tbody>
<tr>
<td>调度顺序</td>
<td>后进先出（栈）</td>
<td>先进先出（队列）</td>
</tr>
<tr>
<td>适用场景</td>
<td>递归分治任务（如归并排序、ForkJoinTask）</td>
<td>通用异步任务（如并行流、CompletableFuture）</td>
</tr>
<tr>
<td>典型应用</td>
<td>显式 <code>new ForkJoinPool()</code> + <code>RecursiveTask</code></td>
<td><code>Stream.parallel()</code>、<code>CompletableFuture.runAsync()</code>、<code>ForkJoinPool.commonPool()</code></td>
</tr>
<tr>
<td>局部性</td>
<td>更好（深度优先，缓存友好）</td>
<td>较差（广度优先）</td>
</tr>
<tr>
<td>公平性</td>
<td>较差（新任务优先）</td>
<td>更好（按提交顺序）</td>
</tr>
</tbody>
</table>
<p><strong>使用示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 默认模式（适合分治任务）</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">defaultPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br><span class="hljs-comment">// 等价于 new ForkJoinPool(parallelism, factory, handler, false)</span><br><br><span class="hljs-comment">// FIFO 模式（适合事件驱动任务）</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">asyncPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<br>    Runtime.getRuntime().availableProcessors(),<br>    ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>    <span class="hljs-literal">null</span>,<br>    <span class="hljs-literal">true</span>  <span class="hljs-comment">// asyncMode=true，启用FIFO调度</span><br>);<br><br><span class="hljs-comment">// 使用场景对比</span><br><span class="hljs-comment">// LIFO 模式：递归分治</span><br>defaultPool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 子任务会被后进先出地执行，保持递归的局部性</span><br>        <span class="hljs-keyword">return</span> leftTask.fork().join() + rightTask.fork().join();<br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">// FIFO 模式：异步事件处理</span><br>asyncPool.execute(() -&gt; &#123;<br>    <span class="hljs-comment">// 按提交顺序执行，适合事件驱动场景</span><br>    processEvent();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>JDK 默认值的场景化设计</strong></p>
<p>JDK 中不同 API 对 asyncMode 的默认值存在差异，这是场景化设计的体现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Executors.newWorkStealingPool() —— 通用任务场景</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newWorkStealingPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(parallelism, factory, <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// FIFO</span><br>&#125;<br><br><span class="hljs-comment">// ForkJoinPool() —— 分治算法场景  </span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>(parallelism, factory, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <span class="hljs-comment">// LIFO</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计 rationale</strong>：</p>
<table>
<thead>
<tr>
<th>API</th>
<th>目标场景</th>
<th>默认值</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>new ForkJoinPool()</code></td>
<td>显式分治算法</td>
<td>LIFO</td>
<td>深度优先遍历，缓存局部性最优</td>
</tr>
<tr>
<td><code>newWorkStealingPool()</code></td>
<td>通用异步任务</td>
<td>FIFO</td>
<td>提交顺序即执行顺序，行为可预测</td>
</tr>
<tr>
<td><code>ForkJoinPool.commonPool()</code></td>
<td>JDK 内部共享池</td>
<td>FIFO</td>
<td>多组件共享，需公平性避免饥饿</td>
</tr>
</tbody>
</table>
<p><strong>对 CompletableFuture 的影响</strong></p>
<p><code>CompletableFuture.runAsync()</code> 使用 <code>commonPool()</code>（FIFO），但若显式传入 LIFO 模式的线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">lifoPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();  <span class="hljs-comment">// LIFO</span><br><br>CompletableFuture.runAsync(() -&gt; &#123;<span class="hljs-comment">/* Task 1 */</span>&#125;, lifoPool);<br>CompletableFuture.runAsync(() -&gt; &#123;<span class="hljs-comment">/* Task 2 */</span>&#125;, lifoPool);<br><span class="hljs-comment">// Task 2 可能先于 Task 1 执行（栈顶优先）</span><br></code></pre></td></tr></table></figure>
<p>需注意：<code>CompletableFuture</code> 的 happens-before 关系由回调链保证，与底层线程池调度策略无关。asyncMode 仅影响独立任务的入队/出队顺序，不影响 CompletableFuture 的语义正确性。</p>
<p>更多内容见<a href="#forkjoinpool%E8%AF%A6%E8%A7%A3-%E5%88%86%E6%B2%BB%E5%B9%B6%E8%A1%8C%E7%9A%84%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E">ForkJoinPool详解：分治并行的执行引擎</a>。</p>
<h3 id="scheduledexecutorservice-接口">ScheduledExecutorService 接口</h3>
<p>ScheduledExecutorService扩展了ExecutorService接口，专门用于支持延迟执行和周期性执行的任务调度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ScheduledExecutorService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ExecutorService</span> &#123;<br>    <span class="hljs-comment">// ========== 一次性延迟执行 ==========</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 延迟执行 Runnable 任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> command 要执行的任务（无返回值）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delay 延迟时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> unit 时间单位</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ScheduledFuture 用于任务取消和状态查询</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit);<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 延迟执行 Callable 任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> callable 要执行的任务（有返回值）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delay 延迟时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> unit 时间单位</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ScheduledFuture 用于任务取消、状态查询和获取结果</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> &lt;V&gt; ScheduledFuture&lt;V&gt; <span class="hljs-title function_">schedule</span><span class="hljs-params">(Callable&lt;V&gt; callable, <span class="hljs-type">long</span> delay, TimeUnit unit)</span>;<br>    <br>    <span class="hljs-comment">// ========== 周期性执行 ==========</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 固定频率执行（从上次任务开始计时）</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 执行时间轴：|----- delay -----|--- period ---|--- period ---|--- period ---|</span><br><span class="hljs-comment">     * 任务执行：                         [task1]       [task2]       [task3]</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 特点：</span><br><span class="hljs-comment">     * - 按照固定的时间间隔执行，不考虑任务实际执行时间</span><br><span class="hljs-comment">     * - 如果任务执行时间超过 period，下一次执行会在当前任务完成后立即开始（不会并发）</span><br><span class="hljs-comment">     * - 适用于需要严格按固定频率执行的场景（如心跳检测、定时采样）</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 示例：period=1s，无论任务执行多久，都严格每秒触发一次</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> command 要执行的任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> initialDelay 首次执行的延迟时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> period 执行周期（从任务开始时间计算）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> unit 时间单位</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ScheduledFuture 用于任务取消</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> period, TimeUnit unit);<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 固定延迟执行（从上次任务完成计时）</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 执行时间轴：|----- delay -----|--- task ---|--- delay ---|--- task ---|--- delay ---|</span><br><span class="hljs-comment">     * 任务执行：                         [task1]       [task2]       [task3]</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 特点：</span><br><span class="hljs-comment">     * - 每次执行完成后，等待固定延迟再执行下一次</span><br><span class="hljs-comment">     * - 保证任务不会并发执行</span><br><span class="hljs-comment">     * - 如果任务执行时间长，整体执行频率会降低</span><br><span class="hljs-comment">     * - 适用于需要任务间隔的场景（如任务队列处理、限流场景）</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 示例：delay=1s，任务执行0.5s，则每1.5秒执行一次；任务执行2s，则每3秒执行一次</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> command 要执行的任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> initialDelay 首次执行的延迟时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delay 执行延迟（从任务完成时间计算）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> unit 时间单位</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ScheduledFuture 用于任务取消</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, <span class="hljs-type">long</span> initialDelay, <span class="hljs-type">long</span> delay, TimeUnit unit);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>核心特性</strong>：</p>
<ul>
<li>支持一次性延迟执行</li>
<li>支持固定频率周期执行（scheduleAtFixedRate）</li>
<li>支持固定延迟周期执行（scheduleWithFixedDelay）</li>
<li>返回ScheduledFuture用于任务控制和结果获取</li>
</ul>
<p><strong>实现类</strong>：<br>
ScheduledThreadPoolExecutor是主要实现，内部使用DelayedWorkQueue作为工作队列，该队列基于堆结构实现优先级调度。</p>
<h3 id="scheduledexecutorservice-内部实现详解">ScheduledExecutorService 内部实现详解</h3>
<p>ScheduledThreadPoolExecutor的实现包含了几个关键组件，形成了完整的定时任务调度体系：</p>
<h4 id="1-核心组件架构">1. 核心组件架构</h4>
<p><strong>ScheduledFutureTask</strong>：定时任务的核心实现类</p>
<ul>
<li>继承自FutureTask，实现RunnableScheduledFuture接口</li>
<li>包含time字段记录任务的纳秒级deadline</li>
<li>通过period字段区分一次性任务(0)、固定频率任务(正值)和固定延迟任务(负值)</li>
<li>实现Delayed接口，支持基于时间的优先级排序</li>
</ul>
<p><strong>DelayedWorkQueue</strong>：基于堆的延迟队列实现</p>
<ul>
<li>使用二叉堆数据结构维护任务的执行顺序</li>
<li>队列元素按deadline时间排序，最近到期的任务位于堆顶</li>
<li>实现Leader-Follower模式避免惊群效应</li>
<li>支持高效的插入、删除和查找操作</li>
</ul>
<p><strong>ScheduledWorker</strong>：专门的工作线程实现</p>
<ul>
<li>继承ThreadPoolExecutor.Worker的职责</li>
<li>专门处理定时任务的执行</li>
<li>实现任务执行后的回调处理</li>
</ul>
<h4 id="2-delayedworkqueue-的-leader-follower-模式">2. DelayedWorkQueue 的 Leader-Follower 模式</h4>
<p>DelayedWorkQueue采用了经典的Leader-Follower并发模式来优化线程等待：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简化的Leader-Follower机制示意</span><br><span class="hljs-keyword">public</span> RunnableScheduledFuture&lt;?&gt; take() <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            RunnableScheduledFuture&lt;?&gt; first = queue[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>) &#123;<br>                available.await(); <span class="hljs-comment">// 队列为空时等待</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> first.getDelay(NANOSECONDS);<br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">return</span> finishPoll(first); <span class="hljs-comment">// 任务到期，立即返回</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (leader != <span class="hljs-literal">null</span>) &#123;<br>                    available.await(); <span class="hljs-comment">// 已有leader，作为follower等待</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">thisThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>                    leader = thisThread; <span class="hljs-comment">// 成为leader</span><br>                    <span class="hljs-keyword">try</span> &#123;<br>                        available.awaitNanos(delay); <span class="hljs-comment">// leader做定时等待</span><br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-keyword">if</span> (leader == thisThread) &#123;<br>                            leader = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 释放leader角色</span><br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (leader == <span class="hljs-literal">null</span> &amp;&amp; queue[<span class="hljs-number">0</span>] != <span class="hljs-literal">null</span>) &#123;<br>            available.signal(); <span class="hljs-comment">// 唤醒下一个follower</span><br>        &#125;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计优势</strong>：</p>
<ul>
<li>避免多个线程同时做定时等待造成的资源浪费</li>
<li>任意时刻最多只有一个线程在精确计时</li>
<li>新任务插入时能及时唤醒合适的线程</li>
<li>有效防止惊群效应(thundering herd)</li>
</ul>
<h4 id="3-scheduledfuturetask-的时间管理机制">3. ScheduledFutureTask 的时间管理机制</h4>
<p>ScheduledFutureTask通过精巧的时间字段设计实现了不同类型任务的统一处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;V&gt; &#123;<br>    <span class="hljs-comment">// 纳秒级的时间戳，表示任务的deadline</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> time;<br>    <br>    <span class="hljs-comment">// 周期任务的周期值</span><br>    <span class="hljs-comment">// 正数：fixed-rate模式，表示理论时间间隔</span><br>    <span class="hljs-comment">// 负数：fixed-delay模式，表示实际延迟时间  </span><br>    <span class="hljs-comment">// 零：一次性任务</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> period;<br>    <br>    <span class="hljs-comment">// 序列号，用于相同时间任务的排序</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> sequenceNumber;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>        <span class="hljs-keyword">return</span> unit.convert(time - now(), NANOSECONDS);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br>        <span class="hljs-keyword">if</span> (other == <span class="hljs-built_in">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> ScheduledFutureTask) &#123;<br>            ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> time - x.time;<br>            <span class="hljs-keyword">if</span> (diff &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (diff &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (sequenceNumber &lt; x.sequenceNumber) <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> getDelay(NANOSECONDS) - other.getDelay(NANOSECONDS);<br>        <span class="hljs-keyword">return</span> (diff &lt; <span class="hljs-number">0</span>) ? -<span class="hljs-number">1</span> : (diff &gt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 周期任务的核心执行逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">periodic</span> <span class="hljs-operator">=</span> isPeriodic();<br>        <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic)) &#123;<br>            cancel(<span class="hljs-literal">false</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic) &#123;<br>            <span class="hljs-comment">// 一次性任务：正常执行</span><br>            <span class="hljs-built_in">super</span>.run();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">super</span>.runAndReset()) &#123;<br>            <span class="hljs-comment">// 周期任务：执行后重置状态，计算下次执行时间</span><br>            setNextRunTime();<br>            reExecutePeriodic(outerTask);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键设计点</strong>：</p>
<ul>
<li><strong>统一时间表示</strong>：所有任务都用纳秒级时间戳表示deadline</li>
<li><strong>周期任务复用</strong>：通过runAndReset()避免创建新对象，提高内存效率</li>
<li><strong>追赶机制</strong>：fixed-rate模式下，如果执行时间超过period，会在任务完成后立即执行下一次（不会并发），以追赶理论时间轴</li>
<li><strong>序列号排序</strong>：相同deadline的任务通过sequenceNumber保证FIFO顺序</li>
</ul>
<h4 id="4-任务调度的完整流程">4. 任务调度的完整流程</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client as 客户端代码
    participant Service as ScheduledThreadPoolExecutor
    participant Queue as DelayedWorkQueue
    participant Task as ScheduledFutureTask
    participant Worker as ScheduledWorker
    
    Client-&gt;&gt;Service: scheduleAtFixedRate(task, 0, 1, SECONDS)
    Service-&gt;&gt;Task: 创建ScheduledFutureTask实例
    Service-&gt;&gt;Queue: offer(task)入队
    Queue-&gt;&gt;Queue: 堆调整，维护时间顺序
    
    loop 任务执行循环
        Worker-&gt;&gt;Queue: take()获取到期任务
        Queue-&gt;&gt;Task: 返回到期的ScheduledFutureTask
        Task-&gt;&gt;Worker: 执行run()方法
        Worker-&gt;&gt;Worker: 执行实际任务逻辑
        
        alt 周期任务
            Worker-&gt;&gt;Task: runAndReset()执行并重置
            Task-&gt;&gt;Task: setNextRunTime()计算下次时间
            Task-&gt;&gt;Queue: reExecutePeriodic()重新入队
            Queue-&gt;&gt;Queue: 堆调整
        else 一次性任务
            Worker-&gt;&gt;Task: run()正常执行完成
            Task-&gt;&gt;Task: 设置完成状态
        end
    end</code></pre>
<h4 id="5-内存管理和性能优化">5. 内存管理和性能优化</h4>
<p><strong>对象复用机制</strong>：</p>
<ul>
<li>周期任务复用同一个ScheduledFutureTask对象</li>
<li>避免频繁的对象创建和垃圾回收开销</li>
<li>通过runAndReset()方法重置任务状态而非创建新实例</li>
</ul>
<p><strong>时间精度处理</strong>：</p>
<ul>
<li>内部使用System.nanoTime()而非System.currentTimeMillis()</li>
<li>避免系统时钟调整对调度精度的影响</li>
<li>纳秒级精度确保高频调度的准确性</li>
</ul>
<p><strong>队列优化</strong>：</p>
<ul>
<li>基于堆的优先队列实现O(log n)的插入和删除</li>
<li>Leader-Follower模式减少不必要的线程唤醒</li>
<li>支持快速的队首元素访问和批量操作</li>
</ul>
<p>这套实现既保证了定时任务调度的精确性，又通过巧妙的设计优化了内存使用和并发性能，体现了Doug Lea在并发编程方面的深厚功底。</p>
<h3 id="scheduledexecutorservice-与-abstractexecutorservice-的关系辨析">ScheduledExecutorService 与 AbstractExecutorService 的关系辨析</h3>
<h4 id="关键问题：api-之间是否也是-abstractexecutorservice-的调用关系？">关键问题：API 之间是否也是 AbstractExecutorService 的调用关系？</h4>
<p><strong>答案：submit/invokeAll/invokeAny 仍遵循 AbstractExecutorService，但 schedule 系列方法是独立实现。</strong></p>
<h5 id="api-分类">API 分类</h5>
<p>ScheduledExecutorService 的 API 可以分为两类：</p>
<table>
<thead>
<tr>
<th>API 类别</th>
<th>方法</th>
<th>是否遵循 AbstractExecutorService</th>
<th>实现路径</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>标准 API</strong></td>
<td><code>submit(Runnable)</code></td>
<td>是</td>
<td><code>submit()</code> → <code>newTaskFor()</code> → <code>execute()</code> → <code>DelayedWorkQueue</code></td>
</tr>
<tr>
<td><strong>标准 API</strong></td>
<td><code>submit(Callable)</code></td>
<td>是</td>
<td><code>submit()</code> → <code>newTaskFor()</code> → <code>execute()</code> → <code>DelayedWorkQueue</code></td>
</tr>
<tr>
<td><strong>标准 API</strong></td>
<td><code>invokeAll()</code></td>
<td>是</td>
<td><code>invokeAll()</code> → <code>newTaskFor()</code> × N → <code>execute()</code> × N</td>
</tr>
<tr>
<td><strong>标准 API</strong></td>
<td><code>invokeAny()</code></td>
<td>是</td>
<td><code>invokeAny()</code> → <code>newTaskFor()</code> × N → <code>execute()</code> × N</td>
</tr>
<tr>
<td><strong>定时 API</strong></td>
<td><code>schedule(Runnable)</code></td>
<td>否</td>
<td><code>schedule()</code> → <code>new ScheduledFutureTask()</code> → <code>DelayedWorkQueue</code></td>
</tr>
<tr>
<td><strong>定时 API</strong></td>
<td><code>schedule(Callable)</code></td>
<td>否</td>
<td><code>schedule()</code> → <code>new ScheduledFutureTask()</code> → <code>DelayedWorkQueue</code></td>
</tr>
<tr>
<td><strong>定时 API</strong></td>
<td><code>scheduleAtFixedRate()</code></td>
<td>否</td>
<td><code>scheduleAtFixedRate()</code> → <code>new ScheduledFutureTask()</code> → <code>DelayedWorkQueue</code></td>
</tr>
<tr>
<td><strong>定时 API</strong></td>
<td><code>scheduleWithFixedDelay()</code></td>
<td>否</td>
<td><code>scheduleWithFixedDelay()</code> → <code>new ScheduledFutureTask()</code> → <code>DelayedWorkQueue</code></td>
</tr>
</tbody>
</table>
<h5 id="实现对比">实现对比</h5>
<p><strong>标准 API（遵循 AbstractExecutorService）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractExecutorService 的默认实现</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);  <span class="hljs-comment">// 创建 FutureTask</span><br>    execute(ftask);  <span class="hljs-comment">// 调用 execute()</span><br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">// ScheduledThreadPoolExecutor.execute() 的实现</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    schedule(command, <span class="hljs-number">0</span>, NANOSECONDS);  <span class="hljs-comment">// 转换为 schedule(0)</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>定时 API（独立实现）</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ScheduledThreadPoolExecutor 的独立实现</span><br><span class="hljs-keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span> || unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableScheduledFuture&lt;Void&gt; t = decorateTask(command,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;Void&gt;(command, <span class="hljs-literal">null</span>,<br>                                      triggerTime(delay, unit)));  <span class="hljs-comment">// 创建 ScheduledFutureTask</span><br>    delayedExecute(t);  <span class="hljs-comment">// 直接提交到 DelayedWorkQueue</span><br>    <span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayedExecute</span><span class="hljs-params">(RunnableScheduledFuture&lt;?&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (isShutdown())<br>        reject(task);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.getQueue().add(task);  <span class="hljs-comment">// 添加到 DelayedWorkQueue</span><br>        <span class="hljs-keyword">if</span> (isShutdown() &amp;&amp;<br>            !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp;<br>            remove(task))<br>            task.cancel(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">else</span><br>            ensurePrestart();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="对比图示">对比图示</h5>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;标准 API（遵循 AbstractExecutorService）&quot;
        A1[submit Runnable] --&gt; B1[newTaskFor]
        B1 --&gt; C1[FutureTask]
        C1 --&gt; D1[execute]
        D1 --&gt; E1[schedule0]
        E1 --&gt; F1[DelayedWorkQueue]
        
        A2[submit Callable] --&gt; B2[newTaskFor]
        B2 --&gt; C2[FutureTask]
        C2 --&gt; D1
        
        A3[invokeAll] --&gt; B3[newTaskFor xN]
        B3 --&gt; C3[FutureTask xN]
        C3 --&gt; D3[execute xN]
        D3 --&gt; E3[schedule0 xN]
        E3 --&gt; F3[DelayedWorkQueue]
    end
    
    subgraph &quot;定时 API（独立实现）&quot;
        A4[schedule Runnable] --&gt; B4[new ScheduledFutureTask]
        B4 --&gt; C4[delayedExecute]
        C4 --&gt; D4[DelayedWorkQueue]
        
        A5[schedule Callable] --&gt; B5[new ScheduledFutureTask]
        B5 --&gt; C5[delayedExecute]
        C5 --&gt; D4
        
        A6[scheduleAtFixedRate] --&gt; B6[new ScheduledFutureTask periodic]
        B6 --&gt; C6[delayedExecute]
        C6 --&gt; D4
        
        A7[scheduleWithFixedDelay] --&gt; B7[new ScheduledFutureTask periodic]
        B7 --&gt; C7[delayedExecute]
        C7 --&gt; D4
    end
    
    style B4 fill:#FFD700
    style B5 fill:#FFD700
    style B6 fill:#FFD700
    style B7 fill:#FFD700
    style C4 fill:#FFD700
    style C5 fill:#FFD700
    style C6 fill:#FFD700
    style C7 fill:#FFD700</code></pre>
<h5 id="关键结论">关键结论</h5>
<ol>
<li>
<p><strong>标准 API</strong>：<code>submit()</code>、<code>invokeAll()</code>、<code>invokeAny()</code> 仍然遵循 AbstractExecutorService 的契约</p>
<ul>
<li>通过 <code>newTaskFor()</code> 创建 FutureTask</li>
<li>调用 <code>execute()</code>，最终转换为 <code>schedule(0)</code></li>
</ul>
</li>
<li>
<p><strong>定时 API</strong>：<code>schedule()</code> 系列方法是独立实现</p>
<ul>
<li>直接创建 ScheduledFutureTask（而非 FutureTask）</li>
<li>调用 <code>delayedExecute()</code>，直接提交到 DelayedWorkQueue</li>
<li>不经过 <code>execute()</code> 路径</li>
</ul>
</li>
<li>
<p><strong>任务类型差异</strong>：</p>
<ul>
<li>FutureTask：普通任务，执行一次即完成</li>
<li>ScheduledFutureTask：定时任务，支持延迟执行和周期执行，继承自 FutureTask</li>
</ul>
</li>
<li>
<p><strong>队列差异</strong>：</p>
<ul>
<li>标准 API：通过 <code>schedule(0)</code> 间接使用 DelayedWorkQueue</li>
<li>定时 API：直接使用 DelayedWorkQueue，支持基于时间的优先级排序</li>
</ul>
</li>
</ol>
<p>这个设计体现了 ScheduledExecutorService 的<strong>双重性质</strong>：既要兼容 ExecutorService 标准接口，又要为定时任务提供专门的实现。</p>
<h3 id="scheduledexecutorservice-核心机制详解">ScheduledExecutorService 核心机制详解</h3>
<h4 id="1-future-get-的语义差异：一次性任务-vs-周期任务">1. Future.get() 的语义差异：一次性任务 vs 周期任务</h4>
<p>根据 <code>ScheduledFuture</code> 的规范，<code>Future.get()</code> 方法在一次性任务和周期任务中的行为截然不同：</p>
<p><strong>一次性任务</strong>：</p>
<ul>
<li><code>get()</code> 会阻塞直到任务执行完成</li>
<li>可以正常获取任务执行结果或捕获异常</li>
<li>任务完成后立即返回，这是预期行为</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFuture&lt;String&gt; future = executor.schedule(() -&gt; &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;task completed&quot;</span>;<br>&#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(); <span class="hljs-comment">// 阻塞直到任务完成，正常返回 &quot;task completed&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>周期任务</strong>：</p>
<ul>
<li><code>get()</code> 基本不会&quot;正常返回&quot;，因为周期任务的设计语义是&quot;无限期执行&quot;</li>
<li>只在以下两种情况返回：
<ol>
<li>任务被取消（<code>cancel()</code> 被调用）</li>
<li>任务执行过程中抛出未捕获的异常</li>
</ol>
</li>
<li>调用 <code>get()</code> 会导致调用线程永久阻塞（直到上述情况发生）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ScheduledFuture&lt;?&gt; future = executor.scheduleAtFixedRate(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;tick&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// future.get(); // 永久阻塞！不要这样做</span><br></code></pre></td></tr></table></figure>
<p><strong>为什么这样设计？</strong><br>
这是有意为之的设计，强制用户通过 <code>cancel()</code> 来主动终止周期任务。周期任务没有自然的&quot;完成&quot;状态，因此 <code>get()</code> 无法判断何时应该返回。</p>
<h4 id="2-串行化铁律：单一任务串行-不同任务并行">2. 串行化铁律：单一任务串行，不同任务并行</h4>
<p>根据 <code>ScheduledThreadPoolExecutor</code> 的源码实现，存在一个重要的&quot;串行化铁律&quot;：</p>
<p><strong>单一周期任务的串行化</strong>：</p>
<ul>
<li>同一个 <code>ScheduledFutureTask</code> 对象在 <code>run()</code> 方法完成后才会计算下次触发时间并重新入队</li>
<li>因此同一个周期任务实例不可能并发执行</li>
<li>这个铁律适用于 <code>scheduleAtFixedRate</code> 和 <code>scheduleWithFixedDelay</code> 两种模式</li>
</ul>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Q as DelayedWorkQueue
    participant T as ScheduledFutureTask
    participant P as WorkerThread
    
    Note over Q,T: 周期任务的串行化执行
    Q-&gt;&gt;T: 取出任务（到期）
    T-&gt;&gt;P: 执行 run()
    P-&gt;&gt;P: 执行任务逻辑
    P-&gt;&gt;T: run() 完成
    T-&gt;&gt;T: setNextRunTime()
    T-&gt;&gt;Q: 重新入队（同一对象）
    
    Note over Q,T: 下一次执行
    Q-&gt;&gt;T: 再次取出（到期）
    T-&gt;&gt;P: 执行 run()</code></pre>
<p><strong>不同任务的并行化</strong>：</p>
<ul>
<li>多个独立的任务（即使执行相同的 Runnable）可以并行执行</li>
<li>只要线程池有足够线程，不同任务可以同时运行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 任务1和任务2是不同的 ScheduledFutureTask 实例，可以并行执行</span><br>ScheduledFuture&lt;?&gt; future1 = executor.scheduleAtFixedRate(taskA, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>ScheduledFuture&lt;?&gt; future2 = executor.scheduleAtFixedRate(taskA, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// 但 future1 内部的执行是串行的，不会并发</span><br></code></pre></td></tr></table></figure>
<p><strong>设计原因</strong>：<br>
周期任务复用同一个 <code>ScheduledFutureTask</code> 对象，在执行期间不会创建新的任务对象入队，这天然保证了单一任务的串行化。</p>
<h4 id="3-漂移-drift-：线程池过小导致的执行延迟">3. 漂移（Drift）：线程池过小导致的执行延迟</h4>
<p><strong>漂移的定义</strong>：<br>
漂移是指任务的实际执行时间偏离了理论调度时间。当线程池过小或任务执行时间过长时：</p>
<ul>
<li>到期的任务从 <code>DelayedWorkQueue</code> 中取出后，可能因为线程池繁忙而需要等待</li>
<li>即使任务已经&quot;到期&quot;，也无法立即执行，只能等待可用线程</li>
<li>这导致执行时间晚于理论时间，产生&quot;漂移&quot;效应</li>
</ul>
<pre><code class="hljs mermaid">gantt
    title 漂移效应示意图（period=1s，执行时间=1.5s）
    dateFormat X
    axisFormat %s
    
    section 理论时间轴
    执行1 : 0, 1
    执行2 : 1, 2
    执行3 : 2, 3
    
    section 实际执行（线程池过小）
    等待队列 : 0, 0.5
    执行1 : 0.5, 2
    等待队列 : 2, 2.5
    执行2 : 2.5, 4
    等待队列 : 4, 4.5
    执行3 : 4.5, 6</code></pre>
<p><strong>漂移的影响</strong>：</p>
<ul>
<li><strong>scheduleAtFixedRate</strong>：漂移会触发追赶机制，在短时间内执行更密集</li>
<li><strong>scheduleWithFixedDelay</strong>：漂移会延迟整个时间轴，不会追赶，表现为节奏变慢</li>
</ul>
<p><strong>避免漂移的建议</strong>：</p>
<ul>
<li>合理设置线程池大小，避免线程不足</li>
<li>控制任务执行时间，避免长时间阻塞</li>
<li>监控任务执行延迟，及时调整配置</li>
</ul>
<h4 id="4-api-参数语义：delay-vs-period">4. API 参数语义：delay vs period</h4>
<p><strong>统一的时间参数模式</strong>：<br>
所有 <code>ScheduledExecutorService</code> 的方法都采用 <code>(long time, TimeUnit unit)</code> 的参数模式，这是 JUC 的统一设计风格。</p>
<p><strong>delay 的语义</strong>：</p>
<ul>
<li>表示&quot;延迟多久后首次执行&quot;</li>
<li>只影响第一次执行</li>
<li>是一次性的时间偏移</li>
</ul>
<p><strong>period 的语义</strong>：</p>
<ul>
<li>表示&quot;周期性执行的间隔&quot;</li>
<li>决定后续执行的节奏</li>
<li>计算方式在不同 API 中有差异：</li>
</ul>
<table>
<thead>
<tr>
<th>API</th>
<th>period 计算</th>
<th>是否追赶</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>scheduleAtFixedRate</code></td>
<td><code>上次理论触发时间 + period</code></td>
<td>是</td>
<td>采样、心跳、metrics 上报</td>
</tr>
<tr>
<td><code>scheduleWithFixedDelay</code></td>
<td><code>上次实际结束时间 + period</code></td>
<td>否</td>
<td>拉取消息、轮询、清理任务</td>
</tr>
</tbody>
</table>
<p><strong>示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// delay=2s, period=1s</span><br>executor.scheduleAtFixedRate(task, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><span class="hljs-comment">// 首次执行：延迟2秒后执行</span><br><span class="hljs-comment">// 后续执行：每隔1秒执行一次（基于理论时间轴）</span><br><br>executor.scheduleWithFixedDelay(task, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><span class="hljs-comment">// 首次执行：延迟2秒后执行</span><br><span class="hljs-comment">// 后续执行：上次执行结束后，再等待1秒执行（基于实际结束时间）</span><br></code></pre></td></tr></table></figure>
<h4 id="5-周期任务异常终止的陷阱">5. 周期任务异常终止的陷阱</h4>
<p><strong>关键问题</strong>：<br>
周期任务如果抛出 <code>RuntimeException</code> 或 <code>Error</code>，默认会终止后续调度，任务不再继续执行。这是最常见的生产环境陷阱之一。</p>
<p><strong>原因分析</strong>：<br>
根据 <code>ScheduledFutureTask.runPeriodic()</code> 的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runPeriodic</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset();<br>    <span class="hljs-keyword">if</span> (ok) &#123;<br>        setNextRunTime();  <span class="hljs-comment">// 计算下次触发时间</span><br>        reExecutePeriodic(outerTask);  <span class="hljs-comment">// 重新入队</span><br>    &#125;<br>    <span class="hljs-comment">// 如果任务抛出异常，ok=false，不会重新入队，任务终止</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>错误示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br><br>executor.scheduleAtFixedRate(() -&gt; &#123;<br>    <span class="hljs-comment">// 如果这里抛出异常，后续调度会终止</span><br>    doSomethingThatMayThrowException();<br>    System.out.println(<span class="hljs-string">&quot;This will stop after exception&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>
<p><strong>正确做法</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">1</span>);<br><br>executor.scheduleAtFixedRate(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        doSomethingThatMayThrowException();<br>        System.out.println(<span class="hljs-string">&quot;Task completed&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 记录异常，但不影响后续调度</span><br>        logger.error(<span class="hljs-string">&quot;Scheduled task failed&quot;</span>, t);<br>    &#125;<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>
<p><strong>铁律</strong>：周期任务必须自己捕获所有异常并记录，否则你会看到&quot;过了一段时间定时任务不执行了&quot;。</p>
<h4 id="6-cancel-true-vs-cancel-false-的差异">6. cancel(true) vs cancel(false) 的差异</h4>
<p>根据 <code>Future.cancel(boolean mayInterruptIfRunning)</code> 的规范：</p>
<p><strong>cancel(false)</strong>：</p>
<ul>
<li>如果任务尚未开始，则取消任务</li>
<li>如果任务正在执行，<strong>不中断</strong>执行线程，让任务自然完成</li>
<li>适用于&quot;优雅取消&quot;场景</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">future.cancel(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 不中断正在执行的任务</span><br></code></pre></td></tr></table></figure>
<p><strong>cancel(true)</strong>：</p>
<ul>
<li>如果任务尚未开始，则取消任务</li>
<li>如果任务正在执行，尝试<strong>中断</strong>执行线程（调用 <code>Thread.interrupt()</code>）</li>
<li>适用于&quot;强制取消&quot;场景</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">future.cancel(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 尝试中断正在执行的任务</span><br></code></pre></td></tr></table></figure>
<p><strong>重要注意</strong>：</p>
<ul>
<li>中断只是设置中断标志，任务代码必须检查 <code>Thread.interrupted()</code> 或使用可中断方法才能真正终止</li>
<li>阻塞 IO、<code>synchronized</code> 锁等不一定响应中断</li>
<li>对于不可中断阻塞，需要使用底层超时机制（HTTP timeout、JDBC timeout 等）</li>
</ul>
<h4 id="7-setremoveoncancelpolicy-true-的重要性">7. setRemoveOnCancelPolicy(true) 的重要性</h4>
<p><strong>默认行为</strong>：</p>
<ul>
<li><code>cancel()</code> 只标记任务为&quot;已取消&quot;</li>
<li>任务对象仍留在 <code>DelayedWorkQueue</code> 中</li>
<li>直到到期取出时才发现已取消并跳过</li>
</ul>
<p><strong>问题场景</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 每个请求都 schedule 一个超时任务</span><br><span class="hljs-keyword">for</span> (Request req : requests) &#123;<br>    ScheduledFuture&lt;?&gt; timeout = executor.schedule(() -&gt; &#123;<br>        handleTimeout(req);<br>    &#125;, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>    <br>    req.addTimeoutFuture(timeout);<br>&#125;<br><br><span class="hljs-comment">// 请求完成后取消</span><br>timeout.cancel(<span class="hljs-literal">false</span>); <span class="hljs-comment">// 默认不移除，队列堆满已取消任务</span><br></code></pre></td></tr></table></figure>
<p><strong>开启移除策略</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">4</span>);<br>executor.setRemoveOnCancelPolicy(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 强烈建议开启</span><br></code></pre></td></tr></table></figure>
<p><strong>效果</strong>：</p>
<ul>
<li><code>cancel()</code> 时立即从队列移除任务</li>
<li>减少队列扫描开销和内存占用</li>
<li><strong>强烈推荐</strong>用于&quot;每个请求都 schedule 超时任务&quot;的场景</li>
</ul>
<h4 id="8-周期任务复用对象与串行化的设计原理">8. 周期任务复用对象与串行化的设计原理</h4>
<p><strong>核心设计</strong>：<br>
周期任务不是每次都新建对象，而是复用同一个 <code>ScheduledFutureTask</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ScheduledFutureTask.runPeriodic() 的核心逻辑</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runPeriodic</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ok</span> <span class="hljs-operator">=</span> ScheduledFutureTask.<span class="hljs-built_in">super</span>.runAndReset();<br>    <span class="hljs-keyword">if</span> (ok) &#123;<br>        setNextRunTime();  <span class="hljs-comment">// 计算下次触发时间</span><br>        reExecutePeriodic(outerTask);  <span class="hljs-comment">// 重新入队同一个对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Queue as DelayedWorkQueue
    participant Task as ScheduledFutureTask
    participant Worker as WorkerThread
    
    rect rgb(200, 220, 240)
        Note over Queue,Task: 第一次执行
        Queue-&gt;&gt;Task: take() 取出任务
        Task-&gt;&gt;Worker: 执行 run()
        Worker-&gt;&gt;Worker: 执行任务逻辑
        Worker-&gt;&gt;Task: run() 完成
        Task-&gt;&gt;Task: setNextRunTime()
        Task-&gt;&gt;Queue: reExecutePeriodic(同一对象)
    end
    
    rect rgb(220, 200, 240)
        Note over Queue,Task: 第二次执行
        Queue-&gt;&gt;Task: take() 取出同一任务
        Task-&gt;&gt;Worker: 执行 run()
        Worker-&gt;&gt;Worker: 执行任务逻辑
        Worker-&gt;&gt;Task: run() 完成
        Task-&gt;&gt;Task: setNextRunTime()
        Task-&gt;&gt;Queue: reExecutePeriodic(同一对象)
    end</code></pre>
<p><strong>设计原因</strong>：</p>
<ul>
<li><strong>内存效率</strong>：避免为每次执行创建新对象</li>
<li><strong>串行化保证</strong>：因为复用同一个对象，且只有在当前执行完成后才重新入队，所以不会存在&quot;同一个任务的多个实例同时待执行&quot;</li>
<li><strong>追赶机制</strong>：追赶逻辑在 <code>setNextRunTime()</code> 中根据时间戳计算，即使追赶多次，也是串行重新入队</li>
</ul>
<p><strong>这就是串行追赶的本质设计原因</strong>。</p>
<h4 id="9-time-字段的可复用设计">9. time 字段的可复用设计</h4>
<p><strong>DelayedWorkQueue 的核心机制</strong>：<br>
<code>DelayedWorkQueue</code> 基于 <code>Delayed</code> 接口的 <code>getDelay()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Delayed</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Comparable</span>&lt;Delayed&gt; &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>ScheduledFutureTask 的 time 字段</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ScheduledFutureTask</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableScheduledFuture</span>&lt;V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> time;  <span class="hljs-comment">// 纳秒级 deadline</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>        <span class="hljs-keyword">return</span> unit.convert(time - now(), TimeUnit.NANOSECONDS);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br>        <span class="hljs-keyword">if</span> (other == <span class="hljs-built_in">this</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> ScheduledFutureTask) &#123;<br>            ScheduledFutureTask&lt;?&gt; x = (ScheduledFutureTask&lt;?&gt;)other;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.time - x.time;<br>            <span class="hljs-keyword">return</span> diff &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : diff &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">diff</span> <span class="hljs-operator">=</span> getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS);<br>        <span class="hljs-keyword">return</span> diff &lt; <span class="hljs-number">0</span> ? -<span class="hljs-number">1</span> : diff &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>经典的可复用设计</strong>：</p>
<ul>
<li><code>time</code> 字段用于堆排序（<code>compareTo</code> 基于 <code>time</code>）</li>
<li><code>time</code> 字段用于判断是否到期（<code>getDelay()</code> 计算剩余时间）</li>
<li><strong>可复用</strong>：周期任务重新入队时，只需更新 <code>time</code> 字段，无需新建对象</li>
</ul>
<p>这是一个经典的时间轮/延迟队列设计模式，高效且内存友好。</p>
<h4 id="10-理论时间轴-vs-当下时间起点：rate-vs-delay-的根本差异">10. 理论时间轴 vs 当下时间起点：Rate vs Delay 的根本差异</h4>
<p><strong>scheduleAtFixedRate（固定频率）</strong>：</p>
<ul>
<li>基于理论时间轴：<code>startTime + n * period</code></li>
<li>下次触发时间 = <code>上次理论触发时间 + period</code></li>
<li>如果执行延迟，会追赶：<code>nextTime = max(now, theoreticalTime)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> period;<br>    <span class="hljs-keyword">if</span> (p &gt; <span class="hljs-number">0</span>)<br>        time += p;  <span class="hljs-comment">// 累加 period，基于理论时间轴</span><br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">gantt
    title scheduleAtFixedRate：理论时间轴（period=1s）
    dateFormat X
    axisFormat %s
    
    section 理论时间轴
    触发1 : 0, 1
    触发2 : 1, 2
    触发3 : 2, 3
    触发4 : 3, 4
    
    section 实际执行（执行慢）
    执行1 : 0, 1.5
    追赶 : 1.5, 2
    执行2 : 2, 3
    执行3 : 3, 4
    执行4 : 4, 5</code></pre>
<p><strong>scheduleWithFixedDelay（固定延迟）</strong>：</p>
<ul>
<li>基于当下时间起点：<code>endTime + period</code></li>
<li>下次触发时间 = <code>上次实际结束时间 + period</code></li>
<li>不会追赶：执行越慢，整个时间轴越往后推</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">setNextRunTime</span><span class="hljs-params">()</span> &#123;<br>    time = now() + (-period);  <span class="hljs-comment">// 重新计算，基于当前时间</span><br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">gantt
    title scheduleWithFixedDelay：当下时间起点（delay=1s）
    dateFormat X
    axisFormat %s
    
    section 执行时间轴
    执行1 : 0, 1.5
    等待1s : 1.5, 2.5
    执行2 : 2.5, 3.5
    等待1s : 3.5, 4.5
    执行3 : 4.5, 6
    等待1s : 6, 7</code></pre>
<p><strong>核心差异</strong>：</p>
<ul>
<li><strong>Rate</strong>：基于理论时间轴，产生追赶效应</li>
<li><strong>Delay</strong>：基于当下时间起点，不产生追赶效应</li>
</ul>
<p>这就是两套 API 产生追赶或者不追赶的根本原因。</p>
<h4 id="11-工程级最佳实践">11. 工程级最佳实践</h4>
<p><strong>周期任务的三条铁律</strong>：</p>
<ol>
<li>永远捕获 Throwable，避免任务因为异常而静默停止</li>
<li>永远加超时（IO/锁等待/远程调用）</li>
<li>永远可取消 + 可观测（日志/metrics/最后成功时间）</li>
</ol>
<p><strong>不要完全替代 cron</strong>：<br>
如果你需要&quot;每天 02:00&quot;（墙上时钟语义、时区/DST/补偿错过的执行），<code>ScheduledExecutorService</code> 不够强；更适合使用：</p>
<ul>
<li>Quartz</li>
<li>Spring <code>@Scheduled(cron=...)</code>（底层常用线程池，但语义更偏 cron）</li>
</ul>
<p><code>ScheduledExecutor</code> 更擅长：</p>
<ul>
<li>“从现在开始每隔 5 秒”</li>
<li>“延迟 200ms 后做一次”</li>
<li>“固定节拍采样/心跳”</li>
</ul>
<p><strong>任务隔离</strong>：<br>
不同性质任务分不同 scheduler：</p>
<ul>
<li>一个专门跑心跳/采样（轻量）</li>
<li>一个专门跑清理/同步（可能重 IO）<br>
否则重任务会把轻任务拖延，造成级联误判（比如心跳延迟导致误判下游故障）。</li>
</ul>
<p><strong>生产级配置示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 生产级ScheduledExecutor配置示例</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 关键特性：</span><br><span class="hljs-comment"> * 1. 周期任务异常捕获</span><br><span class="hljs-comment"> * 2. 任务执行指标记录</span><br><span class="hljs-comment"> * 3. 优雅关闭机制</span><br><span class="hljs-comment"> * 4. 取消策略配置</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> magicliang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2026-01-24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SchedulerDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(SchedulerDemo.class);<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledThreadPoolExecutor exec;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">successCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">failureCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> ScheduledFuture&lt;?&gt; future;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SchedulerDemo</span><span class="hljs-params">()</span> &#123;<br>        exec = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">2</span>, r -&gt; &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>            t.setName(<span class="hljs-string">&quot;biz-scheduler-&quot;</span> + t.getId());<br>            t.setDaemon(<span class="hljs-literal">false</span>);<br>            t.setUncaughtExceptionHandler((thread, throwable) -&gt; &#123;<br>                logger.error(<span class="hljs-string">&quot;Uncaught exception in thread: &#123;&#125;&quot;</span>, thread.getName(), throwable);<br>            &#125;);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;);<br><br>        <span class="hljs-comment">// 关键配置：取消时立即从队列移除</span><br>        exec.setRemoveOnCancelPolicy(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 关键配置：shutdown后不再执行延迟任务</span><br>        exec.setExecuteExistingDelayedTasksAfterShutdownPolicy(<span class="hljs-literal">false</span>);<br>        <span class="hljs-comment">// 关键配置：shutdown后不再执行周期任务</span><br>        exec.setContinueExistingPeriodicTasksAfterShutdownPolicy(<span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        future = exec.scheduleWithFixedDelay(() -&gt; &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行实际任务（带超时控制）</span><br>                doWorkWithTimeout();<br>                successCount.incrementAndGet();<br>                recordSuccess();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                <span class="hljs-comment">// 必须捕获Throwable，防止周期任务静默停止</span><br>                failureCount.incrementAndGet();<br>                recordFailure(t);<br>                logger.error(<span class="hljs-string">&quot;Scheduled task failed, count: &#123;&#125;&quot;</span>, failureCount.get(), t);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">costMs</span> <span class="hljs-operator">=</span> (System.nanoTime() - start) / <span class="hljs-number">1_000_000</span>;<br>                recordLatency(costMs);<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stop</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (future != <span class="hljs-literal">null</span>) &#123;<br>            future.cancel(<span class="hljs-literal">false</span>);<br>        &#125;<br>        exec.shutdown();<br>        <span class="hljs-keyword">if</span> (!exec.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS)) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Scheduler did not terminate in time, forcing shutdown&quot;</span>);<br>            exec.shutdownNow();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 模拟方法（实际项目中应替换为真实实现）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWorkWithTimeout</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 实际业务逻辑</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordSuccess</span><span class="hljs-params">()</span> &#123;<br>        logger.info(<span class="hljs-string">&quot;Task succeeded, total success: &#123;&#125;&quot;</span>, successCount.get());<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>        logger.error(<span class="hljs-string">&quot;Task failed, total failures: &#123;&#125;&quot;</span>, failureCount.get());<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recordLatency</span><span class="hljs-params">(<span class="hljs-type">long</span> costMs)</span> &#123;<br>        logger.debug(<span class="hljs-string">&quot;Task latency: &#123;&#125;ms&quot;</span>, costMs);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="the-executors">The Executors</h3>
<blockquote>
<p>provides convenient factory methods for these Executors.</p>
</blockquote>
<h4 id="常用工厂方法详解">常用工厂方法详解</h4>
<p><code>java.util.concurrent.Executors</code> 类提供了多个工厂方法用于创建预配置的线程池实现。这些方法简化了常见场景下的线程池创建，但开发者必须理解其内部配置的适用场景和潜在风险。</p>
<pre><code class="hljs mermaid">graph TB
    A[Executors 工厂方法] --&gt; B[newFixedThreadPool]
    A --&gt; C[newCachedThreadPool]
    A --&gt; D[newSingleThreadExecutor]
    A --&gt; E[newSingleThreadScheduledExecutor]
    A --&gt; F[newScheduledThreadPool]
    A --&gt; G[newWorkStealingPool]
    
    B --&gt; B1[&quot;固定大小线程池&quot;]
    B --&gt; B2[&quot;无界队列&quot;]
    B --&gt; B3[&quot;适用于限流场景&quot;]
    
    C --&gt; C1[&quot;可缓存线程池&quot;]
    C --&gt; C2[&quot;SynchronousQueue&quot;]
    C --&gt; C3[&quot;适用于短任务&quot;]
    
    D --&gt; D1[&quot;单线程执行器&quot;]
    D --&gt; D2[&quot;无界队列&quot;]
    D --&gt; D3[&quot;顺序执行保证&quot;]
    
    E --&gt; E1[&quot;单线程调度器&quot;]
    E --&gt; E2[&quot;支持定时/周期&quot;]
    E --&gt; E3[&quot;顺序调度保证&quot;]
    
    F --&gt; F1[&quot;多线程调度器&quot;]
    F --&gt; F2[&quot;支持定时/周期&quot;]
    F --&gt; F3[&quot;固定大小&quot;]
    
    G --&gt; G1[&quot;工作窃取池&quot;]
    G --&gt; G2[&quot;ForkJoinPool&quot;]
    G --&gt; G3[&quot;并行任务优化&quot;]</code></pre>
<h5 id="1-newfixedthreadpool">1. newFixedThreadPool</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newFixedThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(nThreads, nThreads,<br>                                  <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                  Executors.defaultThreadFactory(),<br>                                  defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>内部配置</strong>：</p>
<ul>
<li>核心线程数：<code>nThreads</code></li>
<li>最大线程数：<code>nThreads</code>（等于核心线程数）</li>
<li>空闲线程存活时间：0</li>
<li>工作队列：<code>LinkedBlockingQueue</code>（无界队列）</li>
<li>拒绝策略：<code>AbortPolicy</code>（抛出 <code>RejectedExecutionException</code>）</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>线程数量固定，资源消耗可预测，适合限流场景</li>
<li>通过无界队列保证任务不会丢失</li>
<li>核心线程不会回收，减少线程创建开销</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>无界队列风险</strong>：任务提交速度持续超过处理速度时，队列会无限增长，可能导致 <code>OutOfMemoryError</code></li>
<li>无法应对突发性任务高峰（因为最大线程数等于核心线程数）</li>
<li>队列积压会导致任务延迟增加</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>任务执行时间相对稳定</li>
<li>需要限制系统资源使用</li>
<li>任务可以接受排队等待</li>
<li>典型应用：数据库连接池辅助、限流的批处理任务</li>
</ul>
<h5 id="2-newcachedthreadpool">2. newCachedThreadPool</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newCachedThreadPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">0</span>, Integer.MAX_VALUE,<br>                                  <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>                                  <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;Runnable&gt;(),<br>                                  Executors.defaultThreadFactory(),<br>                                  defaultHandler);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>内部配置</strong>：</p>
<ul>
<li>核心线程数：0</li>
<li>最大线程数：<code>Integer.MAX_VALUE</code>（理论无界）</li>
<li>空闲线程存活时间：60秒</li>
<li>工作队列：<code>SynchronousQueue</code>（不存储元素，直接传递）</li>
<li>拒绝策略：<code>AbortPolicy</code></li>
</ul>
<p><strong>命名解析</strong>：<br>
&quot;cached&quot;源于其核心的线程缓存复用机制：</p>
<ul>
<li>线程执行完任务后进入60秒缓存期而非立即销毁</li>
<li>缓存期内的新任务可直接复用现有线程</li>
<li>减少线程创建/销毁开销，实现资源的有效利用<br>
这种设计使线程池能够在任务执行间隙实现线程复用，体现了&quot;缓存&quot;的核心语义。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>能够快速响应大量短时任务</li>
<li>空闲线程自动回收，节省资源</li>
<li>无队列积压，任务提交即执行（有空闲线程时）</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>线程数无界风险</strong>：任务提交速度持续超过处理速度时，线程数会无限增长，可能导致 <code>OutOfMemoryError</code> 或系统资源耗尽</li>
<li>不适合长时间运行的任务</li>
<li>线程创建和销毁有性能开销</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>大量短时异步任务</li>
<li>任务执行时间不可预测但通常很短</li>
<li>对响应速度要求高</li>
<li>典型应用：异步日志记录、HTTP 请求分发</li>
</ul>
<h5 id="3-newsinglethreadexecutor">3. newSingleThreadExecutor</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newSingleThreadExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizableDelegatedExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>,<br>                                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(),<br>                                Executors.defaultThreadFactory(),<br>                                defaultHandler));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>内部配置</strong>：</p>
<ul>
<li>核心线程数：1</li>
<li>最大线程数：1</li>
<li>空闲线程存活时间：0</li>
<li>工作队列：<code>LinkedBlockingQueue</code>（无界队列）</li>
<li>拒绝策略：<code>AbortPolicy</code></li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>保证任务按提交顺序执行（FIFO）</li>
<li>无并发安全问题（单线程）</li>
<li>不可重新配置（委托模式封装）</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>无界队列风险</strong>：任务积压可能导致 OOM</li>
<li>吞吐量受限于单线程性能</li>
<li>任务执行失败会影响后续任务</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>需要保证执行顺序的任务</li>
<li>避免并发竞争的场景</li>
<li>事务性操作（需要串行化）</li>
<li>典型应用：数据库事务操作、文件顺序写入</li>
</ul>
<h5 id="4-newsinglethreadscheduledexecutor">4. newSingleThreadScheduledExecutor</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newSingleThreadScheduledExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatedScheduledExecutorService</span><br>        (<span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>));<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>内部配置</strong>：</p>
<ul>
<li>基于 <code>ScheduledThreadPoolExecutor</code>，核心线程数为1</li>
<li>支持 <code>schedule</code>、<code>scheduleAtFixedRate</code>、<code>scheduleWithFixedDelay</code></li>
<li>使用 <code>DelayedWorkQueue</code> 作为工作队列</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>支持定时和周期性任务</li>
<li>保证任务顺序执行</li>
<li>延迟任务调度精确</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>单线程限制吞吐量</li>
<li>周期任务执行时间过长会影响后续调度</li>
<li>任务异常会导致后续周期任务停止</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>定时任务（如心跳检测）</li>
<li>周期性数据清理</li>
<li>需要严格顺序的定时任务</li>
</ul>
<h5 id="5-newscheduledthreadpool">5. newScheduledThreadPool</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ScheduledExecutorService <span class="hljs-title function_">newScheduledThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(corePoolSize);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>内部配置</strong>：</p>
<ul>
<li>核心线程数：<code>corePoolSize</code></li>
<li>最大线程数：<code>Integer.MAX_VALUE</code></li>
<li>工作队列：<code>DelayedWorkQueue</code></li>
<li>支持延迟和周期性任务</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>支持定时和周期性任务</li>
<li>多线程提高吞吐量</li>
<li>延迟调度精确</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>最大线程数无界</li>
<li>周期任务执行时间过长会影响后续调度</li>
<li>相比 <code>newSingleThreadScheduledExecutor</code> 无顺序保证</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>多定时任务并发执行</li>
<li>周期性任务需要并行处理</li>
<li>批量定时调度</li>
</ul>
<h5 id="6-newworkstealingpool-jdk-8">6. newWorkStealingPool（JDK 8+）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newWorkStealingPool</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span><br>        (Runtime.getRuntime().availableProcessors(),<br>         ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>         <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newWorkStealingPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span><br>        (parallelism,<br>         ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>         <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>内部配置</strong>：</p>
<ul>
<li>基于 <code>ForkJoinPool</code></li>
<li>默认并行度：<code>Runtime.getRuntime().availableProcessors()</code></li>
<li>工作窃取算法优化任务分配</li>
<li>使用 <code>ForkJoinPool.WorkQueue</code></li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>工作窃取算法提高 CPU 利用率</li>
<li>适合分治并行任务</li>
<li>自动负载均衡</li>
<li>支持异步任务和递归任务</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>不适合阻塞操作（会降低工作窃取效率）</li>
<li>任务粒度过小会增加调度开销</li>
<li>与传统 <code>ThreadPoolExecutor</code> 语义不同</li>
</ul>
<p><strong>适用场景</strong>：</p>
<ul>
<li>分治算法（如归并排序）</li>
<li>递归并行任务</li>
<li>CPU 密集型并行计算</li>
<li>典型应用：并行流处理、大数据计算</li>
</ul>
<h4 id="工厂方法对比总结">工厂方法对比总结</h4>
<table>
<thead>
<tr>
<th>工厂方法</th>
<th>核心线程数</th>
<th>最大线程数</th>
<th>工作队列</th>
<th>主要风险</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>newFixedThreadPool</code></td>
<td>n</td>
<td>n</td>
<td>LinkedBlockingQueue（无界）</td>
<td>OOM（队列积压）</td>
<td>限流、稳定负载</td>
</tr>
<tr>
<td><code>newCachedThreadPool</code></td>
<td>0</td>
<td>MAX_VALUE</td>
<td>SynchronousQueue</td>
<td>OOM（线程爆炸）</td>
<td>短时任务、突发负载</td>
</tr>
<tr>
<td><code>newSingleThreadExecutor</code></td>
<td>1</td>
<td>1</td>
<td>LinkedBlockingQueue（无界）</td>
<td>OOM（队列积压）</td>
<td>顺序执行、事务操作</td>
</tr>
<tr>
<td><code>newSingleThreadScheduledExecutor</code></td>
<td>1</td>
<td>MAX_VALUE</td>
<td>DelayedWorkQueue</td>
<td>单点瓶颈</td>
<td>定时任务、顺序调度</td>
</tr>
<tr>
<td><code>newScheduledThreadPool</code></td>
<td>n</td>
<td>MAX_VALUE</td>
<td>DelayedWorkQueue</td>
<td>线程爆炸</td>
<td>并发定时任务</td>
</tr>
<tr>
<td><code>newWorkStealingPool</code></td>
<td>parallelism</td>
<td>parallelism</td>
<td>ForkJoinPool.WorkQueue</td>
<td>不适合阻塞任务</td>
<td>分治并行、CPU密集型</td>
</tr>
</tbody>
</table>
<h4 id="生产环境建议">生产环境建议</h4>
<p>根据 Java 并发实践专家的建议（基于 JSR-166 规范和 Javadoc）：</p>
<ol>
<li><strong>避免使用无界队列</strong>：生产环境应使用有界队列（如 <code>ArrayBlockingQueue</code>）或自定义拒绝策略</li>
<li><strong>避免使用无界线程数</strong>：明确设置合理的最大线程数</li>
<li><strong>为线程池命名</strong>：使用自定义 <code>ThreadFactory</code> 设置有意义的线程名称，便于问题排查</li>
<li><strong>显式指定拒绝策略</strong>：根据业务需求选择合适的拒绝策略</li>
<li><strong>监控线程池状态</strong>：通过 <code>ThreadPoolExecutor</code> 提供的监控方法跟踪活跃线程数、队列大小等指标</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 推荐的生产环境配置示例</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>,                              <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-number">20</span>,                              <span class="hljs-comment">// 最大线程数</span><br>    <span class="hljs-number">60L</span>, TimeUnit.SECONDS,           <span class="hljs-comment">// 空闲线程存活时间</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),   <span class="hljs-comment">// 有界队列</span><br>    Executors.defaultThreadFactory(), <span class="hljs-comment">// 默认线程工厂，生产环境建议自定义</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="hljs-comment">// 拒绝策略</span><br>);<br><br><span class="hljs-comment">// 自定义 ThreadFactory 示例（推荐）</span><br><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">customThreadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">namePrefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;worker-&quot;</span>;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, namePrefix + threadNumber.getAndIncrement());<br>        t.setDaemon(<span class="hljs-literal">false</span>);  <span class="hljs-comment">// 非守护线程</span><br>        t.setPriority(Thread.NORM_PRIORITY);<br>        t.setUncaughtExceptionHandler((thread, throwable) -&gt; &#123;<br>            <span class="hljs-comment">// 自定义异常处理逻辑</span><br>            System.err.println(<span class="hljs-string">&quot;线程 &quot;</span> + thread.getName() + <span class="hljs-string">&quot; 发生异常: &quot;</span> + throwable.getMessage());<br>        &#125;);<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 使用自定义 ThreadFactory 的完整配置</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">productionExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>,<br>    <span class="hljs-number">20</span>,<br>    <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),<br>    customThreadFactory,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()<br>);<br></code></pre></td></tr></table></figure>
<h2 id="层次调用关系">层次调用关系</h2>
<h3 id="futuretask-作为线程池的核心任务载体">FutureTask 作为线程池的核心任务载体</h3>
<p>以  FutureTask 为核心，可以看出如下关系：</p>
<pre><code class="hljs mermaid">classDiagram
    class FutureTask &#123;
        -callable: Callable~V~
        -outcome: Object
        -state: int
        -runner: Thread
        
        +run() void
        +get() V
        +cancel(boolean) boolean
        +isDone() boolean
    &#125;
    
    class RunnableFuture &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    
    class Runnable &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    
    class Future &#123;
        &lt;&lt;interface&gt;&gt;
        +get() V
        +cancel(boolean) boolean
        +isDone() boolean
    &#125;
    
    class Callable &#123;
        &lt;&lt;interface&gt;&gt;
        +call() V
    &#125;
    
    FutureTask ..|&gt; RunnableFuture : implements
    RunnableFuture --|&gt; Runnable : extends
    RunnableFuture --|&gt; Future : extends
    FutureTask o-- Callable : has
    FutureTask o-- Object : stores
    FutureTask o-- Thread : references</code></pre>
<ul>
<li>我们先产生一个新的 Future 接口，然后把 Runnable 和 Future 联合继承出 RunnableFuture。这两个类型一个是对内线程池使用，一个是对外对任务的使用者使用。</li>
<li>然后 RunnableFuture 有个经典实现类 FutureTask-这是两个经典的 RunnableFuture 的经典实现之一（<code>All Known Implementing Classes:FutureTask, SwingWorker</code>），可以认为 FutureTask 是可执行的 Future 的最忠实实现。它本身<strong>不是 Callble，但是包含 Callable</strong>。它的5个一级子成员：
<ul>
<li>callable</li>
<li>outCome 这个成员同时可以是 result 也可以是异常，由 report 自行决定处理方式</li>
<li>runner：用来状态检查，并持有它保证拥有中断能力、取消能力</li>
<li>state：这是线程池里出现的第一个状态，</li>
</ul>
</li>
<li>因为是 runnable 包着 callable，所以底层的运行模式大概是这样的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 之所以这样设计，本质上是因为 Thread 类底层也是 run，不支持 call</span><br>task.run() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行组合的 Callable</span><br>        outcome = callable.call();  <span class="hljs-comment">// &quot;Hello World&quot;</span><br>        state = NORMAL;            <span class="hljs-comment">// 状态转换</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        exception = e;             <span class="hljs-comment">// 存储异常</span><br>        state = EXCEPTIONAL;       <span class="hljs-comment">// 状态转换</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="thread-模型底层">Thread 模型底层</h4>
<p>之所以这样设计，实际上是因为 Thread 模型底层只支持 run 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java 从 1.0 开始就实现了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> Runnable target;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>            target.run();  <span class="hljs-comment">// 只能调用 run()，没有返回值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>底层的 cpp 源码是（以下代码基于 HotSpot JDK 11，不同版本实现可能有差异）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// HotSpot JVM 源码：thread.cpp (JDK 11)</span><br><span class="hljs-built_in">JVM_ENTRY</span>(<span class="hljs-type">void</span>, <span class="hljs-built_in">JVM_StartThread</span>(JNIEnv* jni, jobject jthread))<br>  <span class="hljs-built_in">JVMWrapper</span>(<span class="hljs-string">&quot;JVM_StartThread&quot;</span>);<br>  <br>  <span class="hljs-comment">// 1. 从 Java 对象获取 C++ Thread 对象</span><br>  JavaThread* native_thread = java_lang_Thread::<span class="hljs-built_in">thread</span>(JNIHandles::<span class="hljs-built_in">resolve_non_null</span>(jthread));<br>  <br>  <span class="hljs-comment">// 2. 状态检查</span><br>  <span class="hljs-keyword">if</span> (native_thread-&gt;<span class="hljs-built_in">is_being_ext_suspended</span>()) &#123;<br>    native_thread-&gt;<span class="hljs-built_in">set_terminated_before_start</span>(<span class="hljs-literal">true</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 3. 创建操作系统线程</span><br>  <span class="hljs-keyword">if</span> (native_thread-&gt;<span class="hljs-built_in">osthread</span>() != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// 关键：调用 os::create_thread 创建 OS 线程</span><br>    <span class="hljs-keyword">if</span> (os::<span class="hljs-built_in">create_thread</span>(native_thread, java_thread)) &#123;<br>      <span class="hljs-comment">// 4. 设置线程状态为 INITIALIZED</span><br>      native_thread-&gt;<span class="hljs-built_in">set_state</span>(INITIALIZED);<br>      <br>      <span class="hljs-comment">// 5. 启动操作系统线程</span><br>      os::<span class="hljs-built_in">start_thread</span>(native_thread);<br>    &#125;<br>  &#125;<br>JVM_END<br><br><span class="hljs-comment">// Linux 实现 (os_linux.cpp)</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">os::create_thread</span><span class="hljs-params">(Thread* thread, ThreadType thr_type)</span> </span>&#123;<br>  <span class="hljs-comment">// 1. 创建 pthread_attr_t 属性</span><br>  <span class="hljs-type">pthread_attr_t</span> attr;<br>  <span class="hljs-built_in">pthread_attr_init</span>(&amp;attr);<br>  <br>  <span class="hljs-comment">// 2. 设置栈大小</span><br>  <span class="hljs-type">size_t</span> stack_size = ...; <span class="hljs-comment">// 根据线程类型设置</span><br>  <span class="hljs-built_in">pthread_attr_setstacksize</span>(&amp;attr, stack_size);<br>  <br>  <span class="hljs-comment">// 3. 关键：创建 pthread 线程</span><br>  <span class="hljs-type">pthread_t</span> tid;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;tid, &amp;attr, thread_native_entry, thread);<br>  <br>  <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 4. 保存线程 ID</span><br>    thread-&gt;<span class="hljs-built_in">set_thread_id</span>(tid);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 线程入口函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">thread_native_entry</span><span class="hljs-params">(Thread* thread)</span> </span>&#123;<br>  <span class="hljs-comment">// 1. 设置线程状态</span><br>  thread-&gt;<span class="hljs-built_in">set_state</span>(RUNNABLE);<br>  <br>  <span class="hljs-comment">// 2. 关键：调用 Java 层的 run() 方法</span><br>  thread-&gt;<span class="hljs-built_in">run</span>();<br>  <br>  <span class="hljs-comment">// 3. 线程结束处理</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// HotSpot JVM 中的关键结构，这个 javaThread 既持有操作系统线程句柄，也持有 Java 线程句柄。这样实现了平台无关性。</span><br><span class="hljs-comment">// JavaThread 确实是三位一体的设计：</span><br><span class="hljs-comment">// 1. JVM 层：JavaThread* 本身（管理 JVM 内部状态）</span><br><span class="hljs-comment">// 2. OS 层：OSThread* _osthread（操作系统资源）</span><br><span class="hljs-comment">// 3. Java 层：oop _threadObj（java.lang.Thread 对象）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaThread</span>: <span class="hljs-keyword">public</span> Thread &#123;<br><span class="hljs-keyword">private</span>:<br>  oop _threadObj;        <span class="hljs-comment">// 对应的 Java Thread 对象</span><br>  OSThread* _osthread;   <span class="hljs-comment">// 操作系统线程</span><br>  <span class="hljs-keyword">volatile</span> JavaThreadState _state; <span class="hljs-comment">// 线程状态</span><br>  <br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用 Java 层的 run() 方法</span><br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">thread_main_inner</span>();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_main_inner</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_java_lang_thread</span>()) &#123;<br>      <span class="hljs-comment">// 通过 JNI 调用 Java 层的 run() 方法</span><br>      JavaCalls::<span class="hljs-built_in">call_virtual</span>(<br>        &amp;result,<br>        klass,<br>        method,<br>        threadObj,<br>        CHECK<br>      );<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 通过 JNI 调用 Java 方法</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">call_run_method</span><span class="hljs-params">(JNIEnv* env, jobject jthread)</span> </span>&#123;<br>  jclass threadClass = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;java/lang/Thread&quot;</span>);<br>  jmethodID runMethod = env-&gt;<span class="hljs-built_in">GetMethodID</span>(threadClass, <span class="hljs-string">&quot;run&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>  <br>  <span class="hljs-comment">// 调用 Thread.run() 方法</span><br>  env-&gt;<span class="hljs-built_in">CallVoidMethod</span>(jthread, runMethod);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>整体调用的流程是从 java 到 cpp 再到 java 的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 调用链：</span><br>thread<span class="hljs-selector-class">.start</span>()<br>  → Thread<span class="hljs-selector-class">.start</span>() <span class="hljs-selector-attr">[Java]</span><br>  → <span class="hljs-built_in">start0</span>() <span class="hljs-selector-attr">[native]</span><br>  → <span class="hljs-built_in">JVM_StartThread</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → os::<span class="hljs-built_in">create_thread</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → <span class="hljs-built_in">pthread_create</span>() <span class="hljs-selector-attr">[Linux C]</span><br>  → <span class="hljs-built_in">thread_native_entry</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → JavaThread::<span class="hljs-built_in">run</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → JNI: <span class="hljs-built_in">CallVoidMethod</span>(threadObj, <span class="hljs-string">&quot;run&quot;</span>) <span class="hljs-selector-attr">[JNI]</span><br>  → Thread<span class="hljs-selector-class">.run</span>() <span class="hljs-selector-attr">[Java]</span><br>  → target<span class="hljs-selector-class">.run</span>() <span class="hljs-selector-attr">[Java]</span>  <span class="hljs-comment">// 最终调用用户代码</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">classDiagram
    class JavaThread &#123;
        -OSThread* _osthread
        -oop _threadObj
        -JavaThreadState _state
        -address _stack_base
        -size_t _stack_size
        
        +run()
        +thread_main_inner()
        +osthread() OSThread*
        +threadObj() oop
    &#125;
    
    class OSThread &#123;
        -pthread_t _thread_id
        -int _thread_state
        
        +set_thread_id(pthread_t)
        +thread_id() pthread_t
    &#125;
    
    class JavaThreadObj &#123;
        &lt;&lt;Java Object&gt;&gt;
        -Runnable target
        -int threadStatus
        
        +start()
        +run()
    &#125;
    
    JavaThread o-- OSThread : &quot;持有操作系统线程&quot;
    JavaThread o-- JavaThreadObj : &quot;关联Java对象&quot;</code></pre>
<pre><code class="hljs mermaid">sequenceDiagram
    participant User as Java代码
    participant JVM as JVM(JavaThread)
    participant OS as 操作系统
    
    User-&gt;&gt;JVM: new Thread(runnable)
    JVM-&gt;&gt;JVM: 创建JavaThread对象
    JVM-&gt;&gt;JVM: 创建OSThread对象
    JVM-&gt;&gt;JVM: 关联JavaThread和OSThread
    
    User-&gt;&gt;JVM: thread.start()
    JVM-&gt;&gt;JVM: 检查状态(threadStatus)
    JVM-&gt;&gt;JVM: 添加到线程组
    JVM-&gt;&gt;JVM: 调用start0()(native)
    
    JVM-&gt;&gt;OS: os::create_thread()
    OS-&gt;&gt;OS: 创建pthread线程
    OS-&gt;&gt;OS: 设置入口为thread_native_entry
    
    OS--&gt;&gt;JVM: 线程创建成功
    JVM--&gt;&gt;User: start()返回
    
    Note over OS: 新线程开始执行
    OS-&gt;&gt;JVM: thread_native_entry(JavaThread*)
    JVM-&gt;&gt;JVM: 设置线程状态为RUNNABLE
    JVM-&gt;&gt;JVM: thread-&gt;run()
    JVM-&gt;&gt;JVM: thread_main_inner()
    
    JVM-&gt;&gt;JVM: JNI: 查找Thread.run()方法
    JVM-&gt;&gt;JVM: JavaCalls::call_virtual()
    
    JVM-&gt;&gt;User: 调用Thread.run()
    User-&gt;&gt;User: target.run()(如果target!=null)
    
    User--&gt;&gt;JVM: 返回
    JVM-&gt;&gt;JVM: 线程结束清理
    JVM-&gt;&gt;OS: 释放操作系统资源</code></pre>
<h4 id="futuretask-的-run">FutureTask 的 run()</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123;<br>    <br>    <span class="hljs-comment">// 同时实现 Runnable（可执行）和 Future（可获取结果）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset, <span class="hljs-literal">null</span>, Thread.currentThread()))<br>            <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            Callable&lt;V&gt; c = callable;<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>                V result;<br>                <span class="hljs-type">boolean</span> ran;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    result = c.call();  <span class="hljs-comment">// 执行实际任务（支持返回值）</span><br>                    ran = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                    result = <span class="hljs-literal">null</span>;<br>                    ran = <span class="hljs-literal">false</span>;<br>                    setException(ex);  <span class="hljs-comment">// 设置异常</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (ran)<br>                    set(result);  <span class="hljs-comment">// 设置结果</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            runner = <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>            <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>                handlePossibleCancellationInterrupt(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="futuretask-的-runner">FutureTask 的 runner</h4>
<p>其中 runner 的注入/获取流程大致如下：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant ThreadA
    participant FutureTask
    participant ThreadB
    
    ThreadA-&gt;&gt;FutureTask: submit(task)
    FutureTask-&gt;&gt;FutureTask: state = NEW, runner = null
    
    ThreadB-&gt;&gt;FutureTask: execute(task) // 线程池线程
    FutureTask-&gt;&gt;FutureTask: CAS设置 runner = ThreadB
    FutureTask-&gt;&gt;ThreadB: 执行任务逻辑
    
    Note right of FutureTask: 此时 runner = ThreadB
    
    ThreadA-&gt;&gt;FutureTask: cancel(true)
    FutureTask-&gt;&gt;FutureTask: 检查 mayInterruptIfRunning = true
    FutureTask-&gt;&gt;ThreadB: runner.interrupt() // 使用runner字段
    
    ThreadB--&gt;&gt;FutureTask: 任务被中断
    FutureTask-&gt;&gt;FutureTask: state = INTERRUPTED
    FutureTask-&gt;&gt;FutureTask: runner = null // 清理引用
    
    Note right of FutureTask: 任务完成，runner = null</code></pre>
<h5 id="invokeall">invokeAll</h5>
<p><strong>invokeAll 是有界的</strong>，如果一次性提交了超过它界限的任务，即使这些任务是一瞬间执行的-invokeAll 也会触发拒绝，除非任务执行的速度比 for 循环调用底层的 execute 的速度还要快。</p>
<p>如果有得选，我们批量执行任务应该尽量采用 invokeAll，因为它带有这些特殊的代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                                         <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (tasks == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(tasks.size());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">done</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks)<br>                futures.add(newTaskFor(t));<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> futures.size();<br><br>            <span class="hljs-comment">// Interleave time checks and calls to execute in case</span><br>            <span class="hljs-comment">// executor doesn&#x27;t have any/much parallelism.</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                execute((Runnable)futures.get(i));<br>                nanos = deadline - System.nanoTime();<br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> futures;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                Future&lt;T&gt; f = futures.get(i);<br>                <span class="hljs-keyword">if</span> (!f.isDone()) &#123;<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                        <span class="hljs-keyword">return</span> futures;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// FutureTask 是可以重复获取的</span><br>                        f.get(nanos, TimeUnit.NANOSECONDS);<br>                    &#125; <span class="hljs-keyword">catch</span> (CancellationException ignore) &#123;<br>                    &#125; <span class="hljs-keyword">catch</span> (ExecutionException ignore) &#123;<br>                    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>                        <span class="hljs-keyword">return</span> futures;<br>                    &#125;<br>                    nanos = deadline - System.nanoTime();<br>                &#125;<br>            &#125;<br>            done = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> futures;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (!done)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = futures.size(); i &lt; size; i++)                <br>                    <span class="hljs-comment">// 我们不鼓励 cancel java 线程，但是可以，而且鼓励 cancel Future</span><br>                    futures.get(i).cancel(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h5 id="两种针对-runnable-的-submit">两种针对 Runnable 的 submit</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通 submit(Runnable) - Future.get() 返回 null</span><br>Future&lt;?&gt; future3 = executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;普通任务&quot;</span>));<br><span class="hljs-type">Object</span> <span class="hljs-variable">result3</span> <span class="hljs-operator">=</span> future3.get(); <span class="hljs-comment">// result3 == null</span><br><br><span class="hljs-comment">// submit(Runnable, T result) - Future.get() 返回指定的结果</span><br>Future&lt;String&gt; future4 = executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;带结果的任务&quot;</span>), <span class="hljs-string">&quot;自定义结果&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">result4</span> <span class="hljs-operator">=</span> future4.get(); <span class="hljs-comment">// result4 == &quot;自定义结果&quot;</span><br></code></pre></td></tr></table></figure>
<p>这里面使用到了2种适配器：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">用户层：需要 <span class="hljs-built_in">submit</span>(Runnable, T result) 这样的高级API<br>       ↓<br>适配层：RunnableAdapter 提供语义适配<br>       ↓  <br>执行层：FutureTask 提供接口适配  <br>       ↓<br>基础层：ThreadPoolExecutor 只认 <span class="hljs-built_in">execute</span>(Runnable)<br></code></pre></td></tr></table></figure>
<p>也就是说，底层的 execute 本身要求一个包含 callable + result 的 runnbale - FutureTask（向底层的 execute api 适配，向外提供 Future 的 get、cancel 等能力），但是这样的 callable 最初又要经过 RunnableAdapter 从 Runnable 得来（向上向原始的没有返回值的 Runnable 适配）。</p>
<p>想象一个国际物流系统：</p>
<ul>
<li>FutureTask：相当于报关代理，将&quot;有特殊要求的货物&quot;（Callable）转换成&quot;标准集装箱&quot;（Runnable）以便运输</li>
<li>RunnableAdapter：相当于包装服务，将&quot;普通货物&quot;（Runnable）包装成&quot;带保价标签的货物&quot;（Callable），提供额外保障</li>
</ul>
<p>两类底层调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 底层调用链</span><br><span class="hljs-comment">// 1. submit(callable) → new FutureTask(callable)</span><br><span class="hljs-comment">// 2. execute(futureTask) → futureTask.run()</span><br><span class="hljs-comment">// 3. futureTask.run() → callable.call() → return 42</span><br><span class="hljs-comment">// 4. future.get() → 42</span><br><br><span class="hljs-comment">// 底层调用链</span><br><span class="hljs-comment">// 1. submit(runnable, result) → Executors.callable(runnable, result) </span><br><span class="hljs-comment">//   → new RunnableAdapter(runnable, result)</span><br><span class="hljs-comment">// 2. new FutureTask(runnableAdapter) </span><br><span class="hljs-comment">//   → futureTask内部持有runnableAdapter</span><br><span class="hljs-comment">// 3. execute(futureTask) → futureTask.run()</span><br><span class="hljs-comment">// 4. futureTask.run() → runnableAdapter.call()</span><br><span class="hljs-comment">// 5. runnableAdapter.call() → runnable.run() + return successMessage</span><br><span class="hljs-comment">// 6. future.get() → successMessage</span><br></code></pre></td></tr></table></figure>
<p>至此，我们已经理解了执行器体系的继承关系、任务包装机制和调用链路。接下来，我们深入ThreadPoolExecutor的内部实现，首先看它如何通过巧妙的位运算同时维护线程池状态和工作线程数量。</p>
<h2 id="线程池如何维护自身状态">线程池如何维护自身状态</h2>
<p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>
<p>ctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，<strong>不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况</strong>。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。<strong>这里都使用的是位运算的方式，相比于基本运算，速度也会快很多</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 29</span><br>        System.out.println(COUNT_BITS);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">shifted</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 1 与 29 个 0，所以左移意味着补 0，左移一位意味着补 1 个 0，左移 29 位意味着补 29 个 0，最后得到 30 位数：100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(shifted));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> shifted - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 29个 1：11111111111111111111111111111</span><br>        System.out.println(Integer.toBinaryString(CAPACITY));<br>        <span class="hljs-comment">// 高 3 位为 1，低 29 位为 0：11100000000000000000000000000000，和 CAPACITY 低 29 位为 1，高 3 位为 0 恰好相反</span><br>        System.out.println(Integer.toBinaryString(~CAPACITY));<br>        System.out.println(Integer.toBinaryString(~CAPACITY));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// -1 意味着 32 个 1：11111111111111111111111111111111</span><br>        System.out.println(Integer.toBinaryString(-<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 3 个 1 和 29 个 0：11100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(RUNNING));<br>        <br>        <span class="hljs-comment">// 重点：从后方补 0 的算法，可以把 state 的基准位从低位移到高位，这样大数的一部分就可以拿来表示有限状态了</span><br>        <br>        <span class="hljs-comment">// 0 不管位移多少位都是 0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br>        System.out.println(Integer.toBinaryString(SHUTDOWN));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 1 和 29 个 0：100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(STOP));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 10 和 29 个 0：1000000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(TIDYING));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 11 和 29 个 0：1100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(TERMINATED));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> getCapacity();<br>        <span class="hljs-comment">// 把 CAPACITY 的补码按位与，这样高 32 位就可以被取出来</span><br>        <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; <br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> getCapacity();<br>        <span class="hljs-comment">// 低 32 位本身就是 workCount，这个 workCount 可以容纳很大的数</span><br>        <span class="hljs-keyword">return</span> c &amp; CAPACITY; <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123;<br>        <span class="hljs-keyword">return</span> rs | wc; <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCapacity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">shifted</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> shifted - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> CAPACITY;<br>    &#125;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">运行状态</th>
<th style="text-align:center">状态描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RUNNING</td>
<td style="text-align:center">能接受新提交的任务，并且也能处理阻塞队列中的任务。</td>
</tr>
<tr>
<td style="text-align:center">SHUTDOWN</td>
<td style="text-align:center">关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。</td>
</tr>
<tr>
<td style="text-align:center">STOP</td>
<td style="text-align:center">不能接受新任务，【也不处理队列中的任务，会中断正在处理任务的线程。】增加了两条措施，是一个更严厉的状态，理论上只要线程被中断完，线程池就可以走向关闭</td>
</tr>
<tr>
<td style="text-align:center">TIDYING</td>
<td style="text-align:center">所有的任务都已终止了，workerCount (有效线程数) 为0，这个状态的意思不是整理中，而是整理完了。</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td style="text-align:center">在terminated() 方法执行完后进入该状态。</td>
</tr>
</tbody>
</table>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程池生命周期.png"></p>
<p>其中 running 既是初始态，也是中间态，所以才有<code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</code>作为初始化块的一部分。</p>
<h3 id="尝试关闭线程池">尝试关闭线程池</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Transitions to TERMINATED state if either (SHUTDOWN and pool</span><br><span class="hljs-comment"> * and queue empty) or (STOP and pool empty).  If otherwise</span><br><span class="hljs-comment"> * eligible to terminate but workerCount is nonzero, interrupts an</span><br><span class="hljs-comment"> * idle worker to ensure that shutdown signals propagate. This</span><br><span class="hljs-comment"> * method must be called following any action that might make</span><br><span class="hljs-comment"> * termination possible -- reducing worker count or removing tasks</span><br><span class="hljs-comment"> * from the queue during shutdown. The method is non-private to</span><br><span class="hljs-comment"> * allow access from ScheduledThreadPoolExecutor.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 注意这里有个自旋</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">//  尝试把把本线程池的状态改成 TIDYING -&gt; TERMINATED，所以正在 running、正在 shutdown 但队列未空、已经高于 TIDYING 都直接返回</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 只要 wc&gt;0，就关闭并只关闭一个空闲线程（看起来这里是假设本方法通常是由线程退出来触发的，所以此处能够关掉一个就直接退出）</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果一个 worker 都没有了，就真的关闭本线程池</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 此处的ctlOf转换在语义上是冗余的,因为workerCount已经为0,但保持了代码的一致性</span><br>            <span class="hljs-comment">// 先置为 TIDYING</span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 通常是一个空钩子方法，这两个状态之间就差了一个钩子设计</span><br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 再设置为 TERMINATED</span><br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    <span class="hljs-comment">// 已关闭才做 signalAll()</span><br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>        <span class="hljs-comment">// 这里失败，下次再从外部进入 TIDYING -&gt; TERMINATED 的循环</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="线程池如何管理任务">线程池如何管理任务</h2>
<p>每个线程池的 Worker 管理的实质上是 FutureTask，它既是<code>Callable</code>（确切地说，wrap Callable），也是<code>Future</code>（一个最完美的任务是一个<code>RunnableFuture&lt;V&gt;</code>，用成员变量来帮助 <code>Runnable</code>来保存一个<code>Callable</code>的返回值，以供<code>Future</code>使用）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个可以取消的计算。</span><br><span class="hljs-comment">// 基本上只能完成一次，除非执行 runAndReset，执行完成不能再 cancel</span><br><span class="hljs-comment">// 只有计算执行完成 get 才可以获取结果，之前必然阻塞</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A cancellable asynchronous computation.  This class provides a base</span><br><span class="hljs-comment"> * implementation of &#123;<span class="hljs-doctag">@link</span> Future&#125;, with methods to start and cancel</span><br><span class="hljs-comment"> * a computation, query to see if the computation is complete, and</span><br><span class="hljs-comment"> * retrieve the result of the computation.  The result can only be</span><br><span class="hljs-comment"> * retrieved when the computation has completed; the &#123;<span class="hljs-doctag">@code</span> get&#125;</span><br><span class="hljs-comment"> * methods will block if the computation has not yet completed.  Once</span><br><span class="hljs-comment"> * the computation has completed, the computation cannot be restarted</span><br><span class="hljs-comment"> * or cancelled (unless the computation is invoked using</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #runAndReset&#125;).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;A &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; can be used to wrap a &#123;<span class="hljs-doctag">@link</span> Callable&#125; or</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Runnable&#125; object.  Because &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; implements</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> Runnable&#125;, a &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; can be submitted to an</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Executor&#125; for execution.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;In addition to serving as a standalone class, this class provides</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> protected&#125; functionality that may be useful when creating</span><br><span class="hljs-comment"> * customized task classes.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Doug Lea</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;V&gt; The result type returned by this FutureTask&#x27;s &#123;<span class="hljs-doctag">@code</span> get&#125; methods</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>线程池使用一个把 Runnable 转变为 Callable 的适配器（Callable 转 Runnable 理论上也是容易做到的，但应该没有必要转换），来兼容把 Runnable 传进 submit 的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 把 runnable 和一个勉强的 result 包装成一个 callable，分三步</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>        <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>        <span class="hljs-built_in">this</span>.state = NEW;       <span class="hljs-comment">// ensure visibility of callable</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="hljs-title function_">callable</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt;(task, result);<br>    &#125;<br>    <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">final</span> Runnable task;<br>        <span class="hljs-keyword">final</span> T result;<br>        RunnableAdapter(Runnable task, T result) &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>            <span class="hljs-built_in">this</span>.result = result;<br>        &#125;<br>        <span class="hljs-comment">// 注意，这个 call() 是不抛出异常的，所以对 Java 而言，子类的签名里可以不继续抛出父类声明的异常，</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>            task.run();<br>            <span class="hljs-comment">// 组合逻辑在这一层</span><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>FutureTask 实现了 RunnableFuture，它本质上是一个携带 Runnable 和 state 的任务。</p>
<p>首先看它的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The run state of this task, initially NEW.  The run state</span><br><span class="hljs-comment">     * transitions to a terminal state only in methods set,</span><br><span class="hljs-comment">     * setException, and cancel.  During completion, state may take on</span><br><span class="hljs-comment">     * transient values of COMPLETING (while outcome is being set) or</span><br><span class="hljs-comment">     * INTERRUPTING (only while interrupting the runner to satisfy a</span><br><span class="hljs-comment">     * cancel(true)). Transitions from these intermediate to final</span><br><span class="hljs-comment">     * states use cheaper ordered/lazy writes because values are unique</span><br><span class="hljs-comment">     * and cannot be further modified.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Possible state transitions:</span><br><span class="hljs-comment">     * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="hljs-comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="hljs-comment">     * NEW -&gt; CANCELLED</span><br><span class="hljs-comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br></code></pre></td></tr></table></figure>
<p><strong>FutureTask 状态转换图</strong>：</p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; NEW: 任务创建
    
    NEW --&gt; COMPLETING: call()执行完成
    NEW --&gt; CANCELLED: cancel(false)
    NEW --&gt; INTERRUPTING: cancel(true)
    
    COMPLETING --&gt; NORMAL: 正常结果设置完成
    COMPLETING --&gt; EXCEPTIONAL: 异常结果设置完成
    
    INTERRUPTING --&gt; INTERRUPTED: 中断完成
    
    NORMAL --&gt; [*]: 终态
    EXCEPTIONAL --&gt; [*]: 终态
    CANCELLED --&gt; [*]: 终态
    INTERRUPTED --&gt; [*]: 终态
    
    note right of NEW: 初始状态，任务可被取消
    note right of COMPLETING: 瞬态，正在设置结果
    note right of INTERRUPTING: 瞬态，正在中断runner</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>值得一提的是，任务的中间状态是一个瞬态，它非常的短暂。而且任务的中间态并不代表任务正在执行，而是任务已经执行完了，正在设置最终的返回结果，所以可以这么说：<br>
只要state不处于 NEW 状态，就说明任务已经执行完毕。<br>
注意，<strong>这里的执行完毕是指传入的Callable对象的call方法执行完毕</strong>，<strong>或者抛出了异常</strong>。所以这里的COMPLETING的名字显得有点迷惑性，它并不意味着任务正在执行中，而意味着call方法已经执行完毕，正在设置任务执行的结果。</p>
</blockquote>
<p>换言之，只有 NEW 状态才是 cancellable 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Doug Lea 本身比较喜欢使用普通整数来制造状态机</span><br><span class="hljs-comment">// COMPLETING 和 INTERRUPTING 是 set state 和取消任务的中间态</span><br>    <br>    <span class="hljs-comment">/** The underlying callable; nulled out after running */</span><br>    <span class="hljs-keyword">private</span> Callable&lt;V&gt; callable;<br>    <br>    <span class="hljs-comment">// 异常和输出使用同一个 outcome，所以 outcome 不能是泛型，必须是 object</span><br>    <span class="hljs-comment">// 它是非 volatile 的，需要巧妙利用 state 读写</span><br>    <span class="hljs-comment">// </span><br>    <span class="hljs-comment">// **happens-before 传递性分析**：outcome 的可见性是通过 state 的 volatile 写-读来保证的。</span><br>    <span class="hljs-comment">// 这依赖于 JMM 的 happens-before 传递性：</span><br>    <span class="hljs-comment">// 1. outcome = v happens-before state = NORMAL（程序顺序规则：同一线程内，前面的操作 happens-before 后面的操作）</span><br>    <span class="hljs-comment">// 2. state = NORMAL happens-before 读取 state（volatile 规则：volatile 写 happens-before 后续的 volatile 读）</span><br>    <span class="hljs-comment">// 3. 因此，outcome = v happens-before 读取 outcome（传递性）</span><br>    <span class="hljs-comment">// 这就是为什么 outcome 不需要声明为 volatile，只要保证在写 outcome 之后再写 volatile state，</span><br>    <span class="hljs-comment">// 在读 volatile state 之后再读 outcome，就能保证 outcome 的可见性。</span><br>    <span class="hljs-comment">/** The result to return or exception to throw from get() */</span><br>    <span class="hljs-keyword">private</span> Object outcome; <span class="hljs-comment">// non-volatile, protected by state reads/writes</span><br>    <br>    <span class="hljs-comment">/** The thread running the callable; CASed during run() */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread runner;<br>    <br>    <span class="hljs-comment">/** Treiber stack of waiting threads */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WaitNode waiters;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.callable = callable;<br>    <span class="hljs-comment">// ensure visibility of callable</span><br>    <span class="hljs-built_in">this</span>.state = NEW;       <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>            <span class="hljs-comment">// 把 volatile 变量写在写语句的最后，写在读语句的最前面，类似 monitorEnter 和 monitorExit 的语义，可以保证可见性</span><br>    <span class="hljs-comment">// ensure visibility of callable</span><br>    <span class="hljs-built_in">this</span>.state = NEW;       <br>&#125;<br></code></pre></td></tr></table></figure>
<p>它的状态管理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state &gt;= CANCELLED;<br>    &#125;<br>    <span class="hljs-comment">// 只要不是 NEW 就是完成了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state != NEW;<br>    &#125;<br><br>    <br>    <span class="hljs-comment">// 移除并通知所有等待线程，</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Removes and signals all waiting threads, invokes done(), and</span><br><span class="hljs-comment">     * nulls out callable.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishCompletion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// assert state &gt; COMPLETING;</span><br>        <span class="hljs-comment">// 漂亮的声明和比对写法</span><br>        <span class="hljs-keyword">for</span> (WaitNode q; (q = waiters) != <span class="hljs-literal">null</span>;) &#123;<br>            <span class="hljs-comment">// 在 for 循环里用 cas 把 waiter 置空</span><br>            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q, <span class="hljs-literal">null</span>)) &#123;        <br>                <span class="hljs-comment">// 在内层循环里把当前线程和 futureTask 的关系移除，并且</span><br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    <span class="hljs-comment">// 在这个内存循环里面，要做的就是一个个遍历链表的 next，unpark 掉它们，并且 help gc</span><br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q.thread;<br>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                        q.thread = <span class="hljs-literal">null</span>;<br>                        LockSupport.unpark(t);<br>                    &#125;<br>                    <span class="hljs-type">WaitNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> q.next;<br>                    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>                        <span class="hljs-keyword">break</span>;<br>                    q.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// unlink to help gc</span><br>                    q = next;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        done();<br>        <span class="hljs-comment">// 此处就是上面的 nulled 的意思了，任务进入终态以后 callable 也可以被回收</span><br>        callable = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// to reduce footprint</span><br>    &#125;<br>    <br><span class="hljs-comment">// 通过使 permit 变成 available 的方式，使这个线程从 blocked 状态变成非 blocked 状态，或者下次调用 park 的时候非阻塞。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>            UNSAFE.unpark(thread);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>实际被工作线程调度的 run 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 如果不等于 new 或者 cas 把线程绑定到本 future task 上，就直接退出，这其实是一种幂等</span><br>    <span class="hljs-comment">// runner 的获取是从上下文里获得的</span><br>    <span class="hljs-keyword">if</span> (state != NEW ||<br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                     <span class="hljs-literal">null</span>, Thread.currentThread()))<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Callable&lt;V&gt; c = callable;<br>        <span class="hljs-comment">// 只有状态和 callable 完备才能把值设进来</span><br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>            V result;<br>            <span class="hljs-type">boolean</span> ran;<br>            <span class="hljs-keyword">try</span> &#123;<br>                result = c.call();<br>                ran = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                result = <span class="hljs-literal">null</span>;<br>                ran = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// 如果 run 出异常，就进入 setException 终态方法</span><br>                setException(ex);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (ran)<br>                <span class="hljs-comment">// 否则，set result，走入另一种终态</span><br>                set(result);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// runner must be non-null until state is settled to</span><br>        <span class="hljs-comment">// prevent concurrent calls to run()</span><br>        <span class="hljs-comment">// 执行完要把 runner 置空，这样上面那个 cas 对其他线程而言就会失败</span><br>        runner = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// state must be re-read after nulling runner to prevent</span><br>        <span class="hljs-comment">// leaked interrupts</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>            <span class="hljs-comment">// 可能有其他线程在 interrupting，在这里实现一套等待到  interrupted 的自旋 yield</span><br>            handlePossibleCancellationInterrupt(s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>run 有一个重跑版本，这个版本会重复执行，但不会影响 get 的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Executes the computation without setting its result, and then</span><br><span class="hljs-comment"> * resets this future to initial state, failing to do so if the</span><br><span class="hljs-comment"> * computation encounters an exception or is cancelled.  This is</span><br><span class="hljs-comment"> * designed for use with tasks that intrinsically execute more</span><br><span class="hljs-comment"> * than once.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if successfully run and reset</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runAndReset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (state != NEW ||<br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                     <span class="hljs-literal">null</span>, Thread.currentThread()))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ran</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Callable&lt;V&gt; c = callable;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; s == NEW) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                c.call(); <span class="hljs-comment">// don&#x27;t set result</span><br>                ran = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                setException(ex);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// runner must be non-null until state is settled to</span><br>        <span class="hljs-comment">// prevent concurrent calls to run()</span><br>        runner = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// state must be re-read after nulling runner to prevent</span><br>        <span class="hljs-comment">// leaked interrupts</span><br>        s = state;<br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>            handlePossibleCancellationInterrupt(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ran &amp;&amp; s == NEW;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 FutureTask 里有三类终态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V v)</span> &#123;<br>    <span class="hljs-comment">// 在两个 CAS 操作之间夹逼一个 outcome</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>        outcome = v;<br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, NORMAL); <span class="hljs-comment">// final state</span><br>        finishCompletion();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 几乎等同于 set，但夹逼的是把 Throwable 设进 outcome 里面</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setException</span><span class="hljs-params">(Throwable t)</span> &#123;<br>    <span class="hljs-comment">// 注意这里只能把 callable 内部的异常设置进 outcome 里面，如果本服务发生了 interrupt，则这里必然失败</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>        outcome = t;<br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="hljs-comment">// final state</span><br>        finishCompletion();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 从这个方法可以看出，中断也是 cancel 的一种</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br>    <span class="hljs-comment">// 在一个布尔表达式里面表达顺序结构</span><br>    <span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp;<br>          UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW,<br>              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br>        <span class="hljs-comment">// 只能从 new 迁移到 INTERRUPTING 或者 CANCELLED，只要 cas 不成功，就返回 false。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// in case call to interrupt throws exception</span><br>        <span class="hljs-comment">// 如果取消带有中断标志</span><br>        <span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;<br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 强制中断这个线程</span><br>                    t.interrupt();<br>            &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// final state</span><br>                <span class="hljs-comment">// 不使用 cas，把本应用的状态设为已中断</span><br>                UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, INTERRUPTED);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 所有的终态操作都有的一个操作</span><br>        finishCompletion();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果程序进入终态，则 get 终于可以得到合理的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// get 的阻塞部分交给 awaitDone，而取值部分交给 report</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-comment">// 比对状态</span><br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>        <span class="hljs-comment">// 进入计时的 awaitDone 流程，这里的计时结果是带有状态的，0L 意味着无限计时。</span><br>        s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    <span class="hljs-comment">// 进入 report 流程</span><br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br>   <br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>    <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>        (s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中等待流程见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Awaits completion or aborts on interrupt or timeout.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> timed true if use timed waits</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> nanos time to wait, if timed</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> state upon completion</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>     <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;<br>     <span class="hljs-type">WaitNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>     <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>     <span class="hljs-comment">// 这里通过自旋来实现计时等待</span><br>     <span class="hljs-keyword">for</span> (;;) &#123;<br>         <span class="hljs-comment">// 如果本线程被中断，则释放所有的 get 线程，然后抛出一个中断异常，这里引入了一个经典的设计模式，在 waiting  状态内发生 interrupt 的地方，响应中断的方式是清空中断位（而不是简单地 swap），并抛出中断异常</span><br>         <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>             <span class="hljs-comment">// 如果中断了（不正常退出），清空 waiter</span><br>             removeWaiter(q);<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>         &#125;<br><br>         <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>         <span class="hljs-comment">// 进入终态，返回 s</span><br>         <span class="hljs-keyword">if</span> (s &gt; COMPLETING) &#123;<br>             <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>)<br>                 <span class="hljs-comment">// 清空等待栈的线程，waitnode 可以功成身退了，但只清空当前的 q 的 thread，并不做完整的 removeWaiter</span><br>                 q.thread = <span class="hljs-literal">null</span>;<br>             <span class="hljs-keyword">return</span> s;<br>         &#125;<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == COMPLETING) <span class="hljs-comment">// cannot time out yet</span><br>             <span class="hljs-comment">// no-op</span><br>             Thread.<span class="hljs-keyword">yield</span>();<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)<br>             <span class="hljs-comment">// 这里生成了一个 waitnode，注意，这里的调用栈是等待线程 get -&gt; awaitDone()，所以此处会捕获get 线程进 waitnode 里，在本循环里产生了第一个 q 的节点。</span><br>             q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();<br>             <span class="hljs-comment">// 一般第一轮循环q 总是为 null 的，只有第二轮进入这个地方的，才会进入这个分支，而且这里可能会失败，如果失败也，这时候就会把</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)<br>             <span class="hljs-comment">// 如果 q 不为空，且没有入队，则首先把当前的 waiters 放到当前的 q.next 里，然后把 q 放到本类型的 waiters 里（用新 q 代替老 waiter）</span><br>             queued = UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                                                  q.next = waiters, q);<br>         <span class="hljs-comment">// 前面两轮循环都走过了（前面两轮必须使 q 不为空，queued变成 true，才进入接下来的循环），接下来就进入 park 或者 parkNanos，看看会不会再被唤醒了</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;<br>             nanos = deadline - System.nanoTime();<br>             <span class="hljs-comment">// 如果超时了（bu），清空 waiter</span><br>             <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                 removeWaiter(q);<br>                 <span class="hljs-keyword">return</span> state;<br>             &#125;<br>             <span class="hljs-comment">// 如果没有超时，本线程先驻留一下，驻留完进入下一个循环</span><br>             LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>         &#125;<br>         <span class="hljs-keyword">else</span><br>             <span class="hljs-comment">// 否则，无限驻留，直到下一个循环。下一个循环必须由 finishCompletion 里的 LockSupport.unpark(t); 触发</span><br>             LockSupport.park(<span class="hljs-built_in">this</span>);<br>     &#125;<br> &#125;<br> <br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Simple linked list nodes to record waiting threads in a Treiber</span><br><span class="hljs-comment">  * stack.  See other classes such as Phaser and SynchronousQueue</span><br><span class="hljs-comment">  * for more detailed explanation.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span> &#123;<br>     <span class="hljs-keyword">volatile</span> Thread thread;<br>     <span class="hljs-keyword">volatile</span> WaitNode next;<br>     WaitNode() &#123; thread = Thread.currentThread(); &#125;<br> &#125;<br> <br> <span class="hljs-comment">// 解掉链表，help gc</span><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Tries to unlink a timed-out or interrupted wait node to avoid</span><br><span class="hljs-comment">  * accumulating garbage.  Internal nodes are simply unspliced</span><br><span class="hljs-comment">  * without CAS since it is harmless if they are traversed anyway</span><br><span class="hljs-comment">  * by releasers.  To avoid effects of unsplicing from already</span><br><span class="hljs-comment">  * removed nodes, the list is retraversed in case of an apparent</span><br><span class="hljs-comment">  * race.  This is slow when there are a lot of nodes, but we don&#x27;t</span><br><span class="hljs-comment">  * expect lists to be long enough to outweigh higher-overhead</span><br><span class="hljs-comment">  * schemes.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeWaiter</span><span class="hljs-params">(WaitNode node)</span> &#123;<br>     <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>         node.thread = <span class="hljs-literal">null</span>;<br>         retry:<br>         <span class="hljs-keyword">for</span> (;;) &#123;          <span class="hljs-comment">// restart on removeWaiter race</span><br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">WaitNode</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, q = waiters, s; q != <span class="hljs-literal">null</span>; q = s) &#123;<br>                 s = q.next;<br>                 <span class="hljs-keyword">if</span> (q.thread != <span class="hljs-literal">null</span>)<br>                     pred = q;<br>                 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>                     pred.next = s;<br>                     <span class="hljs-keyword">if</span> (pred.thread == <span class="hljs-literal">null</span>) <span class="hljs-comment">// check for race</span><br>                         <span class="hljs-keyword">continue</span> retry;<br>                 &#125;<br>                 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                                                       q, s))<br>                     <span class="hljs-keyword">continue</span> retry;<br>             &#125;<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>然后就把outcome 通过 report 传出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里使用 object 转 v，必然带来 warning</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;<br>    <span class="hljs-keyword">if</span> (s == NORMAL)<br>        <span class="hljs-keyword">return</span> (V)x;<br>    <span class="hljs-keyword">if</span> (s &gt;= CANCELLED)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<br>    <span class="hljs-comment">// 我们在外部 get catch 的异常就是从这里抛出的。注意这个转型的用意，get 只有一个固定的执行异常，就是这个异常，表明错误来自计算过程内部</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable)x);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="任务执行">任务执行</h3>
<h4 id="提交任务调度">提交任务调度</h4>
<ol>
<li>首先检测线程池运行状态，如果不是 RUNNING，则直接拒绝，线程池要保证在 RUNNING 的状态下执行任务。</li>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p><img src="%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png" alt="任务调度流程.png"></p>
<h4 id="任务缓冲">任务缓冲</h4>
<p>任务缓冲模块是线程池能够管理任务的核心部分。<strong>线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦</strong>，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是**（阻塞的本质即为此）：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。**阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="阻塞队列的工作原理.png"></p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ArrayBlockingQueue</td>
<td style="text-align:center">一个用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序。<strong>支持公平锁和非公平锁</strong>。</td>
</tr>
<tr>
<td style="text-align:center">DelayQueue</td>
<td style="text-align:center">一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。</td>
</tr>
<tr>
<td style="text-align:center">LinkedBlockingDeque</td>
<td style="text-align:center">一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，<strong>可以将锁的竞争最多降到一半</strong>。</td>
</tr>
<tr>
<td style="text-align:center">LinkedBlockingQueue</td>
<td style="text-align:center">一个由链表结构组成的有界队列，此队列按照先进先出(FIFO)的原则对元素进行排序。此队列的默认长度为Integer.MAX_VALUE，<strong>所以默认创建的该队列有容量危险</strong>。</td>
</tr>
<tr>
<td style="text-align:center">LinkedTransferQueue</td>
<td style="text-align:center">一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</td>
</tr>
<tr>
<td style="text-align:center">PriorityBlockingQueue</td>
<td style="text-align:center">一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</td>
</tr>
<tr>
<td style="text-align:center">SynchronousQueue</td>
<td style="text-align:center">一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，<strong>线程空闲了60秒后会被回收</strong>。</td>
</tr>
</tbody>
</table>
<p><strong>阻塞队列选择决策流程图：</strong></p>
<pre><code class="hljs mermaid">flowchart TD
    A[选择阻塞队列] --&gt; B&#123;是否需要有界队列?&#125;
    B --&gt;|是| C&#123;是否需要公平性?&#125;
    B --&gt;|否| D&#123;是否需要优先级?&#125;
    
    C --&gt;|是| E[ArrayBlockingQueue&lt;br/&gt;公平模式]
    C --&gt;|否| F&#123;数组还是链表?&#125;
    
    F --&gt;|数组-内存连续| G[ArrayBlockingQueue&lt;br/&gt;非公平模式]
    F --&gt;|链表-动态扩展| H[LinkedBlockingQueue&lt;br/&gt;指定容量]
    
    D --&gt;|是| I[PriorityBlockingQueue]
    D --&gt;|否| J&#123;是否需要延迟?&#125;
    
    J --&gt;|是| K[DelayQueue]
    J --&gt;|否| L&#123;是否需要直接传递?&#125;
    
    L --&gt;|是| M[SynchronousQueue]
    L --&gt;|否| N[LinkedBlockingQueue&lt;br/&gt;默认容量]
    
    style E fill:#90EE90
    style G fill:#90EE90
    style H fill:#87CEEB
    style I fill:#FFB6C1
    style K fill:#DDA0DD
    style M fill:#F0E68C
    style N fill:#87CEEB</code></pre>
<p><strong>各种阻塞队列的使用示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockingQueueExamples</span> &#123;<br>    <br>    <span class="hljs-comment">// ==================== 1. ArrayBlockingQueue ====================</span><br>    <span class="hljs-comment">// 特点：数组实现、有界、支持公平/非公平锁</span><br>    <span class="hljs-comment">// 适用场景：生产消费速率相近，需要控制内存使用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">arrayBlockingQueueExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建容量为10的有界队列，使用公平锁</span><br>        BlockingQueue&lt;String&gt; fairQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-literal">true</span>);<br>        <br>        <span class="hljs-comment">// 创建容量为10的有界队列，使用非公平锁（默认，性能更好）</span><br>        BlockingQueue&lt;String&gt; unfairQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>, <span class="hljs-literal">false</span>);<br>        <br>        <span class="hljs-comment">// 配合线程池使用 - 适合CPU密集型任务</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">4</span>,                          <span class="hljs-comment">// corePoolSize</span><br>            <span class="hljs-number">8</span>,                          <span class="hljs-comment">// maximumPoolSize</span><br>            <span class="hljs-number">60L</span>, TimeUnit.SECONDS,      <span class="hljs-comment">// keepAliveTime</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),  <span class="hljs-comment">// 有界队列，防止OOM</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="hljs-comment">// 队列满时由调用者执行</span><br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 2. LinkedBlockingQueue ====================</span><br>    <span class="hljs-comment">// 特点：链表实现、可选有界、读写分离锁</span><br>    <span class="hljs-comment">// 适用场景：生产消费速率不均，需要缓冲</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkedBlockingQueueExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 有界队列（推荐）</span><br>        BlockingQueue&lt;String&gt; boundedQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>);<br>        <br>        <span class="hljs-comment">// 无界队列（危险！可能导致OOM）</span><br>        BlockingQueue&lt;String&gt; unboundedQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 配合线程池使用 - 适合IO密集型任务</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">10</span>,                         <span class="hljs-comment">// corePoolSize</span><br>            <span class="hljs-number">10</span>,                         <span class="hljs-comment">// maximumPoolSize（与core相同，因为队列无界时max无意义）</span><br>            <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,  <span class="hljs-comment">// keepAliveTime</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">5000</span>),  <span class="hljs-comment">// 一定要指定容量！</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()<br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 3. SynchronousQueue ====================</span><br>    <span class="hljs-comment">// 特点：不存储元素、直接传递、支持公平/非公平</span><br>    <span class="hljs-comment">// 适用场景：任务需要立即执行，不需要缓冲</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">synchronousQueueExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 非公平模式（默认，性能更好）</span><br>        BlockingQueue&lt;String&gt; unfairQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 公平模式</span><br>        BlockingQueue&lt;String&gt; fairQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;(<span class="hljs-literal">true</span>);<br>        <br>        <span class="hljs-comment">// 配合线程池使用 - CachedThreadPool的实现原理</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">0</span>,                          <span class="hljs-comment">// corePoolSize = 0</span><br>            Integer.MAX_VALUE,          <span class="hljs-comment">// maximumPoolSize = 无限</span><br>            <span class="hljs-number">60L</span>, TimeUnit.SECONDS,      <span class="hljs-comment">// 空闲60秒回收</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;(),   <span class="hljs-comment">// 直接传递，不缓冲</span><br>            Executors.defaultThreadFactory(),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()<br>        );<br>        <span class="hljs-comment">// 注意：这种配置可能创建大量线程，需谨慎使用</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 4. PriorityBlockingQueue ====================</span><br>    <span class="hljs-comment">// 特点：优先级排序、无界、不保证同优先级顺序</span><br>    <span class="hljs-comment">// 适用场景：任务有优先级区分</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">priorityBlockingQueueExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 使用自然排序</span><br>        BlockingQueue&lt;Integer&gt; naturalQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 使用自定义比较器 - 按任务优先级排序</span><br>        BlockingQueue&lt;PriorityTask&gt; customQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;&gt;(<br>            <span class="hljs-number">11</span>,  <span class="hljs-comment">// 初始容量</span><br>            (t1, t2) -&gt; Integer.compare(t2.priority, t1.priority)  <span class="hljs-comment">// 优先级高的先执行</span><br>        );<br>        <br>        <span class="hljs-comment">// 配合线程池使用</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;&gt;()  <span class="hljs-comment">// 注意：无界队列</span><br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">// 优先级任务示例</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span>, Comparable&lt;PriorityTask&gt; &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> priority;<br>        <span class="hljs-keyword">final</span> String name;<br>        <br>        PriorityTask(<span class="hljs-type">int</span> priority, String name) &#123;<br>            <span class="hljs-built_in">this</span>.priority = priority;<br>            <span class="hljs-built_in">this</span>.name = name;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;执行任务: &quot;</span> + name + <span class="hljs-string">&quot;, 优先级: &quot;</span> + priority);<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(PriorityTask other)</span> &#123;<br>            <span class="hljs-comment">// 优先级高的排在前面</span><br>            <span class="hljs-keyword">return</span> Integer.compare(other.priority, <span class="hljs-built_in">this</span>.priority);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 5. DelayQueue ====================</span><br>    <span class="hljs-comment">// 特点：延迟获取、无界、元素必须实现Delayed接口</span><br>    <span class="hljs-comment">// 适用场景：定时任务、缓存过期、订单超时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">delayQueueExample</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        DelayQueue&lt;DelayedTask&gt; delayQueue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>&lt;&gt;();<br>        <br>        <span class="hljs-comment">// 添加延迟任务</span><br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedTask</span>(<span class="hljs-string">&quot;任务1&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS));<br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedTask</span>(<span class="hljs-string">&quot;任务2&quot;</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS));<br>        delayQueue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedTask</span>(<span class="hljs-string">&quot;任务3&quot;</span>, <span class="hljs-number">2</span>, TimeUnit.SECONDS));<br>        <br>        <span class="hljs-comment">// 按延迟时间顺序获取：任务2 -&gt; 任务3 -&gt; 任务1</span><br>        <span class="hljs-keyword">while</span> (!delayQueue.isEmpty()) &#123;<br>            <span class="hljs-type">DelayedTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> delayQueue.take();  <span class="hljs-comment">// 阻塞直到有元素到期</span><br>            System.out.println(<span class="hljs-string">&quot;执行: &quot;</span> + task.name);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 延迟任务示例</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>        <span class="hljs-keyword">final</span> String name;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> expireTime;  <span class="hljs-comment">// 到期时间（纳秒）</span><br>        <br>        DelayedTask(String name, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>            <span class="hljs-built_in">this</span>.name = name;<br>            <span class="hljs-built_in">this</span>.expireTime = System.nanoTime() + unit.toNanos(delay);<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> expireTime - System.nanoTime();<br>            <span class="hljs-keyword">return</span> unit.convert(remaining, TimeUnit.NANOSECONDS);<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed other)</span> &#123;<br>            <span class="hljs-keyword">if</span> (other <span class="hljs-keyword">instanceof</span> DelayedTask) &#123;<br>                <span class="hljs-keyword">return</span> Long.compare(<span class="hljs-built_in">this</span>.expireTime, ((DelayedTask) other).expireTime);<br>            &#125;<br>            <span class="hljs-keyword">return</span> Long.compare(getDelay(TimeUnit.NANOSECONDS), other.getDelay(TimeUnit.NANOSECONDS));<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 6. LinkedBlockingDeque ====================</span><br>    <span class="hljs-comment">// 特点：双端队列、可选有界、支持FIFO和LIFO</span><br>    <span class="hljs-comment">// 适用场景：工作窃取算法、需要双端操作</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">linkedBlockingDequeExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 有界双端队列</span><br>        LinkedBlockingDeque&lt;String&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="hljs-number">100</span>);<br>        <br>        <span class="hljs-comment">// 头部操作</span><br>        deque.addFirst(<span class="hljs-string">&quot;头部元素&quot;</span>);<br>        deque.offerFirst(<span class="hljs-string">&quot;头部元素2&quot;</span>);<br>        <br>        <span class="hljs-comment">// 尾部操作</span><br>        deque.addLast(<span class="hljs-string">&quot;尾部元素&quot;</span>);<br>        deque.offerLast(<span class="hljs-string">&quot;尾部元素2&quot;</span>);<br>        <br>        <span class="hljs-comment">// 工作窃取场景：本线程从头部取，其他线程从尾部偷</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ownTask</span> <span class="hljs-operator">=</span> deque.pollFirst();      <span class="hljs-comment">// 本线程取任务</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stolenTask</span> <span class="hljs-operator">=</span> deque.pollLast();    <span class="hljs-comment">// 其他线程偷任务</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>阻塞队列性能对比：</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph 吞吐量对比
        A[SynchronousQueue] --&gt;|最高| B[直接传递无锁竞争]
        C[LinkedBlockingQueue] --&gt;|高| D[读写分离锁]
        E[ArrayBlockingQueue] --&gt;|中| F[单锁]
        G[PriorityBlockingQueue] --&gt;|低| H[堆排序开销]
    end
    
    subgraph 内存占用对比
        I[SynchronousQueue] --&gt;|最低| J[不存储元素]
        K[ArrayBlockingQueue] --&gt;|固定| L[预分配数组]
        M[LinkedBlockingQueue] --&gt;|动态| N[按需分配节点]
        O[PriorityBlockingQueue] --&gt;|动态| P[堆结构]
    end</code></pre>
<h4 id="任务拒绝">任务拒绝</h4>
<p>当线程池的任务缓存队列已满并且线程池中的线程数目达到 maximumPoolSize 时，如果还有任务到来就会采取任务拒绝策略。</p>
<p><strong>拒绝策略触发流程：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Client as 客户端
    participant TPE as ThreadPoolExecutor
    participant Queue as 阻塞队列
    participant Handler as RejectedExecutionHandler
    
    Client-&gt;&gt;TPE: execute(task)
    TPE-&gt;&gt;TPE: 检查线程数 &lt; corePoolSize?
    
    alt 线程数 &lt; corePoolSize
        TPE-&gt;&gt;TPE: 创建核心线程执行
    else 线程数 &gt;= corePoolSize
        TPE-&gt;&gt;Queue: offer(task)
        alt 队列未满
            Queue--&gt;&gt;TPE: true
            TPE--&gt;&gt;Client: 任务入队成功
        else 队列已满
            Queue--&gt;&gt;TPE: false
            TPE-&gt;&gt;TPE: 检查线程数 &lt; maximumPoolSize?
            alt 线程数 &lt; maximumPoolSize
                TPE-&gt;&gt;TPE: 创建非核心线程执行
            else 线程数 &gt;= maximumPoolSize
                TPE-&gt;&gt;Handler: rejectedExecution(task, executor)
                Note over Handler: 执行拒绝策略
            end
        end
    end</code></pre>
<p><strong>四种内置拒绝策略详解：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RejectionPolicyExamples</span> &#123;<br>    <br>    <span class="hljs-comment">// ==================== 1. AbortPolicy（默认策略）====================</span><br>    <span class="hljs-comment">// 行为：直接抛出 RejectedExecutionException</span><br>    <span class="hljs-comment">// 适用场景：需要明确感知任务被拒绝，由调用方决定如何处理</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abortPolicyExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()  <span class="hljs-comment">// 默认策略</span><br>        );<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 提交3个任务：1个执行中，1个在队列，第3个会被拒绝</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>                executor.execute(() -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                        System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + taskId + <span class="hljs-string">&quot;完成&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>            <span class="hljs-comment">// 捕获拒绝异常，可以记录日志、降级处理等</span><br>            System.err.println(<span class="hljs-string">&quot;任务被拒绝: &quot;</span> + e.getMessage());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            executor.shutdown();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 2. CallerRunsPolicy ====================</span><br>    <span class="hljs-comment">// 行为：由提交任务的线程直接执行该任务</span><br>    <span class="hljs-comment">// 适用场景：不允许丢弃任务，可以接受调用线程被阻塞</span><br>    <span class="hljs-comment">// 优点：提供了一种简单的反压机制</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callerRunsPolicyExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()<br>        );<br>        <br>        System.out.println(<span class="hljs-string">&quot;主线程: &quot;</span> + Thread.currentThread().getName());<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.execute(() -&gt; &#123;<br>                <span class="hljs-comment">// 第3个任务会在主线程中执行</span><br>                System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + taskId + <span class="hljs-string">&quot;在线程&quot;</span> + <br>                    Thread.currentThread().getName() + <span class="hljs-string">&quot;中执行&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <br>        executor.shutdown();<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 3. DiscardPolicy ====================</span><br>    <span class="hljs-comment">// 行为：静默丢弃被拒绝的任务，不抛出异常</span><br>    <span class="hljs-comment">// 适用场景：允许丢弃任务，且不需要知道任务被丢弃</span><br>    <span class="hljs-comment">// 警告：可能导致任务静默丢失，难以排查问题</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discardPolicyExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardPolicy()<br>        );<br>        <br>        <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">completedCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.execute(() -&gt; &#123;<br>                completedCount.incrementAndGet();<br>                System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + taskId + <span class="hljs-string">&quot;完成&quot;</span>);<br>            &#125;);<br>        &#125;<br>        <br>        executor.shutdown();<br>        <span class="hljs-keyword">try</span> &#123;<br>            executor.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 只有部分任务完成，其他被静默丢弃</span><br>        System.out.println(<span class="hljs-string">&quot;完成任务数: &quot;</span> + completedCount.get() + <span class="hljs-string">&quot;/10&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 4. DiscardOldestPolicy ====================</span><br>    <span class="hljs-comment">// 行为：丢弃队列中最老的任务，然后重新尝试提交当前任务</span><br>    <span class="hljs-comment">// 适用场景：新任务比旧任务更重要</span><br>    <span class="hljs-comment">// 警告：可能导致某些任务永远无法执行</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">discardOldestPolicyExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">2</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.DiscardOldestPolicy()<br>        );<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            executor.execute(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;执行任务&quot;</span> + taskId);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">500</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;);<br>            System.out.println(<span class="hljs-string">&quot;提交任务&quot;</span> + taskId);<br>        &#125;<br>        <br>        executor.shutdown();<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 5. 自定义拒绝策略 ====================</span><br>    <span class="hljs-comment">// 适用场景：需要自定义处理逻辑，如记录日志、持久化、降级等</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">customPolicyExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 自定义策略：记录日志 + 持久化到数据库</span><br>        <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">customHandler</span> <span class="hljs-operator">=</span> (runnable, executor) -&gt; &#123;<br>            <span class="hljs-comment">// 1. 记录日志</span><br>            System.err.println(<span class="hljs-string">&quot;任务被拒绝: &quot;</span> + runnable.toString());<br>            System.err.println(<span class="hljs-string">&quot;线程池状态 - 活跃线程: &quot;</span> + executor.getActiveCount() <br>                + <span class="hljs-string">&quot;, 队列大小: &quot;</span> + executor.getQueue().size());<br>            <br>            <span class="hljs-comment">// 2. 可以选择持久化到数据库或消息队列</span><br>            <span class="hljs-comment">// saveToDatabase(runnable);</span><br>            <span class="hljs-comment">// sendToMQ(runnable);</span><br>            <br>            <span class="hljs-comment">// 3. 可以选择在新线程中执行（注意：可能创建过多线程）</span><br>            <span class="hljs-comment">// new Thread(runnable).start();</span><br>            <br>            <span class="hljs-comment">// 4. 可以选择阻塞等待队列有空位</span><br>            <span class="hljs-comment">// try &#123;</span><br>            <span class="hljs-comment">//     executor.getQueue().put(runnable);</span><br>            <span class="hljs-comment">// &#125; catch (InterruptedException e) &#123;</span><br>            <span class="hljs-comment">//     Thread.currentThread().interrupt();</span><br>            <span class="hljs-comment">// &#125;</span><br>            <br>            <span class="hljs-comment">// 5. 也可以抛出自定义异常</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;自定义拒绝: 线程池已满&quot;</span>);<br>        &#125;;<br>        <br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>),<br>            customHandler<br>        );<br>        <br>        <span class="hljs-comment">// 使用自定义策略的线程池</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>                executor.execute(() -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;捕获到自定义拒绝异常: &quot;</span> + e.getMessage());<br>        &#125;<br>        <br>        executor.shutdown();<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 6. 生产环境推荐策略 ====================</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ThreadPoolExecutor <span class="hljs-title function_">createProductionExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 生产环境推荐：自定义策略 + 监控 + 降级</span><br>        <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">productionHandler</span> <span class="hljs-operator">=</span> (runnable, executor) -&gt; &#123;<br>            <span class="hljs-comment">// 1. 增加监控指标</span><br>            <span class="hljs-comment">// Metrics.counter(&quot;threadpool.rejected&quot;).increment();</span><br>            <br>            <span class="hljs-comment">// 2. 记录详细日志</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">taskInfo</span> <span class="hljs-operator">=</span> runnable.toString();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">queueSize</span> <span class="hljs-operator">=</span> executor.getQueue().size();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">activeCount</span> <span class="hljs-operator">=</span> executor.getActiveCount();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">poolSize</span> <span class="hljs-operator">=</span> executor.getPoolSize();<br>            <br>            System.err.printf(<span class="hljs-string">&quot;任务被拒绝 [task=%s, queue=%d, active=%d, pool=%d]%n&quot;</span>,<br>                taskInfo, queueSize, activeCount, poolSize);<br>            <br>            <span class="hljs-comment">// 3. 尝试降级处理</span><br>            <span class="hljs-keyword">if</span> (!executor.isShutdown()) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 等待一小段时间后重试</span><br>                    <span class="hljs-type">boolean</span> <span class="hljs-variable">offered</span> <span class="hljs-operator">=</span> executor.getQueue().offer(runnable, <span class="hljs-number">100</span>, TimeUnit.MILLISECONDS);<br>                    <span class="hljs-keyword">if</span> (offered) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;重试入队成功&quot;</span>);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 4. 最终降级：由调用者执行</span><br>            <span class="hljs-keyword">if</span> (!executor.isShutdown()) &#123;<br>                runnable.run();<br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>            Runtime.getRuntime().availableProcessors(),<br>            Runtime.getRuntime().availableProcessors() * <span class="hljs-number">2</span>,<br>            <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>),<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>                .setNameFormat(<span class="hljs-string">&quot;production-pool-%d&quot;</span>)<br>                .setUncaughtExceptionHandler((t, e) -&gt; <br>                    System.err.println(<span class="hljs-string">&quot;线程异常: &quot;</span> + e.getMessage()))<br>                .build(),<br>            productionHandler<br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">// 简单的ThreadFactory构建器</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadFactoryBuilder</span> &#123;<br>        <span class="hljs-keyword">private</span> String nameFormat;<br>        <span class="hljs-keyword">private</span> Thread.UncaughtExceptionHandler handler;<br>        <br>        ThreadFactoryBuilder <span class="hljs-title function_">setNameFormat</span><span class="hljs-params">(String format)</span> &#123;<br>            <span class="hljs-built_in">this</span>.nameFormat = format;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <br>        ThreadFactoryBuilder <span class="hljs-title function_">setUncaughtExceptionHandler</span><span class="hljs-params">(Thread.UncaughtExceptionHandler h)</span> &#123;<br>            <span class="hljs-built_in">this</span>.handler = h;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>        &#125;<br>        <br>        ThreadFactory <span class="hljs-title function_">build</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> r -&gt; &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>                <span class="hljs-keyword">if</span> (nameFormat != <span class="hljs-literal">null</span>) &#123;<br>                    t.setName(String.format(nameFormat, count.getAndIncrement()));<br>                &#125;<br>                <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>                    t.setUncaughtExceptionHandler(handler);<br>                &#125;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>拒绝策略对比图：</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph 拒绝策略对比
        A[AbortPolicy] --&gt; A1[抛出异常]
        A1 --&gt; A2[调用方感知]
        A2 --&gt; A3[适合：需要明确处理拒绝的场景]
        
        B[CallerRunsPolicy] --&gt; B1[调用者执行]
        B1 --&gt; B2[提供反压]
        B2 --&gt; B3[适合：不能丢弃任务的场景]
        
        C[DiscardPolicy] --&gt; C1[静默丢弃]
        C1 --&gt; C2[无感知]
        C2 --&gt; C3[适合：允许丢弃且无需感知]
        
        D[DiscardOldestPolicy] --&gt; D1[丢弃最老任务]
        D1 --&gt; D2[新任务优先]
        D2 --&gt; D3[适合：新任务更重要的场景]
    end
    
    style A fill:#FF6B6B
    style B fill:#4ECDC4
    style C fill:#95A5A6
    style D fill:#F39C12</code></pre>
<h4 id="任务申请">任务申请</h4>
<blockquote>
<p>任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
</blockquote>
<p>任务的执行主要有 submit-&gt;execute，submit 的主要逻辑是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>execute 的主要逻辑是：</p>
<p><img src="Worker%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.png" alt="Worker执行任务.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法体现了线程池的任务调度策略的顶层设计：先 core 后 queue 后非 core 的设计思路。不过，这里面的 queue 的使用方案需要考虑线程池的状态。</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Executes the given task sometime in the future.  The task</span><br><span class="hljs-comment"> * may execute in a new thread or in an existing pooled thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If the task cannot be submitted for execution, either because this</span><br><span class="hljs-comment"> * executor has been shutdown or because its capacity has been reached,</span><br><span class="hljs-comment"> * the task is handled by the current &#123;<span class="hljs-doctag">@code</span> RejectedExecutionHandler&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> command the task to execute</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException at discretion of</span><br><span class="hljs-comment"> *         &#123;<span class="hljs-doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span><br><span class="hljs-comment"> *         cannot be accepted for execution</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if &#123;<span class="hljs-doctag">@code</span> command&#125; is null</span><br><span class="hljs-comment"> */</span><br>execute(Runnable command) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * execute 本身也是一个经典的四步分发，线程管理就靠这一步了</span><br><span class="hljs-comment">     * Proceed in 3 steps:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="hljs-comment">     * start a new thread with the given command as its first</span><br><span class="hljs-comment">     * task.  The call to addWorker atomically checks runState and</span><br><span class="hljs-comment">     * workerCount, and so prevents false alarms that would add</span><br><span class="hljs-comment">     * threads when it shouldn&#x27;t, by returning false.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. If a task can be successfully queued, then we still need</span><br><span class="hljs-comment">     * to double-check whether we should have added a thread</span><br><span class="hljs-comment">     * (because existing ones died since last checking) or that</span><br><span class="hljs-comment">     * the pool shut down since entry into this method. So we</span><br><span class="hljs-comment">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="hljs-comment">     * stopped, or start a new thread if there are none.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="hljs-comment">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="hljs-comment">     * and so reject the task.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这需要用到<a href="#%E5%B0%9D%E8%AF%95%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B">尝试增加线程</a></p>
<h2 id="线程池如何管理线程">线程池如何管理线程</h2>
<p>核心线程的 idle 不影响核心线程的创建；非核心线程的 idle time 会导致它们退出。</p>
<h3 id="尝试增加线程">尝试增加线程</h3>
<p>注意 addWorker 只是 execute 的一个子分支而已。</p>
<p><img src="%E7%94%B3%E8%AF%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="申请线程执行流程图.png"></p>
<p>Worker 可以被认为是线程和锁的结合体，它的使命就是不断地把 runnable 从缓冲队列里拿出来，放在自己的 thread 里执行，其中关键的方法是 addWorker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Checks if a new worker can be added with respect to current</span><br><span class="hljs-comment"> * pool state and the given bound (either core or maximum). If so,</span><br><span class="hljs-comment"> * the worker count is adjusted accordingly, and, if possible, a</span><br><span class="hljs-comment"> * new worker is created and started, running firstTask as its</span><br><span class="hljs-comment"> * first task. This method returns false if the pool is stopped or</span><br><span class="hljs-comment"> * eligible to shut down. It also returns false if the thread</span><br><span class="hljs-comment"> * factory fails to create a thread when asked.  If the thread</span><br><span class="hljs-comment"> * creation fails, either due to the thread factory returning</span><br><span class="hljs-comment"> * null, or due to an exception (typically OutOfMemoryError in</span><br><span class="hljs-comment"> * Thread.start()), we roll back cleanly.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> firstTask the task the new thread should run first (or</span><br><span class="hljs-comment"> * null if none). Workers are created with an initial first task</span><br><span class="hljs-comment"> * (in method execute()) to bypass queuing when there are fewer</span><br><span class="hljs-comment"> * than corePoolSize threads (in which case we always start one),</span><br><span class="hljs-comment"> * or when the queue is full (in which case we must bypass queue).</span><br><span class="hljs-comment"> * Initially idle threads are usually created via</span><br><span class="hljs-comment"> * prestartCoreThread or to replace other dying workers.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> core if true use corePoolSize as bound, else</span><br><span class="hljs-comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span><br><span class="hljs-comment"> * value to ensure reads of fresh values after checking other pool</span><br><span class="hljs-comment"> * state).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true if successful</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    <span class="hljs-comment">// retry 是外部自旋的标签。大自旋保证 rs 是稳定的，小自旋保证 wc 是稳定的，在双自旋里面保证 wc 的修改成功</span><br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 获取运行时状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>        <br>        <span class="hljs-comment">// 如果线程池关闭了，或者不是worker 的 firstTask 为空，但 workQueue 不空</span><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 内层自旋</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">// 其实 worker 里并没有 core 与否的属性，core 主要看比对哪个 PoolSize</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 如果这次一个原子性地增加 WorkerCount 成功，则退出大自旋；否则还是在大自旋里做 cas 增加 workerCount</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">// 否则失败有两种可能：rc 变了，或者 wc 变了。看看当前 runState 是否还是大自旋的 runState</span><br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-comment">// 如果不是则返回大自旋</span><br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// 如果是则 runState 不变，只是 wc 变了，在小自旋里重新获取 wc 即可</span><br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 在上层的 ctl 的修改是通过自旋来做的，不加锁，但下层就必须加锁了。这个设计实际上让 ctl 的修改和 worker 的修改解耦，实现了某种“最终一致”</span><br>    <br>    <span class="hljs-comment">// worker 的创建和添加是两个状态</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 外部传进来的 firstTask 可能为空，这里照样传进去</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-comment">// 在 Worker 构造器的内部携带的线程工厂创建的 thread 也可能为空</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 凡是修改线程池的 bookkeeping 操作，包含状态之外（比如 worker）的成员复杂流程修改的时候，都需要加锁</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-comment">// Tests if this thread is alive. A thread is alive if it has been started and has not yet died.</span><br>                    <span class="hljs-comment">// 这个方法本身是为了启动新线程，如果线程工厂不是启动新线程而是像线程池一样复用线程的话，线程就是 alive 的了（注意这个状态和线程的 status 还不一样），这时候线程池 addWorker 会失败</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable                   </span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-comment">// 更新簿记值</span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">// 此时才开始线程</span><br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rolls back the worker thread creation.</span><br><span class="hljs-comment"> * - removes worker from workers, if present</span><br><span class="hljs-comment"> * - decrements worker count</span><br><span class="hljs-comment"> * - rechecks for termination, in case the existence of this</span><br><span class="hljs-comment"> *   worker was holding up termination</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)<br>            workers.remove(w);<br>        decrementWorkerCount();<br>        <span class="hljs-comment">// 增加线程失败，会导致线程池终结</span><br>        tryTerminate();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Decrements the workerCount field of ctl. This is called only on</span><br><span class="hljs-comment"> * abrupt termination of a thread (see processWorkerExit). Other</span><br><span class="hljs-comment"> * decrements are performed within getTask.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrementWorkerCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 减 worker count 的操作必须自旋到成功，这种小成员的自旋修改不需要 sleep！</span><br>    <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndIncrementWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect)</span> &#123;<br>    <span class="hljs-comment">// 因为 wc 在 32 位整数的低位，所以直接对 expect + 1 即可。</span><br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="线程执行">线程执行</h3>
<p><img src="%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png" alt="执行任务流程.png"></p>
<p>线程的执行强依赖于 worker 本身的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// worker 本身并不严重依赖自己的状态，所以不像线程池一样拥有一个 runState，但它持有一个 state，能够表达自身的锁状态。所以它自身拥有 -1、0、1 三种状态</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Class Worker mainly maintains interrupt control state for</span><br><span class="hljs-comment"> * threads running tasks, along with other minor bookkeeping.</span><br><span class="hljs-comment"> * This class opportunistically extends AbstractQueuedSynchronizer</span><br><span class="hljs-comment"> * to simplify acquiring and releasing a lock surrounding each</span><br><span class="hljs-comment"> * task execution.  This protects against interrupts that are</span><br><span class="hljs-comment"> * intended to wake up a worker thread waiting for a task from</span><br><span class="hljs-comment"> * instead interrupting a task being run.  We implement a simple</span><br><span class="hljs-comment"> * non-reentrant mutual exclusion lock rather than use</span><br><span class="hljs-comment"> * ReentrantLock because we do not want worker tasks to be able to</span><br><span class="hljs-comment"> * reacquire the lock when they invoke pool control methods like</span><br><span class="hljs-comment"> * setCorePoolSize.  Additionally, to suppress interrupts until</span><br><span class="hljs-comment"> * the thread actually starts running tasks, we initialize lock</span><br><span class="hljs-comment"> * state to a negative value, and clear it upon start (in</span><br><span class="hljs-comment"> * runWorker).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><br>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This class will never be serialized, but we provide a</span><br><span class="hljs-comment">     * serialVersionUID to suppress a javac warning.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6138294804551838833L</span>;<br><br>    <span class="hljs-comment">/** Thread this worker is running in.  Null if factory fails. */</span><br>    <span class="hljs-keyword">final</span> Thread thread;<br>    <span class="hljs-comment">/** Initial task to run.  Possibly null. */</span><br>    Runnable firstTask;<br>    <span class="hljs-comment">/** Per-thread task counter */</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates with given first task and thread from ThreadFactory.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> firstTask the first task (null if none)</span><br><span class="hljs-comment">     */</span><br>    Worker(Runnable firstTask) &#123;<br>        <span class="hljs-comment">// inhibit == prohibit，就是禁止中断的意思，中断前也要求锁</span><br>        setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>        <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>        <span class="hljs-comment">// 这个方法是调用的线程池的 factory，</span><br>        <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/** Delegates main run loop to outer runWorker  */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这个方法是线程池里的方法，这样交互委托可以实现上下文的 merge，以当前的线程去读外部的上下文</span><br>        runWorker(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Lock methods</span><br>    <span class="hljs-comment">// 0 代表常态无锁</span><br>    <span class="hljs-comment">// 1 代表常态加锁</span><br>    <span class="hljs-comment">// The value 0 represents the unlocked state.</span><br>    <span class="hljs-comment">// The value 1 represents the locked state.</span><br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 启动的时候使用的-1 是一种“启动时才能使用的锁”，这里也包含进来了</span><br>        <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// aqs 最关键的加锁方法，锁的标记位可以自定义</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        <span class="hljs-comment">// 这里体现了经典的设计模式，先 cas 把标记位加上去，然后绑定线程。这里要求线程安全的写只有锁的 cas，线程的归属却不是线程安全的</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        <span class="hljs-comment">// 恰好和上一个方法反过来</span><br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 强制解锁，无 cas</span><br>        setState(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>        &#123; acquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>      &#123; release(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-comment">// 锁只支持互斥锁定模式，不支持共享锁定模式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br>    <br>    <span class="hljs-comment">// 提供一种中断 worker（包括内部线程）的工作模式</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;<br>        Thread t;<br>        <span class="hljs-comment">// -1 和 1 不允许中断</span><br>        <span class="hljs-comment">// 在一个括号里实现了漂亮的取数操作</span><br>        <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp;<br>        <span class="hljs-comment">// 线程没有被中断的时候可以被中断</span><br>        !t.isInterrupted()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.interrupt();<br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Worker 生命周期状态图：</strong></p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; Created: new Worker(firstTask)
    
    Created --&gt; Initialized: setState(-1)&lt;br/&gt;禁止中断
    Initialized --&gt; Started: thread.start()
    
    Started --&gt; Running: runWorker(this)
    Running --&gt; Unlocked: w.unlock()&lt;br/&gt;允许中断
    
    state Running &#123;
        Unlocked --&gt; WaitingTask: getTask()
        WaitingTask --&gt; GotTask: task != null
        WaitingTask --&gt; NoTask: task == null
        
        GotTask --&gt; Locked: w.lock()
        Locked --&gt; Executing: task.run()
        Executing --&gt; Unlocked: w.unlock()
    &#125;
    
    NoTask --&gt; Exiting: processWorkerExit()
    Exiting --&gt; [*]: 线程终止
    
    note right of Created
        Worker 构造时：
        1. setState(-1) 禁止中断
        2. 保存 firstTask
        3. 通过 ThreadFactory 创建线程
    end note
    
    note right of WaitingTask
        getTask() 返回 null 的情况：
        1. 线程数 &gt; maximumPoolSize
        2. 线程池 STOP 状态
        3. 线程池 SHUTDOWN 且队列空
        4. 等待超时
    end note</code></pre>
<p><strong>Worker 锁状态转换图：</strong></p>
<pre><code class="hljs mermaid">graph TD
    subgraph Worker锁状态
        A[state = -1&lt;br/&gt;初始化状态] --&gt;|w.unlock| B[state = 0&lt;br/&gt;空闲状态]
        B --&gt;|w.lock| C[state = 1&lt;br/&gt;执行任务中]
        C --&gt;|w.unlock| B
    end
    
    subgraph 锁状态含义
        D[-1: 禁止中断&lt;br/&gt;Worker刚创建] 
        E[0: 允许中断&lt;br/&gt;Worker空闲等待任务]
        F[1: 正在执行任务&lt;br/&gt;不应被中断]
    end
    
    subgraph 中断规则
        G[interruptIfStarted] --&gt; H&#123;getState &gt;= 0?&#125;
        H --&gt;|是| I[可以中断]
        H --&gt;|否| J[不能中断]
    end
    
    style A fill:#FFB6C1
    style B fill:#90EE90
    style C fill:#87CEEB</code></pre>
<p><strong>runWorker 执行流程详解：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant TPE as ThreadPoolExecutor
    participant W as Worker
    participant T as Thread
    participant Q as BlockingQueue
    
    Note over W: 构造函数: setState(-1)
    TPE-&gt;&gt;W: addWorker(task, core)
    TPE-&gt;&gt;T: thread.start()
    T-&gt;&gt;W: run()
    W-&gt;&gt;TPE: runWorker(this)
    
    TPE-&gt;&gt;W: w.unlock() // setState(0)
    Note over W: 现在允许中断
    
    loop 任务循环
        alt 有 firstTask
            TPE-&gt;&gt;TPE: task = firstTask
        else 无 firstTask
            TPE-&gt;&gt;Q: getTask()
            Q--&gt;&gt;TPE: task 或 null
        end
        
        alt task != null
            TPE-&gt;&gt;W: w.lock() // setState(1)
            Note over W: 执行期间不应中断
            
            TPE-&gt;&gt;TPE: beforeExecute(thread, task)
            TPE-&gt;&gt;T: task.run()
            TPE-&gt;&gt;TPE: afterExecute(task, thrown)
            
            TPE-&gt;&gt;W: w.unlock() // setState(0)
            TPE-&gt;&gt;W: completedTasks++
        else task == null
            Note over TPE: 退出循环
        end
    end
    
    TPE-&gt;&gt;TPE: processWorkerExit(w, completedAbruptly)
    Note over W: Worker 生命周期结束</code></pre>
<p>在一个工作线程里，worker delegate 调用给线程池的 runWorker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Main worker run loop.  Repeatedly gets tasks from queue and</span><br><span class="hljs-comment">     * executes them, while coping with a number of issues:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 1. We may start out with an initial task, in which case we</span><br><span class="hljs-comment">     * don&#x27;t need to get the first one. Otherwise, as long as pool is</span><br><span class="hljs-comment">     * running, we get tasks from getTask. If it returns null then the</span><br><span class="hljs-comment">     * worker exits due to changed pool state or configuration</span><br><span class="hljs-comment">     * parameters.  Other exits result from exception throws in</span><br><span class="hljs-comment">     * external code, in which case completedAbruptly holds, which</span><br><span class="hljs-comment">     * usually leads processWorkerExit to replace this thread.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. Before running any task, the lock is acquired to prevent</span><br><span class="hljs-comment">     * other pool interrupts while the task is executing, and then we</span><br><span class="hljs-comment">     * ensure that unless pool is stopping, this thread does not have</span><br><span class="hljs-comment">     * its interrupt set.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. Each task run is preceded by a call to beforeExecute, which</span><br><span class="hljs-comment">     * might throw an exception, in which case we cause thread to die</span><br><span class="hljs-comment">     * (breaking loop with completedAbruptly true) without processing</span><br><span class="hljs-comment">     * the task.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 4. Assuming beforeExecute completes normally, we run the task,</span><br><span class="hljs-comment">     * gathering any of its thrown exceptions to send to afterExecute.</span><br><span class="hljs-comment">     * We separately handle RuntimeException, Error (both of which the</span><br><span class="hljs-comment">     * specs guarantee that we trap) and arbitrary Throwables.</span><br><span class="hljs-comment">     * Because we cannot rethrow Throwables within Runnable.run, we</span><br><span class="hljs-comment">     * wrap them within Errors on the way out (to the thread&#x27;s</span><br><span class="hljs-comment">     * UncaughtExceptionHandler).  Any thrown exception also</span><br><span class="hljs-comment">     * conservatively causes thread to die.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 5. After task.run completes, we call afterExecute, which may</span><br><span class="hljs-comment">     * also throw an exception, which will also cause thread to</span><br><span class="hljs-comment">     * die. According to JLS Sec 14.20, this exception is the one that</span><br><span class="hljs-comment">     * will be in effect even if task.run throws.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The net effect of the exception mechanics is that afterExecute</span><br><span class="hljs-comment">     * and the thread&#x27;s UncaughtExceptionHandler have as accurate</span><br><span class="hljs-comment">     * information as we can provide about any problems encountered by</span><br><span class="hljs-comment">     * user code.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>        <span class="hljs-comment">// 这里为什么不使用 worker 里面的线程呢？</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-comment">// 做一个置换/置空操作</span><br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>        w.firstTask = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 在对象初始化的时候触发了加锁，在线程启动的时候触发了解锁。线程池的 shutdown 方法本身会 interrupt worker，这里不允许在锁周期里面 interrupt worker</span><br>        w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>        <span class="hljs-comment">// 突然完成默认为真</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// getTask 里封装了复杂的取任务流程，这里在一个表达式里面实现了漂亮的取任务操作</span><br>            <span class="hljs-comment">// 本线程只有在 getTask 取不到的时候才退出</span><br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// 只在 run 一个 task 的时候锁定自己一次，不可重入</span><br>                w.lock();<br>                <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>                <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>                <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>                <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>                <span class="hljs-comment">// 如果线程池本身已经进入停止及以后状态，则直接求 工作线程的中断状态。否则，做一轮线程的中断，再求线程池状态（中断居然会影响线程池的状态，很奇怪？），再求工作线程的中断状态。这里有一个比较炫技的地方，wt 和 currentThread 都是当前线程，但偏偏不使用 wt 里的线程        </span><br>                <span class="hljs-comment">// 这里的思想是：不能由命令触发中断，必须由状态触发中断</span><br>                <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                    <span class="hljs-comment">// 或者</span><br>                     (Thread.interrupted() &amp;&amp;<br>                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                    !wt.isInterrupted())<br>                    <span class="hljs-comment">// 遇到这些情况，就要中断 wt，在这里。所以内部线程是由 getTask 内部的流程中断的，然后才去执行下面的 run，看看下面的 run 会不会响应</span><br>                    wt.interrupt();<br>                <span class="hljs-comment">// 线程的中断也不会影响接下来的 task.run()</span><br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 通常这个方法是空方法</span><br>                    beforeExecute(wt, task);<br>                    <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// runnable.run()</span><br>                        task.run();<br>                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                        <span class="hljs-comment">// 有这样的写法就意味着要在 finally 留存 thrown</span><br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-comment">// thrown 是给 afterExecute 准备的</span><br>                        afterExecute(task, thrown);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-literal">null</span>;<br>                    w.completedTasks++;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 只有在 getTask 取不到的时候退出，这个值才是false，其他时候都算是“突然退出”</span><br>            completedAbruptly = <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            processWorkerExit(w, completedAbruptly);<br>        &#125;<br>    &#125;<br>    <br>### 生命周期钩子方法：beforeExecute / afterExecute / terminated<br><br>ThreadPoolExecutor 提供了三个 <span class="hljs-keyword">protected</span> 钩子方法，允许子类在任务执行的关键节点插入自定义逻辑。这是**模板方法模式**的经典应用。<br><br>#### 钩子方法定义与调用时机<br><br>```java<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任务执行前调用</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> t 执行任务的线程</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> r 将要执行的任务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123; &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任务执行后调用（无论是否抛出异常）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> r 已执行的任务</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> t 任务执行过程中抛出的异常，如果正常完成则为 null</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123; &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程池终止后调用（所有任务完成且所有 Worker 线程已退出）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">terminated</span><span class="hljs-params">()</span> &#123; &#125;<br></code></pre></td></tr></table></figure>
<p><strong>调用时机与执行保证：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant TPE as ThreadPoolExecutor
    participant W as Worker
    participant T as Thread
    participant Task as Runnable
    
    TPE-&gt;&gt;W: runWorker(this)
    loop 任务循环
        TPE-&gt;&gt;TPE: getTask()
        TPE-&gt;&gt;W: w.lock()
        
        Note over TPE: === 钩子调用开始 ===
        TPE-&gt;&gt;TPE: beforeExecute(thread, task)
        Note right of TPE: 默认空实现&lt;br/&gt;可抛出异常终止任务
        
        alt beforeExecute 正常完成
            TPE-&gt;&gt;Task: task.run()
            Task--&gt;&gt;TPE: 正常返回或抛出异常
            TPE-&gt;&gt;TPE: afterExecute(task, thrown)
            Note right of TPE: thrown = 捕获的异常&lt;br/&gt;正常完成时为 null
        else beforeExecute 抛出异常
            Note over TPE: 任务不会执行
            TPE-&gt;&gt;TPE: afterExecute(task, thrown)
            Note right of TPE: thrown = beforeExecute 的异常
        end
        
        TPE-&gt;&gt;W: w.unlock()
        TPE-&gt;&gt;W: completedTasks++
    end
    
    TPE-&gt;&gt;TPE: processWorkerExit()
    
    alt 线程池进入 TIDYING 状态
        TPE-&gt;&gt;TPE: terminated()
        Note right of TPE: 仅调用一次&lt;br/&gt;所有 Worker 已退出
    end</code></pre>
<h4 id="典型应用场景">典型应用场景</h4>
<p><strong>1. 任务执行时间监控与统计</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitoredThreadPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;Runnable, Long&gt; taskStartTimes = <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">totalExecutionTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">taskCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MonitoredThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                               <span class="hljs-type">long</span> keepAliveTime, TimeUnit unit,</span><br><span class="hljs-params">                               BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>        <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>        <span class="hljs-built_in">super</span>.beforeExecute(t, r);<br>        <span class="hljs-comment">// 记录任务开始时间</span><br>        taskStartTimes.put(r, System.nanoTime());<br>        <br>        <span class="hljs-comment">// 可添加：线程上下文初始化</span><br>        MDC.put(<span class="hljs-string">&quot;taskStartTime&quot;</span>, String.valueOf(System.currentTimeMillis()));<br>        MDC.put(<span class="hljs-string">&quot;workerThread&quot;</span>, t.getName());<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 计算执行时间</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> taskStartTimes.remove(r);<br>            <span class="hljs-keyword">if</span> (startTime != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">executionTime</span> <span class="hljs-operator">=</span> System.nanoTime() - startTime;<br>                totalExecutionTime.addAndGet(executionTime);<br>                <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> taskCount.incrementAndGet();<br>                <br>                <span class="hljs-comment">// 记录慢任务</span><br>                <span class="hljs-keyword">if</span> (executionTime &gt; TimeUnit.MILLISECONDS.toNanos(<span class="hljs-number">100</span>)) &#123;<br>                    logger.warn(<span class="hljs-string">&quot;Slow task detected: &#123;&#125;ms, avg: &#123;&#125;ms&quot;</span>, <br>                        TimeUnit.NANOSECONDS.toMillis(executionTime),<br>                        TimeUnit.NANOSECONDS.toMillis(totalExecutionTime.get() / count));<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 异常处理</span><br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                logger.error(<span class="hljs-string">&quot;Task execution failed&quot;</span>, t);<br>                <span class="hljs-comment">// 可添加：失败计数、告警通知</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 必须调用父类方法（虽然父类是空实现，但保持好习惯）</span><br>            <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>            <span class="hljs-comment">// 清理线程上下文</span><br>            MDC.clear();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">terminated</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程池关闭后的清理工作</span><br>        logger.info(<span class="hljs-string">&quot;ThreadPool terminated. Total tasks: &#123;&#125;, avg execution time: &#123;&#125;ms&quot;</span>,<br>            taskCount.get(),<br>            TimeUnit.NANOSECONDS.toMillis(totalExecutionTime.get() / Math.max(<span class="hljs-number">1</span>, taskCount.get())));<br>        <br>        <span class="hljs-comment">// 可添加：资源释放、指标上报</span><br>        <span class="hljs-built_in">super</span>.terminated();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>2. 线程上下文传递（如 TraceId）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContextAwareThreadPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ContextAwareThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                                  <span class="hljs-type">long</span> keepAliveTime, TimeUnit unit,</span><br><span class="hljs-params">                                  BlockingQueue&lt;Runnable&gt; workQueue)</span> &#123;<br>        <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>        <span class="hljs-comment">// 从任务中恢复上下文</span><br>        <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> ContextAwareTask) &#123;<br>            <span class="hljs-type">ContextAwareTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> (ContextAwareTask) r;<br>            TraceContext.setTraceId(task.getTraceId());<br>            TraceContext.setSpanId(task.getSpanId());<br>        &#125;<br>        <span class="hljs-built_in">super</span>.beforeExecute(t, r);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 清理上下文，防止线程复用时污染</span><br>            TraceContext.clear();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 包装任务以携带上下文</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ContextAwareTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable task;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String traceId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String spanId;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ContextAwareTask</span><span class="hljs-params">(Runnable task)</span> &#123;<br>        <span class="hljs-built_in">this</span>.task = task;<br>        <span class="hljs-built_in">this</span>.traceId = TraceContext.getTraceId();<br>        <span class="hljs-built_in">this</span>.spanId = TraceContext.generateSpanId();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        task.run();<br>    &#125;<br>    <br>    <span class="hljs-comment">// getters...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>3. 任务优先级动态调整</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PriorityThreadPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> PriorityBlockingQueue&lt;Runnable&gt; priorityQueue;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">PriorityThreadPool</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize)</span> &#123;<br>        <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>              <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityBlockingQueue</span>&lt;&gt;(<span class="hljs-number">11</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskComparator</span>()));<br>        <span class="hljs-built_in">this</span>.priorityQueue = (PriorityBlockingQueue&lt;Runnable&gt;) getQueue();<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>        <span class="hljs-built_in">super</span>.beforeExecute(t, r);<br>        <span class="hljs-comment">// 记录实际开始执行时间，用于计算等待时间</span><br>        <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> PrioritizedTask) &#123;<br>            ((PrioritizedTask) r).setActualStartTime(System.nanoTime());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (r <span class="hljs-keyword">instanceof</span> PrioritizedTask) &#123;<br>                <span class="hljs-type">PrioritizedTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> (PrioritizedTask) r;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">waitTime</span> <span class="hljs-operator">=</span> task.getActualStartTime() - task.getSubmitTime();<br>                <span class="hljs-type">long</span> <span class="hljs-variable">executionTime</span> <span class="hljs-operator">=</span> System.nanoTime() - task.getActualStartTime();<br>                <br>                <span class="hljs-comment">// 根据等待时间和执行时间动态调整优先级策略</span><br>                <span class="hljs-keyword">if</span> (waitTime &gt; TimeUnit.SECONDS.toNanos(<span class="hljs-number">1</span>)) &#123;<br>                    logger.warn(<span class="hljs-string">&quot;High priority task waited too long: &#123;&#125;ms&quot;</span>, <br>                        TimeUnit.NANOSECONDS.toMillis(waitTime));<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;Runnable&gt; &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(Runnable r1, Runnable r2)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> (r1 <span class="hljs-keyword">instanceof</span> PrioritizedTask) ? <br>                ((PrioritizedTask) r1).getPriority() : <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> (r2 <span class="hljs-keyword">instanceof</span> PrioritizedTask) ? <br>                ((PrioritizedTask) r2).getPriority() : <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> Integer.compare(p2, p1); <span class="hljs-comment">// 高优先级在前</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="关键注意事项">关键注意事项</h4>
<p><strong>1. 异常处理原则</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>    <span class="hljs-comment">// ❌ 错误：直接吞掉异常</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 什么都不做</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// ✅ 正确：记录并处理异常</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>        logger.error(<span class="hljs-string">&quot;Task failed: &#123;&#125;&quot;</span>, r, t);<br>        <span class="hljs-comment">// 可添加：失败重试、死信队列、告警通知</span><br>    &#125;<br>    <br>    <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>2. 线程安全考虑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>    <span class="hljs-comment">// 钩子方法在 Worker 线程中同步执行</span><br>    <span class="hljs-comment">// 应避免耗时操作，否则会阻塞任务执行</span><br>    <br>    <span class="hljs-comment">// ❌ 错误：同步调用外部服务</span><br>    <span class="hljs-comment">// externalService.syncCall(); // 阻塞！</span><br>    <br>    <span class="hljs-comment">// ✅ 正确：轻量级操作，异步发送指标</span><br>    metricsRecorder.recordTaskStart(r);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>3. 与 shutdown 的协作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">terminated</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 线程池已完全终止，所有 Worker 线程已退出</span><br>    <span class="hljs-comment">// 此时可以安全地释放资源</span><br>    <br>    <span class="hljs-comment">// 上报最终统计指标</span><br>    metricsReporter.reportFinalStats();<br>    <br>    <span class="hljs-comment">// 关闭关联的资源</span><br>    resourceManager.close();<br>    <br>    <span class="hljs-built_in">super</span>.terminated();<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>threadPool.shutdown();<br><span class="hljs-keyword">if</span> (threadPool.awaitTermination(<span class="hljs-number">60</span>, TimeUnit.SECONDS)) &#123;<br>    <span class="hljs-comment">// terminated() 已被调用，资源已清理</span><br>    System.out.println(<span class="hljs-string">&quot;Graceful shutdown completed&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="钩子方法与状态机的关系">钩子方法与状态机的关系</h4>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; RUNNING: 创建线程池
    
    RUNNING --&gt; SHUTDOWN: shutdown()
    RUNNING --&gt; STOP: shutdownNow()
    
    SHUTDOWN --&gt; TIDYING: 队列为空且所有任务完成
    STOP --&gt; TIDYING: 所有任务完成
    
    TIDYING --&gt; TERMINATED: terminated() 执行完成
    
    note right of RUNNING
        beforeExecute / afterExecute
        在每个任务执行前后调用
    end note
    
    note right of TIDYING
        terminated() 调用点：
        1. 所有 Worker 已退出
        2. 队列已空
        3. 仅调用一次
    end note</code></pre>
<p><strong>核心要点：</strong></p>
<ul>
<li>
<p><code>beforeExecute</code> / <code>afterExecute</code>：每个任务执行前后调用，用于任务级监控和上下文管理</p>
</li>
<li>
<p><code>terminated</code>：线程池完全终止后调用一次，用于资源清理和最终统计</p>
</li>
<li>
<p>所有钩子都在同步上下文中执行，应避免耗时操作</p>
</li>
<li>
<p>异常处理要完善，避免影响线程池正常运行</p>
<p>// 阻塞式获取任务。<br>
// 遇到异常情况给上游的返回值是 null：<br>
// 1. 有超过maximumPoolSize 的线程数，这时候返回 null 会导致它退出。<br>
// 2. 线程池 stopped 了（由 shutdownNow 来触发，比 shutdown 更严厉），这时候线程池也会用 null 的方式指示线程有序退出<br>
// 3. 线程池 shutdown，且队列为空（其实光是本条件就可以返回 null，只是如果线程池还在工作中，队列应该让 getTask 的线程阻塞等待）<br>
// 4. 线程超时。真正的超时实际上有两种：线程数超过 core 且超时，连 core 都允许超时且超时<br>
/**</p>
<ul>
<li>Performs blocking or timed wait for a task, depending on</li>
<li>current configuration settings, or returns null if this worker</li>
<li>must exit because of any of:</li>
<li>
<ol>
<li>There are more than maximumPoolSize workers (due to</li>
</ol>
</li>
<li>a call to setMaximumPoolSize).</li>
<li>
<ol start="2">
<li>The pool is stopped.</li>
</ol>
</li>
<li>
<ol start="3">
<li>The pool is shutdown and the queue is empty.</li>
</ol>
</li>
<li>
<ol start="4">
<li>This worker timed out waiting for a task, and timed-out</li>
</ol>
</li>
<li>workers are subject to termination (that is,</li>
<li>{@code allowCoreThreadTimeOut || workerCount &gt; corePoolSize})</li>
<li>both before and after the timed wait, and if the queue is</li>
<li>non-empty, this worker is not the last thread in the pool.</li>
<li></li>
<li>@return task, or null if the worker must exit, in which case</li>
<li>
<pre><code>    workerCount is decremented
</code></pre>
</li>
</ul>
<p>*/<br>
private Runnable getTask() {<br>
boolean timedOut = false; // Did the last poll() time out?<br>
// 在自旋里面<br>
for (;;) {<br>
int c = ctl.get();<br>
int rs = runStateOf©;</p>
<pre><code>      // 第一类情况返回 null
      // Check if queue empty only if necessary.
      if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) {
          decrementWorkerCount();
          return null;
      }

      int wc = workerCountOf(c);

      // Are workers subject to culling? 是否要强制减少线程数？是的话就要引入计时了
      boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;
      // 超时返回 null 的场景，但注意这里要能减掉一个线程才能返回 null。
      if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))
          &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) {
          // 减线程数目（不一定成功，如 wc == 0 也可能进入这个语句块）
          if (compareAndDecrementWorkerCount(c))
              return null;
          // 不能减线程则 cas 失败，进入大循环里继续
          continue;
      }

      try {
          Runnable r = timed ?
              workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :
              workQueue.take();
          if (r != null)
              return r;
          timedOut = true;
      } catch (InterruptedException retry) {
          timedOut = false;
      }
  }
</code></pre>
<p>}</p>
</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><br>### 回收线程<br><br>&gt; Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反映线程现在的执行状态。<br>&gt;  <br>&gt; <span class="hljs-number">1</span>.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。<br>&gt; <span class="hljs-number">2</span>.如果正在执行任务，则不应该中断线程。 <span class="hljs-number">3</span>.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 <span class="hljs-number">4</span>.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。<br><br>![线程池回收线程的过程.png](线程池回收线程的过程.png)<br>![线程销毁流程.png](线程销毁流程.png)<br><br>```java<br>    <span class="hljs-comment">// 处理一些关闭和簿记工作：</span><br>    <span class="hljs-comment">// 1. 只能被从 worker 线程里调用，也就是说只能在 runWorker 方法里被调用</span><br>    <span class="hljs-comment">// 2. 先尝试把 workerCount 减一</span><br>    <span class="hljs-comment">// 3. 把 worker 从工作集里移除</span><br>    <span class="hljs-comment">// 4. 尝试终结线程池</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Performs cleanup and bookkeeping for a dying worker. Called</span><br><span class="hljs-comment">     * only from worker threads. Unless completedAbruptly is set,</span><br><span class="hljs-comment">     * assumes that workerCount has already been adjusted to account</span><br><span class="hljs-comment">     * for exit.  This method removes thread from worker set, and</span><br><span class="hljs-comment">     * possibly terminates the pool or replaces the worker if either</span><br><span class="hljs-comment">     * it exited due to user task exception or if fewer than</span><br><span class="hljs-comment">     * corePoolSize workers are running or queue is non-empty but</span><br><span class="hljs-comment">     * there are no workers.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param w the worker</span><br><span class="hljs-comment">     * @param completedAbruptly if the worker died due to user exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> processWorkerExit(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly) &#123;<br>        <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>            <span class="hljs-comment">// 只要能够成功减一就行了</span><br>            decrementWorkerCount();<br>        <br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 不管怎样退出，都把 worker 的完成任务数加总到线程池的总数里</span><br>            completedTaskCount += w.completedTasks;<br>            <span class="hljs-comment">// 移除本 worker</span><br>            workers.remove(w);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// 每个 worker 终结都尝试终结线程池</span><br>        tryTerminate(); <br><br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">// 如果线程池没有真的被真的关闭，可以加减线程池里的线程</span><br>        <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>            <span class="hljs-comment">// 如果线程池正常关闭</span><br>            <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>                <span class="hljs-comment">// allowCoreThreadTimeOut 通常为 false，所以线程池的最小值应该是 corePoolSize，否则核心线程数可以归零</span><br>                <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>                <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                    <span class="hljs-comment">// 如果缓冲队列不空，则最小线程数需要维持在 1</span><br>                    min = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                    <span class="hljs-comment">// 如果当前工作线程数大于等于 min，则直接退出</span><br>                    <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>            &#125;<br>            <span class="hljs-comment">// 反之则认为工作线程数小于 min，需要增加非核心线程（增加非核心线程实际上也是在增加核心线程），这里的设计思想是任何一个线程退出都应该增加一个线程，所以就当作非核心线程增加了</span><br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 这个方法在线程退出时只关闭一个【空闲线程】，但在线程池关闭等场景下，会关闭所有的空闲线程，这样线程池最终就关闭了-因为每个worker 退出的时候最少都会关闭一个空闲线程，全局的线程最终得以全部关闭。但线程池的核心参数如 keepAliveTime、corePoolSize、maximumPoolSize 有变化的时候，都会触发全部空闲线程关闭</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Interrupts threads that might be waiting for tasks (as</span><br><span class="hljs-comment">     * indicated by not being locked) so they can check for</span><br><span class="hljs-comment">     * termination or configuration changes. Ignores</span><br><span class="hljs-comment">     * SecurityExceptions (in which case some threads may remain</span><br><span class="hljs-comment">     * uninterrupted).</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param onlyOne If true, interrupt at most one worker. This is</span><br><span class="hljs-comment">     * called only from tryTerminate when termination is otherwise</span><br><span class="hljs-comment">     * enabled but there are still other workers.  In this case, at</span><br><span class="hljs-comment">     * most one waiting worker is interrupted to propagate shutdown</span><br><span class="hljs-comment">     * signals in case all threads are currently waiting.</span><br><span class="hljs-comment">     * Interrupting any arbitrary thread ensures that newly arriving</span><br><span class="hljs-comment">     * workers since shutdown began will also eventually exit.</span><br><span class="hljs-comment">     * To guarantee eventual termination, it suffices to always</span><br><span class="hljs-comment">     * interrupt only one idle worker, but shutdown() interrupts all</span><br><span class="hljs-comment">     * idle workers so that redundant workers exit promptly, not</span><br><span class="hljs-comment">     * waiting for a straggler task to finish.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> interruptIdleWorkers(<span class="hljs-keyword">boolean</span> onlyOne) &#123;<br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>                Thread t = w.thread;<br>                <span class="hljs-comment">// 能够被关闭的线程是一个能够拿到内部锁的线程</span><br>                <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 中断，这个线程内部的工作线程能不能响应看 runnable 内部的实现了</span><br>                        t.interrupt();<br>                    &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        w.unlock();<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (onlyOne)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h2 id="线程池使用中可能遇到的问题">线程池使用中可能遇到的问题</h2>
<h3 id="常见错误用法与正确实践">常见错误用法与正确实践</h3>
<p>根据Java并发编程最佳实践和生产环境常见问题，以下是典型的错误用法对比：</p>
<h4 id="错误用法1-使用无界队列导致oom">错误用法1: 使用无界队列导致OOM</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ❌ 错误用法：newFixedThreadPool使用无界队列</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">badExecutor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-comment">// 风险：</span><br><span class="hljs-comment">// 1. LinkedBlockingQueue默认容量Integer.MAX_VALUE</span><br><span class="hljs-comment">// 2. 任务积压会导致堆内存耗尽</span><br><span class="hljs-comment">// 3. 无法快速失败，问题发现延迟</span><br><br><span class="hljs-comment">// 提交大量慢任务</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>    badExecutor.submit(() -&gt; &#123;<br>        Thread.sleep(<span class="hljs-number">10000</span>);  <span class="hljs-comment">// 慢任务</span><br>    &#125;);<br>&#125;<br><span class="hljs-comment">// 结果：队列积压，最终OOM</span><br><br><span class="hljs-comment">// ✅ 正确用法：使用有界队列 + 拒绝策略</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">goodExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>,                             <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-number">20</span>,                             <span class="hljs-comment">// 最大线程数</span><br>    <span class="hljs-number">60L</span>, TimeUnit.SECONDS,          <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),  <span class="hljs-comment">// 有界队列</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;bounded-worker-&quot;</span> + threadNumber.getAndIncrement());<br>            t.setDaemon(<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="hljs-comment">// 降级策略：调用者线程执行</span><br>);<br></code></pre></td></tr></table></figure>
<h4 id="错误用法2-newcachedthreadpool导致线程爆炸">错误用法2: newCachedThreadPool导致线程爆炸</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ❌ 错误用法：newCachedThreadPool无限创建线程</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">badCached</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br><span class="hljs-comment">// 风险：</span><br><span class="hljs-comment">// 1. 最大线程数Integer.MAX_VALUE</span><br><span class="hljs-comment">// 2. 任务持续提交会无限创建线程</span><br><span class="hljs-comment">// 3. 最终触发&quot;unable to create new native thread&quot;</span><br><br><span class="hljs-comment">// 提交持续的慢任务</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>    badCached.submit(() -&gt; &#123;<br>        Thread.sleep(<span class="hljs-number">30000</span>);  <span class="hljs-comment">// 30秒慢任务</span><br>    &#125;);<br>&#125;<br><span class="hljs-comment">// 结果：创建数千线程，系统崩溃</span><br><br><span class="hljs-comment">// ✅ 正确用法：限制最大线程数</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">goodCached</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">0</span>,                              <span class="hljs-comment">// 核心线程数可以为0</span><br>    <span class="hljs-number">50</span>,                             <span class="hljs-comment">// 最大线程数有界</span><br>    <span class="hljs-number">60L</span>, TimeUnit.SECONDS,          <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;(),       <span class="hljs-comment">// 直接传递队列</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;bounded-cached-&quot;</span> + threadNumber.getAndIncrement());<br>            t.setDaemon(<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()  <span class="hljs-comment">// 拒绝新任务，快速失败</span><br>);<br></code></pre></td></tr></table></figure>
<h4 id="错误用法3-周期任务不捕获异常">错误用法3: 周期任务不捕获异常</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ❌ 错误用法：周期任务抛出异常导致静默停止</span><br><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">badScheduler</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br><br>badScheduler.scheduleAtFixedRate(() -&gt; &#123;<br>    <span class="hljs-comment">// 风险：任何未捕获异常都会导致后续调度停止</span><br>    riskyOperation();  <span class="hljs-comment">// 可能抛出RuntimeException</span><br>    System.out.println(<span class="hljs-string">&quot;This will stop after first exception&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// ✅ 正确用法：必须捕获所有异常</span><br><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">goodScheduler</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br><br>goodScheduler.scheduleAtFixedRate(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        riskyOperation();<br>        System.out.println(<span class="hljs-string">&quot;Task completed&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 必须捕获Throwable，包括Error</span><br>        logger.error(<span class="hljs-string">&quot;Scheduled task failed, but will continue&quot;</span>, t);<br>    &#125;<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>
<h4 id="错误用法4-不设置线程名称导致排查困难">错误用法4: 不设置线程名称导致排查困难</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ❌ 错误用法：使用默认ThreadFactory</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">badNaming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>, <span class="hljs-number">20</span>,<br>    <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>)<br>);<br><span class="hljs-comment">// 线程名：pool-1-thread-1, pool-1-thread-2...</span><br><span class="hljs-comment">// 问题：多个线程池时无法区分</span><br><br><span class="hljs-comment">// ✅ 正确用法：自定义ThreadFactory设置有意义的名称</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">goodNaming</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>, <span class="hljs-number">20</span>,<br>    <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">namePrefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;order-processor-&quot;</span>;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, namePrefix + threadNumber.getAndIncrement());<br>            t.setDaemon(<span class="hljs-literal">false</span>);<br>            t.setPriority(Thread.NORM_PRIORITY);<br>            t.setUncaughtExceptionHandler((thread, throwable) -&gt; &#123;<br>                logger.error(<span class="hljs-string">&quot;Uncaught exception in thread: &#123;&#125;&quot;</span>, thread.getName(), throwable);<br>            &#125;);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()<br>);<br><span class="hljs-comment">// 线程名：order-processor-1, order-processor-2...</span><br><span class="hljs-comment">// 优势：日志和堆栈追踪清晰</span><br></code></pre></td></tr></table></figure>
<h4 id="错误用法5-shutdown后立即awaittermination">错误用法5: shutdown后立即awaitTermination</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ❌ 错误用法：可能导致任务丢失</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> ...;<br><br>executor.shutdown();<br><span class="hljs-comment">// 风险：shutdown只是不再接受新任务，队列中的任务还在执行</span><br><span class="hljs-keyword">if</span> (!executor.awaitTermination(<span class="hljs-number">1</span>, TimeUnit.SECONDS)) &#123;<br>    <span class="hljs-comment">// 1秒后强制关闭，可能丢失任务</span><br>    executor.shutdownNow();<br>&#125;<br><br><span class="hljs-comment">// ✅ 正确用法：根据业务设置合理的等待时间</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> ...;<br><br>executor.shutdown();  <span class="hljs-comment">// 拒绝新任务</span><br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 根据队列大小和任务执行时间设置合理的等待时间</span><br>    <span class="hljs-keyword">if</span> (!executor.awaitTermination(<span class="hljs-number">60</span>, TimeUnit.SECONDS)) &#123;<br>        logger.warn(<span class="hljs-string">&quot;Executor did not terminate in time, forcing shutdown&quot;</span>);<br>        <br>        <span class="hljs-comment">// 尝试中断正在执行的任务</span><br>        List&lt;Runnable&gt; droppedTasks = executor.shutdownNow();<br>        logger.warn(<span class="hljs-string">&quot;Dropped &#123;&#125; tasks&quot;</span>, droppedTasks.size());<br>        <br>        <span class="hljs-comment">// 再次等待</span><br>        <span class="hljs-keyword">if</span> (!executor.awaitTermination(<span class="hljs-number">60</span>, TimeUnit.SECONDS)) &#123;<br>            logger.error(<span class="hljs-string">&quot;Executor did not terminate after shutdownNow&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    executor.shutdownNow();<br>    Thread.currentThread().interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="线程池调参的核心原则">线程池调参的核心原则</h3>
<p>线程池的调参有几个难点：</p>
<ol>
<li>如果核心线程数过小，则吞吐可能不够，遇到流量矛刺可能导致 RejectExecutionException；但值得警惕的是，如果核心线程数很大，可能导致频繁的上下文切换和过多的资源消耗（不管是 cpu 时间片还是操作系统的内核线程）。</li>
<li>如果队列过长，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。</li>
</ol>
<p>那么，如何计算这些参数呢？<br>
有一个基本的原则是：</p>
<ol>
<li>计算密集型的线程数本身应该尽量贴进 cpu 核数。</li>
<li>io 密集型的线程数要注意伸缩，要配合阻塞队列使用，要有承受拒绝失败的的准备。</li>
</ol>
<p>我们常见的计算方式主要来自于《Java并发编程实战》：</p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="线程池计算公式.png"></p>
<p>现实中可选的线程数计算公式最好是取一个并发 qps 数和 cpu 数的折中。通常可以认为 单任务的 rt/1ms 可以得到单一线程的吞吐数，qps 除以吞吐数可以得到 qps 相应的线程数，但这个方案没有考虑cpu 核数和上下文切换的问题。所以这样算出来的线程数的实际 qps 表现应该低于理论 qps，但可以通过估算和压测不断让理论值逼近实际值。</p>
<h2 id="线程池的可替换方案">线程池的可替换方案</h2>
<p>其他可替代方案，都不如线程池的调优方案成熟（<strong>在可以使用新技术的前提下，我们是否还有调优旧方案的魄力呢？</strong>）：</p>
<h3 id="传统替代方案对比">传统替代方案对比</h3>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">优势</th>
<th style="text-align:center">劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Disruptor框架</td>
<td style="text-align:center">线程池内部是通过一个工作队列去维护任务的执行的，它有一个根本性的缺陷：连续争用问题。也就是多个线程在申请任务时，为了合理地分配任务要付出锁资源，对比快速的任务执行来说，这部分申请的损耗是巨大的。高性能进程间消息库LMAX使用了一个叫作环形缓冲的数据结构，用这种这个特殊的数据结构替代队列，将会避免申请任务时出现的连续争用状况。</td>
<td style="text-align:center">避免连续争用，性能更佳</td>
<td style="text-align:center">缺乏线程管理的能力，使用场景较少</td>
</tr>
<tr>
<td style="text-align:center">协程框架</td>
<td style="text-align:center">协程是一种用户态的轻量级线程，其拥有自己的寄存器上下文和栈，当调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。这种切换上下文的方式要小于线程的开销。在瓶颈侧重IO的情况，使用协程获得并发性要优于使用线程。</td>
<td style="text-align:center">侧重IO情况时，性能更佳。与多线程策略无冲突，可结合使用</td>
<td style="text-align:center">在Java中缺乏成熟的应用</td>
</tr>
<tr>
<td style="text-align:center">Actor框架</td>
<td style="text-align:center">Actor模型通过维护多个Actor去处理并发的任务，它放弃了直接使用线程去获取并发性，而是自己定义了一系列系统组件应该如何动作和交互的通用规则，不需要开发者直接使用线程。通过在原生的线程或协程的级别上做了更高层次的封装，只需要开发者关心每个Actor的逻辑即可实现并发操作。由于避免了直接使用锁，很大程度解决了传统并发编程模式下大量依赖悲观锁导致的资源竞争情况。</td>
<td style="text-align:center">无锁策略，性能更佳，避免直接使用线程，安全性更高</td>
<td style="text-align:center">在Java中缺乏成熟的应用，内部复杂，难以排查和调试</td>
</tr>
</tbody>
</table>
<h3 id="现代java并发框架对比">现代Java并发框架对比</h3>
<p>根据Java并发编程实践和各框架的Javadoc文档，以下是主流并发框架的详细对比：</p>
<table>
<thead>
<tr>
<th>框架</th>
<th>适用场景</th>
<th>核心优势</th>
<th>主要劣势</th>
<th>典型应用</th>
<th>成熟度</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ThreadPoolExecutor</strong></td>
<td>通用任务调度、CPU/IO混合负载</td>
<td>JDK内置、灵活配置、监控完善、社区成熟</td>
<td>配置复杂、需要调优经验</td>
<td>Web服务、批处理、定时任务</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>ForkJoinPool</strong></td>
<td>CPU密集型分治任务、并行计算</td>
<td>工作窃取算法、自动负载均衡、递归任务优化</td>
<td>不适合阻塞操作、调试困难</td>
<td>Stream.parallel()、大数据计算</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>ScheduledThreadPoolExecutor</strong></td>
<td>定时/周期任务调度</td>
<td>精确调度、多任务并发、内存高效</td>
<td>不支持cron表达式、时区处理弱</td>
<td>心跳检测、数据同步</td>
<td>⭐⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>Project Reactor</strong></td>
<td>响应式异步流处理、高并发服务</td>
<td>背压支持、组合能力强、非阻塞IO</td>
<td>学习曲线陡峭、调试复杂</td>
<td>WebFlux、消息驱动架构</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>RxJava</strong></td>
<td>异步事件流、UI编程</td>
<td>丰富的操作符、链式调用、易于组合</td>
<td>内存开销大、线程切换频繁</td>
<td>Android开发、事件驱动系统</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>Kotlin Coroutines</strong></td>
<td>轻量级协程、异步IO密集型</td>
<td>资源占用少、代码简洁、结构化并发</td>
<td>需要Kotlin环境、JVM协程非原生</td>
<td>Kotlin服务端、Android</td>
<td>⭐⭐⭐⭐</td>
</tr>
<tr>
<td><strong>Virtual Threads (JDK 21+)</strong></td>
<td>高并发IO密集型、阻塞API场景</td>
<td>轻量级、无需线程池、阻塞代码简化</td>
<td>新特性、生态不成熟、CPU密集型无优势</td>
<td>高并发Web服务、数据库连接</td>
<td>⭐⭐⭐</td>
</tr>
<tr>
<td><strong>Akka</strong></td>
<td>分布式Actor系统、高并发消息处理</td>
<td>无锁设计、容错性强、分布式原生</td>
<td>复杂度高、学习成本大、调试困难</td>
<td>实时系统、游戏服务器</td>
<td>⭐⭐⭐⭐</td>
</tr>
</tbody>
</table>
<h3 id="选择建议">选择建议</h3>
<p><strong>选择ThreadPoolExecutor的场景</strong>：</p>
<ul>
<li>通用的异步任务处理</li>
<li>需要精确控制线程数和队列大小</li>
<li>要求完善的监控和调优能力</li>
<li>团队熟悉传统并发模型</li>
</ul>
<p><strong>选择响应式框架（Reactor/RxJava）的场景</strong>：</p>
<ul>
<li>微服务架构，需要高并发非阻塞IO</li>
<li>数据流处理，需要背压和流量控制</li>
<li>复杂的异步组合逻辑</li>
<li>已有Spring WebFlux等响应式基础设施</li>
</ul>
<p><strong>选择Virtual Threads的场景</strong>：</p>
<ul>
<li>JDK 21+环境</li>
<li>大量阻塞IO操作（数据库、HTTP调用）</li>
<li>希望简化异步代码（避免回调地狱）</li>
<li>不需要精细的线程池调优</li>
</ul>
<p><strong>选择ForkJoinPool的场景</strong>：</p>
<ul>
<li>CPU密集型递归算法</li>
<li>并行数据处理（如Stream.parallel()）</li>
<li>需要工作窃取优化的场景</li>
</ul>
<p><strong>关键原则</strong>：</p>
<ol>
<li><strong>不要为了新而新</strong>：ThreadPoolExecutor依然是生产环境的首选，除非有明确的技术驱动因素</li>
<li><strong>混合使用</strong>：可以在同一系统中混合使用不同框架（如ThreadPoolExecutor处理计算，Reactor处理IO）</li>
<li><strong>渐进式迁移</strong>：从ThreadPoolExecutor迁移到新框架需要充分测试和评估</li>
</ol>
<p>缺乏管控能力就不适合调优。</p>
<h2 id="最终解决方案">最终解决方案</h2>
<p>通过监控线程池负载，制定告警策略：</p>
<ol>
<li>线程池活跃度 = activeCount/maximumPoolSize。看看这个值是不是趋近于 1。</li>
<li>监控队列的capacity 和 size 的比例。</li>
<li>监控 RejectExecutionException 的出现。</li>
</ol>
<p>加引入线程池动态管控能力，基于告警制定 sop，确定是否要动态调节线程数和拒绝策略。</p>
<h2 id="线程池监控与调优实践">线程池监控与调优实践</h2>
<h3 id="监控指标采集">监控指标采集</h3>
<p>根据Java并发编程最佳实践和ThreadPoolExecutor的Javadoc，以下是关键的监控指标：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程池监控指标采集示例</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> magicliang</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2026-01-24</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolMonitor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(ThreadPoolMonitor.class);<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ThreadPoolExecutor executor;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService scheduler;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">rejectedCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolMonitor</span><span class="hljs-params">(ThreadPoolExecutor executor)</span> &#123;<br>        <span class="hljs-built_in">this</span>.executor = executor;<br>        <span class="hljs-built_in">this</span>.scheduler = Executors.newSingleThreadScheduledExecutor(r -&gt; &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;pool-monitor&quot;</span>);<br>            t.setDaemon(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 包装拒绝策略以统计拒绝次数</span><br>        wrapRejectedExecutionHandler();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动监控，每60秒采集一次指标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startMonitoring</span><span class="hljs-params">()</span> &#123;<br>        scheduler.scheduleAtFixedRate(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                logMetrics();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                logger.error(<span class="hljs-string">&quot;Failed to log thread pool metrics&quot;</span>, t);<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 采集并记录线程池指标</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logMetrics</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">activeCount</span> <span class="hljs-operator">=</span> executor.getActiveCount();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">poolSize</span> <span class="hljs-operator">=</span> executor.getPoolSize();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">corePoolSize</span> <span class="hljs-operator">=</span> executor.getCorePoolSize();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">maximumPoolSize</span> <span class="hljs-operator">=</span> executor.getMaximumPoolSize();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">completedTaskCount</span> <span class="hljs-operator">=</span> executor.getCompletedTaskCount();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">taskCount</span> <span class="hljs-operator">=</span> executor.getTaskCount();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">queueSize</span> <span class="hljs-operator">=</span> executor.getQueue().size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">queueRemainingCapacity</span> <span class="hljs-operator">=</span> executor.getQueue().remainingCapacity();<br>        <br>        <span class="hljs-comment">// 计算活跃度</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">activeRatio</span> <span class="hljs-operator">=</span> maximumPoolSize &gt; <span class="hljs-number">0</span> ? <br>            (<span class="hljs-type">double</span>) activeCount / maximumPoolSize : <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 计算队列使用率</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">queueCapacity</span> <span class="hljs-operator">=</span> queueSize + queueRemainingCapacity;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">queueUsageRatio</span> <span class="hljs-operator">=</span> queueCapacity &gt; <span class="hljs-number">0</span> ? <br>            (<span class="hljs-type">double</span>) queueSize / queueCapacity : <span class="hljs-number">0</span>;<br>        <br>        <span class="hljs-comment">// 记录指标</span><br>        logger.info(<span class="hljs-string">&quot;ThreadPool Metrics: &quot;</span> +<br>            <span class="hljs-string">&quot;activeCount=&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;poolSize=&#123;&#125;/&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;activeRatio=&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;queueSize=&#123;&#125;/&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;queueUsageRatio=&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;completedTasks=&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;totalTasks=&#123;&#125;, &quot;</span> +<br>            <span class="hljs-string">&quot;rejectedCount=&#123;&#125;&quot;</span>,<br>            activeCount,<br>            poolSize, maximumPoolSize,<br>            String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, activeRatio),<br>            queueSize, queueCapacity,<br>            String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, queueUsageRatio),<br>            completedTaskCount,<br>            taskCount,<br>            rejectedCount.get());<br>        <br>        <span class="hljs-comment">// 告警检查</span><br>        checkAndAlert(activeRatio, queueUsageRatio);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查指标并触发告警</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndAlert</span><span class="hljs-params">(<span class="hljs-type">double</span> activeRatio, <span class="hljs-type">double</span> queueUsageRatio)</span> &#123;<br>        <span class="hljs-comment">// 活跃度超过90%告警</span><br>        <span class="hljs-keyword">if</span> (activeRatio &gt; <span class="hljs-number">0.9</span>) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Thread pool active ratio too high: &#123;&#125;&quot;</span>, activeRatio);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 队列使用率超过80%告警</span><br>        <span class="hljs-keyword">if</span> (queueUsageRatio &gt; <span class="hljs-number">0.8</span>) &#123;<br>            logger.warn(<span class="hljs-string">&quot;Thread pool queue usage too high: &#123;&#125;&quot;</span>, queueUsageRatio);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 拒绝次数超过阈值告警</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">rejected</span> <span class="hljs-operator">=</span> rejectedCount.get();<br>        <span class="hljs-keyword">if</span> (rejected &gt; <span class="hljs-number">100</span>) &#123;<br>            logger.error(<span class="hljs-string">&quot;Thread pool rejected too many tasks: &#123;&#125;&quot;</span>, rejected);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 包装拒绝策略以统计拒绝次数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wrapRejectedExecutionHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">RejectedExecutionHandler</span> <span class="hljs-variable">originalHandler</span> <span class="hljs-operator">=</span> executor.getRejectedExecutionHandler();<br>        executor.setRejectedExecutionHandler((r, executor) -&gt; &#123;<br>            rejectedCount.incrementAndGet();<br>            originalHandler.rejectedExecution(r, executor);<br>        &#125;);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 停止监控</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">stopMonitoring</span><span class="hljs-params">()</span> &#123;<br>        scheduler.shutdown();<br>        <span class="hljs-keyword">try</span> &#123;<br>            scheduler.awaitTermination(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="常见生产问题排查">常见生产问题排查</h3>
<h4 id="案例1-线程池队列积压导致oom">案例1: 线程池队列积压导致OOM</h4>
<p><strong>现象</strong>：</p>
<ul>
<li>应用突然OOM，heap dump显示LinkedBlockingQueue占用大量内存</li>
<li>GC日志显示Full GC频繁但内存无法回收</li>
<li>线程池队列大小持续增长</li>
</ul>
<p><strong>原因分析</strong>：</p>
<ol>
<li>使用了<code>newFixedThreadPool</code>（无界队列）</li>
<li>任务提交速度持续超过处理速度</li>
<li>队列无限增长导致堆内存耗尽</li>
</ol>
<p><strong>排查步骤</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 通过JMX或监控查看线程池状态</span><br><span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> (ThreadPoolExecutor) <span class="hljs-built_in">this</span>.executor;<br>logger.info(<span class="hljs-string">&quot;Queue size: &#123;&#125;&quot;</span>, executor.getQueue().size());<br>logger.info(<span class="hljs-string">&quot;Active threads: &#123;&#125;/&#123;&#125;&quot;</span>, <br>    executor.getActiveCount(), <br>    executor.getMaximumPoolSize());<br><br><span class="hljs-comment">// 2. 查看任务类型和执行时间</span><br>logger.info(<span class="hljs-string">&quot;Completed tasks: &#123;&#125;&quot;</span>, executor.getCompletedTaskCount());<br>logger.info(<span class="hljs-string">&quot;Total tasks: &#123;&#125;&quot;</span>, executor.getTaskCount());<br></code></pre></td></tr></table></figure>
<p><strong>解决方案</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 改用有界队列 + 合理的拒绝策略</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">fixedExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>,                              <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-number">20</span>,                              <span class="hljs-comment">// 最大线程数</span><br>    <span class="hljs-number">60L</span>, TimeUnit.SECONDS,           <span class="hljs-comment">// 空闲线程存活时间</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>),  <span class="hljs-comment">// 有界队列</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;bounded-worker-&quot;</span> + threadNumber.getAndIncrement());<br>            <span class="hljs-comment">// 设置未捕获异常处理器(重要!)</span><br>            t.setUncaughtExceptionHandler((thread, throwable) -&gt; &#123;<br>                logger.error(<span class="hljs-string">&quot;Uncaught exception in thread: &#123;&#125;&quot;</span>, thread.getName(), throwable);<br>            &#125;);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="hljs-comment">// 调用者线程执行，降级策略</span><br>);<br></code></pre></td></tr></table></figure>
<h4 id="案例2-newcachedthreadpool线程爆炸">案例2: newCachedThreadPool线程爆炸</h4>
<p><strong>现象</strong>：</p>
<ul>
<li>系统突然变慢，CPU使用率异常高</li>
<li>线程数急剧增长（jstack看到数千个线程）</li>
<li>最终触发OOM: unable to create new native thread</li>
</ul>
<p><strong>原因分析</strong>：</p>
<ol>
<li>使用了<code>newCachedThreadPool</code>（最大线程数Integer.MAX_VALUE）</li>
<li>任务持续提交但执行时间较长</li>
<li>每个任务都创建新线程，导致线程爆炸</li>
</ol>
<p><strong>排查步骤</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看线程数</span><br>jstack &lt;pid&gt; | grep <span class="hljs-string">&quot;java.lang.Thread.State&quot;</span> | <span class="hljs-built_in">wc</span> -l<br><br><span class="hljs-comment"># 查看线程分布</span><br>jstack &lt;pid&gt; | grep <span class="hljs-string">&quot;pool-&quot;</span> | <span class="hljs-built_in">head</span> -50<br></code></pre></td></tr></table></figure>
<p><strong>解决方案</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用有界线程数的线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">boundedExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>,                              <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-number">50</span>,                              <span class="hljs-comment">// 最大线程数（有界）</span><br>    <span class="hljs-number">60L</span>, TimeUnit.SECONDS,           <br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>),  <span class="hljs-comment">// 有界队列</span><br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;bounded-cached-&quot;</span> + threadNumber.getAndIncrement());<br>            <span class="hljs-comment">// 设置未捕获异常处理器</span><br>            t.setUncaughtExceptionHandler((thread, throwable) -&gt; &#123;<br>                logger.error(<span class="hljs-string">&quot;Uncaught exception in thread: &#123;&#125;&quot;</span>, thread.getName(), throwable);<br>            &#125;);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>    &#125;,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy()  <span class="hljs-comment">// 拒绝新任务</span><br>);<br></code></pre></td></tr></table></figure>
<h4 id="案例3-周期任务静默停止">案例3: 周期任务静默停止</h4>
<p><strong>现象</strong>：</p>
<ul>
<li>ScheduledExecutorService的周期任务运行一段时间后不再执行</li>
<li>没有任何异常日志</li>
<li>其他非周期任务正常执行</li>
</ul>
<p><strong>原因分析</strong>：<br>
根据ScheduledFutureTask的runPeriodic()实现，周期任务抛出异常会导致后续调度终止。</p>
<p><strong>排查步骤</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查看Future状态</span><br>ScheduledFuture&lt;?&gt; future = scheduler.scheduleAtFixedRate(task, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// 尝试获取结果（会抛出异常）</span><br><span class="hljs-keyword">try</span> &#123;<br>    future.get(<span class="hljs-number">1</span>, TimeUnit.MILLISECONDS);<br>&#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>    <span class="hljs-comment">// 任务还在运行</span><br>&#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>    <span class="hljs-comment">// 任务执行异常</span><br>    logger.error(<span class="hljs-string">&quot;Task failed&quot;</span>, e.getCause());<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>解决方案</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 周期任务必须捕获所有异常</span><br><span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">scheduler</span> <span class="hljs-operator">=</span> Executors.newScheduledThreadPool(<span class="hljs-number">2</span>);<br><br>scheduler.scheduleAtFixedRate(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 任务逻辑</span><br>        riskyOperation();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 必须捕获Throwable，包括Error</span><br>        logger.error(<span class="hljs-string">&quot;Scheduled task failed, but will continue&quot;</span>, t);<br>    &#125;<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>
<h3 id="调优建议">调优建议</h3>
<p><strong>1. 核心线程数设置</strong>：</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">CPU</span>密集型：核心线程数 = <span class="hljs-meta">CPU</span>核数 + <span class="hljs-number">1</span><br>IO密集型：核心线程数 = <span class="hljs-meta">CPU</span>核数 * (<span class="hljs-number">1</span> + 平均等待时间/平均计算时间)<br></code></pre></td></tr></table></figure>
<p><strong>2. 队列大小设置</strong>：</p>
<ul>
<li>快速失败场景：小队列 + AbortPolicy</li>
<li>削峰填谷场景：中等队列 + CallerRunsPolicy</li>
<li>避免丢失场景：大队列（但要监控）</li>
</ul>
<p><strong>3. 拒绝策略选择</strong>：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>适用场景</th>
<th>风险</th>
</tr>
</thead>
<tbody>
<tr>
<td>AbortPolicy</td>
<td>快速失败，允许丢任务</td>
<td>任务丢失</td>
</tr>
<tr>
<td>CallerRunsPolicy</td>
<td>降级执行，不丢任务</td>
<td>调用线程阻塞</td>
</tr>
<tr>
<td>DiscardPolicy</td>
<td>静默丢弃</td>
<td>无感知丢失</td>
</tr>
<tr>
<td>DiscardOldestPolicy</td>
<td>丢弃最老任务</td>
<td>优先级倒置</td>
</tr>
</tbody>
</table>
<p>如果还是解决不了问题，需要考虑全局动态扩容的方案。</p>
<p><strong>线程池监控指标体系：</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph 核心监控指标
        A[线程池监控] --&gt; B[线程指标]
        A --&gt; C[队列指标]
        A --&gt; D[任务指标]
        A --&gt; E[异常指标]
        
        B --&gt; B1[poolSize&lt;br/&gt;当前线程数]
        B --&gt; B2[activeCount&lt;br/&gt;活跃线程数]
        B --&gt; B3[largestPoolSize&lt;br/&gt;历史最大线程数]
        B --&gt; B4[corePoolSize&lt;br/&gt;核心线程数]
        B --&gt; B5[maximumPoolSize&lt;br/&gt;最大线程数]
        
        C --&gt; C1[queue.size&lt;br/&gt;队列当前大小]
        C --&gt; C2[queue.remainingCapacity&lt;br/&gt;队列剩余容量]
        C --&gt; C3[队列使用率&lt;br/&gt;size/capacity]
        
        D --&gt; D1[taskCount&lt;br/&gt;总任务数]
        D --&gt; D2[completedTaskCount&lt;br/&gt;已完成任务数]
        D --&gt; D3[待执行任务数&lt;br/&gt;taskCount-completedTaskCount]
        
        E --&gt; E1[rejectedCount&lt;br/&gt;拒绝任务数]
        E --&gt; E2[exceptionCount&lt;br/&gt;异常任务数]
    end
    
    style A fill:#4ECDC4
    style B fill:#87CEEB
    style C fill:#90EE90
    style D fill:#FFB6C1
    style E fill:#FF6B6B</code></pre>
<p><strong>完整的线程池监控实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicLong;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 可监控的线程池实现</span><br><span class="hljs-comment"> * 提供完整的监控指标收集和告警能力</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MonitoredThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ThreadPoolExecutor</span> &#123;<br>    <br>    <span class="hljs-comment">// ==================== 监控指标 ====================</span><br>    <br>    <span class="hljs-comment">/** 拒绝任务计数器 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">rejectedCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/** 异常任务计数器 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">exceptionCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/** 任务执行时间统计（纳秒） */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">totalExecutionTime</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">/** 任务开始时间记录（用于计算执行时间） */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Runnable, Long&gt; taskStartTimes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-comment">/** 线程池名称（用于日志和监控标识） */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String poolName;<br>    <br>    <span class="hljs-comment">/** 告警阈值配置 */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">double</span> <span class="hljs-variable">activeRatioThreshold</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.8</span>;      <span class="hljs-comment">// 活跃度告警阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">double</span> <span class="hljs-variable">queueUsageThreshold</span> <span class="hljs-operator">=</span> <span class="hljs-number">0.8</span>;       <span class="hljs-comment">// 队列使用率告警阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">taskTimeoutMs</span> <span class="hljs-operator">=</span> <span class="hljs-number">30000</span>;             <span class="hljs-comment">// 任务超时阈值（毫秒）</span><br>    <br>    <span class="hljs-comment">// ==================== 构造函数 ====================</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MonitoredThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">            String poolName,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">            <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">            TimeUnit unit,</span><br><span class="hljs-params">            BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">            ThreadFactory threadFactory)</span> &#123;<br>        <br>        <span class="hljs-built_in">super</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory,<br>            <span class="hljs-comment">// 使用自定义拒绝策略来统计拒绝次数</span><br>            (r, executor) -&gt; &#123;<br>                ((MonitoredThreadPoolExecutor) executor).rejectedCount.incrementAndGet();<br>                <span class="hljs-comment">// 记录拒绝日志</span><br>                System.err.printf(<span class="hljs-string">&quot;[%s] 任务被拒绝: queue=%d, active=%d, pool=%d%n&quot;</span>,<br>                    ((MonitoredThreadPoolExecutor) executor).poolName,<br>                    executor.getQueue().size(),<br>                    executor.getActiveCount(),<br>                    executor.getPoolSize());<br>                <span class="hljs-comment">// 默认行为：抛出异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RejectedExecutionException</span>(<span class="hljs-string">&quot;Task rejected from &quot;</span> + <br>                    ((MonitoredThreadPoolExecutor) executor).poolName);<br>            &#125;);<br>        <br>        <span class="hljs-built_in">this</span>.poolName = poolName;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 生命周期钩子 ====================</span><br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">beforeExecute</span><span class="hljs-params">(Thread t, Runnable r)</span> &#123;<br>        <span class="hljs-built_in">super</span>.beforeExecute(t, r);<br>        <span class="hljs-comment">// 记录任务开始时间</span><br>        taskStartTimes.put(r, System.nanoTime());<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterExecute</span><span class="hljs-params">(Runnable r, Throwable t)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 计算任务执行时间</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> taskStartTimes.remove(r);<br>            <span class="hljs-keyword">if</span> (startTime != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">long</span> <span class="hljs-variable">executionTime</span> <span class="hljs-operator">=</span> System.nanoTime() - startTime;<br>                totalExecutionTime.addAndGet(executionTime);<br>                <br>                <span class="hljs-comment">// 检查任务是否超时</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">executionTimeMs</span> <span class="hljs-operator">=</span> TimeUnit.NANOSECONDS.toMillis(executionTime);<br>                <span class="hljs-keyword">if</span> (executionTimeMs &gt; taskTimeoutMs) &#123;<br>                    System.err.printf(<span class="hljs-string">&quot;[%s] 任务执行超时: %dms &gt; %dms%n&quot;</span>,<br>                        poolName, executionTimeMs, taskTimeoutMs);<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 统计异常</span><br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                exceptionCount.incrementAndGet();<br>                System.err.printf(<span class="hljs-string">&quot;[%s] 任务执行异常: %s%n&quot;</span>, poolName, t.getMessage());<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-built_in">super</span>.afterExecute(r, t);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 监控指标获取 ====================</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取线程池活跃度（0.0 ~ 1.0）</span><br><span class="hljs-comment">     * 活跃度 = 活跃线程数 / 最大线程数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getActiveRatio</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">double</span>) getActiveCount() / getMaximumPoolSize();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取队列使用率（0.0 ~ 1.0）</span><br><span class="hljs-comment">     * 使用率 = 队列当前大小 / 队列总容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getQueueUsageRatio</span><span class="hljs-params">()</span> &#123;<br>        BlockingQueue&lt;Runnable&gt; queue = getQueue();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> queue.size();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">capacity</span> <span class="hljs-operator">=</span> size + queue.remainingCapacity();<br>        <span class="hljs-keyword">return</span> capacity &gt; <span class="hljs-number">0</span> ? (<span class="hljs-type">double</span>) size / capacity : <span class="hljs-number">0.0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取平均任务执行时间（毫秒）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">getAverageExecutionTimeMs</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">completed</span> <span class="hljs-operator">=</span> getCompletedTaskCount();<br>        <span class="hljs-keyword">if</span> (completed == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span>;<br>        <span class="hljs-keyword">return</span> TimeUnit.NANOSECONDS.toMillis(totalExecutionTime.get()) / (<span class="hljs-type">double</span>) completed;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取拒绝任务数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getRejectedCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> rejectedCount.get();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取异常任务数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getExceptionCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> exceptionCount.get();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取待执行任务数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getPendingTaskCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getTaskCount() - getCompletedTaskCount();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取完整的监控快照</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ThreadPoolMetrics <span class="hljs-title function_">getMetrics</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolMetrics</span>(<br>            poolName,<br>            getCorePoolSize(),<br>            getMaximumPoolSize(),<br>            getPoolSize(),<br>            getActiveCount(),<br>            getLargestPoolSize(),<br>            getTaskCount(),<br>            getCompletedTaskCount(),<br>            getQueue().size(),<br>            getQueue().remainingCapacity(),<br>            rejectedCount.get(),<br>            exceptionCount.get(),<br>            getAverageExecutionTimeMs()<br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 告警检查 ====================</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查是否需要告警</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkAndAlert</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 检查活跃度</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">activeRatio</span> <span class="hljs-operator">=</span> getActiveRatio();<br>        <span class="hljs-keyword">if</span> (activeRatio &gt;= activeRatioThreshold) &#123;<br>            System.err.printf(<span class="hljs-string">&quot;[%s] 告警: 线程池活跃度过高 %.2f%% &gt;= %.2f%%%n&quot;</span>,<br>                poolName, activeRatio * <span class="hljs-number">100</span>, activeRatioThreshold * <span class="hljs-number">100</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 检查队列使用率</span><br>        <span class="hljs-type">double</span> <span class="hljs-variable">queueUsage</span> <span class="hljs-operator">=</span> getQueueUsageRatio();<br>        <span class="hljs-keyword">if</span> (queueUsage &gt;= queueUsageThreshold) &#123;<br>            System.err.printf(<span class="hljs-string">&quot;[%s] 告警: 队列使用率过高 %.2f%% &gt;= %.2f%%%n&quot;</span>,<br>                poolName, queueUsage * <span class="hljs-number">100</span>, queueUsageThreshold * <span class="hljs-number">100</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 检查拒绝任务</span><br>        <span class="hljs-keyword">if</span> (rejectedCount.get() &gt; <span class="hljs-number">0</span>) &#123;<br>            System.err.printf(<span class="hljs-string">&quot;[%s] 告警: 存在被拒绝的任务 count=%d%n&quot;</span>,<br>                poolName, rejectedCount.get());<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 动态调参 ====================</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 动态调整核心线程数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustCorePoolSize</span><span class="hljs-params">(<span class="hljs-type">int</span> newCorePoolSize)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldSize</span> <span class="hljs-operator">=</span> getCorePoolSize();<br>        setCorePoolSize(newCorePoolSize);<br>        System.out.printf(<span class="hljs-string">&quot;[%s] 核心线程数调整: %d -&gt; %d%n&quot;</span>, poolName, oldSize, newCorePoolSize);<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 动态调整最大线程数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">adjustMaximumPoolSize</span><span class="hljs-params">(<span class="hljs-type">int</span> newMaximumPoolSize)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">oldSize</span> <span class="hljs-operator">=</span> getMaximumPoolSize();<br>        setMaximumPoolSize(newMaximumPoolSize);<br>        System.out.printf(<span class="hljs-string">&quot;[%s] 最大线程数调整: %d -&gt; %d%n&quot;</span>, poolName, oldSize, newMaximumPoolSize);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ==================== 监控指标数据类 ====================</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolMetrics</span> &#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String poolName;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> corePoolSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maximumPoolSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> poolSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> activeCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> largestPoolSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> taskCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> completedTaskCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> queueSize;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> queueRemainingCapacity;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> rejectedCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> exceptionCount;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> avgExecutionTimeMs;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolMetrics</span><span class="hljs-params">(String poolName, <span class="hljs-type">int</span> corePoolSize, <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">                <span class="hljs-type">int</span> poolSize, <span class="hljs-type">int</span> activeCount, <span class="hljs-type">int</span> largestPoolSize, <span class="hljs-type">long</span> taskCount,</span><br><span class="hljs-params">                <span class="hljs-type">long</span> completedTaskCount, <span class="hljs-type">int</span> queueSize, <span class="hljs-type">int</span> queueRemainingCapacity,</span><br><span class="hljs-params">                <span class="hljs-type">long</span> rejectedCount, <span class="hljs-type">long</span> exceptionCount, <span class="hljs-type">double</span> avgExecutionTimeMs)</span> &#123;<br>            <span class="hljs-built_in">this</span>.poolName = poolName;<br>            <span class="hljs-built_in">this</span>.corePoolSize = corePoolSize;<br>            <span class="hljs-built_in">this</span>.maximumPoolSize = maximumPoolSize;<br>            <span class="hljs-built_in">this</span>.poolSize = poolSize;<br>            <span class="hljs-built_in">this</span>.activeCount = activeCount;<br>            <span class="hljs-built_in">this</span>.largestPoolSize = largestPoolSize;<br>            <span class="hljs-built_in">this</span>.taskCount = taskCount;<br>            <span class="hljs-built_in">this</span>.completedTaskCount = completedTaskCount;<br>            <span class="hljs-built_in">this</span>.queueSize = queueSize;<br>            <span class="hljs-built_in">this</span>.queueRemainingCapacity = queueRemainingCapacity;<br>            <span class="hljs-built_in">this</span>.rejectedCount = rejectedCount;<br>            <span class="hljs-built_in">this</span>.exceptionCount = exceptionCount;<br>            <span class="hljs-built_in">this</span>.avgExecutionTimeMs = avgExecutionTimeMs;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> String.format(<br>                <span class="hljs-string">&quot;ThreadPoolMetrics&#123;pool=%s, core=%d, max=%d, current=%d, active=%d, &quot;</span> +<br>                <span class="hljs-string">&quot;largest=%d, tasks=%d, completed=%d, queue=%d/%d, rejected=%d, &quot;</span> +<br>                <span class="hljs-string">&quot;exceptions=%d, avgTime=%.2fms&#125;&quot;</span>,<br>                poolName, corePoolSize, maximumPoolSize, poolSize, activeCount,<br>                largestPoolSize, taskCount, completedTaskCount, queueSize,<br>                queueSize + queueRemainingCapacity, rejectedCount, exceptionCount,<br>                avgExecutionTimeMs);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>定时监控任务示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolMonitorExample</span> &#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 创建可监控的线程池</span><br>        <span class="hljs-type">MonitoredThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MonitoredThreadPoolExecutor</span>(<br>            <span class="hljs-string">&quot;business-pool&quot;</span>,<br>            <span class="hljs-number">4</span>,                              <span class="hljs-comment">// corePoolSize</span><br>            <span class="hljs-number">8</span>,                              <span class="hljs-comment">// maximumPoolSize</span><br>            <span class="hljs-number">60L</span>, TimeUnit.SECONDS,          <span class="hljs-comment">// keepAliveTime</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">100</span>), <span class="hljs-comment">// workQueue</span><br>            r -&gt; &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>                t.setName(<span class="hljs-string">&quot;business-pool-&quot;</span> + t.getId());<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        );<br>        <br>        <span class="hljs-comment">// 启动监控任务（每5秒打印一次指标）</span><br>        <span class="hljs-type">ScheduledExecutorService</span> <span class="hljs-variable">monitor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadScheduledExecutor();<br>        monitor.scheduleAtFixedRate(() -&gt; &#123;<br>            <span class="hljs-comment">// 获取并打印监控指标</span><br>            MonitoredThreadPoolExecutor.<span class="hljs-type">ThreadPoolMetrics</span> <span class="hljs-variable">metrics</span> <span class="hljs-operator">=</span> executor.getMetrics();<br>            System.out.println(metrics);<br>            <br>            <span class="hljs-comment">// 检查告警</span><br>            executor.checkAndAlert();<br>            <br>            <span class="hljs-comment">// 可以在这里将指标上报到监控系统</span><br>            <span class="hljs-comment">// metricsReporter.report(metrics);</span><br>            <br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        <br>        <span class="hljs-comment">// 模拟提交任务</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">50</span>; i++) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">taskId</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-keyword">try</span> &#123;<br>                executor.execute(() -&gt; &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 模拟任务执行</span><br>                        Thread.sleep((<span class="hljs-type">long</span>) (Math.random() * <span class="hljs-number">1000</span>));<br>                        System.out.println(<span class="hljs-string">&quot;任务&quot;</span> + taskId + <span class="hljs-string">&quot;完成&quot;</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;);<br>            &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException e) &#123;<br>                System.err.println(<span class="hljs-string">&quot;任务&quot;</span> + taskId + <span class="hljs-string">&quot;被拒绝&quot;</span>);<br>            &#125;<br>            Thread.sleep(<span class="hljs-number">100</span>);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 等待任务完成</span><br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        <br>        <span class="hljs-comment">// 关闭</span><br>        executor.shutdown();<br>        monitor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>监控告警决策流程：</strong></p>
<pre><code class="hljs mermaid">flowchart TD
    A[定时采集指标] --&gt; B&#123;活跃度 &gt;= 80%?&#125;
    B --&gt;|是| C[告警: 线程池繁忙]
    B --&gt;|否| D&#123;队列使用率 &gt;= 80%?&#125;
    
    D --&gt;|是| E[告警: 队列积压]
    D --&gt;|否| F&#123;有拒绝任务?&#125;
    
    F --&gt;|是| G[告警: 任务被拒绝]
    F --&gt;|否| H&#123;平均执行时间过长?&#125;
    
    H --&gt;|是| I[告警: 任务执行慢]
    H --&gt;|否| J[正常]
    
    C --&gt; K&#123;是否自动扩容?&#125;
    E --&gt; K
    G --&gt; K
    
    K --&gt;|是| L[动态调整参数]
    K --&gt;|否| M[通知运维处理]
    
    L --&gt; N&#123;调整core?&#125;
    N --&gt;|是| O[setCorePoolSize]
    N --&gt;|否| P&#123;调整max?&#125;
    P --&gt;|是| Q[setMaximumPoolSize]
    P --&gt;|否| R[调整队列容量]
    
    style C fill:#FF6B6B
    style E fill:#FF6B6B
    style G fill:#FF6B6B
    style I fill:#FFB6C1
    style J fill:#90EE90
    style L fill:#4ECDC4</code></pre>
<p><strong>Spring Boot 集成监控示例：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.boot.actuate.endpoint.annotation.*;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.HashMap;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 线程池监控端点</span><br><span class="hljs-comment"> * 访问 /actuator/threadpool 获取所有线程池状态</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Endpoint(id = &quot;threadpool&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolEndpoint</span> &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, MonitoredThreadPoolExecutor&gt; executors = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(String name, MonitoredThreadPoolExecutor executor)</span> &#123;<br>        executors.put(name, executor);<br>    &#125;<br>    <br>    <span class="hljs-meta">@ReadOperation</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title function_">health</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, Object&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        <br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, MonitoredThreadPoolExecutor&gt; entry : executors.entrySet()) &#123;<br>            <span class="hljs-type">MonitoredThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> entry.getValue();<br>            Map&lt;String, Object&gt; poolInfo = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>            <br>            <span class="hljs-comment">// 基础指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;corePoolSize&quot;</span>, executor.getCorePoolSize());<br>            poolInfo.put(<span class="hljs-string">&quot;maximumPoolSize&quot;</span>, executor.getMaximumPoolSize());<br>            poolInfo.put(<span class="hljs-string">&quot;poolSize&quot;</span>, executor.getPoolSize());<br>            poolInfo.put(<span class="hljs-string">&quot;activeCount&quot;</span>, executor.getActiveCount());<br>            poolInfo.put(<span class="hljs-string">&quot;largestPoolSize&quot;</span>, executor.getLargestPoolSize());<br>            <br>            <span class="hljs-comment">// 任务指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;taskCount&quot;</span>, executor.getTaskCount());<br>            poolInfo.put(<span class="hljs-string">&quot;completedTaskCount&quot;</span>, executor.getCompletedTaskCount());<br>            poolInfo.put(<span class="hljs-string">&quot;pendingTaskCount&quot;</span>, executor.getPendingTaskCount());<br>            <br>            <span class="hljs-comment">// 队列指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;queueSize&quot;</span>, executor.getQueue().size());<br>            poolInfo.put(<span class="hljs-string">&quot;queueRemainingCapacity&quot;</span>, executor.getQueue().remainingCapacity());<br>            <br>            <span class="hljs-comment">// 计算指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;activeRatio&quot;</span>, String.format(<span class="hljs-string">&quot;%.2f%%&quot;</span>, executor.getActiveRatio() * <span class="hljs-number">100</span>));<br>            poolInfo.put(<span class="hljs-string">&quot;queueUsageRatio&quot;</span>, String.format(<span class="hljs-string">&quot;%.2f%%&quot;</span>, executor.getQueueUsageRatio() * <span class="hljs-number">100</span>));<br>            poolInfo.put(<span class="hljs-string">&quot;avgExecutionTimeMs&quot;</span>, String.format(<span class="hljs-string">&quot;%.2f&quot;</span>, executor.getAverageExecutionTimeMs()));<br>            <br>            <span class="hljs-comment">// 异常指标</span><br>            poolInfo.put(<span class="hljs-string">&quot;rejectedCount&quot;</span>, executor.getRejectedCount());<br>            poolInfo.put(<span class="hljs-string">&quot;exceptionCount&quot;</span>, executor.getExceptionCount());<br>            <br>            result.put(entry.getKey(), poolInfo);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <br>    <span class="hljs-meta">@WriteOperation</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">adjustPoolSize</span><span class="hljs-params">(</span><br><span class="hljs-params">            <span class="hljs-meta">@Selector</span> String poolName,</span><br><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> Integer corePoolSize,</span><br><span class="hljs-params">            <span class="hljs-meta">@Nullable</span> Integer maximumPoolSize)</span> &#123;<br>        <br>        <span class="hljs-type">MonitoredThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> executors.get(poolName);<br>        <span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;线程池不存在: &quot;</span> + poolName;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (corePoolSize != <span class="hljs-literal">null</span>) &#123;<br>            executor.adjustCorePoolSize(corePoolSize);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (maximumPoolSize != <span class="hljs-literal">null</span>) &#123;<br>            executor.adjustMaximumPoolSize(maximumPoolSize);<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;调整成功&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里的 activeCount 是每个 worker 是否互斥 held 的总数的统计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getActiveCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// workers 是一个 HashSet，它是非线程安全的。</span><br>getActiveCount 需要遍历这个集合，如果不加全局的 mainLock，在遍历过程中如果有线程销毁或创建，会抛出 ConcurrentModificationException 或者读到错误的数据。所以 mainLock 是为了保护 workers 集合的遍历安全。<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (Worker w : workers)<br>                <span class="hljs-comment">// 在 ThreadPoolExecutor 的设计中，Worker 只要开始执行任务（runWorker 方法中），就会把自己锁住（lock）。</span><br>                <span class="hljs-comment">// 当 Worker 没有任务做，正在 getTask() 方法里阻塞等待（即空闲状态）时，它是**不加锁（unlocked）**的。</span><br>               <span class="hljs-comment">// 所以，isLocked() == true 等价于 “这个线程正在干活”。</span><br>getActiveCount 的目的就是统计“当前有多少个线程正在干活”，所以必须统计被锁住的 Worker。<br>                <span class="hljs-keyword">if</span> (w.isLocked())<br>                    ++n;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里的 isLocked 意味着这个工作线程正在跑  task 的run，意味着可能是如下状态：RUNNABLE、BLOCKED、WAITING、TIMED_WAITING。</p>
<h2 id="线程组">线程组</h2>
<p>线程组提供一个“集合”，可以把一群线程归于一处，可以批量 interrupt/stop/suspend。<br>
但这个方案是很危险的，使用线程池和并发安全的 Collection 都可以管理好线程。</p>
<h3 id="原本设计目的">原本设计目的</h3>
<ul>
<li>资源管理：将相关线程组织在一起，便于批量操作</li>
<li>安全隔离：不同线程组可以有不同的安全策略</li>
<li>异常处理：提供组级别的未捕获异常处理</li>
<li>层次结构：支持线程组的嵌套（parent-child关系）</li>
</ul>
<h3 id="缺陷">缺陷</h3>
<ul>
<li>API设计不一致且不完整</li>
<li>线程安全问题</li>
<li>功能缺失</li>
<li>安全模型过时</li>
</ul>
<h3 id="替代方案">替代方案</h3>
<ul>
<li>Executor框架</li>
<li>CompletableFuture</li>
<li>ForkJoinPool</li>
</ul>
<h3 id="官方态度">官方态度</h3>
<ul>
<li>Java 17+：线程组API标记为<code>@Deprecated(forRemoval = true)</code></li>
<li>JEP 411：移除SecurityManager，线程组失去最后的存在意义</li>
<li>OpenJDK邮件列表：多次讨论完全移除线程组</li>
</ul>
<h2 id="completionstage">CompletionStage</h2>
<p>这是定义“可能是”异步计算的一个阶段，可能被其他阶段触发，也可以触发其他阶段。它是 CompletableFuture 的父接口。</p>
<p>它有一个特点，大量非 void 方法返回值都是 CompletionStage 类型，这样既允许 builder 模式，也允许各种 transformation 模式。</p>
<h2 id="completablefuture">CompletableFuture</h2>
<p>线程池的超时中断机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">invokeAll(tasks, <span class="hljs-number">300L</span>, TimeUnit.MILLISECONDS);<br></code></pre></td></tr></table></figure>
<p>会让这个类型中断提前返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">432369</span>-Caused by: java.lang.InterruptedException: <span class="hljs-literal">null</span><br><span class="hljs-number">432370</span>- at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:<span class="hljs-number">347</span>)<br><span class="hljs-number">432371</span>- at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:<span class="hljs-number">1915</span>)<br><span class="hljs-number">432372</span>- at org.apache.dubbo.rpc.AsyncRpcResult.get(AsyncRpcResult.java:<span class="hljs-number">196</span>)<br><span class="hljs-number">432373</span>- at org.apache.dubbo.rpc.protocol.AbstractInvoker.waitForResultIfSync(AbstractInvoker.java:<span class="hljs-number">266</span>)<br><span class="hljs-number">432374</span>- at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:<span class="hljs-number">186</span>)<br><span class="hljs-number">432375</span>- at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invokeWithContext(AbstractClusterInvoker.java:<span class="hljs-number">379</span>)<br><span class="hljs-number">432376</span>- at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:<span class="hljs-number">81</span>)<br></code></pre></td></tr></table></figure>
<h1>小技巧</h1>
<h2 id="如何处理任务超时问题">如何处理任务超时问题</h2>
<h3 id="方法1：使用-futuretask-的实现">方法1：使用 FutureTask 的实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">    Future&lt;Map&lt;String, Object&gt;&gt; future = executor.submit(() -&gt; getFeatures(context, zeusSceneId));<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 穷人版超时：最简单的超时不是使用 circuit breaker，而是使用 FutureTask 的缺省超时实现，这个方案取不到值的时候底层会返回 TimeoutException，只要捕获这个超时就可以走入 fallback 逻辑</span><br>                features.putAll(future.get(paramCollectTimeout, TimeUnit.MILLISECONDS));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;<br>                <span class="hljs-comment">// fallback logic</span><br>            &#125;<br>            <br>    <span class="hljs-comment">// 其中 FutureTask 的实现是：</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>        <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>        <span class="hljs-comment">// 等待结束后抛出异常而不是空指针，否则调用 report 方法</span><br>        <span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>            (s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>        <span class="hljs-keyword">return</span> report(s);<br>    &#125;<br>    <br><span class="hljs-comment">// 约等价于</span><br>其中超时底层的最简单实现是：<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br>    <br>    <span class="hljs-comment">// 循环等待，直到任务完成或超时</span><br>    <span class="hljs-keyword">while</span> (state &lt;= COMPLETING) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> deadline - System.nanoTime();<br>        <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0L</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();  <span class="hljs-comment">// 超时了</span><br>        &#125;<br>        LockSupport.parkNanos(<span class="hljs-built_in">this</span>, remaining);  <span class="hljs-comment">// 等待指定时间</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> report(state);  <span class="hljs-comment">// 返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法2：使用条件变量">方法2：使用条件变量</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发出调用</span><br>condition.await<br><span class="hljs-comment">// 非阻塞地调用 isDone 方法，抛出异常或取值</span><br><span class="hljs-comment">// 这是方法1 的泛化实现</span><br></code></pre></td></tr></table></figure>
<h3 id="方法3：使用-countdownlatch-cyclicbarrier">方法3：使用 countDownLatch/CyclicBarrier</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发出调用</span><br>无锁的 await<br><span class="hljs-comment">// 非阻塞地调用 isDone 方法，抛出异常或取值，但要注意其他线程对 done 状态的维护</span><br></code></pre></td></tr></table></figure>
<p>这个方法不需要依赖于 ReentrantLock，是通过纯 AQS 实现的，见 CountDownLatch 源码。</p>
<h2 id="自定义线程池实现自定义中断">自定义线程池实现自定义中断</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">待补充<br></code></pre></td></tr></table></figure>
<h1>Java 异步执行中的异常处理与线程生命周期</h1>
<h2 id="从-futuretask-asyncuncaughtexceptionhandler-到-uncaughtexceptionhandler">从 FutureTask、AsyncUncaughtExceptionHandler 到 UncaughtExceptionHandler</h2>
<p>在 Java 并发和 Spring 异步执行模型中，异常处理涉及多个抽象层级：<br>
JVM 线程模型、JDK 并发工具以及 Spring 框架本身。</p>
<p>这些层级各自对异常承担不同职责，但它们的行为经常被混淆，典型问题包括：</p>
<ul>
<li>异步任务抛出的异常为何没有日志</li>
<li><code>UncaughtExceptionHandler</code> 在线程池中为何不生效</li>
<li><code>AsyncUncaughtExceptionHandler</code> 是否会影响线程生命周期</li>
</ul>
<p>本文从<strong>线程是否终止</strong>这一确定性问题出发，系统梳理三种机制的边界与协作方式。</p>
<hr>
<h2 id="一-线程是否终止的唯一判定标准">一、线程是否终止的唯一判定标准</h2>
<p>在 JVM 层面，线程是否终止只取决于一个条件：</p>
<blockquote>
<p><strong>是否存在未被捕获、并逃逸出 <code>Thread.run()</code> 的 <code>Throwable</code></strong>。从这个 run 出去以后，就进入 jvm 的cpp 代码的接管范围</p>
</blockquote>
<p>这一规则与使用何种框架无关。</p>
<h3 id="1-1-会导致线程终止的情况">1.1 会导致线程终止的情况</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<ul>
<li>异常未被捕获</li>
<li>异常逃逸出 run()</li>
<li>JVM 调用 UncaughtExceptionHandler</li>
<li>线程终止</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<p>源码位置：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chuyouyinghe/article/details/134306409">Thread 的实现</a><br>
还可以参考这个：<a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《01.崩溃捕获设计实践方案 crash方案》</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">JavaThread::exit</span><span class="hljs-params">(<span class="hljs-type">bool</span> destroy_vm)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_pending_exception</span>()) &#123;<br>        <span class="hljs-function">Handle <span class="hljs-title">exception</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, pending_exception())</span></span>;<br>        <span class="hljs-built_in">clear_pending_exception</span>();<br>        <br>        <span class="hljs-comment">// 直接内联处理，无单独 uncaught_exception 方法</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">threadObj</span>() != <span class="hljs-literal">NULL</span>) &#123;<br>            Klass* klass = SystemDictionary::<span class="hljs-built_in">Thread_klass</span>();<br>            <span class="hljs-comment">// ... 通过 JNI 调用 Java 层 uncaughtException</span><br>            JavaCalls::<span class="hljs-built_in">call_virtual</span>(&amp;result, klass, <br>                                   vmSymbols::<span class="hljs-built_in">uncaughtException_name</span>(),<br>                                   vmSymbols::<span class="hljs-built_in">thread_throwable_void_signature</span>(),<br>                                   &amp;args, <span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant JVM as JVM(C++)
    participant JavaThread as JavaThread(C++)
    participant ThreadJava as java.lang.Thread
    
    JVM-&gt;&gt;JavaThread: 线程执行中抛出异常
    JavaThread-&gt;&gt;JavaThread: set_pending_exception(exception)
    JVM-&gt;&gt;JavaThread: 线程退出调用 exit()
    JavaThread-&gt;&gt;JavaThread: has_pending_exception()
    JavaThread-&gt;&gt;JavaThread: 直接在 exit() 中处理
    JavaThread-&gt;&gt;ThreadJava: JNI call_virtual(&quot;uncaughtException&quot;)
    ThreadJava-&gt;&gt;ThreadJava: 实际调用 java.lang.Thread.uncaughtException
    ThreadJava-&gt;&gt;ThreadJava: dispatchUncaughtException(e)
    ThreadJava-&gt;&gt;ThreadGroup: getUncaughtExceptionHandler()
    ThreadGroup-&gt;&gt;SystemErr: 默认处理</code></pre>
<h3 id="1-2-不会导致线程终止的情况">1.2 不会导致线程终止的情况</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// handled</span><br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<ul>
<li>异常被捕获</li>
<li>JVM 不介入</li>
<li>线程继续运行</li>
</ul>
<p>结论：</p>
<ul>
<li>异常是否被捕获，决定了线程是否终止；</li>
<li>异常由谁处理，并不决定线程生死。</li>
</ul>
<h2 id="二-futuretask-对异常传播路径的改变">二、FutureTask 对异常传播路径的改变</h2>
<p>理解线程池与 Spring 异步行为，必须先理解 FutureTask。</p>
<h3 id="2-1-execute-与-submit-的根本差异">2.1 execute 与 submit 的根本差异</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">executor.execute(runnable);<br>executor.submit(callable);<br></code></pre></td></tr></table></figure>
<p>差异不在返回值，而在执行结构：</p>
<ul>
<li><code>execute</code>：<code>Runnable</code>直接在线程中执行</li>
<li><code>submit</code>：任务先被包装为<code>FutureTask</code>，再执行</li>
</ul>
<h3 id="2-2-futuretask-中的异常拦截点">2.2 FutureTask 中的异常拦截点</h3>
<p>FutureTask.run() 的核心逻辑如下（简化）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        callable.call();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        setException(ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键点：</p>
<ul>
<li>Throwable 被主动捕获</li>
<li>异常不会逃逸出 run()</li>
<li>JVM 不认为线程发生未捕获异常<br>
线程不会终止</li>
</ul>
<p>异常在这里已经脱离“线程异常”的语义。</p>
<h3 id="2-3-异常如何被重新抛出：report">2.3 异常如何被重新抛出：report()</h3>
<p>异常并未消失，而是作为执行结果存储：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">outcome = ex;<br>state = EXCEPTIONAL;<br></code></pre></td></tr></table></figure>
<p>在调用<code>Future.get()</code>时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;<br>    <span class="hljs-keyword">if</span> (s == NORMAL)<br>        <span class="hljs-keyword">return</span> (V) x;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable) x);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>report()</code>的职责是：</p>
<ul>
<li>将“执行结果状态”翻译为 Java 异常语义</li>
<li>将原始异常包装为 ExecutionException</li>
</ul>
<p>结论：</p>
<blockquote>
<p>FutureTask 将异常从“线程控制流”转移为“任务结果数据”。</p>
</blockquote>
<h2 id="三-uncaughtexceptionhandler-的职责边界">三、UncaughtExceptionHandler 的职责边界</h2>
<h3 id="3-1-触发条件">3.1 触发条件</h3>
<p><code>UncaughtExceptionHandler</code>仅在以下条件满足时被调用：</p>
<ul>
<li>异常未被捕获</li>
<li>异常逃逸出<code>Thread.run()</code></li>
<li>线程即将终止</li>
</ul>
<p>JVM 调用顺序为：</p>
<ol>
<li>Thread 自身的 handler</li>
<li>ThreadGroup</li>
<li>DefaultUncaughtExceptionHandler</li>
<li>JVM 默认 stderr</li>
</ol>
<h3 id="3-2-能力与限制">3.2 能力与限制</h3>
<p><code>UncaughtExceptionHandler</code>：</p>
<ul>
<li>无法阻止线程终止</li>
<li>无法恢复线程执行</li>
<li>仅用于日志、告警等系统级兜底</li>
</ul>
<p>在线程池中，只有 <code>execute()</code>且异常未被捕获时，才可能触发该 handler。</p>
<h2 id="四-spring-asyncuncaughtexceptionhandler-的作用范围">四、Spring AsyncUncaughtExceptionHandler 的作用范围</h2>
<h3 id="4-1-适用条件">4.1 适用条件</h3>
<p>Spring 明确限定：</p>
<ul>
<li>仅处理 @Async 标注的 void 方法</li>
<li>不处理返回 Future / CompletableFuture 的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Async</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-2-spring-的异常拦截方式">4.2 Spring 的异常拦截方式</h3>
<p>Spring 在异步调用边界处捕获异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    invokeMethod();<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>    asyncUncaughtExceptionHandler.handle(ex, method, params);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-3-对线程生命周期的影响">4.3 对线程生命周期的影响</h3>
<p><code>AsyncUncaughtExceptionHandler</code>：</p>
<ul>
<li>不会阻止线程终止</li>
<li>也不会导致线程终止</li>
</ul>
<p>原因是：</p>
<ul>
<li>异常已经被 Spring 捕获</li>
<li>JVM 无法感知未捕获异常</li>
<li>线程本身没有死亡条件</li>
</ul>
<p>结论：</p>
<ul>
<li>AsyncUncaughtExceptionHandler 只影响异常的业务处理路径，不影响线程生命周期。</li>
</ul>
<h2 id="五-三种异常路径的对比">五、三种异常路径的对比</h2>
<h3 id="5-1-async-void-方法">5.1 @Async void 方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Async</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">方法执行<br> → Spring 捕获<br> → AsyncUncaughtExceptionHandler<br> → 线程继续运行<br></code></pre></td></tr></table></figure>
<h3 id="5-2-线程池execute">5.2 线程池<code>execute</code></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">executor.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable.run<br> → 异常逃逸<br> → JVM<br> → UncaughtExceptionHandler<br> → 线程终止<br></code></pre></td></tr></table></figure>
<h3 id="5-3-线程池-submit">5.3 线程池 submit</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;?&gt; future = executor.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask.run<br> → <span class="hljs-keyword">catch</span> Throwable<br> → 异常存入 Future<br> → get() 时抛 ExecutionException<br></code></pre></td></tr></table></figure>
<h2 id="六-两种-handler-的推荐使用方式">六、两种 Handler 的推荐使用方式</h2>
<h3 id="6-1-asyncuncaughtexceptionhandler-业务层">6.1 AsyncUncaughtExceptionHandler（业务层）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AsyncConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> AsyncUncaughtExceptionHandler <span class="hljs-title function_">getAsyncUncaughtExceptionHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (ex, method, params) -&gt; &#123;<br>            log.error(<span class="hljs-string">&quot;Async void method failed: &#123;&#125;&quot;</span>, method.getName(), ex);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li>@Async void 方法</li>
<li>业务补偿、告警、日志</li>
</ul>
<h3 id="6-2-uncaughtexceptionhandler-系统层">6.2 UncaughtExceptionHandler（系统层）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> r -&gt; &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>    t.setUncaughtExceptionHandler((thread, ex) -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Thread &#123;&#125; terminated&quot;</span>, thread.getName(), ex);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;;<br><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(),<br>    factory<br>);<br></code></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li><code>execute()</code>执行的任务</li>
<li>系统级兜底监控</li>
</ul>
<h3 id="6-3-有返回值的异步任务">6.3 有返回值的异步任务</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture<br>    .supplyAsync(<span class="hljs-built_in">this</span>::work, executor)<br>    .exceptionally(ex -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Async failed&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<p>必须显式消费异常，否则异常不会被观察到。</p>
<h2 id="结论">结论</h2>
<ol>
<li>线程是否终止，仅由异常是否逃逸到 JVM 决定</li>
<li>FutureTask 和 Spring 已在更高层捕获异常，因此不会触发 JVM 机制</li>
<li>AsyncUncaughtExceptionHandler 不控制线程生死，仅提供业务回调</li>
<li>UncaughtExceptionHandler 只用于处理线程终止前的系统级事件</li>
</ol>
<h1>Spring 的异步支持</h1>
<ul>
<li>如果只是<code>@EnableAsync</code>，Spring 会创建一个默认的 SimpleAsyncTaskExecutor（注意不是 ThreadPoolTaskExecutor）：
<ul>
<li><strong>每个任务都会创建新线程</strong></li>
<li>没有线程池复用</li>
<li>性能较差，不适合生产环境</li>
</ul>
</li>
<li>在这个基础上，再实现<code>AsyncConfigurer.getAsyncExecutor()</code>就可以让自己的线程池替代框架的 Bean。</li>
</ul>
<h2 id="threadpooltaskexecutor">ThreadPoolTaskExecutor</h2>
<p>ThreadPoolTaskExecutor 是 ExecutorConfigurationSupport 的子类，也包装了一个 ThreadPoolExecutor。</p>
<ul>
<li>ExecutorConfigurationSupport 作为基类提供了：
<ul>
<li>生命周期管理：实现了 InitializingBean, DisposableBean</li>
<li>配置管理：线程工厂、拒绝策略、优雅关闭等配置</li>
<li>模板方法：定义了初始化和销毁的标准流程</li>
</ul>
</li>
</ul>
<p>特别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>    initialize();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isInfoEnabled()) &#123;<br>        <span class="hljs-built_in">this</span>.logger.info(<span class="hljs-string">&quot;Initializing ExecutorService &quot;</span> + (<span class="hljs-built_in">this</span>.beanName != <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot; &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.beanName + <span class="hljs-string">&quot;&#x27;&quot;</span> : <span class="hljs-string">&quot;&quot;</span>));<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.threadNamePrefixSet &amp;&amp; <span class="hljs-built_in">this</span>.beanName != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.setThreadNamePrefix(<span class="hljs-built_in">this</span>.beanName + <span class="hljs-string">&quot;-&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 调用子类的具体实现</span><br>    <span class="hljs-built_in">this</span>.executor = <span class="hljs-built_in">this</span>.initializeExecutor(<span class="hljs-built_in">this</span>.threadFactory, <span class="hljs-built_in">this</span>.rejectedExecutionHandler);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以在这个 bean 被使用以前，内部线程池要经过一个 afterPropertiesSet 驱动进行初始化和注入这个 ThreadPoolTaskExecutor 线程池外壳。</p>
<h2 id="threadpooltaskexecutor-内部线程池的替换">ThreadPoolTaskExecutor 内部线程池的替换</h2>
<h3 id="推荐：使用初始化器装饰">推荐：使用初始化器装饰</h3>
<p>initializeExecutor 初始化过程里会允许我们装饰这个线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> ExecutorService <span class="hljs-title function_">initializeExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">        ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;<br><br>    BlockingQueue&lt;Runnable&gt; queue = createQueue(<span class="hljs-built_in">this</span>.queueCapacity);<br><br>    ThreadPoolExecutor executor;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.taskDecorator != <span class="hljs-literal">null</span>) &#123;<br>        executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-built_in">this</span>.corePoolSize, <span class="hljs-built_in">this</span>.maxPoolSize, <span class="hljs-built_in">this</span>.keepAliveSeconds, TimeUnit.SECONDS,<br>                queue, threadFactory, rejectedExecutionHandler) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>                <span class="hljs-type">Runnable</span> <span class="hljs-variable">decorated</span> <span class="hljs-operator">=</span> taskDecorator.decorate(command);<br>                <span class="hljs-keyword">if</span> (decorated != command) &#123;<br>                    decoratedTaskMap.put(decorated, command);<br>                &#125;<br>                <span class="hljs-built_in">super</span>.execute(decorated);<br>            &#125;<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-built_in">this</span>.corePoolSize, <span class="hljs-built_in">this</span>.maxPoolSize, <span class="hljs-built_in">this</span>.keepAliveSeconds, TimeUnit.SECONDS,<br>                queue, threadFactory, rejectedExecutionHandler);<br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.allowCoreThreadTimeOut) &#123;<br>        executor.allowCoreThreadTimeOut(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.threadPoolExecutor = executor;<br>    <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>java 线程池的装饰逻辑就是<strong>只覆盖一个</strong><code>public void execute(Runnable command)</code>即可。</p>
<p>这个方法本质上是<strong>一切线程池外部提交/执行操作的入口</strong>，所以<strong>它的执行线程是外部线程而已不是工作线程</strong>。</p>
<p>可以说<strong>这个壳的其他方法都只是包装一下普通线程的成员方法，但是这个 initializeExecutor 和 decorate 是这个壳特有的，是它存在的意义</strong>。</p>
<p>所有外部 command 在执行前都要被 decorate 一下，而且存在 decoratedTaskMap 里，模式是装饰后-&gt;原始命令。目前这个map没有用处，未来可能在用修饰后的任务找原始 Runnable 的时候会有用。</p>
<h3 id="其他代理">其他代理</h3>
<p>其他方法都是用<strong>类似的模式来代理的，而且不支持多态</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> getThreadPoolExecutor();<br>    <span class="hljs-keyword">try</span> &#123;<br>        executor.execute(task);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskRejectedException</span>(<span class="hljs-string">&quot;Executor [&quot;</span> + executor + <span class="hljs-string">&quot;] did not accept task: &quot;</span> + task, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="如果我们要替换线程池实现">如果我们要替换线程池实现</h3>
<p>我们只能用反射来替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;bizCommonTaskExecutor&quot;)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ThreadPoolTaskExecutor <span class="hljs-title function_">getAsyncExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建支持EagleEye上下文传递的ThreadPoolTaskExecutor</span><br>    <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">taskExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> ThreadPoolExecutor <span class="hljs-title function_">initializeExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">                ThreadFactory threadFactory,</span><br><span class="hljs-params">                RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;<br>            <span class="hljs-comment">// 创建阻塞队列</span><br>            BlockingQueue&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY);<br>            <br>            <span class="hljs-comment">// 创建支持EagleEye上下文传递的线程池</span><br>            <span class="hljs-type">EagleEyeContextAwareThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EagleEyeContextAwareThreadPoolExecutor</span>(<br>                CORE_POOL_SIZE,<br>                MAX_POOL_SIZE,<br>                KEEP_ALIVE_SECONDS,<br>                TimeUnit.SECONDS,<br>                queue,<br>                threadFactory,<br>                rejectedExecutionHandler<br>            );<br><br>            <span class="hljs-comment">// 使用反射将executor赋值给父类的private threadPoolExecutor字段，这是目前唯一的方法</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                java.lang.reflect.<span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> ThreadPoolTaskExecutor.class.getDeclaredField(<span class="hljs-string">&quot;threadPoolExecutor&quot;</span>);<br>                field.setAccessible(<span class="hljs-literal">true</span>);<br>                field.set(<span class="hljs-built_in">this</span>, executor);<br>                <span class="hljs-comment">// 如果有必要，要存储老的 accessible，在 set 完了以后要还原</span><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LoggerUtils.error(LOGGER, <span class="hljs-string">&quot;Failed to set threadPoolExecutor via reflection&quot;</span>, e);<br>            &#125;<br>            <br>            <span class="hljs-keyword">return</span> executor;<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-comment">// 配置线程名前缀</span><br>    taskExecutor.setThreadNamePrefix(<span class="hljs-string">&quot;bd-common-async-&quot;</span>);<br>    <br>    <span class="hljs-comment">// 配置优雅停机</span><br>    taskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="hljs-literal">true</span>);<br>    taskExecutor.setAwaitTerminationSeconds(AWAIT_TERMINATION_SECONDS);<br>    <br>    <span class="hljs-keyword">return</span> taskExecutor;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们不推荐使用这种做法，除非我们真的<strong>有增强 execute 以外的诉求</strong>。</p>
<h2 id="对线程池实行-trace-传递">对线程池实行 trace 传递</h2>
<h3 id="如果使用统一包装器">如果使用统一包装器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法的第一层参数是 ThreadPoolTaskExecutor 的 execute 执行的时候的这个 command：</span><br><span class="hljs-comment">//              public void execute(Runnable command) &#123;</span><br><span class="hljs-comment">//                  Runnable decorated = taskDecorator.decorate(command);</span><br> taskExecutor.setTaskDecorator(runnable -&gt; &#123;<br>            <br>            <span class="hljs-comment">// 这里获取外部提交的时候的线程和上下文</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">submitThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <br>            <span class="hljs-comment">// 这里返回一个 runnable，给外部的 super.execute(decorated); 使用，这个方法就是原始线程池的 execute 了</span><br>            <span class="hljs-keyword">return</span> () -&gt; &#123;<br>                <span class="hljs-comment">// 这里开始执行的时候通常已经进入线程池的 worker 内部了</span><br>                <br>                <span class="hljs-comment">// 当拒绝策略为 CallerRunsPolicy 且在提交线程中执行时，直接运行即可</span><br>                <span class="hljs-keyword">if</span> (submitThread == Thread.currentThread()) &#123;<br>                    runnable.run();<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">oldContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (oldContext == <span class="hljs-literal">null</span>) &#123;<br>                        needClean = <span class="hljs-literal">true</span>;<br>                        EagleEye.setRpcContext(rpcContext);<br>                    &#125;<br>                    <span class="hljs-comment">// 这是在内部线程 run 之前执行的围绕操作</span><br>                    runnable.run();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span> (needClean) &#123;<br>                        EagleEye.clearRpcContext();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>        &#125;);<br></code></pre></td></tr></table></figure>
<p>其中装饰器被调用的地方是就是上面的<a href="#%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E8%A3%85%E9%A5%B0">使用初始化器装饰</a>。</p>
<p>本质上 executor 共有三个入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (EagleEye.currentRpcContext() == <span class="hljs-literal">null</span>) &#123;<br>                needClean = <span class="hljs-literal">true</span>;<br>                EagleEye.setRpcContext(rpcContext);<br>            &#125;<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (needClean) &#123;<br>                    EagleEye.clearRpcContext();<br>                &#125;<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (EagleEye.currentRpcContext() == <span class="hljs-literal">null</span>) &#123;<br>                needClean = <span class="hljs-literal">true</span>;<br>                EagleEye.setRpcContext(rpcContext);<br>            &#125;<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (needClean) &#123;<br>                    EagleEye.clearRpcContext();<br>                &#125;<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>    <span class="hljs-keyword">if</span> (command <span class="hljs-keyword">instanceof</span> FutureTask) &#123;<br>        <span class="hljs-built_in">super</span>.execute(command);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.execute(() -&gt; &#123;<br>            EagleEye.setRpcContext(rpcContext);<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                command.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                EagleEye.clearRpcContext();<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>前两个 newTaskFor 是其他 submit 方法到 execute 之前的底层方法。因为前两个入口最终都会调到<code>execute(Runnable command)</code>，所以它的内部要避开<code>if (command instanceof FutureTask) {</code>的场景。这个设计因此显得比较累赘。</p>
<p>实际上 decorator 的实现就是最佳的，最终只要实现一个 execute 的包装提交就行了。</p>
<p>这个实现里有一个地方要注意：执行完当前的 runnable 需要 clear，否则可能会出现以前有的遗留 traceId 污染的问题。</p>
<p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">《一行一行源码分析清楚AbstractQueuedSynchronizer》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《Java线程池实现原理及其在美团业务中的实践》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">《CompletableFuture原理与实践-外卖商家端API的异步化》</a></li>
</ol>
<hr>
<h1>ForkJoinPool详解：分治并行的执行引擎</h1>
<p><img src="java-thread-x-forkjoin-%E5%8F%AA%E5%8F%91%E7%94%9F%E5%9C%A8%E5%90%8C%E5%B1%82%E4%B9%8B%E9%97%B4.png" alt="java-thread-x-forkjoin-只发生在同层之间.png"></p>
<h2 id="前言：分治并行的诞生">前言：分治并行的诞生</h2>
<p>ForkJoinPool 不是为了通用&quot;并行&quot;而设计，而是专门为<strong>分治并行</strong>（Divide-and-Conquer Parallelism）这一特定模式量身定制。分治算法（如快速排序、归并排序、树遍历）具有独特的执行模式：</p>
<ul>
<li>任务天然形成树状结构</li>
<li>父任务派生子任务后需要等待结果</li>
<li>子任务之间通常无依赖关系</li>
<li>计算密集，无I/O阻塞</li>
</ul>
<p>理解分治算法的执行特性，是理解 ForkJoinPool 设计的关键。传统线程池在处理这类任务时遇到根本性挑战，ForkJoinPool 正是为解决这些挑战而诞生。</p>
<h2 id="1-核心数据结构：forkjoinpool的基石">1. 核心数据结构：ForkJoinPool的基石</h2>
<h3 id="1-1-forkjoinpool：去中心化的调度器">1.1 ForkJoinPool：去中心化的调度器</h3>
<h4 id="数据结构定义">数据结构定义</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-comment">// 64位控制状态：编码活跃线程数、空闲线程数、任务计数</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> ctl;<br>    <br>    <span class="hljs-comment">// 工作队列数组：每个工作线程一个队列</span><br>    <span class="hljs-keyword">volatile</span> WorkQueue[] workQueues; <span class="hljs-comment">// 与TPE的关键区别：TPE用HashSet&lt;Worker&gt;持有线程，</span><br>                                     <span class="hljs-comment">// 而FJP不需要持有工作线程集合，因为：</span><br>                                     <span class="hljs-comment">// 1. 线程通过ctl字段的位操作管理</span><br>                                     <span class="hljs-comment">// 2. 任务调度通过workQueues数组实现</span><br>                                     <span class="hljs-comment">// 3. 工作窃取算法只需要访问队列，不需要直接访问线程</span><br>    <br>    <span class="hljs-comment">// 专用线程工厂</span><br>    <span class="hljs-keyword">final</span> ForkJoinWorkerThreadFactory factory;<br>    <br>    <span class="hljs-comment">// 未捕获异常处理器</span><br>    <span class="hljs-keyword">final</span> UncaughtExceptionHandler ueh;<br>    <br>    <span class="hljs-comment">// 配置参数</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> config; <span class="hljs-comment">// 低16位：并行度（parallelism）</span><br>    <br>    <span class="hljs-comment">// 静态公共池</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ForkJoinPool <span class="hljs-title function_">commonPool</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="与threadpoolexecutor的本质区别">与ThreadPoolExecutor的本质区别</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadPoolExecutor的核心结构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue; <span class="hljs-comment">// 单一共享队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers;          <span class="hljs-comment">// Worker线程集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> corePoolSize;               <span class="hljs-comment">// 核心线程数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> maximumPoolSize;            <span class="hljs-comment">// 最大线程数</span><br>&#125;<br><br><span class="hljs-comment">// ForkJoinPool的核心结构</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinPool</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractExecutorService</span> &#123;<br>    <span class="hljs-keyword">volatile</span> WorkQueue[] workQueues;                <span class="hljs-comment">// 工作队列数组，每个 ForkjoinWokerThread 持有一个 workQueue，这个池就持有一个 workQueue 数组</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> ctl;                              <span class="hljs-comment">// 64位状态控制</span><br>    <span class="hljs-comment">// 无corePoolSize/maximumPoolSize概念</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="关键差异">关键差异</h4>
<ul>
<li><strong>队列模型</strong>：TPE使用单一共享队列，FJP使用每个线程私有队列</li>
<li><strong>线程管理</strong>：TPE有明确的core/max参数，FJP只有目标并行度</li>
<li><strong>调度策略</strong>：TPE基于生产者-消费者模型，FJP基于工作窃取模型</li>
</ul>
<h3 id="1-2-forkjoinworkerthreadfactory：专用线程工厂">1.2 ForkJoinWorkerThreadFactory：专用线程工厂</h3>
<h4 id="接口定义与对比">接口定义与对比</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 标准ThreadFactory接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ThreadFactory</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建新线程</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r 线程要执行的Runnable</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 新线程</span><br><span class="hljs-comment">     */</span><br>    Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span>;<br>&#125;<br><br><span class="hljs-comment">// ForkJoinWorkerThreadFactory接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ForkJoinWorkerThreadFactory</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建新的ForkJoinWorkerThread</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> pool 线程所属的ForkJoinPool</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 新的工作线程</span><br><span class="hljs-comment">     */</span><br>    ForkJoinWorkerThread <span class="hljs-title function_">newThread</span><span class="hljs-params">(ForkJoinPool pool)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="关键区别">关键区别</h4>
<ul>
<li>完全不同的接口：两者没有继承关系，签名完全不同</li>
<li>上下文差异：标准工厂只接收Runnable，即任务，负责包装出线程；FJP工厂接收 ForkJoinPool 即线程池。</li>
<li>线程定制能力：线程工厂通常可以设置：
<ul>
<li>线程名称（便于调试）</li>
<li>线程优先级（Thread.setPriority()）</li>
<li>守护状态（Thread.setDaemon()）</li>
<li>上下文类加载器（Thread.setContextClassLoader()）</li>
<li>异常处理器（Thread.setUncaughtExceptionHandler()）</li>
<li>为什么在工厂里创建，传统工厂使用这个接口把任务包装成进程，并且启动：<code>thread.start(); // 一旦 start()，大部分属性就无法修改了</code></li>
</ul>
</li>
</ul>
<h5 id="fjp-的扩展方法">FJP 的扩展方法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinPool;<br><span class="hljs-keyword">import</span> java.util.concurrent.ForkJoinWorkerThread;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomForkJoinWorkerThreadFactory</span> <br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ForkJoinPool</span>.ForkJoinWorkerThreadFactory &#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">threadNumber</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String poolName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> threadPriority;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader contextClassLoader;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">CustomForkJoinWorkerThreadFactory</span><span class="hljs-params">(</span><br><span class="hljs-params">        String poolName, </span><br><span class="hljs-params">        <span class="hljs-type">int</span> threadPriority,</span><br><span class="hljs-params">        ClassLoader contextClassLoader</span><br><span class="hljs-params">    )</span> &#123;<br>        <span class="hljs-built_in">this</span>.poolName = poolName;<br>        <span class="hljs-built_in">this</span>.threadPriority = threadPriority;<br>        <span class="hljs-built_in">this</span>.contextClassLoader = contextClassLoader;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ForkJoinWorkerThread <span class="hljs-title function_">newThread</span><span class="hljs-params">(ForkJoinPool pool)</span> &#123;<br>        <span class="hljs-comment">// 1. 使用默认工厂创建基础线程</span><br>        <span class="hljs-type">ForkJoinWorkerThread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> ForkJoinPool.defaultForkJoinWorkerThreadFactory.newThread(pool);<br>        <br>        <span class="hljs-comment">// 2. 自定义线程名称（便于调试）</span><br>        thread.setName(String.format(<span class="hljs-string">&quot;%s-worker-%d&quot;</span>, poolName, threadNumber.getAndIncrement()));<br>        <br>        <span class="hljs-comment">// 3. 设置线程优先级</span><br>        thread.setPriority(threadPriority);<br>        <br>        <span class="hljs-comment">// 4. 设置上下文类加载器</span><br>        thread.setContextClassLoader(contextClassLoader);<br>        <br>        <span class="hljs-comment">// 5. 设置未捕获异常处理器（线程级别的）</span><br>        thread.setUncaughtExceptionHandler((t, e) -&gt; &#123;<br>            System.err.printf(<span class="hljs-string">&quot;[%s] 线程 %s 发生未捕获异常: %s%n&quot;</span>, <br>                poolName, t.getName(), e.getMessage());<br>            e.printStackTrace();<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 6. 其他自定义设置</span><br>        thread.setDaemon(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 虽然ForkJoinPool会强制设置，但这里显式设置</span><br>        <br>        System.out.printf(<span class="hljs-string">&quot;创建工作线程: %s, 优先级: %d, 类加载器: %s%n&quot;</span>,<br>            thread.getName(), thread.getPriority(), contextClassLoader.getClass().getSimpleName());<br>        <br>        <span class="hljs-keyword">return</span> thread;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="设计意义">设计意义</h4>
<blockquote>
<p>FJP的工作线程需要知道池的存在，才能参与工作窃取算法。标准ThreadFactory无法提供这种上下文，因此需要专用接口。</p>
</blockquote>
<h3 id="1-3-forkjoinworkerthread：协作式执行者">1.3 ForkJoinWorkerThread：协作式执行者</h3>
<h4 id="数据结构">数据结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinWorkerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-comment">// 所属线程池</span><br>    <span class="hljs-keyword">final</span> ForkJoinPool pool;<br>    <br>    <span class="hljs-comment">// 专属工作队列（由池在registerWorker时分配，而非构造函数直接创建）</span><br>    <span class="hljs-keyword">final</span> WorkQueue workQueue;<br>    <br>    <span class="hljs-comment">// 构造函数（简化示意）</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">ForkJoinWorkerThread</span><span class="hljs-params">(ForkJoinPool pool)</span> &#123;<br>        <span class="hljs-built_in">this</span>.pool = pool;<br>        <span class="hljs-comment">// 注意：WorkQueue 不是在这里直接 new 出来的</span><br>        <span class="hljs-comment">// 实际流程是调用 pool.registerWorker(this)，由池统一分配队列</span><br>        <span class="hljs-comment">// 这确保了 WorkQueue 在 workQueues 数组中的索引由池统一管理</span><br>        <span class="hljs-built_in">this</span>.workQueue = pool.registerWorker(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="与threadpoolexecutor-worker的对比">与ThreadPoolExecutor.Worker的对比</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadPoolExecutor.Worker（组合模式）</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">final</span> Thread thread;       <span class="hljs-comment">// 通过组合持有Thread</span><br>    Runnable firstTask;        <span class="hljs-comment">// 初始任务。任务和执行线程解耦，是兄弟成员。这个成员只使用一次，就在 addWorker 的时候减少对拥塞队列的锁竞争</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks; <span class="hljs-comment">// 完成任务数</span><br>&#125;<br><br><span class="hljs-comment">// ForkJoinWorkerThread（继承模式）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinWorkerThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">final</span> ForkJoinPool pool;   <span class="hljs-comment">// 直接持有池引用</span><br>    <span class="hljs-keyword">final</span> WorkQueue workQueue; <span class="hljs-comment">// 专属队列</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>Worker：“可以自锁定的 runnable，初始化是把自己装进 Thread 里，run 是在线程里自旋获取拥塞队列里的任务”。</li>
<li>ForkJoinWorkerThread：“具有自主窃取能力的协作线程，run 是在本地队列空闲时主动扫描并窃取其他工作队列任务的群体智能执行器”。</li>
</ol>
<h4 id="设计决策">设计决策</h4>
<ul>
<li><strong>Worker使用组合</strong>：TPE的工作线程只需执行任务，无需特殊行为</li>
<li><strong>FJP使用继承</strong>：需要重写run()实现工作窃取，且需要池上下文。继承意味着可以直接使用线程的生命周期方法。</li>
</ul>
<h4 id="线程安全特性：为什么forkjoinpool不会有线程泄露问题？">线程安全特性：为什么ForkJoinPool不会有线程泄露问题？</h4>
<p>ForkJoinPool 在线程管理上具有两个关键特性，使其天然避免了线程泄露问题：</p>
<p><strong>1. 所有工作线程都是 Daemon 线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinPool.registerWorker() 源码片段</span><br><span class="hljs-keyword">final</span> WorkQueue <span class="hljs-title function_">registerWorker</span><span class="hljs-params">(ForkJoinWorkerThread wt)</span> &#123;<br>    wt.setDaemon(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// 强制设置为守护线程</span><br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这意味着：</p>
<ul>
<li>即使忘记调用 <code>shutdown()</code>，ForkJoinPool 的线程也<strong>不会阻止 JVM 退出</strong></li>
<li>当所有非 daemon 线程结束时，JVM 会自动终止，daemon 线程随之销毁</li>
<li>与 ThreadPoolExecutor 的关键区别：TPE 默认创建非 daemon 线程，忘记关闭会导致 JVM 无法退出</li>
</ul>
<p><strong>2. 空闲线程会被自动回收</strong></p>
<p>根据 Javadoc 文档：</p>
<blockquote>
<p>“Using the common pool normally reduces resource usage (its threads are slowly reclaimed during periods of non-use, and reinstated upon subsequent use).”</p>
</blockquote>
<p>ForkJoinPool 的线程回收机制：</p>
<ul>
<li>空闲线程不会立即销毁，而是先 <code>park()</code> 等待</li>
<li>空闲时间超过阈值后，线程主动退出 <code>run()</code> 循环</li>
<li>下次需要时重新创建，避免永久空闲线程占用资源</li>
</ul>
<p><strong>结论</strong>：由于 daemon 线程 + 自动回收机制的双重保障，ForkJoinPool 在实践中几乎不会出现线程泄露问题。但这<strong>不意味着可以忽略资源管理</strong>——对于自定义创建的 ForkJoinPool，仍建议使用 <code>try-with-resources</code>（JDK 19+）或 <code>try-finally</code> 显式关闭，以确保及时释放内部资源。</p>
<h3 id="1-4-workqueue：双端队列的实现">1.4 WorkQueue：双端队列的实现</h3>
<h4 id="数据结构">数据结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkQueue</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> base;          <span class="hljs-comment">// 队列头部索引（公开，供窃取）</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> top;           <span class="hljs-comment">// 队列尾部索引（虽主要由owner修改，但需volatile保证可见性）</span><br>    ForkJoinTask&lt;?&gt;[] array;    <span class="hljs-comment">// 任务数组（环形缓冲区）</span><br>    <span class="hljs-keyword">final</span> ForkJoinPool pool;    <span class="hljs-comment">// 所属池</span><br>    <span class="hljs-keyword">final</span> ForkJoinWorkerThread owner; <span class="hljs-comment">// 所属线程（外部提交队列的owner为null）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="核心操作">核心操作</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 本地push (LIFO)</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(ForkJoinTask&lt;?&gt; task)</span> &#123;<br>    ForkJoinTask&lt;?&gt;[] a = array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> top, cap = a.length;<br>    a[s &amp; (cap - <span class="hljs-number">1</span>)] = task;  <span class="hljs-comment">// 写入尾部</span><br>    top = s + <span class="hljs-number">1</span>;              <span class="hljs-comment">// 仅本线程修改，无锁</span><br>&#125;<br><br><span class="hljs-comment">// 本地pop (LIFO)</span><br><span class="hljs-keyword">final</span> ForkJoinTask&lt;?&gt; pop() &#123;<br>    ForkJoinTask&lt;?&gt;[] a = array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> top, cap = a.length;<br>    <span class="hljs-keyword">if</span> (s != base) &#123;          <span class="hljs-comment">// 队列非空</span><br>        ForkJoinTask&lt;?&gt; t = a[--s &amp; (cap - <span class="hljs-number">1</span>)]; <span class="hljs-comment">// 从尾部取</span><br>        a[s &amp; (cap - <span class="hljs-number">1</span>)] = <span class="hljs-literal">null</span>;<br>        top = s;<br>        <span class="hljs-keyword">return</span> t;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-comment">// 窃取poll (FIFO)</span><br><span class="hljs-keyword">final</span> ForkJoinTask&lt;?&gt; poll() &#123;<br>    ForkJoinTask&lt;?&gt;[] a = array;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> base, cap = a.length;<br>    <span class="hljs-keyword">if</span> (b != top) &#123;           <span class="hljs-comment">// 队列非空</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> b &amp; (cap - <span class="hljs-number">1</span>);<br>        ForkJoinTask&lt;?&gt; t = a[i];<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; <br>            base == b &amp;&amp;      <span class="hljs-comment">// 检查base未变</span><br>            UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, BASE, b, b + <span class="hljs-number">1</span>)) &#123; <span class="hljs-comment">// CAS更新</span><br>            a[i] = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="lifo-fifo-的设计智慧：">LIFO + FIFO 的设计智慧：</h4>
<ul>
<li>本地LIFO：最近派生的任务最先执行，保持时间局部性（temporal locality）：
<ul>
<li>时间局部性：最近访问的数据很可能再次被访问</li>
<li>在分治算法中，最近派生的任务通常与父任务共享数据</li>
<li>保持这些数据在CPU缓存中，避免缓存失效惩罚</li>
</ul>
</li>
<li>窃取FIFO：最早派生的任务最先被窃取，保证窃取到&quot;大块&quot;任务
<ul>
<li>&quot;大块任务&quot;解释：这不是编程隐喻，而是指计算量大的任务。在分治算法中：
<ul>
<li>最早派生的任务通常是父任务分解的第一层子任务，包含大量工作</li>
<li>最近派生的任务通常是深层子任务，计算量较小</li>
</ul>
</li>
<li>例如快速排序中，根任务分解为左右子任务，这两个是&quot;大块任务&quot;；而叶子节点任务只处理几个元素，是&quot;小块任务&quot;</li>
<li>本地LIFO执行小任务（保持缓存），窃取FIFO获取大任务（避免任务碎片化）</li>
</ul>
</li>
</ul>
<h4 id="forkjointask-join-与-thread-join-的本质差异">ForkJoinTask.join() 与 Thread.join() 的本质差异</h4>
<p>这是 ForkJoinPool 能够高效处理海量递归任务而不会死锁的关键机制。两种 join 有着根本性的不同。</p>
<p><strong>Thread.join() - 阻塞式等待</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread.join() 的行为</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; doWork());<br>thread.start();<br>thread.join();  <span class="hljs-comment">// 当前线程进入 WAITING 状态，完全放弃 CPU</span><br></code></pre></td></tr></table></figure>
<p>当调用 <code>Thread.join()</code> 时：</p>
<ol>
<li>调用线程进入 <strong>WAITING</strong> 状态</li>
<li>线程被操作系统挂起，<strong>完全停止执行</strong></li>
<li>直到目标线程结束，调用线程才被唤醒</li>
<li>这是<strong>操作系统级别的线程阻塞</strong></li>
</ol>
<p><strong>ForkJoinTask.join() - 协作式等待</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinTask.join() 的行为</span><br>RecursiveTask&lt;Integer&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveTask</span>&lt;&gt;() &#123;<br>    <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        RecursiveTask&lt;Integer&gt; subtask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveTask</span>&lt;&gt;() &#123; <span class="hljs-comment">/* ... */</span> &#125;;<br>        subtask.fork();<br>        <span class="hljs-keyword">return</span> subtask.join();  <span class="hljs-comment">// 不会阻塞工作线程</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p>当调用 <code>ForkJoinTask.join()</code> 时：</p>
<ol>
<li>工作线程<strong>不会进入 WAITING 状态</strong></li>
<li>线程继续执行其他任务（work-stealing）</li>
<li>定期检查等待的任务是否完成</li>
<li>这是<strong>用户态的协作式调度</strong></li>
</ol>
<p><strong>关键差异对比</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 A
    participant T2 as 线程 B
    participant OS as 操作系统
    
    Note over T1,OS: Thread.join() - 阻塞式
    T1-&gt;&gt;T2: 启动线程 B
    T1-&gt;&gt;T1: 调用 threadB.join()
    T1-&gt;&gt;OS: 进入 WAITING 状态
    OS-&gt;&gt;T1: 挂起线程 A
    Note over T1: 线程 A 停止执行
    T2-&gt;&gt;T2: 执行任务
    T2-&gt;&gt;OS: 线程 B 结束
    OS-&gt;&gt;T1: 唤醒线程 A
    T1-&gt;&gt;T1: 继续执行
    
    Note over T1,OS: ForkJoinTask.join() - 协作式
    T1-&gt;&gt;T1: 调用 task.join()
    alt 任务已完成
        T1-&gt;&gt;T1: 直接返回结果
    else 任务未完成
        T1-&gt;&gt;T1: 尝试执行该任务
        alt 任务在本地队列
            T1-&gt;&gt;T1: 直接执行任务
        else 任务在其他队列
            T1-&gt;&gt;T1: 窃取其他任务执行
            T1-&gt;&gt;T1: 定期检查任务状态
        end
    end
    Note over T1: 线程 A 始终保持 RUNNABLE</code></pre>
<p><strong>为什么 ForkJoinTask.join() 不会导致死锁</strong></p>
<p>考虑这个递归场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveSum</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Long&gt; &#123;<br>    <span class="hljs-keyword">protected</span> Long <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (size &lt;= THRESHOLD) &#123;<br>            <span class="hljs-keyword">return</span> computeDirectly();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 父任务等待子任务</span><br>        <span class="hljs-type">RecursiveSum</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveSum</span>(leftHalf);<br>        <span class="hljs-type">RecursiveSum</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RecursiveSum</span>(rightHalf);<br>        <br>        left.fork();   <span class="hljs-comment">// 提交到队列</span><br>        right.fork();  <span class="hljs-comment">// 提交到队列</span><br>        <br>        <span class="hljs-comment">// 父任务调用 join() 等待子任务</span><br>        <span class="hljs-keyword">return</span> left.join() + right.join();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果使用 <code>Thread.join()</code>，这种模式会导致问题：</p>
<ul>
<li>父线程阻塞等待子线程</li>
<li>但子任务可能还在队列中等待执行</li>
<li>如果所有线程都在等待，就会<strong>死锁</strong></li>
</ul>
<p>使用 <code>ForkJoinTask.join()</code>，不会死锁：</p>
<ul>
<li>父任务调用 <code>join()</code> 时，工作线程不会阻塞</li>
<li>工作线程会尝试执行等待的子任务</li>
<li>如果子任务在自己的队列中，直接执行</li>
<li>如果子任务在其他队列中，窃取其他任务继续工作</li>
<li>这样<strong>父子任务永远不会相互阻塞</strong></li>
</ul>
<p><strong>实现原理：ForkJoinTask.join() 的源码逻辑</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinTask.join() 的简化逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)<br>        reportException(s);<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doJoin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;<br>    <br>    <span class="hljs-comment">// 1. 如果任务已完成，直接返回</span><br>    <span class="hljs-keyword">return</span> (s = status) &lt; <span class="hljs-number">0</span> ? s :<br>        <br>        <span class="hljs-comment">// 2. 如果是 ForkJoinWorkerThread，尝试执行或窃取</span><br>        ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) ?<br>        (w = (wt = (ForkJoinWorkerThread)t).workQueue).<br>        tryUnpush(<span class="hljs-built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="hljs-number">0</span> ? s :<br>        wt.pool.awaitJoin(w, <span class="hljs-built_in">this</span>, <span class="hljs-number">0L</span>) :<br>        <br>        <span class="hljs-comment">// 3. 外部线程，使用阻塞等待</span><br>        externalAwaitDone();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键点：</p>
<ol>
<li><strong>快速路径</strong>：任务已完成，直接返回</li>
<li><strong>工作线程路径</strong>：尝试执行任务或窃取其他任务</li>
<li><strong>外部线程路径</strong>：非 ForkJoinWorkerThread 才会阻塞</li>
</ol>
<p><strong>性能影响</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Thread.join()</th>
<th>ForkJoinTask.join()</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线程状态</strong></td>
<td>WAITING（阻塞）</td>
<td>RUNNABLE（继续工作）</td>
</tr>
<tr>
<td><strong>CPU 利用率</strong></td>
<td>降低（线程挂起）</td>
<td>保持（继续执行任务）</td>
</tr>
<tr>
<td><strong>上下文切换</strong></td>
<td>需要（操作系统调度）</td>
<td>不需要（用户态调度）</td>
</tr>
<tr>
<td><strong>死锁风险</strong></td>
<td>高（递归场景）</td>
<td>无（协作式调度）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>独立线程</td>
<td>分治递归任务</td>
</tr>
</tbody>
</table>
<p><strong>总结</strong></p>
<p>ForkJoinTask.join() 的协作式等待机制是 ForkJoinPool 的核心优势：</p>
<ol>
<li><strong>避免线程阻塞</strong>：工作线程永远不会因为等待而停止工作</li>
<li><strong>充分利用 CPU</strong>：等待期间继续执行其他任务</li>
<li><strong>避免死锁</strong>：父子任务可以在同一个线程中执行</li>
<li><strong>支持海量任务</strong>：可以提交远超线程数的任务而不会耗尽资源</li>
</ol>
<p>这种设计使得 ForkJoinPool 特别适合处理递归分治问题，如归并排序、快速排序、并行流等场景。</p>
<h3 id="1-5-forkjointask：任务抽象">1.5 ForkJoinTask：任务抽象</h3>
<h4 id="核心结构">核心结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Future</span>&lt;V&gt;, Serializable &#123;<br>    <span class="hljs-comment">// 32位状态字段</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> status;<br>    <br>    <span class="hljs-comment">// 状态常量（JDK 8实际定义）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DONE_MASK</span>   <span class="hljs-operator">=</span> <span class="hljs-number">0xf0000000</span>; <span class="hljs-comment">// 完成掩码</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>      <span class="hljs-operator">=</span> <span class="hljs-number">0xf0000000</span>; <span class="hljs-comment">// 正常完成（必须为负数）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>   <span class="hljs-operator">=</span> <span class="hljs-number">0xc0000000</span>; <span class="hljs-comment">// 已取消（必须小于NORMAL）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x80000000</span>; <span class="hljs-comment">// 异常完成（必须小于CANCELLED）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>      <span class="hljs-operator">=</span> <span class="hljs-number">0x00010000</span>; <span class="hljs-comment">// 需要信号（必须 &gt;= 1 &lt;&lt; 16）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SMASK</span>       <span class="hljs-operator">=</span> <span class="hljs-number">0x0000ffff</span>; <span class="hljs-comment">// 短整型位用于标签</span><br>    <span class="hljs-comment">// 注意：没有COMPLETING常量，COMPLETING是FutureTask的状态，不是ForkJoinTask的</span><br>    <br>    <span class="hljs-comment">// 核心方法</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异步提交当前任务到当前线程的本地队列</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> this，支持链式调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">()</span>;  <span class="hljs-comment">// 异步提交</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 等待当前任务完成并返回结果</span><br><span class="hljs-comment">     * 与 Thread.join()的关键区别：</span><br><span class="hljs-comment">     * - Thread.join()会阻塞当前线程，不做任何有用工作</span><br><span class="hljs-comment">     * - ForkJoinTask.join()会：</span><br><span class="hljs-comment">     *   1. 检查任务是否已完成</span><br><span class="hljs-comment">     *   2. 如果未完成，当前线程不会阻塞</span><br><span class="hljs-comment">     *   3. 而是执行&quot;协作式等待&quot;：</span><br><span class="hljs-comment">     *      a. 扫描其他工作队列窃取任务</span><br><span class="hljs-comment">     *      b. 如果窃取到的任务是目标任务的子任务，直接帮助执行</span><br><span class="hljs-comment">     *      c. 通过帮助执行，加速目标任务的完成</span><br><span class="hljs-comment">     *   4. 仅当全局无任务可做时才真正阻塞</span><br><span class="hljs-comment">     * - 可以从外部调用，但通常在FJ任务内部调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span>;               <span class="hljs-comment">// 等待完成</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务的核心计算逻辑，由子类实现</span><br><span class="hljs-comment">     * 与join()的区别：</span><br><span class="hljs-comment">     * - compute()包含任务的实际执行逻辑</span><br><span class="hljs-comment">     * - join()是等待其他任务完成的方法</span><br><span class="hljs-comment">     * - compute()在当前线程执行，join()触发协作执行</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>;        <span class="hljs-comment">// 子类实现</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取原始结果（由compute()设置）</span><br><span class="hljs-comment">     * 满足Future&lt;V&gt;接口契约</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置原始结果</span><br><span class="hljs-comment">     * 通常由compute()内部调用</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(V value)</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试从当前线程的队列中移除任务</span><br><span class="hljs-comment">     * 用于任务取消</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryUnfork</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="标准子类">标准子类</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无返回值任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveAction</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;Void&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 无返回值的计算逻辑</span><br><span class="hljs-comment">     * JLS允许将Void作为类型参数，虽然Void不可实例化</span><br><span class="hljs-comment">     * Void是不可实例化的占位符类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 为什么需要这个方法？</span><br><span class="hljs-comment">     * - 满足ForkJoinTask&lt;Void&gt;的接口契约</span><br><span class="hljs-comment">     * - 虽然返回Void，但类型系统需要具体实现</span><br><span class="hljs-comment">     * - 比RecursiveTask更轻量，因为不需要处理返回值</span><br><span class="hljs-comment">     * - 保持API一致性，避免特殊处理</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Void <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(Void mustBeNull)</span> &#123; &#125;<br>&#125;<br><br><span class="hljs-comment">// 有返回值任务</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RecursiveTask</span>&lt;V&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ForkJoinTask</span>&lt;V&gt; &#123;<br>    V result; <span class="hljs-comment">// 存储计算结果</span><br>    <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> V <span class="hljs-title function_">compute</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 唯一需要子类实现的抽象方法</span><br>    <br>    <span class="hljs-comment">// 注意：以下方法是final的，不是abstract的</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">getRawResult</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> result; &#125;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setRawResult</span><span class="hljs-params">(V value)</span> &#123; result = value; &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="与futuretask的关键区别">与FutureTask的关键区别</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FutureTask.get()：可能完全阻塞</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>        <span class="hljs-comment">// s 的最终赋值是等待完成的结果</span><br>        s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>); <span class="hljs-comment">// 可能阻塞</span><br>    <span class="hljs-comment">// 最终 s 决定了 report 的行为</span><br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br><br><span class="hljs-comment">// ForkJoinTask.join()：协作式等待</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (doJoin() != NORMAL)       <span class="hljs-comment">// doJoin()包含帮助执行逻辑</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="2-关键api：与threadpoolexecutor的差异">2. 关键API：与ThreadPoolExecutor的差异</h2>
<h3 id="2-1-forkjoinpool的核心api">2.1 ForkJoinPool的核心API</h3>
<h4 id="外部客户端api">外部客户端API</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重写的Executor.execute方法</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// 将Runnable包装为ForkJoinTask</span><br>    ForkJoinTask&lt;?&gt; job = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskAdaptor</span>(task);<br>    externalPush(job); <span class="hljs-comment">// 提交到外部队列</span><br>&#125;<br><br><span class="hljs-comment">// 针对ForkJoinTask的专用方法</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 为什么需要这个重载？</span><br><span class="hljs-comment"> * - 针对ForkJoinTask优化：避免包装开销</span><br><span class="hljs-comment"> * - 直接调用externalPush，性能更好</span><br><span class="hljs-comment"> * - 与父类的execute(Runnable)不是相互嵌套关系</span><br><span class="hljs-comment"> * - 两个方法针对不同类型的任务优化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ForkJoinTask&lt;?&gt; task)</span>;<br><br><span class="hljs-comment">// 同步执行并返回结果</span><br>&lt;T&gt; T <span class="hljs-title function_">invoke</span><span class="hljs-params">(ForkJoinTask&lt;T&gt; task)</span>;<br><br><span class="hljs-comment">// 提交任务并返回Future</span><br>&lt;T&gt; ForkJoinTask&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(ForkJoinTask&lt;T&gt; task)</span>;<br></code></pre></td></tr></table></figure>
<ol>
<li>对 TPE：<code>execute(Runnable)</code>是调度层的核心，不是最底层。最底层是 <code>runWorker()</code>。</li>
<li>对于外部提交，<code>externalPush()</code>或<code>externalSubmit()</code>是入口；但内部<code>fork()</code>调用的是<code>WorkQueue.push()</code>，两者是并行的入口路径，不是汇聚关系。</li>
</ol>
<h4 id="内部计算api">内部计算API</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内部API的访问控制：</span><br><span class="hljs-comment"> * - 虽然fork()/join()是public方法，但文档约定只在FJ任务内部调用</span><br><span class="hljs-comment"> * - 通过文档约定和性能惩罚来限制，不是通过访问控制</span><br><span class="hljs-comment"> * - 在外部调用fork()会回退到commonPool，性能较差</span><br><span class="hljs-comment"> * - 正确用法：外部客户端用invoke()，内部计算用fork()/join()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">void</span> ForkJoinTask.fork();    <span class="hljs-comment">// 异步派生子任务</span><br>V ForkJoinTask.join();       <span class="hljs-comment">// 等待子任务完成</span><br>V ForkJoinTask.invoke();     <span class="hljs-comment">// 执行并等待完成</span><br></code></pre></td></tr></table></figure>
<h4 id="监控与管理api">监控与管理API</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取全局窃取次数</span><br><span class="hljs-type">long</span> <span class="hljs-title function_">getStealCount</span><span class="hljs-params">()</span>;<br><br><span class="hljs-comment">// 等待池变为空闲</span><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitQuiescence</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span>;<br><br><span class="hljs-comment">// 优雅关闭</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>
<h3 id="2-2-forkjoinpool-与-abstractexecutorservice-的关系辨析">2.2 ForkJoinPool 与 AbstractExecutorService 的关系辨析</h3>
<h4 id="关键问题：submit-和-execute-的关系是否改变了？">关键问题：submit 和 execute 的关系是否改变了？</h4>
<p><strong>答案：接口契约未变，但实现路径不同。</strong></p>
<p>根据 JSR-166 规范和 ForkJoinPool 的 Javadoc，需要区分两种情况：</p>
<h5 id="情况1：普通-runnable-callable-任务">情况1：普通 Runnable/Callable 任务</h5>
<p>对于普通 Runnable/Callable，ForkJoinPool <strong>完全遵循</strong> AbstractExecutorService 的契约：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractExecutorService 的默认实现（ForkJoinPool 继承）</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>    execute(ftask);  <span class="hljs-comment">// 调用 ForkJoinPool.execute()</span><br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">// ForkJoinPool.execute() 的实现</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    ForkJoinTask&lt;?&gt; job;<br>    <span class="hljs-keyword">if</span> (task <span class="hljs-keyword">instanceof</span> ForkJoinTask)  <span class="hljs-comment">// 不会进入此分支</span><br>        job = (ForkJoinTask&lt;?&gt;) task;<br>    <span class="hljs-keyword">else</span><br>        job = newTaskAdaptor(task);  <span class="hljs-comment">// 包装为 ForkJoinTask</span><br>    externalPush(job);  <span class="hljs-comment">// 提交到外部队列</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>调用链</strong>：<code>submit()</code> → <code>newTaskFor()</code> → <code>execute()</code> → <code>externalPush()</code> → WorkQueue</p>
<h5 id="情况2：forkjointask-任务">情况2：ForkJoinTask 任务</h5>
<p>对于 ForkJoinTask，ForkJoinPool 提供了<strong>重载方法</strong>，绕过 FutureTask 包装：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinPool 专用方法</span><br><span class="hljs-keyword">public</span> &lt;T&gt; ForkJoinTask&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(ForkJoinTask&lt;T&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    externalPush(task);  <span class="hljs-comment">// 直接提交，不包装为 FutureTask</span><br>    <span class="hljs-keyword">return</span> task;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(ForkJoinTask&lt;?&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    externalPush(task);  <span class="hljs-comment">// 直接提交，不包装为 FutureTask</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>调用链</strong>：<code>submit()</code> → <code>externalPush()</code> → WorkQueue（跳过 FutureTask 包装）</p>
<h5 id="对比图示">对比图示</h5>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;ThreadPoolExecutor（标准实现）&quot;
        A1[submit Runnable] --&gt; B1[newTaskFor]
        B1 --&gt; C1[FutureTask]
        C1 --&gt; D1[execute]
        D1 --&gt; E1[WorkerQueue]
        
        A2[submit Callable] --&gt; B2[newTaskFor]
        B2 --&gt; C2[FutureTask]
        C2 --&gt; D1
    end
    
    subgraph &quot;ForkJoinPool（普通任务）&quot;
        A3[submit Runnable] --&gt; B3[newTaskFor]
        B3 --&gt; C3[FutureTask]
        C3 --&gt; D3[execute]
        D3 --&gt; E3[externalPush]
        E3 --&gt; F3[WorkQueue]
        
        A4[submit Callable] --&gt; B4[newTaskFor]
        B4 --&gt; C4[FutureTask]
        C4 --&gt; D3
    end
    
    subgraph &quot;ForkJoinPool（ForkJoinTask）&quot;
        A5[submit ForkJoinTask] --&gt; D5[externalPush]
        D5 --&gt; F5[WorkQueue]
        
        A6[execute ForkJoinTask] --&gt; D5
    end
    
    style A5 fill:#90EE90
    style A6 fill:#90EE90
    style D5 fill:#90EE90
    style F5 fill:#90EE90</code></pre>
<h5 id="关键结论">关键结论</h5>
<ol>
<li><strong>接口契约未变</strong>：ForkJoinPool 仍然继承 AbstractExecutorService，<code>submit()</code>、<code>invokeAll()</code>、<code>invokeAny()</code> 的契约保持不变</li>
<li><strong>实现路径不同</strong>：
<ul>
<li>普通任务：<code>submit()</code> → <code>FutureTask</code> → <code>execute()</code> → <code>externalPush()</code> → WorkQueue</li>
<li>ForkJoinTask：<code>submit()</code> → <code>externalPush()</code> → WorkQueue（跳过 FutureTask）</li>
</ul>
</li>
<li><strong>性能优化</strong>：ForkJoinTask 重载方法避免了不必要的 FutureTask 包装开销</li>
<li><strong>工作窃取</strong>：无论哪种路径，最终都通过 <code>externalPush()</code> 提交到 WorkQueue，支持工作窃取算法</li>
</ol>
<p>这个设计体现了 ForkJoinPool 的<strong>双重性质</strong>：既要兼容 ExecutorService 标准接口，又要为 ForkJoinTask 提供优化路径。</p>
<h3 id="2-3-api使用边界：为什么不能混用？">2.3 API使用边界：为什么不能混用？</h3>
<p>Javadoc 明确划分了 API 使用边界：</p>
<table>
<thead>
<tr>
<th>meannings</th>
<th>Call from non-fork/join clients</th>
<th>Call from within fork/join computations</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Arrange async execution</strong></td>
<td><code>execute(ForkJoinTask)</code></td>
<td><code>ForkJoinTask.fork()</code></td>
</tr>
<tr>
<td><strong>Await and obtain result</strong></td>
<td><code>invoke(ForkJoinTask)</code></td>
<td><code>ForkJoinTask.invoke()</code></td>
</tr>
<tr>
<td><strong>Arrange exec and obtain Future</strong></td>
<td><code>submit(ForkJoinTask)</code></td>
<td><code>ForkJoinTask.fork()</code> (ForkJoinTasks are Futures)</td>
</tr>
</tbody>
</table>
<p><strong>&quot;Arrange&quot;的含义：</strong><br>
此处的&quot;Arrange&quot;是英语动词，意为&quot;安排、组织&quot;，描述API的意图：</p>
<ul>
<li>Arrange async execution = “安排异步执行” → 任务提交后立即返回</li>
<li>Await and obtain result = “等待并获取结果” → 阻塞直到任务完成</li>
<li>Arrange exec and obtain Future = “安排执行并获取 Future” → 异步执行但保留结果句柄，通过 Future 获取结果。</li>
</ul>
<blockquote>
<p>原始文档强调<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/271521213">2</a>： “These methods are designed to be used primarily by clients<br>
not already engaged in fork/join computations in the current pool…<br>
tasks that are already executing in a pool should normally instead use<br>
the within-computation forms…”</p>
</blockquote>
<p><strong>混用API的代价</strong>：</p>
<ul>
<li><strong>性能下降</strong>：绕过工作窃取优化</li>
<li><strong>死锁风险</strong>：阻塞式等待导致资源浪费</li>
<li><strong>缓存失效</strong>：失去任务局部性</li>
</ul>
<h2 id="3-线程调度机制：动态适应的艺术">3. 线程调度机制：动态适应的艺术</h2>
<h3 id="3-1-并行度：唯一的核心参数">3.1 并行度：唯一的核心参数</h3>
<h4 id="配置参数">配置参数</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 构造函数</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism,</span><br><span class="hljs-params">                   ForkJoinWorkerThreadFactory factory,</span><br><span class="hljs-params">                   UncaughtExceptionHandler handler,</span><br><span class="hljs-params">                   <span class="hljs-type">boolean</span> asyncMode)</span>;<br></code></pre></td></tr></table></figure>
<p><strong>四个参数详解</strong>：</p>
<ol>
<li>
<p><strong>parallelism</strong>：目标并行度</p>
<ul>
<li>控制池中活跃工作线程的数量上限</li>
<li>默认值为<code>Runtime.getRuntime().availableProcessors()</code></li>
<li>实际线程数会根据负载动态调整</li>
</ul>
</li>
<li>
<p><strong>factory</strong>：工作线程工厂</p>
<ul>
<li>用于创建ForkJoinWorkerThread实例</li>
<li>默认使用<code>ForkJoinPool.defaultForkJoinWorkerThreadFactory</code></li>
<li>可自定义线程名称、优先级、上下文类加载器等属性</li>
</ul>
</li>
<li>
<p><strong>handler</strong>：未捕获异常处理器</p>
<ul>
<li>处理工作线程中未被捕获的异常</li>
<li>默认为null，异常会传播到<code>ThreadGroup.uncaughtException()</code></li>
<li>可设置自定义处理器进行统一异常处理</li>
</ul>
</li>
<li>
<p><strong>asyncMode</strong>：任务调度模式（核心设计决策）</p>
<ul>
<li><strong>false（默认）</strong>：LIFO模式 - 本地队列采用后进先出
<ul>
<li>适合递归分解任务（divide-and-conquer）</li>
<li>增强任务局部性，提高缓存命中率</li>
<li>工作窃取时采用FIFO（从队列尾部窃取）</li>
</ul>
</li>
<li><strong>true</strong>：FIFO模式 - 本地队列采用先进先出
<ul>
<li>适合事件驱动任务（event-style tasks）</li>
<li>降低线程间竞争，提高吞吐量</li>
<li>工作窃取时同样采用FIFO</li>
</ul>
</li>
</ul>
</li>
</ol>
<p><strong>设计哲学与JRE源码的深层考量</strong>：</p>
<p>表面上看，<code>newWorkStealingPool()</code>设置<code>asyncMode=true</code>似乎与&quot;递归分解适合LIFO&quot;的原则相矛盾。但实际上这是精心设计的结果：</p>
<ol>
<li>
<p><strong>使用场景区分</strong>：</p>
<ul>
<li>直接使用<code>ForkJoinPool</code>构造函数：通常是开发者明确知道在做分治算法</li>
<li>使用<code>newWorkStealingPool()</code>：面向通用并发任务，多数是非递归的独立任务</li>
</ul>
</li>
<li>
<p><strong>性能优化考量</strong>：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">asyncMode</span>=<span class="hljs-literal">true</span>的优势：<br>→ 任务按提交顺序执行，减少线程竞争<br>→ 适合大量独立小任务的并发执行<br>→ 避免递归深度导致的栈溢出风险<br>→ 更好的负载均衡效果<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>API设计意图</strong>：</p>
<ul>
<li><code>newWorkStealingPool()</code>旨在提供&quot;开箱即用&quot;的高性能并发池</li>
<li>默认FIFO模式对大多数应用更友好</li>
<li>需要专门的分治算法时，开发者会直接使用<code>ForkJoinPool</code>构造函数</li>
</ul>
</li>
<li>
<p><strong>Doug Lea的设计智慧</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK源码中的实际设计</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ExecutorService <span class="hljs-title function_">newWorkStealingPool</span><span class="hljs-params">(<span class="hljs-type">int</span> parallelism)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(parallelism, <br>                           defaultForkJoinWorkerThreadFactory,<br>                           <span class="hljs-literal">null</span>, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 故意设为true</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种设计体现了&quot;默认最优&quot;的理念：为普通用户提供最适合大多数场景的配置，而将专业调优留给有明确需求的开发者。</p>
</li>
</ol>
<p><strong>关于工作窃取算法的澄清</strong>（回应读者核心疑问）：</p>
<p>这是一个非常重要的概念澄清：</p>
<p>✅ <strong>工作窃取算法始终启用</strong>：</p>
<ul>
<li>无论是<code>asyncMode=true</code>还是<code>false</code>，<strong>工作窃取机制都100%启用</strong></li>
<li>这是ForkJoinPool的核心特性，不因asyncMode而改变</li>
<li>Doug Lea设计的work-stealing算法是ForkJoinPool存在的根本</li>
</ul>
<p>❌ <strong>常见的误解纠正</strong>：</p>
<pre><code class="hljs mermaid">graph TD
    A[ForkJoinPool核心机制] --&gt; B[工作窃取算法&lt;br/&gt;始终启用]
    A --&gt; C[任务调度策略&lt;br/&gt;受asyncMode影响]
    B --&gt; D[线程空闲时&lt;br/&gt;从其他线程队列窃取任务]
    C --&gt; E[asyncMode=false: LIFO本地队列]
    C --&gt; F[asyncMode=true: FIFO本地队列]
    E --&gt; G[适合递归分解&lt;br/&gt;增强局部性]
    F --&gt; H[适合独立任务&lt;br/&gt;减少竞争]</code></pre>
<p><strong>递归分解 vs 工作窃取的关系</strong>：</p>
<p>这两个特性<strong>不是互斥的</strong>，而是<strong>互补的</strong>：</p>
<ol>
<li><strong>工作窃取是基础设施</strong>：提供线程间的负载均衡能力</li>
<li><strong>任务调度策略是优化手段</strong>：针对不同类型任务优化性能</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">asyncMode</span>=<span class="hljs-literal">false</span>（LIFO）：<br>├─ 本地执行：LIFO（最新任务优先）<br>├─ 窃取机制：FIFO（从队列尾部窃取）<br>└─ 优势：递归任务局部性好，缓存友好<br><br><span class="hljs-attribute">asyncMode</span>=<span class="hljs-literal">true</span>（FIFO）：<br>├─ 本地执行：FIFO（按序执行）<br>├─ 窃取机制：FIFO（同样从尾部窃取）<br>└─ 优势：独立任务竞争少，吞吐量高<br></code></pre></td></tr></table></figure>
<p><strong>关键洞察</strong>：</p>
<ul>
<li><strong>工作窃取 ≠ 任务调度策略</strong></li>
<li>工作窃取是&quot;怎么分任务&quot;，调度策略是&quot;按什么顺序执行任务&quot;</li>
<li><code>newWorkStealingPool()</code>名称强调的是&quot;使用工作窃取算法的池&quot;，而非&quot;积极启用工作窃取&quot;</li>
<li>asyncMode=true实际上是选择了更适合通用任务的执行顺序，但工作窃取机制从未关闭</li>
</ul>
<h4 id="公共池的系统属性">公共池的系统属性</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.concurrent.ForkJoinPool.common.parallelism<br>    - 目标并行度，控制活跃线程数<br>    - 默认 = Runtime.getRuntime().availableProcessors()<br>    <br>java.util.concurrent.ForkJoinPool.common.threadFactory<br>    - 自定义工作线程创建逻辑<br>    - 默认使用DefaultForkJoinWorkerThreadFactory<br>    <br>java.util.concurrent.ForkJoinPool.common.exceptionHandler<br>    - 处理未捕获异常<br>    - 默认使用系统默认异常处理器：<br>    <span class="hljs-comment">//   - 打印异常堆栈到System.err</span><br>    <span class="hljs-comment">//   - 不终止JVM</span><br>    <span class="hljs-comment">//   - 可通过Thread.setDefaultUncaughtExceptionHandler覆盖</span><br>    <br>java.util.concurrent.ForkJoinPool.common.maximumSpares<br>    - 额外线程上限，用于补偿阻塞<br>    - 默认 = <span class="hljs-number">256</span><br></code></pre></td></tr></table></figure>
<h4 id="各参数的实际影响：">各参数的实际影响：</h4>
<ul>
<li><strong>parallelism</strong>：直接影响CPU利用率，设置过大导致上下文切换开销</li>
<li><strong>threadFactory</strong>：可控制线程优先级、名称、守护状态</li>
<li><strong>exceptionHandler</strong>：确保异常不会静默失败</li>
<li><strong>maximumSpares</strong>：处理阻塞时的补偿机制，过小导致性能下降</li>
</ul>
<h3 id="3-2-无core-max参数的设计哲学">3.2 无core/max参数的设计哲学</h3>
<h4 id="threadpoolexecutor的线程管理">ThreadPoolExecutor的线程管理</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// TPE的线程创建逻辑</span><br><span class="hljs-keyword">if</span> (当前线程数 &lt; corePoolSize) 创建核心线程<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (队列未满) 入队<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (当前线程数 &lt; maximumPoolSize) 创建非核心线程<br><span class="hljs-keyword">else</span> 拒绝策略<br></code></pre></td></tr></table></figure>
<h4 id="forkjoinpool的线程管理">ForkJoinPool的线程管理</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// FJP的线程创建逻辑</span><br><span class="hljs-keyword">if</span> (活跃线程数 &lt; parallelism) 创建新线程<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (有线程阻塞且 spare线程数 &lt; maximumSpares) 创建spare线程<br><span class="hljs-keyword">else</span> 复用现有线程 <span class="hljs-comment">// 任务数超过线程数时：</span><br>                 <span class="hljs-comment">//   - 通过工作窃取实现负载均衡</span><br>                 <span class="hljs-comment">//   - 空闲线程会窃取其他队列的任务</span><br>                 <span class="hljs-comment">//   - 如果没有空闲线程：</span><br>                 <span class="hljs-comment">//     * 新任务入队到当前线程的本地队列</span><br>                 <span class="hljs-comment">//     * 队列会动态扩容（无界）</span><br>                 <span class="hljs-comment">//   - 不会创建新线程，除非有阻塞</span><br></code></pre></td></tr></table></figure>
<h4 id="parallelism-vs-corepoolsize-maximumspares-vs-maximumpoolsize：">parallelism vs corePoolSize, maximumSpares vs maximumPoolSize：</h4>
<ul>
<li>本质不同：
<ul>
<li>TPE：corePoolSize是静态下限（保持的最小线程数），maximumPoolSize是静态上限（允许的最大线程数）</li>
<li>FJP：parallelism是动态目标（期望的<strong>活跃线程数</strong>），maximumSpares是补偿上限（允许的额外线程数）：<strong>只要有任务，机制可以通过一个有限度的补偿拼命维持 active thread 的 count；ThreadPoolExecutor维持的是线程数量的边界范围（corePoolSize ≤ 线程数 ≤ maximumPoolSize），而不是特别关注线程的活跃状态。</strong></li>
<li>TPE的线程边界是硬性的，FJP的线程边界是软性的</li>
<li>TPE创建线程是为了处理更多任务，FJP创建spare线程是为了补偿阻塞</li>
</ul>
</li>
<li>关键区别：
<ul>
<li>线程数硬性上限：FJP的线程数永远不会超过 parallelism + maximumSpares</li>
<li>当达到上限后：
<ul>
<li>有线程阻塞时，无法创建spare线程</li>
<li>新任务入队到现有线程的队列（队列无界，会动态扩容）</li>
</ul>
</li>
<li>与TPE的核心区别：
<ul>
<li>TPE：有界队列满 + 线程=max 时触发拒绝策略（RejectedExecutionHandler）</li>
<li>FJP：<strong>无需配置拒绝策略</strong>，队列动态扩容，仅在 shutdown 或内部资源耗尽时抛出 RejectedExecutionException</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="线程回收机制对比">线程回收机制对比</h4>
<blockquote>
<p>Javadoc明确说明 <a target="_blank" rel="noopener" href="https://www.zhihu.com/question/271521213">2</a>： “Using the common pool normally reduces resource<br>
usage (its threads are slowly reclaimed during periods of non-use, and<br>
reinstated upon subsequent use).”</p>
</blockquote>
<h4 id="fjp线程回收细节">FJP线程回收细节</h4>
<ul>
<li>空闲线程不会立即销毁，而是park()</li>
<li>如果空闲时间超过阈值，标记为可回收</li>
<li>通过ctl字段的位操作，逐步减少活跃线程计数</li>
<li>下次需要时重新创建，避免频繁创建/销毁开销</li>
</ul>
<h3 id="3-3-为什么没有拒绝策略：无界队列与任务消费模型">3.3 为什么没有拒绝策略：无界队列与任务消费模型</h3>
<h4 id="forkjoinpool-构造器对比">ForkJoinPool 构造器对比</h4>
<p>查看 ForkJoinPool 的构造器签名，会发现一个显著的差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ThreadPoolExecutor 构造器（7个参数）</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ThreadPoolExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> corePoolSize,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> maximumPoolSize,</span><br><span class="hljs-params">    <span class="hljs-type">long</span> keepAliveTime,</span><br><span class="hljs-params">    TimeUnit unit,</span><br><span class="hljs-params">    BlockingQueue&lt;Runnable&gt; workQueue,</span><br><span class="hljs-params">    ThreadFactory threadFactory,</span><br><span class="hljs-params">    RejectedExecutionHandler handler  // 拒绝策略</span><br><span class="hljs-params">)</span><br><br><span class="hljs-comment">// ForkJoinPool 构造器（最完整版本，4个参数）</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">ForkJoinPool</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> parallelism,</span><br><span class="hljs-params">    ForkJoinWorkerThreadFactory factory,</span><br><span class="hljs-params">    UncaughtExceptionHandler handler,  // 异常处理器，不是拒绝策略</span><br><span class="hljs-params">    <span class="hljs-type">boolean</span> asyncMode</span><br><span class="hljs-params">)</span><br></code></pre></td></tr></table></figure>
<p><strong>ForkJoinPool 没有 RejectedExecutionHandler 参数</strong>。这不是疏忽，而是有意为之的设计决策。</p>
<h4 id="为什么不需要拒绝策略？">为什么不需要拒绝策略？</h4>
<pre><code class="hljs mermaid">flowchart TB
    subgraph TPE[&quot;ThreadPoolExecutor 任务流&quot;]
        T1[新任务] --&gt; T2&#123;线程数 &lt; core?&#125;
        T2 --&gt;|是| T3[创建核心线程]
        T2 --&gt;|否| T4&#123;队列未满?&#125;
        T4 --&gt;|是| T5[入队等待]
        T4 --&gt;|否| T6&#123;线程数 &lt; max?&#125;
        T6 --&gt;|是| T7[创建非核心线程]
        T6 --&gt;|否| T8[触发拒绝策略]
        
        style T8 fill:#ff6b6b,color:#fff
    end
    
    subgraph FJP[&quot;ForkJoinPool 任务流&quot;]
        F1[新任务] --&gt; F2&#123;外部提交?&#125;
        F2 --&gt;|是| F3[放入共享提交队列]
        F2 --&gt;|否| F4[放入当前线程本地队列]
        F3 --&gt; F5[队列动态扩容]
        F4 --&gt; F5
        F5 --&gt; F6[工作窃取平衡负载]
        F6 --&gt; F7[join时帮助执行]
        
        style F5 fill:#51cf66,color:#fff
        style F7 fill:#51cf66,color:#fff
    end</code></pre>
<p><strong>原因一：队列是无界的</strong></p>
<p>每个 WorkQueue 内部使用 <code>ForkJoinTask&lt;?&gt;[] array</code> 存储任务：</p>
<p>根据 ForkJoinPool 的 Javadoc（Java SE 8+）：</p>
<blockquote>
<p>“This implementation rejects submitted tasks (that is, by throwing RejectedExecutionException) only when the pool is shut down or internal resources have been exhausted.”</p>
</blockquote>
<p>这意味着 ForkJoinPool <strong>不需要显式的拒绝策略参数</strong>，因为：</p>
<ul>
<li>正常运行时，任务总能被接受（队列会动态扩容）</li>
<li>只有在 shutdown 或内部资源耗尽时才会拒绝</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// WorkQueue 内部结构（来自 OpenJDK 8 源码）</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WorkQueue</span> &#123;<br>    ForkJoinTask&lt;?&gt;[] array;  <span class="hljs-comment">// 任务数组</span><br>    <span class="hljs-type">int</span> base;                  <span class="hljs-comment">// 窃取端索引（FIFO）</span><br>    <span class="hljs-type">int</span> top;                   <span class="hljs-comment">// 本地端索引（LIFO）</span><br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-comment">// 数组容量范围（来自 OpenJDK 源码）</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INITIAL_QUEUE_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">13</span>;  <span class="hljs-comment">// 8192</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAXIMUM_QUEUE_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">26</span>;  <span class="hljs-comment">// 67,108,864（约 6700 万）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>当队列满时，会自动扩容（容量翻倍），直到达到 MAXIMUM_QUEUE_CAPACITY。这意味着：</p>
<ul>
<li>单个队列理论上可以容纳约 6700 万个任务</li>
<li>多个工作线程各有自己的队列</li>
<li>实际上，内存耗尽（OOM）会先于队列容量上限触发 “internal resources exhausted”</li>
</ul>
<p><strong>原因二：任务模型的本质差异</strong></p>
<p>ThreadPoolExecutor 处理的是<strong>独立任务</strong>：</p>
<ul>
<li>任务之间没有依赖关系</li>
<li>拒绝一个任务不影响其他任务</li>
<li>拒绝策略是合理的边界保护</li>
</ul>
<p>ForkJoinPool 处理的是<strong>可分解的递归任务</strong>：</p>
<ul>
<li>父任务 fork 出子任务</li>
<li>父任务必须 join 等待子任务完成</li>
<li><strong>如果拒绝子任务，父任务将永远无法完成，导致死锁</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果 ForkJoinPool 有拒绝策略，这段代码可能死锁</span><br><span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (size &lt; THRESHOLD) &#123;<br>        <span class="hljs-keyword">return</span> directCompute();<br>    &#125;<br>    <br>    <span class="hljs-type">SubTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTask</span>(leftHalf);<br>    <span class="hljs-type">SubTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTask</span>(rightHalf);<br>    <br>    left.fork();   <span class="hljs-comment">// 如果这里被拒绝...</span><br>    right.fork();  <span class="hljs-comment">// 或者这里被拒绝...</span><br>    <br>    <span class="hljs-comment">// 父任务将永远阻塞在这里</span><br>    <span class="hljs-keyword">return</span> left.join() + right.join();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>原因三：join 的协作式消费</strong></p>
<p>ForkJoinPool 的 join 不是被动等待，而是主动帮助消费任务：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Parent as 父任务线程
    participant Queue as 本地队列
    participant Child as 子任务
    
    Parent-&gt;&gt;Queue: fork(子任务)
    Parent-&gt;&gt;Parent: 准备 join
    
    alt 子任务还在本地队列顶部
        Parent-&gt;&gt;Queue: tryUnpush(子任务)
        Parent-&gt;&gt;Child: 直接执行子任务
        Child--&gt;&gt;Parent: 返回结果
    else 子任务被窃取
        Parent-&gt;&gt;Queue: 执行队列中其他任务
        Note over Parent: 帮助消费，而非空等
        Child--&gt;&gt;Parent: 异步完成后返回结果
    end</code></pre>
<p>这种设计意味着：</p>
<ul>
<li>即使队列中有大量任务，线程也在持续消费</li>
<li>join 操作本身就是在帮助消费队列</li>
<li>任务的生产和消费是协作式的，不会出现&quot;生产远超消费&quot;的失控情况</li>
</ul>
<h4 id="队列无界会导致-oom-吗？">队列无界会导致 OOM 吗？</h4>
<p>理论上是的，但在正确使用 ForkJoinPool 的场景下，这不是问题：</p>
<p><strong>分治任务的&quot;菱形&quot;特征</strong>：</p>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;任务数量随时间变化&quot;
        A[根任务] --&gt; B1[子任务1]
        A --&gt; B2[子任务2]
        B1 --&gt; C1[孙任务1]
        B1 --&gt; C2[孙任务2]
        B2 --&gt; C3[孙任务3]
        B2 --&gt; C4[孙任务4]
        
        C1 --&gt; D1[结果1]
        C2 --&gt; D2[结果2]
        C3 --&gt; D3[结果3]
        C4 --&gt; D4[结果4]
        
        D1 --&gt; E1[合并1]
        D2 --&gt; E1
        D3 --&gt; E2[合并2]
        D4 --&gt; E2
        
        E1 --&gt; F[最终结果]
        E2 --&gt; F
    end
    
    style A fill:#4dabf7
    style B1 fill:#748ffc
    style B2 fill:#748ffc
    style C1 fill:#9775fa
    style C2 fill:#9775fa
    style C3 fill:#9775fa
    style C4 fill:#9775fa
    style D1 fill:#da77f2
    style D2 fill:#da77f2
    style D3 fill:#da77f2
    style D4 fill:#da77f2
    style E1 fill:#f783ac
    style E2 fill:#f783ac
    style F fill:#ff6b6b</code></pre>
<p>典型的分治任务呈现&quot;先增后减&quot;的菱形模式：</p>
<ol>
<li><strong>分解阶段</strong>：任务数量指数增长</li>
<li><strong>基准情况</strong>：到达阈值，开始直接计算</li>
<li><strong>合并阶段</strong>：任务数量指数减少</li>
</ol>
<p>工作窃取算法确保任务被及时消费，队列长度不会无限增长。</p>
<p><strong>如果滥用会怎样？</strong></p>
<p>如果把 ForkJoinPool 当作普通线程池，不断提交独立任务而不消费结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误用法：把 ForkJoinPool 当作无界队列使用</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ForkJoinPool.commonPool();<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    pool.execute(() -&gt; &#123;<br>        <span class="hljs-comment">// 永远不结束的任务，或者生产速度远超消费速度</span><br>        Thread.sleep(Long.MAX_VALUE);<br>    &#125;);<br>&#125;<br><span class="hljs-comment">// 最终会 OOM</span><br></code></pre></td></tr></table></figure>
<p>这与使用 <code>new ThreadPoolExecutor(..., new LinkedBlockingQueue&lt;&gt;())</code> 的效果相同——都会因为无界队列导致 OOM。</p>
<h4 id="设计哲学总结">设计哲学总结</h4>
<table>
<thead>
<tr>
<th>维度</th>
<th>ThreadPoolExecutor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>任务模型</strong></td>
<td>独立任务</td>
<td>可分解的递归任务</td>
</tr>
<tr>
<td><strong>队列类型</strong></td>
<td>可配置（有界/无界）</td>
<td>动态扩容（无界）</td>
</tr>
<tr>
<td><strong>拒绝策略</strong></td>
<td>必需配置 RejectedExecutionHandler</td>
<td>无需配置，仅在 shutdown/资源耗尽时拒绝</td>
</tr>
<tr>
<td><strong>消费模式</strong></td>
<td>被动等待</td>
<td>协作式消费（join帮助执行）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>通用任务执行</td>
<td>分治并行计算</td>
</tr>
<tr>
<td><strong>OOM风险</strong></td>
<td>无界队列时存在</td>
<td>滥用时存在（触发 internal resources exhausted）</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>核心洞察</strong>：ForkJoinPool 的构造器不需要 RejectedExecutionHandler 参数，是因为在分治并行模型中，拒绝子任务会导致父任务死锁。根据 Javadoc，ForkJoinPool 仅在 shutdown 或内部资源耗尽时抛出 RejectedExecutionException。动态扩容的队列配合工作窃取和协作式 join，形成了一个自平衡的任务消费系统。</p>
</blockquote>
<h3 id="3-4-工作线程生命周期">3.4 工作线程生命周期</h3>
<p>工作线程经历四个阶段：</p>
<ul>
<li><strong>初始化</strong>：首次提交任务时创建，初始活跃线程数不超过parallelism，但总线程数可能达到 parallelism + maximumSpares
<ul>
<li>与TPE的关键区别：TPE的核心线程即使空闲也不会回收（除非设置allowCoreThreadTimeOut），<strong>而FJP的所有线程在空闲时都会被回收</strong></li>
<li>FJP的设计哲学：按需创建，及时释放，适合间歇性负载</li>
</ul>
</li>
<li><strong>活跃期</strong>：执行任务 + 窃取任务，检测阻塞时触发spare线程
<ul>
<li>通过<code>ManagedBlocker</code>接口检测阻塞</li>
<li>当线程阻塞时，可能创建spare线程补偿</li>
</ul>
</li>
<li><strong>空闲期</strong>：无任务时park()，保持空闲状态
<ul>
<li>线程通过<code>awaitWork()</code>方法（内部实现）进入等待，使用<code>LockSupport.park()</code>挂起</li>
<li>有新任务时被唤醒</li>
</ul>
</li>
<li><strong>回收期</strong>：空闲超过阈值，逐步减少线程
<ul>
<li>通过ctl字段的位操作管理线程状态，空闲超时后线程主动退出run()循环</li>
<li>线程退出run()方法，被垃圾回收</li>
<li>下次需要时重新创建，避免永久空闲线程</li>
</ul>
</li>
</ul>
<p>根据 ForkJoinPool 源码注释和 Javadoc 文档：</p>
<blockquote>
<p>“The pool attempts to maintain enough active (or available) threads by dynamically adding, suspending, or resuming internal worker threads, even if some tasks are stalled waiting to join others.”</p>
</blockquote>
<p>这意味着 ForkJoinPool 会动态调整线程数以维持目标并行度，同时避免频繁的线程创建/销毁循环。与传统线程池不同，ForkJoinPool 会回收所有空闲线程以减少资源消耗。</p>
<h2 id="4-实战案例：并行文件搜索系统">4. 实战案例：并行文件搜索系统</h2>
<h3 id="4-1-业务需求">4.1 业务需求</h3>
<ul>
<li>搜索指定目录下的所有文件</li>
<li>查找包含特定关键词的文件</li>
<li>统计匹配行数</li>
<li>处理大型目录（10万+文件）</li>
<li>要求高效利用多核CPU</li>
</ul>
<h3 id="4-2-数据结构定义">4.2 数据结构定义</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 文件搜索任务：递归遍历目录树</span><br><span class="hljs-comment"> * 使用RecursiveTask，因为需要返回匹配结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileSearchTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;List&lt;SearchResult&gt;&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>; <span class="hljs-comment">// 子任务阈值</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Path directory;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String keyword;<br>    <br>    FileSearchTask(Path directory, String keyword) &#123;<br>        <span class="hljs-built_in">this</span>.directory = directory;<br>        <span class="hljs-built_in">this</span>.keyword = keyword;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> List&lt;SearchResult&gt; <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取目录下的所有路径（文件和子目录）</span><br>            List&lt;Path&gt; paths = Files.list(directory)<br>                                   .collect(Collectors.toList());<br>            <br>            <span class="hljs-comment">// 基本情况：小目录直接处理</span><br>            <span class="hljs-keyword">if</span> (paths.size() &lt;= THRESHOLD) &#123;<br>                <span class="hljs-keyword">return</span> searchDirectly(paths);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 递归情况：分解为子任务</span><br>            List&lt;FileSearchTask&gt; subtasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            List&lt;Path&gt; currentBatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <br>            <span class="hljs-keyword">for</span> (Path path : paths) &#123;<br>                currentBatch.add(path);<br>                <span class="hljs-comment">// 每THRESHOLD个路径创建一个子任务</span><br>                <span class="hljs-keyword">if</span> (currentBatch.size() &gt;= THRESHOLD) &#123;<br>                    subtasks.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(createTempDir(currentBatch), keyword));<br>                    currentBatch = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 处理剩余路径</span><br>            <span class="hljs-keyword">if</span> (!currentBatch.isEmpty()) &#123;<br>                subtasks.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(createTempDir(currentBatch), keyword));<br>            &#125;<br>            <br>            <span class="hljs-comment">// 优化：fork其他任务，直接执行最后一个任务（减少调度开销）</span><br>            <span class="hljs-keyword">if</span> (subtasks.size() &gt; <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-comment">// 将最后一个任务留给自己执行，它不进入 fork</span><br>                <span class="hljs-comment">// 因为 fork 是一次执行，compute 是另一次，计算并不一定是幂等的</span><br>                <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">lastTask</span> <span class="hljs-operator">=</span> subtasks.remove(subtasks.size() - <span class="hljs-number">1</span>);<br>                <br>                <span class="hljs-comment">// 异步fork其他任务</span><br>                <span class="hljs-keyword">for</span> (FileSearchTask task : subtasks) &#123;<br>                    task.fork(); <span class="hljs-comment">// 正确：无锁本地队列push</span><br>                &#125;<br>                <br>                <span class="hljs-comment">// 同步执行最后一个任务</span><br>                List&lt;SearchResult&gt; results = lastTask.compute(); <span class="hljs-comment">// 正确：保持缓存</span><br>                <br>                <span class="hljs-comment">// 等待其他任务完成</span><br>                <span class="hljs-keyword">for</span> (FileSearchTask task : subtasks) &#123;<br>                    results.addAll(task.join()); <span class="hljs-comment">// 正确：协作式等待</span><br>                &#125;<br>                <br>                <span class="hljs-keyword">return</span> results;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 只有一个子任务，直接执行</span><br>                <span class="hljs-keyword">return</span> subtasks.get(<span class="hljs-number">0</span>).compute();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UncheckedIOException</span>(e);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> List&lt;SearchResult&gt; <span class="hljs-title function_">searchDirectly</span><span class="hljs-params">(List&lt;Path&gt; paths)</span> &#123;<br>        List&lt;SearchResult&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Path path : paths) &#123;<br>            <span class="hljs-keyword">if</span> (Files.isDirectory(path)) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 递归处理子目录</span><br>                    results.addAll(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(path, keyword).compute());<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-comment">// 忽略无法访问的目录</span><br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 处理文件</span><br>                <span class="hljs-keyword">try</span> (<span class="hljs-type">BufferedReader</span> <span class="hljs-variable">reader</span> <span class="hljs-operator">=</span> Files.newBufferedReader(path)) &#123;<br>                    String line;<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">lineNumber</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">while</span> ((line = reader.readLine()) != <span class="hljs-literal">null</span>) &#123;<br>                        <span class="hljs-keyword">if</span> (line.contains(keyword)) &#123;<br>                            results.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchResult</span>(path, lineNumber, line));<br>                        &#125;<br>                        lineNumber++;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-comment">// 忽略无法读取的文件</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Path <span class="hljs-title function_">createTempDir</span><span class="hljs-params">(List&lt;Path&gt; paths)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 创建临时目录的逻辑（简化）</span><br>        <span class="hljs-keyword">return</span> Files.createTempDirectory(<span class="hljs-string">&quot;search_&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 搜索结果封装</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SearchResult</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Path filePath;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> lineNumber;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String lineContent;<br>    <br>    SearchResult(Path filePath, <span class="hljs-type">int</span> lineNumber, String lineContent) &#123;<br>        <span class="hljs-built_in">this</span>.filePath = filePath;<br>        <span class="hljs-built_in">this</span>.lineNumber = lineNumber;<br>        <span class="hljs-built_in">this</span>.lineContent = lineContent;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> String.format(<span class="hljs-string">&quot;%s:%d: %s&quot;</span>, filePath, lineNumber, lineContent);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-3-线程池初始化与使用">4.3 线程池初始化与使用</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParallelFileSearch</span> &#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建自定义ForkJoinPool</span><br><span class="hljs-comment">     * 根据业务需求配置参数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ForkJoinPool <span class="hljs-title function_">createSearchPool</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">parallelism</span> <span class="hljs-operator">=</span> Math.min(<br>            Runtime.getRuntime().availableProcessors(),<br>            <span class="hljs-number">16</span> <span class="hljs-comment">// 限制最大并行度，避免I/O瓶颈</span><br>        );<br>        <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<br>            parallelism,<br>            ForkJoinPool.defaultForkJoinWorkerThreadFactory,<br>            (thread, throwable) -&gt; &#123;<br>                <span class="hljs-comment">// 自定义异常处理：记录日志</span><br>                System.err.printf(<span class="hljs-string">&quot;Thread %s threw exception: %s%n&quot;</span>, <br>                                 thread.getName(), throwable.getMessage());<br>            &#125;,<br>            <span class="hljs-literal">false</span> <span class="hljs-comment">// asyncMode = false，使用LIFO模式</span><br>        );<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 搜索入口方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;SearchResult&gt; <span class="hljs-title function_">search</span><span class="hljs-params">(Path rootDir, String keyword)</span> &#123;<br>        <span class="hljs-comment">// 创建自定义池，避免使用公共池影响其他组件</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> createSearchPool()) &#123;<br>            <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">rootTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(rootDir, keyword);<br>            <br>            <span class="hljs-comment">// 正确：外部客户端使用invoke()</span><br>            <span class="hljs-keyword">return</span> pool.invoke(rootTask);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 错误用法示例（注释说明）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;SearchResult&gt; <span class="hljs-title function_">wrongApproach</span><span class="hljs-params">(Path rootDir, String keyword)</span> &#123;<br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> createSearchPool()) &#123;<br>            <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">rootTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(rootDir, keyword);<br>            <br>            <span class="hljs-comment">// 错误1：在外部客户端使用fork()</span><br>            <span class="hljs-comment">// rootTask.fork(); // 这会在公共池执行，绕过自定义池配置</span><br>            <br>            <span class="hljs-comment">// 错误2：混用API</span><br>            <span class="hljs-comment">// 在compute()内部这样写是错误的：</span><br>            <span class="hljs-comment">// pool.submit(subtask); // 绕过工作窃取</span><br>            <span class="hljs-comment">// pool.invoke(anotherTask); // 阻塞当前线程</span><br>            <br>            <span class="hljs-comment">// 正确：外部客户端使用invoke()</span><br>            <span class="hljs-keyword">return</span> pool.invoke(rootTask);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (args.length &lt; <span class="hljs-number">2</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Usage: java ParallelFileSearch &lt;directory&gt; &lt;keyword&gt;&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">Path</span> <span class="hljs-variable">rootDir</span> <span class="hljs-operator">=</span> Paths.get(args[<span class="hljs-number">0</span>]);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">keyword</span> <span class="hljs-operator">=</span> args[<span class="hljs-number">1</span>];<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-variable">startTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        List&lt;SearchResult&gt; results = search(rootDir, keyword);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">endTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <br>        System.out.printf(<span class="hljs-string">&quot;Found %d matches in %d ms%n&quot;</span>, <br>                         results.size(), endTime - startTime);<br>        <br>        <span class="hljs-comment">// 打印前10个结果</span><br>        results.stream().limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以正确的框架是：</p>
<pre><code class="hljs mermaid">graph TD
    A[ForkJoinPool任务执行] --&gt; B&#123;使用哪个API?&#125;
    B --&gt;|invoke()| C[✅ 正确方式]
    B --&gt;|submit()/execute()| D[❌ 错误方式]
    
    C --&gt; E[触发工作窃取机制]
    C --&gt; F[维护任务父子关系]
    C --&gt; G[支持fork()/join()调用链]
    C --&gt; H[同步等待结果]
    
    D --&gt; I[无法触发工作窃取]
    D --&gt; J[破坏任务分解结构]
    D --&gt; K[RecursiveTask无法正常工作]</code></pre>
<ol>
<li>
<p><strong>必须使用invoke()而非submit()/execute()</strong>：</p>
<ul>
<li><code>invoke()</code>是ForkJoinPool的专用API，专为工作窃取算法设计</li>
<li>只有通过<code>invoke()</code>提交的任务才能正确触发<code>fork()</code>和<code>join()</code>的执行机制</li>
<li><code>submit()/execute()</code>提交的任务无法参与工作窃取，违背了ForkJoinPool的设计初衷</li>
</ul>
</li>
<li>
<p>定义一个 RecursiveTask 或者 RecursiveAction，而不是直接使用 ForkJoinTask，然后让 ForkJoinPool 来 invoke 根 task。</p>
</li>
<li>
<p>每个任务内部：</p>
<ol>
<li>先检查任务大小，只有大任务才分解生成子任务，小任务直接计算。</li>
<li>从子任务列表中移除最后一个任务，保留给自己直接执行。</li>
<li>对其余子任务调用fork()（异步提交）。</li>
<li>对保留的任务调用compute()（同步执行）。</li>
</ol>
</li>
</ol>
<p><strong>Specification支撑</strong>：根据JSR 166规范和Doug Lea的设计原则，ForkJoinPool的<code>invoke()</code>方法是唯一能够正确激活工作窃取调度器的入口点。使用其他API会导致任务无法被正确分解和调度。<br>
5. 对其他任务进行 join 收集计算结果，合并进上一个计算结果里。<br>
6. 返回全部计算结果。<br>
3. 所以在任务外部使用 invoke，内部使用 fork/compute/join。外部不应该用fork()/join()，看上面的 arrange。</p>
<h3 id="4-4-关键设计决策解析">4.4 关键设计决策解析</h3>
<h4 id="1-为什么使用-recursivetask-而不是-recursiveaction？">1. 为什么使用 RecursiveTask 而不是 RecursiveAction？</h4>
<ul>
<li>需要返回搜索结果（List）</li>
<li>RecursiveTask 提供类型安全的返回值</li>
<li>符合分治模式：子任务结果合并为父任务结果</li>
</ul>
<h4 id="2-为什么设置threshold-100？">2. 为什么设置THRESHOLD=100？</h4>
<ul>
<li>任务分解粒度需要平衡：
<ul>
<li>太小：调度开销超过计算收益</li>
<li>
<ul>
<li>太大：负载不均衡，CPU核心利用率低</li>
</ul>
</li>
</ul>
</li>
<li>100是经验值，可根据文件大小调整</li>
<li>通过基准测试确定最优值</li>
</ul>
<h4 id="3-为什么fork其他任务-直接执行最后一个任务？">3. 为什么fork其他任务，直接执行最后一个任务？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 优化：fork其他任务，直接执行最后一个任务（避免不必要的调度开销）</span><br><span class="hljs-keyword">if</span> (subtasks.size() &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">lastTask</span> <span class="hljs-operator">=</span> subtasks.remove(subtasks.size() - <span class="hljs-number">1</span>);<br>    <br>    <span class="hljs-keyword">for</span> (FileSearchTask task : subtasks) &#123;<br>        task.fork(); <span class="hljs-comment">// 异步提交</span><br>    &#125;<br>    <br>    List&lt;SearchResult&gt; results = lastTask.compute(); <span class="hljs-comment">// 同步执行</span><br>    <br>    <span class="hljs-keyword">for</span> (FileSearchTask task : subtasks) &#123;<br>        results.addAll(task.join()); <span class="hljs-comment">// 等待完成</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>设计理由：</p>
<ul>
<li><strong>避免调度开销</strong>：直接compute()比fork()后再join()少一次入队出队操作</li>
<li><strong>缓存局部性</strong>：直接执行的任务与父任务共享数据，保持CPU缓存热度</li>
<li><strong>栈深度控制</strong>：避免过深的递归导致StackOverflowError</li>
<li><strong>注意</strong>：这里的&quot;最后一个任务&quot;不是指&quot;最大的任务&quot;，而是任意选择一个任务直接执行以减少调度开销</li>
</ul>
<h4 id="4-为什么创建自定义池而不是使用公共池？">4. 为什么创建自定义池而不是使用公共池？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> (<span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> createSearchPool()) &#123;<br>    <span class="hljs-keyword">return</span> pool.invoke(rootTask);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计理由</strong>：</p>
<ul>
<li><strong>资源隔离</strong>：避免影响其他使用公共池的组件</li>
<li><strong>参数定制</strong>：限制并行度（16），避免I/O瓶颈</li>
<li><strong>异常处理</strong>：自定义异常处理器，确保错误可见</li>
<li><strong>生命周期管理</strong>：try-with-resources确保池关闭</li>
</ul>
<h4 id="5-为什么asyncmode-false？">5. 为什么asyncMode=false？</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(parallelism, ..., <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>
<p><strong>设计理由</strong>：</p>
<ul>
<li>
<p><strong>LIFO模式</strong>：适合分治算法，保持缓存局部性</p>
</li>
<li>
<p><strong>asyncMode=true</strong>：使用FIFO模式，适合事件处理</p>
</li>
<li>
<p>文件搜索是典型的分治场景，LIFO更高效</p>
</li>
</ul>
<h2 id="5-常见错误模式与避坑指南">5. 常见错误模式与避坑指南</h2>
<h3 id="5-1-api混用错误">5.1 API混用错误</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ❌ 错误：在ForkJoinTask.compute()内部调用pool方法</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(leftDir, keyword);<br>    <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(rightDir, keyword);<br>    <br>    <span class="hljs-comment">// 错误1：绕过工作窃取优化</span><br>    pool.submit(left); <span class="hljs-comment">// 提交到共享队列，失去局部性</span><br>    <br>    <span class="hljs-comment">// 错误2：阻塞当前线程</span><br>    List&lt;SearchResult&gt; rightResults = pool.invoke(right); <span class="hljs-comment">// 完全阻塞</span><br>    <br>    <span class="hljs-comment">// 错误3：结果合并时可能未完成</span><br>    List&lt;SearchResult&gt; results = left.get(); <span class="hljs-comment">// 可能抛出异常</span><br>    results.addAll(rightResults);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>正确做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ✅ 正确：使用fork/join API</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(leftDir, keyword);<br>    <span class="hljs-type">FileSearchTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileSearchTask</span>(rightDir, keyword);<br>    <br>    <span class="hljs-comment">// 优化：fork较小的任务</span><br>    <span class="hljs-keyword">if</span> (leftDirSize &lt; rightDirSize) &#123;<br>        left.fork(); <span class="hljs-comment">// 无锁本地队列push</span><br>        List&lt;SearchResult&gt; results = right.compute(); <span class="hljs-comment">// 保持缓存</span><br>        results.addAll(left.join()); <span class="hljs-comment">// 协作式等待</span><br>        <span class="hljs-keyword">return</span> results;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        right.fork();<br>        List&lt;SearchResult&gt; results = left.compute();<br>        results.addAll(right.join());<br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-2-i-o阻塞错误">5.2 I/O阻塞错误</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ❌ 错误：在ForkJoinTask中执行阻塞I/O</span><br><span class="hljs-keyword">protected</span> List&lt;SearchResult&gt; <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file)) &#123;<br>        <span class="hljs-comment">// 阻塞读取文件</span><br>        <span class="hljs-type">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[fis.available()];<br>        fis.read(data); <span class="hljs-comment">// 阻塞I/O</span><br>        <br>        <span class="hljs-comment">// 处理数据...</span><br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>正确做法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ✅ 正确：I/O与计算分离</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReadTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;<span class="hljs-type">byte</span>[]&gt; &#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">byte</span>[] compute() &#123;<br>        <span class="hljs-comment">// 非阻塞I/O或使用NIO</span><br>        <span class="hljs-keyword">return</span> Files.readAllBytes(path);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileProcessTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;List&lt;SearchResult&gt;&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] fileData;<br>    <br>    <span class="hljs-keyword">protected</span> List&lt;SearchResult&gt; <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 纯CPU计算，无I/O</span><br>        List&lt;SearchResult&gt; results = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(fileData);<br>        <span class="hljs-comment">// 处理内容...</span><br>        <span class="hljs-keyword">return</span> results;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 外部协调</span><br><span class="hljs-type">byte</span>[] fileData = fileReadPool.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReadTask</span>(path)).get();<br>List&lt;SearchResult&gt; results = computePool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileProcessTask</span>(fileData));<br></code></pre></td></tr></table></figure>
<h3 id="两种线程池的本质区别">两种线程池的本质区别</h3>
<p>这个例子完美展示了不同类型线程池的应用场景：</p>
<pre><code class="hljs mermaid">graph TD
    A[任务类型分析] --&gt; B&#123;任务特征&#125;
    B --&gt;|阻塞IO操作| C[fileReadPool&lt;br/&gt;传统线程池]
    B --&gt;|CPU密集计算| D[computePool&lt;br/&gt;ForkJoinPool]
    
    C --&gt; E[submit().get()模式]
    C --&gt; F[适合阻塞操作]
    C --&gt; G[有限线程数]
    
    D --&gt; H[invoke()模式]
    D --&gt; I[适合计算密集]
    D --&gt; J[工作窃取算法]
    D --&gt; K[动态线程调整]</code></pre>
<p><strong>技术对比</strong>：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>fileReadPool (IO线程池)</th>
<th>computePool (ForkJoinPool)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>API使用</strong></td>
<td><code>submit().get()</code></td>
<td><code>invoke()</code></td>
</tr>
<tr>
<td><strong>任务类型</strong></td>
<td>IO密集型阻塞操作</td>
<td>CPU密集型计算任务</td>
</tr>
<tr>
<td><strong>线程模型</strong></td>
<td>固定大小线程池</td>
<td>动态调整的工作线程</td>
</tr>
<tr>
<td><strong>调度机制</strong></td>
<td>FIFO队列调度</td>
<td>工作窃取算法</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>文件读取、网络请求</td>
<td>分治算法、并行计算</td>
</tr>
</tbody>
</table>
<p><strong>设计原理</strong>：</p>
<ul>
<li><strong>IO线程池</strong>：使用传统<code>submit().get()</code>模式，因为IO操作是阻塞的，需要等待结果</li>
<li><strong>ForkJoinPool</strong>：使用<code>invoke()</code>模式，专为可分解的计算任务设计，能充分利用工作窃取算法提高并行效率</li>
</ul>
<h3 id="5-3-资源泄漏错误">5.3 资源泄漏错误</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误：不关闭自定义池</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br>pool.invoke(task); <span class="hljs-comment">// 池永远不会关闭</span><br></code></pre></td></tr></table></figure>
<p>正确做法（JDK 19+）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 19+ 正确：使用try-with-resources（ForkJoinPool实现了AutoCloseable）</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>()) &#123;<br>    <span class="hljs-keyword">return</span> pool.invoke(task);<br>&#125; <span class="hljs-comment">// 自动调用shutdown()和awaitTermination()</span><br></code></pre></td></tr></table></figure>
<p>正确做法（JDK 8-18）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// JDK 8-18：ForkJoinPool不实现AutoCloseable，需手动管理</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> pool.invoke(task);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    pool.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>要点：即使线程不会泄露，线程池仍然需要关闭，否则线程池实例本身会泄露。</strong></p>
<p>ForkJoinPool会自动回收空闲worker线程到0（通过<code>keepAliveTime</code>机制，默认60秒无任务后线程自动退出），因此<strong>线程本身不会泄露</strong>。但这并不意味着可以不关闭线程池——<strong>线程池实例本身持有的内部资源不会自动释放</strong>。临时创建的ForkJoinPool若不显式调用shutdown()/shutdownNow()，将导致以下资源泄露：</p>
<ol>
<li>内存资源泄露：</li>
</ol>
<ul>
<li>64位ctl状态字段（原子控制变量）</li>
<li>WorkQueue数组（每个worker线程的任务队列）</li>
<li>任务引用（队列中未处理的任务对象）</li>
<li>线程工厂实例（ForkJoinWorkerThreadFactory引用）</li>
<li>异常处理器（UncaughtExceptionHandler引用）</li>
<li>内部锁和条件变量（同步器对象）</li>
</ul>
<ol start="2">
<li>系统资源泄露：</li>
</ol>
<ul>
<li>文件描述符（如果ThreadFactory创建了带资源的线程）</li>
<li>本地内存（JVM内部线程状态结构）</li>
<li>类加载器引用（可能导致ClassLoader泄露）</li>
</ul>
<ol start="3">
<li>监控资源泄露：</li>
</ol>
<ul>
<li>JMX MBean注册（每个pool注册的监控指标）</li>
<li>线程统计信息（活跃/已完成任务计数器）</li>
</ul>
<p>commonPool()由JVM在shutdown hook中自动管理，手动关闭会破坏全局并发设施。生产环境应通过静态复用或池缓存机制管理ForkJoinPool实例，避免高频创建/销毁。每次临时创建后必须用try-finally确保关闭，否则在长时间运行的应用中将累积严重内存压力。</p>
<h2 id="6-父子任务死锁：传统线程池的致命缺陷与forkjoinpool的解决方案">6. 父子任务死锁：传统线程池的致命缺陷与ForkJoinPool的解决方案</h2>
<h3 id="6-1-问题场景：线程池饥饿死锁">6.1 问题场景：线程池饥饿死锁</h3>
<p>在使用传统<code>ThreadPoolExecutor</code>时，一个经典的陷阱是<strong>父子任务使用同一线程池导致的死锁</strong>。</p>
<h4 id="死锁复现代码">死锁复现代码</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolDeadlockDemo</span> &#123;<br>    <span class="hljs-comment">// 固定大小的线程池，只有2个线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 提交2个父任务，恰好占满线程池</span><br>        Future&lt;Integer&gt; f1 = pool.submit(() -&gt; parentTask(<span class="hljs-string">&quot;Parent-1&quot;</span>));<br>        Future&lt;Integer&gt; f2 = pool.submit(() -&gt; parentTask(<span class="hljs-string">&quot;Parent-2&quot;</span>));<br>        <br>        <span class="hljs-comment">// 永远无法完成 -- 死锁</span><br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + f1.get() + <span class="hljs-string">&quot;, &quot;</span> + f2.get());<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">parentTask</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        System.out.println(name + <span class="hljs-string">&quot; started on &quot;</span> + Thread.currentThread().getName());<br>        <br>        <span class="hljs-comment">// 父任务提交子任务到同一个线程池</span><br>        Future&lt;Integer&gt; childFuture = pool.submit(() -&gt; childTask(name));<br>        <br>        <span class="hljs-comment">// 父任务阻塞等待子任务完成</span><br>        <span class="hljs-comment">// 但子任务在队列中等待线程，而所有线程都被父任务占用</span><br>        <span class="hljs-keyword">return</span> childFuture.get(); <span class="hljs-comment">// 死锁点</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">childTask</span><span class="hljs-params">(String parentName)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Child of &quot;</span> + parentName + <span class="hljs-string">&quot; on &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="死锁分析">死锁分析</h4>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs subunit">时间线：<br>T1: Parent<span class="hljs-string">-1</span> 提交，获得 Thread<span class="hljs-string">-1</span>，开始执行<br>T2: Parent<span class="hljs-string">-2</span> 提交，获得 Thread<span class="hljs-string">-2</span>，开始执行<br>T3: Parent<span class="hljs-string">-1</span> 提交 Child<span class="hljs-string">-1</span> 到队列，调用 childFuture.get() 阻塞<br>T4: Parent<span class="hljs-string">-2</span> 提交 Child<span class="hljs-string">-2</span> 到队列，调用 childFuture.get() 阻塞<br>T5: 死锁形成<br>    - Thread<span class="hljs-string">-1</span> 被 Parent<span class="hljs-string">-1</span> 占用，等待 Child<span class="hljs-string">-1</span><br>    - Thread<span class="hljs-string">-2</span> 被 Parent<span class="hljs-string">-2</span> 占用，等待 Child<span class="hljs-string">-2</span><br>    - Child<span class="hljs-string">-1</span> 和 Child<span class="hljs-string">-2</span> 在队列中，等待空闲线程<br>    - 没有空闲线程，因为都被父任务占用<br></code></pre></td></tr></table></figure>
<p>这就是经典的<strong>线程池饥饿死锁</strong>（Thread Pool Starvation Deadlock）：</p>
<ul>
<li><strong>必要条件1</strong>：父任务持有线程资源</li>
<li><strong>必要条件2</strong>：父任务阻塞等待子任务</li>
<li><strong>必要条件3</strong>：子任务需要线程资源才能执行</li>
<li><strong>必要条件4</strong>：线程池容量有限</li>
</ul>
<h3 id="6-2-传统解决方案的局限性">6.2 传统解决方案的局限性</h3>
<h4 id="方案1：增大线程池容量">方案1：增大线程池容量</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">100</span>);<br></code></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>无法预知任务的嵌套深度</li>
<li>递归分治算法的任务数量呈指数增长</li>
<li>过大的线程池浪费资源，过小仍可能死锁</li>
</ul>
<h4 id="方案2：使用无界线程池">方案2：使用无界线程池</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newCachedThreadPool();<br></code></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>失去对并发度的控制</li>
<li>可能创建过多线程，导致OOM或上下文切换开销</li>
<li>不适合生产环境</li>
</ul>
<h4 id="方案3：父子任务使用不同线程池">方案3：父子任务使用不同线程池</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">parentPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">childPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure>
<p><strong>问题</strong>：</p>
<ul>
<li>需要预知任务层级结构</li>
<li>多层嵌套需要多个线程池</li>
<li>资源利用率低，管理复杂</li>
</ul>
<h3 id="6-3-forkjoinpool的根本性解决：协作式等待">6.3 ForkJoinPool的根本性解决：协作式等待</h3>
<p>ForkJoinPool通过<strong>协作式等待</strong>（Cooperative Waiting）从根本上解决了这个问题。</p>
<h4 id="核心机制：join-不是真正的阻塞">核心机制：join()不是真正的阻塞</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinTask.join() 的简化逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s;<br>    <span class="hljs-keyword">if</span> ((s = doJoin() &amp; DONE_MASK) != NORMAL)<br>        reportException(s);<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doJoin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> s; Thread t; ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue w;<br>    <br>    <span class="hljs-comment">// 1. 检查任务是否已完成</span><br>    <span class="hljs-keyword">if</span> ((s = status) &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> s;<br>    <br>    <span class="hljs-comment">// 2. 如果当前线程是 ForkJoinWorkerThread</span><br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread) &#123;<br>        wt = (ForkJoinWorkerThread)t;<br>        w = wt.workQueue;<br>        <br>        <span class="hljs-comment">// 3. 尝试从本地队列弹出并执行目标任务</span><br>        <span class="hljs-keyword">if</span> (w.tryUnpush(<span class="hljs-built_in">this</span>) &amp;&amp; (s = doExec()) &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> s;<br>        <br>        <span class="hljs-comment">// 4. 如果目标任务不在本地队列顶部，进入协作等待</span><br>        <span class="hljs-keyword">return</span> wt.pool.awaitJoin(w, <span class="hljs-built_in">this</span>, <span class="hljs-number">0L</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 5. 非 ForkJoinWorkerThread，使用外部等待</span><br>    <span class="hljs-keyword">return</span> externalAwaitDone();<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="协作等待的核心：awaitjoin">协作等待的核心：awaitJoin()</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ForkJoinPool.awaitJoin() 的简化逻辑</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitJoin</span><span class="hljs-params">(WorkQueue w, ForkJoinTask&lt;?&gt; task, <span class="hljs-type">long</span> deadline)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (task != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 循环直到任务完成</span><br>        <span class="hljs-keyword">while</span> ((s = task.status) &gt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 关键：不是阻塞等待，而是尝试帮助执行</span><br>            <span class="hljs-keyword">if</span> (!tryHelpStealer(w, task))  <span class="hljs-comment">// 尝试帮助窃取者</span><br>                <span class="hljs-keyword">if</span> (!tryCompensate(w))      <span class="hljs-comment">// 尝试补偿（创建新线程）</span><br>                    LockSupport.park(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// 仅当无事可做时才真正阻塞</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="帮助窃取者机制-help-stealer">帮助窃取者机制（Help Stealer）</h4>
<p>当线程A等待任务T完成时，如果T被线程B窃取：</p>
<ol>
<li>A不会阻塞等待</li>
<li>A会扫描B的工作队列</li>
<li>A帮助执行B队列中的任务（可能是T的子任务）</li>
<li>通过帮助B，间接加速T的完成</li>
</ol>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">场景：<span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span> 执行 <span class="hljs-variable">Parent</span>，<span class="hljs-variable">fork</span> 了 <span class="hljs-variable">Child</span>，然后 <span class="hljs-variable">join</span><span class="hljs-punctuation">(</span><span class="hljs-variable">Child</span><span class="hljs-punctuation">)</span><br>      <span class="hljs-variable">Child</span> 被 <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> 窃取<br><br>传统线程池：<br>  <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span>阻塞等待 <span class="hljs-variable">Child</span> 完成<span class="hljs-punctuation">]</span> <span class="hljs-operator">&lt;--</span> 线程资源浪费<br>  <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span>执行 <span class="hljs-variable">Child</span><span class="hljs-punctuation">]</span><br><br><span class="hljs-variable">ForkJoinPool</span>：<br>  <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">1</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span>发现 <span class="hljs-variable">Child</span> 被 <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> 窃取<span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">[</span>扫描 <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> 的队列<span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">[</span>帮助执行 <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span> 队列中的其他任务<span class="hljs-punctuation">]</span><br>            <span class="hljs-punctuation">[</span>间接加速 <span class="hljs-variable">Child</span> 完成<span class="hljs-punctuation">]</span><br>  <span class="hljs-built_in">Thread</span><span class="hljs-operator">-</span><span class="hljs-number">2</span><span class="hljs-operator">:</span> <span class="hljs-punctuation">[</span>执行 <span class="hljs-variable">Child</span><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure>
<h3 id="6-4-为什么父子任务可以不相互阻塞？">6.4 为什么父子任务可以不相互阻塞？</h3>
<p>这个问题的答案涉及ForkJoinTask接口设计的精妙之处：</p>
<h4 id="接口层面的异步化解耦">接口层面的异步化解耦</h4>
<p><code>ForkJoinTask</code>的<code>fork()</code>和<code>join()</code>方法在接口设计上实现了<strong>计算与等待的解耦</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// fork() 只是将任务入队，不执行</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title function_">fork</span><span class="hljs-params">()</span> &#123;<br>    Thread t;<br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread)<br>        ((ForkJoinWorkerThread)t).workQueue.push(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">else</span><br>        ForkJoinPool.common.externalPush(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br><span class="hljs-comment">// join() 不是简单等待，而是&quot;参与式等待&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V <span class="hljs-title function_">join</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (doJoin() != NORMAL)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>    <span class="hljs-keyword">return</span> getRawResult();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键设计点</strong>：</p>
<ol>
<li><strong>fork()是纯异步的</strong>：只负责将任务放入队列，立即返回</li>
<li><strong>join()是协作式的</strong>：不是被动等待，而是主动寻找可执行的工作</li>
<li><strong>compute()是可分解的</strong>：子类通过重写compute()定义分解逻辑</li>
</ol>
<h4 id="分治模式的天然适配">分治模式的天然适配</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (任务足够小) &#123;<br>        <span class="hljs-keyword">return</span> 直接计算();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 分解</span><br>    <span class="hljs-type">SubTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTask</span>(左半部分);<br>    <span class="hljs-type">SubTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubTask</span>(右半部分);<br>    <br>    <span class="hljs-comment">// fork() 只是入队，不阻塞</span><br>    left.fork();<br>    <br>    <span class="hljs-comment">// 当前线程直接执行 right，不入队</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">rightResult</span> <span class="hljs-operator">=</span> right.compute();<br>    <br>    <span class="hljs-comment">// join() 时，如果 left 还在本地队列，直接弹出执行</span><br>    <span class="hljs-comment">// 如果被窃取，则帮助窃取者执行其他任务</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">leftResult</span> <span class="hljs-operator">=</span> left.join();<br>    <br>    <span class="hljs-comment">// 合并</span><br>    <span class="hljs-keyword">return</span> leftResult + rightResult;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么不会死锁</strong>：</p>
<ol>
<li><code>right.compute()</code>直接在当前线程执行，不占用额外线程</li>
<li><code>left.join()</code>时，如果left还在本地队列顶部，直接弹出执行（tryUnpush）</li>
<li>如果left被窃取，当前线程不会阻塞，而是帮助执行其他任务</li>
<li>即使所有线程都在&quot;等待&quot;，它们实际上都在执行任务</li>
</ol>
<h3 id="6-5-线程补偿机制：有限度的弹性">6.5 线程补偿机制：有限度的弹性</h3>
<h4 id="线程可以无限补偿吗？">线程可以无限补偿吗？</h4>
<p><strong>答案是否定的</strong>。ForkJoinPool的线程补偿受到<code>maximumSpares</code>参数的严格限制。</p>
<h4 id="补偿机制的工作原理">补偿机制的工作原理</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// tryCompensate() 的简化逻辑</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryCompensate</span><span class="hljs-params">(WorkQueue w)</span> &#123;<br>    <span class="hljs-comment">// 检查是否可以创建补偿线程</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(ctl &amp; ~SMASK);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">pc</span> <span class="hljs-operator">=</span> config &amp; SMASK;  <span class="hljs-comment">// parallelism</span><br>    <br>    <span class="hljs-comment">// 计算当前spare线程数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">tc</span> <span class="hljs-operator">=</span> (<span class="hljs-type">short</span>)(ctl &gt;&gt;&gt; TC_SHIFT);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ac</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>)(ctl &gt;&gt; AC_SHIFT);<br>    <br>    <span class="hljs-comment">// 如果spare线程数已达上限，不再创建</span><br>    <span class="hljs-keyword">if</span> (tc &gt;= pc + MAX_SPARES) <span class="hljs-comment">// MAX_SPARES 默认为 256</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 创建补偿线程</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 条件满足 */</span>) &#123;<br>        createWorker();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="线程数的硬性上限">线程数的硬性上限</h4>
<p>ForkJoinPool的线程数永远不会超过：<strong>parallelism + maximumSpares</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 系统属性配置</span><br>java.util.concurrent.ForkJoinPool.common.maximumSpares = <span class="hljs-number">256</span> <span class="hljs-comment">// 默认值</span><br></code></pre></td></tr></table></figure>
<h4 id="当达到上限后会发生什么？">当达到上限后会发生什么？</h4>
<ol>
<li><strong>无法创建新的补偿线程</strong></li>
<li><strong>tryCompensate()返回false</strong></li>
<li><strong>线程进入真正的阻塞等待</strong>（LockSupport.park）</li>
<li><strong>如果所有线程都阻塞，可能导致吞吐量下降</strong></li>
</ol>
<h4 id="为什么要限制补偿？">为什么要限制补偿？</h4>
<ol>
<li><strong>防止线程爆炸</strong>：无限补偿可能导致创建过多线程</li>
<li><strong>资源保护</strong>：每个线程都消耗栈内存（默认1MB）</li>
<li><strong>上下文切换开销</strong>：过多线程导致调度开销增加</li>
<li><strong>设计哲学</strong>：ForkJoinPool假设任务是CPU密集型的，不应频繁阻塞</li>
</ol>
<h4 id="最佳实践">最佳实践</h4>
<ol>
<li><strong>避免在ForkJoinTask中执行阻塞I/O</strong></li>
<li><strong>如果必须阻塞，使用ManagedBlocker接口</strong></li>
<li><strong>合理设置parallelism和maximumSpares</strong></li>
<li><strong>监控getPoolSize()和getActiveThreadCount()</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用ManagedBlocker处理阻塞操作</span><br>ForkJoinPool.managedBlock(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>.ManagedBlocker() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">block</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 执行阻塞操作</span><br>        result = blockingOperation();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReleasable</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 检查是否已完成</span><br>        <span class="hljs-keyword">return</span> result != <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h3 id="6-6-对比验证">6.6 对比验证</h3>
<h4 id="forkjoinpool版本-不会死锁">ForkJoinPool版本（不会死锁）</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ForkJoinNoDeadlockDemo</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">2</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ParentTask</span>(<span class="hljs-string">&quot;Root&quot;</span>));<br>        System.out.println(<span class="hljs-string">&quot;Result: &quot;</span> + result); <span class="hljs-comment">// 正常完成</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParentTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>        <br>        ParentTask(String name) &#123; <span class="hljs-built_in">this</span>.name = name; &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(name + <span class="hljs-string">&quot; on &quot;</span> + Thread.currentThread().getName());<br>            <br>            <span class="hljs-comment">// 创建子任务</span><br>            <span class="hljs-type">ChildTask</span> <span class="hljs-variable">child1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildTask</span>(name + <span class="hljs-string">&quot;-Child1&quot;</span>);<br>            <span class="hljs-type">ChildTask</span> <span class="hljs-variable">child2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChildTask</span>(name + <span class="hljs-string">&quot;-Child2&quot;</span>);<br>            <br>            <span class="hljs-comment">// fork 子任务</span><br>            child1.fork();<br>            child2.fork();<br>            <br>            <span class="hljs-comment">// join 不会死锁</span><br>            <span class="hljs-comment">// 当前线程会帮助执行子任务，而不是阻塞等待</span><br>            <span class="hljs-keyword">return</span> child1.join() + child2.join();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChildTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Integer&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>        <br>        ChildTask(String name) &#123; <span class="hljs-built_in">this</span>.name = name; &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Integer <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(name + <span class="hljs-string">&quot; on &quot;</span> + Thread.currentThread().getName());<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">21</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="执行结果">执行结果</h4>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Root</span> <span class="hljs-literal">on</span> ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span><br><span class="hljs-attribute">Root</span>-Child1 <span class="hljs-literal">on</span> ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">1</span>  // 父线程帮助执行子任务<br><span class="hljs-attribute">Root</span>-Child2 <span class="hljs-literal">on</span> ForkJoinPool-<span class="hljs-number">1</span>-worker-<span class="hljs-number">2</span><br><span class="hljs-attribute">Result</span>: <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure>
<p>注意：即使只有2个线程，父任务也能完成，因为父线程在<code>join()</code>时直接执行了<code>Child1</code>。</p>
<h3 id="6-7-设计启示">6.7 设计启示</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>ThreadPoolExecutor</th>
<th>ForkJoinPool</th>
</tr>
</thead>
<tbody>
<tr>
<td>等待语义</td>
<td>阻塞等待（浪费线程）</td>
<td>协作等待（帮助执行）</td>
</tr>
<tr>
<td>父子任务</td>
<td>可能死锁</td>
<td>天然支持</td>
</tr>
<tr>
<td>线程利用率</td>
<td>等待时为0</td>
<td>等待时仍在工作</td>
</tr>
<tr>
<td>线程补偿</td>
<td>无</td>
<td>有限度补偿（maximumSpares）</td>
</tr>
<tr>
<td>适用场景</td>
<td>独立任务</td>
<td>分治/递归任务</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>核心洞察</strong>：ForkJoinPool的<code>join()</code>不是&quot;等待&quot;，而是&quot;参与&quot;。线程不会因为等待子任务而闲置，而是主动寻找可执行的工作。这种设计从根本上消除了父子任务死锁的可能性，同时通过有限度的线程补偿机制，在保证系统稳定性的前提下提供了额外的弹性。</p>
</blockquote>
<h2 id="7-结论：设计的本质">7. 结论：设计的本质</h2>
<p>ForkJoinPool不是&quot;另一个线程池&quot;，而是<strong>为分治并行量身定制的执行引擎</strong>。其核心设计决策源于对问题域的深刻理解：</p>
<ol>
<li><strong>任务结构驱动执行模型</strong>：分治算法的&quot;父-子&quot;任务结构要求特殊的调度策略，工作窃取正是为这种结构优化。</li>
<li><strong>局部性优先于公平性</strong>：LIFO本地执行牺牲任务执行的公平性，换取时间局部性的显著提升。</li>
<li><strong>协作优于竞争</strong>：线程从&quot;竞争共享资源&quot;转变为&quot;协作完成任务&quot;，资源利用率显著提高。</li>
<li><strong>动态适应优于静态配置</strong>：与ThreadPoolExecutor的&quot;核心-最大&quot;静态模型不同，ForkJoinPool通过目标并行度+spare线程机制，动态适应工作负载。</li>
<li><strong>资源效率优于固定开销</strong>：与TPE保持核心线程不同，FJP回收所有空闲线程，适合间歇性负载。</li>
</ol>
<p>正如Doug Lea在论文结论中所述：</p>
<blockquote>
<p>“This paper has demonstrated that it is possible to support portable, efficient, scalable parallel processing in pure Java, with a programming model and framework that can be convenient for programmers.”</p>
<p>（本论文证明了，纯粹的Java语言也能够实现可移植、高效可伸缩的并行处理，并且能够为程序员提供便捷的编程模型和框架。）</p>
</blockquote>
<p>理解ForkJoinPool的核心数据结构和设计哲学，才能在正确场景发挥其价值。它不是万能的，但在分治并行领域，它代表了并发计算的理论最优解。</p>
<p><strong>ForkJoinPool参考文献</strong>：</p>
<ul>
<li>Doug Lea. “A Java Fork/Join Framework”. In Proceedings of the ACM 2000 conference on Java Grande, 2000. <a target="_blank" rel="noopener" href="https://gee.cs.oswego.edu/dl/papers/fj.pdf">https://gee.cs.oswego.edu/dl/papers/fj.pdf</a></li>
</ul>
<hr>
<h1>异步编程的进化</h1>
<p>本章节一部分来自于qwen，一部分来自于以下文章：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2022/05/12/principles-and-practices-of-completablefuture.html">《CompletableFuture原理与实践-外卖商家端API的异步化》</a></li>
</ol>
<h2 id="演进本质">演进本质</h2>
<pre><code class="hljs mermaid">graph LR
    A[Java 5 Future] --&gt;|阻塞痛点| B[Guava ListenableFuture]
    B --&gt;|回调地狱| C[CompletableFuture]
    C --&gt;|流处理需求| D[RxJava]
    D --&gt;|Spring整合| E[Reactor]
    
    A --&gt;|范式转变| F[命令式-&gt;声明式]
    B --&gt;|抽象提升| G[事件驱动-&gt;数据流]
    C --&gt;|能力增强| H[组合-&gt;背压]
    D &amp; E --&gt;|统一理念| I[异步即数据流]</code></pre>
<ul>
<li>控制流：阻塞等待 → 回调响应 → 声明式组合 → 响应式流</li>
<li>错误处理：分散try-catch → 回调onFailure → 链式exceptionally → 流式onError</li>
<li>组合能力：无 → 有限transform → 丰富组合操作符 → 完整流处理</li>
<li>背压支持：无 → 无 → 有限 → 完整内建支持</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:left">模式</th>
<th style="text-align:left">核心特征</th>
<th style="text-align:left">编程范式</th>
<th style="text-align:left">适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Java 5 Future</td>
<td style="text-align:left">阻塞等待</td>
<td style="text-align:left">命令式</td>
<td style="text-align:left">简单异步任务，兼容性要求高</td>
</tr>
<tr>
<td style="text-align:left">Guava ListenableFuture</td>
<td style="text-align:left">回调驱动</td>
<td style="text-align:left">事件驱动</td>
<td style="text-align:left">中等复杂度，需要非阻塞回调</td>
</tr>
<tr>
<td style="text-align:left">CompletableFuture</td>
<td style="text-align:left">链式组合</td>
<td style="text-align:left">声明式</td>
<td style="text-align:left">复杂异步流程，需要组合和错误处理</td>
</tr>
<tr>
<td style="text-align:left">RxJava</td>
<td style="text-align:left">响应式流</td>
<td style="text-align:left">函数式响应式</td>
<td style="text-align:left">事件流处理，背压支持，复杂数据转换</td>
</tr>
<tr>
<td style="text-align:left">Reactor</td>
<td style="text-align:left">响应式流</td>
<td style="text-align:left">函数式响应式</td>
<td style="text-align:left">Spring生态，高性能流处理，背压内建</td>
</tr>
</tbody>
</table>
<h2 id="传统调用时序">传统调用时序</h2>
<h3 id="java-5-future">Java 5 Future</h3>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#FFF5E1&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant Executor as ExecutorService
    participant Future as Future&lt;T&gt;
    participant Task as Callable&lt;T&gt;

    Note over Client,Task: Java 5 Future (阻塞式)
    Client-&gt;&gt;Executor: submit(Callable)
    Executor-&gt;&gt;Future: 创建Future
    Executor--&gt;&gt;Client: 返回Future
    Note right of Client: 非阻塞返回

    Executor-&gt;&gt;Task: 执行任务
    Task--&gt;&gt;Executor: 返回结果

    Client-&gt;&gt;Future: get() / get(timeout)
    Note right of Client: 阻塞等待
    Future--&gt;&gt;Client: 返回结果或抛出异常
    Note over Client: 阻塞式: submit/get</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心特点：阻塞等待结果</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;String&gt; future = executor.submit(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello Future&quot;</span>;<br>&#125;);<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// [注意] 阻塞当前线程等待结果</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(<span class="hljs-number">2</span>, TimeUnit.SECONDS);<br>    System.out.println(result);<br>&#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>    System.err.println(<span class="hljs-string">&quot;超时了!&quot;</span>);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    executor.shutdown();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="guava-listenablefuture">Guava ListenableFuture</h3>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#D5E8D4&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant Executor as ListeningExecutorService
    participant Future as ListenableFuture&lt;T&gt;
    participant Callback as FutureCallback&lt;T&gt;
    participant Task as Callable&lt;T&gt;

    Note over Client,Task: Guava ListenableFuture (回调式)
    Client-&gt;&gt;Executor: submit(Callable)
    Executor-&gt;&gt;Future: 创建ListenableFuture
    Executor--&gt;&gt;Client: 返回ListenableFuture
    Note right of Client: 非阻塞返回

    Client-&gt;&gt;Future: addCallback(FutureCallback)
    Note right of Client: 注册回调，非阻塞

    Executor-&gt;&gt;Task: 执行任务
    Task--&gt;&gt;Executor: 返回结果

    Future-&gt;&gt;Callback: onSuccess(result) 或 onFailure(ex)
    Note over Client: 回调式: submit/addCallback</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心特点：回调处理结果</span><br><span class="hljs-type">ListeningExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> MoreExecutors.listeningDecorator(<br>    Executors.newSingleThreadExecutor()<br>);<br><br>ListenableFuture&lt;String&gt; future = executor.submit(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello ListenableFuture&quot;</span>;<br>&#125;);<br><br><span class="hljs-comment">// [正确] 非阻塞：注册回调处理结果</span><br>Futures.addCallback(future, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(String result)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;成功: &quot;</span> + result);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>        System.err.println(<span class="hljs-string">&quot;失败: &quot;</span> + t.getMessage());<br>    &#125;<br>&#125;, executor);<br><br><span class="hljs-comment">// [注意] 需要手动关闭executor</span><br>executor.shutdown();<br></code></pre></td></tr></table></figure>
<p>这个方案是很容易产生回调地狱的，因为总是会有 addCallback + onSuccess 这种不可编排、组合 api 不适合把大型并发结果组合在一起的缺陷：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 回调地狱示例</span><br>ListenableFuture&lt;User&gt; userFuture = userService.getUser(userId);<br><br><span class="hljs-comment">// 第一层回调</span><br>Futures.addCallback(userFuture, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;User&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(User user)</span> &#123;<br>        <span class="hljs-comment">// 第二层回调：需要 user 结果</span><br>        ListenableFuture&lt;List&lt;Order&gt;&gt; ordersFuture = orderService.getOrders(user.getId());<br>        <br>        Futures.addCallback(ordersFuture, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;List&lt;Order&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(List&lt;Order&gt; orders)</span> &#123;<br>                <span class="hljs-comment">// 第三层回调：需要 orders 结果</span><br>                ListenableFuture&lt;List&lt;Product&gt;&gt; productsFuture = <br>                    productService.getProducts(orders.stream()<br>                        .map(Order::getProductId)<br>                        .collect(Collectors.toList()));<br>                <br>                Futures.addCallback(productsFuture, <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;List&lt;Product&gt;&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(List&lt;Product&gt; products)</span> &#123;<br>                        <span class="hljs-comment">// 第四层回调：需要 products 结果</span><br>                        <span class="hljs-comment">// 终于可以组装最终结果了...</span><br>                        <span class="hljs-type">OrderDetails</span> <span class="hljs-variable">details</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">OrderDetails</span>(user, orders, products);<br>                        log.info(<span class="hljs-string">&quot;订单详情: &#123;&#125;&quot;</span>, details);<br>                    &#125;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>                        log.error(<span class="hljs-string">&quot;Products retrieval failed&quot;</span>, t);<br>                        auditService.logFailure(<span class="hljs-string">&quot;products&quot;</span>, t);<br>                    &#125;<br>                &#125;, executor);<br>            &#125;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>                log.error(<span class="hljs-string">&quot;Orders retrieval failed&quot;</span>, t);<br>                auditService.logFailure(<span class="hljs-string">&quot;orders&quot;</span>, t);<br>            &#125;<br>        &#125;, executor);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span> &#123;<br>        log.error(<span class="hljs-string">&quot;User retrieval failed&quot;</span>, t);<br>        auditService.logFailure(<span class="hljs-string">&quot;user&quot;</span>, t);<br>    &#125;<br>&#125;, executor);<br></code></pre></td></tr></table></figure>
<h3 id="completablefuture">CompletableFuture</h3>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#DAE8FC&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant CF1 as CompletableFuture&lt;T&gt;
    participant CF2 as CompletableFuture&lt;U&gt;
    participant Executor as Executor

    Note over Client,Executor: CompletableFuture (链式组合)
    Client-&gt;&gt;CF1: supplyAsync(Supplier)
    CF1--&gt;&gt;Client: 返回CompletableFuture
    Note right of Client: 非阻塞返回

    Client-&gt;&gt;CF1: thenApply(Function)
    CF1-&gt;&gt;CF2: 创建新的CompletableFuture
    CF2--&gt;&gt;Client: 返回新的CompletableFuture
    Note right of Client: 链式组合，非阻塞

    Executor-&gt;&gt;CF1: 执行任务
    CF1-&gt;&gt;CF2: 传递结果
    CF2--&gt;&gt;Client: 完成时通知
    Note over Client: 链式: supplyAsync/thenApply/thenCompose</code></pre>
<p>CompletableFuture 和 ListenableFuture 的设计哲学差异：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ListenableFuture 设计哲学：</span><br><span class="hljs-comment">// &quot;当异步操作完成时，通知我&quot;</span><br>future.addCallback(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureCallback</span>&lt;T&gt;() &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onSuccess</span><span class="hljs-params">(T result)</span>;    <span class="hljs-comment">// 回调处理成功</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">onFailure</span><span class="hljs-params">(Throwable t)</span>; <span class="hljs-comment">// 回调处理失败</span><br>&#125;);<br><br><span class="hljs-comment">// CompletableFuture 设计哲学：</span><br><span class="hljs-comment">// &quot;将这个异步操作与下一个操作组合起来&quot;</span><br>future.thenCompose(result -&gt; nextOperation(result))<br>      .thenApply(transformed -&gt; process(transformed))<br>      .exceptionally(ex -&gt; handle(ex));<br></code></pre></td></tr></table></figure>
<h4 id="执行树">执行树</h4>
<p><img src="CompletableFuture%E6%89%A7%E8%A1%8C%E6%A0%91.png" alt="CompletableFuture执行树.png"></p>
<h4 id="核心-api">核心 API</h4>
<pre><code class="hljs mermaid">classDiagram
    class CompletableFuture~T~ &#123;
        &lt;&lt;核心类&gt;&gt;
        +T result
        +Throwable exception
        +Object stack
        
        %% 创建方法
        +supplyAsync(Supplier~T~) CompletableFuture~T~
        +runAsync(Runnable) CompletableFuture~Void~
        +completedFuture(T) CompletableFuture~T~
        
        %% 转换方法
        +thenApply(Function) CompletableFuture~U~
        +thenApplyAsync(Function) CompletableFuture~U~
        +thenCompose(Function) CompletableFuture~U~
        
        %% 消费方法
        +thenAccept(Consumer) CompletableFuture~Void~
        +thenRun(Runnable) CompletableFuture~Void~
        
        %% 组合方法
        +thenCombine(CompletableFuture, BiFunction) CompletableFuture~V~
        +allOf(CompletableFuture...) CompletableFuture~Void~
        +anyOf(CompletableFuture...) CompletableFuture~Object~
        
        %% 异常处理
        +exceptionally(Function) CompletableFuture~T~
        +handle(BiFunction) CompletableFuture~U~
        +whenComplete(BiConsumer) CompletableFuture~T~
        
        %% 完成方法
        +complete(T) boolean
        +completeExceptionally(Throwable) boolean
        
        %% 获取结果
        +get() T
        +join() T
        +getNow(T) T
    &#125;
    
    class CompletionStage~T~ &#123;
        &lt;&lt;接口&gt;&gt;
        +thenApply(Function) CompletionStage~U~
        +thenCompose(Function) CompletionStage~U~
        +thenCombine(CompletionStage, BiFunction) CompletionStage~V~
        +exceptionally(Function) CompletionStage~T~
    &#125;
    
    class Future~T~ &#123;
        &lt;&lt;接口&gt;&gt;
        +get() T
        +get(long, TimeUnit) T
        +cancel(boolean) boolean
        +isDone() boolean
        +isCancelled() boolean
    &#125;
    
    CompletableFuture ..|&gt; CompletionStage : implements
    CompletableFuture ..|&gt; Future : implements</code></pre>
<h4 id="使用原则">使用原则</h4>
<h5 id="原则一：异步回调要传线程池">原则一：异步回调要传线程池</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 不指定线程池，使用默认的ForkJoinPool.commonPool()</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))  <span class="hljs-comment">// 可能在commonPool线程执行</span><br>    .thenAccept(result -&gt; save(result)); <span class="hljs-comment">// 可能在调用线程执行</span><br><br><span class="hljs-comment">// [正确] 明确指定线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ioExecutor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuExecutor</span> <span class="hljs-operator">=</span> Executors.newWorkStealingPool();<br><br>CompletableFuture.supplyAsync(() -&gt; fetchData(), ioExecutor)<br>    .thenApplyAsync(data -&gt; process(data), cpuExecutor)<br>    .thenAcceptAsync(result -&gt; save(result), ioExecutor);<br></code></pre></td></tr></table></figure>
<h5 id="原则二：completablefuture-中不要吞异常">原则二：CompletableFuture 中不要吞异常</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 异常被吞掉，无法感知</span><br>CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;出错了&quot;</span>);<br>&#125;).thenApply(result -&gt; result + <span class="hljs-string">&quot;processed&quot;</span>);<br><span class="hljs-comment">// 如果不调用get/join，异常永远不会被发现</span><br><br><span class="hljs-comment">// [正确] 使用exceptionally或handle处理异常</span><br>CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;出错了&quot;</span>);<br>&#125;).exceptionally(ex -&gt; &#123;<br>    log.error(<span class="hljs-string">&quot;任务执行失败&quot;</span>, ex);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;默认值&quot;</span>;<br>&#125;).thenApply(result -&gt; result + <span class="hljs-string">&quot;processed&quot;</span>);<br><br><span class="hljs-comment">// [更好] 使用whenComplete记录日志，不影响异常传播</span><br>CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;出错了&quot;</span>);<br>&#125;).whenComplete((result, ex) -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (ex != <span class="hljs-literal">null</span>) &#123;<br>        log.error(<span class="hljs-string">&quot;任务执行失败&quot;</span>, ex);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>
<h5 id="原则三：自定义线程池时-注意饱和策略">原则三：自定义线程池时，注意饱和策略</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 使用无界队列，可能导致OOM</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;()  <span class="hljs-comment">// 无界队列</span><br>);<br><br><span class="hljs-comment">// [正确] 使用有界队列 + 合适的拒绝策略</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>),<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()  <span class="hljs-comment">// 调用者执行策略</span><br>);<br></code></pre></td></tr></table></figure>
<h5 id="原则四：正确进行异常处理">原则四：正确进行异常处理</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 只处理部分异常</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))<br>    .exceptionally(ex -&gt; handleFetchError(ex));  <span class="hljs-comment">// 只能处理fetchData的异常</span><br><br><span class="hljs-comment">// [正确] 在链的末端统一处理异常</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))<br>    .thenApply(result -&gt; transform(result))<br>    .exceptionally(ex -&gt; &#123;<br>        <span class="hljs-comment">// 处理整个链中的任何异常</span><br>        log.error(<span class="hljs-string">&quot;处理失败&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> defaultValue;<br>    &#125;);<br><br><span class="hljs-comment">// [更好] 使用handle同时处理结果和异常</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))<br>    .handle((result, ex) -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (ex != <span class="hljs-literal">null</span>) &#123;<br>            log.error(<span class="hljs-string">&quot;处理失败&quot;</span>, ex);<br>            <span class="hljs-keyword">return</span> defaultValue;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<h5 id="原则五：合理设置超时">原则五：合理设置超时</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 没有超时控制</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-comment">// 可能永远阻塞</span><br>    <span class="hljs-keyword">return</span> slowService.call();<br>&#125;);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.join();  <span class="hljs-comment">// 可能永远阻塞</span><br><br><span class="hljs-comment">// [正确] Java 9+ 使用orTimeout</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">return</span> slowService.call();<br>&#125;).orTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br><br><span class="hljs-comment">// [正确] Java 8 使用get with timeout</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.get(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>&#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>    future.cancel(<span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 处理超时</span><br>&#125;<br><br><span class="hljs-comment">// [更好] 使用completeOnTimeout提供默认值 (Java 9+)</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-keyword">return</span> slowService.call();<br>&#125;).completeOnTimeout(<span class="hljs-string">&quot;默认值&quot;</span>, <span class="hljs-number">5</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>
<h5 id="completablefuture-allof-的超时控制">CompletableFuture.allOf 的超时控制</h5>
<p><code>CompletableFuture.allOf</code> 提供了一种更现代的批量任务等待方式，其核心优势体现在以下几个方面：</p>
<p><strong>统一异常处理</strong></p>
<p>传统的 <code>Future.get</code> 方式需要对每个任务单独捕获异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传统方式：重复的 try-catch</span><br><span class="hljs-keyword">for</span> (Future&lt;Response&gt; future : futures) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        future.get(<span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>    &#125; <span class="hljs-keyword">catch</span> (TimeoutException e) &#123;<br>        log.error(<span class="hljs-string">&quot;Task timeout&quot;</span>, e);<br>    &#125; <span class="hljs-keyword">catch</span> (ExecutionException e) &#123;<br>        log.error(<span class="hljs-string">&quot;Task failed&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>而 <code>CompletableFuture.allOf</code> 可以通过调用链统一处理所有子任务的异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 现代方式：统一的异常处理</span><br>CompletableFuture.allOf(completableFutures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>]))<br>    .exceptionally(e -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;One or more tasks failed:&quot;</span>, e);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;)<br>    .join();<br></code></pre></td></tr></table></figure>
<p>这种方式的优势在于：</p>
<ul>
<li><strong>单一职责</strong>：异常处理逻辑集中在一处，易于维护</li>
<li><strong>避免重复</strong>：不需要为每个任务写相同的 try-catch</li>
<li><strong>声明式风格</strong>：通过函数式编程链表达&quot;等待所有完成，统一处理异常&quot;的意图</li>
</ul>
<p><strong>组合式编程</strong></p>
<p><code>CompletableFuture.allOf</code> 支持链式调用，可以轻松组合多个异步操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture.allOf(futures)<br>    .thenRun(() -&gt; log.info(<span class="hljs-string">&quot;All tasks completed&quot;</span>))<br>    .exceptionally(e -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Some tasks failed&quot;</span>, e);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;)<br>    .orTimeout(<span class="hljs-number">5</span>, TimeUnit.SECONDS)  <span class="hljs-comment">// 整体超时</span><br>    .join();<br></code></pre></td></tr></table></figure>
<p><strong>与 Future.get 的关键区别</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Future.get 逐个等待</th>
<th>CompletableFuture.allOf</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>等待策略</strong></td>
<td>串行等待，总时间 = N x timeout</td>
<td>并行等待，总时间 = max(各任务时间)</td>
</tr>
<tr>
<td><strong>异常处理</strong></td>
<td>每个任务单独 try-catch</td>
<td>统一的 exceptionally 处理</td>
</tr>
<tr>
<td><strong>超时语义</strong></td>
<td>每个任务独立的超时</td>
<td>整体超时（所有任务的总时间）</td>
</tr>
<tr>
<td><strong>代码风格</strong></td>
<td>命令式，循环 + try-catch</td>
<td>声明式，链式调用</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>可以中途退出（break/continue）</td>
<td>必须等待所有任务完成</td>
</tr>
</tbody>
</table>
<p><strong>注意事项</strong></p>
<ol>
<li><strong>超时控制</strong>：<code>allOf</code> 本身不提供超时功能，需要配合 <code>get(timeout)</code> 或 <code>orTimeout</code> 使用</li>
<li><strong>无法中途退出</strong>：一旦调用 <code>allOf</code>，必须等待所有任务完成（即使部分任务已经失败）</li>
<li><strong>异常传播</strong>：任何一个子任务失败，<code>allOf</code> 都会失败，异常会被封装在 <code>CompletionException</code> 中</li>
</ol>
<h5 id="completablefuture-ortimeout-底层实现深入分析">CompletableFuture.orTimeout 底层实现深入分析</h5>
<p><code>CompletableFuture.orTimeout()</code> 和 JavaScript 的 <code>Promise.race + setTimeout</code> 在表面上实现了相同的功能——为异步操作附加超时控制。但二者的底层机制截然不同，这种差异根植于两种语言完全不同的并发模型。</p>
<p><strong>orTimeout 源码剖析</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java: CompletableFuture.orTimeout 的底层实现 (JDK 9+, 简化)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;T&gt; <span class="hljs-title function_">orTimeout</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> &#123;<br>    <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// Delayer 是一个静态内部类，持有一个 ScheduledThreadPoolExecutor</span><br>        <span class="hljs-comment">// 本质上是向线程池提交了一个延迟任务</span><br>        whenComplete(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Canceller</span>(<br>            Delayer.delay(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Timeout</span>(<span class="hljs-built_in">this</span>), timeout, unit)));<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>&#125;<br><br><span class="hljs-comment">// Delayer 的实现</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Delayer</span> &#123;<br>    <span class="hljs-comment">// 守护线程池，全局共享，负责所有 CompletableFuture 的超时调度</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScheduledThreadPoolExecutor delayer;<br>    <span class="hljs-keyword">static</span> &#123;<br>        delayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">DaemonThreadFactory</span>());<br>        delayer.setRemoveOnCancelPolicy(<span class="hljs-literal">true</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> ScheduledFuture&lt;?&gt; delay(Runnable command, <span class="hljs-type">long</span> delay, TimeUnit unit) &#123;<br>        <span class="hljs-keyword">return</span> delayer.schedule(command, delay, unit);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Timeout 任务：超时后将 Future 以 TimeoutException 完成</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Timeout</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">final</span> CompletableFuture&lt;?&gt; future;<br>    Timeout(CompletableFuture&lt;?&gt; future) &#123; <span class="hljs-built_in">this</span>.future = future; &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (future != <span class="hljs-literal">null</span> &amp;&amp; !future.isDone())<br>            future.completeExceptionally(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>与 JavaScript setTimeout 的对比</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// JavaScript: Promise.race + setTimeout 的等价实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">orTimeout</span>(<span class="hljs-params">promise, timeoutMs</span>) &#123;<br>    <span class="hljs-keyword">const</span> timeoutPromise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">_, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// setTimeout 将回调注册到事件循环的定时器队列</span><br>        <span class="hljs-comment">// 由 libuv (Node.js) 或浏览器引擎的定时器机制管理</span><br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;TimeoutException&#x27;</span>));<br>        &#125;, timeoutMs);<br>    &#125;);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">race</span>([promise, timeoutPromise]);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>二者的关键差异可以从以下维度理解：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph Java[&quot;Java CompletableFuture.orTimeout&quot;]
        J1[&quot;ScheduledThreadPoolExecutor&lt;br/&gt;(守护线程池，全局共享)&quot;]
        J2[&quot;DelayQueue (最小堆)&lt;br/&gt;O(log n) 插入/取消&quot;]
        J3[&quot;独立线程执行超时回调&quot;]
        J4[&quot;多线程环境：需要 CAS/volatile&lt;br/&gt;保证 completeExceptionally 的线程安全&quot;]
        J1 --&gt; J2 --&gt; J3 --&gt; J4
    end
    
    subgraph JS[&quot;JavaScript setTimeout&quot;]
        JS1[&quot;事件循环定时器队列&lt;br/&gt;(libuv / 浏览器引擎)&quot;]
        JS2[&quot;红黑树或最小堆&lt;br/&gt;O(log n) 管理&quot;]
        JS3[&quot;主线程在下一个 tick 执行回调&quot;]
        JS4[&quot;单线程环境：天然无竞态&lt;br/&gt;无需同步原语&quot;]
        JS1 --&gt; JS2 --&gt; JS3 --&gt; JS4
    end
    
    style Java fill:#FFF3E0
    style JS fill:#FFFDE7</code></pre>
<table>
<thead>
<tr>
<th>维度</th>
<th>Java <code>CompletableFuture.orTimeout</code></th>
<th>JavaScript <code>Promise.race + setTimeout</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>定时器实现</strong></td>
<td><code>ScheduledThreadPoolExecutor</code>（线程池 + DelayQueue）</td>
<td>事件循环内置定时器（libuv 红黑树 / 浏览器最小堆）</td>
</tr>
<tr>
<td><strong>回调执行线程</strong></td>
<td>ScheduledThreadPoolExecutor 的工作线程</td>
<td>主线程（事件循环的下一个 tick）</td>
</tr>
<tr>
<td><strong>线程安全</strong></td>
<td>需要 CAS 保证 <code>completeExceptionally</code> 的原子性</td>
<td>单线程，天然无竞态</td>
</tr>
<tr>
<td><strong>取消机制</strong></td>
<td><code>Canceller</code> 在 Future 正常完成时取消定时任务；<code>setRemoveOnCancelPolicy(true)</code> 避免队列堆积</td>
<td><code>clearTimeout</code> 从定时器队列移除；但 <code>Promise.race</code> 无法自动取消</td>
</tr>
<tr>
<td><strong>精度</strong></td>
<td>依赖 <code>ScheduledThreadPoolExecutor</code> 的调度精度（通常毫秒级）</td>
<td>依赖事件循环 tick 频率（通常毫秒级，但受主线程阻塞影响）</td>
</tr>
<tr>
<td><strong>资源开销</strong></td>
<td>全局共享 1 个守护线程 + DelayQueue 堆操作</td>
<td>零额外线程，定时器由运行时管理</td>
</tr>
<tr>
<td><strong>任务真正取消</strong></td>
<td><code>orTimeout</code> 不会取消原始任务的执行线程</td>
<td><code>setTimeout</code> 不会取消原始 <code>fetch</code> 请求</td>
</tr>
</tbody>
</table>
<p><strong>共同缺陷：超时不等于取消</strong></p>
<p>无论是 Java 的 <code>orTimeout</code> 还是 JavaScript 的 <code>Promise.race</code>，超时后<strong>原始任务都不会被真正取消</strong>。Java 中 <code>supplyAsync</code> 提交的任务仍在线程池中运行；JavaScript 中 <code>fetch</code> 请求仍在进行网络 IO。要实现真正的取消，Java 需要配合 <code>cancel(true)</code> + 中断检查，JavaScript 需要使用 <code>AbortController</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java: 正确的超时 + 取消模式</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    <span class="hljs-comment">// 任务内部必须检查中断</span><br>    <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>        <span class="hljs-comment">// 执行工作...</span><br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>(<span class="hljs-string">&quot;interrupted&quot;</span>);<br>&#125;);<br><br>future.orTimeout(<span class="hljs-number">3</span>, TimeUnit.SECONDS)<br>      .whenComplete((result, ex) -&gt; &#123;<br>          <span class="hljs-keyword">if</span> (ex <span class="hljs-keyword">instanceof</span> TimeoutException) &#123;<br>              future.cancel(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 尝试中断底层线程</span><br>          &#125;<br>      &#125;);<br></code></pre></td></tr></table></figure>
<p><strong>本质差异</strong>：Java 的 <code>CompletableFuture</code> 是在多线程模型上构建的异步抽象，超时调度需要额外的线程池和同步机制；JavaScript 的 <code>Promise</code> 是在单线程事件循环上构建的异步抽象，超时调度由运行时内置的定时器队列完成，无需额外线程。二者在 API 层面趋于一致（都是&quot;给异步操作附加超时&quot;），但底层的复杂度差异巨大——这正是并发模型选择对上层 API 设计的深远影响。</p>
<h5 id="原则六：避免在回调中阻塞">原则六：避免在回调中阻塞</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 在回调中阻塞</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; &#123;<br>        <span class="hljs-comment">// 阻塞操作，会占用线程池线程</span><br>        <span class="hljs-keyword">return</span> anotherService.syncCall(data);<br>    &#125;);<br><br><span class="hljs-comment">// [正确] 使用thenCompose处理嵌套的异步操作</span><br>CompletableFuture.supplyAsync(() -&gt; fetchData())<br>    .thenCompose(data -&gt; &#123;<br>        <span class="hljs-comment">// 返回新的CompletableFuture，不阻塞</span><br>        <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(<br>            () -&gt; anotherService.syncCall(data), <br>            ioExecutor<br>        );<br>    &#125;);<br></code></pre></td></tr></table></figure>
<h4 id="完成保证原则">完成保证原则</h4>
<p>完成保证原则（Completion Guarantee Principle）是 CompletableFuture 编程中的一个核心设计模式，其核心思想是：</p>
<blockquote>
<p><strong>在调用 <code>join()</code> 或 <code>get()</code> 之前，确保目标 Future 已经完成，从而将阻塞操作转化为非阻塞的结果获取。</strong></p>
</blockquote>
<h5 id="为什么需要完成保证原则？">为什么需要完成保证原则？</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [问题] 直接调用join()会阻塞当前线程</span><br>CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;result&quot;</span>;<br>&#125;);<br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.join();  <span class="hljs-comment">// 阻塞1秒</span><br><br><span class="hljs-comment">// [解决] 使用allOf确保完成后再join</span><br>CompletableFuture&lt;Void&gt; allDone = CompletableFuture.allOf(future);<br>allDone.thenApply(v -&gt; &#123;<br>    <span class="hljs-comment">// 此时future已完成，join()立即返回，不阻塞</span><br>    <span class="hljs-keyword">return</span> future.join();<br>&#125;);<br></code></pre></td></tr></table></figure>
<h5 id="完成保证原则的核心模式">完成保证原则的核心模式</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 模式：allOf() + thenApplyAsync() + join()</span><br>List&lt;CompletableFuture&lt;String&gt;&gt; futures = services.stream()<br>    .map(service -&gt; CompletableFuture.supplyAsync(() -&gt; service.call(), ioExecutor))<br>    .collect(Collectors.toList());<br><br>CompletableFuture&lt;List&lt;String&gt;&gt; resultFuture = CompletableFuture<br>    .allOf(futures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>]))  <span class="hljs-comment">// 1. 等待所有完成</span><br>    .thenApplyAsync(v -&gt; &#123;                              <span class="hljs-comment">// 2. 完成后执行回调</span><br>        <span class="hljs-keyword">return</span> futures.stream()<br>            .map(CompletableFuture::join)               <span class="hljs-comment">// 3. join()不阻塞</span><br>            .collect(Collectors.toList());<br>    &#125;, cpuExecutor);<br></code></pre></td></tr></table></figure>
<h5 id="完整示例">完整示例</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.*;<br><span class="hljs-keyword">import</span> java.util.*;<br><span class="hljs-keyword">import</span> java.util.stream.*;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 完成保证原则示例</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 核心思想：在调用join()之前，确保Future已完成</span><br><span class="hljs-comment"> * 模式：allOf() + thenApplyAsync() + join()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CompletionGuaranteeExample</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建IO线程池（用于网络调用等IO密集型任务）</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ioPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>, r -&gt; &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;io-pool-&quot;</span> + System.nanoTime());<br>            t.setDaemon(<span class="hljs-literal">true</span>);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 创建CPU线程池（用于结果聚合等CPU密集型任务）</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<br>            Runtime.getRuntime().availableProcessors(),<br>            r -&gt; &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;cpu-pool-&quot;</span> + System.nanoTime());<br>                t.setDaemon(<span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        );<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;] 开始执行&quot;</span>);<br>            <br>            <span class="hljs-comment">// 1. 创建多个异步任务（模拟30个服务调用）</span><br>            List&lt;CompletableFuture&lt;String&gt;&gt; serviceFutures = IntStream.range(<span class="hljs-number">0</span>, <span class="hljs-number">30</span>)<br>                .mapToObj(i -&gt; CompletableFuture.supplyAsync(() -&gt; &#123;<br>                    System.out.println(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;] 调用服务 &quot;</span> + i);<br>                    simulateIoOperation(i);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;result-&quot;</span> + i;<br>                &#125;, ioPool))<br>                .collect(Collectors.toList());<br><br>            <span class="hljs-comment">// 2. 应用完成保证原则：allOf() + thenApplyAsync() + join()</span><br>            CompletableFuture&lt;List&lt;String&gt;&gt; resultFuture = CompletableFuture<br>                .allOf(serviceFutures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>])) <span class="hljs-comment">// 等待所有完成</span><br>                .thenApplyAsync(v -&gt; &#123; <span class="hljs-comment">// 所有future完成后才执行此回调</span><br>                    System.out.println(<span class="hljs-string">&quot;\n[正确] 原则验证: 所有服务调用已完成，开始聚合结果&quot;</span>);<br>                    System.out.println(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;] 聚合阶段启动（CPU密集型）&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// 关键点：此处join() 100% 不阻塞！</span><br>                    List&lt;String&gt; results = serviceFutures.stream()<br>                        .map(future -&gt; &#123;<br>                            <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                            <br>                            <span class="hljs-comment">// [要点] 完成保证原则核心：</span><br>                            <span class="hljs-comment">// 由于 allOf() 确保所有 future 已完成，</span><br>                            <span class="hljs-comment">// future.join() 直接返回内部存储的 result 字段</span><br>                            <span class="hljs-comment">// 无锁竞争、无上下文切换、无阻塞</span><br>                            <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> future.join(); <br>                            <br>                            <span class="hljs-type">long</span> <span class="hljs-variable">duration</span> <span class="hljs-operator">=</span> System.nanoTime() - start;<br>                            System.out.printf(<br>                                <span class="hljs-string">&quot;[%s] join() 耗时: %d ns, 结果: %s\n&quot;</span>, <br>                                Thread.currentThread().getName(), <br>                                duration, <br>                                result<br>                            );<br>                            <br>                            <span class="hljs-comment">// [注意] 重要验证：join() 耗时应接近 0（通常 &lt; 1000 ns）</span><br>                            <span class="hljs-comment">// 如果耗时 &gt; 10000 ns，说明存在阻塞（违反完成保证原则）</span><br>                            <span class="hljs-keyword">return</span> result;<br>                        &#125;)<br>                        .collect(Collectors.toList());<br>                    <br>                    <span class="hljs-keyword">return</span> results;<br>                &#125;, cpuPool) <span class="hljs-comment">// 显式指定CPU线程池，避免在IO线程执行计算</span><br>                .exceptionally(ex -&gt; &#123;<br>                    System.err.println(<span class="hljs-string">&quot;[&quot;</span> + Thread.currentThread().getName() + <span class="hljs-string">&quot;] [错误] 全局异常: &quot;</span> + ex.getMessage());<br>                    <span class="hljs-keyword">return</span> Arrays.asList(<span class="hljs-string">&quot;GLOBAL_FALLBACK&quot;</span>);<br>                &#125;);<br><br>            <span class="hljs-comment">// 3. 获取最终结果（末端阻塞，由主线程执行）</span><br>            List&lt;String&gt; results = resultFuture.join();<br>            System.out.println(<span class="hljs-string">&quot;\n最终聚合结果: &quot;</span> + results.size() + <span class="hljs-string">&quot; 个结果&quot;</span>);<br>            results.forEach(r -&gt; System.out.println(<span class="hljs-string">&quot;  - &quot;</span> + r));<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            ioPool.shutdown();<br>            cpuPool.shutdown();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟IO操作（可变延迟）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">simulateIoOperation</span><span class="hljs-params">(<span class="hljs-type">int</span> id)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 不同服务不同延迟，模拟真实场景</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span> + (id * <span class="hljs-number">10</span>) % <span class="hljs-number">200</span>;<br>            Thread.sleep(delay);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;IO操作被中断&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="对传统的线程池的效率改进">对传统的线程池的效率改进</h4>
<p>CompletableFuture 相对于一般线程池的改进主要来自于对于<strong>复杂结果编排的 API 优化，本身并不提供性能优化</strong>。</p>
<p>如果要实现性能优化，可以</p>
<ol>
<li>基于 Netty/NIO 实现了真正的异步 RPC：</li>
</ol>
<ul>
<li>发起调用后立即返回，不阻塞线程；</li>
<li>结果由 Netty 的 IO 线程（或专用回调线程）在数据到达时触发；</li>
<li>一个 IO 线程可同时管理成千上万个连接（C10K+）。</li>
</ul>
<ol start="2">
<li>CompletableFuture 被用作&quot;胶水层&quot;：</li>
</ol>
<ul>
<li>将 NIO 回调封装为 CompletableFuture（如 toCompletableFuture 工具方法）；</li>
<li>用 thenCompose / allOf 等组合多个异步 RPC；</li>
<li>业务逻辑不再关心回调注册，只关注数据流依赖。</li>
</ul>
<pre><code class="hljs mermaid">graph TD
    A[&quot;Client Request&quot;] --&gt; B[&quot;Inbound IO Thread&lt;br&gt;Netty EventLoop&quot;]
    B --&gt; C[&quot;Business Worker Thread&lt;br&gt;from biz-pool&quot;]

    C --&gt; d1[&quot;Create CF1 = new CompletableFuture()&quot;]
    C --&gt; d2[&quot;Create CF2 = new CompletableFuture()&quot;]
    C --&gt; d3[&quot;Create CF3 = new CompletableFuture()&quot;]

    d1 --&gt; e1[&quot;Register Observer1:&lt;br&gt;onSuccess → CF1.complete(...)&lt;br&gt;onFailure → CF1.completeEx(...)&quot;]
    d2 --&gt; e2[&quot;Register Observer2:&lt;br&gt;onSuccess → CF2.complete(...)&lt;br&gt;onFailure → CF2.completeEx(...)&quot;]
    d3 --&gt; e3[&quot;Register Observer3:&lt;br&gt;onSuccess → CF3.complete(...)&lt;br&gt;onFailure → CF3.completeEx(...)&quot;]

    e1 --&gt; f1[&quot;Call mtthrift.async(orderService, Observer1)&quot;]
    e2 --&gt; f2[&quot;Call mtthrift.async(productService, Observer2)&quot;]
    e3 --&gt; f3[&quot;Call mtthrift.async(deliveryService, Observer3)&quot;]

    f1 --&gt; g[&quot;Outbound IO Thread&lt;br&gt;Netty Client EventLoop&quot;]
    f2 --&gt; g
    f3 --&gt; g

    g --&gt; h1[&quot;(orderService)&quot;]
    g --&gt; h2[&quot;(productService)&quot;]
    g --&gt; h3[&quot;(deliveryService)&quot;]

    h1 --&gt;|Response| i1[&quot;Outbound IO Thread invokes&lt;br&gt;Observer1.onSuccess(result)&quot;]
    h2 --&gt;|Response| i2[&quot;Outbound IO Thread invokes&lt;br&gt;Observer2.onSuccess(result)&quot;]
    h3 --&gt;|Error| i3[&quot;Outbound IO Thread invokes&lt;br&gt;Observer3.onFailure(ex)&quot;]

    i1 --&gt; j1[&quot;CF1.complete(result)&quot;]
    i2 --&gt; j2[&quot;CF2.complete(result)&quot;]
    i3 --&gt; j3[&quot;CF3.completeExceptionally(ex)&quot;]

    j1 --&gt; k1[&quot;CF1.thenApplyAsync(enrichOrder, cpu-pool)&quot;]
    j2 --&gt; k2[&quot;CF2.thenApplyAsync(enrichProduct, cpu-pool)&quot;]
    j3 --&gt; k3[&quot;CF3.exceptionally(handleFallback)&quot;]

    k1 --&gt; l[&quot;CF4 = CF1.thenCombine(CF2, merge)&quot;]
    k2 --&gt; l
    k1 --&gt; m[&quot;CompletableFuture.allOf(CF1..CF30)&quot;]
    k2 --&gt; m
    k3 --&gt; m

    m --&gt; n[&quot;m.thenApplyAsync(aggregateAll, cpu-pool)&quot;]
    n --&gt; o[&quot;Final Result&quot;]
    o --&gt; p[&quot;Write Response via Inbound IO Thread&quot;]
    p --&gt; q[&quot;Client&quot;]

    classDef io fill:#d5e8d4,stroke:#82b366;
    classDef worker fill:#dae8fc,stroke:#6c8ebf;
    classDef outbound fill:#e1d5e7,stroke:#9673a6;
    classDef cf fill:#fff2cc,stroke:#d6b656;
    classDef service fill:#f8cecc,stroke:#b85450;
    classDef observer fill:#e6e6fa,stroke:#999;

    class B,p io
    class C,d1,d2,d3,e1,e2,e3,f1,f2,f3,k1,k2,k3,l,m,n worker
    class g,i1,i2,i3 outbound
    class j1,j2,j3,o cf
    class h1,h2,h3 service
    class e1,e2,e3 observer</code></pre>
<h2 id="rxjava">RxJava</h2>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#E1D5E7&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant Observable as Observable
    participant Operator1 as map
    participant Operator2 as filter
    participant Subscriber as Subscriber

    Note over Client,Subscriber: RxJava (响应式流)
    Client-&gt;&gt;Observable: create(emitter)
    Observable--&gt;&gt;Operator1: 注册操作符
    Operator1-&gt;&gt;Observable: map(transform)
    Observable--&gt;&gt;Operator2: 注册操作符
    Operator2-&gt;&gt;Observable: filter(predicate)
    Observable--&gt;&gt;Subscriber: subscribe(Subscriber)
    Note right of Client: 非阻塞订阅

    par 数据流处理
        Observable-&gt;&gt;Operator1: onNext(item)
        Operator1-&gt;&gt;Operator2: onNext(mapped)
        Operator2-&gt;&gt;Subscriber: onNext(filtered)
    end

    Observable-&gt;&gt;Subscriber: onComplete()
    Note over Client: 响应式: map/filter/subscribe</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心特点：数据流处理，背压支持</span><br>Observable&lt;String&gt; observable1 = Observable.fromCallable(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;).subscribeOn(Schedulers.io());<br><br>Observable&lt;String&gt; observable2 = Observable.fromCallable(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;RxJava&quot;</span>;<br>&#125;).subscribeOn(Schedulers.io());<br><br><span class="hljs-comment">// [正确] 非阻塞：流式处理</span><br>Observable.zip(observable1, observable2, (s1, s2) -&gt; s1 + <span class="hljs-string">&quot; &quot;</span> + s2)<br>    .map(String::toUpperCase)<br>    .timeout(<span class="hljs-number">2</span>, TimeUnit.SECONDS)<br>    .onErrorReturn(ex -&gt; <span class="hljs-string">&quot;FALLBACK: &quot;</span> + ex.getMessage())<br>    .subscribe(<br>        result -&gt; System.out.println(<span class="hljs-string">&quot;结果: &quot;</span> + result),<br>        error -&gt; System.err.println(<span class="hljs-string">&quot;错误: &quot;</span> + error.getMessage())<br>    );<br><br><span class="hljs-comment">// [注意] RxJava通常不需要手动关闭调度器</span><br></code></pre></td></tr></table></figure>
<h2 id="reactor">Reactor</h2>
<pre><code class="hljs mermaid">%%&#123;init: &#123;&#x27;theme&#x27;: &#x27;base&#x27;, &#x27;themeVariables&#x27;: &#123; &#x27;primaryColor&#x27;: &#x27;#9DC3E6&#x27;, &#x27;edgeLabelBackground&#x27;:&#x27;#FFF&#x27;, &#x27;fontFamily&#x27;: &#x27;monospace&#x27;&#125;&#125;&#125;%%
sequenceDiagram
    participant Client as Client
    participant Flux as Flux
    participant Operator1 as map
    participant Operator2 as flatMap
    participant Subscriber as Subscriber

    Note over Client,Subscriber: Reactor (响应式流)
    Client-&gt;&gt;Flux: create(sink)
    Flux--&gt;&gt;Operator1: 注册操作符
    Operator1-&gt;&gt;Flux: map(transform)
    Flux--&gt;&gt;Operator2: 注册操作符
    Operator2-&gt;&gt;Flux: flatMap(asyncOp)
    Flux--&gt;&gt;Subscriber: subscribe(Subscriber)
    Note right of Client: 非阻塞订阅

    par 数据流处理
        Flux-&gt;&gt;Operator1: onNext(item)
        Operator1-&gt;&gt;Operator2: onNext(mapped)
        Operator2-&gt;&gt;Subscriber: onNext(result)
    end

    Flux-&gt;&gt;Subscriber: onComplete()
    Note over Client: 响应式: map/flatMap/subscribe</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 核心特点：响应式流，背压内建，Spring集成</span><br>Flux&lt;String&gt; flux1 = Flux.fromCallable(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello&quot;</span>;<br>&#125;).subscribeOn(Schedulers.boundedElastic());<br><br>Flux&lt;String&gt; flux2 = Flux.fromCallable(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">500</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Reactor&quot;</span>;<br>&#125;).subscribeOn(Schedulers.boundedElastic());<br><br><span class="hljs-comment">// [正确] 非阻塞：声明式流处理</span><br>Flux.zip(flux1, flux2, (s1, s2) -&gt; s1 + <span class="hljs-string">&quot; &quot;</span> + s2)<br>    .map(String::toUpperCase)<br>    .timeout(Duration.ofSeconds(<span class="hljs-number">2</span>))<br>    .onErrorResume(ex -&gt; Mono.just(<span class="hljs-string">&quot;FALLBACK: &quot;</span> + ex.getMessage()))<br>    .subscribe(<br>        result -&gt; System.out.println(<span class="hljs-string">&quot;结果: &quot;</span> + result),<br>        error -&gt; System.err.println(<span class="hljs-string">&quot;错误: &quot;</span> + error.getMessage()),<br>        () -&gt; System.out.println(<span class="hljs-string">&quot;完成&quot;</span>)<br>    );<br><br><span class="hljs-comment">// [注意] Reactor通常由Spring管理生命周期</span><br></code></pre></td></tr></table></figure>
<hr>
<h1>虚拟线程：Java 并发模型的未来</h1>
<p>虚拟线程（Virtual Threads）是 JDK 21 正式引入的革命性特性（JEP 444），代表了 Java 并发模型的未来方向。理解虚拟线程与传统线程池的差异，对架构决策至关重要。</p>
<h2 id="为什么需要虚拟线程？">为什么需要虚拟线程？</h2>
<h3 id="传统线程模型的困境">传统线程模型的困境</h3>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;传统平台线程模型&quot;
        A[Java Thread] --&gt;|1:1 映射| B[OS Thread]
        B --&gt; C[内核调度]
        C --&gt; D[上下文切换开销大]
        D --&gt; E[线程数受限于内存]
        E --&gt; F[线程池成为必需品]
    end
    
    subgraph &quot;问题&quot;
        F --&gt; G[线程池大小难以调优]
        F --&gt; H[阻塞操作浪费线程]
        F --&gt; I[高并发场景受限]
    end</code></pre>
<p>传统 Java 线程（平台线程）的问题：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
<th>影响</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>内存开销大</strong></td>
<td>每个线程默认栈大小 1MB</td>
<td>10000 线程 ≈ 10GB 内存</td>
</tr>
<tr>
<td><strong>创建成本高</strong></td>
<td>需要 OS 内核参与</td>
<td>创建/销毁耗时约 1ms</td>
</tr>
<tr>
<td><strong>上下文切换昂贵</strong></td>
<td>内核态切换</td>
<td>约 1-10μs 每次切换</td>
</tr>
<tr>
<td><strong>数量受限</strong></td>
<td>受 OS 和内存限制</td>
<td>通常数千到数万</td>
</tr>
</tbody>
</table>
<h3 id="虚拟线程的解决方案">虚拟线程的解决方案</h3>
<pre><code class="hljs mermaid">graph TD
    subgraph &quot;虚拟线程模型&quot;
        A1[Virtual Thread 1] --&gt; B1[Carrier Thread 1]
        A2[Virtual Thread 2] --&gt; B1
        A3[Virtual Thread 3] --&gt; B1
        A4[Virtual Thread 4] --&gt; B2[Carrier Thread 2]
        A5[Virtual Thread ...] --&gt; B2
        A6[Virtual Thread N] --&gt; B2
        
        B1 --&gt; C1[OS Thread 1]
        B2 --&gt; C2[OS Thread 2]
    end
    
    subgraph &quot;优势&quot;
        D[M:N 调度模型]
        E[JVM 管理调度]
        F[阻塞时自动让出]
        G[百万级并发]
    end</code></pre>
<h2 id="虚拟线程-vs-平台线程">虚拟线程 vs 平台线程</h2>
<h3 id="核心差异对比">核心差异对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>平台线程 (Platform Thread)</th>
<th>虚拟线程 (Virtual Thread)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>映射关系</strong></td>
<td>1:1 映射到 OS 线程</td>
<td>M:N 映射（多对少）</td>
</tr>
<tr>
<td><strong>调度者</strong></td>
<td>OS 内核</td>
<td>JVM（用户态调度）</td>
</tr>
<tr>
<td><strong>栈大小</strong></td>
<td>固定（默认 1MB）</td>
<td>动态增长（初始 KB 级）</td>
</tr>
<tr>
<td><strong>创建成本</strong></td>
<td>高（~1ms）</td>
<td>极低（~1μs）</td>
</tr>
<tr>
<td><strong>数量上限</strong></td>
<td>数千到数万</td>
<td>数百万</td>
</tr>
<tr>
<td><strong>阻塞行为</strong></td>
<td>阻塞 OS 线程</td>
<td>自动挂起，让出载体线程</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>CPU 密集型</td>
<td>IO 密集型</td>
</tr>
</tbody>
</table>
<h3 id="代码对比">代码对比</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ========== 传统平台线程池方式 ==========</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">platformPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">200</span>);<br><br><span class="hljs-comment">// 问题：200个线程处理10000个请求，大量时间浪费在等待IO</span><br>List&lt;Future&lt;String&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>    futures.add(platformPool.submit(() -&gt; &#123;<br>        <span class="hljs-comment">// 模拟IO操作（数据库查询、HTTP调用等）</span><br>        Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 线程被阻塞，无法处理其他请求</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result-&quot;</span> + id;<br>    &#125;));<br>&#125;<br><br><span class="hljs-comment">// ========== 虚拟线程方式 (JDK 21+) ==========</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">ExecutorService</span> <span class="hljs-variable">virtualPool</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    <span class="hljs-comment">// 优势：可以创建10000个虚拟线程，每个请求一个线程</span><br>    List&lt;Future&lt;String&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> i;<br>        futures.add(virtualPool.submit(() -&gt; &#123;<br>            <span class="hljs-comment">// 虚拟线程阻塞时自动让出载体线程</span><br>            Thread.sleep(<span class="hljs-number">100</span>); <span class="hljs-comment">// 不会阻塞载体线程！</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result-&quot;</span> + id;<br>        &#125;));<br>    &#125;<br>    <br>    <span class="hljs-comment">// 收集结果</span><br>    <span class="hljs-keyword">for</span> (Future&lt;String&gt; future : futures) &#123;<br>        System.out.println(future.get());<br>    &#125;<br>&#125; <span class="hljs-comment">// try-with-resources 自动关闭</span><br></code></pre></td></tr></table></figure>
<h2 id="虚拟线程的工作原理">虚拟线程的工作原理</h2>
<h3 id="挂载与卸载机制">挂载与卸载机制</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant VT as Virtual Thread
    participant CT as Carrier Thread
    participant OS as OS Thread
    participant IO as IO Operation

    Note over VT,OS: 虚拟线程执行流程
    
    VT-&gt;&gt;CT: 挂载 (mount)
    CT-&gt;&gt;OS: 执行用户代码
    
    VT-&gt;&gt;IO: 发起阻塞IO
    Note over VT: 检测到阻塞操作
    VT-&gt;&gt;CT: 卸载 (unmount)
    Note over CT: 载体线程空闲，可执行其他虚拟线程
    
    IO--&gt;&gt;VT: IO完成
    VT-&gt;&gt;CT: 重新挂载 (remount)
    CT-&gt;&gt;OS: 继续执行</code></pre>
<h3 id="虚拟线程调度模型：与-go-gpm-的对比">虚拟线程调度模型：与 Go GPM 的对比</h3>
<p>理解虚拟线程的调度机制，需要与 Go 语言的 GPM 模型进行对比。两者都实现了 M:N 调度，但设计哲学有所不同。</p>
<p><strong>Go 的 GPM 模型</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Go Runtime&quot;
        G1[Goroutine 1]
        G2[Goroutine 2]
        G3[Goroutine 3]
        G4[Goroutine 4]
        
        P1[P: Processor 1&lt;br/&gt;本地队列]
        P2[P: Processor 2&lt;br/&gt;本地队列]
        
        M1[M: OS Thread 1]
        M2[M: OS Thread 2]
        
        GQ[Global Queue&lt;br/&gt;全局队列]
        
        G1 --&gt; P1
        G2 --&gt; P1
        G3 --&gt; P2
        G4 --&gt; GQ
        
        P1 --&gt; M1
        P2 --&gt; M2
        
        M1 --&gt; OS1[OS Scheduler]
        M2 --&gt; OS1
    end
    
    style P1 fill:#90EE90
    style P2 fill:#90EE90</code></pre>
<p><strong>Java 虚拟线程模型</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;JVM&quot;
        VT1[Virtual Thread 1]
        VT2[Virtual Thread 2]
        VT3[Virtual Thread 3]
        VT4[Virtual Thread 4]
        
        WQ1[WorkQueue 1]
        WQ2[WorkQueue 2]
        
        CT1[Carrier Thread 1&lt;br/&gt;ForkJoinWorkerThread]
        CT2[Carrier Thread 2&lt;br/&gt;ForkJoinWorkerThread]
        
        VT1 -.unmounted.-&gt; WQ1
        VT2 --&gt; CT1
        VT3 --&gt; CT2
        VT4 -.unmounted.-&gt; WQ2
        
        CT1 --&gt; OS1[OS Thread 1]
        CT2 --&gt; OS2[OS Thread 2]
        
        OS1 --&gt; OSS[OS Scheduler]
        OS2 --&gt; OSS
    end
    
    style CT1 fill:#87CEEB
    style CT2 fill:#87CEEB</code></pre>
<p><strong>核心差异对比</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Go GPM</th>
<th>Java Virtual Thread</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>G (Goroutine)</strong></td>
<td>用户态协程</td>
<td>虚拟线程 (Virtual Thread)</td>
</tr>
<tr>
<td><strong>P (Processor)</strong></td>
<td>逻辑处理器，持有 G 的本地队列</td>
<td>无显式 P 概念，使用 ForkJoinPool 的 WorkQueue</td>
</tr>
<tr>
<td><strong>M (Machine)</strong></td>
<td>OS 线程</td>
<td>Carrier Thread (载体线程)</td>
</tr>
<tr>
<td><strong>调度器</strong></td>
<td>Go Runtime Scheduler</td>
<td>ForkJoinPool (work-stealing)</td>
</tr>
<tr>
<td><strong>队列模型</strong></td>
<td>本地队列 + 全局队列</td>
<td>每个 Carrier Thread 的 WorkQueue</td>
</tr>
<tr>
<td><strong>Work Stealing</strong></td>
<td>P 之间窃取 G</td>
<td>Carrier Thread 之间窃取任务</td>
</tr>
<tr>
<td><strong>阻塞处理</strong></td>
<td>M 阻塞时创建新 M</td>
<td>Carrier Thread 不阻塞，虚拟线程 unmount</td>
</tr>
</tbody>
</table>
<p><strong>关键设计差异</strong></p>
<ol>
<li>
<p><strong>Go 的 P (Processor)</strong>：</p>
<ul>
<li>Go 显式引入了 P 的概念，作为 G 和 M 之间的中介</li>
<li>P 的数量通常等于 CPU 核心数（GOMAXPROCS）</li>
<li>P 持有本地队列，减少全局队列的竞争</li>
</ul>
</li>
<li>
<p><strong>Java 的简化模型</strong>：</p>
<ul>
<li>Java 没有显式的 P 概念</li>
<li>直接使用 ForkJoinPool 的 work-stealing 机制</li>
<li>Carrier Thread 数量默认等于 CPU 核心数</li>
<li>每个 Carrier Thread 有自己的 WorkQueue</li>
</ul>
</li>
</ol>
<p><strong>为什么 Java 不需要 P？</strong></p>
<p>Go 的 P 设计是为了解决以下问题：</p>
<ul>
<li>减少全局队列的锁竞争</li>
<li>支持 work-stealing</li>
<li>管理 G 的本地缓存</li>
</ul>
<p>Java 虚拟线程通过 <strong>ForkJoinPool</strong> 已经实现了这些功能：</p>
<ul>
<li>ForkJoinPool 本身就是为 work-stealing 设计的</li>
<li>每个 ForkJoinWorkerThread 有自己的双端队列</li>
<li>无需额外的 P 抽象层</li>
</ul>
<h3 id="虚拟线程的-continuation-机制：unmount-mount-的本质">虚拟线程的 Continuation 机制：unmount/mount 的本质</h3>
<p>虚拟线程的核心是 <strong>Continuation</strong>（延续）机制。这是理解 unmount/mount 行为的关键。</p>
<p><strong>什么是 Continuation？</strong></p>
<p>Continuation 是一种可以暂停和恢复执行的程序抽象。在 Java 中，它是 <code>jdk.internal.vm.Continuation</code> 类的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 简化的 Continuation 概念示例（实际是 JVM 内部实现）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Continuation</span> &#123;<br>    <span class="hljs-keyword">private</span> Object[] stack;  <span class="hljs-comment">// 保存的栈帧</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> pc;          <span class="hljs-comment">// 程序计数器</span><br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 执行到 yield 点</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">yield</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 保存当前栈帧和 PC</span><br>        <span class="hljs-comment">// 返回到调用者</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">resume</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 恢复栈帧和 PC</span><br>        <span class="hljs-comment">// 继续执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>虚拟线程的 unmount/mount 流程</strong></p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; Unmounted: 创建虚拟线程
    
    Unmounted --&gt; Mounted: mount()&lt;br/&gt;分配 Carrier Thread
    
    Mounted --&gt; Running: 开始执行
    
    Running --&gt; Unmounted: unmount()&lt;br/&gt;遇到阻塞操作
    
    Running --&gt; Pinned: 遇到 synchronized&lt;br/&gt;或 native 方法
    
    Pinned --&gt; Running: 阻塞操作完成&lt;br/&gt;(Carrier Thread 被阻塞)
    
    Unmounted --&gt; Mounted: IO 完成&lt;br/&gt;重新调度
    
    Running --&gt; [*]: 任务完成
    
    note right of Unmounted
        虚拟线程状态保存在堆中
        Continuation 保存栈帧
        不占用 Carrier Thread
    end note
    
    note right of Mounted
        虚拟线程在 Carrier Thread 上执行
        栈帧在 Carrier Thread 的栈上
    end note
    
    note right of Pinned
        无法 unmount
        Carrier Thread 被阻塞
        降级为平台线程行为
    end note</code></pre>
<p><strong>自动 unmount 的场景</strong></p>
<p>根据 JEP 444 和 JDK 源码，虚拟线程在以下场景会自动 unmount：</p>
<table>
<thead>
<tr>
<th>阻塞操作</th>
<th>是否 unmount</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong><code>Thread.sleep()</code></strong></td>
<td>✅ 是</td>
<td>JDK 内部实现为 <code>Continuation.yield()</code></td>
</tr>
<tr>
<td><strong><code>Object.wait()</code></strong></td>
<td>✅ 是</td>
<td>不在 synchronized 块内时</td>
</tr>
<tr>
<td><strong><code>LockSupport.park()</code></strong></td>
<td>✅ 是</td>
<td>虚拟线程的标准阻塞原语</td>
</tr>
<tr>
<td><strong><code>BlockingQueue.take()</code></strong></td>
<td>✅ 是</td>
<td>内部使用 <code>LockSupport.park()</code></td>
</tr>
<tr>
<td><strong><code>Semaphore.acquire()</code></strong></td>
<td>✅ 是</td>
<td>内部使用 <code>LockSupport.park()</code></td>
</tr>
<tr>
<td><strong><code>ReentrantLock.lock()</code></strong></td>
<td>✅ 是</td>
<td>阻塞时使用 <code>LockSupport.park()</code></td>
</tr>
<tr>
<td><strong>Socket I/O</strong></td>
<td>✅ 是</td>
<td>JDK 改造为非阻塞实现</td>
</tr>
<tr>
<td><strong>File I/O</strong></td>
<td>✅ 是</td>
<td>JDK 改造为非阻塞实现</td>
</tr>
<tr>
<td><strong><code>synchronized</code> 块</strong></td>
<td>❌ 否</td>
<td><strong>Pinning 问题</strong></td>
</tr>
<tr>
<td><strong>JNI 调用</strong></td>
<td>❌ 否</td>
<td><strong>Pinning 问题</strong></td>
</tr>
<tr>
<td><strong>CPU 密集计算</strong></td>
<td>❌ 否</td>
<td>无阻塞点，无法 unmount</td>
</tr>
</tbody>
</table>
<p><strong>unmount 的实现原理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 虚拟线程阻塞时的简化流程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadBlocking</span> &#123;<br>    <br>    <span class="hljs-comment">// 当虚拟线程调用 Thread.sleep() 时</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> &#123;<br>        <span class="hljs-comment">// 1. 检查当前线程是否是虚拟线程</span><br>        <span class="hljs-keyword">if</span> (Thread.currentThread().isVirtual()) &#123;<br>            <span class="hljs-comment">// 2. 调用 Continuation.yield()</span><br>            <span class="hljs-comment">//    - 保存当前栈帧到堆中</span><br>            <span class="hljs-comment">//    - 释放 Carrier Thread</span><br>            <span class="hljs-comment">//    - 注册唤醒回调（定时器）</span><br>            Continuation.<span class="hljs-keyword">yield</span>(SLEEP_SCOPE);<br>            <br>            <span class="hljs-comment">// 3. 当定时器触发时</span><br>            <span class="hljs-comment">//    - 虚拟线程被重新调度</span><br>            <span class="hljs-comment">//    - 分配新的 Carrier Thread</span><br>            <span class="hljs-comment">//    - 恢复栈帧，继续执行</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 平台线程：直接调用 OS sleep</span><br>            Thread0.sleep(millis);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>与 C 协程的差异：隐式 vs 显式调度</strong></p>
<p>这是一个关键的设计差异：</p>
<p><strong>C 协程（如 libco）</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// C 协程支持显式 yield</span><br><span class="hljs-type">void</span>* <span class="hljs-title function_">coroutine_func</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span> &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Step 1\n&quot;</span>);<br>    co_yield();  <span class="hljs-comment">// 显式让出 CPU</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Step 2\n&quot;</span>);<br>    co_yield();  <span class="hljs-comment">// 再次显式让出</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Step 3\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Java 虚拟线程</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java 虚拟线程是隐式调度</span><br>Thread.ofVirtual().start(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Step 1&quot;</span>);<br>    <span class="hljs-comment">// 无法显式 yield！</span><br>    <span class="hljs-comment">// 只能通过阻塞操作触发 unmount</span><br>    Thread.sleep(<span class="hljs-number">0</span>);  <span class="hljs-comment">// 隐式 yield</span><br>    System.out.println(<span class="hljs-string">&quot;Step 2&quot;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>为什么 Java 选择隐式调度？</strong></p>
<ol>
<li><strong>向后兼容</strong>：现有的阻塞 API 无需修改即可工作</li>
<li><strong>简化编程</strong>：开发者无需关心调度细节</li>
<li><strong>安全性</strong>：避免程序员错误使用 yield 导致的问题</li>
<li><strong>性能</strong>：JVM 可以优化 unmount 时机</li>
</ol>
<p><strong>unmount 的性能开销</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// unmount 的成本分析</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnmountCost</span> &#123;<br>    <br>    <span class="hljs-comment">// 1. 保存栈帧到堆（几百纳秒）</span><br>    <span class="hljs-comment">//    - 拷贝栈帧数据</span><br>    <span class="hljs-comment">//    - 保存程序计数器</span><br>    <br>    <span class="hljs-comment">// 2. 释放 Carrier Thread（几十纳秒）</span><br>    <span class="hljs-comment">//    - 从 Carrier Thread 解绑</span><br>    <br>    <span class="hljs-comment">// 3. 重新调度（微秒级）</span><br>    <span class="hljs-comment">//    - 等待 IO 完成</span><br>    <span class="hljs-comment">//    - 分配新的 Carrier Thread</span><br>    <span class="hljs-comment">//    - 恢复栈帧</span><br>    <br>    <span class="hljs-comment">// 总开销：约 1-10 微秒</span><br>    <span class="hljs-comment">// 对比：平台线程上下文切换约 1-10 微秒</span><br>    <span class="hljs-comment">// 但虚拟线程的优势在于不阻塞 Carrier Thread</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>核心洞察</strong></p>
<ol>
<li>
<p><strong>Java 虚拟线程不是&quot;完全&quot;的协程</strong>：</p>
<ul>
<li>无法在任意点 yield</li>
<li>只能在特定的阻塞点 unmount</li>
<li>这是设计选择，不是技术限制</li>
</ul>
</li>
<li>
<p><strong>unmount 是自动的，不是手动的</strong>：</p>
<ul>
<li>JVM 检测到阻塞操作时自动触发</li>
<li>开发者无需（也无法）显式控制</li>
</ul>
</li>
<li>
<p><strong>Pinning 是虚拟线程的限制</strong>：</p>
<ul>
<li><code>synchronized</code> 和 JNI 调用无法 unmount</li>
<li>这是当前实现的限制，未来可能改进</li>
</ul>
</li>
<li>
<p><strong>虚拟线程的价值不在于&quot;任意点切换&quot;</strong>：</p>
<ul>
<li>而在于&quot;阻塞时不浪费 Carrier Thread&quot;</li>
<li>这对 IO 密集型应用已经足够</li>
</ul>
</li>
</ol>
<h3 id="关键概念">关键概念</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 虚拟线程核心概念示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadConcepts</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1. 创建虚拟线程的三种方式</span><br>        <br>        <span class="hljs-comment">// 方式一：Thread.ofVirtual()</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">vt1</span> <span class="hljs-operator">=</span> Thread.ofVirtual()<br>            .name(<span class="hljs-string">&quot;virtual-thread-1&quot;</span>)<br>            .start(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;Running on: &quot;</span> + Thread.currentThread());<br>                System.out.println(<span class="hljs-string">&quot;Is virtual: &quot;</span> + Thread.currentThread().isVirtual());<br>            &#125;);<br>        <br>        <span class="hljs-comment">// 方式二：Thread.startVirtualThread()</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">vt2</span> <span class="hljs-operator">=</span> Thread.startVirtualThread(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Quick virtual thread&quot;</span>);<br>        &#125;);<br>        <br>        <span class="hljs-comment">// 方式三：Executors.newVirtualThreadPerTaskExecutor()</span><br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>            executor.submit(() -&gt; &#123;<br>                System.out.println(<span class="hljs-string">&quot;Virtual thread from executor&quot;</span>);<br>            &#125;);<br>        &#125;<br>        <br>        vt1.join();<br>        vt2.join();<br>        <br>        <span class="hljs-comment">// 2. 虚拟线程的特性</span><br>        Thread.ofVirtual().start(() -&gt; &#123;<br>            <span class="hljs-comment">// 获取载体线程（仅用于调试）</span><br>            <span class="hljs-comment">// 注意：生产代码不应依赖载体线程</span><br>            System.out.println(<span class="hljs-string">&quot;Virtual thread running&quot;</span>);<br>            <br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 阻塞操作会触发卸载</span><br>                Thread.sleep(<span class="hljs-number">100</span>);<br>                <span class="hljs-comment">// sleep 期间，载体线程可以执行其他虚拟线程</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;).join();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="虚拟线程的使用原则">虚拟线程的使用原则</h2>
<h3 id="原则一：不要池化虚拟线程">原则一：不要池化虚拟线程</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] 不要池化虚拟线程！</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">wrongPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">100</span>, <br>    Thread.ofVirtual().factory()); <span class="hljs-comment">// 错误：限制了虚拟线程数量</span><br><br><span class="hljs-comment">// [正确] 每个任务一个虚拟线程</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">correctPool</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor();<br><span class="hljs-comment">// 虚拟线程非常轻量，无需池化</span><br></code></pre></td></tr></table></figure>
<p><strong>为什么虚拟线程无需池化？</strong></p>
<p>传统线程池的设计目的是<strong>复用昂贵的操作系统线程资源</strong>。理解这一点是理解虚拟线程设计哲学的关键。</p>
<p><strong>平台线程的成本结构</strong>：</p>
<table>
<thead>
<tr>
<th>成本项</th>
<th>平台线程</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>创建成本</strong></td>
<td>~1ms（需要 OS 内核参与）</td>
<td>~1μs（纯 JVM 对象创建）</td>
</tr>
<tr>
<td><strong>内存占用</strong></td>
<td>固定 1MB 栈空间</td>
<td>初始几 KB，按需增长</td>
</tr>
<tr>
<td><strong>调度开销</strong></td>
<td>内核态切换（~1-10μs）</td>
<td>用户态切换（纳秒级）</td>
</tr>
<tr>
<td><strong>数量上限</strong></td>
<td>数千到数万（受内存限制）</td>
<td>数百万（受堆内存限制）</td>
</tr>
</tbody>
</table>
<p><strong>虚拟线程的&quot;用完即弃&quot;设计</strong>：</p>
<p>根据 JEP 444，虚拟线程被设计为 <strong>use-and-throw-away</strong>（用完即弃）资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 虚拟线程的创建成本接近普通对象</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">vt</span> <span class="hljs-operator">=</span> Thread.ofVirtual().start(() -&gt; &#123;<br>    <span class="hljs-comment">// 执行任务</span><br>&#125;);<br><span class="hljs-comment">// 任务完成后，虚拟线程被 GC 回收，无需复用</span><br></code></pre></td></tr></table></figure>
<p><strong>池化虚拟线程的问题</strong>：</p>
<ol>
<li><strong>违背设计初衷</strong>：虚拟线程本身就是为了避免池化的复杂性</li>
<li><strong>限制并发能力</strong>：池化会人为限制虚拟线程数量，失去其核心优势</li>
<li><strong>增加复杂性</strong>：需要管理池的生命周期、任务队列等</li>
<li><strong>状态清理开销</strong>：复用线程需要清理 ThreadLocal 等状态，反而增加开销</li>
</ol>
<p><strong>对比示例</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 平台线程：必须池化</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">platformPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">200</span>);<br><span class="hljs-comment">// 原因：创建 10000 个平台线程会耗尽内存（10GB+）</span><br><br><span class="hljs-comment">// 虚拟线程：无需池化</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">virtualPool</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    <span class="hljs-comment">// 可以轻松创建 10000 个虚拟线程（仅需 ~20MB）</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>        virtualPool.submit(() -&gt; doWork());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>核心洞察</strong>：虚拟线程将&quot;线程&quot;从&quot;昂贵的需要复用的资源&quot;变成了&quot;廉价的可随意创建的对象&quot;。这是并发编程范式的根本转变。</p>
<h3 id="原则二：避免在虚拟线程中执行-cpu-密集型任务">原则二：避免在虚拟线程中执行 CPU 密集型任务</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误] CPU密集型任务不适合虚拟线程</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    executor.submit(() -&gt; &#123;<br>        <span class="hljs-comment">// CPU密集型计算</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10_000_000_000L</span>; i++) &#123;<br>            result += i;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;);<br>&#125;<br><br><span class="hljs-comment">// [正确] CPU密集型任务使用平台线程池</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<br>    Runtime.getRuntime().availableProcessors()<br>);<br>cpuPool.submit(() -&gt; &#123;<br>    <span class="hljs-comment">// CPU密集型计算</span><br>    <span class="hljs-keyword">return</span> heavyComputation();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong>原因</strong>：虚拟线程的优势在于 IO 等待期间让出载体线程。CPU 密集型任务没有等待，无法发挥虚拟线程优势。</p>
<h3 id="原则三：注意-synchronized-和-native-方法的-pinning-问题">原则三：注意 synchronized 和 native 方法的 Pinning 问题</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [问题] synchronized 会导致虚拟线程 &quot;pinning&quot;（钉住载体线程）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PinningExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-comment">// [错误] synchronized 块内的阻塞操作会钉住载体线程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">badMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 载体线程被钉住！</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// [正确] 使用 ReentrantLock 替代 synchronized</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">reentrantLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodMethod</span><span class="hljs-params">()</span> &#123;<br>        reentrantLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 虚拟线程可以正常卸载</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            reentrantLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Pinning（钉住）</strong>：当虚拟线程执行 <code>synchronized</code> 块或 native 方法时，无法从载体线程卸载，导致载体线程被阻塞。</p>
<h3 id="原则四：正确使用-threadlocal">原则四：正确使用 ThreadLocal</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [注意] 虚拟线程与 ThreadLocal 的交互</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadLocalWithVirtualThreads</span> &#123;<br>    <br>    <span class="hljs-comment">// 传统 ThreadLocal 在虚拟线程中仍然有效</span><br>    <span class="hljs-comment">// 但要注意：百万虚拟线程 × ThreadLocal 数据 = 巨大内存开销</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;ExpensiveObject&gt; threadLocal = <br>        ThreadLocal.withInitial(ExpensiveObject::<span class="hljs-keyword">new</span>);<br>    <br>    <span class="hljs-comment">// [推荐] 对于虚拟线程，考虑使用 ScopedValue (JDK 21 Preview)</span><br>    <span class="hljs-comment">// ScopedValue 是不可变的，更适合虚拟线程场景</span><br>    <span class="hljs-comment">// private static final ScopedValue&lt;String&gt; SCOPED_VALUE = ScopedValue.newInstance();</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 使用 ThreadLocal</span><br>        <span class="hljs-type">ExpensiveObject</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> threadLocal.get();<br>        <span class="hljs-comment">// ... 使用 obj</span><br>        <br>        <span class="hljs-comment">// [重要] 虚拟线程结束后，ThreadLocal 会被清理</span><br>        <span class="hljs-comment">// 但如果虚拟线程数量巨大，仍需注意内存</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="threadlocal-在虚拟线程中为何仍然有效？">ThreadLocal 在虚拟线程中为何仍然有效？</h3>
<p>这是一个重要的设计决策，需要从JVM实现层面理解：</p>
<pre><code class="hljs mermaid">graph LR
    A[虚拟线程创建] --&gt; B[继承载体线程ThreadLocal]
    B --&gt; C[创建独立ThreadLocal映射]
    C --&gt; D[执行期间访问本地数据]
    D --&gt; E[虚拟线程结束]
    E --&gt; F[自动清理ThreadLocal]
    
    subgraph &quot;载体线程&quot;
        G[ThreadLocal Map]
    end
    
    subgraph &quot;虚拟线程&quot;
        H[独立ThreadLocal Map]
        I[执行任务]
    end
    
    G -.-&gt; B
    B --&gt; H
    H --&gt; D
    H --&gt; F</code></pre>
<p><strong>Technical Details</strong>：</p>
<ol>
<li><strong>继承机制</strong>：虚拟线程创建时会继承载体线程的ThreadLocal值副本</li>
<li><strong>独立存储</strong>：每个虚拟线程维护自己的ThreadLocal映射表，与载体线程隔离</li>
<li><strong>生命周期管理</strong>：虚拟线程结束时，JVM会自动清理其ThreadLocal变量，防止内存泄漏</li>
</ol>
<p><strong>JDK实现改进</strong>：</p>
<ul>
<li>增加了针对大量虚拟线程的内存优化策略</li>
<li>改进了ThreadLocal清理机制的性能</li>
<li>添加了虚拟线程专用的ThreadLocal访问路径</li>
</ul>
<h3 id="scopedvalue-为什么优于-threadlocal？">ScopedValue 为什么优于 ThreadLocal？</h3>
<p>对于虚拟线程场景，ScopedValue是更好的选择：</p>
<pre><code class="hljs mermaid">graph TD
    A[并发数据传递需求] --&gt; B&#123;选择哪种机制?&#125;
    B --&gt;|传统场景| C[ThreadLocal]
    B --&gt;|虚拟线程场景| D[ScopedValue]
    
    C --&gt; E[可变状态]
    C --&gt; F[潜在内存泄漏]
    C --&gt; G[性能开销]
    
    D --&gt; H[不可变数据]
    D --&gt; I[明确作用域]
    D --&gt; J[零内存泄漏风险]
    D --&gt; K[更高性能]</code></pre>
<p><strong>ScopedValue的核心优势</strong>：</p>
<ol>
<li><strong>不可变性保证</strong>：一旦设置就无法修改，避免并发修改问题</li>
<li><strong>作用域明确</strong>：具有清晰的生命周期边界，不会跨作用域泄漏</li>
<li><strong>M:N调度友好</strong>：不依赖具体线程身份，在虚拟线程的载体线程切换中表现更好</li>
<li><strong>性能优势</strong>：避免了ThreadLocal的哈希表查找和冲突处理开销</li>
</ol>
<p><strong>Specification依据</strong>：根据JEP 429和JEP 446规范，ScopedValue专为结构化并发和虚拟线程场景设计，解决了ThreadLocal在大规模并发下的根本性问题。</p>
<h2 id="虚拟线程与传统线程池的选择">虚拟线程与传统线程池的选择</h2>
<h3 id="决策流程图">决策流程图</h3>
<pre><code class="hljs mermaid">flowchart TD
    A[新任务] --&gt; B&#123;任务类型?&#125;
    
    B --&gt;|IO密集型| C&#123;JDK版本?&#125;
    C --&gt;|JDK 21+| D[使用虚拟线程]
    C --&gt;|JDK 21以下| E[使用传统IO线程池]
    
    B --&gt;|CPU密集型| F[使用平台线程池]
    F --&gt; G[线程数 = CPU核心数]
    
    B --&gt;|混合型| H&#123;主要瓶颈?&#125;
    H --&gt;|IO等待| D
    H --&gt;|CPU计算| F
    
    D --&gt; I[newVirtualThreadPerTaskExecutor]
    E --&gt; J[newCachedThreadPool 或 自定义线程池]
    
    style D fill:#90EE90
    style F fill:#87CEEB
    style E fill:#FFE4B5</code></pre>
<h3 id="场景对比">场景对比</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Web 服务器处理 HTTP 请求</strong></td>
<td>虚拟线程</td>
<td>大量 IO 等待（数据库、外部 API）</td>
</tr>
<tr>
<td><strong>批量数据处理/ETL</strong></td>
<td>虚拟线程</td>
<td>文件 IO、网络传输</td>
</tr>
<tr>
<td><strong>图像/视频处理</strong></td>
<td>平台线程池</td>
<td>CPU 密集型计算</td>
</tr>
<tr>
<td><strong>科学计算/机器学习</strong></td>
<td>平台线程池 + ForkJoinPool</td>
<td>CPU 密集型，需要并行计算</td>
</tr>
<tr>
<td><strong>实时交易系统</strong></td>
<td>平台线程池</td>
<td>低延迟要求，避免 JVM 调度开销</td>
</tr>
<tr>
<td><strong>微服务间调用</strong></td>
<td>虚拟线程</td>
<td>大量网络 IO 等待</td>
</tr>
</tbody>
</table>
<h3 id="迁移示例">迁移示例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从传统线程池迁移到虚拟线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MigrationExample</span> &#123;<br><br>    <span class="hljs-comment">// ========== 迁移前：传统线程池 ==========</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">legacyPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>        <span class="hljs-number">10</span>, <span class="hljs-number">100</span>, <span class="hljs-number">60L</span>, TimeUnit.SECONDS,<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>),<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy()<br>    );<br>    <br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">fetchDataLegacy</span><span class="hljs-params">(String url)</span> &#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;<br>            <span class="hljs-comment">// 模拟 HTTP 调用</span><br>            <span class="hljs-keyword">return</span> httpClient.get(url);<br>        &#125;, legacyPool);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ========== 迁移后：虚拟线程 ==========</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">virtualPool</span> <span class="hljs-operator">=</span> <br>        Executors.newVirtualThreadPerTaskExecutor();<br>    <br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">fetchDataVirtual</span><span class="hljs-params">(String url)</span> &#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; &#123;<br>            <span class="hljs-comment">// 相同的业务逻辑，无需修改</span><br>            <span class="hljs-keyword">return</span> httpClient.get(url);<br>        &#125;, virtualPool);<br>    &#125;<br>    <br>    <span class="hljs-comment">// ========== 混合模式：IO 用虚拟线程，CPU 用平台线程 ==========</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">ioPool</span> <span class="hljs-operator">=</span> <br>        Executors.newVirtualThreadPerTaskExecutor();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">cpuPool</span> <span class="hljs-operator">=</span> <br>        Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br>    <br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;ProcessedData&gt; <span class="hljs-title function_">fetchAndProcess</span><span class="hljs-params">(String url)</span> &#123;<br>        <span class="hljs-keyword">return</span> CompletableFuture<br>            .supplyAsync(() -&gt; httpClient.get(url), ioPool)      <span class="hljs-comment">// IO：虚拟线程</span><br>            .thenApplyAsync(data -&gt; heavyProcess(data), cpuPool); <span class="hljs-comment">// CPU：平台线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="虚拟线程的性能特征">虚拟线程的性能特征</h2>
<h3 id="吞吐量对比">吞吐量对比</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 虚拟线程 vs 平台线程性能对比示例</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PerformanceComparison</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TASK_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">100_000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">IO_DELAY_MS</span> <span class="hljs-operator">=</span> <span class="hljs-number">50</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 平台线程池（200线程）</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">platformTime</span> <span class="hljs-operator">=</span> benchmarkPlatformThreads();<br>        System.out.println(<span class="hljs-string">&quot;Platform threads: &quot;</span> + platformTime + <span class="hljs-string">&quot; ms&quot;</span>);<br>        <br>        <span class="hljs-comment">// 虚拟线程</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">virtualTime</span> <span class="hljs-operator">=</span> benchmarkVirtualThreads();<br>        System.out.println(<span class="hljs-string">&quot;Virtual threads: &quot;</span> + virtualTime + <span class="hljs-string">&quot; ms&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">benchmarkPlatformThreads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">200</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <br>        List&lt;Future&lt;?&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; TASK_COUNT; i++) &#123;<br>            futures.add(pool.submit(() -&gt; &#123;<br>                Thread.sleep(IO_DELAY_MS);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125;));<br>        &#125;<br>        <br>        <span class="hljs-keyword">for</span> (Future&lt;?&gt; f : futures) f.get();<br>        pool.shutdown();<br>        <br>        <span class="hljs-keyword">return</span> System.currentTimeMillis() - start;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-type">long</span> <span class="hljs-title function_">benchmarkVirtualThreads</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <br>        <span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>            List&lt;Future&lt;?&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; TASK_COUNT; i++) &#123;<br>                futures.add(pool.submit(() -&gt; &#123;<br>                    Thread.sleep(IO_DELAY_MS);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125;));<br>            &#125;<br>            <br>            <span class="hljs-keyword">for</span> (Future&lt;?&gt; f : futures) f.get();<br>        &#125;<br>        <br>        <span class="hljs-keyword">return</span> System.currentTimeMillis() - start;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 典型结果（100,000 任务，50ms IO 延迟）：</span><br><span class="hljs-comment">// Platform threads (200): ~25,000 ms</span><br><span class="hljs-comment">// Virtual threads: ~100 ms</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">// 虚拟线程快 250 倍！</span><br><span class="hljs-comment">// 原因：平台线程受限于 200 个线程，需要排队</span><br><span class="hljs-comment">//       虚拟线程可以同时处理所有任务</span><br></code></pre></td></tr></table></figure>
<h3 id="内存占用对比">内存占用对比</h3>
<table>
<thead>
<tr>
<th>线程类型</th>
<th>10,000 线程内存</th>
<th>100,000 线程内存</th>
<th>1,000,000 线程内存</th>
</tr>
</thead>
<tbody>
<tr>
<td>平台线程</td>
<td>~10 GB</td>
<td>~100 GB（不可行）</td>
<td>不可能</td>
</tr>
<tr>
<td>虚拟线程</td>
<td>~20 MB</td>
<td>~200 MB</td>
<td>~2 GB</td>
</tr>
</tbody>
</table>
<h2 id="总结：线程池技术的演进">总结：线程池技术的演进</h2>
<pre><code class="hljs mermaid">timeline
    title Java 并发模型演进
    
    section JDK 1.0-1.4
        1996 : Thread 类
             : 手动管理线程
    
    section JDK 5
        2004 : ExecutorService
             : ThreadPoolExecutor
             : 线程池标准化
    
    section JDK 7
        2011 : ForkJoinPool
             : 工作窃取算法
             : 分治并行
    
    section JDK 8
        2014 : CompletableFuture
             : 异步编程
             : 链式组合
    
    section JDK 21
        2023 : Virtual Threads
             : 百万级并发
             : 简化异步编程</code></pre>
<h3 id="技术选型总结">技术选型总结</h3>
<table>
<thead>
<tr>
<th>技术</th>
<th>适用场景</th>
<th>核心优势</th>
<th>注意事项</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ThreadPoolExecutor</strong></td>
<td>通用任务执行</td>
<td>成熟稳定，参数可控</td>
<td>需要调优线程池参数</td>
</tr>
<tr>
<td><strong>ForkJoinPool</strong></td>
<td>分治/递归任务</td>
<td>工作窃取，高效并行</td>
<td>任务需可分解</td>
</tr>
<tr>
<td><strong>CompletableFuture</strong></td>
<td>异步编排</td>
<td>链式组合，声明式</td>
<td>注意线程池选择</td>
</tr>
<tr>
<td><strong>Virtual Threads</strong></td>
<td>IO 密集型高并发</td>
<td>轻量级，简化编程</td>
<td>JDK 21+，避免 Pinning</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>核心洞察</strong>：虚拟线程不是要取代线程池，而是为 IO 密集型场景提供更简单、更高效的解决方案。在 CPU 密集型场景，传统线程池仍然是最佳选择。理解每种技术的适用场景，才能做出正确的架构决策。</p>
</blockquote>
<hr>
<h2 id="结构化并发-structured-concurrency">结构化并发 (Structured Concurrency)</h2>
<p>结构化并发的完整内容已独立成文，详见 <a href="https://magicliang.github.io/2026/02/07/Java-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91">Java 结构化并发</a>。</p>
<p>结构化并发（Structured Concurrency）借鉴结构化编程的思想，将并发任务的生命周期与代码的词法作用域绑定，解决传统并发编程中的线程泄漏、错误处理困难和取消传播困难三大问题。Java 从 JDK 19 开始引入 <code>StructuredTaskScope</code> API，经过多轮孵化和预览，提供了 <code>ShutdownOnFailure</code> 和 <code>ShutdownOnSuccess</code> 两种内置策略，与虚拟线程紧密协同。</p>
<h2 id="spring框架中的线程池实现与最佳实践">Spring框架中的线程池实现与最佳实践</h2>
<h3 id="1-spring线程池体系概述">1. Spring线程池体系概述</h3>
<p>Spring框架提供了多层次的线程池抽象，从底层的JDK线程池封装到高层的应用级线程池管理：</p>
<pre><code class="hljs mermaid">graph TD
    A[Spring线程池体系] --&gt; B&#123;抽象层级&#125;
    B --&gt;|底层封装| C[TaskExecutor接口]
    B --&gt;|中层实现| D[ThreadPoolTaskExecutor]
    B --&gt;|高层管理| E[TaskScheduler]
    B --&gt;|应用集成| F[@Async注解支持]
    
    C --&gt; G[SimpleAsyncTaskExecutor]
    C --&gt; H[ConcurrentTaskExecutor]
    C --&gt; I[ThreadPoolTaskExecutor]
    
    D --&gt; J[配置属性]
    D --&gt; K[生命周期管理]
    D --&gt; L[监控指标]
    
    E --&gt; M[定时任务]
    E --&gt; N[Cron表达式]
    E --&gt; O[延迟执行]</code></pre>
<h3 id="2-核心组件详解">2. 核心组件详解</h3>
<h4 id="2-1-taskexecutor接口设计">2.1 TaskExecutor接口设计</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Spring的线程池抽象接口</span><br><span class="hljs-comment"> * 基于命令模式，提供统一的异步执行契约</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">TaskExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行给定的Runnable任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> task 要执行的任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>设计优势</strong>：</p>
<ul>
<li>解耦了应用代码与具体线程池实现</li>
<li>提供了统一的异常处理机制</li>
<li>支持任务装饰器模式</li>
</ul>
<h4 id="2-2-threadpooltaskexecutor实现">2.2 ThreadPoolTaskExecutor实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolConfig</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title function_">taskExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>        <br>        <span class="hljs-comment">// 核心配置参数</span><br>        executor.setCorePoolSize(<span class="hljs-number">10</span>);           <span class="hljs-comment">// 核心线程数</span><br>        executor.setMaxPoolSize(<span class="hljs-number">50</span>);            <span class="hljs-comment">// 最大线程数</span><br>        executor.setQueueCapacity(<span class="hljs-number">200</span>);         <span class="hljs-comment">// 队列容量</span><br>        executor.setKeepAliveSeconds(<span class="hljs-number">60</span>);       <span class="hljs-comment">// 空闲线程存活时间</span><br>        <br>        <span class="hljs-comment">// 线程命名和拒绝策略</span><br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;spring-task-&quot;</span>);<br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>        <br>        <span class="hljs-comment">// 等待所有任务完成</span><br>        executor.setWaitForTasksToCompleteOnShutdown(<span class="hljs-literal">true</span>);<br>        executor.setAwaitTerminationSeconds(<span class="hljs-number">30</span>);<br>        <br>        <span class="hljs-comment">// 初始化线程池</span><br>        <span class="hljs-comment">// 注意: initialize()会立即创建corePoolSize个线程</span><br>        <span class="hljs-comment">// 如果希望延迟创建线程，可以设置:</span><br>        <span class="hljs-comment">// executor.setAllowCoreThreadTimeOut(true);</span><br>        executor.initialize();<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="3-与原生线程池的映射关系">3. 与原生线程池的映射关系</h3>
<table>
<thead>
<tr>
<th>Spring组件</th>
<th>JDK原生组件</th>
<th>配置映射</th>
</tr>
</thead>
<tbody>
<tr>
<td>ThreadPoolTaskExecutor</td>
<td>ThreadPoolExecutor</td>
<td>1:1直接映射</td>
</tr>
<tr>
<td>SimpleAsyncTaskExecutor</td>
<td>ThreadFactory</td>
<td>每次创建新线程</td>
</tr>
<tr>
<td>ConcurrentTaskExecutor</td>
<td>ExecutorService</td>
<td>适配器模式</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph LR
    A[ThreadPoolTaskExecutor] --&gt; B[ThreadPoolExecutor]
    A --&gt; C[配置参数映射]
    
    C --&gt; D[corePoolSize]
    C --&gt; E[maxPoolSize]
    C --&gt; F[keepAliveTime]
    C --&gt; G[workQueue]
    
    B --&gt; H[实际执行]</code></pre>
<h3 id="4-spring-scheduled-的默认陷阱：单线程调度器">4. Spring @Scheduled 的默认陷阱：单线程调度器</h3>
<h4 id="4-1-问题描述">4.1 问题描述</h4>
<p>在 Spring 中，<code>@Scheduled</code> 的执行由 <code>TaskScheduler</code>/<code>ScheduledTaskRegistrar</code> 驱动。<strong>如果你没显式配置，很多场景会退化到单线程调度器</strong>。</p>
<p>这是一个长期存在的坑，不同 Spring Boot 版本与配置路径略有差异：</p>
<ul>
<li><strong>Spring Boot 2.x</strong>: 默认使用单线程的 <code>ConcurrentTaskScheduler</code></li>
<li><strong>Spring Boot 3.x</strong>: 仍然是单线程，但提供了更好的配置支持（<code>spring.task.scheduling.pool.size</code>）</li>
<li><strong>核心问题</strong>: 无论哪个版本，<strong>默认调度器线程池大小都是1</strong>，需要显式配置才能并行执行</li>
</ul>
<p>但&quot;默认不一定是你想要的并行度&quot;是核心问题。</p>
<h4 id="4-2-问题影响">4.2 问题影响</h4>
<p><strong>结果</strong>：一个定时任务慢了，会拖住其他任务的触发/执行。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as Task1 (慢任务)
    participant T2 as Task2 (正常任务)
    participant T3 as Task3 (正常任务)
    participant S as 单线程调度器
    
    Note over S: 默认配置：单线程
    S-&gt;&gt;T1: 执行 Task1
    T1-&gt;&gt;T1: 执行中...（耗时5秒）
    
    Note over T2,T3: Task2 和 Task3 等待
    T2--xS: 无法执行
    T3--xS: 无法执行
    
    T1-&gt;&gt;S: 完成
    S-&gt;&gt;T2: 执行 Task2
    T2-&gt;&gt;S: 完成
    S-&gt;&gt;T3: 执行 Task3
    T3-&gt;&gt;S: 完成</code></pre>
<h4 id="4-3-正确做法：显式配置">4.3 正确做法：显式配置</h4>
<p><strong>方式一：实现 SchedulingConfigurer（最可控）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SchedulingConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">SchedulingConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Bean(destroyMethod = &quot;shutdown&quot;)</span><br>    <span class="hljs-keyword">public</span> ScheduledThreadPoolExecutor <span class="hljs-title function_">taskScheduler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ScheduledThreadPoolExecutor</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ScheduledThreadPoolExecutor</span>(<span class="hljs-number">4</span>, r -&gt; &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>            t.setName(<span class="hljs-string">&quot;spring-scheduler-&quot;</span> + t.getId());<br>            t.setDaemon(<span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">return</span> t;<br>        &#125;);<br>        exec.setRemoveOnCancelPolicy(<span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 注意: 以下配置会在shutdown时立即取消所有任务</span><br>        <span class="hljs-comment">// 如果需要优雅关闭，考虑设置为true或配合waitForTasksToCompleteOnShutdown使用</span><br>        exec.setExecuteExistingDelayedTasksAfterShutdownPolicy(<span class="hljs-literal">false</span>);<br>        exec.setContinueExistingPeriodicTasksAfterShutdownPolicy(<span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span> exec;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">configureTasks</span><span class="hljs-params">(ScheduledTaskRegistrar taskRegistrar)</span> &#123;<br>        taskRegistrar.setScheduler(taskScheduler());<br><br>        <span class="hljs-comment">// Spring 的错误处理钩子：防止异常导致任务静默停止/没人知道</span><br>        taskRegistrar.setErrorHandler(t -&gt;<br>            System.err.println(<span class="hljs-string">&quot;scheduled task error: &quot;</span> + t)<br>        );<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>对应的任务</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Jobs</span> &#123;<br><br>    <span class="hljs-meta">@Scheduled(fixedDelayString = &quot;2000&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanup</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 永远 catch，ErrorHandler 是兜底，不是主策略</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            doCleanup();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-comment">// log + metrics</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>方式二：使用 ThreadPoolTaskScheduler（Spring 的包装）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> ThreadPoolTaskScheduler <span class="hljs-title function_">threadPoolTaskScheduler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ThreadPoolTaskScheduler</span> <span class="hljs-variable">ts</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskScheduler</span>();<br>    ts.setPoolSize(<span class="hljs-number">4</span>);<br>    ts.setThreadNamePrefix(<span class="hljs-string">&quot;spring-ts-&quot;</span>);<br>    ts.setRemoveOnCancelPolicy(<span class="hljs-literal">true</span>);<br>    ts.setErrorHandler(t -&gt; System.err.println(<span class="hljs-string">&quot;task error: &quot;</span> + t));<br>    ts.initialize();<br>    <span class="hljs-keyword">return</span> ts;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="4-4-关键要点">4.4 关键要点</h4>
<ul>
<li><strong>线程名很重要</strong>：排查线程栈、日志定位、告警归因都靠它</li>
<li><strong>ErrorHandler 更像&quot;集中兜底记录&quot;</strong>：你仍应在任务内部捕获异常并做业务级处理</li>
<li><strong>显式配置是必须的</strong>：不要依赖默认值，因为它可能不是你想要的</li>
</ul>
<h4 id="4-5-spring-的-fixedrate-fixeddelay-与-juc-的对应关系">4.5 Spring 的 fixedRate/fixedDelay 与 JUC 的对应关系</h4>
<table>
<thead>
<tr>
<th>Spring 注解</th>
<th>JUC 方法</th>
<th>语义</th>
<th>时间计算基准</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>@Scheduled(fixedRate=1000)</code></td>
<td><code>scheduleAtFixedRate</code></td>
<td>固定频率（理论上每1s执行）</td>
<td>上次<strong>开始时间</strong> + period</td>
</tr>
<tr>
<td><code>@Scheduled(fixedDelay=1000)</code></td>
<td><code>scheduleWithFixedDelay</code></td>
<td>固定延迟（完成后延迟1s再执行）</td>
<td>上次<strong>完成时间</strong> + delay</td>
</tr>
<tr>
<td><code>@Scheduled(cron=...)</code></td>
<td>无直接对应</td>
<td>Cron 语义（墙上时钟）</td>
<td>绝对时间点</td>
</tr>
</tbody>
</table>
<p><strong>关键差异</strong>：</p>
<ul>
<li><code>fixedRate</code>: 努力维持固定频率，但如果任务执行时间超过period，会等待任务完成后立即执行下一次</li>
<li><code>fixedDelay</code>: 严格保证任务间隔，每次都在完成后等待delay时间</li>
<li><code>cron</code>: 按照cron表达式的绝对时间执行，与任务执行时间无关</li>
</ul>
<p><strong>注意</strong>：<code>@Scheduled(cron=...)</code> 是 cron 语义（墙上时钟），通常更像 Quartz 的使用体验；但底层执行仍依赖 scheduler/线程池，仍会受线程池大小影响。</p>
<h4 id="4-6-避免-任务重入-的手段">4.6 避免&quot;任务重入&quot;的手段</h4>
<p>在 Spring 集群中，<code>@Scheduled</code> 默认每个实例都会跑一遍。常见做法：</p>
<ul>
<li>用 DB/Redis 分布式锁（ShedLock 是常用库）保证同一时刻只有一个实例执行</li>
<li>或用 leader election（K8s lease / ZK / etcd）</li>
</ul>
<p>此外即便单机，也可能因为任务慢造成&quot;下一次触发时上一次还没结束&quot;的重入风险（cron 语义更常见）。处理方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-meta">@Scheduled(cron = &quot;0 */1 * * * *&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">job</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!lock.tryLock()) &#123;<br>        <span class="hljs-comment">// 记录跳过执行，便于排查问题</span><br>        logger.warn(<span class="hljs-string">&quot;Previous job is still running, skipping this execution&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123; <br>        doJob(); <br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-comment">// 捕获所有异常，防止任务静默停止</span><br>        logger.error(<span class="hljs-string">&quot;Job execution failed&quot;</span>, t);<br>    &#125; <span class="hljs-keyword">finally</span> &#123; <br>        lock.unlock(); <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-生产环境最佳实践">5. 生产环境最佳实践</h3>
<h4 id="5-1-参数调优指南">5.1 参数调优指南</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ProductionThreadPoolConfig</span> &#123;<br>    <br>    <span class="hljs-comment">// IO密集型任务配置</span><br>    <span class="hljs-meta">@Bean(&quot;ioTaskExecutor&quot;)</span><br>    <span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title function_">ioTaskExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>        <br>        <span class="hljs-comment">// IO密集型：线程数 = CPU核心数 × (1 + IO等待时间/CPU计算时间)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">processors</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br>        executor.setCorePoolSize(processors * <span class="hljs-number">8</span>);    <span class="hljs-comment">// 假设IO/CPU = 7:1</span><br>        executor.setMaxPoolSize(processors * <span class="hljs-number">16</span>);<br>        executor.setQueueCapacity(<span class="hljs-number">1000</span>);<br>        <br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;io-worker-&quot;</span>);<br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>    <br>    <span class="hljs-comment">// CPU密集型任务配置</span><br>    <span class="hljs-meta">@Bean(&quot;cpuTaskExecutor&quot;)</span><br>    <span class="hljs-keyword">public</span> TaskExecutor <span class="hljs-title function_">cpuTaskExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>        <br>        <span class="hljs-comment">// CPU密集型：线程数 ≈ CPU核心数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">processors</span> <span class="hljs-operator">=</span> Runtime.getRuntime().availableProcessors();<br>        executor.setCorePoolSize(processors);<br>        executor.setMaxPoolSize(processors);<br>        executor.setQueueCapacity(<span class="hljs-number">50</span>);<br>        <br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;cpu-worker-&quot;</span>);<br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="5-与其他框架组件的集成">5. 与其他框架组件的集成</h3>
<h4 id="5-1-与-async注解集成">5.1 与@Async注解集成</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncBusinessService</span> &#123;<br>    <br>    <span class="hljs-meta">@Async(&quot;ioTaskExecutor&quot;)</span><br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;String&gt; <span class="hljs-title function_">processIoTask</span><span class="hljs-params">(String taskId)</span> &#123;<br>        <span class="hljs-comment">// @Async已经将方法异步化到ioTaskExecutor，直接执行业务逻辑</span><br>        <span class="hljs-comment">// 不要再使用CompletableFuture.supplyAsync()，避免双重异步化</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 模拟IO操作</span><br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>            <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(<span class="hljs-string">&quot;Processed: &quot;</span> + taskId);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>            <span class="hljs-keyword">return</span> CompletableFuture.failedFuture(e);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Async(&quot;cpuTaskExecutor&quot;)</span><br>    <span class="hljs-keyword">public</span> CompletableFuture&lt;Integer&gt; <span class="hljs-title function_">processCpuTask</span><span class="hljs-params">(List&lt;Integer&gt; numbers)</span> &#123;<br>        <span class="hljs-comment">// CPU密集型并行计算</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> numbers.parallelStream()<br>                           .mapToInt(Integer::intValue)<br>                           .sum();<br>        <span class="hljs-keyword">return</span> CompletableFuture.completedFuture(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/">https://magicliang.github.io/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a><a class="post-meta__tags" href="/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/">线程池</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="Java 并发编程笔记"><img class="cover" src="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-12</div><div class="info-item-2">Java 并发编程笔记</div></div><div class="info-2"><div class="info-item-1"> juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 MESA 模型 JAVA 采用 MESA 模型：  互斥（Mutual Exclusion）：通过锁机制保证同一时刻只有一个线程能进入管程内部执行。 同步（Synchronization）：利用条件变量（Condition Variable）实现线程间的等待与唤醒。 Signal and Continue：   当线程发出通知（signal/notify）时，它继续持有锁并运行，而被唤醒的线程仅仅是进入就绪队列，并不立即抢占 CPU。   必须使用 while 循环：   由于线程被唤醒后不一定立即执行，当它重新获得锁时，环境条件可能已发生变化，因此必须在一个 while 循环中重新检查等待条件（while (condition) { wait(); }）。  为什么用 se...</div></div></div></a><a class="pagination-related" href="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" title="无锁队列"><img class="cover" src="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">无锁队列</div></div><div class="info-2"><div class="info-item-1">Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。 * * &lt;p&gt;原理说明： * - 仅允许一个线程调用 &#123;@code offer()&#125;，一个线程调用 &#123;@code poll()&#125;。 * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。 * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系： *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。 * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad）， *   ...</div></div></div></a><a class="pagination-related" href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-19</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1"> 版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374）。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级。但在深入讨论线程安全的分类之前，我们需要先理解 Java 内存模型——它是理解线程安全问题的理论基础。 Java 内存模型基础 Java 内存模型（Java Memory Model，JMM）是 Java 语言规范的一部分，定义了多线程程序中共享变量的访问规则。理解 JMM 是理解线程安全问题的基础。 为什么需要内存模型？ 现代计算机系统中，CPU 与主内存之间存在巨大的速度差异。为了弥补这一差距，硬件层面引入了多级缓存（L1、L2、L3 Cache）。这带来了一个问...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-96.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2017/11/03/JVM-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="JVM 的内存模型与线程"><img class="cover" src="/img/wall-paper-94.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-03</div><div class="info-item-2">JVM 的内存模型与线程</div></div><div class="info-2"><div class="info-item-1">JVM 的内存模型与线程 Java 内存模型（Java Memory Model, JMM）定义了多线程环境下共享变量的访问规则，是理解并发编程的基石。本文从硬件架构出发，逐步深入到 JMM 的核心机制与实践模式。 mindmap   root((JMM))     硬件基础       CPU缓存层次       缓存一致性协议     JMM 抽象       主内存 vs 工作内存       八种内存操作       happens-before 关系     关键保证       原子性       可见性       有序性     实践工具       volatile       synchronized       final 模式总览    # 模式名称 一句话口诀 适用场景     1 写刷读清 写入即刷盘，读取先清空 volatile / unlock 后的可见性   2 顺序锁 同把锁内，串行执行 synchronized 临界区保护   3 偏序传递 A先于B，B先于C，则A先于C happens-before 链式推理   4 不可变安全 构造完成前...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-146.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">上下文 卡表和 RSet（Remember Set），是 JVM 为了解决分代收集时，live set 扫描需要穿梭到不同的代的时候的效率问题。 使用缓存表来提高查询效率，是化顺序查找为部分随机查找的一种常用的设计思路。 例如，在传统的计算机体系结构中，当我们把内存分成页以后，会有一个页表，页表又会有一个快表，作为一个中间缓存项，来帮助我们查找我们需要使用的页表项（table entry）。 JVM 在进行垃圾收集的时候，有一项非常重要的工作就是确定这一次垃圾收集的对象到底有多少个，即确定 live set 的范围。 对于新生代垃圾收集器而言，这个问题又有其特殊之处。根据 JVM 的弱分代收集假设（weak generational hypothesis）的存在，每次垃圾收集的时候，新生代的扫描范围可能很大，但新生代的 live set 不应该太大。card table/Remember Set 的设计目的，就是尽量减少无用的垃圾扫描范围，使用类似操作系统或者数据库的脏页表的形式，来做类似快表的查询。 卡表（card table）  卡表是 CMS 的解决方案。 卡表通常在 JV...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">从执行器到线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">1.1.</span> <span class="toc-text">执行器继承体系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#executor-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.1.</span> <span class="toc-text">Executor 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#executorservice-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.2.</span> <span class="toc-text">ExecutorService 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abstractexecutorservice"><span class="toc-number">1.1.3.</span> <span class="toc-text">AbstractExecutorService</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#newtaskfor%EF%BC%9A%E4%BB%BB%E5%8A%A1%E5%8C%85%E8%A3%85%E7%9A%84%E6%A0%B8%E5%BF%83%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">newTaskFor：任务包装的核心工厂方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#threadpoolexecutor"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjoinpool"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">ForkJoinPool</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduledexecutorservice-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.1.4.</span> <span class="toc-text">ScheduledExecutorService 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduledexecutorservice-%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.1.5.</span> <span class="toc-text">ScheduledExecutorService 内部实现详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%9E%B6%E6%9E%84"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">1. 核心组件架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-delayedworkqueue-%E7%9A%84-leader-follower-%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">2. DelayedWorkQueue 的 Leader-Follower 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-scheduledfuturetask-%E7%9A%84%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">3. ScheduledFutureTask 的时间管理机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">1.1.5.4.</span> <span class="toc-text">4. 任务调度的完整流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%92%8C%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.1.5.5.</span> <span class="toc-text">5. 内存管理和性能优化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduledexecutorservice-%E4%B8%8E-abstractexecutorservice-%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BE%A8%E6%9E%90"><span class="toc-number">1.1.6.</span> <span class="toc-text">ScheduledExecutorService 与 AbstractExecutorService 的关系辨析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%EF%BC%9Aapi-%E4%B9%8B%E9%97%B4%E6%98%AF%E5%90%A6%E4%B9%9F%E6%98%AF-abstractexecutorservice-%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">关键问题：API 之间是否也是 AbstractExecutorService 的调用关系？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#api-%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.6.1.1.</span> <span class="toc-text">API 分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%AF%94"><span class="toc-number">1.1.6.1.2.</span> <span class="toc-text">实现对比</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%9B%BE%E7%A4%BA"><span class="toc-number">1.1.6.1.3.</span> <span class="toc-text">对比图示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA"><span class="toc-number">1.1.6.1.4.</span> <span class="toc-text">关键结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scheduledexecutorservice-%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.1.7.</span> <span class="toc-text">ScheduledExecutorService 核心机制详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-future-get-%E7%9A%84%E8%AF%AD%E4%B9%89%E5%B7%AE%E5%BC%82%EF%BC%9A%E4%B8%80%E6%AC%A1%E6%80%A7%E4%BB%BB%E5%8A%A1-vs-%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">1. Future.get() 的语义差异：一次性任务 vs 周期任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%B2%E8%A1%8C%E5%8C%96%E9%93%81%E5%BE%8B%EF%BC%9A%E5%8D%95%E4%B8%80%E4%BB%BB%E5%8A%A1%E4%B8%B2%E8%A1%8C-%E4%B8%8D%E5%90%8C%E4%BB%BB%E5%8A%A1%E5%B9%B6%E8%A1%8C"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">2. 串行化铁律：单一任务串行，不同任务并行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%BC%82%E7%A7%BB-drift-%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%87%E5%B0%8F%E5%AF%BC%E8%87%B4%E7%9A%84%E6%89%A7%E8%A1%8C%E5%BB%B6%E8%BF%9F"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">3. 漂移（Drift）：线程池过小导致的执行延迟</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-api-%E5%8F%82%E6%95%B0%E8%AF%AD%E4%B9%89%EF%BC%9Adelay-vs-period"><span class="toc-number">1.1.7.4.</span> <span class="toc-text">4. API 参数语义：delay vs period</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%BC%82%E5%B8%B8%E7%BB%88%E6%AD%A2%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-number">1.1.7.5.</span> <span class="toc-text">5. 周期任务异常终止的陷阱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-cancel-true-vs-cancel-false-%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">1.1.7.6.</span> <span class="toc-text">6. cancel(true) vs cancel(false) 的差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-setremoveoncancelpolicy-true-%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">1.1.7.7.</span> <span class="toc-text">7. setRemoveOnCancelPolicy(true) 的重要性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%A4%8D%E7%94%A8%E5%AF%B9%E8%B1%A1%E4%B8%8E%E4%B8%B2%E8%A1%8C%E5%8C%96%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.7.8.</span> <span class="toc-text">8. 周期任务复用对象与串行化的设计原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-time-%E5%AD%97%E6%AE%B5%E7%9A%84%E5%8F%AF%E5%A4%8D%E7%94%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.1.7.9.</span> <span class="toc-text">9. time 字段的可复用设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-%E7%90%86%E8%AE%BA%E6%97%B6%E9%97%B4%E8%BD%B4-vs-%E5%BD%93%E4%B8%8B%E6%97%B6%E9%97%B4%E8%B5%B7%E7%82%B9%EF%BC%9Arate-vs-delay-%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%B7%AE%E5%BC%82"><span class="toc-number">1.1.7.10.</span> <span class="toc-text">10. 理论时间轴 vs 当下时间起点：Rate vs Delay 的根本差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E5%B7%A5%E7%A8%8B%E7%BA%A7%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.1.7.11.</span> <span class="toc-text">11. 工程级最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#the-executors"><span class="toc-number">1.1.8.</span> <span class="toc-text">The Executors</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.1.8.1.</span> <span class="toc-text">常用工厂方法详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-newfixedthreadpool"><span class="toc-number">1.1.8.1.1.</span> <span class="toc-text">1. newFixedThreadPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-newcachedthreadpool"><span class="toc-number">1.1.8.1.2.</span> <span class="toc-text">2. newCachedThreadPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-newsinglethreadexecutor"><span class="toc-number">1.1.8.1.3.</span> <span class="toc-text">3. newSingleThreadExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-newsinglethreadscheduledexecutor"><span class="toc-number">1.1.8.1.4.</span> <span class="toc-text">4. newSingleThreadScheduledExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-newscheduledthreadpool"><span class="toc-number">1.1.8.1.5.</span> <span class="toc-text">5. newScheduledThreadPool</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-newworkstealingpool-jdk-8"><span class="toc-number">1.1.8.1.6.</span> <span class="toc-text">6. newWorkStealingPool（JDK 8+）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">1.1.8.2.</span> <span class="toc-text">工厂方法对比总结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.1.8.3.</span> <span class="toc-text">生产环境建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.</span> <span class="toc-text">层次调用关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#futuretask-%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%BB%E5%8A%A1%E8%BD%BD%E4%BD%93"><span class="toc-number">1.2.1.</span> <span class="toc-text">FutureTask 作为线程池的核心任务载体</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#thread-%E6%A8%A1%E5%9E%8B%E5%BA%95%E5%B1%82"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Thread 模型底层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#futuretask-%E7%9A%84-run"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">FutureTask 的 run()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#futuretask-%E7%9A%84-runner"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">FutureTask 的 runner</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#invokeall"><span class="toc-number">1.2.1.3.1.</span> <span class="toc-text">invokeAll</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%92%88%E5%AF%B9-runnable-%E7%9A%84-submit"><span class="toc-number">1.2.1.3.2.</span> <span class="toc-text">两种针对 Runnable 的 submit</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8A%A4%E8%87%AA%E8%BA%AB%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">线程池如何维护自身状态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.3.1.</span> <span class="toc-text">尝试关闭线程池</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">1.4.</span> <span class="toc-text">线程池如何管理任务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">1.4.1.</span> <span class="toc-text">任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">提交任务调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%BC%93%E5%86%B2"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">任务缓冲</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%8B%92%E7%BB%9D"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">任务拒绝</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%94%B3%E8%AF%B7"><span class="toc-number">1.4.1.4.</span> <span class="toc-text">任务申请</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text">线程池如何管理线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">尝试增加线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="toc-number">1.5.2.</span> <span class="toc-text">线程执行</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.5.2.1.</span> <span class="toc-text">典型应用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.5.2.2.</span> <span class="toc-text">关键注意事项</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%A9%E5%AD%90%E6%96%B9%E6%B3%95%E4%B8%8E%E7%8A%B6%E6%80%81%E6%9C%BA%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.5.2.3.</span> <span class="toc-text">钩子方法与状态机的关系</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.</span> <span class="toc-text">线程池使用中可能遇到的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%95%E4%B8%8E%E6%AD%A3%E7%A1%AE%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">常见错误用法与正确实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%951-%E4%BD%BF%E7%94%A8%E6%97%A0%E7%95%8C%E9%98%9F%E5%88%97%E5%AF%BC%E8%87%B4oom"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">错误用法1: 使用无界队列导致OOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%952-newcachedthreadpool%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E7%88%86%E7%82%B8"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">错误用法2: newCachedThreadPool导致线程爆炸</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%953-%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E4%B8%8D%E6%8D%95%E8%8E%B7%E5%BC%82%E5%B8%B8"><span class="toc-number">1.6.1.3.</span> <span class="toc-text">错误用法3: 周期任务不捕获异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%954-%E4%B8%8D%E8%AE%BE%E7%BD%AE%E7%BA%BF%E7%A8%8B%E5%90%8D%E7%A7%B0%E5%AF%BC%E8%87%B4%E6%8E%92%E6%9F%A5%E5%9B%B0%E9%9A%BE"><span class="toc-number">1.6.1.4.</span> <span class="toc-text">错误用法4: 不设置线程名称导致排查困难</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E7%94%A8%E6%B3%955-shutdown%E5%90%8E%E7%AB%8B%E5%8D%B3awaittermination"><span class="toc-number">1.6.1.5.</span> <span class="toc-text">错误用法5: shutdown后立即awaitTermination</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%B0%83%E5%8F%82%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99"><span class="toc-number">1.6.2.</span> <span class="toc-text">线程池调参的核心原则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88"><span class="toc-number">1.7.</span> <span class="toc-text">线程池的可替换方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.1.</span> <span class="toc-text">传统替代方案对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3java%E5%B9%B6%E5%8F%91%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">1.7.2.</span> <span class="toc-text">现代Java并发框架对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.7.3.</span> <span class="toc-text">选择建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.8.</span> <span class="toc-text">最终解决方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%91%E6%8E%A7%E4%B8%8E%E8%B0%83%E4%BC%98%E5%AE%9E%E8%B7%B5"><span class="toc-number">1.9.</span> <span class="toc-text">线程池监控与调优实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E6%8C%87%E6%A0%87%E9%87%87%E9%9B%86"><span class="toc-number">1.9.1.</span> <span class="toc-text">监控指标采集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%94%9F%E4%BA%A7%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">1.9.2.</span> <span class="toc-text">常见生产问题排查</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%98%9F%E5%88%97%E7%A7%AF%E5%8E%8B%E5%AF%BC%E8%87%B4oom"><span class="toc-number">1.9.2.1.</span> <span class="toc-text">案例1: 线程池队列积压导致OOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B2-newcachedthreadpool%E7%BA%BF%E7%A8%8B%E7%88%86%E7%82%B8"><span class="toc-number">1.9.2.2.</span> <span class="toc-text">案例2: newCachedThreadPool线程爆炸</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A1%88%E4%BE%8B3-%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E9%9D%99%E9%BB%98%E5%81%9C%E6%AD%A2"><span class="toc-number">1.9.2.3.</span> <span class="toc-text">案例3: 周期任务静默停止</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E4%BC%98%E5%BB%BA%E8%AE%AE"><span class="toc-number">1.9.3.</span> <span class="toc-text">调优建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-number">1.10.</span> <span class="toc-text">线程组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E6%9C%AC%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84"><span class="toc-number">1.10.1.</span> <span class="toc-text">原本设计目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-number">1.10.2.</span> <span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">1.10.3.</span> <span class="toc-text">替代方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%80%81%E5%BA%A6"><span class="toc-number">1.10.4.</span> <span class="toc-text">官方态度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completionstage"><span class="toc-number">1.11.</span> <span class="toc-text">CompletionStage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completablefuture"><span class="toc-number">1.12.</span> <span class="toc-text">CompletableFuture</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98"><span class="toc-number">2.1.</span> <span class="toc-text">如何处理任务超时问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E4%BD%BF%E7%94%A8-futuretask-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">方法1：使用 FutureTask 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">方法2：使用条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E4%BD%BF%E7%94%A8-countdownlatch-cyclicbarrier"><span class="toc-number">2.1.3.</span> <span class="toc-text">方法3：使用 countDownLatch&#x2F;CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E6%96%AD"><span class="toc-number">2.2.</span> <span class="toc-text">自定义线程池实现自定义中断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Java 异步执行中的异常处理与线程生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-futuretask-asyncuncaughtexceptionhandler-%E5%88%B0-uncaughtexceptionhandler"><span class="toc-number">3.1.</span> <span class="toc-text">从 FutureTask、AsyncUncaughtExceptionHandler 到 UncaughtExceptionHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%88%E6%AD%A2%E7%9A%84%E5%94%AF%E4%B8%80%E5%88%A4%E5%AE%9A%E6%A0%87%E5%87%86"><span class="toc-number">3.2.</span> <span class="toc-text">一、线程是否终止的唯一判定标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">1.1 会导致线程终止的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">3.2.2.</span> <span class="toc-text">1.2 不会导致线程终止的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-futuretask-%E5%AF%B9%E5%BC%82%E5%B8%B8%E4%BC%A0%E6%92%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">3.3.</span> <span class="toc-text">二、FutureTask 对异常传播路径的改变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-execute-%E4%B8%8E-submit-%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%B7%AE%E5%BC%82"><span class="toc-number">3.3.1.</span> <span class="toc-text">2.1 execute 与 submit 的根本差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-futuretask-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA%E7%82%B9"><span class="toc-number">3.3.2.</span> <span class="toc-text">2.2 FutureTask 中的异常拦截点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BC%82%E5%B8%B8%E5%A6%82%E4%BD%95%E8%A2%AB%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%EF%BC%9Areport"><span class="toc-number">3.3.3.</span> <span class="toc-text">2.3 异常如何被重新抛出：report()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-uncaughtexceptionhandler-%E7%9A%84%E8%81%8C%E8%B4%A3%E8%BE%B9%E7%95%8C"><span class="toc-number">3.4.</span> <span class="toc-text">三、UncaughtExceptionHandler 的职责边界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text">3.1 触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%83%BD%E5%8A%9B%E4%B8%8E%E9%99%90%E5%88%B6"><span class="toc-number">3.4.2.</span> <span class="toc-text">3.2 能力与限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-spring-asyncuncaughtexceptionhandler-%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">3.5.</span> <span class="toc-text">四、Spring AsyncUncaughtExceptionHandler 的作用范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.5.1.</span> <span class="toc-text">4.1 适用条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-spring-%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA%E6%96%B9%E5%BC%8F"><span class="toc-number">3.5.2.</span> <span class="toc-text">4.2 Spring 的异常拦截方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AF%B9%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">3.5.3.</span> <span class="toc-text">4.3 对线程生命周期的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E4%B8%89%E7%A7%8D%E5%BC%82%E5%B8%B8%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.6.</span> <span class="toc-text">五、三种异常路径的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-async-void-%E6%96%B9%E6%B3%95"><span class="toc-number">3.6.1.</span> <span class="toc-text">5.1 @Async void 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0execute"><span class="toc-number">3.6.2.</span> <span class="toc-text">5.2 线程池execute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0-submit"><span class="toc-number">3.6.3.</span> <span class="toc-text">5.3 线程池 submit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E4%B8%A4%E7%A7%8D-handler-%E7%9A%84%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">3.7.</span> <span class="toc-text">六、两种 Handler 的推荐使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-asyncuncaughtexceptionhandler-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">3.7.1.</span> <span class="toc-text">6.1 AsyncUncaughtExceptionHandler（业务层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-uncaughtexceptionhandler-%E7%B3%BB%E7%BB%9F%E5%B1%82"><span class="toc-number">3.7.2.</span> <span class="toc-text">6.2 UncaughtExceptionHandler（系统层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.7.3.</span> <span class="toc-text">6.3 有返回值的异步任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">3.8.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">Spring 的异步支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpooltaskexecutor"><span class="toc-number">4.1.</span> <span class="toc-text">ThreadPoolTaskExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpooltaskexecutor-%E5%86%85%E9%83%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">ThreadPoolTaskExecutor 内部线程池的替换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E8%A3%85%E9%A5%B0"><span class="toc-number">4.2.1.</span> <span class="toc-text">推荐：使用初始化器装饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BB%A3%E7%90%86"><span class="toc-number">4.2.2.</span> <span class="toc-text">其他代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%A6%81%E6%9B%BF%E6%8D%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.2.3.</span> <span class="toc-text">如果我们要替换线程池实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E8%A1%8C-trace-%E4%BC%A0%E9%80%92"><span class="toc-number">4.3.</span> <span class="toc-text">对线程池实行 trace 传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%E7%BB%9F%E4%B8%80%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">4.3.1.</span> <span class="toc-text">如果使用统一包装器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">ForkJoinPool详解：分治并行的执行引擎</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A%E5%88%86%E6%B2%BB%E5%B9%B6%E8%A1%8C%E7%9A%84%E8%AF%9E%E7%94%9F"><span class="toc-number">5.1.</span> <span class="toc-text">前言：分治并行的诞生</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9Aforkjoinpool%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-number">5.2.</span> <span class="toc-text">1. 核心数据结构：ForkJoinPool的基石</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-forkjoinpool%EF%BC%9A%E5%8E%BB%E4%B8%AD%E5%BF%83%E5%8C%96%E7%9A%84%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">5.2.1.</span> <span class="toc-text">1.1 ForkJoinPool：去中心化的调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">数据结构定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Ethreadpoolexecutor%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">与ThreadPoolExecutor的本质区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%B7%AE%E5%BC%82"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">关键差异</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-forkjoinworkerthreadfactory%EF%BC%9A%E4%B8%93%E7%94%A8%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%8E%82"><span class="toc-number">5.2.2.</span> <span class="toc-text">1.2 ForkJoinWorkerThreadFactory：专用线程工厂</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%AE%9A%E4%B9%89%E4%B8%8E%E5%AF%B9%E6%AF%94"><span class="toc-number">5.2.2.1.</span> <span class="toc-text">接口定义与对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.2.2.</span> <span class="toc-text">关键区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#fjp-%E7%9A%84%E6%89%A9%E5%B1%95%E6%96%B9%E6%B3%95"><span class="toc-number">5.2.2.2.1.</span> <span class="toc-text">FJP 的扩展方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%84%8F%E4%B9%89"><span class="toc-number">5.2.2.3.</span> <span class="toc-text">设计意义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-forkjoinworkerthread%EF%BC%9A%E5%8D%8F%E4%BD%9C%E5%BC%8F%E6%89%A7%E8%A1%8C%E8%80%85"><span class="toc-number">5.2.3.</span> <span class="toc-text">1.3 ForkJoinWorkerThread：协作式执行者</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.3.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Ethreadpoolexecutor-worker%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">5.2.3.2.</span> <span class="toc-text">与ThreadPoolExecutor.Worker的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96"><span class="toc-number">5.2.3.3.</span> <span class="toc-text">设计决策</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%89%B9%E6%80%A7%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88forkjoinpool%E4%B8%8D%E4%BC%9A%E6%9C%89%E7%BA%BF%E7%A8%8B%E6%B3%84%E9%9C%B2%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">5.2.3.4.</span> <span class="toc-text">线程安全特性：为什么ForkJoinPool不会有线程泄露问题？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-workqueue%EF%BC%9A%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.2.4.</span> <span class="toc-text">1.4 WorkQueue：双端队列的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.4.1.</span> <span class="toc-text">数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%93%8D%E4%BD%9C"><span class="toc-number">5.2.4.2.</span> <span class="toc-text">核心操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lifo-fifo-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%99%BA%E6%85%A7%EF%BC%9A"><span class="toc-number">5.2.4.3.</span> <span class="toc-text">LIFO + FIFO 的设计智慧：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjointask-join-%E4%B8%8E-thread-join-%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%B7%AE%E5%BC%82"><span class="toc-number">5.2.4.4.</span> <span class="toc-text">ForkJoinTask.join() 与 Thread.join() 的本质差异</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-5-forkjointask%EF%BC%9A%E4%BB%BB%E5%8A%A1%E6%8A%BD%E8%B1%A1"><span class="toc-number">5.2.5.</span> <span class="toc-text">1.5 ForkJoinTask：任务抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84"><span class="toc-number">5.2.5.1.</span> <span class="toc-text">核心结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%AD%90%E7%B1%BB"><span class="toc-number">5.2.5.2.</span> <span class="toc-text">标准子类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8Efuturetask%E7%9A%84%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">5.2.5.3.</span> <span class="toc-text">与FutureTask的关键区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%85%B3%E9%94%AEapi%EF%BC%9A%E4%B8%8Ethreadpoolexecutor%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">5.3.</span> <span class="toc-text">2. 关键API：与ThreadPoolExecutor的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-forkjoinpool%E7%9A%84%E6%A0%B8%E5%BF%83api"><span class="toc-number">5.3.1.</span> <span class="toc-text">2.1 ForkJoinPool的核心API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%AE%A2%E6%88%B7%E7%AB%AFapi"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">外部客户端API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E8%AE%A1%E7%AE%97api"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">内部计算API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%91%E6%8E%A7%E4%B8%8E%E7%AE%A1%E7%90%86api"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">监控与管理API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-forkjoinpool-%E4%B8%8E-abstractexecutorservice-%E7%9A%84%E5%85%B3%E7%B3%BB%E8%BE%A8%E6%9E%90"><span class="toc-number">5.3.2.</span> <span class="toc-text">2.2 ForkJoinPool 与 AbstractExecutorService 的关系辨析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%EF%BC%9Asubmit-%E5%92%8C-execute-%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%E5%90%A6%E6%94%B9%E5%8F%98%E4%BA%86%EF%BC%9F"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">关键问题：submit 和 execute 的关系是否改变了？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B51%EF%BC%9A%E6%99%AE%E9%80%9A-runnable-callable-%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.3.2.1.1.</span> <span class="toc-text">情况1：普通 Runnable&#x2F;Callable 任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B52%EF%BC%9Aforkjointask-%E4%BB%BB%E5%8A%A1"><span class="toc-number">5.3.2.1.2.</span> <span class="toc-text">情况2：ForkJoinTask 任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%9B%BE%E7%A4%BA"><span class="toc-number">5.3.2.1.3.</span> <span class="toc-text">对比图示</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA"><span class="toc-number">5.3.2.1.4.</span> <span class="toc-text">关键结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-api%E4%BD%BF%E7%94%A8%E8%BE%B9%E7%95%8C%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%B7%B7%E7%94%A8%EF%BC%9F"><span class="toc-number">5.3.3.</span> <span class="toc-text">2.3 API使用边界：为什么不能混用？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%8A%A8%E6%80%81%E9%80%82%E5%BA%94%E7%9A%84%E8%89%BA%E6%9C%AF"><span class="toc-number">5.4.</span> <span class="toc-text">3. 线程调度机制：动态适应的艺术</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E5%B9%B6%E8%A1%8C%E5%BA%A6%EF%BC%9A%E5%94%AF%E4%B8%80%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.1.</span> <span class="toc-text">3.1 并行度：唯一的核心参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">配置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E6%B1%A0%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%B1%9E%E6%80%A7"><span class="toc-number">5.4.1.2.</span> <span class="toc-text">公共池的系统属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E5%8F%82%E6%95%B0%E7%9A%84%E5%AE%9E%E9%99%85%E5%BD%B1%E5%93%8D%EF%BC%9A"><span class="toc-number">5.4.1.3.</span> <span class="toc-text">各参数的实际影响：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%97%A0core-max%E5%8F%82%E6%95%B0%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">5.4.2.</span> <span class="toc-text">3.2 无core&#x2F;max参数的设计哲学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#threadpoolexecutor%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">ThreadPoolExecutor的线程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjoinpool%E7%9A%84%E7%BA%BF%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">ForkJoinPool的线程管理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parallelism-vs-corepoolsize-maximumspares-vs-maximumpoolsize%EF%BC%9A"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">parallelism vs corePoolSize, maximumSpares vs maximumPoolSize：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.2.4.</span> <span class="toc-text">线程回收机制对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#fjp%E7%BA%BF%E7%A8%8B%E5%9B%9E%E6%94%B6%E7%BB%86%E8%8A%82"><span class="toc-number">5.4.2.5.</span> <span class="toc-text">FJP线程回收细节</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%B2%A1%E6%9C%89%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9A%E6%97%A0%E7%95%8C%E9%98%9F%E5%88%97%E4%B8%8E%E4%BB%BB%E5%8A%A1%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.4.3.</span> <span class="toc-text">3.3 为什么没有拒绝策略：无界队列与任务消费模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjoinpool-%E6%9E%84%E9%80%A0%E5%99%A8%E5%AF%B9%E6%AF%94"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">ForkJoinPool 构造器对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E9%9C%80%E8%A6%81%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%EF%BC%9F"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">为什么不需要拒绝策略？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E6%97%A0%E7%95%8C%E4%BC%9A%E5%AF%BC%E8%87%B4-oom-%E5%90%97%EF%BC%9F"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">队列无界会导致 OOM 吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%E6%80%BB%E7%BB%93"><span class="toc-number">5.4.3.4.</span> <span class="toc-text">设计哲学总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%B7%A5%E4%BD%9C%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">5.4.4.</span> <span class="toc-text">3.4 工作线程生命周期</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%EF%BC%9A%E5%B9%B6%E8%A1%8C%E6%96%87%E4%BB%B6%E6%90%9C%E7%B4%A2%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.5.</span> <span class="toc-text">4. 实战案例：并行文件搜索系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82"><span class="toc-number">5.5.1.</span> <span class="toc-text">4.1 业务需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89"><span class="toc-number">5.5.2.</span> <span class="toc-text">4.2 数据结构定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-number">5.5.3.</span> <span class="toc-text">4.3 线程池初始化与使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%85%B3%E9%94%AE%E8%AE%BE%E8%AE%A1%E5%86%B3%E7%AD%96%E8%A7%A3%E6%9E%90"><span class="toc-number">5.5.4.</span> <span class="toc-text">4.4 关键设计决策解析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8-recursivetask-%E8%80%8C%E4%B8%8D%E6%98%AF-recursiveaction%EF%BC%9F"><span class="toc-number">5.5.4.1.</span> <span class="toc-text">1. 为什么使用 RecursiveTask 而不是 RecursiveAction？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%AE%BE%E7%BD%AEthreshold-100%EF%BC%9F"><span class="toc-number">5.5.4.2.</span> <span class="toc-text">2. 为什么设置THRESHOLD&#x3D;100？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E4%B8%BA%E4%BB%80%E4%B9%88fork%E5%85%B6%E4%BB%96%E4%BB%BB%E5%8A%A1-%E7%9B%B4%E6%8E%A5%E6%89%A7%E8%A1%8C%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E4%BB%BB%E5%8A%A1%EF%BC%9F"><span class="toc-number">5.5.4.3.</span> <span class="toc-text">3. 为什么fork其他任务，直接执行最后一个任务？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%9B%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B1%A0%E8%80%8C%E4%B8%8D%E6%98%AF%E4%BD%BF%E7%94%A8%E5%85%AC%E5%85%B1%E6%B1%A0%EF%BC%9F"><span class="toc-number">5.5.4.4.</span> <span class="toc-text">4. 为什么创建自定义池而不是使用公共池？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E4%B8%BA%E4%BB%80%E4%B9%88asyncmode-false%EF%BC%9F"><span class="toc-number">5.5.4.5.</span> <span class="toc-text">5. 为什么asyncMode&#x3D;false？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%B8%B8%E8%A7%81%E9%94%99%E8%AF%AF%E6%A8%A1%E5%BC%8F%E4%B8%8E%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97"><span class="toc-number">5.6.</span> <span class="toc-text">5. 常见错误模式与避坑指南</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-api%E6%B7%B7%E7%94%A8%E9%94%99%E8%AF%AF"><span class="toc-number">5.6.1.</span> <span class="toc-text">5.1 API混用错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-i-o%E9%98%BB%E5%A1%9E%E9%94%99%E8%AF%AF"><span class="toc-number">5.6.2.</span> <span class="toc-text">5.2 I&#x2F;O阻塞错误</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">5.6.3.</span> <span class="toc-text">两种线程池的本质区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E8%B5%84%E6%BA%90%E6%B3%84%E6%BC%8F%E9%94%99%E8%AF%AF"><span class="toc-number">5.6.4.</span> <span class="toc-text">5.3 资源泄漏错误</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E7%88%B6%E5%AD%90%E4%BB%BB%E5%8A%A1%E6%AD%BB%E9%94%81%EF%BC%9A%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%87%B4%E5%91%BD%E7%BC%BA%E9%99%B7%E4%B8%8Eforkjoinpool%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">5.7.</span> <span class="toc-text">6. 父子任务死锁：传统线程池的致命缺陷与ForkJoinPool的解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E9%97%AE%E9%A2%98%E5%9C%BA%E6%99%AF%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E9%A5%A5%E9%A5%BF%E6%AD%BB%E9%94%81"><span class="toc-number">5.7.1.</span> <span class="toc-text">6.1 问题场景：线程池饥饿死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%A4%8D%E7%8E%B0%E4%BB%A3%E7%A0%81"><span class="toc-number">5.7.1.1.</span> <span class="toc-text">死锁复现代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E5%88%86%E6%9E%90"><span class="toc-number">5.7.1.2.</span> <span class="toc-text">死锁分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E4%BC%A0%E7%BB%9F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E5%B1%80%E9%99%90%E6%80%A7"><span class="toc-number">5.7.2.</span> <span class="toc-text">6.2 传统解决方案的局限性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%881%EF%BC%9A%E5%A2%9E%E5%A4%A7%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%B9%E9%87%8F"><span class="toc-number">5.7.2.1.</span> <span class="toc-text">方案1：增大线程池容量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%882%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%97%A0%E7%95%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.7.2.2.</span> <span class="toc-text">方案2：使用无界线程池</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%A1%883%EF%BC%9A%E7%88%B6%E5%AD%90%E4%BB%BB%E5%8A%A1%E4%BD%BF%E7%94%A8%E4%B8%8D%E5%90%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.7.2.3.</span> <span class="toc-text">方案3：父子任务使用不同线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-forkjoinpool%E7%9A%84%E6%A0%B9%E6%9C%AC%E6%80%A7%E8%A7%A3%E5%86%B3%EF%BC%9A%E5%8D%8F%E4%BD%9C%E5%BC%8F%E7%AD%89%E5%BE%85"><span class="toc-number">5.7.3.</span> <span class="toc-text">6.3 ForkJoinPool的根本性解决：协作式等待</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%9C%BA%E5%88%B6%EF%BC%9Ajoin-%E4%B8%8D%E6%98%AF%E7%9C%9F%E6%AD%A3%E7%9A%84%E9%98%BB%E5%A1%9E"><span class="toc-number">5.7.3.1.</span> <span class="toc-text">核心机制：join()不是真正的阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8F%E4%BD%9C%E7%AD%89%E5%BE%85%E7%9A%84%E6%A0%B8%E5%BF%83%EF%BC%9Aawaitjoin"><span class="toc-number">5.7.3.2.</span> <span class="toc-text">协作等待的核心：awaitJoin()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%AE%E5%8A%A9%E7%AA%83%E5%8F%96%E8%80%85%E6%9C%BA%E5%88%B6-help-stealer"><span class="toc-number">5.7.3.3.</span> <span class="toc-text">帮助窃取者机制（Help Stealer）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%88%B6%E5%AD%90%E4%BB%BB%E5%8A%A1%E5%8F%AF%E4%BB%A5%E4%B8%8D%E7%9B%B8%E4%BA%92%E9%98%BB%E5%A1%9E%EF%BC%9F"><span class="toc-number">5.7.4.</span> <span class="toc-text">6.4 为什么父子任务可以不相互阻塞？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%B1%82%E9%9D%A2%E7%9A%84%E5%BC%82%E6%AD%A5%E5%8C%96%E8%A7%A3%E8%80%A6"><span class="toc-number">5.7.4.1.</span> <span class="toc-text">接口层面的异步化解耦</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B2%BB%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%A4%A9%E7%84%B6%E9%80%82%E9%85%8D"><span class="toc-number">5.7.4.2.</span> <span class="toc-text">分治模式的天然适配</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-5-%E7%BA%BF%E7%A8%8B%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6%EF%BC%9A%E6%9C%89%E9%99%90%E5%BA%A6%E7%9A%84%E5%BC%B9%E6%80%A7"><span class="toc-number">5.7.5.</span> <span class="toc-text">6.5 线程补偿机制：有限度的弹性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%8F%AF%E4%BB%A5%E6%97%A0%E9%99%90%E8%A1%A5%E5%81%BF%E5%90%97%EF%BC%9F"><span class="toc-number">5.7.5.1.</span> <span class="toc-text">线程可以无限补偿吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.7.5.2.</span> <span class="toc-text">补偿机制的工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84%E7%A1%AC%E6%80%A7%E4%B8%8A%E9%99%90"><span class="toc-number">5.7.5.3.</span> <span class="toc-text">线程数的硬性上限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%93%E8%BE%BE%E5%88%B0%E4%B8%8A%E9%99%90%E5%90%8E%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">5.7.5.4.</span> <span class="toc-text">当达到上限后会发生什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E9%99%90%E5%88%B6%E8%A1%A5%E5%81%BF%EF%BC%9F"><span class="toc-number">5.7.5.5.</span> <span class="toc-text">为什么要限制补偿？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.7.5.6.</span> <span class="toc-text">最佳实践</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-6-%E5%AF%B9%E6%AF%94%E9%AA%8C%E8%AF%81"><span class="toc-number">5.7.6.</span> <span class="toc-text">6.6 对比验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#forkjoinpool%E7%89%88%E6%9C%AC-%E4%B8%8D%E4%BC%9A%E6%AD%BB%E9%94%81"><span class="toc-number">5.7.6.1.</span> <span class="toc-text">ForkJoinPool版本（不会死锁）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">5.7.6.2.</span> <span class="toc-text">执行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-7-%E8%AE%BE%E8%AE%A1%E5%90%AF%E7%A4%BA"><span class="toc-number">5.7.7.</span> <span class="toc-text">6.7 设计启示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E7%BB%93%E8%AE%BA%EF%BC%9A%E8%AE%BE%E8%AE%A1%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">5.8.</span> <span class="toc-text">7. 结论：设计的本质</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">异步编程的进化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BC%94%E8%BF%9B%E6%9C%AC%E8%B4%A8"><span class="toc-number">6.1.</span> <span class="toc-text">演进本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E8%B0%83%E7%94%A8%E6%97%B6%E5%BA%8F"><span class="toc-number">6.2.</span> <span class="toc-text">传统调用时序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-5-future"><span class="toc-number">6.2.1.</span> <span class="toc-text">Java 5 Future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#guava-listenablefuture"><span class="toc-number">6.2.2.</span> <span class="toc-text">Guava ListenableFuture</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#completablefuture"><span class="toc-number">6.2.3.</span> <span class="toc-text">CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%A0%91"><span class="toc-number">6.2.3.1.</span> <span class="toc-text">执行树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83-api"><span class="toc-number">6.2.3.2.</span> <span class="toc-text">核心 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.3.3.</span> <span class="toc-text">使用原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%80%EF%BC%9A%E5%BC%82%E6%AD%A5%E5%9B%9E%E8%B0%83%E8%A6%81%E4%BC%A0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">6.2.3.3.1.</span> <span class="toc-text">原则一：异步回调要传线程池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%BA%8C%EF%BC%9Acompletablefuture-%E4%B8%AD%E4%B8%8D%E8%A6%81%E5%90%9E%E5%BC%82%E5%B8%B8"><span class="toc-number">6.2.3.3.2.</span> <span class="toc-text">原则二：CompletableFuture 中不要吞异常</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%89%EF%BC%9A%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%97%B6-%E6%B3%A8%E6%84%8F%E9%A5%B1%E5%92%8C%E7%AD%96%E7%95%A5"><span class="toc-number">6.2.3.3.3.</span> <span class="toc-text">原则三：自定义线程池时，注意饱和策略</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E5%9B%9B%EF%BC%9A%E6%AD%A3%E7%A1%AE%E8%BF%9B%E8%A1%8C%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">6.2.3.3.4.</span> <span class="toc-text">原则四：正确进行异常处理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%BA%94%EF%BC%9A%E5%90%88%E7%90%86%E8%AE%BE%E7%BD%AE%E8%B6%85%E6%97%B6"><span class="toc-number">6.2.3.3.5.</span> <span class="toc-text">原则五：合理设置超时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#completablefuture-allof-%E7%9A%84%E8%B6%85%E6%97%B6%E6%8E%A7%E5%88%B6"><span class="toc-number">6.2.3.3.6.</span> <span class="toc-text">CompletableFuture.allOf 的超时控制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#completablefuture-ortimeout-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="toc-number">6.2.3.3.7.</span> <span class="toc-text">CompletableFuture.orTimeout 底层实现深入分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E5%85%AD%EF%BC%9A%E9%81%BF%E5%85%8D%E5%9C%A8%E5%9B%9E%E8%B0%83%E4%B8%AD%E9%98%BB%E5%A1%9E"><span class="toc-number">6.2.3.3.8.</span> <span class="toc-text">原则六：避免在回调中阻塞</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%88%99"><span class="toc-number">6.2.3.4.</span> <span class="toc-text">完成保证原则</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%AE%8C%E6%88%90%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%88%99%EF%BC%9F"><span class="toc-number">6.2.3.4.1.</span> <span class="toc-text">为什么需要完成保证原则？</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%88%90%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%88%99%E7%9A%84%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.2.3.4.2.</span> <span class="toc-text">完成保证原则的核心模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.2.3.4.3.</span> <span class="toc-text">完整示例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E4%BC%A0%E7%BB%9F%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%95%88%E7%8E%87%E6%94%B9%E8%BF%9B"><span class="toc-number">6.2.3.5.</span> <span class="toc-text">对传统的线程池的效率改进</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rxjava"><span class="toc-number">6.3.</span> <span class="toc-text">RxJava</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reactor"><span class="toc-number">6.4.</span> <span class="toc-text">Reactor</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">虚拟线程：Java 并发模型的未来</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">7.1.</span> <span class="toc-text">为什么需要虚拟线程？</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9B%B0%E5%A2%83"><span class="toc-number">7.1.1.</span> <span class="toc-text">传统线程模型的困境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">7.1.2.</span> <span class="toc-text">虚拟线程的解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B-vs-%E5%B9%B3%E5%8F%B0%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.2.</span> <span class="toc-text">虚拟线程 vs 平台线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%B7%AE%E5%BC%82%E5%AF%B9%E6%AF%94"><span class="toc-number">7.2.1.</span> <span class="toc-text">核心差异对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%AF%B9%E6%AF%94"><span class="toc-number">7.2.2.</span> <span class="toc-text">代码对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">虚拟线程的工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%BD%BD%E4%B8%8E%E5%8D%B8%E8%BD%BD%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.1.</span> <span class="toc-text">挂载与卸载机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%EF%BC%9A%E4%B8%8E-go-gpm-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">7.3.2.</span> <span class="toc-text">虚拟线程调度模型：与 Go GPM 的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84-continuation-%E6%9C%BA%E5%88%B6%EF%BC%9Aunmount-mount-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">7.3.3.</span> <span class="toc-text">虚拟线程的 Continuation 机制：unmount&#x2F;mount 的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%A6%82%E5%BF%B5"><span class="toc-number">7.3.4.</span> <span class="toc-text">关键概念</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8E%9F%E5%88%99"><span class="toc-number">7.4.</span> <span class="toc-text">虚拟线程的使用原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%80%EF%BC%9A%E4%B8%8D%E8%A6%81%E6%B1%A0%E5%8C%96%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.4.1.</span> <span class="toc-text">原则一：不要池化虚拟线程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%BA%8C%EF%BC%9A%E9%81%BF%E5%85%8D%E5%9C%A8%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%89%A7%E8%A1%8C-cpu-%E5%AF%86%E9%9B%86%E5%9E%8B%E4%BB%BB%E5%8A%A1"><span class="toc-number">7.4.2.</span> <span class="toc-text">原则二：避免在虚拟线程中执行 CPU 密集型任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E4%B8%89%EF%BC%9A%E6%B3%A8%E6%84%8F-synchronized-%E5%92%8C-native-%E6%96%B9%E6%B3%95%E7%9A%84-pinning-%E9%97%AE%E9%A2%98"><span class="toc-number">7.4.3.</span> <span class="toc-text">原则三：注意 synchronized 和 native 方法的 Pinning 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%88%99%E5%9B%9B%EF%BC%9A%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8-threadlocal"><span class="toc-number">7.4.4.</span> <span class="toc-text">原则四：正确使用 ThreadLocal</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadlocal-%E5%9C%A8%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%B8%BA%E4%BD%95%E4%BB%8D%E7%84%B6%E6%9C%89%E6%95%88%EF%BC%9F"><span class="toc-number">7.4.5.</span> <span class="toc-text">ThreadLocal 在虚拟线程中为何仍然有效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scopedvalue-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%98%E4%BA%8E-threadlocal%EF%BC%9F"><span class="toc-number">7.4.6.</span> <span class="toc-text">ScopedValue 为什么优于 ThreadLocal？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">7.5.</span> <span class="toc-text">虚拟线程与传统线程池的选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">7.5.1.</span> <span class="toc-text">决策流程图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%BA%E6%99%AF%E5%AF%B9%E6%AF%94"><span class="toc-number">7.5.2.</span> <span class="toc-text">场景对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.5.3.</span> <span class="toc-text">迁移示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%80%A7%E8%83%BD%E7%89%B9%E5%BE%81"><span class="toc-number">7.6.</span> <span class="toc-text">虚拟线程的性能特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%9E%E5%90%90%E9%87%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">7.6.1.</span> <span class="toc-text">吞吐量对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%AF%B9%E6%AF%94"><span class="toc-number">7.6.2.</span> <span class="toc-text">内存占用对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">7.7.</span> <span class="toc-text">总结：线程池技术的演进</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B%E6%80%BB%E7%BB%93"><span class="toc-number">7.7.1.</span> <span class="toc-text">技术选型总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91-structured-concurrency"><span class="toc-number">7.8.</span> <span class="toc-text">结构化并发 (Structured Concurrency)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E6%A1%86%E6%9E%B6%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.9.</span> <span class="toc-text">Spring框架中的线程池实现与最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-spring%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%93%E7%B3%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">7.9.1.</span> <span class="toc-text">1. Spring线程池体系概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">7.9.2.</span> <span class="toc-text">2. 核心组件详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-taskexecutor%E6%8E%A5%E5%8F%A3%E8%AE%BE%E8%AE%A1"><span class="toc-number">7.9.2.1.</span> <span class="toc-text">2.1 TaskExecutor接口设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-threadpooltaskexecutor%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.9.2.2.</span> <span class="toc-text">2.2 ThreadPoolTaskExecutor实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%B8%8E%E5%8E%9F%E7%94%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%98%A0%E5%B0%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.9.3.</span> <span class="toc-text">3. 与原生线程池的映射关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-spring-scheduled-%E7%9A%84%E9%BB%98%E8%AE%A4%E9%99%B7%E9%98%B1%EF%BC%9A%E5%8D%95%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-number">7.9.4.</span> <span class="toc-text">4. Spring @Scheduled 的默认陷阱：单线程调度器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E9%97%AE%E9%A2%98%E6%8F%8F%E8%BF%B0"><span class="toc-number">7.9.4.1.</span> <span class="toc-text">4.1 问题描述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E9%97%AE%E9%A2%98%E5%BD%B1%E5%93%8D"><span class="toc-number">7.9.4.2.</span> <span class="toc-text">4.2 问题影响</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95%EF%BC%9A%E6%98%BE%E5%BC%8F%E9%85%8D%E7%BD%AE"><span class="toc-number">7.9.4.3.</span> <span class="toc-text">4.3 正确做法：显式配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E5%85%B3%E9%94%AE%E8%A6%81%E7%82%B9"><span class="toc-number">7.9.4.4.</span> <span class="toc-text">4.4 关键要点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-spring-%E7%9A%84-fixedrate-fixeddelay-%E4%B8%8E-juc-%E7%9A%84%E5%AF%B9%E5%BA%94%E5%85%B3%E7%B3%BB"><span class="toc-number">7.9.4.5.</span> <span class="toc-text">4.5 Spring 的 fixedRate&#x2F;fixedDelay 与 JUC 的对应关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-%E9%81%BF%E5%85%8D-%E4%BB%BB%E5%8A%A1%E9%87%8D%E5%85%A5-%E7%9A%84%E6%89%8B%E6%AE%B5"><span class="toc-number">7.9.4.6.</span> <span class="toc-text">4.6 避免&quot;任务重入&quot;的手段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.9.5.</span> <span class="toc-text">5. 生产环境最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%8F%82%E6%95%B0%E8%B0%83%E4%BC%98%E6%8C%87%E5%8D%97"><span class="toc-number">7.9.5.1.</span> <span class="toc-text">5.1 参数调优指南</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A1%86%E6%9E%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E9%9B%86%E6%88%90"><span class="toc-number">7.9.6.</span> <span class="toc-text">5. 与其他框架组件的集成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E4%B8%8E-async%E6%B3%A8%E8%A7%A3%E9%9B%86%E6%88%90"><span class="toc-number">7.9.6.1.</span> <span class="toc-text">5.1 与@Async注解集成</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>