<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>无锁队列 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。">
<meta property="og:type" content="article">
<meta property="og:title" content="无锁队列">
<meta property="og:url" content="https://magicliang.github.io/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png">
<meta property="article:published_time" content="2026-01-18T14:50:42.000Z">
<meta property="article:modified_time" content="2026-01-24T07:32:08.915Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "无锁队列",
  "url": "https://magicliang.github.io/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/",
  "image": "https://magicliang.github.io/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png",
  "datePublished": "2026-01-18T14:50:42.000Z",
  "dateModified": "2026-01-24T07:32:08.915Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '无锁队列',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">无锁队列</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">无锁队列</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-18T14:50:42.000Z" title="Created 2026-01-18 22:50:42">2026-01-18</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T07:32:08.915Z" title="Updated 2026-01-24 15:32:08">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">3.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>13mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>Java</h1>
<h2 id="一读一写-spsc-：memory-barrier-volatile">一读一写（SPSC）：Memory Barrier + Volatile</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Single-Producer Single-Consumer (SPSC) 无锁环形队列。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;原理说明：</span><br><span class="hljs-comment"> * - 仅允许一个线程调用 &#123;<span class="hljs-doctag">@code</span> offer()&#125;，一个线程调用 &#123;<span class="hljs-doctag">@code</span> poll()&#125;。</span><br><span class="hljs-comment"> * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。</span><br><span class="hljs-comment"> * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系：</span><br><span class="hljs-comment"> *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。</span><br><span class="hljs-comment"> * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad），</span><br><span class="hljs-comment"> *   虽然比 Disruptor 的 putOrdered 稍重，但在 SPSC 场景下完全安全且简洁。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;性能提示：</span><br><span class="hljs-comment"> * - 更极致的实现会用 &#123;<span class="hljs-doctag">@code</span> AtomicLong.lazySet()&#125;（即 store-store barrier）</span><br><span class="hljs-comment"> *   替代 volatile 写，避免 StoreLoad 开销。但本例为清晰起见使用 volatile。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SPSCQueue</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] buffer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacityMask; <span class="hljs-comment">// 必须是 2^n - 1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// producer writes here</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">// consumer reads from here</span><br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SPSCQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (c &lt; capacity) c &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.buffer = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[c];<br>        <span class="hljs-built_in">this</span>.capacityMask = c - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单生产者入队。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功返回 true，队列满则返回 false。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">currentTail</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextTail</span> <span class="hljs-operator">=</span> (currentTail + <span class="hljs-number">1</span>) &amp; capacityMask;<br>        <span class="hljs-keyword">if</span> (nextTail == head) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// full</span><br><br>        buffer[currentTail] = e;<br>        <span class="hljs-comment">// volatile 写 tail 建立 happens-before：buffer 写入 → tail 更新</span><br>        tail = nextTail;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单消费者出队。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 队首元素，若空则返回 null。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == tail) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// empty</span><br>        <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> buffer[head];<br>        buffer[head] = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>        head = (head + <span class="hljs-number">1</span>) &amp; capacityMask;<br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="一写多读-spmc-：single-writer-principle-volatile-publish">一写多读（SPMC）：Single-Writer Principle + Volatile Publish</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Single-Producer Multiple-Consumer (SPMC) 序列化环形缓冲区。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;原理说明：</span><br><span class="hljs-comment"> * - 严格遵循 &quot;single-writer principle&quot;：仅一个线程可调用 &#123;<span class="hljs-doctag">@code</span> publish()&#125;。</span><br><span class="hljs-comment"> * - 多个消费者通过读取 &#123;<span class="hljs-doctag">@code</span> cursor&#125; 判断数据是否就绪。</span><br><span class="hljs-comment"> * - &#123;<span class="hljs-doctag">@code</span> cursor&#125; 是 volatile long，作为“发布门”（publication fence）：</span><br><span class="hljs-comment"> *   写者先写入 buffer[slot]，再 volatile 写 cursor → 所有读者 guaranteed see the value.</span><br><span class="hljs-comment"> * - 这正是 LMAX Disruptor RingBuffer 的核心思想：避免 CAS，靠单写者 + volatile 发布。</span><br><span class="hljs-comment"> * - 读者无需同步，只需轮询或等待 cursor &gt;= targetSequence。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;注意：</span><br><span class="hljs-comment"> * - 不提供阻塞或通知机制，仅为底层数据结构。</span><br><span class="hljs-comment"> * - sequence 必须单调递增，由外部协调。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SPMCSequenceRingBuffer</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] buffer;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> mask;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span>; <span class="hljs-comment">// last published sequence</span><br><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SPMCSequenceRingBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (c &lt; capacity) c &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.buffer = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[c];<br>        <span class="hljs-built_in">this</span>.mask = c - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取下一个可用序列号（仅建议生产者调用）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cursor + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发布指定序列的数据（仅单写者调用！）。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sequence 序列号，必须等于 &#123;<span class="hljs-doctag">@code</span> cursor + 1&#125;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 数据</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publish</span><span class="hljs-params">(<span class="hljs-type">long</span> sequence, E value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slot</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (sequence &amp; mask);<br>        buffer[slot] = value;<br>        <span class="hljs-comment">// volatile write to cursor acts as a memory barrier:</span><br>        <span class="hljs-comment">// ensures all prior writes (to buffer[slot]) are visible to readers</span><br>        cursor = sequence;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 多消费者可安全读取已发布的数据。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 若 sequence 尚未发布，返回 null；否则返回数据。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> sequence)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sequence &gt; cursor) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// not published yet</span><br>        <span class="hljs-keyword">return</span> buffer[(<span class="hljs-type">int</span>) (sequence &amp; mask)];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="disruptor-的实现">disruptor 的实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 简化版 Disruptor RingBuffer 核心原理演示（仅支持单生产者）。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;b&gt;Disruptor 为何能达到超高吞吐（100M+ ops/sec）？&lt;/b&gt;</span><br><span class="hljs-comment"> * 其性能并非来自魔法，而是通过精心设计，将并发问题转化为&lt;strong&gt;顺序执行 + 可预测内存访问&lt;/strong&gt;的问题。</span><br><span class="hljs-comment"> * 核心依赖三大工程原则：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;h3&gt;1. 【单写者原则】(Single-Writer Principle)&lt;/h3&gt;</span><br><span class="hljs-comment"> * - 在任意时刻，&lt;b&gt;只有一个线程&lt;/b&gt;被允许修改关键状态（如 sequence）。</span><br><span class="hljs-comment"> * - 这彻底消除了多写者竞争，无需 CAS、锁或原子操作，避免了：</span><br><span class="hljs-comment"> *   • CAS 失败重试的开销（在高竞争下指数级恶化）</span><br><span class="hljs-comment"> *   • 内存总线争用（多个核心同时尝试写同一缓存行）</span><br><span class="hljs-comment"> * - 多消费者通过各自维护独立的消费序列号（consumer cursor）进行读取，</span><br><span class="hljs-comment"> *   彼此完全解耦，无任何同步需求。</span><br><span class="hljs-comment"> * - 此原则是 Disruptor 性能基石：它把“并发写”问题降维为“并发读 + 单写”。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;h3&gt;2. 【预分配对象 + 缓存行填充】(Pre-allocation + Cache Line Padding)&lt;/h3&gt;</span><br><span class="hljs-comment"> * - &lt;b&gt;预分配&lt;/b&gt;：RingBuffer 在构造时一次性分配所有槽位（Object[]），运行时不再创建/回收对象，</span><br><span class="hljs-comment"> *   极大降低 GC 压力（尤其对 latency-sensitive 系统至关重要）。</span><br><span class="hljs-comment"> * - &lt;b&gt;缓存行填充&lt;/b&gt;（Cache Line Padding）：防止 &lt;i&gt;伪共享&lt;/i&gt;（False Sharing）——这是高性能并发中常被忽视的“隐形杀手”。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   &lt;p&gt;&lt;b&gt;什么是伪共享（False Sharing）？&lt;/b&gt;</span><br><span class="hljs-comment"> *   - 现代 CPU 并不以字节为单位加载内存，而是以 &lt;b&gt;缓存行&lt;/b&gt;（Cache Line）为单位，通常为 &lt;b&gt;64 字节&lt;/b&gt;。</span><br><span class="hljs-comment"> *   - 当多个 CPU 核心分别访问 &lt;b&gt;不同变量&lt;/b&gt;，但这些变量物理上位于 &lt;b&gt;同一个缓存行&lt;/b&gt; 内时，</span><br><span class="hljs-comment"> *     只要任一核心修改了该缓存行中的任意一个变量，整个缓存行就会在其他核心的 L1/L2 缓存中标记为 &lt;i&gt;Invalid&lt;/i&gt;（失效）。</span><br><span class="hljs-comment"> *   - 其他核心若再读取自己关心的变量，就必须通过缓存一致性协议（如 MESI）从主存或其他核心重新加载整行。</span><br><span class="hljs-comment"> *   - 这种因“逻辑无关但物理相邻”导致的缓存同步开销，称为 &lt;b&gt;伪共享&lt;/b&gt;。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   &lt;p&gt;&lt;b&gt;为何在 RingBuffer 中特别危险？&lt;/b&gt;</span><br><span class="hljs-comment"> *   - 生产者高频写 &#123;<span class="hljs-doctag">@code</span> cursor.value&#125;（sequence++）。</span><br><span class="hljs-comment"> *   - 消费者高频读 &#123;<span class="hljs-doctag">@code</span> cursor.value&#125; 判断数据是否就绪。</span><br><span class="hljs-comment"> *   - 如果 &#123;<span class="hljs-doctag">@code</span> cursor.value&#125; 与其它 volatile 字段（如另一个消费者的进度、状态标志等）落在同一缓存行，</span><br><span class="hljs-comment"> *     则每次生产者更新都会导致所有消费者缓存失效 → 引发大量不必要的缓存同步流量 → 吞吐骤降。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *   &lt;p&gt;&lt;b&gt;如何解决？&lt;/b&gt;</span><br><span class="hljs-comment"> *   - 让高频读写的独立状态字段 &lt;b&gt;独占一个完整的缓存行&lt;/b&gt;。</span><br><span class="hljs-comment"> *   - 方法：在目标字段前后填充无用的 long 字段（每个 long 8 字节），</span><br><span class="hljs-comment"> *     使得目标字段前后至少有 64 字节的“隔离带”。</span><br><span class="hljs-comment"> *   - 本例中：7 个前填充 + 1 个 value + 7 个后填充 = 15 × 8 = 120 字节 &gt; 64 字节，</span><br><span class="hljs-comment"> *     确保无论 JVM 如何布局对象，&#123;<span class="hljs-doctag">@code</span> value&#125; 都不会与相邻字段共享缓存行。</span><br><span class="hljs-comment"> *   - 注意：Java 9+ 可用 &#123;<span class="hljs-doctag">@code</span> <span class="hljs-doctag">@sun</span>.misc.Contended&#125; 自动填充，但 Java 8 必须手动实现。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;h3&gt;3. 【精确内存屏障控制】(Precise Memory Barrier Control)&lt;/h3&gt;</span><br><span class="hljs-comment"> * - Disruptor 不依赖粗粒度的 synchronized 或 heavyweight volatile，</span><br><span class="hljs-comment"> *   而是使用 &lt;b&gt;最小必要屏障&lt;/b&gt; 实现“发布语义”（Publication Guarantee）：</span><br><span class="hljs-comment"> *     • 先写入数据到 buffer[slot]</span><br><span class="hljs-comment"> *     • 再更新 sequence（作为“发布信号”）</span><br><span class="hljs-comment"> * - 在 Java 内存模型中，&#123;<span class="hljs-doctag">@code</span> volatile&#125; 写提供 &lt;b&gt;StoreLoad barrier&lt;/b&gt;，</span><br><span class="hljs-comment"> *   保证所有之前的普通写（buffer[slot] = value）对后续读取该 volatile 的线程可见。</span><br><span class="hljs-comment"> * - 工业级 Disruptor 实际使用 &#123;<span class="hljs-doctag">@code</span> Unsafe.putOrderedLong()&#125;（即 store-store barrier），</span><br><span class="hljs-comment"> *   它比 volatile 更轻量（不包含 StoreLoad），但 Java 8 无法通过标准 API 使用 VarHandle，</span><br><span class="hljs-comment"> *   故此处用 volatile 保证正确性与可移植性。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;&lt;b&gt;对比传统队列（如 ArrayBlockingQueue / ConcurrentLinkedQueue）：&lt;/b&gt;</span><br><span class="hljs-comment"> * - ✅ 无锁（lock-free）且无 CAS（单生产者场景）</span><br><span class="hljs-comment"> * - ✅ 无指针追逐（pointer chasing）：数组连续内存 vs 链表分散节点</span><br><span class="hljs-comment"> * - ✅ 无 GC 压力：预分配槽位，避免运行时 new/delete</span><br><span class="hljs-comment"> * - ✅ 无伪共享：关键状态字段缓存行隔离</span><br><span class="hljs-comment"> * - ✅ CPU 分支预测友好：循环逻辑高度可预测</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;正是这些看似微小的设计叠加，使 Disruptor 在 LMAX 交易所实测达到 &lt;b&gt;每秒数千万事件处理&lt;/b&gt; 的吞吐。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DisruptorLikeRingBuffer</span>&lt;E&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带缓存行填充的序列计数器，专为防止伪共享设计。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;布局说明（按 64 字节缓存行对齐）：</span><br><span class="hljs-comment">     * - p1~p7: 前填充（56 字节），确保 &#123;<span class="hljs-doctag">@code</span> value&#125; 不与前一个对象字段共享缓存行。</span><br><span class="hljs-comment">     * - value: 核心字段（8 字节），volatile 保证跨线程可见性。</span><br><span class="hljs-comment">     * - p8~p14: 后填充（56 字节），确保 &#123;<span class="hljs-doctag">@code</span> value&#125; 不与后续字段（如对象头、其他实例变量）共享缓存行。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;总占用 120 字节，远超 64 字节缓存行，提供强隔离保障。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaddedSequence</span> &#123;<br>        <span class="hljs-type">long</span> p1, p2, p3, p4, p5, p6, p7;      <span class="hljs-comment">// 前填充：56 字节</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1L</span>;             <span class="hljs-comment">// 核心序列号：8 字节</span><br>        <span class="hljs-type">long</span> p8, p9, p10, p11, p12, p13, p14; <span class="hljs-comment">// 后填充：56 字节</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> E[] buffer;                 <span class="hljs-comment">// 预分配的环形缓冲区</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> mask;                   <span class="hljs-comment">// 容量掩码（capacity - 1），用于快速取模</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">PaddedSequence</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PaddedSequence</span>(); <span class="hljs-comment">// 生产者发布的最新序列号</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数：初始化 RingBuffer。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> capacity 队列容量（会被向上对齐到 2 的幂，以支持位运算取模）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DisruptorLikeRingBuffer</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-comment">// 强制容量为 2 的幂，以便用 (sequence &amp; mask) 替代 % 运算（更快）</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (c &lt; capacity) c &lt;&lt;= <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">this</span>.buffer = (E[]) <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[c];<br>        <span class="hljs-built_in">this</span>.mask = c - <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单生产者申请下一个可用序列号。</span><br><span class="hljs-comment">     * &lt;p&gt;由于仅一个线程调用此方法，直接返回 &#123;<span class="hljs-doctag">@code</span> cursor + 1&#125;，无任何同步开销。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cursor.value + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发布数据到指定序列位置。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;&lt;b&gt;内存可见性保证：&lt;/b&gt;</span><br><span class="hljs-comment">     * - 步骤 1: &#123;<span class="hljs-doctag">@code</span> buffer[slot] = value&#125; 是普通写（non-volatile store）</span><br><span class="hljs-comment">     * - 步骤 2: &#123;<span class="hljs-doctag">@code</span> cursor.value = sequence&#125; 是 volatile 写</span><br><span class="hljs-comment">     * - 根据 Java 内存模型，volatile 写建立 happens-before 关系：</span><br><span class="hljs-comment">     *   所有在 volatile 写之前的动作（包括步骤 1），对后续读取该 volatile 的线程可见。</span><br><span class="hljs-comment">     * - 因此，任何消费者读到 &#123;<span class="hljs-doctag">@code</span> cursor &gt;= sequence&#125; 时，必定能看到 &#123;<span class="hljs-doctag">@code</span> buffer[slot]&#125; 的值。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;p&gt;工业级优化：Disruptor 使用 &#123;<span class="hljs-doctag">@code</span> Unsafe.putOrderedLong()&#125; 替代 volatile 写，</span><br><span class="hljs-comment">     * 仅插入 StoreStore barrier（禁止重排序，但不强制刷新缓存），性能更高。</span><br><span class="hljs-comment">     * 但 Java 8 无标准 API 支持，故此处用 volatile 保证正确性。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">publish</span><span class="hljs-params">(<span class="hljs-type">long</span> sequence, E value)</span> &#123;<br>        <span class="hljs-keyword">if</span> (value == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">slot</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (sequence &amp; mask);  <span class="hljs-comment">// 快速取模</span><br>        buffer[slot] = value;<br>        <span class="hljs-comment">// 发布屏障：确保数据写入先于 sequence 更新对消费者可见</span><br>        cursor.value = sequence;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消费者读取指定序列的数据。</span><br><span class="hljs-comment">     * &lt;p&gt;多消费者可并行调用，只要各自维护自己的消费进度（如 lastSeenSequence），</span><br><span class="hljs-comment">     * 互不干扰。此方法本身无同步，依赖外部协调消费逻辑。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> sequence 要读取的序列号</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 若数据已发布则返回元素，否则返回 null</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> sequence)</span> &#123;<br>        <span class="hljs-keyword">if</span> (sequence &gt; cursor.value) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// 尚未发布</span><br>        <span class="hljs-keyword">return</span> buffer[(<span class="hljs-type">int</span>) (sequence &amp; mask)];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前已发布的最大序列号。</span><br><span class="hljs-comment">     * &lt;p&gt;消费者通常轮询此值，判断是否有新数据可处理。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getCursor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> cursor.value;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="多写多读-mpmc-：cas-lock-free-linked-queue">多写多读（MPMC）：CAS + Lock-Free Linked Queue</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReference;<br><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Multi-Producer Multi-Consumer (MPMC) 无锁链表队列。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;原理说明：</span><br><span class="hljs-comment"> * - 支持任意数量的生产者和消费者并发操作。</span><br><span class="hljs-comment"> * - 核心同步机制：CAS（Compare-And-Swap）原子更新指针。</span><br><span class="hljs-comment"> * - 基于经典的 Michael &amp; Scott 无锁队列算法：</span><br><span class="hljs-comment"> *   - 入队：尝试 CAS 更新 tail.next；失败则重试或帮助推进 tail。</span><br><span class="hljs-comment"> *   - 出队：CAS 更新 head 指向 next 节点，实现逻辑删除。</span><br><span class="hljs-comment"> * - 使用 &#123;<span class="hljs-doctag">@code</span> AtomicReferenceFieldUpdater&#125; 对 Node.next 做 CAS，</span><br><span class="hljs-comment"> *   避免每个 Node 持有 AtomicReference（节省内存）。</span><br><span class="hljs-comment"> * - 虽然无锁（lock-free），但高竞争下可能重试多次，吞吐低于 SPSC/SPMC。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;设计权衡：</span><br><span class="hljs-comment"> * - 无容量限制（unbounded），可能 OOM。</span><br><span class="hljs-comment"> * - 不处理 ABA 问题（因引用语义，Java 中对象地址唯一，ABA 风险低）。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MPMCLinkedListQueue</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        <span class="hljs-keyword">volatile</span> E item;<br>        <span class="hljs-keyword">volatile</span> Node&lt;E&gt; next;<br><br>        Node(E item) &#123; <span class="hljs-built_in">this</span>.item = item; &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;Node&lt;E&gt;&gt; head;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicReference&lt;Node&lt;E&gt;&gt; tail;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MPMCLinkedListQueue</span><span class="hljs-params">()</span> &#123;<br>        Node&lt;E&gt; dummy = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(<span class="hljs-literal">null</span>);<br>        head = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(dummy);<br>        tail = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(dummy);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicReferenceFieldUpdater&lt;Node, Node&gt; NEXT_UPDATER =<br>        AtomicReferenceFieldUpdater.newUpdater(Node.class, Node.class, <span class="hljs-string">&quot;next&quot;</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 多生产者入队。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">offer</span><span class="hljs-params">(E e)</span> &#123;<br>        <span class="hljs-keyword">if</span> (e == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        Node&lt;E&gt; newNode = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(e);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            Node&lt;E&gt; currentTail = tail.get();<br>            Node&lt;E&gt; next = currentTail.next;<br><br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-comment">// Tail is stale; help advance it</span><br>                tail.compareAndSet(currentTail, next);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// Attempt to link new node</span><br>                <span class="hljs-keyword">if</span> (NEXT_UPDATER.compareAndSet(currentTail, <span class="hljs-literal">null</span>, newNode)) &#123;<br>                    <span class="hljs-comment">// Success: now try to move tail forward (optional optimization)</span><br>                    tail.compareAndSet(currentTail, newNode);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>                <span class="hljs-comment">// Lost race to another producer; retry</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 多消费者出队。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">poll</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            Node&lt;E&gt; currentHead = head.get();<br>            Node&lt;E&gt; first = currentHead.next;<br><br>            <span class="hljs-keyword">if</span> (first == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// empty</span><br><br>            <span class="hljs-type">E</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> first.item;<br>            <span class="hljs-keyword">if</span> (item != <span class="hljs-literal">null</span> &amp;&amp; NEXT_UPDATER.compareAndSet(currentHead, first, <span class="hljs-literal">null</span>)) &#123;<br>                <span class="hljs-comment">// Successfully unlinked; move head forward</span><br>                head.set(first);<br>                first.item = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                <span class="hljs-keyword">return</span> item;<br>            &#125;<br>            <span class="hljs-comment">// Help other consumers by advancing head, or retry</span><br>            head.compareAndSet(currentHead, first);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/">https://magicliang.github.io/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="Java 并发编程笔记"><img class="cover" src="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-12</div><div class="info-item-2">Java 并发编程笔记</div></div><div class="info-2"><div class="info-item-1"> juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。高层语言的并发模型都要基于底层系统对硬件抽象和并发的设计来设计和实现，不能超出操作系统允许的范围。所谓的高级抽象总体上是简化对 OS 底层机制的复杂调用。 并发与异步 本文聚焦并发（Concurrency），即多任务在同一时间段内的交替或并行执行，核心问题是资源共享、线程同步与协作。 **异步（Asynchronous）**是另一维度：调用方发起操作后不等结果返回即继续执行，通过回调、Future或事件机制获取结果。异步可通过单线程事件循环实现，也可依托多线程并发实现。 二者关系：并发关注&quot;多任务如何执行与协调&quot;，异步关注&quot;调用是否阻塞等待&quot;。并发编程常涉及异步，但本文不展开异步编程模式（如响应式流、协程），相关内容请参阅《Java 线程池笔记》。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本...</div></div></div></a><a class="pagination-related" href="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/" title="Java 线程池笔记"><img class="cover" src="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-24</div><div class="info-item-2">Java 线程池笔记</div></div><div class="info-2"><div class="info-item-1">从执行器到线程池（from executor interface to thread pool implementation）  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia “池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。 在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括： 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection Pool...</div></div></div></a><a class="pagination-related" href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-19</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1"> 版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374）。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级。但在深入讨论线程安全的分类之前，我们需要先理解 Java 内存模型——它是理解线程安全问题的理论基础。 Java 内存模型基础 Java 内存模型（Java Memory Model，JMM）是 Java 语言规范的一部分，定义了多线程程序中共享变量的访问规则。理解 JMM 是理解线程安全问题的基础。 为什么需要内存模型？ 现代计算机系统中，CPU 与主内存之间存在巨大的速度差异。为了弥补这一差距，硬件层面引入了多级缓存（L1、L2、L3 Cache）。这带来了一个问...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-176.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-4.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">卡表和 RSet 问题定义：为什么需要跨区域引用记录 JVM 垃圾收集器的核心工作之一是确定 live set——哪些对象仍然存活、不可回收。确定 live set 的标准做法是从 GC Roots（栈帧中的局部变量、静态字段等）出发，沿引用链遍历所有可达对象。 问题在于：当堆被划分为多个区域（代、Region）并且只回收其中一部分时，如何高效地找到从&quot;不回收区域&quot;指向&quot;回收区域&quot;的引用？ 以 Young GC 为例：只回收新生代，但老年代中可能持有指向新生代对象的引用。如果不处理这些跨代引用，就会错误地回收仍被老年代引用的新生代对象。最朴素的做法是扫描整个老年代来找出这些引用——但老年代通常远大于新生代，这样做的代价过高，违背了分代收集&quot;只回收一部分堆&quot;的初衷。 卡表（Card Table）和 RSet（Remembered Set）正是为解决这个问题而设计的辅助数据结构。二者的关系并非互相替代，而是层次不同、协作互补：卡表是底层的脏标记机制，RSet 是建立在卡表之上的更高层索引结构。 核心概念速览 在深入细节之前，...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-166.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E8%AF%BB%E4%B8%80%E5%86%99-spsc-%EF%BC%9Amemory-barrier-volatile"><span class="toc-number">1.1.</span> <span class="toc-text">一读一写（SPSC）：Memory Barrier + Volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%86%99%E5%A4%9A%E8%AF%BB-spmc-%EF%BC%9Asingle-writer-principle-volatile-publish"><span class="toc-number">1.2.</span> <span class="toc-text">一写多读（SPMC）：Single-Writer Principle + Volatile Publish</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#disruptor-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">disruptor 的实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%86%99%E5%A4%9A%E8%AF%BB-mpmc-%EF%BC%9Acas-lock-free-linked-queue"><span class="toc-number">1.3.</span> <span class="toc-text">多写多读（MPMC）：CAS + Lock-Free Linked Queue</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>