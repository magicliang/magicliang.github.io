<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>线程安全与锁优化 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374）。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何">
<meta property="og:type" content="article">
<meta property="og:title" content="线程安全与锁优化">
<meta property="og:url" content="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374）。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg">
<meta property="article:published_time" content="2026-01-19T11:18:44.000Z">
<meta property="article:modified_time" content="2026-02-12T12:01:40.576Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "线程安全与锁优化",
  "url": "https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/",
  "image": "https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg",
  "datePublished": "2026-01-19T11:18:44.000Z",
  "dateModified": "2026-02-12T12:01:40.576Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '线程安全与锁优化',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">线程安全与锁优化</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">线程安全与锁优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-19T11:18:44.000Z" title="Created 2026-01-19 19:18:44">2026-01-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-12T12:01:40.576Z" title="Updated 2026-02-12 20:01:40">2026-02-12</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">108.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>432mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>版本说明</strong>：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374）。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。</p>
</blockquote>
<h1>线程安全</h1>
<h2 id="什么是线程安全">什么是线程安全</h2>
<p>“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。”</p>
<p>相对的线程安全，可以分成五个等级。但在深入讨论线程安全的分类之前，我们需要先理解 Java 内存模型——它是理解线程安全问题的理论基础。</p>
<h2 id="java-内存模型基础">Java 内存模型基础</h2>
<p>Java 内存模型（Java Memory Model，JMM）是 Java 语言规范的一部分，定义了多线程程序中共享变量的访问规则。理解 JMM 是理解线程安全问题的基础。</p>
<h3 id="为什么需要内存模型？">为什么需要内存模型？</h3>
<p>现代计算机系统中，CPU 与主内存之间存在巨大的速度差异。为了弥补这一差距，硬件层面引入了多级缓存（L1、L2、L3 Cache）。这带来了一个问题：<strong>当多个 CPU 核心同时操作同一块内存时，各自缓存中的数据可能不一致</strong>。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;多核 CPU 的缓存架构&quot;
        direction TB
        
        subgraph &quot;CPU 0&quot;
            C0[&quot;Core 0&quot;]
            L1_0[&quot;L1 Cache&quot;]
            L2_0[&quot;L2 Cache&quot;]
            C0 --&gt; L1_0 --&gt; L2_0
        end
        
        subgraph &quot;CPU 1&quot;
            C1[&quot;Core 1&quot;]
            L1_1[&quot;L1 Cache&quot;]
            L2_1[&quot;L2 Cache&quot;]
            C1 --&gt; L1_1 --&gt; L2_1
        end
        
        L3[&quot;L3 Cache（共享）&quot;]
        MEM[&quot;主内存（Main Memory）&quot;]
        
        L2_0 --&gt; L3
        L2_1 --&gt; L3
        L3 --&gt; MEM
        
        style C0 fill:#e1f5ff
        style C1 fill:#e1f5ff
        style L1_0 fill:#c8e6c9
        style L1_1 fill:#c8e6c9
        style L2_0 fill:#fff9c4
        style L2_1 fill:#fff9c4
        style L3 fill:#ffecb3
        style MEM fill:#ffcdd2
    end
    
    note[&quot;问题：Core 0 修改了变量 x，&lt;br/&gt;Core 1 的缓存中可能还是旧值&quot;]
    style note fill:#fff9c4</code></pre>
<p>JMM 的作用就是<strong>屏蔽底层硬件差异，为 Java 程序员提供一套统一的内存访问规则</strong>。</p>
<h3 id="jmm-的抽象模型">JMM 的抽象模型</h3>
<p>JMM 将内存分为两个层次：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;JMM 抽象模型&quot;
        direction TB
        
        subgraph &quot;线程 1&quot;
            T1[&quot;线程 1&quot;]
            WM1[&quot;工作内存&lt;br/&gt;（Working Memory）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;变量 x 的副本&lt;br/&gt;变量 y 的副本&quot;]
        end
        
        subgraph &quot;线程 2&quot;
            T2[&quot;线程 2&quot;]
            WM2[&quot;工作内存&lt;br/&gt;（Working Memory）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;变量 x 的副本&lt;br/&gt;变量 y 的副本&quot;]
        end
        
        MM[&quot;主内存（Main Memory）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;共享变量 x&lt;br/&gt;共享变量 y&quot;]
        
        T1 --&gt; WM1
        T2 --&gt; WM2
        WM1 &lt;--&gt;|&quot;read/load&lt;br/&gt;store/write&quot;| MM
        WM2 &lt;--&gt;|&quot;read/load&lt;br/&gt;store/write&quot;| MM
        
        style T1 fill:#e1f5ff
        style T2 fill:#e1f5ff
        style WM1 fill:#c8e6c9
        style WM2 fill:#c8e6c9
        style MM fill:#ffcdd2
    end</code></pre>
<table>
<thead>
<tr>
<th>概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>主内存（Main Memory）</strong></td>
<td>所有线程共享的内存区域，存储共享变量</td>
</tr>
<tr>
<td><strong>工作内存（Working Memory）</strong></td>
<td>每个线程私有的内存区域，存储该线程使用的共享变量的副本</td>
</tr>
</tbody>
</table>
<p><strong>关键规则</strong>：</p>
<ol>
<li>线程对共享变量的所有操作都必须在工作内存中进行，不能直接读写主内存</li>
<li>不同线程之间无法直接访问对方的工作内存，必须通过主内存传递</li>
</ol>
<h3 id="线程安全的三大特性">线程安全的三大特性</h3>
<p>JMM 围绕三个核心特性来定义线程安全：</p>
<h4 id="1-原子性-atomicity">1. 原子性（Atomicity）</h4>
<p><strong>定义</strong>：一个操作要么全部执行完成，要么完全不执行，不会被其他线程中断。</p>
<p><strong>问题示例</strong>：<code>i++</code> 不是原子操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// i++ 实际上是三个操作：</span><br><span class="hljs-comment">// 1. 读取 i 的值</span><br><span class="hljs-comment">// 2. 将值加 1</span><br><span class="hljs-comment">// 3. 将结果写回 i</span><br><span class="hljs-comment">// 这三个操作之间可能被其他线程中断</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 1
    participant M as 主内存 (i=0)
    participant T2 as 线程 2
    
    T1-&gt;&gt;M: 读取 i=0
    T2-&gt;&gt;M: 读取 i=0
    T1-&gt;&gt;T1: 计算 0+1=1
    T2-&gt;&gt;T2: 计算 0+1=1
    T1-&gt;&gt;M: 写入 i=1
    T2-&gt;&gt;M: 写入 i=1
    
    Note over M: 预期 i=2，实际 i=1&lt;br/&gt;（丢失更新）</code></pre>
<p><strong>保证原子性的方式</strong>：</p>
<ul>
<li><code>synchronized</code> 关键字</li>
<li><code>java.util.concurrent.atomic</code> 包中的原子类</li>
<li><code>Lock</code> 接口的实现类</li>
</ul>
<h4 id="2-可见性-visibility">2. 可见性（Visibility）</h4>
<p><strong>定义</strong>：当一个线程修改了共享变量的值，其他线程能够立即看到这个修改。</p>
<p><strong>问题示例</strong>：没有可见性保证的循环</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 1</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">running</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">while</span> (running) &#123;<br>    <span class="hljs-comment">// 执行任务</span><br>&#125;<br><br><span class="hljs-comment">// 线程 2</span><br>running = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 线程 1 可能永远看不到这个修改！</span><br></code></pre></td></tr></table></figure>
<p><strong>为什么会看不到？</strong></p>
<ul>
<li>线程 1 可能将 <code>running</code> 缓存在 CPU 寄存器或 L1 Cache 中</li>
<li>线程 2 的修改只写入了主内存，没有通知线程 1 刷新缓存</li>
<li>结果：线程 1 一直读取的是缓存中的旧值</li>
</ul>
<p><strong>保证可见性的方式</strong>：</p>
<ul>
<li><code>volatile</code> 关键字</li>
<li><code>synchronized</code> 关键字（进入和退出同步块时会刷新缓存）</li>
<li><code>final</code> 关键字（对于不可变对象）</li>
</ul>
<h4 id="3-有序性-ordering">3. 有序性（Ordering）</h4>
<p><strong>定义</strong>：程序执行的顺序按照代码的先后顺序执行。</p>
<p><strong>问题</strong>：编译器和处理器可能对指令进行<strong>重排序</strong>以优化性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原始代码</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;      <span class="hljs-comment">// 语句 1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;      <span class="hljs-comment">// 语句 2</span><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;  <span class="hljs-comment">// 语句 3</span><br><br><span class="hljs-comment">// 可能的重排序结果（语句 1 和 2 交换）</span><br><span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;      <span class="hljs-comment">// 语句 2</span><br><span class="hljs-type">int</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;      <span class="hljs-comment">// 语句 1</span><br><span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> a + b;  <span class="hljs-comment">// 语句 3</span><br><span class="hljs-comment">// 单线程下结果正确，但多线程下可能出问题</span><br></code></pre></td></tr></table></figure>
<p><strong>经典问题：双重检查锁定（DCL）的问题</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;              <span class="hljs-comment">// 第一次检查</span><br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;      <span class="hljs-comment">// 第二次检查</span><br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();  <span class="hljs-comment">// 问题在这里！</span><br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>instance = new Singleton()</code> 实际上是三个操作：</p>
<ol>
<li>分配内存空间</li>
<li>初始化对象</li>
<li>将 instance 指向分配的内存</li>
</ol>
<p>由于重排序，可能变成 1 → 3 → 2，导致其他线程看到一个<strong>未完全初始化的对象</strong>。</p>
<p><strong>保证有序性的方式</strong>：</p>
<ul>
<li><code>volatile</code> 关键字（禁止特定类型的重排序）</li>
<li><code>synchronized</code> 关键字（同一时刻只有一个线程执行）</li>
<li>happens-before 规则</li>
</ul>
<h3 id="happens-before-规则">happens-before 规则</h3>
<p>happens-before 是 JMM 的核心概念，它定义了<strong>操作之间的可见性关系</strong>。</p>
<p><strong>定义</strong>：如果操作 A happens-before 操作 B，那么 A 的执行结果对 B 可见，且 A 的执行顺序在 B 之前。</p>
<p><strong>注意</strong>：happens-before 不是指时间上的先后，而是指<strong>可见性的保证</strong>。</p>
<h4 id="jmm-定义的-happens-before-规则">JMM 定义的 happens-before 规则</h4>
<table>
<thead>
<tr>
<th>规则</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>程序顺序规则</strong></td>
<td>同一个线程中，前面的操作 happens-before 后面的操作</td>
</tr>
<tr>
<td><strong>监视器锁规则</strong></td>
<td>对一个锁的解锁 happens-before 对同一个锁的加锁</td>
</tr>
<tr>
<td><strong>volatile 变量规则</strong></td>
<td>对 volatile 变量的写 happens-before 对同一变量的读</td>
</tr>
<tr>
<td><strong>传递性规则</strong></td>
<td>如果 A happens-before B，B happens-before C，则 A happens-before C</td>
</tr>
<tr>
<td><strong>线程启动规则</strong></td>
<td>Thread.start() happens-before 该线程中的任何操作</td>
</tr>
<tr>
<td><strong>线程终止规则</strong></td>
<td>线程中的任何操作 happens-before 其他线程检测到该线程终止</td>
</tr>
<tr>
<td><strong>中断规则</strong></td>
<td>对线程 interrupt() 的调用 happens-before 被中断线程检测到中断</td>
</tr>
<tr>
<td><strong>对象终结规则</strong></td>
<td>对象的构造函数执行完成 happens-before finalize() 方法的开始</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;happens-before 示例&quot;
        direction TB
        
        subgraph &quot;线程 1&quot;
            A[&quot;x = 1&quot;]
            B[&quot;unlock(m)&quot;]
            A --&gt;|&quot;程序顺序规则&quot;| B
        end
        
        subgraph &quot;线程 2&quot;
            C[&quot;lock(m)&quot;]
            D[&quot;读取 x&quot;]
            C --&gt;|&quot;程序顺序规则&quot;| D
        end
        
        B --&gt;|&quot;监视器锁规则&quot;| C
        A --&gt;|&quot;传递性：x=1 对线程 2 可见&quot;| D
        
        style A fill:#c8e6c9
        style B fill:#fff9c4
        style C fill:#fff9c4
        style D fill:#e1f5ff
    end</code></pre>
<h3 id="volatile-关键字">volatile 关键字</h3>
<p><code>volatile</code> 是 Java 提供的最轻量级的同步机制，它保证了<strong>可见性</strong>和<strong>有序性</strong>，但<strong>不保证原子性</strong>。</p>
<h4 id="volatile-的语义">volatile 的语义</h4>
<ol>
<li><strong>可见性</strong>：对 volatile 变量的写入会立即刷新到主内存，读取会从主内存重新加载</li>
<li><strong>有序性</strong>：禁止 volatile 变量与普通变量之间的重排序</li>
</ol>
<h4 id="volatile-的内存屏障">volatile 的内存屏障</h4>
<p>JVM 通过插入**内存屏障（Memory Barrier）**来实现 volatile 的语义：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>LoadLoad</strong></td>
<td>确保 Load1 数据的装载先于 Load2 及后续装载指令</td>
</tr>
<tr>
<td><strong>StoreStore</strong></td>
<td>确保 Store1 数据对其他处理器可见先于 Store2 及后续存储指令</td>
</tr>
<tr>
<td><strong>LoadStore</strong></td>
<td>确保 Load1 数据装载先于 Store2 及后续存储指令刷新到内存</td>
</tr>
<tr>
<td><strong>StoreLoad</strong></td>
<td>确保 Store1 数据对其他处理器可见先于 Load2 及后续装载指令</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;volatile 写操作的内存屏障&quot;
        direction TB
        
        SS1[&quot;StoreStore 屏障&quot;]
        VW[&quot;volatile 写&quot;]
        SL1[&quot;StoreLoad 屏障&quot;]
        
        SS1 --&gt; VW --&gt; SL1
        
        note1[&quot;禁止上面的普通写&lt;br/&gt;与 volatile 写重排序&quot;]
        note2[&quot;禁止 volatile 写&lt;br/&gt;与下面的读/写重排序&quot;]
        
        SS1 -.-&gt; note1
        SL1 -.-&gt; note2
        
        style VW fill:#ffcdd2
    end
    
    subgraph &quot;volatile 读操作的内存屏障&quot;
        direction TB
        
        VR[&quot;volatile 读&quot;]
        LL1[&quot;LoadLoad 屏障&quot;]
        LS1[&quot;LoadStore 屏障&quot;]
        
        VR --&gt; LL1 --&gt; LS1
        
        note3[&quot;禁止 volatile 读&lt;br/&gt;与下面的读重排序&quot;]
        note4[&quot;禁止 volatile 读&lt;br/&gt;与下面的写重排序&quot;]
        
        LL1 -.-&gt; note3
        LS1 -.-&gt; note4
        
        style VR fill:#c8e6c9
    end</code></pre>
<h3 id="深入理解内存屏障">深入理解内存屏障</h3>
<p>上面我们介绍了 JVM 层面的四种内存屏障（LoadLoad、LoadStore、StoreLoad、StoreStore），但这只是冰山一角。要真正理解内存屏障的本质，我们需要深入到 CPU 和缓存的层面。</p>
<h4 id="为什么需要内存屏障？">为什么需要内存屏障？</h4>
<p>现代 CPU 为了提高性能，引入了多级缓存和各种优化机制，这些机制可能导致<strong>内存操作的可见性和顺序性问题</strong>：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;CPU 的写操作优化&quot;
        direction TB
        
        CPU[&quot;CPU Core&quot;]
        SB[&quot;Store Buffer&lt;br/&gt;（写缓冲区）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;暂存写操作&lt;br/&gt;异步刷新到缓存&quot;]
        L1[&quot;L1 Cache&quot;]
        L2[&quot;L2 Cache&quot;]
        MEM[&quot;主内存&quot;]
        
        CPU --&gt;|&quot;1. 写入&quot;| SB
        SB --&gt;|&quot;2. 异步刷新&quot;| L1
        L1 --&gt; L2 --&gt; MEM
        
        note1[&quot;问题：写入 Store Buffer 后&lt;br/&gt;CPU 认为写操作完成&lt;br/&gt;但其他 CPU 还看不到&quot;]
        
        style SB fill:#ffcdd2
        style note1 fill:#fff9c4
    end
    
    subgraph &quot;CPU 的读操作优化&quot;
        direction TB
        
        CPU2[&quot;CPU Core&quot;]
        IQ[&quot;Invalidate Queue&lt;br/&gt;（失效队列）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;暂存失效消息&lt;br/&gt;延迟处理&quot;]
        L1_2[&quot;L1 Cache&quot;]
        
        CPU2 --&gt;|&quot;读取&quot;| L1_2
        IQ --&gt;|&quot;延迟失效&quot;| L1_2
        
        note2[&quot;问题：失效消息在队列中&lt;br/&gt;但缓存行还未真正失效&lt;br/&gt;可能读到过期数据&quot;]
        
        style IQ fill:#ffcdd2
        style note2 fill:#fff9c4
    end</code></pre>
<p><strong>Store Buffer（写缓冲区）</strong>：</p>
<ul>
<li>CPU 执行写操作时，不会直接写入缓存，而是先写入 Store Buffer</li>
<li>这样 CPU 可以继续执行后续指令，不用等待缓存一致性协议完成</li>
<li><strong>问题</strong>：其他 CPU 可能看不到 Store Buffer 中的数据</li>
</ul>
<p><strong>Invalidate Queue（失效队列）</strong>：</p>
<ul>
<li>当 CPU 收到缓存失效消息时，不会立即处理，而是放入 Invalidate Queue</li>
<li>这样 CPU 可以快速响应，不用等待缓存失效完成</li>
<li><strong>问题</strong>：缓存行可能还未真正失效，读到过期数据</li>
</ul>
<h4 id="内存屏障的本质">内存屏障的本质</h4>
<p><strong>内存屏障（Memory Barrier / Memory Fence）是 CPU 提供的指令，用于强制刷新 Store Buffer 或处理 Invalidate Queue</strong>：</p>
<table>
<thead>
<tr>
<th>CPU 架构</th>
<th>写屏障指令</th>
<th>读屏障指令</th>
<th>全屏障指令</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>x86/x64</strong></td>
<td><code>sfence</code></td>
<td><code>lfence</code></td>
<td><code>mfence</code></td>
</tr>
<tr>
<td><strong>ARM</strong></td>
<td><code>dmb st</code></td>
<td><code>dmb ld</code></td>
<td><code>dmb ish</code></td>
</tr>
<tr>
<td><strong>POWER</strong></td>
<td><code>lwsync</code></td>
<td><code>lwsync</code></td>
<td><code>sync</code></td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;内存屏障的作用&quot;
        direction TB
        
        subgraph &quot;写屏障（Store Barrier）&quot;
            WB[&quot;sfence / dmb st&quot;]
            WB_DESC[&quot;强制刷新 Store Buffer&lt;br/&gt;确保之前的写操作&lt;br/&gt;对其他 CPU 可见&quot;]
        end
        
        subgraph &quot;读屏障（Load Barrier）&quot;
            RB[&quot;lfence / dmb ld&quot;]
            RB_DESC[&quot;强制处理 Invalidate Queue&lt;br/&gt;确保读到最新数据&quot;]
        end
        
        subgraph &quot;全屏障（Full Barrier）&quot;
            FB[&quot;mfence / dmb ish&quot;]
            FB_DESC[&quot;同时具有读屏障和写屏障的效果&lt;br/&gt;最强的顺序保证&quot;]
        end
        
        style WB fill:#c8e6c9
        style RB fill:#e1f5ff
        style FB fill:#ffcdd2
    end</code></pre>
<h4 id="jvm-如何映射内存屏障">JVM 如何映射内存屏障</h4>
<p>JVM 的四种抽象屏障会根据不同的 CPU 架构映射到具体的指令：</p>
<table>
<thead>
<tr>
<th>JVM 屏障</th>
<th>x86/x64</th>
<th>ARM</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>LoadLoad</strong></td>
<td>空操作（x86 保证）</td>
<td><code>dmb ishld</code></td>
<td>禁止读-读重排序</td>
</tr>
<tr>
<td><strong>StoreStore</strong></td>
<td>空操作（x86 保证）</td>
<td><code>dmb ishst</code></td>
<td>禁止写-写重排序</td>
</tr>
<tr>
<td><strong>LoadStore</strong></td>
<td>空操作（x86 保证）</td>
<td><code>dmb ish</code></td>
<td>禁止读-写重排序</td>
</tr>
<tr>
<td><strong>StoreLoad</strong></td>
<td><code>mfence</code> 或 <code>lock</code> 前缀</td>
<td><code>dmb ish</code></td>
<td>禁止写-读重排序</td>
</tr>
</tbody>
</table>
<p><strong>为什么 x86 大部分屏障是空操作？</strong></p>
<p>x86 架构采用<strong>强内存模型（TSO - Total Store Order）</strong>，硬件层面已经保证了大部分顺序性，只有 StoreLoad 重排序需要显式屏障。这也是为什么 Java 在 x86 上的并发性能通常比 ARM 更好。</p>
<h4 id="volatile-的底层实现">volatile 的底层实现</h4>
<p><strong>重要说明：JMM 规范与 JVM 实现的区别</strong></p>
<p>在讨论 volatile 的实现之前，需要明确区分两个层次：</p>
<table>
<thead>
<tr>
<th>层次</th>
<th>定义者</th>
<th>内容</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>JMM 规范</strong></td>
<td>JLS 17.4</td>
<td>定义 happens-before 语义，不规定具体实现</td>
</tr>
<tr>
<td><strong>JVM 实现</strong></td>
<td>HotSpot 等</td>
<td>使用内存屏障实现 JMM 语义，因架构而异</td>
</tr>
</tbody>
</table>
<p>根据 <strong>JLS 17.4.4</strong>，volatile 变量的语义是：</p>
<ul>
<li>对 volatile 变量的写操作 <strong>happens-before</strong> 后续对同一变量的读操作</li>
<li>这保证了可见性和有序性，但 JLS <strong>并未规定</strong>必须使用哪种内存屏障</li>
</ul>
<p><strong>JSR-133 Cookbook 的实现指南</strong>（非规范，仅供参考）：</p>
<p>当 JVM 编译 volatile 变量的读写时，会插入相应的内存屏障：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// volatile 写</span><br><span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">// JSR-133 Cookbook 建议的屏障（理论模型）</span><br>StoreStore barrier  <span class="hljs-comment">// 确保之前的写完成</span><br><span class="hljs-type">store</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><br>StoreLoad barrier   <span class="hljs-comment">// 确保写对其他 CPU 可见</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// volatile 读</span><br><span class="hljs-type">int</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x;  <span class="hljs-comment">// x 是 volatile</span><br><br><span class="hljs-comment">// JSR-133 Cookbook 建议的屏障（理论模型）</span><br><span class="hljs-type">load</span> <span class="hljs-variable">y</span> <span class="hljs-operator">=</span> x<br>LoadLoad barrier    <span class="hljs-comment">// 确保后续读不会重排序到前面</span><br>LoadStore barrier   <span class="hljs-comment">// 确保后续写不会重排序到前面</span><br></code></pre></td></tr></table></figure>
<p><strong>x86 架构的实际实现</strong>：</p>
<p>由于 x86 采用强内存模型（TSO），大部分屏障是空操作：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>x86 上的实现</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>StoreStore</td>
<td>空操作</td>
<td>x86 保证 Store-Store 顺序</td>
</tr>
<tr>
<td>LoadLoad</td>
<td>空操作</td>
<td>x86 保证 Load-Load 顺序</td>
</tr>
<tr>
<td>LoadStore</td>
<td>空操作</td>
<td>x86 保证 Load-Store 顺序</td>
</tr>
<tr>
<td><strong>StoreLoad</strong></td>
<td><strong>需要显式屏障</strong></td>
<td>x86 允许 Store-Load 重排序</td>
</tr>
</tbody>
</table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs asm">; HotSpot 在 x86 上的 volatile 写实现<br>mov [address], value    ; 普通写入<br>lock addl $0, (%rsp)    ; 使用 lock 前缀指令作为 StoreLoad 屏障<br></code></pre></td></tr></table></figure>
<p><code>lock</code> 前缀会锁定缓存行（或总线），确保写操作对所有 CPU 可见。</p>
<p><strong>关键理解</strong>：内存屏障是 JVM 实现 JMM 语义的手段，不是 JMM 规范本身。不同 JVM、不同 CPU 架构可能使用不同的屏障组合，只要最终满足 happens-before 语义即可。</p>
<h3 id="内存屏障-vs-gc-屏障：名字相同-本质不同">内存屏障 vs GC 屏障：名字相同，本质不同</h3>
<p>你可能听说过 G1、ZGC 也使用&quot;屏障&quot;（Barrier），但这与 CPU 内存屏障是<strong>完全不同的概念</strong>：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>CPU 内存屏障</th>
<th>GC 屏障</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>层次</strong></td>
<td>硬件指令</td>
<td>软件代码</td>
</tr>
<tr>
<td><strong>目的</strong></td>
<td>保证内存操作的可见性和顺序性</td>
<td>维护 GC 的正确性（如记录引用变化）</td>
</tr>
<tr>
<td><strong>实现</strong></td>
<td>CPU 指令（mfence、dmb 等）</td>
<td>JIT 编译器插入的代码片段</td>
</tr>
<tr>
<td><strong>性能影响</strong></td>
<td>阻止 CPU 优化，有一定开销</td>
<td>每次引用操作都执行，开销更大</td>
</tr>
</tbody>
</table>
<h4 id="g1-的写屏障-write-barrier">G1 的写屏障（Write Barrier）</h4>
<p>G1 使用<strong>写屏障</strong>来维护 Remembered Set（记录跨 Region 引用）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用户代码</span><br>obj.field = newValue;<br><br><span class="hljs-comment">// G1 插入的写屏障（伪代码）</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">writeBarrier</span><span class="hljs-params">(Object obj, Object newValue)</span> &#123;<br>    <span class="hljs-comment">// Pre-write barrier（SATB）</span><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> obj.field;<br>    <span class="hljs-keyword">if</span> (oldValue != <span class="hljs-literal">null</span>) &#123;<br>        satbMarkQueue.enqueue(oldValue);  <span class="hljs-comment">// 记录旧值，用于并发标记</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 实际写入</span><br>    obj.field = newValue;<br>    <br>    <span class="hljs-comment">// Post-write barrier</span><br>    <span class="hljs-keyword">if</span> (crossRegion(obj, newValue)) &#123;<br>        rememberedSet.add(obj, newValue);  <span class="hljs-comment">// 记录跨 Region 引用</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="zgc-的读屏障-load-barrier">ZGC 的读屏障（Load Barrier）</h4>
<p>ZGC 使用<strong>读屏障</strong>来实现并发重定位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 用户代码</span><br><span class="hljs-type">Object</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> obj.field;<br><br><span class="hljs-comment">// ZGC 插入的读屏障（伪代码）</span><br>Object <span class="hljs-title function_">loadBarrier</span><span class="hljs-params">(Object* fieldAddress)</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">ref</span> <span class="hljs-operator">=</span> *fieldAddress;<br>    <br>    <span class="hljs-comment">// 检查指针的颜色位</span><br>    <span class="hljs-keyword">if</span> (needsRemapping(ref)) &#123;<br>        <span class="hljs-comment">// 对象已被移动，更新指针</span><br>        ref = remap(ref);<br>        *fieldAddress = ref;  <span class="hljs-comment">// 自愈</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> ref;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;两种&#x27;屏障&#x27;的对比&quot;
        direction LR
        
        subgraph &quot;CPU 内存屏障&quot;
            MB[&quot;mfence / dmb&quot;]
            MB_USE[&quot;用途：保证内存可见性&quot;]
            MB_WHEN[&quot;时机：volatile 读写、锁操作&quot;]
            MB_HOW[&quot;实现：CPU 指令&quot;]
        end
        
        subgraph &quot;GC 屏障&quot;
            GB[&quot;Write/Load Barrier&quot;]
            GB_USE[&quot;用途：维护 GC 正确性&quot;]
            GB_WHEN[&quot;时机：每次引用读写&quot;]
            GB_HOW[&quot;实现：JIT 插入的代码&quot;]
        end
        
        style MB fill:#e1f5ff
        style GB fill:#c8e6c9
    end</code></pre>
<p><strong>为什么都叫&quot;屏障&quot;？</strong></p>
<p>两者都是在某个操作前后插入额外的逻辑，起到&quot;拦截&quot;或&quot;保护&quot;的作用，因此都被称为&quot;屏障&quot;。但它们解决的问题完全不同：</p>
<ul>
<li><strong>CPU 内存屏障</strong>：解决多核 CPU 的缓存一致性问题</li>
<li><strong>GC 屏障</strong>：解决并发 GC 的正确性问题</li>
</ul>
<h3 id="mesi-协议：缓存一致性的基石">MESI 协议：缓存一致性的基石</h3>
<p>在讨论内存屏障时，我们提到了&quot;缓存一致性&quot;。那么 CPU 是如何保证多核之间缓存一致的呢？答案是 <strong>MESI 协议</strong>。</p>
<p><strong>重要说明</strong>：MESI 协议<strong>不是 x86 专属的</strong>，而是一种<strong>通用的缓存一致性协议</strong>。它最初由 Intel 在 1980 年代提出，但被广泛应用于多种处理器架构：</p>
<table>
<thead>
<tr>
<th>处理器架构</th>
<th>使用的协议</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>x86/x64</strong></td>
<td>MESI、MESIF</td>
<td>Intel 使用 MESIF（增加 Forward 状态），AMD 使用 MOESI</td>
</tr>
<tr>
<td><strong>ARM</strong></td>
<td>MOESI、MESI 变体</td>
<td>ARM 的 big.LITTLE 架构使用类似协议</td>
</tr>
<tr>
<td><strong>SPARC</strong></td>
<td>MOESI</td>
<td>Sun/Oracle 的 SPARC 处理器</td>
</tr>
<tr>
<td><strong>PowerPC</strong></td>
<td>MESI 扩展</td>
<td>IBM 的 Power 系列处理器</td>
</tr>
<tr>
<td><strong>RISC-V</strong></td>
<td>可配置</td>
<td>支持多种一致性协议</td>
</tr>
</tbody>
</table>
<p>本文以 MESI 为例讲解，因为它是最基础、最经典的缓存一致性协议，其他协议（如 MOESI、MESIF）都是在 MESI 基础上的扩展。</p>
<h4 id="mesi-的四种状态">MESI 的四种状态</h4>
<p>MESI 是一种<strong>缓存一致性协议</strong>，每个缓存行（Cache Line）都有四种状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>全称</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>M</strong></td>
<td>Modified</td>
<td>缓存行被修改，与主内存不一致，只有当前 CPU 有效副本</td>
</tr>
<tr>
<td><strong>E</strong></td>
<td>Exclusive</td>
<td>缓存行与主内存一致，只有当前 CPU 有副本</td>
</tr>
<tr>
<td><strong>S</strong></td>
<td>Shared</td>
<td>缓存行与主内存一致，多个 CPU 都有副本</td>
</tr>
<tr>
<td><strong>I</strong></td>
<td>Invalid</td>
<td>缓存行无效，需要从主内存或其他 CPU 重新加载</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; I: 初始状态
    
    I --&gt; E: 本地读取（其他 CPU 无副本）
    I --&gt; S: 本地读取（其他 CPU 有副本）
    I --&gt; M: 本地写入
    
    E --&gt; S: 其他 CPU 读取
    E --&gt; M: 本地写入
    E --&gt; I: 其他 CPU 写入
    
    S --&gt; M: 本地写入（需先失效其他副本）
    S --&gt; I: 其他 CPU 写入
    
    M --&gt; S: 其他 CPU 读取（需先写回主内存）
    M --&gt; I: 其他 CPU 写入（需先写回主内存）
    M --&gt; E: 写回主内存</code></pre>
<h4 id="mesi-的工作流程">MESI 的工作流程</h4>
<p>上面的状态图展示了 MESI 协议的基本状态转换，但实际的 CPU 实现中还有两个关键组件：<strong>Store Buffer</strong> 和 <strong>Invalidate Queue</strong>。它们是性能优化的关键，也是导致内存可见性问题的根源。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;CPU 0&quot;
        CPU0_CORE[&quot;CPU 0 Core&quot;]
        SB0[&quot;Store Buffer&lt;br/&gt;━━━━━━━━━━━━━━&lt;br/&gt;写入缓冲区&lt;br/&gt;暂存待写入的数据&quot;]
        CACHE0[&quot;L1 Cache&lt;br/&gt;━━━━━━━━━━━━━━&lt;br/&gt;MESI 状态管理&quot;]
        IQ0[&quot;Invalidate Queue&lt;br/&gt;━━━━━━━━━━━━━━&lt;br/&gt;失效队列&lt;br/&gt;暂存待处理的失效消息&quot;]
        
        CPU0_CORE --&gt;|&quot;1. 写入&quot;| SB0
        SB0 --&gt;|&quot;2. 刷新到缓存&quot;| CACHE0
        IQ0 --&gt;|&quot;4. 处理失效&quot;| CACHE0
    end
    
    BUS[&quot;系统总线（Bus）&quot;]
    
    subgraph &quot;CPU 1&quot;
        CPU1_CORE[&quot;CPU 1 Core&quot;]
        SB1[&quot;Store Buffer&quot;]
        CACHE1[&quot;L1 Cache&quot;]
        IQ1[&quot;Invalidate Queue&quot;]
        
        CPU1_CORE --&gt;|&quot;读取&quot;| CACHE1
        IQ1 --&gt;|&quot;处理失效&quot;| CACHE1
    end
    
    CACHE0 &lt;--&gt;|&quot;3. Invalidate 消息&quot;| BUS
    BUS &lt;--&gt;|&quot;放入队列&quot;| IQ1
    CACHE1 &lt;--&gt;|&quot;Read/Response&quot;| BUS
    
    style SB0 fill:#ffcdd2
    style SB1 fill:#ffcdd2
    style IQ0 fill:#fff9c4
    style IQ1 fill:#fff9c4</code></pre>
<p><strong>Store Buffer 和 Invalidate Queue 的作用：</strong></p>
<table>
<thead>
<tr>
<th>组件</th>
<th>作用</th>
<th>带来的问题</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Store Buffer</strong></td>
<td>CPU 写入时先写入 Store Buffer，不等待其他 CPU 确认，提高写入性能</td>
<td>写入可能延迟对其他 CPU 可见</td>
</tr>
<tr>
<td><strong>Invalidate Queue</strong></td>
<td>CPU 收到 Invalidate 消息后先放入队列，不立即处理，提高响应速度</td>
<td>可能读到已被其他 CPU 修改的旧值</td>
</tr>
</tbody>
</table>
<p><strong>这就是为什么需要内存屏障的根本原因：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant CPU0 as CPU 0
    participant SB0 as Store Buffer 0
    participant C0 as Cache 0
    participant BUS as 总线
    participant IQ1 as Invalidate Queue 1
    participant C1 as Cache 1
    participant CPU1 as CPU 1
    
    Note over CPU0,CPU1: 问题场景：没有内存屏障时
    
    CPU0-&gt;&gt;SB0: 写入 x = 1
    Note over SB0: x = 1 暂存在 Store Buffer
    CPU0-&gt;&gt;CPU0: 继续执行其他指令
    
    CPU1-&gt;&gt;C1: 读取 x
    Note over CPU1: 读到旧值 x = 0！
    
    SB0-&gt;&gt;C0: 稍后刷新到缓存
    C0-&gt;&gt;BUS: 发送 Invalidate
    BUS-&gt;&gt;IQ1: 放入 Invalidate Queue
    Note over IQ1: 失效消息还在队列中...
    
    Note over CPU0,CPU1: 解决方案：使用内存屏障
    
    rect rgb(200, 230, 200)
        Note over CPU0: Store Barrier（写屏障）
        CPU0-&gt;&gt;SB0: 强制刷新 Store Buffer
        SB0-&gt;&gt;C0: 立即写入缓存
    end
    
    rect rgb(200, 200, 230)
        Note over CPU1: Load Barrier（读屏障）
        CPU1-&gt;&gt;IQ1: 强制处理 Invalidate Queue
        IQ1-&gt;&gt;C1: 使缓存行失效
        CPU1-&gt;&gt;C1: 读取 x
        Note over CPU1: 读到新值 x = 1
    end</code></pre>
<p><strong>关键理解</strong>：</p>
<ul>
<li><strong>MESI 协议本身是正确的</strong>，它最终会保证所有 CPU 看到一致的值</li>
<li><strong>但 Store Buffer 和 Invalidate Queue 引入了延迟</strong>，导致&quot;最终一致&quot;而非&quot;即时一致&quot;</li>
<li><strong>内存屏障的作用</strong>就是强制刷新这些缓冲区，确保写入立即可见</li>
</ul>
<h4 id="mesi-与-jmm-的关系">MESI 与 JMM 的关系</h4>
<p><strong>MESI 是硬件层面的缓存一致性协议，JMM 是语言层面的内存模型。两者的关系是：</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;层次关系&quot;
        direction TB
        
        JMM[&quot;Java 内存模型（JMM）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;定义 happens-before 规则&lt;br/&gt;定义 volatile、synchronized 语义&lt;br/&gt;屏蔽底层硬件差异&quot;]
        
        JVM[&quot;JVM 实现&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;将 JMM 语义映射到&lt;br/&gt;具体的内存屏障指令&quot;]
        
        CPU[&quot;CPU 硬件&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;MESI 协议保证缓存一致性&lt;br/&gt;内存屏障指令控制顺序&quot;]
        
        JMM --&gt; JVM --&gt; CPU
        
        style JMM fill:#e1f5ff
        style JVM fill:#c8e6c9
        style CPU fill:#fff9c4
    end</code></pre>
<p><strong>关键理解</strong>：</p>
<ol>
<li><strong>MESI 保证最终一致性</strong>：通过 Invalidate 消息，MESI 最终会让所有 CPU 看到相同的值</li>
<li><strong>但 MESI 不保证即时可见性</strong>：由于 Store Buffer 和 Invalidate Queue 的存在，写操作可能延迟可见</li>
<li><strong>内存屏障弥补这个差距</strong>：强制刷新 Store Buffer 或处理 Invalidate Queue</li>
</ol>
<h4 id="锁缓存-cache-line-locking">“锁缓存”（Cache Line Locking）</h4>
<p>你可能听说过&quot;锁缓存&quot;这个概念，它与 MESI 密切相关：</p>
<p><strong>锁缓存是 x86 CPU 的一种优化机制</strong>：当执行带 <code>lock</code> 前缀的指令时，如果操作的数据在缓存中，CPU 不会锁定整个总线，而是只锁定对应的缓存行。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;lock 前缀的两种实现&quot;
        direction LR
        
        subgraph &quot;总线锁（Bus Lock）&quot;
            BL[&quot;锁定整个总线&quot;]
            BL_WHEN[&quot;条件：数据跨缓存行&lt;br/&gt;或缓存行不在 M/E 状态&quot;]
            BL_COST[&quot;开销：非常大&lt;br/&gt;阻塞所有 CPU 的内存访问&quot;]
        end
        
        subgraph &quot;缓存锁（Cache Lock）&quot;
            CL[&quot;只锁定缓存行&quot;]
            CL_WHEN[&quot;条件：数据在单个缓存行内&lt;br/&gt;且缓存行在 M/E 状态&quot;]
            CL_COST[&quot;开销：较小&lt;br/&gt;只影响该缓存行的访问&quot;]
        end
        
        style BL fill:#ffcdd2
        style CL fill:#c8e6c9
    end</code></pre>
<p><strong>CAS 操作与缓存锁</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java 代码</span><br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>counter.incrementAndGet();<br><br><span class="hljs-comment">// 底层实现（x86）</span><br>lock cmpxchg [address], newValue<br></code></pre></td></tr></table></figure>
<p><code>lock cmpxchg</code> 指令会：</p>
<ol>
<li>如果数据在缓存中且满足条件，使用<strong>缓存锁</strong></li>
<li>将缓存行状态设为 M（Modified）</li>
<li>发送 Invalidate 消息给其他 CPU</li>
<li>其他 CPU 的对应缓存行变为 I（Invalid）</li>
</ol>
<p>这就是 CAS 能保证原子性的硬件基础。</p>
<h4 id="为什么有了-mesi-还需要内存屏障？">为什么有了 MESI 还需要内存屏障？</h4>
<p>这是一个常见的困惑。答案是：<strong>MESI 保证一致性，但不保证可见性的时机</strong>。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;MESI 的局限性&quot;
        direction TB
        
        WRITE[&quot;CPU 0 执行写操作&quot;]
        SB[&quot;写入 Store Buffer&quot;]
        MESI[&quot;MESI 协议开始工作&lt;br/&gt;（发送 Invalidate 消息）&quot;]
        IQ[&quot;CPU 1 收到消息&lt;br/&gt;放入 Invalidate Queue&quot;]
        DELAY[&quot;延迟处理...&quot;]
        INVALID[&quot;缓存行真正失效&quot;]
        
        WRITE --&gt; SB --&gt; MESI --&gt; IQ --&gt; DELAY --&gt; INVALID
        
        note1[&quot;问题：在 DELAY 期间&lt;br/&gt;CPU 1 可能读到旧值&quot;]
        
        style SB fill:#ffcdd2
        style IQ fill:#ffcdd2
        style note1 fill:#fff9c4
    end</code></pre>
<p><strong>Store Buffer 和 Invalidate Queue 是性能优化</strong>，它们让 CPU 不用等待 MESI 协议完成就能继续执行。但这也带来了可见性延迟。</p>
<p><strong>内存屏障的作用</strong>就是在需要时强制等待这些异步操作完成：</p>
<ul>
<li><strong>写屏障</strong>：等待 Store Buffer 刷新</li>
<li><strong>读屏障</strong>：等待 Invalidate Queue 处理</li>
</ul>
<h3 id="synchronized-与内存屏障">synchronized 与内存屏障</h3>
<p><strong>JLS 17.4.4 对 synchronized 的规范定义</strong>：</p>
<p>根据 JLS 规范，synchronized 的内存语义通过 <strong>happens-before 关系</strong>定义：</p>
<ul>
<li>对一个 monitor 的<strong>解锁操作</strong> happens-before 后续对<strong>同一 monitor 的加锁操作</strong></li>
</ul>
<p>这意味着：在解锁之前的所有写操作，对于后续获取同一锁的线程都是可见的。</p>
<p><strong>JVM 实现层面</strong>（非规范，仅供理解）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-comment">// 临界区</span><br>&#125;<br><br><span class="hljs-comment">// JVM 实现时的等价语义（概念模型）</span><br>monitorenter(lock);<br><span class="hljs-comment">// 获取语义（acquire semantics）：后续读写不能重排序到此之前</span><br><span class="hljs-comment">// 临界区代码</span><br><span class="hljs-comment">// 释放语义（release semantics）：之前读写不能重排序到此之后</span><br>monitorexit(lock);<br></code></pre></td></tr></table></figure>
<p><strong>JSR-133 Cookbook 建议的屏障</strong>（实现指南，非规范）：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>建议屏障</th>
<th>语义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>monitorenter 之后</strong></td>
<td>LoadLoad + LoadStore</td>
<td>获取语义（acquire）</td>
</tr>
<tr>
<td><strong>monitorexit 之前</strong></td>
<td>StoreStore + StoreLoad</td>
<td>释放语义（release）</td>
</tr>
</tbody>
</table>
<p><strong>实际实现因架构而异</strong>：</p>
<table>
<thead>
<tr>
<th>架构</th>
<th>monitorenter 实现</th>
<th>monitorexit 实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>x86</strong></td>
<td><code>lock cmpxchg</code>（隐含全屏障）</td>
<td><code>lock</code> 前缀指令或普通写</td>
</tr>
<tr>
<td><strong>ARM</strong></td>
<td><code>dmb</code> + <code>ldrex/strex</code></td>
<td><code>dmb</code> + 普通写</td>
</tr>
<tr>
<td><strong>AArch64</strong></td>
<td><code>ldaxr/stxr</code>（acquire）</td>
<td><code>stlr</code>（release）</td>
</tr>
</tbody>
</table>
<p><strong>关键理解</strong>：JLS 规定的是 happens-before 语义，具体使用哪种内存屏障是 JVM 的实现细节。在 x86 上，由于其强内存模型，<code>lock</code> 前缀指令已经提供了足够的内存屏障语义。</p>
<p>这就是为什么 <code>synchronized</code> 能保证可见性：<strong>释放锁时的 StoreLoad 屏障确保所有写操作对获取锁的线程可见</strong>。</p>
<h3 id="小结">小结</h3>
<table>
<thead>
<tr>
<th>概念</th>
<th>层次</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>MESI 协议</strong></td>
<td>硬件</td>
<td>保证多核缓存的最终一致性</td>
</tr>
<tr>
<td><strong>Store Buffer / Invalidate Queue</strong></td>
<td>硬件</td>
<td>性能优化，但导致可见性延迟</td>
</tr>
<tr>
<td><strong>CPU 内存屏障</strong></td>
<td>硬件指令</td>
<td>强制刷新缓冲区，保证可见性时机</td>
</tr>
<tr>
<td><strong>JMM 内存屏障</strong></td>
<td>JVM 抽象</td>
<td>屏蔽硬件差异，提供统一语义</td>
</tr>
<tr>
<td><strong>volatile / synchronized</strong></td>
<td>Java 语言</td>
<td>通过内存屏障实现可见性和有序性</td>
</tr>
<tr>
<td><strong>GC 屏障</strong></td>
<td>JVM 软件</td>
<td>维护 GC 正确性，与内存屏障无关</td>
</tr>
</tbody>
</table>
<p>理解这些概念的层次关系，有助于：</p>
<ul>
<li>正确理解 volatile 和 synchronized 的底层原理</li>
<li>区分不同&quot;屏障&quot;概念，避免混淆</li>
<li>理解为什么 Java 在不同 CPU 架构上的并发行为可能不同</li>
</ul>
<h4 id="volatile-的正确使用场景">volatile 的正确使用场景</h4>
<p><strong>适用场景</strong>：</p>
<ol>
<li>状态标志（如上面的 <code>running</code> 变量）</li>
<li>一次性安全发布（配合 final 字段）</li>
<li>双重检查锁定（DCL）的修复</li>
</ol>
<p><strong>修复后的 DCL</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Singleton</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;  <span class="hljs-comment">// 添加 volatile</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title function_">getInstance</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-keyword">if</span> (instance == <span class="hljs-literal">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Singleton</span>();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么 synchronized 不能替代 volatile？</strong></p>
<p>有人可能会问：synchronized 不是也保证可见性吗？为什么还需要 volatile？</p>
<p>关键在于：<strong>第一次检查 <code>if (instance == null)</code> 发生在 synchronized 块外部</strong>。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 1
    participant T2 as 线程 2
    participant instance as instance 变量
    
    Note over T1,instance: 没有 volatile 的问题场景
    
    T1-&gt;&gt;T1: 进入 synchronized
    T1-&gt;&gt;instance: instance = new Singleton()
    Note over T1,instance: 对象可能未完全初始化&lt;br/&gt;但引用已经非 null
    T1-&gt;&gt;T1: 退出 synchronized
    
    T2-&gt;&gt;instance: 第一次检查：instance == null?
    Note over T2,instance: 在 synchronized 外部读取！&lt;br/&gt;可能看到部分构造的对象
    T2-&gt;&gt;T2: instance != null，跳过 synchronized
    T2-&gt;&gt;T2: 使用未完全初始化的对象 💥</code></pre>
<p><strong>具体分析</strong>：</p>
<table>
<thead>
<tr>
<th>检查位置</th>
<th>是否在 synchronized 内</th>
<th>可见性保证</th>
</tr>
</thead>
<tbody>
<tr>
<td>第一次检查 <code>if (instance == null)</code></td>
<td>❌ 否</td>
<td>无保证，可能看到部分构造的对象</td>
</tr>
<tr>
<td>第二次检查 <code>if (instance == null)</code></td>
<td>✅ 是</td>
<td>有保证，synchronized 提供可见性</td>
</tr>
</tbody>
</table>
<p><strong>volatile 的作用</strong>：</p>
<ol>
<li><strong>禁止指令重排序</strong>：确保 <code>new Singleton()</code> 的三个步骤（分配内存、初始化、赋值引用）不会被重排序</li>
<li><strong>保证可见性</strong>：确保第一次检查（在 synchronized 外部）也能看到完全初始化的对象</li>
</ol>
<p><strong>如果所有访问都在 synchronized 内部呢？</strong></p>
<p>如果你能保证所有对 <code>instance</code> 的访问都通过 <code>getInstance()</code> 方法，并且都进入 synchronized 块，那么理论上 synchronized 的可见性就足够了。但 DCL 的设计目的就是<strong>避免每次都进入 synchronized</strong>，所以第一次检查必须在锁外部，这就需要 volatile。</p>
<p><strong>不适用场景</strong>：</p>
<ul>
<li>复合操作（如 <code>i++</code>）</li>
<li>需要原子性保证的场景</li>
</ul>
<h3 id="synchronized-与-volatile-的对比">synchronized 与 volatile 的对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>synchronized</th>
<th>volatile</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>原子性</strong></td>
<td>保证</td>
<td>不保证</td>
</tr>
<tr>
<td><strong>可见性</strong></td>
<td>保证</td>
<td>保证</td>
</tr>
<tr>
<td><strong>有序性</strong></td>
<td>保证</td>
<td>保证（部分）</td>
</tr>
<tr>
<td><strong>阻塞</strong></td>
<td>会阻塞</td>
<td>不会阻塞</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较重</td>
<td>较轻</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>复合操作、临界区</td>
<td>状态标志、一次性发布</td>
</tr>
</tbody>
</table>
<h3 id="关于-一致性-的说明">关于&quot;一致性&quot;的说明</h3>
<p>本文多处提到&quot;一致性&quot;这个词，需要特别说明：<strong>一致性（Consistency）不是 JMM 的专有属性</strong>。</p>
<p>JMM 的三大核心属性是：</p>
<ul>
<li><strong>原子性（Atomicity）</strong></li>
<li><strong>可见性（Visibility）</strong></li>
<li><strong>有序性（Ordering）</strong></li>
</ul>
<p>而&quot;一致性&quot;在不同上下文中有不同含义：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>含义</th>
<th>所属领域</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>缓存一致性（Cache Coherence）</strong></td>
<td>多核 CPU 缓存之间的数据一致</td>
<td>硬件/MESI 协议</td>
</tr>
<tr>
<td><strong>内存一致性模型（Memory Consistency Model）</strong></td>
<td>定义多处理器系统中内存操作的可见顺序</td>
<td>硬件/操作系统</td>
</tr>
<tr>
<td><strong>顺序一致性（Sequential Consistency）</strong></td>
<td>最强的内存模型，所有操作按全局顺序执行</td>
<td>理论模型</td>
</tr>
<tr>
<td><strong>数据一致性（Data Consistency）</strong></td>
<td>分布式系统中数据副本的一致</td>
<td>分布式系统/ACID</td>
</tr>
<tr>
<td><strong>最终一致性（Eventual Consistency）</strong></td>
<td>数据最终会达到一致状态</td>
<td>分布式系统/BASE</td>
</tr>
</tbody>
</table>
<p><strong>JMM 与一致性的关系</strong>：</p>
<ul>
<li>JMM 通过 <strong>happens-before</strong> 规则定义了操作之间的可见性关系</li>
<li>JMM 提供的是一种<strong>弱于顺序一致性</strong>的内存模型（允许一定程度的重排序）</li>
<li>JMM 的目标是在<strong>性能</strong>和<strong>正确性</strong>之间取得平衡</li>
</ul>
<h3 id="final-字段的内存语义">final 字段的内存语义</h3>
<p>除了 volatile 和 synchronized，<strong>final 字段</strong>也是 JMM 的重要组成部分。final 字段的内存语义保证了不可变对象的线程安全发布。</p>
<h4 id="final-字段的写入语义">final 字段的写入语义</h4>
<p>当构造函数完成时，JVM 会在 final 字段写入之后插入一个 <strong>StoreStore 屏障</strong>，确保：</p>
<ol>
<li>final 字段的写入不会被重排序到构造函数之外</li>
<li>其他线程在看到对象引用时，一定能看到 final 字段的正确值</li>
</ol>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 1（构造）
    participant MEM as 主内存
    participant T2 as 线程 2（读取）
    
    Note over T1: 构造函数开始
    T1-&gt;&gt;MEM: 写入 final 字段 x = 42
    Note over T1: StoreStore 屏障
    T1-&gt;&gt;MEM: 发布对象引用 obj = this
    Note over T1: 构造函数结束
    
    T2-&gt;&gt;MEM: 读取 obj 引用
    T2-&gt;&gt;MEM: 读取 obj.x
    Note over T2: 保证看到 x = 42</code></pre>
<h4 id="final-字段的读取语义">final 字段的读取语义</h4>
<p>当首次读取包含 final 字段的对象引用时，JVM 会在读取 final 字段之前插入一个 <strong>LoadLoad 屏障</strong>，确保：</p>
<ol>
<li>先读取对象引用，再读取 final 字段</li>
<li>不会读取到 final 字段的默认值（如 0 或 null）</li>
</ol>
<h4 id="正确使用-final-的示例">正确使用 final 的示例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FinalFieldExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object ref;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">FinalFieldExample</span><span class="hljs-params">()</span> &#123;<br>        x = <span class="hljs-number">42</span>;<br>        ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-comment">// 构造函数结束时，JVM 插入 StoreStore 屏障</span><br>        <span class="hljs-comment">// 保证 x 和 ref 的写入对其他线程可见</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 安全发布：其他线程通过正确发布的引用访问时</span><br>    <span class="hljs-comment">// 一定能看到 x = 42 和 ref 的正确值</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="final-语义的限制">final 语义的限制</h4>
<p><strong>重要</strong>：final 的内存语义有一个前提条件——<strong>对象引用必须被正确发布</strong>。如果在构造函数中将 <code>this</code> 引用泄露出去，final 的语义保证将失效：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：this 引用逃逸</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BrokenFinalExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> x;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">BrokenFinalExample</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 危险：在 final 字段初始化完成前，this 引用已经逃逸</span><br>        SomeRegistry.register(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// 其他线程可能看到 x = 0</span><br>        x = <span class="hljs-number">42</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="final-vs-volatile-vs-synchronized">final vs volatile vs synchronized</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>final</th>
<th>volatile</th>
<th>synchronized</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>可见性</strong></td>
<td>构造完成后保证</td>
<td>每次读写都保证</td>
<td>临界区内保证</td>
</tr>
<tr>
<td><strong>有序性</strong></td>
<td>禁止构造函数内外重排序</td>
<td>禁止读写重排序</td>
<td>禁止临界区内外重排序</td>
</tr>
<tr>
<td><strong>原子性</strong></td>
<td>不保证（只写一次）</td>
<td>不保证</td>
<td>保证</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>不可变对象</td>
<td>状态标志、DCL</td>
<td>复合操作</td>
</tr>
<tr>
<td><strong>性能开销</strong></td>
<td>最低（只在构造时）</td>
<td>较低</td>
<td>较高</td>
</tr>
</tbody>
</table>
<h3 id="小结">小结</h3>
<p>理解 JMM 是理解 Java 并发编程的基础：</p>
<ol>
<li><strong>JMM 的作用</strong>：屏蔽硬件差异，提供统一的内存访问规则</li>
<li><strong>三大特性</strong>：原子性、可见性、有序性（注意：不包括&quot;一致性&quot;）</li>
<li><strong>happens-before</strong>：定义操作之间可见性关系的核心规则</li>
<li><strong>volatile</strong>：轻量级同步机制，保证可见性和有序性</li>
<li><strong>final</strong>：不可变对象的安全发布保证</li>
<li><strong>synchronized</strong>：重量级同步机制，保证原子性、可见性和有序性</li>
</ol>
<p>有了这些基础知识，我们就可以更好地理解后续章节中的线程安全分类和锁优化技术。</p>
<h2 id="线程安全的分类">线程安全的分类</h2>
<h3 id="不可变-immutable">不可变（Immutable）</h3>
<p>不可变的数据，都是线程安全的。不可变的对象引用，加上所有field都是不可变的。如果有得选，尽量连方法都是final的。</p>
<h3 id="绝对线程安全-absolute-thread-safety">绝对线程安全（Absolute Thread Safety）</h3>
<p>Vector 不是绝对线程安全的。它也会出现并发修改时 Out of Range 的异常（注意，不是 ConcurrentModification 的异常）。</p>
<h3 id="相对线程安全-relative-thread-safety">相对线程安全（Relative Thread Safety）</h3>
<p>需要保证对这个对象的单独操作是线程安全的，在调用的时候不需要加上额外的保障措施。对于特定顺序的连续操作，就需要额外的同步来保证调用的正确性了。<br>
线程对立</p>
<p>Vector 是相对线程安全的。</p>
<h3 id="线程兼容-thread-compatible">线程兼容（Thread Compatible）</h3>
<p>可以通过特殊手段做到线程安全的普通类，绝大部分类都属于线程兼容的。</p>
<h3 id="线程对立-thread-hostile">线程对立（Thread Hostile）</h3>
<p>线程对立，是不管调用端是否采取了同步措施，都无法在多线程环境中使用的代码。常见的线程对立的操作还有 suspend()，resume()， System.setIn()，System.setOut()和System.runFinalizerOnExit()。</p>
<h2 id="线程安全的实现">线程安全的实现</h2>
<h3 id="互斥同步-mutual-exclusion-synchronization">互斥同步（Mutual Exclusion &amp; Synchronization)</h3>
<p>这是最常见（也是我们在考虑并发问题的时候，首先应该考虑的万能解决方案，也是《Java并发编程实践》和《Thinking in Java 》中最推荐的做法。）的保障并发正确性的手段。同步（Synchronization）是指协调多个线程的执行，保证共享数据在同一时刻只被一条（或使用信号量时多条）线程访问。互斥（Mutual Exclusion）是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量都是实现互斥的常见方式。<strong>互斥是因，同步是果；互斥是方法，同步是目的</strong>。这两个概念源自操作系统理论（Dijkstra 1965 年提出信号量时引入），同样出现在 OS 层面。同步的终极目标是将并发的乱序转化为类似无并发时的有序。</p>
<p><strong>[辨析] 临界区、同步块与锁保护区域</strong></p>
<p>这三个概念经常被混淆，但实际上是<strong>层次关系</strong>：</p>
<ul>
<li>
<p><strong>临界区（Critical Section）</strong>：通用并发编程领域的<strong>抽象概念</strong>，指&quot;访问共享资源的代码段&quot;。例如：<code>x = 1; y = 2;</code> 这段代码如果需要互斥访问，它就是一个临界区。</p>
</li>
<li>
<p><strong>同步块（Synchronized Block）</strong>：Java 语言层面的<strong>语法结构</strong>，是临界区的一种<strong>实现方式</strong>。例如：<code>synchronized (lock) { x = 1; }</code>，其中的 <code>{ x = 1; }</code> 是临界区，<code>synchronized (lock) { }</code> 是同步块。</p>
</li>
<li>
<p><strong>锁保护区域（Lock-Protected Region）</strong>：<strong>运行时概念</strong>，指实际被 <code>synchronized</code> 或 <code>ReentrantLock</code> 保护的具体代码区域。例如：当线程执行到 <code>synchronized (lock)</code> 内的代码时，这块正在执行的代码就是锁保护区域。</p>
</li>
</ul>
<p><strong>层次关系图</strong>：</p>
<pre><code class="hljs mermaid">graph TD
    A[临界区 Critical Section&lt;br/&gt;抽象概念&lt;br/&gt;访问共享资源的代码段] --&gt; B[同步块 Synchronized Block&lt;br/&gt;Java 语法结构&lt;br/&gt;临界区的实现方式]
    B --&gt; C[锁保护区域 Lock-Protected Region&lt;br/&gt;运行时实例&lt;br/&gt;被锁保护的具体代码]
    
    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#e8f5e9</code></pre>
<p><strong>关键区别</strong>：</p>
<ul>
<li>临界区是<strong>抽象概念</strong>，描述&quot;需要保护什么&quot;</li>
<li>同步块是<strong>语法工具</strong>，描述&quot;如何保护&quot;</li>
<li>锁保护区域是<strong>运行时实例</strong>，描述&quot;当前正在保护什么&quot;</li>
</ul>
<p>在 Java 里面，最基本的互斥手段就是 synchronized 关键字。它经过编译后，会转化为 monitorenter 和 monitorexit 这两个字节码指令（bytecode instructions）。在执行这两个字节码指令之前，需要先将锁对象的引用压入操作数栈，指令会从栈顶获取这个引用来确定加锁/解锁的对象。这个引用不是一个普通对象实例，就是一个 Class 对象（对于 synchronized 静态方法）。</p>
<p>根据虚拟机规范，在执行 monitorenter 指令时，首先尝试获取对象的锁（实际上就是去用线程信息写 markword）。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，那么把锁的计数器加1。相应地，在执行 monitorexit 时，会对计数器减1，当计数器为0时，锁就被释放了。从某种意义上来讲，这种设计可以在分布式场景下用 Redis 实现。如果获取锁失败了，那么就会进入阻塞状态，直到对象锁被释放为止。虚拟机规范对 monitorenter 和 monitorexit 两条指令的行为描述中，有两点是需要特别注意的。<strong>首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死（阻塞）的情况。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入</strong>。对于映射到操作系统原生进程的实现，不管是阻塞还是唤醒线程，都需要操作系统的调用帮忙，也就会牵涉到用户态转变入核心态的问题（系统控制权从用户空间转入内核空间）。<strong>这种切换需要消耗很多 CPU 时间。这也是为什么它是昂贵的原因，时间是最昂贵的。对于很多简单的getter()、setter（）操作，花在状态切换上的时间，甚至会多过用户代码执行的时间。甚至可以认为，这样的状态切换需要使用很多的汇编指令代码，以至于要使用很多的 cpu 时钟周期</strong>。因此synchronized本身是一种重量级（Heavyweight）操作。JVM（注意，不是Java语言） 本身可能会对重量锁进行优化，使用偏向锁/轻量级锁/锁自旋而非阻塞来避免频繁地切入核心态之中（自旋难道就不浪费CPU 时间了吗？）。</p>
<p>J.U.C包里专门提供了Reentrantlock来实现同步。它同样具有 synchronized 具有的可重入、阻塞其他求锁者的特性。但它还具有三个额外的特点，支持某些场景下的任务调度需求：</p>
<ol>
<li>等待可中断。Lock 接口有实现类可以实现试锁，超时试锁等功能，各种接口都有 interruptibly 版本。这样 synchronized中，其他求锁线程傻等的情况可以避免。</li>
<li>公平锁。公平锁指的是按照求锁顺序来分配锁（求锁也是有顺序的，fifo 天然就是公平的）。默认的锁（synchronized 和 ReentrantLock 的默认构造函数）是非公平的，随机给予锁，这样性能更好。synchronized 本身并不内置公平锁，AQS 的非公平锁通过允许插队（新来的线程可以直接尝试 CAS 获取锁，不用排队），来减少 cpu 时间片花在调度/cpu上下文切换上的开销，来获得更高的吞吐。非公平锁的吞吐会更好，而公平锁可避免线程饥饿。ReentrantLock 默认使用非公平锁。</li>
<li>绑定多个条件。在 synchronized 的时代，多个 condition 就意味着多层 synchronized。</li>
</ol>
<h4 id="为什么需要可中断锁？使用场景分析">为什么需要可中断锁？使用场景分析</h4>
<p><code>lock()</code> 不支持中断，线程会一直阻塞直到获取锁。这与原始的 <code>synchronized</code> 行为一致：<strong>一旦进入等待，就无法中途退出</strong>。而 <code>lockInterruptibly()</code> 的引入，让加解锁不再是单一的对称重复操作，提供了更灵活的控制。</p>
<p><strong>可中断锁的核心价值</strong>：让线程在等待锁的过程中能够响应外部中断信号，提前退出等待状态。</p>
<h5 id="典型使用场景">典型使用场景</h5>
<p><strong>场景 1：线程池优雅关闭</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：使用不可中断的 lock()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BadBlockingQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">take</span><span class="hljs-params">()</span> &#123;<br>        lock.lock(); <span class="hljs-comment">// ❌ 如果这里阻塞，线程无法响应 shutdownNow()</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 等待队列非空</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 正确示例：使用可中断的 lockInterruptibly()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodBlockingQueue</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lockInterruptibly(); <span class="hljs-comment">// ✅ 可以响应中断</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 等待队列非空</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线程池关闭时</span><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br>executor.submit(() -&gt; goodQueue.take());<br><br><span class="hljs-comment">// 关闭线程池：会中断所有工作线程</span><br>executor.shutdownNow(); <span class="hljs-comment">// ✅ 工作线程会抛出 InterruptedException，快速退出</span><br></code></pre></td></tr></table></figure>
<p><strong>为什么场景 1 需要可中断锁？</strong></p>
<ul>
<li>线程池调用 <code>shutdownNow()</code> 时，会对所有工作线程调用 <code>interrupt()</code></li>
<li>如果工作线程使用 <code>lock()</code> 阻塞在锁上，<strong>无法响应中断</strong>，会一直傻等到获取锁</li>
<li>使用 <code>lockInterruptibly()</code>，线程会立即抛出 <code>InterruptedException</code>，可以快速响应关闭</li>
</ul>
<p><strong>场景 2：任务超时取消</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">TaskProcessor</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (!lock.tryLock(timeout, unit)) &#123; <span class="hljs-comment">// ✅ 带超时的锁获取</span><br>            <span class="hljs-comment">// 超时后，任务被取消</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>(<span class="hljs-string">&quot;获取锁超时&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 执行任务</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>Future&lt;?&gt; future = executor.submit(() -&gt; processor.process(<span class="hljs-number">5</span>, TimeUnit.SECONDS));<br><br><span class="hljs-comment">// 3秒后取消任务（假设任务还没获取到锁）</span><br>Thread.sleep(<span class="hljs-number">3000</span>);<br>future.cancel(<span class="hljs-literal">true</span>); <span class="hljs-comment">// ✅ 会中断线程，lockInterruptibly 会抛出 InterruptedException</span><br></code></pre></td></tr></table></figure>
<p><strong>为什么场景 2 需要可中断锁？</strong></p>
<ul>
<li>任务可能因为锁竞争严重而长时间无法获取锁</li>
<li>外部调用者可能因为超时需要取消任务</li>
<li>使用 <code>lockInterruptibly()</code> 或 <code>tryLock(timeout)</code>，可以让任务快速响应取消</li>
</ul>
<p><strong>场景 3：分布式锁的锁续期失败</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">localLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RedisLock redisLock;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWithLock</span><span class="hljs-params">(Runnable action)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        localLock.lockInterruptibly(); <span class="hljs-comment">// ✅ 响应中断</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            redisLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                action.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                redisLock.unlock();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            localLock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果 Redis 锁续期失败，需要快速放弃</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; distributedLock.doWithLock(() -&gt; &#123;<br>    <span class="hljs-comment">// 执行业务逻辑</span><br>&#125;));<br><br><span class="hljs-comment">// 检测到续期失败，中断线程</span><br>worker.interrupt(); <span class="hljs-comment">// ✅ 线程会抛出 InterruptedException，快速退出</span><br></code></pre></td></tr></table></figure>
<p><strong>为什么场景 3 需要可中断锁？</strong></p>
<ul>
<li>分布式锁可能因为网络问题、Redis 故障等原因续期失败</li>
<li>需要快速放弃锁持有，避免其他节点长时间等待</li>
<li>可中断锁可以让线程快速响应异常情况</li>
</ul>
<h5 id="可中断锁-vs-不可中断锁">可中断锁 vs 不可中断锁</h5>
<table>
<thead>
<tr>
<th>特性</th>
<th><code>lock()</code></th>
<th><code>lockInterruptibly()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>响应中断</strong></td>
<td>❌ 不响应</td>
<td>✅ 响应</td>
</tr>
<tr>
<td><strong>中断时行为</strong></td>
<td>继续阻塞</td>
<td>抛出 <code>InterruptedException</code></td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>简单互斥，不需要取消</td>
<td>需要快速响应外部取消信号</td>
</tr>
<tr>
<td><strong>底层实现</strong></td>
<td>AQS <code>acquire()</code></td>
<td>AQS <code>acquireInterruptibly()</code></td>
</tr>
<tr>
<td><strong>线程状态</strong></td>
<td><code>BLOCKED</code> 或 <code>WAITING</code></td>
<td><code>WAITING</code>（可被中断唤醒）</td>
</tr>
</tbody>
</table>
<h5 id="synchronized-为什么不支持中断？">synchronized 为什么不支持中断？</h5>
<p><code>synchronized</code> 不支持中断是<strong>历史设计和 JVM 实现限制</strong>的结果：</p>
<ol>
<li><strong>历史原因</strong>：<code>synchronized</code> 是 Java 1.0 就存在的语言特性，当时还没有考虑线程中断机制</li>
<li><strong>JVM 实现</strong>：<code>synchronized</code> 的 <code>monitorenter</code> 指令直接映射到操作系统的互斥锁，无法在中途取消等待</li>
<li><strong>语义设计</strong>：<code>synchronized</code> 设计为&quot;简单的互斥&quot;，<code>ReentrantLock</code> 设计为&quot;高级的同步工具&quot;</li>
</ol>
<p><strong>总结</strong>：</p>
<ul>
<li><strong>优先使用 <code>synchronized</code></strong>：对于简单的互斥场景，<code>synchronized</code> 的性能和可读性都更好</li>
<li><strong>需要可中断时使用 <code>lockInterruptibly()</code></strong>：线程池关闭、任务取消、超时控制等场景</li>
<li><strong>需要超时时使用 <code>tryLock(timeout)</code></strong>：避免长时间等待锁</li>
</ul>
<p>这种设计体现了 Java 并发库的<strong>渐进式复杂度</strong>：简单场景用简单工具，复杂场景用高级工具。</p>
<p>synchronized 的性能屡屡被 JVM 的实现者改进，因此还是优先要使用synchronized（《TIJ》、《Java 并发实践》和《深入理解 Java 虚拟机》到此达到了同一结论）。</p>
<h3 id="synchronized-的公平性深入分析">synchronized 的公平性深入分析</h3>
<p>synchronized 是一个<strong>非公平锁</strong>，这一特性源于其底层实现机制。理解 synchronized 的非公平性，需要从 JVM 的 ObjectMonitor 实现说起。</p>
<h4 id="为什么-synchronized-是非公平的">为什么 synchronized 是非公平的</h4>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;synchronized 获取锁的竞争过程&quot;
        T_NEW[&quot;新到达的线程&quot;]
        T_QUEUE[&quot;队列中等待的线程&quot;]
        LOCK[&quot;锁（ObjectMonitor）&quot;]
        
        T_NEW --&gt;|&quot;1. 直接尝试 CAS&quot;| LOCK
        T_QUEUE --&gt;|&quot;2. 被唤醒后尝试&quot;| LOCK
        
        RESULT&#123;&quot;谁先成功?&quot;&#125;
        LOCK --&gt; RESULT
        RESULT --&gt;|&quot;新线程先 CAS 成功&quot;| WIN_NEW[&quot;新线程获得锁&quot;]
        RESULT --&gt;|&quot;队列线程先成功&quot;| WIN_QUEUE[&quot;队列线程获得锁&quot;]
        
        style T_NEW fill:#ffcdd2
        style T_QUEUE fill:#c8e6c9
        style WIN_NEW fill:#ffcdd2
    end</code></pre>
<p>synchronized 的非公平性体现在以下几个层面：</p>
<table>
<thead>
<tr>
<th>层面</th>
<th>非公平行为</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>偏向锁</strong></td>
<td>偏向第一个获取锁的线程</td>
<td>优化单线程场景</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>自旋竞争，先 CAS 成功者获胜</td>
<td>避免线程阻塞开销</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>新线程可直接尝试获取，不必排队</td>
<td>减少上下文切换</td>
</tr>
</tbody>
</table>
<h4 id="objectmonitor-的-entrylist-竞争机制">ObjectMonitor 的 EntryList 竞争机制</h4>
<p>当 synchronized 升级为重量级锁后，底层使用 ObjectMonitor 管理等待线程。ObjectMonitor 维护两个队列：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;ObjectMonitor 结构&quot;
        OWNER[&quot;_owner&lt;br/&gt;当前持有锁的线程&quot;]
        
        subgraph &quot;EntryList&quot;
            E1[&quot;等待线程 1&quot;]
            E2[&quot;等待线程 2&quot;]
            E3[&quot;等待线程 3&quot;]
        end
        
        subgraph &quot;cxq (Contention Queue)&quot;
            C1[&quot;新竞争线程 A&quot;]
            C2[&quot;新竞争线程 B&quot;]
        end
        
        NEW_THREAD[&quot;新到达的线程&quot;]
        
        NEW_THREAD --&gt;|&quot;1. 先尝试直接获取&quot;| OWNER
        NEW_THREAD --&gt;|&quot;2. 失败则进入 cxq&quot;| C1
        
        OWNER --&gt;|&quot;释放锁时&quot;| WAKE[&quot;唤醒策略&quot;]
        WAKE --&gt;|&quot;可能唤醒&quot;| E1
        WAKE --&gt;|&quot;也可能唤醒&quot;| C1
    end
    
    style NEW_THREAD fill:#fff9c4
    style OWNER fill:#c8e6c9</code></pre>
<p><strong>关键点</strong>：当锁被释放时，JVM 并不保证 EntryList 中等待最久的线程一定能获得锁。新到达的线程可以&quot;插队&quot;直接尝试获取锁，这就是非公平的本质。</p>
<h4 id="synchronized-与-reentrantlock-公平性对比">synchronized 与 ReentrantLock 公平性对比</h4>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;synchronized（非公平，不可配置）&quot;
        S_NEW[&quot;新线程&quot;] --&gt;|&quot;直接 CAS&quot;| S_LOCK[&quot;锁&quot;]
        S_QUEUE[&quot;队列线程&quot;] --&gt;|&quot;被唤醒后竞争&quot;| S_LOCK
    end
    
    subgraph &quot;ReentrantLock（可配置）&quot;
        subgraph &quot;非公平模式（默认）&quot;
            NF_NEW[&quot;新线程&quot;] --&gt;|&quot;直接 CAS&quot;| NF_LOCK[&quot;锁&quot;]
            NF_QUEUE[&quot;队列线程&quot;] --&gt;|&quot;被唤醒后竞争&quot;| NF_LOCK
        end
        
        subgraph &quot;公平模式&quot;
            F_NEW[&quot;新线程&quot;] --&gt;|&quot;检查队列&quot;| F_CHECK&#123;&quot;队列空?&quot;&#125;
            F_CHECK --&gt;|&quot;否&quot;| F_ENQUEUE[&quot;必须排队&quot;]
            F_CHECK --&gt;|&quot;是&quot;| F_LOCK[&quot;锁&quot;]
            F_QUEUE[&quot;队列线程&quot;] --&gt;|&quot;按顺序获取&quot;| F_LOCK
        end
    end</code></pre>
<table>
<thead>
<tr>
<th>特性</th>
<th>synchronized</th>
<th>ReentrantLock（非公平）</th>
<th>ReentrantLock（公平）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>公平性</strong></td>
<td>非公平</td>
<td>非公平</td>
<td>公平</td>
</tr>
<tr>
<td><strong>可配置</strong></td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td><strong>吞吐量</strong></td>
<td>高</td>
<td>高</td>
<td>较低</td>
</tr>
<tr>
<td><strong>线程饥饿风险</strong></td>
<td>存在</td>
<td>存在</td>
<td>无</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>通用</td>
<td>高吞吐优先</td>
<td>顺序敏感场景</td>
</tr>
</tbody>
</table>
<h4 id="非公平锁的性能优势">非公平锁的性能优势</h4>
<p>非公平锁的设计是一个经过深思熟虑的权衡。其性能优势来源于：</p>
<ol>
<li><strong>减少线程唤醒开销</strong>：新线程可能在队列线程被唤醒之前就获得锁并完成工作</li>
<li><strong>减少上下文切换</strong>：避免不必要的线程状态转换</li>
<li><strong>提高 CPU 缓存命中率</strong>：刚释放锁的线程再次获取锁时，相关数据可能还在缓存中</li>
</ol>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程1（持有锁）
    participant T2 as 线程2（队列中）
    participant T3 as 线程3（新到达）
    participant Lock as 锁
    
    Note over T1,Lock: 非公平锁场景
    T1-&gt;&gt;Lock: 释放锁
    T3-&gt;&gt;Lock: 同时到达，直接 CAS
    T3-&gt;&gt;Lock: CAS 成功，获得锁
    Note over T3: T3 执行临界区（很短）
    T3-&gt;&gt;Lock: 释放锁
    Lock-&gt;&gt;T2: 唤醒 T2
    T2-&gt;&gt;Lock: 获得锁
    
    Note over T1,Lock: 如果是公平锁
    Note over T3: T3 必须等待 T2 先执行
    Note over T3: 增加了一次上下文切换</code></pre>
<h3 id="非阻塞同步-non-blocking-synchronization">非阻塞同步（Non-Blocking Synchronization)</h3>
<p>也就是我们常说的乐观策略。不需要加锁，也就不需要负担线程状态切换的代价。但代价是，如果真的发生了冲突，乐观操作需要付出的代价就是补偿（compensation）。最常见的补偿，应该就是不断重试（又要引入自旋了）。乐观锁的核心基石，实际上是 CAS（CompareAndSet或者 CompareAndSwap），这两个操作必须是原子化操作，这就要求现代的处理器提供这样的指令原语（instruction primitive）。JVM 虚拟机里，专门通过  Unsafe 包来向上层提供这种原语的语义。</p>
<p>CAS操作有一个很讨厌的 ABA 问题。虽然 ABA 问题本身在大部分情况下不会引起问题，但J.U.C还是提供了一个 AtomicStampedReference操作来避免这个问题（所以说，<strong>带版本的原子值才是最安全的</strong>）。在大多数情况下，进入互斥同步，还比用这些鸡肋功能要高效。所有自旋都满足如下规律：低度竞争自旋优于真正的 mutex 互斥锁定，高度竞争自旋会浪费 cpu-低度竞争适合线程活跃等待，高度竞争适合线程阻塞等待。</p>
<h3 id="无同步方案">无同步方案</h3>
<h4 id="可重入代码-reentrant-code">可重入代码（Reentrant Code）</h4>
<p>也叫纯代码（Pure Code）。在它执行的任意时刻中断它，转而去执行另一段代码，再切换上下文回来以后，不会发生任何错误。<strong>所有可重入的代码都是线程安全的，但并非所有线程安全的代码都是可重入的</strong>。</p>
<p>可重入代码的特征：</p>
<ul>
<li><strong>不依赖任何非常量的全局变量或静态变量</strong></li>
<li>不修改自身的代码</li>
<li>不调用不可重入的函数</li>
<li>所有数据都通过参数传递或使用局部变量（栈封闭）</li>
</ul>
<p>这类似于函数式编程里的纯函数，<strong>函数的行为完全由输入参数决定，结果可预测</strong>，不依赖也不修改外部状态。这也是为什么函数式编程在高并发下是安全的，它们天然满足栈封闁的标准。</p>
<h4 id="线程本地存储-thread-local-storage">线程本地存储（Thread Local Storage）</h4>
<p>请参阅专题文章：<a href="https://magicliang.github.io/2020/04/01/ThreadLocal-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">ThreadLocal 的设计模式</a></p>
<h1>对象头</h1>
<p>需要参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26357186/what-is-in-java-object-header">What is in Java object header?</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_50275872/article/details/124302457">并发编程的艺术（3）：深入理解Synchronized的原理</a></li>
</ol>
<p>在 32 位虚拟机里：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">普通对象<br>|<span class="hljs-string">--------------------------------------------------------------</span>|<br>|<span class="hljs-string">                   Object Header (64 bits)                    </span>|<br>|<span class="hljs-string">------------------------------------</span>|<span class="hljs-string">-------------------------</span>|<br>|<span class="hljs-string"> Mark Word (32 bits)                </span>|<span class="hljs-string"> Klass Word (32 bits)    </span>|<br>|<span class="hljs-string">------------------------------------</span>|<span class="hljs-string">-------------------------</span>|<br>数组对象<br>|<span class="hljs-string">---------------------------------------------------------------------------------</span>|<br>|<span class="hljs-string">                                 Object Header (96 bits)                         </span>|<br>|<span class="hljs-string">--------------------------------</span>|<span class="hljs-string">-----------------------</span>|<span class="hljs-string">------------------------</span>|<br>|<span class="hljs-string"> Mark Word(32bits)              </span>|<span class="hljs-string"> Klass Word(32bits)    </span>|<span class="hljs-string"> array length(32bits)   </span>|<br>|<span class="hljs-string">--------------------------------</span>|<span class="hljs-string">-----------------------</span>|<span class="hljs-string">------------------------</span>|<br>标记字是<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> Mark Word (32 bits)                                   </span>|<span class="hljs-string"> State              </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> hashcode:25 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:0              </span>|<span class="hljs-string"> 01 </span>|<span class="hljs-string"> Normal             </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> thread:23 </span>|<span class="hljs-string"> epoch:2 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1      </span>|<span class="hljs-string"> 01 </span>|<span class="hljs-string"> Biased             </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> ptr_to_lock_record:30(lock_record指针)           </span>|<span class="hljs-string"> 00 </span>|<span class="hljs-string"> Lightweight Locked </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> ptr_to_heavyweight_monitor:30(monitor指针)       </span>|<span class="hljs-string"> 10 </span>|<span class="hljs-string"> Heavyweight Locked </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string">                                                  </span>|<span class="hljs-string"> 11 </span>|<span class="hljs-string"> Marked for GC      </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>在64位虚拟机里<br>|<span class="hljs-string">--------------------------------------------------------------</span>|<br>|<span class="hljs-string">                     Object Header (128 bits)                 </span>|<br>|<span class="hljs-string">-------------------------------</span>|<span class="hljs-string">------------------------------</span>|<br>|<span class="hljs-string">          Mark Word (64 bits)  </span>|<span class="hljs-string">         Klass Word (64 bits) </span>|<br>|<span class="hljs-string">-------------------------------</span>|<span class="hljs-string">------------------------------</span>|<br>标记字是<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> Mark Word (64 bits)                                              </span>|<span class="hljs-string"> State              </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> unused:25 </span>|<span class="hljs-string"> hashcode:31 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:0 </span>|<span class="hljs-string"> 01  </span>|<span class="hljs-string"> Normal             </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> thread:54 </span>|<span class="hljs-string"> epoch:2 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1     </span>|<span class="hljs-string"> 01  </span>|<span class="hljs-string"> Biased             </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> ptr_to_lock_record:62                                      </span>|<span class="hljs-string"> 00  </span>|<span class="hljs-string"> Lightweight Locked </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> ptr_to_heavyweight_monitor:62                              </span>|<span class="hljs-string"> 10  </span>|<span class="hljs-string"> Heavyweight Locked </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string">                                                            </span>|<span class="hljs-string"> 11  </span>|<span class="hljs-string"> Marked for GC      </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br></code></pre></td></tr></table></figure>
<p><img src="monitor%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="monitor的结构"></p>
<p>我们大致上认为一个对象应该分为 object header 和 object body，然后再把 header 分为 Mark Word 和 Klass Pointer。</p>
<p><strong>为什么叫 Mark Word？</strong></p>
<ul>
<li><strong>Mark</strong> = 标记/标志，因为这个字段用于存储对象的各种<strong>运行时标记信息</strong></li>
<li><strong>Word</strong> = 机器字长（32 位或 64 位），表示它占用一个机器字的空间</li>
<li>存储内容（根据锁状态动态变化）：
<ul>
<li><strong>无锁状态</strong>：对象的 hashCode、GC 分代年龄（age）、锁标志位</li>
<li><strong>偏向锁状态</strong>：偏向线程 ID、epoch、GC 分代年龄、锁标志位</li>
<li><strong>轻量级锁状态</strong>：指向栈中 Lock Record 的指针</li>
<li><strong>重量级锁状态</strong>：指向 Monitor 对象的指针</li>
<li><strong>GC 标记状态</strong>：用于垃圾回收</li>
</ul>
</li>
</ul>
<p><strong>为什么叫 Klass Word（类型字）？</strong></p>
<ul>
<li><strong>Klass</strong> 是 HotSpot 虚拟机中对 Java 类元数据的 C++ 表示（注意不是 Class，而是 Klass，这是 HotSpot 源码中的命名约定）</li>
<li><strong>Word</strong> = 机器字长（32 位或 64 位），表示它占用一个机器字的空间</li>
<li>本质上是一个<strong>指针</strong>，指向方法区中该对象所属类的元数据（Klass 对象）</li>
<li>存储内容：指向方法区中 <code>InstanceKlass</code>（普通对象）或 <code>ArrayKlass</code>（数组对象）的指针</li>
<li>作用：JVM 通过这个指针确定对象是哪个类的实例，从而找到类的方法表、字段布局等信息</li>
</ul>
<blockquote>
<p><strong>术语说明</strong>：在不同的技术文档中，你可能会看到 <strong>Klass Word</strong> 和 <strong>Klass Pointer</strong> 两种叫法，它们指的是同一个东西。<strong>Klass Word</strong> 强调它占用一个机器字的空间（与 Mark Word 对应），<strong>Klass Pointer</strong> 强调它的本质是一个指针。本文统一使用 <strong>Klass Word</strong> 以与对象头结构图保持一致。</p>
</blockquote>
<h3 id="klass-pointer-与类元数据的关系">Klass Pointer 与类元数据的关系</h3>
<p>Klass Pointer 指向的究竟是什么？当 <code>.class</code> 文件被类加载器加载进 JVM 后，字节码中的类型信息会被解析并存储在方法区（JDK 8+ 为 Metaspace）中，形成 HotSpot 内部的 C++ 数据结构——<strong>Klass</strong>。</p>
<p><strong>图：从 .class 文件到对象实例的完整链路</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;编译期&quot;
        JAVA[&quot;Java 源文件&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;MyClass.java&quot;]
        JAVAC[&quot;javac 编译器&quot;]
        CLASS[&quot;字节码文件&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;MyClass.class&lt;br/&gt;（魔数、版本、常量池、&lt;br/&gt;字段表、方法表...）&quot;]
        
        JAVA --&gt; JAVAC --&gt; CLASS
        style JAVA fill:#e8f5e9
        style CLASS fill:#fff9c4
    end
    
    subgraph &quot;运行期 - 类加载&quot;
        CL[&quot;类加载器&lt;br/&gt;ClassLoader&quot;]
        CLASS --&gt; CL
    end
    
    subgraph &quot;方法区 / Metaspace&quot;
        direction TB
        
        subgraph &quot;Klass 层次结构（C++ 对象）&quot;
            KLASS[&quot;Klass（抽象基类）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;所有类元数据的基类&quot;]
            
            IK[&quot;InstanceKlass&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;普通类的元数据&lt;br/&gt;• vtable（虚方法表）&lt;br/&gt;• itable（接口方法表）&lt;br/&gt;• 字段布局信息&lt;br/&gt;• 常量池引用&lt;br/&gt;• 方法字节码&quot;]
            
            AK[&quot;ArrayKlass&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;数组类的元数据&quot;]
            
            OAK[&quot;ObjArrayKlass&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;对象数组&lt;br/&gt;如 String[]&quot;]
            
            TAK[&quot;TypeArrayKlass&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;基本类型数组&lt;br/&gt;如 int[], byte[]&quot;]
            
            KLASS --&gt; IK
            KLASS --&gt; AK
            AK --&gt; OAK
            AK --&gt; TAK
        end
        
        MIRROR[&quot;java.lang.Class 对象&lt;br/&gt;（Mirror 对象）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Java 层面的类对象&lt;br/&gt;MyClass.class&quot;]
        
        IK &lt;--&gt;|&quot;双向引用&quot;| MIRROR
        
        style KLASS fill:#e1f5ff
        style IK fill:#c8e6c9
        style AK fill:#fff9c4
        style OAK fill:#ffecb3
        style TAK fill:#ffecb3
        style MIRROR fill:#f3e5f5
    end
    
    CL --&gt;|&quot;解析字节码&lt;br/&gt;创建 Klass&quot;| IK
    
    subgraph &quot;堆（Heap）&quot;
        direction TB
        
        subgraph &quot;普通对象实例&quot;
            OBJ1[&quot;对象实例 obj1&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Object Header:&lt;br/&gt;┌─────────────────┐&lt;br/&gt;│ Mark Word (8B)  │&lt;br/&gt;├─────────────────┤&lt;br/&gt;│ Klass Ptr (4/8B)│───────&lt;br/&gt;└─────────────────┘&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Instance Data&quot;]
        end
        
        subgraph &quot;数组对象实例&quot;
            ARR[&quot;数组实例 arr&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Object Header:&lt;br/&gt;┌─────────────────┐&lt;br/&gt;│ Mark Word (8B)  │&lt;br/&gt;├─────────────────┤&lt;br/&gt;│ Klass Ptr (4/8B)│───────&lt;br/&gt;├─────────────────┤&lt;br/&gt;│ Array Length(4B)│&lt;br/&gt;└─────────────────┘&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Array Elements&quot;]
        end
        
        style OBJ1 fill:#e1f5ff
        style ARR fill:#fff9c4
    end
    
    OBJ1 --&gt;|&quot;Klass Pointer&quot;| IK
    ARR --&gt;|&quot;Klass Pointer&quot;| OAK
    
    note1[&quot;关键理解：&lt;br/&gt;1. Klass 是 HotSpot 中类元数据的 C++ 表示&lt;br/&gt;2. InstanceKlass 对应普通 Java 类&lt;br/&gt;3. ArrayKlass 对应数组类型&lt;br/&gt;4. 每个对象的 Klass Pointer 指向其类型的 Klass&lt;br/&gt;5. java.lang.Class 是 Klass 在 Java 层的镜像&quot;]
    style note1 fill:#fff9c4</code></pre>
<p><strong>图：Klass Pointer 的指针压缩</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;64 位 JVM - 未压缩&quot;
        OH1[&quot;Object Header&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word: 8 bytes&lt;br/&gt;Klass Ptr: 8 bytes&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;总计: 16 bytes&quot;]
        style OH1 fill:#ffcdd2
    end
    
    subgraph &quot;64 位 JVM - 压缩指针（默认）&quot;
        OH2[&quot;Object Header&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word: 8 bytes&lt;br/&gt;Klass Ptr: 4 bytes&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;总计: 12 bytes&lt;br/&gt;（+ 4 bytes padding = 16）&quot;]
        style OH2 fill:#c8e6c9
    end
    
    OH1 --&gt;|&quot;-XX:+UseCompressedClassPointers&lt;br/&gt;（堆 &lt; 32GB 时默认开启）&quot;| OH2
    
    note[&quot;压缩指针原理：&lt;br/&gt;• 将 64 位指针压缩为 32 位&lt;br/&gt;• 通过左移 3 位还原（8 字节对齐）&lt;br/&gt;• 可寻址 32GB 的 Metaspace&quot;]
    style note fill:#fff9c4</code></pre>
<p><strong>核心概念澄清：</strong></p>
<table>
<thead>
<tr>
<th>概念</th>
<th>层面</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Klass</strong></td>
<td>C++ (HotSpot 内部)</td>
<td>类元数据的抽象基类，是 HotSpot 对 Java 类型系统的内部表示</td>
</tr>
<tr>
<td><strong>InstanceKlass</strong></td>
<td>C++ (HotSpot 内部)</td>
<td>普通 Java 类的元数据，包含 vtable、字段布局、方法字节码等</td>
</tr>
<tr>
<td><strong>ArrayKlass</strong></td>
<td>C++ (HotSpot 内部)</td>
<td>数组类型的元数据，分为 ObjArrayKlass 和 TypeArrayKlass</td>
</tr>
<tr>
<td><strong>java.lang.Class</strong></td>
<td>Java</td>
<td>Klass 在 Java 层的&quot;镜像&quot;对象，通过 <code>MyClass.class</code> 获取</td>
</tr>
<tr>
<td><strong>Klass Pointer</strong></td>
<td>对象头</td>
<td>每个对象实例中指向其 Klass 的指针，占 1 个机器字（可压缩）</td>
</tr>
</tbody>
</table>
<p><strong>为什么叫 Klass 而不是 Class？</strong></p>
<p>这是 HotSpot 源码的命名约定。由于 C++ 中 <code>class</code> 是保留关键字，无法用作类名，因此 HotSpot 开发者使用 <code>Klass</code> 来表示 Java 类的元数据。这个命名也体现了它与 Java 层 <code>java.lang.Class</code> 的区别——<code>Klass</code> 是 VM 内部的 C++ 对象，而 <code>Class</code> 是 Java 层的反射对象。</p>
<p><strong>为什么放在对象头？</strong></p>
<ul>
<li>这两个信息是 JVM 管理对象的<strong>核心元数据</strong>，每个对象都必须携带</li>
<li>Mark Word 支持 synchronized 锁机制和 GC</li>
<li>Klass Word 支持方法调用（虚方法表查找）和类型检查（instanceof）</li>
</ul>
<p><strong>两个 Word 的结构特性差异：</strong></p>
<p>在不同的 JVM 实现中（32 位 vs 64 位），这两个 Word 都是固定的机器字长（32 bits 或 64 bits），但它们的<strong>结构可变性</strong>完全不同：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>大小</th>
<th>结构是否可变</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Mark Word</strong></td>
<td>32/64 bits</td>
<td><strong>可变</strong></td>
<td>根据锁状态动态变化，像 C 语言的 union，同一块内存在不同状态下存储不同含义的数据</td>
</tr>
<tr>
<td><strong>Klass Word</strong></td>
<td>32/64 bits</td>
<td><strong>固定</strong></td>
<td>始终是一个指向方法区类元数据的指针，结构从不改变</td>
</tr>
</tbody>
</table>
<p>这种设计体现了不同的职责：</p>
<ul>
<li><strong>Klass Word 是静态的</strong>：对象的类型在创建后就确定了，永远不会改变，所以 Klass Word 只需要存储一个固定的指针</li>
<li><strong>Mark Word 是动态的</strong>：对象的运行时状态（锁状态、GC 年龄、hashCode 等）会随着程序执行而变化，所以 Mark Word 需要能够&quot;变形&quot;来适应不同的场景</li>
</ul>
<p><strong>锁升级时原始信息去哪了？</strong></p>
<p>Mark Word 的各种状态是<strong>互斥的</strong>，锁升级时原始信息（hashCode、age 等）会被<strong>转移保存</strong>。关于三种锁对 Mark Word 的详细处理策略，请参见下文<a href="#%E4%B8%89%E7%A7%8D%E9%94%81%E5%AF%B9-Mark-Word-%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5">偏向锁章节的&quot;三种锁对 Mark Word 的处理策略&quot;</a>。</p>
<p>这也解释了为什么轻量级锁解锁时必须用 CAS 把 Displaced Mark Word 写回——就是为了<strong>恢复</strong>原始的 Mark Word 信息。如果 CAS 失败，说明锁已膨胀，原始信息已转移到 ObjectMonitor 中。</p>
<p>Mark Word 本身在对象生命周期里面表现得像 union 一样可变，是让研究 synchronized 的人最头痛的。</p>
<p><img src="%E9%94%81%E7%9A%84%E4%B8%89%E9%87%8D%E5%AF%B9%E8%B1%A1%E9%93%BE%E6%8E%A5.png" alt="锁的三重对象链接"></p>
<p>通常我们可以看到 thread 会维护 lock record/monitor record；monitor 会维护两种 set 和 owner（aqs 原理的原型），似乎可以被看成操作系统的 mutext lock 在 jvm 里的句柄；object 本身使用一个 object header。</p>
<h2 id="mark-word-与-monitor-的关系">Mark Word 与 Monitor 的关系</h2>
<p><strong>核心要点：Mark Word 只保存 Monitor 的引用（指针），而不保存 Monitor 的具体信息。</strong></p>
<p>虽然 Mark Word 是一个多变的数据结构（根据锁状态动态变化），但在重量级锁状态下，它会保存指向 Monitor 对象的指针。而真正的锁管理信息——包括 <strong>Owner（当前持有锁的线程）</strong>、<strong>EntryList（阻塞等待锁的线程队列）</strong>、<strong>WaitSet（调用 wait() 后等待的线程集合）</strong>——都存储在 Monitor 这个独立的数据结构中。</p>
<p><strong>Monitor（ObjectMonitor）的核心字段：</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_header</code></td>
<td>markOop</td>
<td>保存对象原始的 Mark Word（用于锁释放时恢复）</td>
</tr>
<tr>
<td><code>_owner</code></td>
<td>void*</td>
<td>指向当前持有锁的线程</td>
</tr>
<tr>
<td><code>_EntryList</code></td>
<td>ObjectWaiter*</td>
<td>阻塞在 synchronized 入口处的线程链表</td>
</tr>
<tr>
<td><code>_WaitSet</code></td>
<td>ObjectWaiter*</td>
<td>调用 wait() 后进入等待状态的线程集合</td>
</tr>
<tr>
<td><code>_recursions</code></td>
<td>intptr_t</td>
<td>锁的重入次数</td>
</tr>
<tr>
<td><code>_count</code></td>
<td>volatile intptr_t</td>
<td>等待获取锁的线程数</td>
</tr>
</tbody>
</table>
<p><strong>图1：锁对象、Mark Word 与 Monitor 的引用关系</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Java 对象&quot;
        OBJ[Object]
        subgraph &quot;Object Header&quot;
            MW[Mark Word&lt;br/&gt;64 bits]
            KP[Klass Pointer]
        end
        BODY[Object Body&lt;br/&gt;实例数据]
        OBJ --&gt; MW
        OBJ --&gt; KP
        OBJ --&gt; BODY
    end
    
    subgraph &quot;Monitor 对象（ObjectMonitor）&quot;
        MON[ObjectMonitor]
        HEADER[&quot;_header&lt;br/&gt;原始 Mark Word 备份&quot;]
        OWNER[&quot;_owner&lt;br/&gt;当前持锁线程&quot;]
        ENTRY[&quot;_EntryList&lt;br/&gt;阻塞等待队列&quot;]
        WAIT[&quot;_WaitSet&lt;br/&gt;wait() 等待集合&quot;]
        REC[&quot;_recursions&lt;br/&gt;重入次数&quot;]
        MON --&gt; HEADER
        MON --&gt; OWNER
        MON --&gt; ENTRY
        MON --&gt; WAIT
        MON --&gt; REC
    end
    
    subgraph &quot;线程&quot;
        T1[Thread-1&lt;br/&gt;持有锁]
        T2[Thread-2&lt;br/&gt;阻塞等待]
        T3[Thread-3&lt;br/&gt;wait 等待]
    end
    
    MW --&gt;|&quot;重量级锁状态&lt;br/&gt;ptr_to_heavyweight_monitor&quot;| MON
    OWNER --&gt;|指向| T1
    ENTRY --&gt;|包含| T2
    WAIT --&gt;|包含| T3
    
    style MW fill:#e1f5ff
    style MON fill:#fff4e6
    style HEADER fill:#e8f5e9
    style OWNER fill:#ffcdd2
    style ENTRY fill:#fff9c4
    style WAIT fill:#e1bee7</code></pre>
<p><strong>图2：不同锁状态下 Mark Word 的内容变化</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;无锁状态 (01)&quot;
        MW1[&quot;Mark Word&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;unused:25 | hashcode:31 | unused:1 | age:4 | 0 | 01&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;直接存储 hashCode 和 GC 年龄&quot;]
        style MW1 fill:#c8e6c9
    end
    
    subgraph &quot;偏向锁状态 (01)&quot;
        MW2[&quot;Mark Word&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;thread:54 | epoch:2 | unused:1 | age:4 | 1 | 01&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;存储偏向线程 ID，无需 Monitor&quot;]
        style MW2 fill:#fff9c4
    end
    
    subgraph &quot;轻量级锁状态 (00)&quot;
        MW3[&quot;Mark Word&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;ptr_to_lock_record:62 | 00&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;指向线程栈帧中的 Lock Record&lt;br/&gt;原始 Mark Word 保存在 Lock Record 中&quot;]
        LR[&quot;Lock Record&lt;br/&gt;（线程栈帧中）&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word&lt;br/&gt;（原始 Mark Word 备份）&quot;]
        MW3 -.-&gt;|指向| LR
        style MW3 fill:#bbdefb
        style LR fill:#e3f2fd
    end
    
    subgraph &quot;重量级锁状态 (10)&quot;
        MW4[&quot;Mark Word&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;ptr_to_heavyweight_monitor:62 | 10&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;只存储 Monitor 指针！&lt;br/&gt;所有锁信息都在 Monitor 中&quot;]
        MON4[&quot;ObjectMonitor&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;_header: 原始 Mark Word&lt;br/&gt;_owner: 持锁线程&lt;br/&gt;_EntryList: 阻塞队列&lt;br/&gt;_WaitSet: 等待集合&lt;br/&gt;_recursions: 重入次数&quot;]
        MW4 -.-&gt;|指向| MON4
        style MW4 fill:#ffcdd2
        style MON4 fill:#ffebee
    end
    
    MW1 --&gt;|&quot;第一次加锁&lt;br/&gt;（无竞争）&quot;| MW2
    MW2 --&gt;|&quot;出现竞争&lt;br/&gt;撤销偏向&quot;| MW3
    MW3 --&gt;|&quot;竞争激烈&lt;br/&gt;锁膨胀&quot;| MW4</code></pre>
<p><strong>图3：重量级锁下 Monitor 的工作机制</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as Thread-1
    participant OBJ as 锁对象
    participant MW as Mark Word
    participant MON as ObjectMonitor
    participant T2 as Thread-2
    participant T3 as Thread-3
    
    Note over OBJ,MON: 初始状态：无锁
    
    T1-&gt;&gt;OBJ: synchronized(obj)
    OBJ-&gt;&gt;MW: 检查锁状态
    MW-&gt;&gt;MON: 锁膨胀，创建 Monitor
    Note over MW: Mark Word 变为&lt;br/&gt;ptr_to_monitor | 10
    MON-&gt;&gt;MON: _owner = Thread-1
    Note over T1,MON: Thread-1 成功获取锁
    
    T2-&gt;&gt;OBJ: synchronized(obj)
    OBJ-&gt;&gt;MW: 检查锁状态
    MW-&gt;&gt;MON: 获取 Monitor 引用
    MON-&gt;&gt;MON: 检查 _owner != null
    MON-&gt;&gt;MON: Thread-2 加入 _EntryList
    Note over T2: Thread-2 阻塞等待
    
    T1-&gt;&gt;MON: obj.wait()
    MON-&gt;&gt;MON: Thread-1 移入 _WaitSet
    MON-&gt;&gt;MON: _owner = null
    MON-&gt;&gt;MON: 从 _EntryList 唤醒 Thread-2
    MON-&gt;&gt;MON: _owner = Thread-2
    Note over T2,MON: Thread-2 获取锁
    
    T3-&gt;&gt;MON: obj.notify()
    MON-&gt;&gt;MON: 从 _WaitSet 移出 Thread-1
    MON-&gt;&gt;MON: Thread-1 加入 _EntryList
    Note over T1: Thread-1 等待重新竞争锁</code></pre>
<p><strong>图4：锁状态转换与数据存储位置</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;锁状态&quot;
        UNLOCK[无锁&lt;br/&gt;01]
        BIASED[偏向锁&lt;br/&gt;01]
        LIGHT[轻量级锁&lt;br/&gt;00]
        HEAVY[重量级锁&lt;br/&gt;10]
    end
    
    subgraph &quot;原始信息存储位置&quot;
        IN_MW[&quot;在 Mark Word 中&quot;]
        IN_LR[&quot;在 Lock Record 中&lt;br/&gt;（线程栈帧）&quot;]
        IN_MON[&quot;在 Monitor 的&lt;br/&gt;_header 字段中&quot;]
    end
    
    subgraph &quot;锁管理信息&quot;
        NO_LOCK[&quot;无需管理&quot;]
        THREAD_ID[&quot;线程 ID 在 Mark Word&quot;]
        LR_PTR[&quot;Lock Record 指针在 Mark Word&quot;]
        MON_ALL[&quot;Owner/EntryList/WaitSet&lt;br/&gt;全部在 Monitor 中&quot;]
    end
    
    UNLOCK --&gt;|hashCode/age| IN_MW
    UNLOCK --&gt;|锁信息| NO_LOCK
    
    BIASED --&gt;|hashCode/age| IN_MW
    BIASED --&gt;|锁信息| THREAD_ID
    
    LIGHT --&gt;|hashCode/age| IN_LR
    LIGHT --&gt;|锁信息| LR_PTR
    
    HEAVY --&gt;|hashCode/age| IN_MON
    HEAVY --&gt;|锁信息| MON_ALL
    
    UNLOCK --&gt;|首次加锁| BIASED
    BIASED --&gt;|竞争| LIGHT
    LIGHT --&gt;|膨胀| HEAVY
    
    style UNLOCK fill:#c8e6c9
    style BIASED fill:#fff9c4
    style LIGHT fill:#bbdefb
    style HEAVY fill:#ffcdd2
    style IN_MW fill:#e8f5e9
    style IN_LR fill:#e3f2fd
    style IN_MON fill:#ffebee</code></pre>
<p><strong>关键理解：</strong></p>
<ol>
<li>
<p><strong>Mark Word 是&quot;指针容器&quot;而非&quot;数据容器&quot;</strong>：在轻量级锁和重量级锁状态下，Mark Word 不再直接存储 hashCode 等原始信息，而是存储指向其他数据结构的指针。</p>
</li>
<li>
<p><strong>Monitor 是独立的数据结构</strong>：ObjectMonitor 是 JVM 在 C++ 层面实现的对象，它独立于 Java 对象存在。当锁膨胀为重量级锁时，JVM 会创建（或复用）一个 ObjectMonitor 对象，并将其地址写入 Mark Word。</p>
</li>
<li>
<p><strong>原始信息的&quot;流转&quot;</strong>：</p>
<ul>
<li>无锁/偏向锁：原始信息直接在 Mark Word 中</li>
<li>轻量级锁：原始信息被拷贝到线程栈帧的 Lock Record 中</li>
<li>重量级锁：原始信息被保存到 Monitor 的 <code>_header</code> 字段中</li>
</ul>
</li>
<li>
<p><strong>解锁时的恢复</strong>：无论是轻量级锁还是重量级锁，解锁时都需要将原始的 Mark Word 恢复回去。这就是为什么轻量级锁解锁时需要 CAS 操作——它要把 Lock Record 中保存的 Displaced Mark Word 写回对象头。</p>
</li>
</ol>
<h2 id="monitor-与操作系统同步原语的关系">Monitor 与操作系统同步原语的关系</h2>
<h3 id="什么是原语-primitive-？">什么是原语（Primitive）？</h3>
<p>在讨论锁的底层实现之前，我们需要先理解一个核心概念：<strong>原语（Primitive）</strong>。</p>
<p><strong>原语的定义：</strong></p>
<p>原语是指由若干条机器指令组成的、用于完成特定功能的<strong>不可分割的基本操作</strong>。&quot;不可分割&quot;意味着原语的执行过程不会被中断——要么全部执行完成，要么完全不执行，不存在执行到一半的中间状态。</p>
<p><strong>原语的层次结构：</strong></p>
<p>在计算机系统中，原语存在于不同的层次，它们之间有明确的依赖关系：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;应用层&quot;
        JAVA[&quot;Java 同步机制&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;synchronized&lt;br/&gt;ReentrantLock&lt;br/&gt;Semaphore&quot;]
        style JAVA fill:#c8e6c9
    end
    
    subgraph &quot;JVM 层&quot;
        JVM[&quot;JVM 同步原语&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;ObjectMonitor&lt;br/&gt;Parker&lt;br/&gt;Unsafe.park/unpark&quot;]
        style JVM fill:#fff9c4
    end
    
    subgraph &quot;操作系统层&quot;
        OS[&quot;操作系统同步原语&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mutex（互斥量）&lt;br/&gt;Semaphore（信号量）&lt;br/&gt;Condition Variable（条件变量）&lt;br/&gt;Futex（Linux 快速用户态互斥）&quot;]
        style OS fill:#ffcc80
    end
    
    subgraph &quot;硬件/CPU 层&quot;
        CPU[&quot;CPU 指令原语&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;CAS（Compare-And-Swap）&lt;br/&gt;LL/SC（Load-Linked/Store-Conditional）&lt;br/&gt;Memory Barrier（内存屏障）&lt;br/&gt;LOCK 前缀指令（x86）&quot;]
        style CPU fill:#ffcdd2
    end
    
    JAVA --&gt;|&quot;依赖&quot;| JVM
    JVM --&gt;|&quot;依赖&quot;| OS
    OS --&gt;|&quot;依赖&quot;| CPU
    
    note1[&quot;关键理解：&lt;br/&gt;上层原语由下层原语组合实现&lt;br/&gt;最底层是 CPU 提供的原子指令&quot;]
    style note1 fill:#e1f5ff</code></pre>
<p><strong>CPU 指令原语（Instruction Primitives）：</strong></p>
<p>CPU 指令原语是最底层的原子操作，由硬件直接保证其原子性。常见的 CPU 指令原语包括：</p>
<table>
<thead>
<tr>
<th>指令原语</th>
<th>架构</th>
<th>功能</th>
<th>在 Java 中的体现</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CAS（Compare-And-Swap）</strong></td>
<td>x86: <code>CMPXCHG</code><br/>ARM: <code>LDREX/STREX</code></td>
<td>比较并交换：如果内存值等于预期值，则更新为新值</td>
<td><code>Unsafe.compareAndSwapInt()</code><br/><code>AtomicInteger.compareAndSet()</code></td>
</tr>
<tr>
<td><strong>LOCK 前缀</strong></td>
<td>x86</td>
<td>锁定总线或缓存行，确保后续指令的原子性</td>
<td>CAS 指令的底层实现</td>
</tr>
<tr>
<td><strong>Memory Barrier</strong></td>
<td>所有架构</td>
<td>防止指令重排序，确保内存可见性</td>
<td><code>volatile</code> 的底层实现</td>
</tr>
<tr>
<td><strong>XCHG</strong></td>
<td>x86</td>
<td>原子交换两个值</td>
<td>自旋锁的底层实现</td>
</tr>
</tbody>
</table>
<p><strong>操作系统同步原语（OS Synchronization Primitives）：</strong></p>
<p>操作系统基于 CPU 指令原语，提供了更高级的同步机制：</p>
<table>
<thead>
<tr>
<th>OS 原语</th>
<th>功能</th>
<th>特点</th>
<th>对应的 Java 机制</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Mutex（互斥量）</strong></td>
<td>保证同一时刻只有一个线程进入临界区</td>
<td>阻塞式，需要系统调用</td>
<td><code>synchronized</code>（重量级锁）</td>
</tr>
<tr>
<td><strong>Semaphore（信号量）</strong></td>
<td>控制同时访问资源的线程数量</td>
<td>可以允许多个线程同时访问</td>
<td><code>java.util.concurrent.Semaphore</code></td>
</tr>
<tr>
<td><strong>Condition Variable（条件变量）</strong></td>
<td>线程等待特定条件成立</td>
<td>必须与 Mutex 配合使用</td>
<td><code>Object.wait()/notify()</code></td>
</tr>
<tr>
<td><strong>Futex（Fast Userspace Mutex）</strong></td>
<td>Linux 特有的快速互斥量</td>
<td>无竞争时在用户态完成，有竞争时才进入内核</td>
<td>JVM 在 Linux 上的锁实现</td>
</tr>
</tbody>
</table>
<p><strong>指令原语与操作系统原语的关系：</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;CPU 指令原语&quot;
        CAS[&quot;CAS 指令&quot;]
        LOCK[&quot;LOCK 前缀&quot;]
        BARRIER[&quot;Memory Barrier&quot;]
    end
    
    subgraph &quot;操作系统原语&quot;
        MUTEX[&quot;Mutex&quot;]
        FUTEX[&quot;Futex&quot;]
        COND[&quot;Condition Variable&quot;]
    end
    
    CAS --&gt;|&quot;构建&quot;| FUTEX
    CAS --&gt;|&quot;构建&quot;| MUTEX
    LOCK --&gt;|&quot;保证原子性&quot;| CAS
    BARRIER --&gt;|&quot;保证可见性&quot;| MUTEX
    MUTEX --&gt;|&quot;配合使用&quot;| COND
    
    note[&quot;OS 原语 = CPU 原语 + 线程调度 + 等待队列&lt;br/&gt;OS 原语提供了线程阻塞/唤醒的能力&lt;br/&gt;CPU 原语只能自旋等待&quot;]
    style note fill:#fff9c4</code></pre>
<p><strong>为什么需要操作系统原语？</strong></p>
<p>CPU 指令原语（如 CAS）只能实现<strong>自旋等待</strong>——线程不断循环检查条件是否满足。这种方式在等待时间短时效率很高，但如果等待时间长，会浪费大量 CPU 资源。</p>
<p>操作系统原语（如 Mutex）提供了<strong>阻塞等待</strong>的能力——线程可以被挂起，不占用 CPU，等条件满足时再被唤醒。这需要操作系统内核的支持，因为只有内核才能控制线程的调度。</p>
<table>
<thead>
<tr>
<th>等待方式</th>
<th>实现基础</th>
<th>CPU 占用</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>自旋等待</strong></td>
<td>CPU 指令原语（CAS）</td>
<td>高（持续占用 CPU）</td>
<td>等待时间极短（&lt; 几微秒）</td>
</tr>
<tr>
<td><strong>阻塞等待</strong></td>
<td>OS 原语（Mutex）</td>
<td>低（线程挂起）</td>
<td>等待时间较长（&gt; 几微秒）</td>
</tr>
</tbody>
</table>
<p>这也解释了为什么 JVM 的锁优化策略是&quot;先自旋，后阻塞&quot;——先用 CPU 原语尝试快速获取锁，如果失败再退化到 OS 原语进行阻塞等待。</p>
<p><strong>核心问题：ObjectMonitor 是如何实现线程阻塞和唤醒的？</strong></p>
<p>前面我们知道，重量级锁的核心是 ObjectMonitor，它管理着 Owner、EntryList、WaitSet 等数据结构。但 ObjectMonitor 本身只是一个 JVM 层面的 C++ 对象，它<strong>无法直接让线程阻塞或唤醒</strong>——这些操作必须依赖操作系统提供的同步原语。</p>
<p><strong>图1：从 synchronized 到操作系统的完整调用链</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Java 层&quot;
        SYNC[&quot;synchronized(obj)&quot;]
        style SYNC fill:#c8e6c9
    end
    
    subgraph &quot;JVM 层（HotSpot C++）&quot;
        INTERP[&quot;字节码解释器&lt;br/&gt;monitorenter/monitorexit&quot;]
        OBJMON[&quot;ObjectMonitor&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;enter() / exit()&lt;br/&gt;wait() / notify()&quot;]
        PARKER[&quot;Parker&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;park() / unpark()&lt;br/&gt;每个线程一个 Parker 实例&quot;]
        
        INTERP --&gt; OBJMON
        OBJMON --&gt;|&quot;竞争失败&lt;br/&gt;需要阻塞&quot;| PARKER
        
        style INTERP fill:#fff9c4
        style OBJMON fill:#ffcc80
        style PARKER fill:#ffab91
    end
    
    subgraph &quot;操作系统层&quot;
        subgraph &quot;Linux&quot;
            FUTEX[&quot;futex()&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Fast Userspace Mutex&lt;br/&gt;用户态/内核态混合&quot;]
            PTHREAD_L[&quot;pthread_mutex_t&lt;br/&gt;pthread_cond_t&quot;]
            FUTEX --&gt; PTHREAD_L
            style FUTEX fill:#e1bee7
            style PTHREAD_L fill:#ce93d8
        end
        
        subgraph &quot;macOS/BSD&quot;
            PTHREAD_M[&quot;pthread_mutex_t&lt;br/&gt;pthread_cond_t&quot;]
            style PTHREAD_M fill:#ce93d8
        end
        
        subgraph &quot;Windows&quot;
            CRITICAL[&quot;CRITICAL_SECTION&lt;br/&gt;WaitForSingleObject&quot;]
            style CRITICAL fill:#90caf9
        end
    end
    
    PARKER --&gt;|&quot;Linux&quot;| FUTEX
    PARKER --&gt;|&quot;macOS&quot;| PTHREAD_M
    PARKER --&gt;|&quot;Windows&quot;| CRITICAL
    
    note1[&quot;关键洞察：&lt;br/&gt;ObjectMonitor 不直接调用 OS 原语&lt;br/&gt;而是通过 Parker 这个中间层&lt;br/&gt;Parker 封装了跨平台的阻塞/唤醒逻辑&quot;]
    style note1 fill:#e1f5ff</code></pre>
<p><strong>图2：ObjectMonitor 内部的同步机制</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;ObjectMonitor 内部结构&quot;
        direction TB
        
        subgraph &quot;数据字段&quot;
            OWNER[&quot;_owner&lt;br/&gt;当前持锁线程&quot;]
            ENTRY[&quot;_EntryList&lt;br/&gt;阻塞等待队列&quot;]
            WAIT[&quot;_WaitSet&lt;br/&gt;wait() 等待集合&quot;]
            CXQUEUE[&quot;_cxq&lt;br/&gt;竞争队列（新来的线程）&quot;]
            style OWNER fill:#ffcdd2
            style ENTRY fill:#fff9c4
            style WAIT fill:#e1bee7
            style CXQUEUE fill:#b2dfdb
        end
        
        subgraph &quot;同步原语（平台相关）&quot;
            MUTEX[&quot;底层 Mutex&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;保护 ObjectMonitor 自身&lt;br/&gt;的数据结构一致性&quot;]
            EVENT[&quot;Park/Unpark 事件&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;用于线程阻塞/唤醒&quot;]
            style MUTEX fill:#ffcc80
            style EVENT fill:#ffab91
        end
    end
    
    subgraph &quot;线程状态转换&quot;
        T_RUN[&quot;RUNNABLE&lt;br/&gt;运行中&quot;]
        T_BLOCK[&quot;BLOCKED&lt;br/&gt;阻塞等待锁&quot;]
        T_WAIT[&quot;WAITING&lt;br/&gt;wait() 等待&quot;]
        
        T_RUN --&gt;|&quot;获取锁失败&lt;br/&gt;park()&quot;| T_BLOCK
        T_BLOCK --&gt;|&quot;获取锁成功&lt;br/&gt;unpark()&quot;| T_RUN
        T_RUN --&gt;|&quot;调用 wait()&lt;br/&gt;park()&quot;| T_WAIT
        T_WAIT --&gt;|&quot;被 notify()&lt;br/&gt;unpark()&quot;| T_BLOCK
        
        style T_RUN fill:#c8e6c9
        style T_BLOCK fill:#ffcdd2
        style T_WAIT fill:#e1bee7
    end
    
    MUTEX -.-&gt;|&quot;保护&quot;| OWNER
    MUTEX -.-&gt;|&quot;保护&quot;| ENTRY
    MUTEX -.-&gt;|&quot;保护&quot;| WAIT
    EVENT -.-&gt;|&quot;阻塞/唤醒&quot;| T_BLOCK
    EVENT -.-&gt;|&quot;阻塞/唤醒&quot;| T_WAIT</code></pre>
<p><strong>ObjectMonitor 与 OS 原语的对应关系：</strong></p>
<table>
<thead>
<tr>
<th>ObjectMonitor 操作</th>
<th>对应的 OS 原语</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>enter()</code> 获取锁失败</td>
<td><code>pthread_mutex_lock()</code> 或 <code>futex(FUTEX_WAIT)</code></td>
<td>线程阻塞，进入 EntryList</td>
</tr>
<tr>
<td><code>exit()</code> 释放锁</td>
<td><code>pthread_mutex_unlock()</code> 或 <code>futex(FUTEX_WAKE)</code></td>
<td>唤醒 EntryList 中的线程</td>
</tr>
<tr>
<td><code>wait()</code></td>
<td><code>pthread_cond_wait()</code></td>
<td>释放锁，进入 WaitSet，阻塞</td>
</tr>
<tr>
<td><code>notify()</code></td>
<td><code>pthread_cond_signal()</code></td>
<td>从 WaitSet 移动一个线程到 EntryList</td>
</tr>
<tr>
<td><code>notifyAll()</code></td>
<td><code>pthread_cond_broadcast()</code></td>
<td>移动 WaitSet 中所有线程到 EntryList</td>
</tr>
</tbody>
</table>
<p><strong>图3：Linux 上的 Futex 优化机制</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Futex 的设计理念&quot;
        direction TB
        
        subgraph &quot;无竞争路径（Fast Path）&quot;
            FAST[&quot;用户态 CAS 操作&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;直接修改 futex word&lt;br/&gt;不进入内核&lt;br/&gt;开销：≈ 几十个 CPU 周期&quot;]
            style FAST fill:#c8e6c9
        end
        
        subgraph &quot;有竞争路径（Slow Path）&quot;
            SLOW[&quot;futex() 系统调用&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;进入内核&lt;br/&gt;线程阻塞在内核等待队列&lt;br/&gt;开销：≈ 几千个 CPU 周期&quot;]
            style SLOW fill:#ffcdd2
        end
    end
    
    subgraph &quot;与 JVM 锁的对应&quot;
        LIGHT_LOCK[&quot;轻量级锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;类似 Futex Fast Path&lt;br/&gt;用户态 CAS + 自旋&quot;]
        HEAVY_LOCK[&quot;重量级锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;类似 Futex Slow Path&lt;br/&gt;进入内核阻塞&quot;]
        
        style LIGHT_LOCK fill:#fff9c4
        style HEAVY_LOCK fill:#ffcc80
    end
    
    FAST -.-&gt;|&quot;设计理念相同&quot;| LIGHT_LOCK
    SLOW -.-&gt;|&quot;设计理念相同&quot;| HEAVY_LOCK
    
    note1[&quot;Futex = Fast Userspace Mutex&lt;br/&gt;核心思想：无竞争时在用户态解决&lt;br/&gt;有竞争时才进入内核&lt;br/&gt;这与 JVM 锁优化的思想一致！&quot;]
    style note1 fill:#e1f5ff</code></pre>
<p><strong>图4：完整的锁获取流程（从 Java 到内核）</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Java as Java 代码
    participant JVM as JVM (HotSpot)
    participant Monitor as ObjectMonitor
    participant Parker as Parker
    participant OS as 操作系统内核
    
    Java-&gt;&gt;JVM: synchronized(obj)
    JVM-&gt;&gt;JVM: 检查 Mark Word
    
    alt 偏向锁/轻量级锁成功
        JVM-&gt;&gt;Java: 获取锁成功（用户态完成）
    else 需要重量级锁
        JVM-&gt;&gt;Monitor: 获取 ObjectMonitor
        Monitor-&gt;&gt;Monitor: 尝试 CAS 设置 _owner
        
        alt CAS 成功
            Monitor-&gt;&gt;Java: 获取锁成功
        else CAS 失败（有竞争）
            Monitor-&gt;&gt;Monitor: 自旋尝试
            
            alt 自旋成功
                Monitor-&gt;&gt;Java: 获取锁成功
            else 自旋失败
                Monitor-&gt;&gt;Parker: 调用 park()
                Parker-&gt;&gt;OS: futex(FUTEX_WAIT) / pthread_mutex_lock()
                Note over OS: 线程阻塞在内核
                OS--&gt;&gt;Parker: 被唤醒
                Parker--&gt;&gt;Monitor: park() 返回
                Monitor-&gt;&gt;Monitor: 重新竞争锁
            end
        end
    end</code></pre>
<p><strong>为什么需要 Parker 这个中间层？</strong></p>
<blockquote>
<p><strong>重要说明</strong>：Parker <strong>不是 Java 类</strong>，而是 <strong>HotSpot JVM 中的 C++ 类</strong>，定义在 <code>hotspot/src/share/runtime/park.hpp</code> 文件中。每个 Java 线程在 JVM 内部都有一个对应的 <code>Parker</code> 对象实例。你在 Java 代码中找不到 <code>Parker</code> 类，因为它完全存在于 JVM 的 native 层。</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// hotspot/src/share/runtime/park.hpp（简化）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parker</span> : <span class="hljs-keyword">public</span> os::PlatformParker &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> _counter;  <span class="hljs-comment">// permit 计数器（0 或 1）</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">park</span><span class="hljs-params">(<span class="hljs-type">bool</span> isAbsolute, jlong time)</span></span>;  <span class="hljs-comment">// 阻塞线程</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">()</span></span>;                            <span class="hljs-comment">// 唤醒线程</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p>Parker 的设计目的：</p>
<ol>
<li><strong>跨平台抽象</strong>：不同操作系统的阻塞原语不同（Linux 用 futex/pthread，Windows 用 Event），Parker 提供统一接口</li>
<li><strong>性能优化</strong>：Parker 可以实现&quot;先自旋再阻塞&quot;的策略，减少不必要的系统调用</li>
<li><strong>与 LockSupport 对接</strong>：Java 层的 <code>LockSupport.park()/unpark()</code> 最终调用的就是 Parker</li>
</ol>
<p><strong>调用链路</strong>：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">Java: LockSupport.<span class="hljs-built_in">park</span>()<br>  → JNI: Unsafe.<span class="hljs-built_in">park</span>()<br>    → JVM C++: Parker::<span class="hljs-built_in">park</span>()<br>      → OS: <span class="hljs-built_in">pthread_cond_wait</span>() / <span class="hljs-built_in">futex</span>() / <span class="hljs-built_in">WaitForSingleObject</span>()<br></code></pre></td></tr></table></figure>
<p><strong>关键理解：两层 Mutex 的区别</strong></p>
<p>很多人容易混淆的一点是：ObjectMonitor 内部有一个 Mutex，操作系统也有 Mutex，它们是什么关系？</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>Mutex 用途</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ObjectMonitor 内部 Mutex</strong></td>
<td>保护 ObjectMonitor 自身的数据结构</td>
<td>确保多线程并发修改 <code>_owner</code>、<code>_EntryList</code> 等字段时的一致性</td>
</tr>
<tr>
<td><strong>OS Mutex（通过 Parker）</strong></td>
<td>实现线程的阻塞和唤醒</td>
<td>当线程需要等待时，真正让 CPU 不再调度该线程</td>
</tr>
</tbody>
</table>
<p>简单来说：</p>
<ul>
<li><strong>ObjectMonitor 的 Mutex</strong> 是为了保护&quot;锁的元数据&quot;</li>
<li><strong>OS 的 Mutex/Futex</strong> 是为了实现&quot;线程的阻塞&quot;</li>
</ul>
<p>这就像一个银行：</p>
<ul>
<li>银行内部的保险柜锁（ObjectMonitor Mutex）保护的是&quot;谁在排队、谁在办业务&quot;的记录</li>
<li>银行大门的锁（OS Mutex）决定的是&quot;顾客能不能进来&quot;</li>
</ul>
<p><strong>锁对象复用陷阱：</strong> 由于一个对象在任意时刻只能被一个线程锁定（monitor 只有一个 owner），如果在不同的业务逻辑中复用同一个锁对象，会导致本来毫无关联的代码互相阻塞。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BadExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <span class="hljs-comment">// 只有一个锁对象</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123; <span class="hljs-comment">/* 业务逻辑 A */</span> &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123; <span class="hljs-comment">/* 业务逻辑 B，与 A 完全无关 */</span> &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>即使 <code>methodA</code> 和 <code>methodB</code> 的业务逻辑完全独立，它们也会互相阻塞，因为竞争的是同一个对象的 monitor。正确做法是为不相关的临界区使用不同的锁对象。这个问题同样适用于 <code>ReentrantLock</code>——锁的粒度由锁对象/Lock 实例的数量决定，一个锁对象 = 一把锁 = 同一时刻只能一个线程持有。</p>
<h1>锁优化</h1>
<p><img src="synchronized%E5%8E%9F%E7%90%86.jpg" alt="synchronized原理"><br>
<img src="%E9%94%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt="锁对象的变化流程"></p>
<p>所有的锁优化其实是 synchronized 优化。</p>
<h2 id="锁优化的设计哲学：用户态锁-vs-内核态锁">锁优化的设计哲学：用户态锁 vs 内核态锁</h2>
<p><strong>核心思想：锁越轻，离底层 Mutex 机制越远，越能在 Java/JVM 内部的数据结构中解决；涉及的 JVM 外部/底层机制越少，开销就越小。</strong></p>
<p>这个设计思想与 <strong>绿色线程（Green Thread）vs内核线程（Kernel Thread）</strong> 的设计理念高度相似：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>绿色线程</th>
<th>内核线程</th>
<th>轻量级锁</th>
<th>重量级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>调度/管理者</strong></td>
<td>用户态运行时（如 JVM、Go runtime）</td>
<td>操作系统内核</td>
<td>JVM（CAS + 自旋）</td>
<td>操作系统（Mutex）</td>
</tr>
<tr>
<td><strong>切换开销</strong></td>
<td>极低（不涉及内核）</td>
<td>高（用户态/内核态切换）</td>
<td>极低（用户态 CAS）</td>
<td>高（系统调用）</td>
</tr>
<tr>
<td><strong>数据结构位置</strong></td>
<td>用户空间</td>
<td>内核空间</td>
<td>Java 栈帧（Lock Record）</td>
<td>内核 Mutex + ObjectMonitor</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>大量轻量级并发</td>
<td>需要真正并行</td>
<td>低竞争同步</td>
<td>高竞争同步</td>
</tr>
</tbody>
</table>
<p><strong>可以说，偏向锁和轻量级锁就是&quot;用户态锁&quot;，而重量级锁是&quot;内核态锁&quot;。</strong></p>
<p><strong>图：锁机制的分层架构——从用户态到内核态的渐进式下沉</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;用户态（User Space）&quot;
        subgraph &quot;纯 Java 对象层&quot;
            BIAS[&quot;偏向锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word 存储线程 ID&lt;br/&gt;后续加锁：仅比较线程 ID&lt;br/&gt;开销：≈ 0&quot;]
            style BIAS fill:#c8e6c9
        end
        
        subgraph &quot;Java 栈 + CAS 层&quot;
            LIGHT[&quot;轻量级锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word → Lock Record&lt;br/&gt;Lock Record 在线程栈帧中&lt;br/&gt;开销：CAS + 自旋&quot;]
            style LIGHT fill:#fff9c4
        end
        
        subgraph &quot;JVM 运行时层&quot;
            MONITOR[&quot;ObjectMonitor&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;JVM C++ 对象&lt;br/&gt;管理 Owner/EntryList/WaitSet&quot;]
            style MONITOR fill:#ffcc80
        end
    end
    
    subgraph &quot;内核态（Kernel Space）&quot;
        MUTEX[&quot;OS Mutex / Futex&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;操作系统同步原语&lt;br/&gt;线程阻塞/唤醒&lt;br/&gt;开销：用户态/内核态切换&quot;]
        style MUTEX fill:#ffcdd2
    end
    
    BIAS --&gt;|&quot;出现竞争&lt;br/&gt;撤销偏向&quot;| LIGHT
    LIGHT --&gt;|&quot;竞争激烈&lt;br/&gt;自旋失败&quot;| MONITOR
    MONITOR --&gt;|&quot;阻塞线程&lt;br/&gt;系统调用&quot;| MUTEX
    
    note1[&quot;越往下，离 Java 越远，离 OS 越近&lt;br/&gt;开销越大，但能处理的竞争越激烈&quot;]
    style note1 fill:#e1f5ff</code></pre>
<h3 id="锁升级的标志性事件">锁升级的标志性事件</h3>
<p>锁的状态转换不是随机发生的，而是由<strong>明确的、可识别的标志性事件</strong>触发。理解这些事件是理解锁优化的关键：</p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;锁状态&quot;
        UNLOCKED[&quot;无锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word 存储：&lt;br/&gt;hashCode + age + 0|01&quot;]
        BIASED[&quot;偏向锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word 存储：&lt;br/&gt;ThreadID + epoch + 1|01&quot;]
        LIGHT[&quot;轻量级锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word 存储：&lt;br/&gt;Lock Record 指针 + 00&quot;]
        HEAVY[&quot;重量级锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word 存储：&lt;br/&gt;Monitor 指针 + 10&quot;]
    end
    
    UNLOCKED --&gt;|&quot;事件①&lt;br/&gt;首次加锁&quot;| BIASED
    BIASED --&gt;|&quot;事件②&lt;br/&gt;第二个线程尝试获取锁&quot;| LIGHT
    LIGHT --&gt;|&quot;事件③&lt;br/&gt;CAS 竞争失败&quot;| HEAVY
    
    style UNLOCKED fill:#e8f5e9
    style BIASED fill:#c8e6c9
    style LIGHT fill:#fff9c4
    style HEAVY fill:#ffcdd2</code></pre>
<p><strong>锁升级的标志性事件详解：</strong></p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发条件</th>
<th>状态转换</th>
<th>具体表现</th>
<th>为什么触发升级</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>事件①：首次加锁</strong></td>
<td>对象第一次被 <code>synchronized</code></td>
<td>无锁 → 偏向锁</td>
<td>CAS 将当前线程 ID 写入 Mark Word</td>
<td>假设锁总是被同一线程获取</td>
</tr>
<tr>
<td><strong>事件②：第二个线程尝试获取锁</strong></td>
<td>另一个线程尝试获取已偏向的锁</td>
<td>偏向锁 → 轻量级锁</td>
<td>撤销偏向，两个线程都创建 Lock Record，CAS 竞争</td>
<td>偏向假设被打破，需要真正的同步机制</td>
</tr>
<tr>
<td><strong>事件③：CAS 竞争失败</strong></td>
<td>线程 CAS 设置 Lock Record 指针失败</td>
<td>轻量级锁 → 重量级锁</td>
<td>创建 ObjectMonitor，失败线程进入 EntryList 阻塞</td>
<td>CAS 失败意味着存在真正的并发竞争</td>
</tr>
</tbody>
</table>
<p><strong>关键理解：什么是&quot;竞争&quot;？</strong></p>
<p>在锁优化的语境下，&quot;竞争&quot;有精确的定义：</p>
<table>
<thead>
<tr>
<th>竞争类型</th>
<th>定义</th>
<th>锁状态</th>
<th>处理方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无竞争</strong></td>
<td>始终只有一个线程访问锁</td>
<td>偏向锁</td>
<td>仅记录线程 ID，无需同步</td>
</tr>
<tr>
<td><strong>交替访问（无真正竞争）</strong></td>
<td>多个线程访问锁，但不同时</td>
<td>轻量级锁</td>
<td>CAS 总能成功，无需阻塞</td>
</tr>
<tr>
<td><strong>真正竞争</strong></td>
<td>多个线程同时尝试获取锁</td>
<td>重量级锁</td>
<td>CAS 失败，需要阻塞等待</td>
</tr>
</tbody>
</table>
<p><strong>偏向锁 vs 轻量级锁的本质区别：</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>偏向锁</th>
<th>轻量级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>假设场景</strong></td>
<td>锁始终被同一个线程获取</td>
<td>锁被多个线程交替获取，但不同时</td>
</tr>
<tr>
<td><strong>加锁操作</strong></td>
<td>首次 CAS，后续仅比较线程 ID</td>
<td>每次都需要 CAS</td>
</tr>
<tr>
<td><strong>数据结构</strong></td>
<td>仅 Mark Word（存线程 ID）</td>
<td>Mark Word + Lock Record</td>
</tr>
<tr>
<td><strong>升级触发</strong></td>
<td>第二个线程出现</td>
<td>CAS 失败（真正竞争）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>单线程反复进入同步块</td>
<td>多线程交替进入同步块</td>
</tr>
</tbody>
</table>
<p><strong>为什么这种分层设计是高效的？</strong></p>
<p>观察 Mark Word 在不同锁状态下的内容变化，可以发现一个清晰的<strong>局部性原则</strong>：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>数据存储位置</th>
<th>依赖层级</th>
<th>涉及的外部机制</th>
<th>性能开销</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无锁</strong></td>
<td>Mark Word 直接存储 hashCode、age</td>
<td>纯 Java 对象</td>
<td>无</td>
<td>无额外开销</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>Mark Word 存储线程 ID</td>
<td>纯 Java 对象</td>
<td>无（仅首次 CAS）</td>
<td>≈ 0</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>Mark Word → Lock Record（线程栈帧）</td>
<td>Java 栈 + CPU CAS 指令</td>
<td>CPU 原子指令</td>
<td>用户态自旋</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>Mark Word → ObjectMonitor → OS Mutex</td>
<td>操作系统内核</td>
<td>系统调用、内核调度器</td>
<td>用户态/内核态切换</td>
</tr>
</tbody>
</table>
<p><strong>这种设计体现了&quot;能在用户态解决的问题，就不要下沉到内核态&quot;的优化原则：</strong></p>
<ol>
<li>
<p><strong>偏向锁（纯用户态，零开销）</strong>：假设锁总是被同一个线程获取，直接在 Mark Word 中记录线程 ID，后续加锁只需比较线程 ID，连 CAS 都省了。这是最乐观的假设，完全在 Java 对象层面解决，<strong>不涉及任何 JVM 外部机制</strong>。</p>
</li>
<li>
<p><strong>轻量级锁（用户态，低开销）</strong>：当出现竞争时，退而求其次，使用 CAS + 自旋的方式在用户态解决。Lock Record 存储在线程栈帧中，仍然是 Java 层面的数据结构。虽然 CAS 需要 CPU 提供原子指令支持，但<strong>不涉及操作系统调用</strong>，仍在用户态完成。</p>
</li>
<li>
<p><strong>重量级锁（内核态，高开销）</strong>：当竞争激烈、自旋无法快速获取锁时，才不得不&quot;下沉&quot;到操作系统层面，使用 Mutex/Futex 等同步原语。此时 Mark Word 指向 ObjectMonitor，而 ObjectMonitor 内部会调用操作系统的阻塞/唤醒机制，<strong>触发用户态/内核态切换</strong>。</p>
</li>
</ol>
<p><strong>与绿色线程的类比深化：</strong></p>
<table>
<thead>
<tr>
<th>设计理念</th>
<th>绿色线程</th>
<th>轻量级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心思想</strong></td>
<td>用户态调度替代内核态调度</td>
<td>用户态同步替代内核态同步</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td>M:N 模型，多个用户态线程映射到少量内核线程</td>
<td>CAS + 自旋，在用户态完成锁的获取和释放</td>
</tr>
<tr>
<td><strong>优势</strong></td>
<td>避免内核态切换开销，支持大量轻量级并发</td>
<td>避免系统调用开销，支持低竞争场景的高效同步</td>
</tr>
<tr>
<td><strong>局限性</strong></td>
<td>无法利用多核并行（除非有内核线程支撑）</td>
<td>无法处理高竞争场景（必须膨胀为重量级锁）</td>
</tr>
<tr>
<td><strong>典型实现</strong></td>
<td>Go goroutine、Erlang process、Java 虚拟线程</td>
<td>JVM 偏向锁、轻量级锁</td>
</tr>
</tbody>
</table>
<p><strong>但有一个关键区别</strong>：绿色线程可以<strong>完全替代</strong>内核线程（如 Go 的 goroutine 在大多数场景下足够），而轻量级锁<strong>不能完全替代</strong>重量级锁——当竞争激烈时，自旋会浪费大量 CPU，必须膨胀为重量级锁让线程阻塞等待。</p>
<p><strong>为什么锁只能升级不能降级？</strong></p>
<p>这也解释了为什么锁只能升级不能降级：一旦发现竞争激烈到需要重量级锁，说明这个锁的使用场景确实存在高并发竞争，降级回轻量级锁反而会因为频繁的 CAS 失败和自旋浪费更多 CPU 资源。这就像一个服务发现单机处理不了流量后扩容到集群，即使流量下降也不会立即缩容——因为流量模式已经证明了需要更高的处理能力。</p>
<p><strong>总结：锁优化的本质是&quot;就近原则&quot;</strong></p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">问题能在 <span class="hljs-variable">Java</span> 对象层解决 → 偏向锁（<span class="hljs-variable">Mark</span> <span class="hljs-built_in">Word</span> 存线程 <span class="hljs-variable">ID</span>）<br>问题能在 <span class="hljs-variable">Java</span> 栈层解决   → 轻量级锁（<span class="hljs-variable">Lock</span> <span class="hljs-built_in">Record</span> <span class="hljs-operator">+</span> <span class="hljs-variable">CAS</span>）<br>问题必须在 <span class="hljs-variable">OS</span> 层解决     → 重量级锁（<span class="hljs-variable">ObjectMonitor</span> <span class="hljs-operator">+</span> <span class="hljs-variable">Mutex</span>）<br></code></pre></td></tr></table></figure>
<p><strong>离问题发生地越近的解决方案，开销越小。</strong> 这与计算机体系结构中的&quot;局部性原理&quot;一脉相承：CPU 缓存比内存快，内存比磁盘快，本地调用比远程调用快——同样，用户态同步比内核态同步快。</p>
<h3 id="三种锁对-mark-word-的处理策略">三种锁对 Mark Word 的处理策略</h3>
<p>理解三种锁的本质差异，关键在于理解它们如何处理 Mark Word 中的原始信息（hashCode、GC age 等）：</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>Mark Word 处理方式</th>
<th>原始信息存储位置</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>偏向锁</strong></td>
<td>原地复用 Mark Word，用 threadId 替换 hashCode 字段</td>
<td>无需备份（但 hashCode 与偏向锁互斥）</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>Mark Word 被替换为指向 Lock Record 的指针</td>
<td>Lock Record 的 Displaced Mark Word 字段</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>Mark Word 被替换为指向 ObjectMonitor 的指针</td>
<td>ObjectMonitor 的 <code>_header</code> 字段</td>
</tr>
</tbody>
</table>
<p>这个设计体现了一个核心权衡：</p>
<ul>
<li><strong>偏向锁</strong>是&quot;原地操作&quot;，不需要额外的数据结构来保存原始 Mark Word，因此最轻量。代价是 hashCode 和 threadId 互斥，调用 <code>hashCode()</code> 会导致偏向锁失效。</li>
<li><strong>轻量级锁和重量级锁</strong>都是&quot;指针替换&quot;，需要将原始 Mark Word 转移到别处保存（Lock Record 或 ObjectMonitor），解锁时再恢复。这也解释了为什么轻量级锁解锁时必须用 CAS 把 Displaced Mark Word 写回——就是为了恢复原始信息。</li>
</ul>
<h3 id="三种锁的数据结构对比">三种锁的数据结构对比</h3>
<p>理解三种锁的本质差异，关键在于理解它们各自的数据结构：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;偏向锁：最轻量，无额外数据结构&quot;
        direction TB
        
        OBJ_BIAS[&quot;锁对象 obj&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word:&lt;br/&gt;threadId | epoch | age | 1 | 01&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;直接在 Mark Word 中&lt;br/&gt;记录偏向线程 ID&quot;]
        
        THREAD_BIAS[&quot;偏向线程&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;无需任何额外数据结构&lt;br/&gt;只需检查 Mark Word 中的&lt;br/&gt;threadId 是否是自己&quot;]
        
        OBJ_BIAS -.-&gt;|&quot;threadId 记录在&lt;br/&gt;Mark Word 中&quot;| THREAD_BIAS
        
        style OBJ_BIAS fill:#e8f5e9
        style THREAD_BIAS fill:#e8f5e9
    end</code></pre>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;轻量级锁：一个 Lock Record，无等待队列&quot;
        direction TB
        
        OBJ_LIGHT[&quot;锁对象 obj&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word:&lt;br/&gt;ptr_to_lock_record | 00&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;指向持锁线程栈上的&lt;br/&gt;Lock Record&quot;]
        
        LR_LIGHT[&quot;Lock Record（栈上）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word&lt;br/&gt;（原始 Mark Word 备份）&lt;br/&gt;owner → obj&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;无 WaitSet&lt;br/&gt;无 EntryList&lt;br/&gt;无 Mutex&quot;]
        
        THREAD_LIGHT[&quot;持锁线程&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Lock Record 在其栈帧中&quot;]
        
        OTHER_LIGHT[&quot;竞争线程&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;CAS 自旋重试&lt;br/&gt;不阻塞、不排队&quot;]
        
        OBJ_LIGHT --&gt;|&quot;Mark Word 指向&quot;| LR_LIGHT
        LR_LIGHT --&gt;|&quot;在栈帧中&quot;| THREAD_LIGHT
        OTHER_LIGHT -.-&gt;|&quot;CAS 失败后自旋&quot;| OBJ_LIGHT
        
        style OBJ_LIGHT fill:#e1f5ff
        style LR_LIGHT fill:#e1f5ff
        style THREAD_LIGHT fill:#c8e6c9
        style OTHER_LIGHT fill:#fff9c4
    end</code></pre>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;重量级锁：完整的 Monitor 结构&quot;
        direction TB
        
        OBJ_HEAVY[&quot;锁对象 obj&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word:&lt;br/&gt;ptr_to_monitor | 10&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;指向 ObjectMonitor&quot;]
        
        MONITOR[&quot;ObjectMonitor（C++ 堆）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;_header: 原始 Mark Word&lt;br/&gt;_owner: → 持锁线程&lt;br/&gt;_recursions: 重入计数&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;_cxq: 竞争队列&lt;br/&gt;_EntryList: 阻塞等待队列&lt;br/&gt;_WaitSet: wait() 等待队列&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;底层同步原语&quot;]
        
        MUTEX[&quot;pthread_mutex_t&lt;br/&gt;（OS 互斥量）&quot;]
        
        COND[&quot;pthread_cond_t&lt;br/&gt;（条件变量）&quot;]
        
        OWNER[&quot;持锁线程&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;_owner 指向它&quot;]
        
        WAITING[&quot;等待线程们&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;在 _EntryList 中阻塞&lt;br/&gt;或在 _WaitSet 中等待&quot;]
        
        OBJ_HEAVY --&gt;|&quot;Mark Word 指向&quot;| MONITOR
        MONITOR --&gt;|&quot;_owner&quot;| OWNER
        MONITOR --&gt;|&quot;_EntryList / _WaitSet&quot;| WAITING
        MONITOR --&gt;|&quot;封装&quot;| MUTEX
        MONITOR --&gt;|&quot;封装&quot;| COND
        MUTEX --&gt;|&quot;系统调用&quot;| KERNEL[&quot;内核态&quot;]
        
        style OBJ_HEAVY fill:#ffcdd2
        style MONITOR fill:#ffcdd2
        style MUTEX fill:#ffcdd2
        style COND fill:#ffcdd2
        style OWNER fill:#c8e6c9
        style WAITING fill:#fff9c4
        style KERNEL fill:#ffcdd2
    end</code></pre>
<p><strong>三种锁的本质区别总结：</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>偏向锁</th>
<th>轻量级锁</th>
<th>重量级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Mark Word 内容</strong></td>
<td>偏向线程 ID</td>
<td>指向 Lock Record 的指针</td>
<td>指向 ObjectMonitor 的指针</td>
</tr>
<tr>
<td><strong>额外数据结构</strong></td>
<td>无</td>
<td>Lock Record（栈上，1个）</td>
<td>ObjectMonitor（C++ 堆，含多个队列）</td>
</tr>
<tr>
<td><strong>持锁线程记录</strong></td>
<td>Mark Word 中的 threadId</td>
<td>Mark Word 指向的 Lock Record 所在栈帧</td>
<td>Monitor 的 _owner 字段</td>
</tr>
<tr>
<td><strong>等待队列</strong></td>
<td>无</td>
<td>无（自旋重试）</td>
<td>有（_EntryList、_WaitSet、_cxq）</td>
</tr>
<tr>
<td><strong>底层同步原语</strong></td>
<td>无</td>
<td>CAS 指令</td>
<td>OS Mutex + Condition Variable</td>
</tr>
<tr>
<td><strong>竞争失败处理</strong></td>
<td>撤销偏向，升级</td>
<td>CAS 自旋，超时则膨胀</td>
<td>阻塞，进入等待队列</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>单线程反复获取同一把锁</td>
<td>多线程交替获取锁，竞争不激烈</td>
<td>多线程激烈竞争</td>
</tr>
</tbody>
</table>
<p><strong>关键理解：</strong></p>
<ol>
<li>
<p><strong>偏向锁</strong>：最轻量，直接在 Mark Word 中记录偏向线程 ID，无任何额外数据结构。相当于&quot;这把锁归你了，以后你来就直接进&quot;。</p>
</li>
<li>
<p><strong>轻量级锁</strong>：Mark Word 指向持锁线程栈上的 Lock Record。Lock Record 只保存原始 Mark Word 的备份，<strong>不包含任何等待队列</strong>。竞争失败的线程只能 CAS 自旋重试，不会被阻塞。</p>
</li>
<li>
<p><strong>重量级锁</strong>：Mark Word 指向 ObjectMonitor，Monitor 是一个完整的同步结构，包含：</p>
<ul>
<li><code>_owner</code>：指向持锁线程</li>
<li><code>_EntryList</code>：阻塞等待获取锁的线程队列</li>
<li><code>_WaitSet</code>：调用 <code>wait()</code> 后等待被 <code>notify()</code> 的线程队列</li>
<li><code>_cxq</code>：竞争队列（新来的竞争者先进这里）</li>
<li>底层封装了 OS 的 Mutex 和 Condition Variable</li>
</ul>
</li>
</ol>
<h4 id="objectmonitor-的三个队列：cxq-entrylist-waitset-详解">ObjectMonitor 的三个队列：cxq、EntryList、WaitSet 详解</h4>
<p>ObjectMonitor 中的三个队列各有不同的职责，理解它们的区别是理解 synchronized 底层机制的关键：</p>
<table>
<thead>
<tr>
<th>队列</th>
<th>全称</th>
<th>用途</th>
<th>线程来源</th>
<th>数据结构</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>_cxq</strong></td>
<td>Contention Queue</td>
<td>新竞争线程的入口队列</td>
<td>新到达的、尝试获取锁失败的线程</td>
<td>单向链表（LIFO）</td>
</tr>
<tr>
<td><strong>_EntryList</strong></td>
<td>Entry List</td>
<td>等待获取锁的正式队列</td>
<td>从 cxq 转移过来的线程</td>
<td>双向链表</td>
</tr>
<tr>
<td><strong>_WaitSet</strong></td>
<td>Wait Set</td>
<td>调用 wait() 后等待的线程</td>
<td>调用 Object.wait() 的线程</td>
<td>双向循环链表</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;ObjectMonitor 的三个队列&quot;
        direction TB
        
        NEW_THREAD[&quot;新到达的竞争线程&quot;]
        
        subgraph CXQ[&quot;_cxq（Contention Queue）&quot;]
            CXQ_DESC[&quot;新竞争者入口&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 单向链表，LIFO 顺序&lt;br/&gt;• 新线程从头部插入&lt;br/&gt;• 锁释放时可能整体转移到 EntryList&quot;]
            C1[&quot;线程 C&quot;] --&gt; C2[&quot;线程 B&quot;] --&gt; C3[&quot;线程 A&quot;]
        end
        
        subgraph ENTRYLIST[&quot;_EntryList&quot;]
            EL_DESC[&quot;正式等待队列&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 双向链表&lt;br/&gt;• 锁释放时从这里唤醒线程&lt;br/&gt;• 被唤醒的线程竞争 _owner&quot;]
            E1[&quot;线程 X&quot;] &lt;--&gt; E2[&quot;线程 Y&quot;] &lt;--&gt; E3[&quot;线程 Z&quot;]
        end
        
        subgraph WAITSET[&quot;_WaitSet&quot;]
            WS_DESC[&quot;wait() 等待队列&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 双向循环链表&lt;br/&gt;• 调用 wait() 的线程进入&lt;br/&gt;• notify() 后转移到 EntryList 或 cxq&quot;]
            W1[&quot;线程 P&quot;] &lt;--&gt; W2[&quot;线程 Q&quot;] &lt;--&gt; W3[&quot;线程 R&quot;]
            W3 &lt;-.-&gt; W1
        end
        
        OWNER[&quot;_owner&lt;br/&gt;当前持锁线程&quot;]
        
        NEW_THREAD --&gt;|&quot;1. 获取锁失败&quot;| CXQ
        CXQ --&gt;|&quot;2. 锁释放时转移&quot;| ENTRYLIST
        ENTRYLIST --&gt;|&quot;3. 被唤醒后竞争&quot;| OWNER
        OWNER --&gt;|&quot;4. 调用 wait()&quot;| WAITSET
        WAITSET --&gt;|&quot;5. 被 notify()&quot;| ENTRYLIST
        
        style OWNER fill:#c8e6c9
        style CXQ fill:#fff9c4
        style ENTRYLIST fill:#e1f5ff
        style WAITSET fill:#ffcdd2
    end</code></pre>
<p><strong>为什么需要两个入口队列（cxq 和 EntryList）？</strong></p>
<p>这是一个性能优化设计：</p>
<ol>
<li><strong>cxq 是&quot;快速入口&quot;</strong>：新线程竞争锁失败时，直接 CAS 插入 cxq 头部（LIFO），这个操作非常快，不需要获取任何锁</li>
<li><strong>EntryList 是&quot;正式队列&quot;</strong>：锁释放时，持锁线程会将 cxq 中的线程批量转移到 EntryList，然后从 EntryList 中唤醒线程</li>
<li><strong>分离的好处</strong>：入队操作（插入 cxq）和出队操作（从 EntryList 唤醒）在不同的队列上进行，减少了竞争</li>
</ol>
<p><strong>为什么 ObjectMonitor 有 cxq，而 AQS 没有？</strong></p>
<p>这是一个很好的问题。AQS 确实没有 cxq 这样的结构，但两者都实现了&quot;无锁入队&quot;的目标，只是方式不同：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>ObjectMonitor</th>
<th>AQS</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>入队结构</strong></td>
<td>cxq（单向链表，LIFO）</td>
<td>sync queue（双向链表，FIFO）</td>
</tr>
<tr>
<td><strong>入队方式</strong></td>
<td>CAS 插入 cxq 头部</td>
<td>CAS 设置 tail 指针</td>
</tr>
<tr>
<td><strong>是否需要额外队列</strong></td>
<td>需要 cxq + EntryList</td>
<td>不需要，直接操作 sync queue</td>
</tr>
<tr>
<td><strong>入队复杂度</strong></td>
<td>O(1) CAS 到头部</td>
<td>O(1) CAS 到尾部</td>
</tr>
</tbody>
</table>
<p><strong>为什么设计不同？</strong></p>
<ol>
<li><strong>ObjectMonitor 的历史原因</strong>：ObjectMonitor 是 JVM 早期设计的，cxq 的 LIFO 设计可能是为了简化实现（头插法比尾插法简单）</li>
<li><strong>AQS 的改进设计</strong>：AQS 设计时借鉴了 CLH 队列的思想，直接 CAS 到 tail，同样是 O(1) 操作，但保持了 FIFO 顺序</li>
<li><strong>本质相同</strong>：两者都实现了&quot;无锁入队&quot;——新线程入队时不需要获取任何锁，只需要一次 CAS 操作</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS 的入队操作（简化）</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        node.prev = pred;<br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;  <span class="hljs-comment">// CAS 到 tail，无锁入队</span><br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    enq(node);  <span class="hljs-comment">// 失败则自旋重试</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>结论</strong>：cxq 不是锁的&quot;必要&quot;组成部分，它只是 ObjectMonitor 实现无锁入队的一种方式。AQS 用另一种方式（CAS 到 tail）达到了同样的目的。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程1（持锁）
    participant T2 as 线程2（新竞争）
    participant T3 as 线程3（新竞争）
    participant CXQ as _cxq
    participant EL as _EntryList
    participant Owner as _owner
    
    Note over T1,Owner: T1 持有锁
    
    T2-&gt;&gt;CXQ: CAS 插入头部
    T3-&gt;&gt;CXQ: CAS 插入头部
    Note over CXQ: cxq: T3 → T2
    
    T1-&gt;&gt;Owner: 释放锁（_owner = null）
    T1-&gt;&gt;CXQ: 将 cxq 转移到 EntryList
    Note over EL: EntryList: T3 ↔ T2
    T1-&gt;&gt;EL: 唤醒 EntryList 头部线程
    
    T3-&gt;&gt;Owner: 竞争获取锁
    Note over T3,Owner: T3 成为新的 _owner</code></pre>
<p><strong>WaitSet 的特殊性</strong>：</p>
<p>WaitSet 与 cxq/EntryList 有本质区别：</p>
<ul>
<li><strong>cxq/EntryList</strong>：线程在等待<strong>获取锁</strong></li>
<li><strong>WaitSet</strong>：线程在等待<strong>某个条件</strong>（已经释放了锁）</li>
</ul>
<p>当线程调用 <code>wait()</code> 时：</p>
<ol>
<li>释放持有的锁（<code>_owner = null</code>）</li>
<li>进入 WaitSet 等待</li>
<li>被 <code>notify()</code> 唤醒后，转移到 EntryList 或 cxq</li>
<li>重新竞争锁，获取成功后从 <code>wait()</code> 返回</li>
</ol>
<p><strong>为什么轻量级锁不需要等待队列？</strong></p>
<p>因为轻量级锁的设计假设是&quot;竞争很少发生&quot;。在这种假设下，竞争失败的线程通过短暂的 CAS 自旋就能获取到锁，不需要排队等待。一旦自旋超过阈值（说明竞争激烈），就膨胀为重量级锁，此时才需要等待队列来管理大量等待的线程。</p>
<h4 id="synchronized-的非公平性：完整机制分析">synchronized 的非公平性：完整机制分析</h4>
<p><strong>规范层面的说明</strong>：</p>
<p>Java Language Specification (JLS 17.1) 明确指出：synchronized 只保证互斥性和 happens-before 关系，<strong>不保证任何特定的获取顺序</strong>。这意味着依赖 synchronized 公平性的代码是不正确的。</p>
<p><strong>非公平性的来源（HotSpot 实现）</strong>：</p>
<p>synchronized 的非公平性来源于<strong>多个因素的组合</strong>，而不仅仅是 cxq 的 LIFO 特性：</p>
<table>
<thead>
<tr>
<th>因素</th>
<th>描述</th>
<th>对非公平性的贡献</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>新线程直接抢占</strong></td>
<td>新线程首先尝试 CAS 获取 <code>_owner</code>，不先排队</td>
<td><strong>主要因素</strong>：新线程可以&quot;插队&quot;</td>
</tr>
<tr>
<td><strong>cxq 的 LIFO 特性</strong></td>
<td>新竞争线程从 cxq 头部插入</td>
<td>次要因素：影响等待线程间的顺序</td>
</tr>
<tr>
<td><strong>唤醒后重新竞争</strong></td>
<td>被唤醒的线程需要与新线程竞争</td>
<td>次要因素：唤醒不等于获得锁</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;synchronized 非公平性的三个来源&quot;
        direction TB
        
        subgraph SOURCE1[&quot;来源1：新线程直接抢占（主要因素）&quot;]
            S1_1[&quot;新线程到达&quot;]
            S1_2[&quot;直接尝试 CAS _owner&quot;]
            S1_3[&quot;成功则获取锁&lt;br/&gt;失败才入队&quot;]
            
            S1_1 --&gt; S1_2 --&gt; S1_3
            style S1_2 fill:#ffcdd2
        end
        
        subgraph SOURCE2[&quot;来源2：cxq 的 LIFO 特性（次要因素）&quot;]
            S2_1[&quot;线程 A 先到达&quot;]
            S2_2[&quot;线程 B 后到达&quot;]
            S2_3[&quot;cxq: B → A&quot;]
            S2_4[&quot;B 可能比 A 先被处理&quot;]
            
            S2_1 --&gt; S2_3
            S2_2 --&gt; S2_3
            S2_3 --&gt; S2_4
            style S2_3 fill:#fff9c4
        end
        
        subgraph SOURCE3[&quot;来源3：唤醒后重新竞争（次要因素）&quot;]
            S3_1[&quot;EntryList 线程被唤醒&quot;]
            S3_2[&quot;唤醒过程需要时间&quot;]
            S3_3[&quot;新线程可能抢先获取锁&quot;]
            S3_4[&quot;被唤醒线程 CAS 失败&quot;]
            
            S3_1 --&gt; S3_2 --&gt; S3_3 --&gt; S3_4
            style S3_3 fill:#e1f5ff
        end
    end</code></pre>
<p><strong>关键澄清：cxq 的 LIFO 不是非公平性的主要原因</strong></p>
<p>一个常见的误解是认为 synchronized 的非公平性主要来自 cxq 的 LIFO 特性。实际上：</p>
<ol>
<li>
<p><strong>cxq 的 LIFO 只影响等待线程之间的顺序</strong>：它决定了 A、B、C 三个等待线程谁先被转移到 EntryList，但这只是&quot;不公平&quot;的一个方面。</p>
</li>
<li>
<p><strong>真正的非公平性来自&quot;插队&quot;机制</strong>：即使 cxq 是 FIFO 的，只要允许新线程直接 CAS 获取锁（不先检查队列），synchronized 仍然是非公平的。</p>
</li>
<li>
<p><strong>对比 AQS 的公平锁实现</strong>：AQS 公平锁通过 <code>hasQueuedPredecessors()</code> 检查队列是否有等待者，如果有则不允许新线程直接获取锁。synchronized 没有这个检查。</p>
</li>
</ol>
<pre><code class="hljs mermaid">sequenceDiagram
    participant New as 新线程
    participant Owner as 持锁线程
    participant Monitor as ObjectMonitor
    participant EL as EntryList 线程
    
    Note over Owner,Monitor: 持锁线程正在执行临界区
    
    Owner-&gt;&gt;Monitor: 1. 释放锁（_owner = null）
    Owner-&gt;&gt;EL: 2. 唤醒 EntryList 头部线程
    
    Note over EL: 3. 唤醒中...（需要时间）
    
    New-&gt;&gt;Monitor: 4. 新线程到达，直接 CAS _owner
    Note over New,Monitor: CAS 成功！新线程获取锁
    
    Note over EL: 5. 唤醒完成
    EL-&gt;&gt;Monitor: 6. 尝试 CAS _owner
    Note over EL,Monitor: CAS 失败，重新进入等待
    
    Note over New,EL: 结果：新线程&quot;插队&quot;成功</code></pre>
<p><strong>为什么设计成非公平的？</strong></p>
<p>非公平锁的吞吐量更高，原因是：</p>
<ol>
<li>
<p><strong>减少锁空闲时间</strong>：公平锁在释放锁后必须等待队列头部线程被唤醒，这期间锁处于空闲状态。非公平锁允许新线程立即获取锁，减少了空闲时间。</p>
</li>
<li>
<p><strong>减少上下文切换</strong>：如果新线程能直接获取锁，就不需要经历&quot;入队 → 阻塞 → 唤醒&quot;的过程，减少了上下文切换开销。</p>
</li>
<li>
<p><strong>利用 CPU 缓存局部性</strong>：刚释放锁的线程如果立即重新获取锁，其 CPU 缓存中的数据仍然有效，性能更好。</p>
</li>
</ol>
<p><strong>总结</strong>：</p>
<table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody>
<tr>
<td>synchronized 是公平的吗？</td>
<td>否，JLS 不保证公平性</td>
</tr>
<tr>
<td>非公平性的主要来源？</td>
<td>新线程可以直接 CAS 获取锁，不先排队</td>
</tr>
<tr>
<td>cxq 的 LIFO 是主要原因吗？</td>
<td>否，它只是次要因素，影响等待线程间的顺序</td>
</tr>
<tr>
<td>为什么设计成非公平的？</td>
<td>吞吐量更高，减少锁空闲时间和上下文切换</td>
</tr>
</tbody>
</table>
<h3 id="锁升级全景图：从无锁到重量级锁的完整状态转换">锁升级全景图：从无锁到重量级锁的完整状态转换</h3>
<p>下图展示了 synchronized 锁的完整生命周期，包括所有可能的状态转换路径：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 锁状态转换图
        direction TB
        
        START((&quot;对象创建&quot;)) --&gt; Unlocked
        
        subgraph Unlocked[&quot;无锁状态&quot;]
            U1[&quot;Mark Word: hashCode | age | 0 | 01&quot;]
            U2[&quot;无线程持有锁&quot;]
        end
        
        subgraph Biased[&quot;偏向锁状态&quot;]
            B1[&quot;Mark Word: threadId | epoch | age | 1 | 01&quot;]
            B2[&quot;偏向第一个获取锁的线程&quot;]
        end
        
        subgraph Lightweight[&quot;轻量级锁状态&quot;]
            L1[&quot;Mark Word: Lock Record 指针 | 00&quot;]
            L2[&quot;指向持锁线程栈上的 Lock Record&quot;]
        end
        
        subgraph Heavyweight[&quot;重量级锁状态&quot;]
            H1[&quot;Mark Word: ObjectMonitor 指针 | 10&quot;]
            H2[&quot;指向 C++ 堆上的 Monitor 对象&quot;]
        end
        
        Unlocked --&gt;|&quot;首次加锁&lt;br/&gt;(偏向锁启用时)&quot;| Biased
        Unlocked --&gt;|&quot;首次加锁&lt;br/&gt;(偏向锁禁用时)&quot;| Lightweight
        
        Biased --&gt;|&quot;同一线程重入&lt;br/&gt;(无需任何操作)&quot;| Biased
        Biased --&gt;|&quot;其他线程竞争&lt;br/&gt;(偏向锁撤销)&quot;| Lightweight
        Biased --&gt;|&quot;调用 hashCode()&lt;br/&gt;(偏向锁撤销)&quot;| Heavyweight
        
        Lightweight --&gt;|&quot;同一线程重入&lt;br/&gt;(Lock Record 计数)&quot;| Lightweight
        Lightweight --&gt;|&quot;CAS 自旋失败&lt;br/&gt;(锁膨胀)&quot;| Heavyweight
        Lightweight --&gt;|&quot;解锁成功&lt;br/&gt;(CAS 恢复 Mark Word)&quot;| Unlocked
        
        Heavyweight --&gt;|&quot;线程竞争&lt;br/&gt;(进入 EntryList)&quot;| Heavyweight
        Heavyweight --&gt;|&quot;解锁&lt;br/&gt;(可能降级 JDK 15+)&quot;| Unlocked
    end
    
    style Unlocked fill:#e8f5e9
    style Biased fill:#fff3e0
    style Lightweight fill:#e3f2fd
    style Heavyweight fill:#ffebee</code></pre>
<p><strong>锁升级的触发条件与详细流程：</strong></p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;锁升级决策流程&quot;
        START[&quot;线程尝试获取锁&quot;]
        
        CHECK_BIAS&#123;&quot;偏向锁&lt;br/&gt;是否启用?&quot;&#125;
        
        subgraph &quot;偏向锁路径&quot;
            BIAS_CHECK&#123;&quot;Mark Word&lt;br/&gt;threadId == 当前线程?&quot;&#125;
            BIAS_CAS[&quot;CAS 写入 threadId&quot;]
            BIAS_SUCCESS[&quot;偏向锁获取成功&lt;br/&gt;━━━━━━━━━━━━━━&lt;br/&gt;后续重入零开销&quot;]
            BIAS_REVOKE[&quot;偏向锁撤销&lt;br/&gt;━━━━━━━━━━━━━━&lt;br/&gt;需要 STW 安全点&quot;]
        end
        
        subgraph &quot;轻量级锁路径&quot;
            LW_RECORD[&quot;创建 Lock Record&lt;br/&gt;复制 Mark Word&quot;]
            LW_CAS[&quot;CAS: Mark Word&lt;br/&gt;→ Lock Record 指针&quot;]
            LW_SUCCESS[&quot;轻量级锁获取成功&quot;]
            LW_SPIN[&quot;CAS 自旋重试&quot;]
            LW_SPIN_CHECK&#123;&quot;自旋次数&lt;br/&gt;超过阈值?&quot;&#125;
        end
        
        subgraph &quot;重量级锁路径&quot;
            HW_INFLATE[&quot;锁膨胀&lt;br/&gt;━━━━━━━━━━━━━━&lt;br/&gt;创建 ObjectMonitor&quot;]
            HW_ENTER[&quot;进入 Monitor&lt;br/&gt;━━━━━━━━━━━━━━&lt;br/&gt;可能阻塞&quot;]
            HW_SUCCESS[&quot;重量级锁获取成功&quot;]
        end
        
        START --&gt; CHECK_BIAS
        
        CHECK_BIAS --&gt;|&quot;是&quot;| BIAS_CHECK
        CHECK_BIAS --&gt;|&quot;否&quot;| LW_RECORD
        
        BIAS_CHECK --&gt;|&quot;是&quot;| BIAS_SUCCESS
        BIAS_CHECK --&gt;|&quot;否（其他线程）&quot;| BIAS_REVOKE
        BIAS_CHECK --&gt;|&quot;否（无偏向）&quot;| BIAS_CAS
        
        BIAS_CAS --&gt;|&quot;成功&quot;| BIAS_SUCCESS
        BIAS_CAS --&gt;|&quot;失败&quot;| BIAS_REVOKE
        
        BIAS_REVOKE --&gt; LW_RECORD
        
        LW_RECORD --&gt; LW_CAS
        LW_CAS --&gt;|&quot;成功&quot;| LW_SUCCESS
        LW_CAS --&gt;|&quot;失败&quot;| LW_SPIN
        
        LW_SPIN --&gt; LW_SPIN_CHECK
        LW_SPIN_CHECK --&gt;|&quot;否&quot;| LW_CAS
        LW_SPIN_CHECK --&gt;|&quot;是&quot;| HW_INFLATE
        
        HW_INFLATE --&gt; HW_ENTER
        HW_ENTER --&gt; HW_SUCCESS
    end
    
    style BIAS_SUCCESS fill:#c8e6c9
    style LW_SUCCESS fill:#c8e6c9
    style HW_SUCCESS fill:#c8e6c9
    style BIAS_REVOKE fill:#ffcdd2
    style HW_INFLATE fill:#ffcdd2</code></pre>
<p><strong>锁状态与 Mark Word 的对应关系：</strong></p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>Mark Word 布局（64位）</th>
<th>标志位</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无锁</strong></td>
<td><code>[unused:25][hashCode:31][unused:1][age:4][biased:1][lock:2]</code></td>
<td><code>0 01</code></td>
<td>存储对象 hashCode</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td><code>[threadId:54][epoch:2][unused:1][age:4][biased:1][lock:2]</code></td>
<td><code>1 01</code></td>
<td>存储偏向线程 ID，<strong>无 hashCode 存储空间</strong></td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td><code>[Lock Record 指针:62][lock:2]</code></td>
<td><code>00</code></td>
<td>指向栈上 Lock Record</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td><code>[ObjectMonitor 指针:62][lock:2]</code></td>
<td><code>10</code></td>
<td>指向堆上 Monitor</td>
</tr>
<tr>
<td><strong>GC 标记</strong></td>
<td><code>[转发指针或其他 GC 信息:62][lock:2]</code></td>
<td><code>11</code></td>
<td>GC 期间使用</td>
</tr>
</tbody>
</table>
<p><strong>锁升级的不可逆性与例外：</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;传统模型（JDK 14 及之前）&quot;
        A1[无锁] --&gt; B1[偏向锁]
        B1 --&gt; C1[轻量级锁]
        C1 --&gt; D1[重量级锁]
        D1 -.-&gt;|&quot;不可降级&quot;| D1
    end
    
    subgraph &quot;现代模型（JDK 15+）&quot;
        A2[无锁] --&gt; C2[轻量级锁]
        C2 --&gt; D2[重量级锁]
        D2 -.-&gt;|&quot;可降级&quot;| C2
        
        note1[&quot;偏向锁默认禁用&lt;br/&gt;-XX:+UseBiasedLocking 可启用&quot;]
        note2[&quot;重量级锁可降级&lt;br/&gt;当竞争消失时&quot;]
    end
    
    style D1 fill:#ffcdd2
    style D2 fill:#fff9c4</code></pre>
<p><strong>各锁状态的性能特征对比：</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>偏向锁</th>
<th>轻量级锁</th>
<th>重量级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>获取开销</strong></td>
<td>几乎为零（仅比较 threadId）</td>
<td>一次 CAS 操作</td>
<td>可能涉及系统调用</td>
</tr>
<tr>
<td><strong>释放开销</strong></td>
<td>无（不修改 Mark Word）</td>
<td>一次 CAS 操作</td>
<td>Monitor 操作</td>
</tr>
<tr>
<td><strong>竞争处理</strong></td>
<td>撤销偏向（需 STW）</td>
<td>CAS 自旋</td>
<td>阻塞等待</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>单线程反复获取同一锁</td>
<td>多线程交替获取，竞争不激烈</td>
<td>多线程激烈竞争</td>
</tr>
<tr>
<td><strong>JDK 15+ 默认</strong></td>
<td>禁用</td>
<td>启用</td>
<td>启用</td>
</tr>
</tbody>
</table>
<p><strong>为什么 JDK 15 默认禁用偏向锁？</strong></p>
<ol>
<li><strong>撤销成本高</strong>：偏向锁撤销需要在安全点（STW）进行，影响应用延迟</li>
<li><strong>现代应用特征变化</strong>：容器化、微服务架构下，单线程反复获取同一锁的场景减少</li>
<li><strong>轻量级锁足够高效</strong>：现代 CPU 的 CAS 操作已经非常快</li>
<li><strong>简化 JVM 实现</strong>：移除偏向锁可以简化锁的实现和调试</li>
</ol>
<p><strong>偏向锁与 hashCode() 的特殊关系</strong></p>
<p>当对象处于偏向锁状态时，调用 <code>hashCode()</code> 会导致偏向锁<strong>直接膨胀为重量级锁</strong>，而非回到无锁状态。这是因为：</p>
<ol>
<li><strong>Mark Word 空间冲突</strong>：偏向锁的 Mark Word 存储的是 threadId（54位），没有空间存储 hashCode（31位）</li>
<li><strong>hashCode 需要持久存储</strong>：一旦计算了 hashCode，必须保存在对象头中（用于 HashMap 等场景的一致性）</li>
<li><strong>重量级锁的解决方案</strong>：ObjectMonitor 结构中有专门的字段存储 hashCode</li>
</ol>
<pre><code class="hljs mermaid">flowchart LR
    subgraph &quot;偏向锁调用 hashCode() 的处理&quot;
        BIASED[&quot;偏向锁状态&lt;br/&gt;Mark Word: threadId&quot;]
        CALL[&quot;调用 hashCode()&quot;]
        PROBLEM[&quot;问题：无空间存储 hashCode&quot;]
        INFLATE[&quot;膨胀为重量级锁&quot;]
        MONITOR[&quot;ObjectMonitor&lt;br/&gt;可存储 hashCode&quot;]
        
        BIASED --&gt; CALL --&gt; PROBLEM --&gt; INFLATE --&gt; MONITOR
        
        style PROBLEM fill:#ffcdd2
        style INFLATE fill:#fff9c4
    end</code></pre>
<p><strong>依据</strong>：HotSpot 源码 <code>biasedLocking.cpp</code> 中的 <code>BiasedLocking::revoke_and_rebias()</code> 方法。</p>
<p><strong>最佳实践</strong>：如果对象会被用作锁，避免在加锁前调用 <code>hashCode()</code>，或者考虑使用 <code>System.identityHashCode()</code> 的替代方案。</p>
<h2 id="锁消除-lock-elimination">锁消除（Lock Elimination）</h2>
<h3 id="什么是锁消除？">什么是锁消除？</h3>
<p>锁消除是 JIT 编译器的一项优化技术：如果 JVM 通过**逃逸分析（Escape Analysis）**发现某个锁对象不可能被其他线程访问，那么这个锁就是&quot;多余的&quot;，可以被安全地消除。</p>
<p><strong>逃逸分析的核心问题：对象会不会&quot;逃逸&quot;出当前作用域？</strong></p>
<table>
<thead>
<tr>
<th>逃逸类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>不逃逸</strong></td>
<td>对象只在方法内部使用，不会被外部引用</td>
<td>方法内的局部变量</td>
</tr>
<tr>
<td><strong>方法逃逸</strong></td>
<td>对象被作为参数传递或作为返回值</td>
<td><code>return new Object()</code></td>
</tr>
<tr>
<td><strong>线程逃逸</strong></td>
<td>对象可能被其他线程访问</td>
<td>赋值给静态变量、实例变量</td>
</tr>
</tbody>
</table>
<p><strong>只有&quot;不逃逸&quot;的对象上的锁才能被消除。</strong></p>
<h3 id="锁消除的工作原理">锁消除的工作原理</h3>
<p><strong>图1：锁消除的决策流程</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;JIT 编译时的逃逸分析&quot;
        CODE[&quot;synchronized (lockObj) &#123;&lt;br/&gt;    // 临界区代码&lt;br/&gt;&#125;&quot;]
        
        ANALYZE[&quot;逃逸分析&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;分析 lockObj 的引用链&lt;br/&gt;判断是否可能被其他线程访问&quot;]
        
        ESCAPE&#123;&quot;lockObj 是否逃逸?&quot;&#125;
        
        ELIMINATE[&quot;锁消除&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;移除 monitorenter/monitorexit&lt;br/&gt;直接执行临界区代码&quot;]
        
        KEEP[&quot;保留锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;正常执行同步逻辑&quot;]
        
        CODE --&gt; ANALYZE
        ANALYZE --&gt; ESCAPE
        ESCAPE --&gt;|&quot;不逃逸&quot;| ELIMINATE
        ESCAPE --&gt;|&quot;可能逃逸&quot;| KEEP
        
        style ELIMINATE fill:#c8e6c9
        style KEEP fill:#fff9c4
    end</code></pre>
<h3 id="锁消除的典型场景">锁消除的典型场景</h3>
<p><strong>场景1：StringBuffer/StringBuilder 的同步</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-comment">// StringBuffer 是线程安全的，内部方法都有 synchronized</span><br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);  <span class="hljs-comment">// synchronized</span><br>    sb.append(s2);  <span class="hljs-comment">// synchronized</span><br>    sb.append(s3);  <span class="hljs-comment">// synchronized</span><br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>StringBuffer sb</code> 是一个局部变量，不会逃逸出 <code>concatString</code> 方法，更不可能被其他线程访问。因此，JIT 编译器可以安全地消除 <code>append()</code> 方法内部的同步操作。</p>
<p><strong>优化后的等效代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-comment">// 锁被消除，等效于使用 StringBuilder</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    sb.append(s3);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>场景2：方法内部的同步块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <span class="hljs-comment">// 局部变量，不逃逸</span><br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-comment">// 临界区代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于 <code>lock</code> 对象是方法内部创建的局部变量，每次方法调用都会创建新的对象，不可能被其他线程访问，因此这个同步块可以被完全消除。</p>
<h3 id="reentrantlock-能被消除吗？">ReentrantLock 能被消除吗？</h3>
<p>根据 <a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/~aldrich/papers/scp-camera.pdf">CMU 的研究论文</a>，<strong>ReentrantLock 也可以被锁消除优化</strong>。JIT 编译器的逃逸分析不仅适用于 <code>synchronized</code>，也适用于 <code>java.util.concurrent</code> 包中的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWithLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <span class="hljs-comment">// 局部变量</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 临界区代码</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果 <code>lock</code> 对象不逃逸，JIT 编译器可以消除 <code>lock()</code> 和 <code>unlock()</code> 的调用。</p>
<p><strong>但需要注意：</strong></p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>消除难度</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>synchronized</strong></td>
<td>较容易</td>
<td>JVM 内置支持，字节码层面可识别</td>
</tr>
<tr>
<td><strong>ReentrantLock</strong></td>
<td>较难</td>
<td>需要识别 <code>lock()</code>/<code>unlock()</code> 的调用模式</td>
</tr>
<tr>
<td><strong>分布式锁</strong></td>
<td>不可能</td>
<td>涉及外部系统，无法通过逃逸分析判断</td>
</tr>
</tbody>
</table>
<h3 id="如何验证锁消除是否生效？">如何验证锁消除是否生效？</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启逃逸分析（JDK 6u23+ 默认开启）</span><br>-XX:+DoEscapeAnalysis<br><br><span class="hljs-comment"># 开启锁消除（默认开启）</span><br>-XX:+EliminateLocks<br><br><span class="hljs-comment"># 打印逃逸分析结果</span><br>-XX:+PrintEscapeAnalysis<br><br><span class="hljs-comment"># 打印锁消除信息</span><br>-XX:+PrintEliminateLocks<br></code></pre></td></tr></table></figure>
<h2 id="锁粗化-lock-coarsening">锁粗化（Lock Coarsening）</h2>
<h3 id="什么是锁粗化？">什么是锁粗化？</h3>
<p>锁粗化是 JIT 编译器的另一项优化技术：如果 JVM 检测到<strong>一系列连续的加锁/解锁操作都是针对同一个锁对象</strong>，那么可以将这些操作合并为一次更大范围的加锁/解锁，从而减少锁操作的开销。</p>
<p><strong>图1：锁粗化的优化过程</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;优化前：频繁加锁/解锁&quot;
        BEFORE[&quot;synchronized (lock) &#123; op1(); &#125;&lt;br/&gt;synchronized (lock) &#123; op2(); &#125;&lt;br/&gt;synchronized (lock) &#123; op3(); &#125;&quot;]
        
        COST1[&quot;开销分析&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 3 次 monitorenter&lt;br/&gt;• 3 次 monitorexit&lt;br/&gt;• 3 次 CAS 操作&lt;br/&gt;• 可能的锁膨胀&quot;]
        
        BEFORE --&gt; COST1
        style COST1 fill:#ffcdd2
    end
    
    subgraph &quot;优化后：一次大锁&quot;
        AFTER[&quot;synchronized (lock) &#123;&lt;br/&gt;    op1();&lt;br/&gt;    op2();&lt;br/&gt;    op3();&lt;br/&gt;&#125;&quot;]
        
        COST2[&quot;开销分析&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 1 次 monitorenter&lt;br/&gt;• 1 次 monitorexit&lt;br/&gt;• 1 次 CAS 操作&lt;br/&gt;• 锁持有时间略长&quot;]
        
        AFTER --&gt; COST2
        style COST2 fill:#c8e6c9
    end
    
    BEFORE --&gt;|&quot;JIT 锁粗化&quot;| AFTER</code></pre>
<h3 id="锁粗化的典型场景">锁粗化的典型场景</h3>
<p><strong>场景1：循环内的同步</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 优化前：每次循环都加锁/解锁</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        list.add(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 优化后：整个循环只加锁一次</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        list.add(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>场景2：连续的同步方法调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 优化前：每个方法调用都有独立的同步</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>    sb.append(<span class="hljs-string">&quot;Hello&quot;</span>);   <span class="hljs-comment">// synchronized</span><br>    sb.append(<span class="hljs-string">&quot; &quot;</span>);       <span class="hljs-comment">// synchronized</span><br>    sb.append(<span class="hljs-string">&quot;World&quot;</span>);   <span class="hljs-comment">// synchronized</span><br>    sb.append(<span class="hljs-string">&quot;!&quot;</span>);       <span class="hljs-comment">// synchronized</span><br>&#125;<br><br><span class="hljs-comment">// 优化后：合并为一次同步</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (sb) &#123;<br>        sb.append(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        sb.append(<span class="hljs-string">&quot; &quot;</span>);<br>        sb.append(<span class="hljs-string">&quot;World&quot;</span>);<br>        sb.append(<span class="hljs-string">&quot;!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="锁粗化的权衡">锁粗化的权衡</h3>
<p><strong>图2：锁粗化的利弊分析</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;锁粗化的收益&quot;
        BENEFIT1[&quot;减少锁操作次数&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;N 次加锁/解锁 → 1 次&lt;br/&gt;减少 CAS 开销&quot;]
        BENEFIT2[&quot;减少锁状态转换&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;避免频繁的偏向锁撤销&lt;br/&gt;避免轻量级锁膨胀&quot;]
        BENEFIT3[&quot;提高缓存命中率&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;减少 Mark Word 的修改&lt;br/&gt;减少缓存行失效&quot;]
        
        style BENEFIT1 fill:#c8e6c9
        style BENEFIT2 fill:#c8e6c9
        style BENEFIT3 fill:#c8e6c9
    end
    
    subgraph &quot;锁粗化的代价&quot;
        COST1[&quot;锁持有时间变长&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;其他线程等待时间增加&lt;br/&gt;可能降低并发度&quot;]
        COST2[&quot;临界区变大&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;包含了原本不需要同步的代码&lt;br/&gt;可能引入不必要的串行化&quot;]
        
        style COST1 fill:#ffcdd2
        style COST2 fill:#ffcdd2
    end</code></pre>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否适合锁粗化</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>连续的短临界区</strong></td>
<td>适合</td>
<td>锁操作开销 &gt; 临界区执行时间</td>
</tr>
<tr>
<td><strong>循环内的同步</strong></td>
<td>适合</td>
<td>避免大量重复的加锁/解锁</td>
</tr>
<tr>
<td><strong>包含 I/O 操作的临界区</strong></td>
<td>不适合</td>
<td>锁持有时间过长，严重影响并发</td>
</tr>
<tr>
<td><strong>高并发竞争场景</strong></td>
<td>不适合</td>
<td>锁粗化会加剧竞争</td>
</tr>
</tbody>
</table>
<h3 id="锁粗化-vs-锁细化">锁粗化 vs 锁细化</h3>
<p>锁粗化和锁细化（Lock Splitting/Striping）是两个相反的优化方向：</p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;锁粗化&quot;
        COARSE[&quot;多个小锁 → 一个大锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;减少锁操作开销&lt;br/&gt;适合低竞争场景&quot;]
        style COARSE fill:#e1f5ff
    end
    
    subgraph &quot;锁细化&quot;
        FINE[&quot;一个大锁 → 多个小锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;减少锁竞争&lt;br/&gt;适合高并发场景&quot;]
        style FINE fill:#fff9c4
    end
    
    COARSE &lt;--&gt;|&quot;相反的优化方向&quot;| FINE</code></pre>
<p><strong>JVM 自动进行锁粗化，但锁细化需要程序员手动设计。</strong> 典型的锁细化例子包括：</p>
<ul>
<li><code>ConcurrentHashMap</code> 的分段锁（JDK 7）/ CAS + synchronized（JDK 8+）</li>
<li><code>LongAdder</code> 的分散热点</li>
<li>读写锁分离（<code>ReentrantReadWriteLock</code>）</li>
</ul>
<h3 id="如何控制锁粗化？">如何控制锁粗化？</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启锁粗化（默认开启）</span><br>-XX:+EliminateNestedLocks<br><br><span class="hljs-comment"># 关闭锁粗化（用于调试）</span><br>-XX:-EliminateNestedLocks<br></code></pre></td></tr></table></figure>
<p><strong>最佳实践：</strong></p>
<ol>
<li><strong>信任 JVM 的优化</strong>：在大多数情况下，JVM 的锁粗化决策是合理的</li>
<li><strong>避免过度优化</strong>：不要为了&quot;帮助&quot; JVM 而手动粗化锁，这可能适得其反</li>
<li><strong>关注热点代码</strong>：只有被 JIT 编译的热点代码才会进行锁粗化优化</li>
<li><strong>监控锁竞争</strong>：使用 <code>jstack</code>、<code>async-profiler</code> 等工具监控锁竞争情况，判断是否需要手动调整锁粒度</li>
</ol>
<h2 id="锁膨胀-lock-inflation">锁膨胀（Lock Inflation）</h2>
<p>本章节完整介绍 synchronized 锁的状态变化机制，包括：偏向锁、轻量级锁、重量级锁的实现原理，以及自旋与阻塞的等待机制优化。这是理解 JVM 锁优化的核心内容。</p>
<p><strong>术语说明</strong>：在 JVM 和 HotSpot 源码中，描述偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁这一过程的正式术语是 <strong>Lock Inflation（锁膨胀）</strong>，而非 “Lock Escalation”。后者是数据库领域的术语，指将多个细粒度锁（如行锁）升级为粗粒度锁（如表锁）以减少锁管理开销。中文社区常用的&quot;锁升级&quot;（Lock Upgrade）虽然不够精确，但已被广泛接受。本文采用&quot;锁膨胀&quot;这一更贴近 HotSpot 实现的术语。</p>
<h3 id="概述：锁状态与等待机制">概述：锁状态与等待机制</h3>
<p>在深入讨论之前，我们需要先澄清两个常被混淆的概念：</p>
<p><strong>&quot;自旋锁&quot;这个术语在不同语境下有不同含义：</strong></p>
<ol>
<li>
<p><strong>狭义的自旋锁（Spinlock）</strong>：一种独立的锁实现，如 Linux 内核中的 <code>spinlock_t</code>，它完全基于自旋实现，不涉及线程阻塞。这种锁通常用于内核态或中断上下文中，因为这些场景不能进行线程调度。</p>
</li>
<li>
<p><strong>锁的自旋优化（Spin Optimization）</strong>：在传统阻塞锁的基础上，增加一个自旋阶段。线程获取锁失败后，先自旋一段时间，如果还获取不到再阻塞。这是 JVM 中 synchronized 和 ReentrantLock 采用的策略。</p>
</li>
</ol>
<p><strong>本文讨论的是第二种含义——锁的自旋优化。</strong></p>
<p><strong>关键理解：自旋是等待机制的优化，不是锁实现的优化</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;锁的分类维度&quot;
        direction TB
        
        subgraph &quot;按锁实现分类&quot;
            IMPL[&quot;锁实现&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;偏向锁 / 轻量级锁 / 重量级锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;决定：如何记录锁的持有者&lt;br/&gt;如何管理锁的状态&quot;]
            style IMPL fill:#e1f5ff
        end
        
        subgraph &quot;按等待机制分类&quot;
            WAIT[&quot;等待机制&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;自旋等待 / 阻塞等待&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;决定：获取锁失败后&lt;br/&gt;线程如何等待&quot;]
            style WAIT fill:#fff9c4
        end
    end
    
    note1[&quot;这两个维度是正交的！&lt;br/&gt;偏向锁/轻量级锁/重量级锁 描述的是「锁的实现」&lt;br/&gt;自旋/阻塞 描述的是「等待机制」&lt;br/&gt;不要混为一谈&quot;]
    style note1 fill:#ffcdd2</code></pre>
<p><strong>英文文献中的术语：</strong></p>
<p>在学术文献和专业书籍中，这两个概念有明确的区分：</p>
<table>
<thead>
<tr>
<th>英文术语</th>
<th>中文</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Lock Implementation</strong></td>
<td>锁实现</td>
<td>偏向锁、轻量级锁、重量级锁属于这个范畴</td>
</tr>
<tr>
<td><strong>Spinning / Spin-waiting</strong></td>
<td>自旋等待</td>
<td>获取锁失败后，线程忙循环等待</td>
</tr>
<tr>
<td><strong>Blocking / Block-waiting</strong></td>
<td>阻塞等待</td>
<td>获取锁失败后，线程被挂起</td>
</tr>
<tr>
<td><strong>Spin-then-block</strong></td>
<td>先自旋后阻塞</td>
<td>JVM 采用的混合策略</td>
</tr>
</tbody>
</table>
<p>《The Art of Multiprocessor Programming》（多处理器编程的艺术）一书中明确指出：</p>
<blockquote>
<p>“Spinning is a technique where a thread repeatedly checks a condition instead of blocking. It is orthogonal to the lock implementation itself.”</p>
<p>（自旋是一种线程反复检查条件而不是阻塞的技术。它与锁的实现本身是正交的。）</p>
</blockquote>
<p><strong>为什么这个区分很重要？</strong></p>
<p>因为：</p>
<ul>
<li><strong>偏向锁、轻量级锁、重量级锁</strong>回答的是&quot;锁的状态如何记录、锁的持有者如何追踪&quot;</li>
<li><strong>自旋、阻塞</strong>回答的是&quot;获取锁失败后，线程如何等待&quot;</li>
</ul>
<p>这两个问题是独立的。例如：</p>
<ul>
<li>轻量级锁获取失败后，可以选择自旋等待，也可以直接膨胀为重量级锁然后阻塞</li>
<li>重量级锁获取失败后，JVM 也会先自旋一段时间，再进入阻塞</li>
</ul>
<p><strong>锁状态升级的完整路径：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">无锁 → 偏向锁 → 轻量级锁 → 重量级锁<br></code></pre></td></tr></table></figure>
<p>接下来，我们将按照这个升级路径，逐一介绍每种锁状态的实现原理。</p>
<h3 id="偏向锁-biased-lock">偏向锁（Biased Lock）</h3>
<p>偏向锁是 JDK 1.6 中引入的一项锁优化。它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，偏向锁就是在无竞争的情况下，把整个同步过程都消除掉，连 CAS 都不做了。</p>
<h4 id="偏向锁的本质：一个-写在-mark-word-里的-volatile-threadid">偏向锁的本质：一个&quot;写在 Mark Word 里的 volatile threadId&quot;</h4>
<p>理解偏向锁最直观的方式是将它类比为一个 <strong>volatile 全局变量</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 偏向锁的概念模型（伪代码）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiasedLockSimulation</span> &#123;<br>    <span class="hljs-comment">// 这个 volatile 变量就像 Mark Word 中的 threadId 字段</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">biasedThreadId</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentThreadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-keyword">if</span> (biasedThreadId == currentThreadId) &#123;<br>            <span class="hljs-comment">// 已偏向当前线程，直接进入临界区</span><br>            <span class="hljs-comment">// 这就是偏向锁&quot;零开销&quot;的来源</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (biasedThreadId == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 首次加锁，CAS 设置偏向线程</span><br>            <span class="hljs-keyword">if</span> (CAS(biasedThreadId, <span class="hljs-number">0</span>, currentThreadId)) &#123;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 偏向成功</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 偏向失败，升级到轻量级锁...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>偏向锁与 volatile 变量的相似性：</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>volatile threadId 变量</th>
<th>偏向锁的 Mark Word</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>存储位置</strong></td>
<td>堆中的对象字段</td>
<td>对象头的 Mark Word</td>
</tr>
<tr>
<td><strong>可见性保证</strong></td>
<td>volatile 语义</td>
<td>Mark Word 的原子读写</td>
</tr>
<tr>
<td><strong>写入方式</strong></td>
<td>直接赋值</td>
<td>CAS（仅首次）</td>
</tr>
<tr>
<td><strong>读取开销</strong></td>
<td>一次内存读取</td>
<td>一次内存读取 + 比较</td>
</tr>
<tr>
<td><strong>空间占用</strong></td>
<td>8 字节（long）</td>
<td>复用 Mark Word 的 54 位</td>
</tr>
</tbody>
</table>
<p><strong>关键区别：偏向锁复用了 Mark Word 的空间</strong></p>
<p>偏向锁的精妙之处在于：它没有额外分配一个字段来存储 threadId，而是<strong>复用了 Mark Word 中原本存储 hashCode 的空间</strong>。这就是为什么偏向锁与 hashCode 互斥——它们在 Mark Word 中占用相同的位。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">无锁状态的 Mark Word（64位）：<br>|<span class="hljs-string"> unused:25 </span>|<span class="hljs-string"> hashcode:31 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:0 </span>|<span class="hljs-string"> 01 </span>|<br><br>偏向锁状态的 Mark Word（64位）：<br>|<span class="hljs-string"> thread:54 </span>|<span class="hljs-string"> epoch:2 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1 </span>|<span class="hljs-string"> 01 </span>|<br></code></pre></td></tr></table></figure>
<p>这种设计的权衡是：</p>
<ul>
<li><strong>优点</strong>：零额外空间开销，偏向锁检查只需读取 Mark Word 并比较 threadId</li>
<li><strong>缺点</strong>：hashCode 和 threadId 互斥，调用 <code>hashCode()</code> 会导致偏向锁失效</li>
</ul>
<p><strong>age 与 epoch 的本质区别</strong></p>
<p>观察上述 Mark Word 结构，可以发现两个容易混淆的字段：<code>age</code>（4 bits）和 <code>epoch</code>（2 bits）。它们虽然都存储在 Mark Word 中，但属于完全不同的子系统，服务于不同的目的：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>位数</th>
<th>所属子系统</th>
<th>作用</th>
<th>变化时机</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>age</strong></td>
<td>4 bits</td>
<td>GC 子系统</td>
<td>记录对象的分代年龄</td>
<td>每次 Minor GC 存活后 +1，达到阈值（默认 15）后晋升到老年代</td>
</tr>
<tr>
<td><strong>epoch</strong></td>
<td>2 bits</td>
<td>锁子系统</td>
<td>偏向锁的&quot;批次戳&quot;，用于批量重偏向</td>
<td>当某个类的偏向锁撤销次数超过阈值时，该类的 epoch +1</td>
</tr>
</tbody>
</table>
<p><strong>age 的语义</strong>：这是 GC 的概念。新生代对象每经历一次 Minor GC 且存活，age 就加 1。当 age 达到 <code>-XX:MaxTenuringThreshold</code>（默认 15，正好是 4 bits 能表示的最大值）时，对象会被晋升到老年代。age 与锁机制无关，它在所有锁状态下都保持不变（除非被 GC 更新）。</p>
<p><strong>epoch 的语义</strong>：这是偏向锁特有的概念。每个类（Klass）维护一个 epoch 值，每个偏向锁对象的 Mark Word 中也存储一个 epoch 值。当 JVM 检测到某个类的偏向锁被频繁撤销（超过 <code>BiasedLockingBulkRebiasThreshold</code>，默认 20 次），会触发<strong>批量重偏向（Bulk Rebias）</strong>：类的 epoch 值加 1，使得所有该类对象的旧偏向锁&quot;过期&quot;。后续线程获取这些对象的锁时，发现对象的 epoch 与类的 epoch 不匹配，可以直接重偏向到当前线程，而无需执行昂贵的偏向锁撤销操作。</p>
<p>简言之：<strong>age 是对象在 GC 中的&quot;年龄&quot;，epoch 是偏向锁的&quot;版本号&quot;</strong>。两者在 Mark Word 中共存，但互不干扰。</p>
<p>偏向锁的偏，是偏心的。这个锁会偏向于第一个获得它的线程，如果接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。从这点来看，<strong>偏向锁导致同步消除了，等同于锁消除了。但锁消除并不等同于偏向锁，可能有 JIT 自己去掉同步代码的优化</strong>。</p>
<p>当对象在第一次被线程锁定的时候，虚拟机会把标志位设置为&quot;01&quot;（<strong>至此标志位已经被用尽了</strong>）。同时使用 CAS 模式（<strong>因为此时还不能保证没有竞争</strong>）试图把线程 ID 写入 Mark Word 中（<strong>此处就真的写入线程号了</strong>）。如果 CAS 成功，那么以后再进入同步块，都不需要执行任何同步操作。</p>
<p>如果这个时候发生锁竞争，则会发生撤销偏向（Revoke Bias），对象会短暂回到未锁定状态，然后进入轻量级锁的竞争阶段。注意：偏向锁撤销后是先升级到轻量级锁，而不是直接膨胀为重量级锁。只有在轻量级锁竞争失败（CAS 自旋超过阈值）时，才会进一步膨胀为重量级锁。偏向锁是默认打开的，很多推荐的 JVM 配置都关掉它，因为多线程竞争很激烈的情况下，偏向锁的假定往往会失效（轻量级锁实际上也会失效）。所以可以用 <code>-XX:-UseBiasedLocking</code> 来关闭偏向锁。</p>
<h4 id="hashcode-与偏向锁的互斥">hashCode 与偏向锁的互斥</h4>
<p>偏向锁有一个容易被忽略但非常重要的限制：<strong>偏向锁与 identity hashCode 是互斥的</strong>。</p>
<p>观察 64 位 JVM 下偏向锁的 Mark Word 结构：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> thread:54 </span>|<span class="hljs-string"> epoch:2 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1 </span>|<span class="hljs-string"> 01 </span>|<br></code></pre></td></tr></table></figure>
<p>可以发现：偏向锁的 Mark Word 中没有 hashCode 的存储位置。54 位被线程 ID 占用，剩余的位用于 epoch、age 和标志位。而无锁状态下的 Mark Word 结构是：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> unused:25 </span>|<span class="hljs-string"> hashcode:31 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:0 </span>|<span class="hljs-string"> 01 </span>|<br></code></pre></td></tr></table></figure>
<p>hashCode 占用了 31 位。由于 Mark Word 空间有限，threadId 和 hashCode 无法同时存储，这导致了以下行为：</p>
<ol>
<li><strong>对象从未调用过 <code>hashCode()</code></strong>：可以正常进入偏向锁状态，Mark Word 存储线程 ID</li>
<li><strong>对象已经调用过 <code>hashCode()</code></strong>：hashCode 已经占用了 Mark Word 的相应位，无法再存储 threadId，因此直接跳过偏向锁，进入轻量级锁</li>
<li><strong>对象已经处于偏向锁状态时调用 <code>hashCode()</code></strong>：偏向锁会被立即撤销。如果当前线程持有该偏向锁，则升级为轻量级锁（hashCode 存入 Lock Record 的 Displaced Mark Word）；如果存在其他线程竞争，则膨胀为重量级锁（hashCode 存入 ObjectMonitor 的 <code>_header</code> 字段）</li>
</ol>
<p>这里需要区分两种 hashCode：</p>
<ul>
<li><strong>identity hashCode</strong>：由 <code>Object.hashCode()</code> 或 <code>System.identityHashCode()</code> 返回，基于对象地址计算，需要存储在 Mark Word 中</li>
<li><strong>重写的 hashCode</strong>：如 <code>String.hashCode()</code>，基于对象内容计算，不需要存储在 Mark Word 中，不影响偏向锁</li>
</ul>
<p><strong>实践建议：</strong> 如果一个对象主要用作锁，应避免对其调用 <code>hashCode()</code> 或将其放入 <code>HashMap</code>/<code>HashSet</code>，否则偏向锁优化将失效。</p>
<h3 id="轻量级锁-lightweight-lock">轻量级锁（Lightweight Lock）</h3>
<p>轻量级锁本身是 JDK 1.6 以后才加入的新型锁机制，它名字中的&quot;轻量级&quot;是相对于使用操作系统互斥量来实现的传统锁而言的（<strong>Mutex 等于重量锁，在不同的场景下又称 Mutex Lock、fat lock。可以认为 OS 的系统调用提供了并发机制-线程，就会必然提供互斥量机制。</strong>）。它不是用来代替重量级锁的，用意是在多线程竞争不激烈的情况下，减少重量级锁的使用，来减少性能消耗。</p>
<h4 id="轻量级锁-vs-重量级锁：到底-轻-在哪里？">轻量级锁 vs 重量级锁：到底&quot;轻&quot;在哪里？</h4>
<p>要理解轻量级锁为什么&quot;轻&quot;，首先需要理解重量级锁为什么&quot;重&quot;。</p>
<p><strong>重量级锁的实现机制：</strong></p>
<p>当 synchronized 升级为重量级锁时，JVM 会为锁对象关联一个 <strong>ObjectMonitor</strong> 对象（也称为 Monitor 或管程）。这个 Monitor 对象是 HotSpot 在 C++ 层面实现的，它内部封装了操作系统的 <strong>Mutex（互斥量）</strong> 和 <strong>Condition Variable（条件变量）</strong>。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;重量级锁的完整结构&quot;
        direction TB
        
        subgraph &quot;堆（Heap）&quot;
            OBJ[&quot;锁对象&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word: ptr_to_monitor | 10&lt;br/&gt;Klass Pointer&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Instance Data&quot;]
            style OBJ fill:#e1f5ff
        end
        
        subgraph &quot;C++ 堆 / Native Memory&quot;
            MONITOR[&quot;ObjectMonitor（C++ 对象）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;_header: 原始 Mark Word 备份&lt;br/&gt;_owner: 持锁线程指针&lt;br/&gt;_recursions: 重入计数&lt;br/&gt;_EntryList: 阻塞等待队列&lt;br/&gt;_WaitSet: wait() 等待队列&lt;br/&gt;_cxq: 竞争队列&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;底层同步原语&quot;]
            
            MUTEX[&quot;pthread_mutex_t&lt;br/&gt;（OS 互斥量）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;需要系统调用&lt;br/&gt;futex / mutex_lock&quot;]
            
            COND[&quot;pthread_cond_t&lt;br/&gt;（条件变量）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;用于 wait/notify&quot;]
            
            MONITOR --&gt; MUTEX
            MONITOR --&gt; COND
            
            style MONITOR fill:#ffcdd2
            style MUTEX fill:#ffcdd2
            style COND fill:#ffcdd2
        end
        
        subgraph &quot;操作系统内核&quot;
            KERNEL[&quot;内核态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;线程调度&lt;br/&gt;上下文切换&lt;br/&gt;futex 系统调用&quot;]
            style KERNEL fill:#ffcdd2
        end
        
        OBJ --&gt;|&quot;Mark Word 指向&quot;| MONITOR
        MUTEX --&gt;|&quot;系统调用&quot;| KERNEL
    end
    
    note1[&quot;重量级锁的开销：&lt;br/&gt;1. 需要分配 ObjectMonitor 对象&lt;br/&gt;2. 竞争失败时线程被阻塞（park）&lt;br/&gt;3. 阻塞/唤醒需要系统调用&lt;br/&gt;4. 用户态 ↔ 内核态切换开销大&lt;br/&gt;5. 线程上下文切换成本高&quot;]
    style note1 fill:#ffcdd2</code></pre>
<p><strong>轻量级锁的实现机制：</strong></p>
<p>轻量级锁完全不使用 ObjectMonitor，而是利用线程栈帧中的 <strong>Lock Record</strong> 和 <strong>CAS 操作</strong> 来实现同步。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;轻量级锁的完整结构&quot;
        direction TB
        
        subgraph &quot;线程栈（用户态内存）&quot;
            LR[&quot;Lock Record&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word&lt;br/&gt;owner → 锁对象&quot;]
            style LR fill:#c8e6c9
        end
        
        subgraph &quot;堆（Heap）&quot;
            OBJ2[&quot;锁对象&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word: ptr_to_LR | 00&lt;br/&gt;Klass Pointer&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Instance Data&quot;]
            style OBJ2 fill:#e1f5ff
        end
        
        subgraph &quot;CPU 指令&quot;
            CAS[&quot;CAS 指令&lt;br/&gt;（cmpxchg）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;原子操作&lt;br/&gt;无需系统调用&lt;br/&gt;纯用户态执行&quot;]
            style CAS fill:#c8e6c9
        end
        
        LR &lt;--&gt;|&quot;互相指向&quot;| OBJ2
        LR --&gt;|&quot;加锁/解锁&quot;| CAS
    end
    
    note2[&quot;轻量级锁的优势：&lt;br/&gt;1. Lock Record 在栈上，无需额外分配&lt;br/&gt;2. 只用 CAS 操作，无系统调用&lt;br/&gt;3. 始终在用户态执行&lt;br/&gt;4. 无线程阻塞，无上下文切换&lt;br/&gt;5. CPU 缓存友好&quot;]
    style note2 fill:#c8e6c9</code></pre>
<p><strong>核心对比：轻量级锁的&quot;轻&quot;体现在哪里</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>轻量级锁</th>
<th>重量级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>锁状态存储</strong></td>
<td>栈上的 Lock Record（自动管理）</td>
<td>堆外的 ObjectMonitor（需要分配/回收）</td>
</tr>
<tr>
<td><strong>加锁操作</strong></td>
<td>一次 CAS 指令（~10-20 CPU cycles）</td>
<td>可能涉及系统调用（~1000+ CPU cycles）</td>
</tr>
<tr>
<td><strong>竞争失败时</strong></td>
<td>自旋重试（仍在用户态）</td>
<td>线程阻塞（park，进入内核态）</td>
</tr>
<tr>
<td><strong>解锁操作</strong></td>
<td>一次 CAS 指令</td>
<td>可能需要唤醒等待线程（unpark）</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>无额外开销（Lock Record 随栈帧销毁）</td>
<td>ObjectMonitor 对象（约 200+ bytes）</td>
</tr>
<tr>
<td><strong>上下文切换</strong></td>
<td>无</td>
<td>有（阻塞/唤醒时）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>无竞争或轻度竞争</td>
<td>高竞争场景</td>
</tr>
</tbody>
</table>
<p><strong>使用 Lock Record 而非 Monitor 的原因</strong></p>
<ol>
<li><strong>避免内存分配</strong>：Lock Record 在线程栈帧中，随方法调用自动创建和销毁，无需 GC 管理</li>
<li><strong>避免系统调用</strong>：CAS 是 CPU 指令，不需要进入内核态</li>
<li><strong>避免线程阻塞</strong>：轻量级锁失败时可以自旋重试，不会立即阻塞线程</li>
<li><strong>缓存友好</strong>：栈内存通常在 CPU 缓存中，访问速度快</li>
</ol>
<h3 id="lock-record-不是锁本身-mark-word-才是">Lock Record 不是锁本身，Mark Word 才是</h3>
<p>谁存了“哪个线程拥有锁”，谁就是锁。</p>
<p>这里有一个容易混淆的概念需要澄清：<strong>Lock Record 本身并不是锁，它只是锁状态的&quot;证据&quot;</strong>。</p>
<p>很多人会疑惑：Lock Record 存储在线程私有的栈帧中，其他线程根本访问不到，它怎么能起到锁的作用呢？这与 ObjectMonitor 不同——Monitor 在堆上（虽然是 C++ 堆），所有线程都可以访问它、竞争它。</p>
<p>实际上，<strong>真正的锁不是 Lock Record，而是锁对象的 Mark Word</strong>。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;锁的本质：Mark Word 是全局可见的&quot;
        direction TB
        
        subgraph &quot;线程 A 的栈（私有）&quot;
            LR_A[&quot;Lock Record A&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word&lt;br/&gt;owner → obj&quot;]
            style LR_A fill:#c8e6c9
        end
        
        subgraph &quot;线程 B 的栈（私有）&quot;
            LR_B[&quot;Lock Record B&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word&lt;br/&gt;owner → obj&quot;]
            style LR_B fill:#fff9c4
        end
        
        subgraph &quot;堆（全局共享）&quot;
            OBJ[&quot;锁对象 obj&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word: ptr_to_LR_A | 00&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;所有线程都能读取这个 Mark Word！&quot;]
            style OBJ fill:#e1f5ff
        end
        
        LR_A --&gt;|&quot;owner 指向&quot;| OBJ
        LR_B --&gt;|&quot;owner 指向&quot;| OBJ
        OBJ --&gt;|&quot;Mark Word 指向&lt;br/&gt;（这就是锁的证明）&quot;| LR_A
    end
    
    note1[&quot;关键理解：&lt;br/&gt;1. Lock Record 是私有的，但 Mark Word 是共享的&lt;br/&gt;2. 线程通过 CAS 竞争的是 Mark Word，不是 Lock Record&lt;br/&gt;3. Mark Word 指向谁的 Lock Record，谁就持有锁&lt;br/&gt;4. 其他线程通过读取 Mark Word 就能知道锁被谁持有&quot;]
    style note1 fill:#fff9c4</code></pre>
<p><strong>轻量级锁的工作原理可以这样理解：</strong></p>
<ol>
<li><strong>锁对象的 Mark Word 是全局共享的</strong>：所有线程都可以读取堆上对象的 Mark Word</li>
<li><strong>CAS 竞争的是 Mark Word</strong>：线程通过 CAS 尝试将 Mark Word 从&quot;无锁状态&quot;修改为&quot;指向自己 Lock Record 的指针&quot;</li>
<li><strong>Mark Word 指向谁，谁就是锁的持有者</strong>：其他线程读取 Mark Word，发现它指向某个 Lock Record，就知道锁已被占用</li>
<li><strong>Lock Record 只是&quot;持锁证明&quot;的存储位置</strong>：它保存了原始 Mark Word 的备份，用于解锁时恢复</li>
</ol>
<p><strong>类比理解：</strong></p>
<p>可以把这个机制类比为&quot;停车位&quot;：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>类比</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>锁对象的 Mark Word</strong></td>
<td>停车位上的&quot;占用标识牌&quot;</td>
</tr>
<tr>
<td><strong>Lock Record</strong></td>
<td>车主的&quot;停车凭证&quot;（存在车主口袋里）</td>
</tr>
<tr>
<td><strong>CAS 操作</strong></td>
<td>原子地在标识牌上写下自己的车牌号</td>
</tr>
<tr>
<td><strong>竞争失败</strong></td>
<td>发现标识牌上已经有别人的车牌号</td>
</tr>
</tbody>
</table>
<p>停车凭证（Lock Record）确实是私有的，但停车位的标识牌（Mark Word）是所有人都能看到的。其他车主通过看标识牌就知道这个位置被谁占了，而不需要去翻别人的口袋。</p>
<p><strong>Lock Record vs ObjectMonitor 的本质区别：</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Lock Record（轻量级锁）</th>
<th>ObjectMonitor（重量级锁）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>锁状态存储</strong></td>
<td>Mark Word 存储指向 Lock Record 的指针</td>
<td>Mark Word 存储指向 Monitor 的指针</td>
</tr>
<tr>
<td><strong>竞争机制</strong></td>
<td>CAS 自旋（用户态）</td>
<td>Mutex 阻塞（内核态）</td>
</tr>
<tr>
<td><strong>等待队列</strong></td>
<td>无（自旋重试）</td>
<td>有（_EntryList、_WaitSet）</td>
</tr>
<tr>
<td><strong>线程阻塞</strong></td>
<td>不阻塞（自旋消耗 CPU）</td>
<td>阻塞（释放 CPU）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>竞争少、持锁时间短</td>
<td>竞争多、持锁时间长</td>
</tr>
</tbody>
</table>
<p><strong>轻量级锁不需要全局可见 Monitor 的原因</strong></p>
<p>因为轻量级锁的设计假设是：<strong>锁竞争很少发生</strong>。在这种假设下：</p>
<ol>
<li><strong>不需要等待队列</strong>：竞争失败的线程直接自旋重试，不需要排队</li>
<li><strong>不需要阻塞/唤醒机制</strong>：没有线程会被挂起，也就不需要 Mutex 和 Condition Variable</li>
<li><strong>Mark Word 足以表达锁状态</strong>：只需要知道&quot;锁被谁持有&quot;，不需要复杂的等待/通知语义</li>
</ol>
<p>一旦竞争变得激烈（自旋超过阈值），轻量级锁就会膨胀为重量级锁，此时才需要 ObjectMonitor 来管理等待队列和线程阻塞。</p>
<h3 id="objectmonitor-的创建时机与生命周期">ObjectMonitor 的创建时机与生命周期</h3>
<p>当 synchronized 需要使用重量级锁时，ObjectMonitor 并非凭空 new 出来，而是<strong>按需延迟创建（Lazy Allocation）</strong>。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Thread as 线程
    participant OBJ as 锁对象
    participant MW as Mark Word
    participant Pool as Monitor 池
    participant Monitor as ObjectMonitor
    
    Note over Thread,Monitor: 场景：轻量级锁竞争失败，需要膨胀
    
    Thread-&gt;&gt;MW: CAS 失败，检测到竞争
    Thread-&gt;&gt;Thread: 决定膨胀为重量级锁
    
    alt Monitor 池中有空闲 Monitor
        Thread-&gt;&gt;Pool: 从池中获取 Monitor
        Pool--&gt;&gt;Thread: 返回空闲 Monitor
    else Monitor 池为空
        Thread-&gt;&gt;Monitor: new ObjectMonitor()
        Note over Monitor: 在 C++ 堆上分配&lt;br/&gt;初始化 mutex/cond
    end
    
    Thread-&gt;&gt;Monitor: 设置 _header = 原始 Mark Word
    Thread-&gt;&gt;Monitor: 设置 _owner = 当前线程
    Thread-&gt;&gt;MW: CAS 更新为 ptr_to_monitor | 10
    
    Note over Thread,Monitor: 锁膨胀完成
    
    Note over Thread,Monitor: 后续：锁释放时
    Thread-&gt;&gt;Monitor: 释放锁
    Monitor-&gt;&gt;Pool: 归还到 Monitor 池（可能）
    Note over Pool: 或者直接销毁&lt;br/&gt;取决于 JVM 实现</code></pre>
<p><strong>ObjectMonitor 的生命周期：</strong></p>
<ol>
<li><strong>创建时机</strong>：只有当轻量级锁竞争失败，需要膨胀为重量级锁时，才会创建或获取 ObjectMonitor</li>
<li><strong>关联方式</strong>：通过将 Mark Word 替换为指向 ObjectMonitor 的指针（锁标志位为 10）</li>
<li><strong>回收时机</strong>：当锁不再被使用时，ObjectMonitor 可能被回收或放入池中复用</li>
<li><strong>池化复用</strong>：HotSpot 维护了一个 ObjectMonitor 的空闲池，避免频繁分配/销毁</li>
</ol>
<p><strong>Mark Word 与 Monitor 的关系图：</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;Mark Word 的不同状态&quot;
        direction TB
        
        MW1[&quot;无锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;hashCode | age | 0 | 01&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;存储对象自身信息&quot;]
        
        MW2[&quot;偏向锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;threadId | epoch | age | 1 | 01&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;存储偏向线程 ID&quot;]
        
        MW3[&quot;轻量级锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;ptr_to_lock_record | 00&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;指向栈上的 Lock Record&quot;]
        
        MW4[&quot;重量级锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;ptr_to_monitor | 10&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;指向 ObjectMonitor&quot;]
        
        MW5[&quot;GC 标记状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;... | 11&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;GC 使用&quot;]
        
        style MW1 fill:#e8f5e9
        style MW2 fill:#fff9c4
        style MW3 fill:#e1f5ff
        style MW4 fill:#ffcdd2
        style MW5 fill:#f5f5f5
    end
    
    subgraph &quot;指向的目标&quot;
        LR[&quot;Lock Record&lt;br/&gt;（栈上）&quot;]
        MON[&quot;ObjectMonitor&lt;br/&gt;（C++ 堆）&quot;]
        
        style LR fill:#e1f5ff
        style MON fill:#ffcdd2
    end
    
    MW3 --&gt;|&quot;指针&quot;| LR
    MW4 --&gt;|&quot;指针&quot;| MON</code></pre>
<p><strong>关键理解：synchronized(obj) 的加锁过程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (obj) &#123;<br>    <span class="hljs-comment">// 临界区代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码的加锁过程：</p>
<ol>
<li><strong>首先尝试偏向锁</strong>（如果启用）：检查 Mark Word 是否已偏向当前线程</li>
<li><strong>偏向失败，尝试轻量级锁</strong>：在栈帧创建 Lock Record，CAS 替换 Mark Word</li>
<li><strong>轻量级锁失败，膨胀为重量级锁</strong>：
<ul>
<li>创建或获取 ObjectMonitor</li>
<li>将 Mark Word 替换为指向 Monitor 的指针</li>
<li>当前线程成为 Monitor 的 owner</li>
<li>竞争失败的线程进入 Monitor 的等待队列并阻塞</li>
</ul>
</li>
</ol>
<p><strong>小结：轻量级锁与重量级锁的核心差异</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>轻量级锁&quot;轻&quot;在哪里？</strong></td>
<td>不使用 OS 的 Mutex，只用 CAS 指令，无系统调用，无线程阻塞</td>
</tr>
<tr>
<td><strong>为什么用 Lock Record 而不是 Monitor？</strong></td>
<td>Lock Record 在栈上自动管理，无需分配/回收，CAS 操作比 Mutex 快几十倍</td>
</tr>
<tr>
<td><strong>synchronized(obj) 靠 Mark Word 引用 Monitor 吗？</strong></td>
<td>是的，重量级锁状态下 Mark Word 存储的就是指向 ObjectMonitor 的指针</td>
</tr>
<tr>
<td><strong>Monitor 是凭空 new 出来的吗？</strong></td>
<td>是延迟创建的，只有膨胀为重量级锁时才会创建，且可能从池中复用</td>
</tr>
</tbody>
</table>
<p>&quot;Mark Word&quot;被设计成一个非固定的数据结构，以便在极小的空间内存储尽量多的信息。因此，它的内存布局是可变的。要动态地理解对象的数据结构，可以采用 jol 工具：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student stu=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(<span class="hljs-string">&quot;=====加锁之前======&quot;</span>);<br>        System.out.println(ClassLayout.parseInstance(stu).toPrintable());<br>        <span class="hljs-keyword">synchronized</span> (stu)&#123;<br>            System.out.println(<span class="hljs-string">&quot;=====加锁之后======&quot;</span>);<br>            System.out.println(ClassLayout.parseInstance(stu).toPrintable());<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为&quot;01&quot;），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储所对象目前的 Mark Word的拷贝（实际上被命名为 Displaced Markd Word）。<strong>也就是说，试图求锁的线程局部栈帧可能是不一样的。</strong></p>
<h3 id="线程栈帧与-lock-record-的结构">线程栈帧与 Lock Record 的结构</h3>
<p>要理解轻量级锁的工作原理，首先需要理解线程栈帧的结构以及 Lock Record 在其中的位置。</p>
<p><strong>线程栈帧（Stack Frame）的基本结构：</strong></p>
<p>每个线程在执行方法时，JVM 会为该方法创建一个栈帧（Stack Frame），栈帧是方法执行的基本单位。栈帧包含以下几个核心部分：</p>
<table>
<thead>
<tr>
<th>组成部分</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>局部变量表（Local Variable Table）</strong></td>
<td>存储方法参数和方法内定义的局部变量</td>
</tr>
<tr>
<td><strong>操作数栈（Operand Stack）</strong></td>
<td>用于执行字节码指令时的临时数据存储</td>
</tr>
<tr>
<td><strong>动态链接（Dynamic Linking）</strong></td>
<td>指向运行时常量池中该方法的引用</td>
</tr>
<tr>
<td><strong>方法返回地址（Return Address）</strong></td>
<td>方法正常退出或异常退出后的返回位置</td>
</tr>
<tr>
<td><strong>Lock Record（锁记录）</strong></td>
<td><strong>仅在进入 synchronized 块时创建</strong>，用于轻量级锁的实现</td>
</tr>
</tbody>
</table>
<p><strong>图：线程栈帧结构与 Lock Record 的位置</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;线程栈（Thread Stack）&quot;
        direction TB
        
        subgraph &quot;栈帧3（当前方法 - synchronized 块内）&quot;
            LVT3[&quot;局部变量表&lt;br/&gt;Local Variable Table&quot;]
            OS3[&quot;操作数栈&lt;br/&gt;Operand Stack&quot;]
            DL3[&quot;动态链接&lt;br/&gt;Dynamic Linking&quot;]
            RA3[&quot;方法返回地址&lt;br/&gt;Return Address&quot;]
            
            subgraph &quot;Lock Record（锁记录）&quot;
                DMW[&quot;Displaced Mark Word&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;对象原始 Mark Word 的备份&lt;br/&gt;（hashCode、age 等信息）&quot;]
                OBJ_REF[&quot;owner 指针&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;指向被锁定的对象&quot;]
            end
            
            style DMW fill:#e8f5e9
            style OBJ_REF fill:#fff9c4
        end
        
        subgraph &quot;栈帧2（调用方法）&quot;
            LVT2[&quot;局部变量表&quot;]
            OS2[&quot;操作数栈&quot;]
            DL2[&quot;动态链接&quot;]
            RA2[&quot;方法返回地址&quot;]
            style LVT2 fill:#f5f5f5
            style OS2 fill:#f5f5f5
            style DL2 fill:#f5f5f5
            style RA2 fill:#f5f5f5
        end
        
        subgraph &quot;栈帧1（main 方法）&quot;
            LVT1[&quot;局部变量表&quot;]
            OS1[&quot;操作数栈&quot;]
            DL1[&quot;动态链接&quot;]
            RA1[&quot;方法返回地址&quot;]
            style LVT1 fill:#f5f5f5
            style OS1 fill:#f5f5f5
            style DL1 fill:#f5f5f5
            style RA1 fill:#f5f5f5
        end
    end
    
    subgraph &quot;堆（Heap）&quot;
        OBJ[&quot;锁对象&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Object Header:&lt;br/&gt;Mark Word | Klass Word&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Object Body&quot;]
        style OBJ fill:#e1f5ff
    end
    
    OBJ_REF --&gt;|&quot;指向&quot;| OBJ
    OBJ --&gt;|&quot;Mark Word 存储&lt;br/&gt;Lock Record 指针&quot;| DMW
    
    note1[&quot;Lock Record 是栈帧的一部分&lt;br/&gt;仅在进入 synchronized 块时动态创建&lt;br/&gt;退出时销毁&quot;]
    style note1 fill:#fff9c4</code></pre>
<p><strong>Lock Record 的内部结构：</strong></p>
<p>Lock Record 是轻量级锁实现的核心数据结构，它包含两个关键字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Displaced Mark Word</strong></td>
<td>markOop</td>
<td>对象原始 Mark Word 的备份。当获取轻量级锁时，对象的 Mark Word 会被替换为指向 Lock Record 的指针，原始信息（hashCode、GC age 等）就保存在这里。解锁时需要将其恢复回对象头。</td>
</tr>
<tr>
<td><strong>owner（对象指针）</strong></td>
<td>oop</td>
<td>指向被锁定对象的指针。用于标识这个 Lock Record 锁定的是哪个对象，也用于 GC 时的对象引用追踪。</td>
</tr>
</tbody>
</table>
<p><strong>图：轻量级锁加锁过程中 Lock Record 与对象的交互</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Thread as 线程栈帧
    participant LR as Lock Record
    participant OBJ as 锁对象
    participant MW as Mark Word
    
    Note over Thread,MW: 1. 进入 synchronized 块
    
    Thread-&gt;&gt;LR: 在栈帧中创建 Lock Record
    Thread-&gt;&gt;LR: 初始化 owner 指向锁对象
    
    Note over Thread,MW: 2. 备份原始 Mark Word
    
    OBJ-&gt;&gt;MW: 读取当前 Mark Word
    MW-&gt;&gt;LR: 拷贝到 Displaced Mark Word
    Note over LR: Displaced Mark Word =&lt;br/&gt;hashCode | age | 01
    
    Note over Thread,MW: 3. CAS 尝试获取锁
    
    Thread-&gt;&gt;MW: CAS(原始值, Lock Record 指针)
    
    alt CAS 成功
        MW-&gt;&gt;MW: Mark Word = ptr_to_LR | 00
        Note over Thread,MW: 获取轻量级锁成功！
    else CAS 失败
        alt Mark Word 已指向当前线程的 Lock Record
            Note over Thread,MW: 锁重入，直接进入
        else Mark Word 指向其他线程
            Note over Thread,MW: 竞争失败，锁膨胀为重量级锁
        end
    end</code></pre>
<p><strong>图：Lock Record 在锁重入场景下的表现</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;线程栈（同一线程多次进入 synchronized）&quot;
        direction TB
        
        subgraph &quot;栈帧 - 第三次进入 synchronized&quot;
            LR3[&quot;Lock Record 3&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word: null&lt;br/&gt;owner: → 锁对象&quot;]
            style LR3 fill:#ffcdd2
        end
        
        subgraph &quot;栈帧 - 第二次进入 synchronized&quot;
            LR2[&quot;Lock Record 2&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word: null&lt;br/&gt;owner: → 锁对象&quot;]
            style LR2 fill:#fff9c4
        end
        
        subgraph &quot;栈帧 - 第一次进入 synchronized&quot;
            LR1[&quot;Lock Record 1&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word: 原始值&lt;br/&gt;owner: → 锁对象&quot;]
            style LR1 fill:#c8e6c9
        end
    end
    
    subgraph &quot;堆&quot;
        OBJ[&quot;锁对象&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word:&lt;br/&gt;ptr_to_LR1 | 00&quot;]
        style OBJ fill:#e1f5ff
    end
    
    LR1 --&gt;|&quot;owner&quot;| OBJ
    LR2 --&gt;|&quot;owner&quot;| OBJ
    LR3 --&gt;|&quot;owner&quot;| OBJ
    OBJ --&gt;|&quot;Mark Word 指向&quot;| LR1
    
    note1[&quot;锁重入时：&lt;br/&gt;1. 每次进入都创建新的 Lock Record&lt;br/&gt;2. 只有第一个 LR 保存原始 Mark Word&lt;br/&gt;3. 后续 LR 的 Displaced Mark Word 为 null&lt;br/&gt;4. 解锁时按栈顺序逐个弹出 LR&lt;br/&gt;5. 遇到非 null 的 Displaced Mark Word 时恢复&quot;]
    style note1 fill:#fff9c4</code></pre>
<p><strong>Lock Record 放在栈帧中的原因</strong></p>
<ol>
<li><strong>生命周期自动管理</strong>：栈帧随方法调用创建、随方法返回销毁，Lock Record 也随之自动管理，无需额外的内存分配和回收</li>
<li><strong>线程私有</strong>：每个线程有自己的栈，Lock Record 天然是线程私有的，无需同步</li>
<li><strong>支持锁重入</strong>：每次进入 synchronized 块都会创建新的 Lock Record，通过栈的 LIFO 特性天然支持锁重入的计数和恢复</li>
<li><strong>快速访问</strong>：栈帧在 CPU 缓存中的命中率高，访问速度快</li>
</ol>
<h3 id="lock-record-的生命周期-生老病死">Lock Record 的生命周期（生老病死）</h3>
<p>理解 Lock Record 的完整生命周期，是理解轻量级锁机制的关键：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Thread as 线程
    participant Stack as 线程栈帧
    participant LR as Lock Record
    participant OBJ as 锁对象
    participant MW as Mark Word
    
    Note over Thread,MW: 1. 创建（Birth）：进入 synchronized 块
    
    Thread-&gt;&gt;Stack: 在当前栈帧中分配空间
    Stack-&gt;&gt;LR: 创建 Lock Record
    LR-&gt;&gt;LR: 初始化 owner 指向锁对象
    
    Note over Thread,MW: 2. 备份（Backup）：保存原始 Mark Word
    
    Thread-&gt;&gt;MW: 读取当前 Mark Word
    MW-&gt;&gt;LR: 拷贝到 Displaced Mark Word
    
    Note over Thread,MW: 3. 竞争（Compete）：CAS 尝试获取锁
    
    Thread-&gt;&gt;MW: CAS(原始值, LR指针|00)
    
    alt CAS 成功
        MW-&gt;&gt;MW: 更新为 ptr_to_LR | 00
        Note over LR: Lock Record 生效&lt;br/&gt;线程持有锁
    else CAS 失败（竞争）
        Note over LR: Lock Record 仍存在于栈帧&lt;br/&gt;但未能成为&quot;有效&quot;的锁记录
        Thread-&gt;&gt;Thread: 自旋重试或触发锁膨胀
    end
    
    Note over Thread,MW: 4. 释放（Release）：退出 synchronized 块
    
    Thread-&gt;&gt;MW: CAS(LR指针|00, 原始Mark Word)
    
    alt CAS 成功
        MW-&gt;&gt;MW: 恢复原始 Mark Word
        Note over LR: 正常解锁
    else CAS 失败（锁已膨胀）
        Note over LR: 按重量级锁方式释放
    end
    
    Note over Thread,MW: 5. 销毁（Death）：栈帧弹出
    
    Stack-&gt;&gt;LR: 随栈帧销毁而自动回收
    Note over LR: Lock Record 生命周期结束</code></pre>
<p><strong>Lock Record 生命周期的关键问题解答：</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>每个线程都有 Lock Record 吗？</strong></td>
<td>只有尝试获取锁的线程才会创建 Lock Record。每次进入 synchronized 块时创建，退出时销毁。</td>
</tr>
<tr>
<td><strong>竞争失败的线程还有 Lock Record 吗？</strong></td>
<td><strong>有</strong>。竞争失败的线程的 Lock Record 仍然存在于其栈帧中，只是它的 Displaced Mark Word 没有被&quot;采用&quot;——锁对象的 Mark Word 没有指向它。</td>
</tr>
<tr>
<td><strong>Lock Record 什么时候销毁？</strong></td>
<td>当线程退出 synchronized 块时，栈帧弹出，Lock Record 随之自动销毁。这是栈内存的天然特性。</td>
</tr>
<tr>
<td><strong>锁膨胀后 Lock Record 怎么办？</strong></td>
<td>锁膨胀后，Lock Record 仍然存在，但解锁时需要按重量级锁的方式处理（唤醒等待线程等）。Lock Record 中的 Displaced Mark Word 会被转移到 ObjectMonitor 的 <code>_header</code> 字段。</td>
</tr>
</tbody>
</table>
<h3 id="轻量级锁没有-waitset-和-entrylist-的原因">轻量级锁没有 WaitSet 和 EntryList 的原因</h3>
<p>重量级锁的 ObjectMonitor 有 <code>_EntryList</code>（阻塞等待队列）和 <code>_WaitSet</code>（wait 等待队列），但轻量级锁的 Lock Record 完全没有这些结构。这是因为<strong>轻量级锁的设计假设是&quot;竞争很少发生&quot;，因此不需要管理等待线程</strong>。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;轻量级锁的设计假设&quot;
        ASSUME[&quot;假设：锁竞争很少发生&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 大多数情况下，锁是无竞争的&lt;br/&gt;• 即使有竞争，也是短暂的&lt;br/&gt;• 竞争失败的线程自旋几次就能获取锁&quot;]
        style ASSUME fill:#c8e6c9
    end
    
    subgraph &quot;因此不需要&quot;
        NO_ENTRY[&quot;不需要 EntryList&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;竞争失败的线程不阻塞&lt;br/&gt;而是自旋重试&quot;]
        NO_WAIT[&quot;不需要 WaitSet&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;轻量级锁不支持 wait/notify&lt;br/&gt;调用 wait() 会触发锁膨胀&quot;]
        NO_COND[&quot;不需要 Condition&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;条件等待需要阻塞线程&lt;br/&gt;这与轻量级锁的设计冲突&quot;]
        
        style NO_ENTRY fill:#fff9c4
        style NO_WAIT fill:#fff9c4
        style NO_COND fill:#fff9c4
    end
    
    ASSUME --&gt; NO_ENTRY
    ASSUME --&gt; NO_WAIT
    ASSUME --&gt; NO_COND
    
    subgraph &quot;一旦假设被打破&quot;
        INFLATE[&quot;立即膨胀为重量级锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• CAS 自旋超过阈值&lt;br/&gt;• 调用 wait()/notify()&lt;br/&gt;• 竞争过于激烈&quot;]
        style INFLATE fill:#ffcdd2
    end
    
    NO_ENTRY --&gt;|&quot;假设失效&quot;| INFLATE
    NO_WAIT --&gt;|&quot;假设失效&quot;| INFLATE
    NO_COND --&gt;|&quot;假设失效&quot;| INFLATE</code></pre>
<p><strong>轻量级锁 vs 重量级锁的数据结构对比：</strong></p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>轻量级锁（Lock Record）</th>
<th>重量级锁（ObjectMonitor）</th>
<th>为什么轻量级锁不需要</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Displaced Mark Word</strong></td>
<td>有</td>
<td>有（<code>_header</code> 字段）</td>
<td>都需要备份原始 Mark Word</td>
</tr>
<tr>
<td><strong>owner 指针</strong></td>
<td>有</td>
<td>有（<code>_owner</code> 字段）</td>
<td>都需要记录持锁线程</td>
</tr>
<tr>
<td><strong>重入计数</strong></td>
<td>有（多个 Lock Record）</td>
<td>有（<code>_recursions</code> 字段）</td>
<td>都需要支持锁重入</td>
</tr>
<tr>
<td><strong>EntryList</strong></td>
<td>无</td>
<td>有</td>
<td>轻量级锁不阻塞线程，自旋重试</td>
</tr>
<tr>
<td><strong>WaitSet</strong></td>
<td>无</td>
<td>有</td>
<td>轻量级锁不支持 wait/notify</td>
</tr>
<tr>
<td><strong>cxq（竞争队列）</strong></td>
<td>无</td>
<td>有</td>
<td>轻量级锁不排队，直接自旋</td>
</tr>
<tr>
<td><strong>Mutex/Condition</strong></td>
<td>无</td>
<td>有</td>
<td>轻量级锁不使用 OS 同步原语</td>
</tr>
</tbody>
</table>
<h3 id="自旋与阻塞：锁等待机制的优化">自旋与阻塞：锁等待机制的优化</h3>
<p>在理解了偏向锁和轻量级锁的实现原理后，我们需要深入讨论一个关键问题：当线程获取锁失败时，应该如何等待？</p>
<h4 id="自旋优化的必要性">自旋优化的必要性</h4>
<p>一个已经拥有 CPU 执行时间的线程，在求锁的时候，如果直接被阻塞（进入内核态等待），会带来显著的性能开销：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>开销</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>用户态/内核态切换</strong></td>
<td>≈ 1000+ CPU 周期</td>
<td>需要保存/恢复寄存器、切换特权级别</td>
</tr>
<tr>
<td><strong>线程上下文切换</strong></td>
<td>≈ 5000+ CPU 周期</td>
<td>需要保存/恢复线程状态、刷新 TLB</td>
</tr>
<tr>
<td><strong>CAS 操作</strong></td>
<td>≈ 10-100 CPU 周期</td>
<td>仅需原子指令，无需内核介入</td>
</tr>
</tbody>
</table>
<p>如果锁的持有时间很短（如简单的 getter/setter），线程阻塞后很快就会被唤醒，那么<strong>阻塞和唤醒的开销可能远超过实际执行临界区代码的开销</strong>。这就是自旋锁存在的意义：<strong>用 CPU 空转换取避免线程切换的开销</strong>。</p>
<h4 id="自旋锁的实现原理">自旋锁的实现原理</h4>
<p>自旋锁的核心思想是：当线程获取锁失败时，不立即阻塞，而是执行一个<strong>忙循环（busy waiting）</strong>，不断尝试获取锁。</p>
<p><strong>图：自旋锁 vs 阻塞锁的执行流程对比</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;阻塞锁（传统方式）&quot;
        direction TB
        B1[&quot;线程尝试获取锁&quot;]
        B2&#123;&quot;获取成功?&quot;&#125;
        B3[&quot;进入临界区执行&quot;]
        B4[&quot;释放锁&quot;]
        B5[&quot;阻塞线程&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;1. 保存线程上下文&lt;br/&gt;2. 用户态→内核态&lt;br/&gt;3. 加入等待队列&lt;br/&gt;4. 调度其他线程&quot;]
        B6[&quot;被唤醒&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;1. 内核态→用户态&lt;br/&gt;2. 恢复线程上下文&lt;br/&gt;3. 重新调度&quot;]
        
        B1 --&gt; B2
        B2 --&gt;|是| B3
        B2 --&gt;|否| B5
        B5 --&gt;|锁释放| B6
        B6 --&gt; B1
        B3 --&gt; B4
        
        style B5 fill:#ffcdd2
        style B6 fill:#ffcdd2
    end
    
    subgraph &quot;自旋锁&quot;
        direction TB
        S1[&quot;线程尝试获取锁&quot;]
        S2&#123;&quot;获取成功?&quot;&#125;
        S3[&quot;进入临界区执行&quot;]
        S4[&quot;释放锁&quot;]
        S5[&quot;自旋等待&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;while (!tryLock()) &#123;&lt;br/&gt;    // 空循环&lt;br/&gt;    // 或执行 PAUSE 指令&lt;br/&gt;&#125;&quot;]
        
        S1 --&gt; S2
        S2 --&gt;|是| S3
        S2 --&gt;|否| S5
        S5 --&gt;|继续尝试| S2
        S3 --&gt; S4
        
        style S5 fill:#fff9c4
    end</code></pre>
<p><strong>忙循环是怎么实现的？</strong></p>
<p>在 HotSpot JVM 中，自旋锁的实现并不是简单的 <code>while(true)</code> 空循环。实际的实现涉及以下几个层面：</p>
<ol>
<li><strong>字节码层面</strong>：<code>monitorenter</code> 指令在获取锁失败时，会进入 JVM 运行时的自旋逻辑</li>
<li><strong>JVM 运行时层面</strong>：在 <code>ObjectMonitor::enter()</code> 方法中实现自旋逻辑</li>
<li><strong>CPU 指令层面</strong>：使用 <code>PAUSE</code> 指令（x86）或类似指令来优化自旋</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// HotSpot 中自旋锁的简化伪代码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectMonitor::enter</span><span class="hljs-params">(TRAPS)</span> </span>&#123;<br>    <span class="hljs-comment">// 快速路径：尝试 CAS 获取锁</span><br>    <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">cmpxchg</span>(Self, &amp;_owner, <span class="hljs-literal">NULL</span>) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 获取成功</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 自旋尝试</span><br>    <span class="hljs-type">int</span> spinCount = Knob_SpinLimit; <span class="hljs-comment">// 自旋次数限制</span><br>    <span class="hljs-keyword">while</span> (spinCount-- &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (_owner == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">cmpxchg</span>(Self, &amp;_owner, <span class="hljs-literal">NULL</span>) == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 自旋期间获取成功</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">SpinPause</span>(); <span class="hljs-comment">// 执行 PAUSE 指令，降低 CPU 功耗和总线竞争</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 自旋失败，进入阻塞</span><br>    <span class="hljs-built_in">EnterI</span>(THREAD);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong><code>PAUSE</code> 指令的作用：</strong></p>
<table>
<thead>
<tr>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>降低 CPU 功耗</strong></td>
<td>告诉 CPU 当前处于自旋等待状态，可以降低时钟频率</td>
</tr>
<tr>
<td><strong>减少总线竞争</strong></td>
<td>避免频繁的缓存行失效（cache line invalidation）</td>
</tr>
<tr>
<td><strong>提高超线程效率</strong></td>
<td>让出执行资源给同一物理核心上的其他超线程</td>
</tr>
<tr>
<td><strong>避免流水线惩罚</strong></td>
<td>防止 CPU 错误预测分支导致的流水线刷新</td>
</tr>
</tbody>
</table>
<h4 id="自旋次数的控制">自旋次数的控制</h4>
<p><strong>固定自旋（JDK 6 之前）：</strong></p>
<p>循环的次数通常不会很多，默认是 10 次。这个次数可以通过 <code>-XX:PreBlockSpin</code> 参数调整。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置自旋次数为 20</span><br>java -XX:PreBlockSpin=20 MyApplication<br></code></pre></td></tr></table></figure>
<p><strong>自适应自旋（Adaptive Spinning，JDK 6+）：</strong></p>
<p>固定自旋次数的问题在于：不同的锁、不同的场景，最优的自旋次数是不同的。JDK 6 引入了<strong>自适应自旋锁</strong>，让 JVM 根据运行时统计信息动态调整自旋次数：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;自适应自旋的决策逻辑&quot;
        direction TB
        
        HISTORY[&quot;历史统计信息&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 上次自旋是否成功&lt;br/&gt;• 锁的持有者状态&lt;br/&gt;• 自旋成功率&quot;]
        
        DECIDE&#123;&quot;决策&quot;&#125;
        
        INCREASE[&quot;增加自旋次数&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;上次自旋成功获取锁&lt;br/&gt;说明锁竞争不激烈&lt;br/&gt;值得多自旋几次&quot;]
        
        DECREASE[&quot;减少自旋次数&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;上次自旋失败&lt;br/&gt;说明锁竞争激烈&lt;br/&gt;自旋浪费 CPU&quot;]
        
        SKIP[&quot;跳过自旋&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;自旋从未成功过&lt;br/&gt;直接阻塞更高效&quot;]
        
        HISTORY --&gt; DECIDE
        DECIDE --&gt;|&quot;自旋成功率高&quot;| INCREASE
        DECIDE --&gt;|&quot;自旋成功率低&quot;| DECREASE
        DECIDE --&gt;|&quot;自旋从未成功&quot;| SKIP
        
        style INCREASE fill:#c8e6c9
        style DECREASE fill:#fff9c4
        style SKIP fill:#ffcdd2
    end</code></pre>
<p>自适应自旋的核心思想是：<strong>让 JVM 自己学习最优的自旋策略</strong>。如果对于某个锁，自旋经常能成功获取，那么下次就多自旋几次；如果自旋很少成功，那么下次就少自旋甚至直接阻塞。</p>
<h4 id="自旋锁的适用场景">自旋锁的适用场景</h4>
<p><strong>图：自旋锁 vs 阻塞锁的性能对比</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;锁持有时间短 + 竞争不激烈&quot;
        SHORT[&quot;临界区执行时间 &lt; 线程切换时间&quot;]
        SPIN_WIN[&quot;自旋锁胜出&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;自旋几次就能获取锁&lt;br/&gt;避免了线程切换开销&quot;]
        SHORT --&gt; SPIN_WIN
        style SPIN_WIN fill:#c8e6c9
    end
    
    subgraph &quot;锁持有时间长 + 竞争激烈&quot;
        LONG[&quot;临界区执行时间 &gt; 线程切换时间&quot;]
        BLOCK_WIN[&quot;阻塞锁胜出&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;自旋浪费大量 CPU&lt;br/&gt;不如让出 CPU 给其他线程&quot;]
        LONG --&gt; BLOCK_WIN
        style BLOCK_WIN fill:#c8e6c9
    end</code></pre>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐策略</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CAS 操作</strong>（如 <code>AtomicInteger.incrementAndGet()</code>）</td>
<td>自旋</td>
<td>操作极快（几个 CPU 周期），自旋几乎总能成功</td>
</tr>
<tr>
<td><strong>简单 getter/setter</strong></td>
<td>自旋</td>
<td>临界区代码很短，锁持有时间极短</td>
</tr>
<tr>
<td><strong>数据库操作、网络 I/O</strong></td>
<td>阻塞</td>
<td>操作耗时长，自旋会浪费大量 CPU</td>
</tr>
<tr>
<td><strong>高并发竞争</strong></td>
<td>阻塞</td>
<td>多个线程同时自旋会导致 CPU 资源浪费</td>
</tr>
</tbody>
</table>
<p><strong>自旋锁的本质权衡：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">自旋锁的收益 <span class="hljs-operator">=</span> 避免的线程切换开销<br>自旋锁的成本 <span class="hljs-operator">=</span> 自旋期间浪费的 CPU 时间<br><br>当 收益 &gt; 成本 时，自旋锁是划算的<br>当 收益 &lt; 成本 时，阻塞锁更高效<br></code></pre></td></tr></table></figure>
<p>这也是为什么 JVM 会结合使用自旋和阻塞：<strong>先自旋一定次数，如果还获取不到锁，再阻塞</strong>。这种策略在大多数场景下都能取得较好的平衡。</p>
<h4 id="锁膨胀的必然性：自旋失败是常态而非例外">锁膨胀的必然性：自旋失败是常态而非例外</h4>
<p>理解了自旋的本质权衡后，一个重要的推论是：<strong>在存在真实竞争的场景下，从轻量级锁膨胀到重量级锁几乎是必然的</strong>。</p>
<p>考虑以下推理链条：</p>
<ol>
<li>
<p><strong>synchronized 的语义是无限等待</strong>：与 <code>tryLock(timeout)</code> 不同，<code>synchronized</code> 没有超时机制。一旦线程尝试进入同步块，它必须获取锁才能继续，否则就一直等待。</p>
</li>
<li>
<p><strong>自旋次数是有限的</strong>：无论是固定自旋（默认约 10 次）还是自适应自旋，自旋次数都有上限。假设自旋循环执行 10-20 次，每次循环消耗约 100-200 个 CPU 周期，整个自旋过程大约持续 1-4 微秒。</p>
</li>
<li>
<p><strong>同步块执行时间通常远超自旋时间</strong>：即使是一个简单的同步块，只要包含任何有意义的业务逻辑（如一次 HashMap 操作、一次日志记录），其执行时间通常在微秒到毫秒级别。</p>
</li>
<li>
<p><strong>结论</strong>：如果线程 A 持有轻量级锁正在执行同步块，线程 B 尝试获取锁并开始自旋。只要同步块的执行时间超过自旋等待时间（这在绝大多数情况下都成立），线程 B 的自旋必然失败，锁必然膨胀为重量级锁。</p>
</li>
</ol>
<p><strong>图：自旋失败的时间竞赛</strong></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">时间轴 →<br>线程 A: |<span class="hljs-string">-------- 持有锁执行同步块（10-1000+ 微秒）--------</span>|<span class="hljs-string">释放锁</span>|<br>线程 B:      |<span class="hljs-string">自旋（1-4 微秒）</span>|<span class="hljs-string">膨胀</span>|<span class="hljs-string">阻塞等待.............</span>|<span class="hljs-string">被唤醒</span>|<br>                              |<span class="hljs-string"></span><br><span class="hljs-string">                    自旋时间 &lt;&lt; 同步块执行时间</span><br><span class="hljs-string">                    膨胀是必然结果</span><br></code></pre></td></tr></table></figure>
<p><strong>这个分析的实践意义：</strong></p>
<ol>
<li>
<p><strong>不要对轻量级锁抱有不切实际的期望</strong>：轻量级锁的真正价值在于处理&quot;交替访问&quot;（线程 A 释放锁后，线程 B 才来获取）的场景，而非&quot;同时竞争&quot;的场景。</p>
</li>
<li>
<p><strong>自旋的作用是&quot;延迟膨胀&quot;而非&quot;避免膨胀&quot;</strong>：自旋给了持锁线程一个短暂的窗口期来释放锁。如果持锁线程恰好在这个窗口期内释放锁，就避免了膨胀；否则膨胀不可避免。</p>
</li>
<li>
<p><strong>自旋可以看作轻量级的&quot;等待队列&quot;</strong>：在重量级锁中，等待线程被放入 <code>_EntryList</code> 队列并阻塞。而在轻量级锁阶段，自旋循环实际上起到了类似的&quot;等待&quot;作用——只不过是忙等待而非阻塞等待。自旋失败后，线程才真正进入 ObjectMonitor 的等待队列。</p>
</li>
<li>
<p><strong>synchronized 的&quot;无限等待&quot;语义决定了最终必须有阻塞机制</strong>：既然 synchronized 承诺&quot;一定能获取锁&quot;，那么在自旋失败后，唯一的选择就是阻塞等待。这就是为什么锁升级的终点必然是重量级锁——只有重量级锁才有完整的阻塞/唤醒机制。</p>
</li>
</ol>
<h3 id="什么是-竞争-？如何判定竞争程度？">什么是&quot;竞争&quot;？如何判定竞争程度？</h3>
<p>在锁优化的语境下，&quot;竞争&quot;有精确的技术定义：</p>
<p><strong>竞争的判定标准：</strong></p>
<table>
<thead>
<tr>
<th>竞争程度</th>
<th>判定条件</th>
<th>锁状态</th>
<th>线程行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无竞争</strong></td>
<td>始终只有一个线程访问锁</td>
<td>偏向锁</td>
<td>仅比较 threadId，零开销</td>
</tr>
<tr>
<td><strong>轻度竞争</strong></td>
<td>多个线程交替访问锁，但不同时</td>
<td>轻量级锁</td>
<td>CAS 总能成功，无需等待</td>
</tr>
<tr>
<td><strong>中度竞争</strong></td>
<td>多个线程同时尝试获取锁，但持锁时间短</td>
<td>轻量级锁 + 自旋</td>
<td>CAS 偶尔失败，自旋几次后成功</td>
</tr>
<tr>
<td><strong>重度竞争</strong></td>
<td>多个线程同时竞争，持锁时间长</td>
<td>重量级锁</td>
<td>CAS 频繁失败，自旋超时，线程阻塞</td>
</tr>
</tbody>
</table>
<p><strong>轻量级锁如何判定&quot;竞争发生&quot;？</strong></p>
<p>轻量级锁通过 <strong>CAS 操作的成功与否</strong> 来判定竞争：</p>
<pre><code class="hljs mermaid">graph TB
    START[&quot;线程尝试获取轻量级锁&quot;]
    CAS[&quot;CAS 将 Mark Word 替换为 Lock Record 指针&quot;]
    
    SUCCESS&#123;&quot;CAS 成功?&quot;&#125;
    
    LOCK_OK[&quot;获取锁成功&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;无竞争或竞争已结束&quot;]
    
    CHECK_REENTRY&#123;&quot;Mark Word 指向&lt;br/&gt;当前线程的 Lock Record?&quot;&#125;
    
    REENTRY[&quot;锁重入&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;创建新的 Lock Record&lt;br/&gt;Displaced Mark Word = null&quot;]
    
    SPIN[&quot;自旋重试&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;说明存在竞争&lt;br/&gt;但可能是短暂的&quot;]
    
    SPIN_CHECK&#123;&quot;自旋次数&lt;br/&gt;超过阈值?&quot;&#125;
    
    INFLATE[&quot;锁膨胀&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;竞争激烈&lt;br/&gt;升级为重量级锁&quot;]
    
    START --&gt; CAS
    CAS --&gt; SUCCESS
    SUCCESS --&gt;|是| LOCK_OK
    SUCCESS --&gt;|否| CHECK_REENTRY
    CHECK_REENTRY --&gt;|是| REENTRY
    CHECK_REENTRY --&gt;|否| SPIN
    SPIN --&gt; SPIN_CHECK
    SPIN_CHECK --&gt;|否| CAS
    SPIN_CHECK --&gt;|是| INFLATE
    
    style LOCK_OK fill:#c8e6c9
    style REENTRY fill:#c8e6c9
    style SPIN fill:#fff9c4
    style INFLATE fill:#ffcdd2</code></pre>
<p><strong>关键理解：轻量级锁的&quot;竞争&quot;触发锁膨胀</strong></p>
<p>轻量级锁的设计哲学是：<strong>一旦检测到真正的竞争（CAS 失败且不是锁重入），就认为轻量级锁的假设被打破，应该膨胀为重量级锁。</strong></p>
<p>这与偏向锁的区别在于：</p>
<ul>
<li><strong>偏向锁</strong>：第二个线程出现就撤销偏向，升级到轻量级锁</li>
<li><strong>轻量级锁</strong>：CAS 失败后先自旋重试，自旋超过阈值才膨胀为重量级锁</li>
</ul>
<p>自旋的存在是为了应对&quot;短暂竞争&quot;的场景——如果持锁线程很快就释放锁，等待线程自旋几次就能获取锁，比阻塞后再唤醒更高效。</p>
<p>然后虚拟机试图使用 CAS 操作尝试将对象的Mark Word 更新为指向 Lock Record 的指针（<strong>注意是整个Mark Word</strong>）。如果更新成功了，那么线程就拥有了该对象的锁，并且 Mark Word 的**锁标志位（Markword的最后两位）**转变为“00”。如果这个更新失败了，虚拟机首先会检查对象的 Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word也就变成指向重量级锁的指针（<strong>也就是说，不再指向 Lock Record</strong>）。</p>
<p>轻量级锁的解锁过程，也必须借助 CAS 操作，把 Displaced Mark Word 的值写到 Mark Word 上。如果替换完成，同步结束。如果替换失败，证明有其他线程尝试获取过该锁，说明在持有轻量级锁期间发生了锁膨胀。此时需要按重量级锁的方式释放锁并唤醒被挂起的线程。这确实是一个&quot;不对称&quot;的操作——加锁时使用轻量级锁，但解锁时需要按重量级锁处理。这种设计是合理的：锁膨胀发生在持锁期间，持锁线程在解锁时必须负责处理膨胀后的状态。</p>
<p><img src="https://ws1.sinaimg.cn/large/66dd581fly1flsf4024taj20h40a5q5u.jpg" alt=""></p>
<p><img src="https://ws1.sinaimg.cn/large/66dd581fly1flsf43kk1vj20d40abtb2.jpg" alt=""></p>
<p>轻量级锁在发生竞争时，依然会出现锁膨胀，而且还加上了CAS的开销，反而比直接使用重量级锁更慢。使用偏向锁只能根据一种经验假定，“绝大部分锁，在同步周期内是不存在竞争的”。</p>
<p>从这个过程我们可以看出来，mark word里并不是存了线程号，而是直接把mark word指向了目标线程的栈帧，轻量级锁和重量级锁的差别就在于底层是不是会触发 Mutex。</p>
<h3 id="锁竞争的详细场景分析">锁竞争的详细场景分析</h3>
<p>前面我们介绍了偏向锁、轻量级锁、重量级锁的基本原理，本节将通过详细的场景分析来说明<strong>当多个线程同时竞争锁时，具体会发生什么</strong>。</p>
<h4 id="轻量级锁竞争失败的处理策略">轻量级锁竞争失败的处理策略</h4>
<p>当线程尝试获取轻量级锁时 CAS 失败，JVM 会<strong>先自旋重试，自旋失败后才膨胀为重量级锁</strong>。</p>
<pre><code class="hljs mermaid">graph TB
    START[&quot;线程 B 尝试获取轻量级锁&quot;]
    CAS1[&quot;CAS 尝试将 Mark Word&lt;br/&gt;替换为自己的 Lock Record 指针&quot;]
    
    CAS1_RESULT&#123;&quot;CAS 成功?&quot;&#125;
    
    SUCCESS[&quot;获取锁成功&lt;br/&gt;进入临界区&quot;]
    
    CHECK_REENTRY&#123;&quot;Mark Word 指向&lt;br/&gt;当前线程的 Lock Record?&quot;&#125;
    
    REENTRY[&quot;锁重入&lt;br/&gt;创建新 Lock Record&lt;br/&gt;Displaced Mark Word = null&quot;]
    
    SPIN[&quot;自旋重试&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;在用户态循环执行 CAS&lt;br/&gt;期望持锁线程很快释放锁&quot;]
    
    SPIN_COUNT&#123;&quot;自旋次数&lt;br/&gt;超过阈值?&lt;br/&gt;（自适应调整）&quot;&#125;
    
    INFLATE[&quot;锁膨胀&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;1. 创建/获取 ObjectMonitor&lt;br/&gt;2. 将 Mark Word 替换为 Monitor 指针&lt;br/&gt;3. 线程进入 Monitor 的等待队列&lt;br/&gt;4. 线程被阻塞（park）&quot;]
    
    START --&gt; CAS1
    CAS1 --&gt; CAS1_RESULT
    CAS1_RESULT --&gt;|是| SUCCESS
    CAS1_RESULT --&gt;|否| CHECK_REENTRY
    CHECK_REENTRY --&gt;|是| REENTRY
    CHECK_REENTRY --&gt;|否| SPIN
    SPIN --&gt; SPIN_COUNT
    SPIN_COUNT --&gt;|否，继续自旋| CAS1
    SPIN_COUNT --&gt;|是，自旋超时| INFLATE
    
    style SUCCESS fill:#c8e6c9
    style REENTRY fill:#c8e6c9
    style SPIN fill:#fff9c4
    style INFLATE fill:#ffcdd2</code></pre>
<p><strong>关键理解：轻量级锁的自旋发生在哪里？</strong></p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>锁状态</th>
<th>自旋行为</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CAS 首次失败</strong></td>
<td>仍是轻量级锁</td>
<td>开始自旋</td>
<td>Mark Word 仍指向其他线程的 Lock Record，锁标志位仍是 <code>00</code></td>
</tr>
<tr>
<td><strong>自旋期间</strong></td>
<td>仍是轻量级锁</td>
<td>持续 CAS 重试</td>
<td>期望持锁线程释放锁，Mark Word 恢复为无锁状态</td>
</tr>
<tr>
<td><strong>自旋成功</strong></td>
<td>轻量级锁</td>
<td>停止自旋</td>
<td>CAS 成功，获取轻量级锁</td>
</tr>
<tr>
<td><strong>自旋超时</strong></td>
<td>膨胀为重量级锁</td>
<td>停止自旋</td>
<td>创建 Monitor，线程进入阻塞状态</td>
</tr>
</tbody>
</table>
<p><strong>HotSpot 中的实现细节：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 简化的轻量级锁获取逻辑（ObjectSynchronizer::slow_enter）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectSynchronizer::slow_enter</span><span class="hljs-params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;<br>    markOop mark = obj-&gt;<span class="hljs-built_in">mark</span>();<br>    <br>    <span class="hljs-comment">// 检查是否是无锁状态</span><br>    <span class="hljs-keyword">if</span> (mark-&gt;<span class="hljs-built_in">is_neutral</span>()) &#123;<br>        <span class="hljs-comment">// 尝试 CAS 获取轻量级锁</span><br>        lock-&gt;<span class="hljs-built_in">set_displaced_header</span>(mark);<br>        <span class="hljs-keyword">if</span> (mark == <span class="hljs-built_in">obj</span>()-&gt;<span class="hljs-built_in">cas_set_mark</span>((markOop)lock, mark)) &#123;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 获取成功</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 检查是否是锁重入</span><br>    <span class="hljs-keyword">if</span> (mark-&gt;<span class="hljs-built_in">has_locker</span>() &amp;&amp; <br>        THREAD-&gt;<span class="hljs-built_in">is_lock_owned</span>((address)mark-&gt;<span class="hljs-built_in">locker</span>())) &#123;<br>        lock-&gt;<span class="hljs-built_in">set_displaced_header</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 锁重入</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// CAS 失败，需要自旋或膨胀</span><br>    <span class="hljs-comment">// 注意：这里会先尝试自旋</span><br>    ObjectSynchronizer::<span class="hljs-built_in">inflate</span>(THREAD, <span class="hljs-built_in">obj</span>())-&gt;<span class="hljs-built_in">enter</span>(THREAD);<br>&#125;<br><br><span class="hljs-comment">// inflate 方法会创建 Monitor，enter 方法会先自旋再阻塞</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectMonitor::enter</span><span class="hljs-params">(TRAPS)</span> </span>&#123;<br>    <span class="hljs-comment">// 快速路径：尝试 CAS 获取</span><br>    <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">cmpxchg</span>(Self, &amp;_owner, <span class="hljs-literal">NULL</span>) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自旋尝试（在膨胀后仍会自旋！）</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TrySpin</span>(Self) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 自旋成功</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 自旋失败，进入阻塞</span><br>    <span class="hljs-built_in">EnterI</span>(THREAD);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>重要澄清：自旋发生在两个阶段</strong></p>
<ol>
<li><strong>轻量级锁阶段的自旋</strong>：CAS 失败后，在膨胀之前，会先进行一定次数的自旋重试</li>
<li><strong>重量级锁阶段的自旋</strong>：即使膨胀为重量级锁，在真正阻塞之前，<code>ObjectMonitor::enter()</code> 也会先自旋</li>
</ol>
<p>这意味着：<strong>线程从 CAS 失败到真正阻塞，中间会经历两轮自旋机会</strong>。</p>
<h4 id="偏向锁竞争：多线程场景详解">偏向锁竞争：多线程场景详解</h4>
<p>偏向锁的竞争场景比轻量级锁更复杂，因为涉及到<strong>偏向锁撤销</strong>这个需要安全点的操作。</p>
<p><strong>场景1：原偏向线程仍在同步块内，其他线程尝试获取锁</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 A（原偏向线程）
    participant OBJ as 锁对象
    participant T2 as 线程 B（竞争线程）
    participant VM as VM Thread
    
    Note over T1,OBJ: 初始状态：对象偏向线程 A
    
    T1-&gt;&gt;OBJ: 持有偏向锁，正在执行同步块
    Note over OBJ: Mark Word: threadId=A | 1 | 01
    
    T2-&gt;&gt;OBJ: 尝试获取锁
    T2-&gt;&gt;T2: 检查 Mark Word，发现偏向其他线程
    T2-&gt;&gt;VM: 请求撤销偏向锁
    
    Note over VM: 等待安全点（STW）
    VM-&gt;&gt;VM: 所有线程到达安全点
    
    VM-&gt;&gt;T1: 检查线程 A 的栈帧
    Note over VM: 发现线程 A 仍持有锁&lt;br/&gt;（栈帧中有对应的 Lock Record）
    
    VM-&gt;&gt;OBJ: 撤销偏向，升级为轻量级锁
    Note over OBJ: Mark Word: ptr_to_LR_A | 00&lt;br/&gt;（指向线程 A 的 Lock Record）
    
    VM-&gt;&gt;VM: 恢复所有线程
    
    T2-&gt;&gt;OBJ: 继续尝试获取轻量级锁
    T2-&gt;&gt;T2: CAS 失败（锁被 A 持有）
    T2-&gt;&gt;T2: 自旋等待...
    
    T1-&gt;&gt;OBJ: 释放锁（CAS 恢复 Mark Word）
    T2-&gt;&gt;OBJ: CAS 成功，获取轻量级锁</code></pre>
<p><strong>场景2：原偏向线程已退出同步块，其他线程尝试获取锁</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 A（原偏向线程）
    participant OBJ as 锁对象
    participant T2 as 线程 B（竞争线程）
    participant VM as VM Thread
    
    Note over T1,OBJ: 初始状态：对象偏向线程 A，但 A 已退出同步块
    
    Note over OBJ: Mark Word: threadId=A | 1 | 01&lt;br/&gt;（仍偏向 A，但 A 不在同步块内）
    
    T2-&gt;&gt;OBJ: 尝试获取锁
    T2-&gt;&gt;T2: 检查 Mark Word，发现偏向其他线程
    T2-&gt;&gt;VM: 请求撤销偏向锁
    
    Note over VM: 等待安全点（STW）
    VM-&gt;&gt;VM: 所有线程到达安全点
    
    VM-&gt;&gt;T1: 检查线程 A 的栈帧
    Note over VM: 发现线程 A 未持有锁&lt;br/&gt;（栈帧中没有对应的 Lock Record）
    
    alt 重偏向（Rebias）
        VM-&gt;&gt;OBJ: 将偏向锁重偏向到线程 B
        Note over OBJ: Mark Word: threadId=B | 1 | 01
        VM-&gt;&gt;VM: 恢复所有线程
        T2-&gt;&gt;T2: 获取偏向锁成功
    else 撤销偏向
        VM-&gt;&gt;OBJ: 撤销偏向，恢复为无锁状态
        Note over OBJ: Mark Word: hashCode | age | 0 | 01
        VM-&gt;&gt;VM: 恢复所有线程
        T2-&gt;&gt;OBJ: CAS 获取轻量级锁
        Note over OBJ: Mark Word: ptr_to_LR_B | 00
    end</code></pre>
<p><strong>场景3：多个线程同时竞争偏向锁</strong></p>
<p>这是最复杂的场景：假设对象偏向线程 A，此时线程 B、C、D 同时尝试获取锁。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;初始状态&quot;
        OBJ1[&quot;锁对象&lt;br/&gt;Mark Word: threadId=A | 1 | 01&lt;br/&gt;（偏向线程 A）&quot;]
        style OBJ1 fill:#fff9c4
    end
    
    subgraph &quot;多线程同时竞争&quot;
        T_A[&quot;线程 A&lt;br/&gt;（原偏向线程）&lt;br/&gt;可能在同步块内&lt;br/&gt;也可能已退出&quot;]
        T_B[&quot;线程 B&lt;br/&gt;尝试获取锁&quot;]
        T_C[&quot;线程 C&lt;br/&gt;尝试获取锁&quot;]
        T_D[&quot;线程 D&lt;br/&gt;尝试获取锁&quot;]
        
        style T_A fill:#c8e6c9
        style T_B fill:#e1f5ff
        style T_C fill:#e1f5ff
        style T_D fill:#e1f5ff
    end
    
    subgraph &quot;处理流程&quot;
        REVOKE[&quot;1. 触发偏向锁撤销&lt;br/&gt;（只会触发一次，由第一个检测到竞争的线程触发）&quot;]
        STW[&quot;2. 等待安全点（STW）&lt;br/&gt;所有线程暂停&quot;]
        CHECK[&quot;3. VM Thread 检查线程 A 的状态&quot;]
        
        UPGRADE[&quot;4. 升级为轻量级锁&lt;br/&gt;（如果 A 仍持有锁）&lt;br/&gt;或恢复为无锁状态&lt;br/&gt;（如果 A 已释放锁）&quot;]
        
        RESUME[&quot;5. 恢复所有线程&quot;]
        
        COMPETE[&quot;6. B、C、D 同时竞争轻量级锁&lt;br/&gt;只有一个能 CAS 成功&lt;br/&gt;其他线程自旋等待&quot;]
        
        INFLATE[&quot;7. 如果竞争激烈&lt;br/&gt;膨胀为重量级锁&lt;br/&gt;失败的线程进入等待队列&quot;]
        
        style REVOKE fill:#fff9c4
        style STW fill:#ffcdd2
        style COMPETE fill:#e1f5ff
        style INFLATE fill:#ffcdd2
    end
    
    OBJ1 --&gt; REVOKE
    T_B --&gt; REVOKE
    T_C --&gt; REVOKE
    T_D --&gt; REVOKE
    REVOKE --&gt; STW
    STW --&gt; CHECK
    CHECK --&gt; UPGRADE
    UPGRADE --&gt; RESUME
    RESUME --&gt; COMPETE
    COMPETE --&gt; INFLATE</code></pre>
<p><strong>多线程竞争的关键点：</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>谁触发偏向锁撤销？</strong></td>
<td>第一个检测到竞争的线程。其他线程会等待撤销完成。</td>
</tr>
<tr>
<td><strong>撤销期间其他线程在做什么？</strong></td>
<td>等待安全点。所有线程都会在安全点暂停。</td>
</tr>
<tr>
<td><strong>撤销后谁能获得锁？</strong></td>
<td>取决于原偏向线程的状态。如果原线程仍持有锁，它会继续持有（升级为轻量级锁）；如果原线程已释放，则竞争线程通过 CAS 竞争。</td>
</tr>
<tr>
<td><strong>多个竞争线程如何排序？</strong></td>
<td>轻量级锁阶段没有排序，谁 CAS 成功谁获得锁。膨胀为重量级锁后，由 Monitor 的等待队列管理。</td>
</tr>
</tbody>
</table>
<h4 id="批量重偏向与批量撤销">批量重偏向与批量撤销</h4>
<p>当一个类的对象频繁发生偏向锁撤销时，JVM 会采取更激进的策略：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;批量操作的触发条件&quot;
        SINGLE[&quot;单次撤销&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;某个对象的偏向锁被撤销&lt;br/&gt;计数器 +1&quot;]
        
        THRESHOLD1&#123;&quot;撤销次数 ≥ 20?&lt;br/&gt;（BiasedLockingBulkRebiasThreshold）&quot;&#125;
        
        BULK_REBIAS[&quot;批量重偏向&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;该类的 epoch +1&lt;br/&gt;后续该类的对象可以重偏向&lt;br/&gt;到新的线程&quot;]
        
        THRESHOLD2&#123;&quot;撤销次数 ≥ 40?&lt;br/&gt;（BiasedLockingBulkRevokeThreshold）&quot;&#125;
        
        BULK_REVOKE[&quot;批量撤销&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;禁用该类的偏向锁&lt;br/&gt;该类的所有对象直接使用轻量级锁&quot;]
        
        SINGLE --&gt; THRESHOLD1
        THRESHOLD1 --&gt;|否| SINGLE
        THRESHOLD1 --&gt;|是| BULK_REBIAS
        BULK_REBIAS --&gt; THRESHOLD2
        THRESHOLD2 --&gt;|否| SINGLE
        THRESHOLD2 --&gt;|是| BULK_REVOKE
        
        style SINGLE fill:#c8e6c9
        style BULK_REBIAS fill:#fff9c4
        style BULK_REVOKE fill:#ffcdd2
    end</code></pre>
<p><strong>epoch 机制详解：</strong></p>
<p>每个类都有一个 <code>epoch</code> 值，每个偏向锁对象的 Mark Word 中也存储了一个 <code>epoch</code> 值。当发生批量重偏向时：</p>
<ol>
<li>类的 <code>epoch</code> 值 +1</li>
<li>当线程尝试获取偏向锁时，会比较对象的 <code>epoch</code> 和类的 <code>epoch</code></li>
<li>如果不相等，说明对象的偏向锁已&quot;过期&quot;，可以直接重偏向到当前线程，无需撤销</li>
</ol>
<p>这个机制避免了频繁的偏向锁撤销开销。</p>
<h3 id="锁升级流程总结">锁升级流程总结</h3>
<p>综合以上所有内容，我们可以总结出 synchronized 锁的完整升级流程：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">无锁 → 偏向锁 → 轻量级锁 → 重量级锁<br></code></pre></td></tr></table></figure>
<p><strong>锁升级的触发条件：</strong></p>
<table>
<thead>
<tr>
<th>当前状态</th>
<th>升级条件</th>
<th>目标状态</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无锁</strong></td>
<td>第一个线程获取锁</td>
<td>偏向锁</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>第二个线程尝试获取锁（竞争）</td>
<td>轻量级锁</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>调用 <code>hashCode()</code></td>
<td>轻量级锁或重量级锁</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>CAS 自旋超过阈值</td>
<td>重量级锁</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>调用 <code>wait()</code>/<code>notify()</code></td>
<td>重量级锁</td>
</tr>
</tbody>
</table>
<p><strong>关键理解：</strong></p>
<ol>
<li><strong>锁只能升级，不能降级</strong>：一旦升级为重量级锁，即使竞争消失，也不会降级回轻量级锁或偏向锁</li>
<li><strong>偏向锁撤销需要安全点</strong>：偏向锁的撤销是一个 STW 操作，需要等待所有线程到达安全点</li>
<li><strong>轻量级锁膨胀是即时的</strong>：轻量级锁膨胀为重量级锁不需要等待安全点，可以立即进行</li>
</ol>
<h2 id="安全点-safepoint-：从锁问题诊断到-jvm-底层机制">安全点（Safepoint）：从锁问题诊断到 JVM 底层机制</h2>
<h3 id="引子：锁问题诊断与日志分析">引子：锁问题诊断与日志分析</h3>
<p>在前面的章节中，我们深入探讨了 synchronized 的锁升级机制：偏向锁、轻量级锁、重量级锁。理论知识只是第一步——<strong>当生产系统出现锁相关的性能问题时，诊断和定位的主要手段是查看日志</strong>。</p>
<p>但这里有一个关键的认知：<strong>锁的运行时行为，大部分是&quot;静默&quot;的</strong>。</p>
<table>
<thead>
<tr>
<th>锁操作</th>
<th>是否有日志</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁获取/释放</td>
<td>无</td>
<td>仅比较 threadId，零开销操作</td>
</tr>
<tr>
<td>轻量级锁 CAS</td>
<td>无</td>
<td>用户态原子指令，不涉及 JVM 状态切换</td>
</tr>
<tr>
<td>重量级锁获取/释放</td>
<td>无</td>
<td>虽然涉及 Monitor，但记录日志开销太大</td>
</tr>
<tr>
<td><strong>偏向锁撤销</strong></td>
<td>有</td>
<td>必须触发安全点，这是一个&quot;重&quot;操作</td>
</tr>
<tr>
<td><strong>锁膨胀</strong></td>
<td>有限</td>
<td>可通过 <code>-Xlog:monitorinflation</code> 观察</td>
</tr>
</tbody>
</table>
<p>从中可以观察到一个规律：<strong>只有那些需要&quot;暂停世界&quot;的锁操作，才会留下日志痕迹</strong>。</p>
<p>偏向锁撤销需要暂停世界并出现在日志中的原因，与 JVM 的一个底层机制密切相关——<strong>安全点（Safepoint）</strong>。</p>
<h3 id="日志与安全点的关系">日志与安全点的关系</h3>
<p>从一个具体的日志条目开始分析：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[0.452s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Entering</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span>: <span class="hljs-selector-tag">RevokeBias</span><br><span class="hljs-selector-attr">[0.453s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Leaving</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span><br><span class="hljs-selector-attr">[0.453s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Total</span> <span class="hljs-selector-tag">time</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">which</span> <span class="hljs-selector-tag">application</span> <span class="hljs-selector-tag">threads</span> <span class="hljs-selector-tag">were</span> <span class="hljs-selector-tag">stopped</span>: <span class="hljs-number">0.0008350</span> <span class="hljs-selector-tag">seconds</span><br></code></pre></td></tr></table></figure>
<p>这条日志告诉我们：</p>
<ol>
<li>JVM 进入了一个安全点区域</li>
<li>触发安全点的原因是 <code>RevokeBias</code>（撤销偏向锁）</li>
<li>所有应用线程被暂停了 0.8 毫秒</li>
</ol>
<p><strong>关键洞察：偏向锁撤销之所以有日志，是因为它必须触发安全点。安全点是 JVM 的&quot;全局暂停&quot;机制，任何触发安全点的操作都会被记录。</strong></p>
<p>讨论锁的日志诊断必须先理解安全点，两者的关系如下：</p>
<pre><code class="hljs mermaid">graph LR
    LOCK[&quot;锁问题诊断&quot;]
    LOG[&quot;查看日志&quot;]
    SP[&quot;理解安全点&quot;]
    ROOT[&quot;定位根因&quot;]
    
    LOCK --&gt;|&quot;第一步&quot;| LOG
    LOG --&gt;|&quot;发现 RevokeBias&quot;| SP
    SP --&gt;|&quot;理解机制&quot;| ROOT
    
    style LOCK fill:#e1f5ff
    style LOG fill:#fff9c4
    style SP fill:#ffcdd2
    style ROOT fill:#c8e6c9</code></pre>
<p>下面深入分析安全点的工作原理。</p>
<h3 id="安全点的本质：jvm-的-红绿灯">安全点的本质：JVM 的&quot;红绿灯&quot;</h3>
<p><strong>安全点是什么？</strong></p>
<p>想象一个十字路口：当交通灯变红时，所有车辆都必须停下来，让行人（或其他方向的车辆）安全通过。安全点就是 JVM 的&quot;红绿灯&quot;——当 JVM 需要执行某些全局操作时，它会&quot;亮红灯&quot;，让所有应用线程暂停。</p>
<p><strong>安全点的必要性</strong></p>
<p>GC 需要遍历堆中的所有对象，标记哪些是存活的、哪些是垃圾。但<strong>应用线程还在不断地修改对象引用</strong>——创建新对象、修改字段、调用方法。如果 GC 在遍历的同时，应用线程修改了对象引用，GC 看到的就是一个&quot;不一致&quot;的堆状态，可能会错误地回收存活对象，或者遗漏垃圾对象。</p>
<p>这就像你在数一群不断移动的羊——你数到第 50 只的时候，第 30 只可能已经跑到第 60 只的位置了。</p>
<p><strong>解决方案有两种思路：</strong></p>
<ol>
<li>
<p><strong>并发标记 + 写屏障</strong>：让 GC 和应用线程并发执行，通过写屏障（Write Barrier）记录引用的变化。这是 G1、ZGC、Shenandoah 等现代 GC 的做法，但实现复杂，且某些阶段仍需要 STW。</p>
</li>
<li>
<p><strong>Stop-The-World（STW）</strong>：让所有应用线程暂停，GC 独占 CPU 完成工作。这是最简单、最可靠的方式，但会造成应用停顿。</p>
</li>
</ol>
<p><strong>安全点就是实现 STW 的机制。</strong> 但这里有一个关键的洞察：</p>
<blockquote>
<p><strong>STW 依赖安全点实现，但安全点不只是为 GC 服务。</strong></p>
</blockquote>
<p>安全点是一个<strong>通用的线程协调机制</strong>，GC 只是它最常见的使用者之一。</p>
<h3 id="安全点的本质：线程状态的一致性快照">安全点的本质：线程状态的一致性快照</h3>
<p><strong>安全点的定义：</strong> 程序执行过程中的一个特定位置，在这个位置上，线程的状态是<strong>完全可描述的</strong>——所有的寄存器、栈帧、局部变量、锁状态都处于一个&quot;干净&quot;的状态，JVM 可以安全地检查和修改它们。</p>
<p>换句话说，安全点是线程的一个&quot;可拍照&quot;时刻。在这个时刻：</p>
<ul>
<li>所有 GC Roots（栈上的对象引用）都是可枚举的</li>
<li>所有锁的持有状态都是明确的</li>
<li>所有 JIT 编译的代码都可以被安全地去优化</li>
</ul>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;安全点的本质&quot;
        direction TB
        
        RUNNING[&quot;线程正在执行&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;寄存器、栈帧状态不断变化&lt;br/&gt;对象引用可能在寄存器中&lt;br/&gt;JVM 无法安全地检查线程状态&quot;]
        
        SAFEPOINT[&quot;到达安全点&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;所有对象引用都在已知位置&lt;br/&gt;（栈帧、OopMap 描述的位置）&lt;br/&gt;线程状态完全可描述&quot;]
        
        BLOCKED[&quot;线程阻塞在安全点&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;等待 VM 操作完成&lt;br/&gt;状态被&quot;冻结&quot;&quot;]
        
        RUNNING --&gt;|&quot;执行到安全点位置&quot;| SAFEPOINT
        SAFEPOINT --&gt;|&quot;响应 VM 请求&quot;| BLOCKED
        BLOCKED --&gt;|&quot;VM 操作完成&quot;| RUNNING
        
        style RUNNING fill:#fff9c4
        style SAFEPOINT fill:#c8e6c9
        style BLOCKED fill:#ffcdd2
    end</code></pre>
<h3 id="安全点在哪里？">安全点在哪里？</h3>
<p>JVM 不会在每条字节码指令后都插入安全点检查——那样开销太大。安全点只会出现在以下位置：</p>
<table>
<thead>
<tr>
<th>安全点位置</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>方法调用/返回</strong></td>
<td>方法边界是自然的状态一致点</td>
</tr>
<tr>
<td><strong>循环的回边（back edge）</strong></td>
<td>防止长时间运行的循环阻塞安全点（见下文详解）</td>
</tr>
<tr>
<td><strong>异常抛出点</strong></td>
<td>异常处理需要完整的栈状态</td>
</tr>
<tr>
<td><strong>JNI 调用返回</strong></td>
<td>从 native 代码返回时需要同步状态</td>
</tr>
<tr>
<td><strong>线程阻塞点</strong></td>
<td><code>Object.wait()</code>、<code>Thread.sleep()</code>、锁等待等</td>
</tr>
</tbody>
</table>
<p><strong>什么是循环的回边（Back Edge）？</strong></p>
<p>在控制流图（Control Flow Graph）中，<strong>回边</strong>是指从循环体末尾跳回到循环头部的边。简单来说，就是循环每次迭代结束、准备开始下一次迭代时的那个&quot;跳转点&quot;。</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">┌─────────────────────────────────────────────────────────────┐</span><br><span class="hljs-comment">│  for (int i = 0; i</span> &lt; <span class="hljs-comment">n; i</span><span class="hljs-literal">++</span><span class="hljs-comment">) &#123;                              │</span><br><span class="hljs-comment">│      doSomething();                                          │</span><br><span class="hljs-comment">│  &#125;  //</span> &lt;<span class="hljs-literal">--</span> <span class="hljs-comment">这里就是回边：i</span><span class="hljs-literal">++</span> <span class="hljs-comment">之后跳回到 i</span> &lt; <span class="hljs-comment">n 的判断          │</span><br><span class="hljs-comment">│      |                                                       │</span><br><span class="hljs-comment">│</span>      <span class="hljs-literal">+--</span> <span class="hljs-comment">回边（Back Edge）：从循环末尾跳回循环头部            │</span><br><span class="hljs-comment">└─────────────────────────────────────────────────────────────┘</span><br></code></pre></td></tr></table></figure>
<p>JVM 在回边处插入安全点检查的原因是：<strong>如果一个循环执行时间很长，而循环内部没有方法调用，那么线程可能长时间无法到达安全点</strong>。在回边处插入检查，可以确保每次循环迭代都有机会响应安全点请求。</p>
<p>但这里有一个重要的例外——<strong>可数循环（Counted Loop）</strong>：</p>
<p><strong>关键问题：可数循环（Counted Loop）的陷阱</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个循环可能导致安全点延迟！</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1_000_000_000</span>; i++) &#123;<br>    sum += array[i];  <span class="hljs-comment">// 没有方法调用，没有安全点</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>JIT 编译器会将这种&quot;可数循环&quot;（循环次数在编译时可确定）优化为不包含安全点检查的紧凑代码。这意味着如果 GC 请求 STW，必须等待这个循环执行完毕。这就是著名的 <strong>“Time To Safepoint”（TTSP）问题</strong>。</p>
<h3 id="安全点的工作机制">安全点的工作机制</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant VMThread as VM Thread
    participant Polling as Polling Page
    participant T1 as App Thread 1
    participant T2 as App Thread 2
    participant T3 as App Thread 3
    
    Note over VMThread: 需要执行 VM 操作&lt;br/&gt;（如 GC、偏向锁撤销）
    
    VMThread-&gt;&gt;Polling: 1. 设置 Polling Page 为不可读
    Note over Polling: 内存保护位变更
    
    par 并行检测
        T1-&gt;&gt;Polling: 2a. 读取 Polling Page
        Polling--&gt;&gt;T1: SIGSEGV 信号
        T1-&gt;&gt;T1: 进入安全点，阻塞
        
        T2-&gt;&gt;Polling: 2b. 读取 Polling Page
        Polling--&gt;&gt;T2: SIGSEGV 信号
        T2-&gt;&gt;T2: 进入安全点，阻塞
        
        T3-&gt;&gt;Polling: 2c. 读取 Polling Page
        Polling--&gt;&gt;T3: SIGSEGV 信号
        T3-&gt;&gt;T3: 进入安全点，阻塞
    end
    
    Note over VMThread: 3. 所有线程已到达安全点&lt;br/&gt;STW 开始
    
    VMThread-&gt;&gt;VMThread: 4. 执行 VM 操作&lt;br/&gt;（GC / 偏向锁撤销 / 去优化...）
    
    VMThread-&gt;&gt;Polling: 5. 恢复 Polling Page 为可读
    
    par 并行恢复
        T1-&gt;&gt;T1: 6a. 离开安全点，继续执行
        T2-&gt;&gt;T2: 6b. 离开安全点，继续执行
        T3-&gt;&gt;T3: 6c. 离开安全点，继续执行
    end
    
    Note over VMThread: STW 结束</code></pre>
<p><strong>Polling Page 机制详解：</strong></p>
<p>HotSpot 使用一种巧妙的&quot;陷阱&quot;机制来实现安全点检查：</p>
<ol>
<li><strong>正常状态</strong>：Polling Page 是一个可读的内存页，线程周期性地读取它（在安全点位置插入读取指令）</li>
<li><strong>请求 STW</strong>：VM Thread 将 Polling Page 设置为不可读（通过 <code>mprotect</code> 系统调用）</li>
<li><strong>触发信号</strong>：当应用线程读取不可读的内存页时，会触发 <code>SIGSEGV</code>（段错误）信号</li>
<li><strong>信号处理</strong>：JVM 的信号处理器捕获这个信号，让线程进入安全点并阻塞</li>
<li><strong>恢复执行</strong>：VM 操作完成后，恢复 Polling Page 为可读，唤醒所有线程</li>
</ol>
<p>这种设计的精妙之处在于：<strong>正常情况下，安全点检查只是一次内存读取，开销极小</strong>（通常在 L1 缓存命中）。只有在需要 STW 时，才会触发信号处理的开销。</p>
<h3 id="需要安全点的-vm-操作">需要安全点的 VM 操作</h3>
<p>GC 是最常见的安全点使用者，但远不是唯一的。以下是 HotSpot 中需要安全点的主要操作：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;需要 Safepoint 的 VM 操作&quot;
        direction TB
        
        subgraph &quot;GC 相关&quot;
            GC1[&quot;Young GC&quot;]
            GC2[&quot;Full GC&quot;]
            GC3[&quot;并发 GC 的 STW 阶段&lt;br/&gt;（初始标记、最终标记等）&quot;]
        end
        
        subgraph &quot;锁相关&quot;
            LOCK1[&quot;RevokeBias&lt;br/&gt;撤销单个对象的偏向锁&quot;]
            LOCK2[&quot;BulkRevokeBias&lt;br/&gt;批量撤销偏向锁&quot;]
            LOCK3[&quot;EnableBiasedLocking&lt;br/&gt;启用偏向锁（JVM 启动后延迟）&quot;]
        end
        
        subgraph &quot;代码相关&quot;
            CODE1[&quot;Deoptimize&lt;br/&gt;JIT 代码去优化&quot;]
            CODE2[&quot;IC_Stub_Invalidate&lt;br/&gt;内联缓存失效&quot;]
            CODE3[&quot;CodeCache_Flush&lt;br/&gt;代码缓存清理&quot;]
        end
        
        subgraph &quot;类相关&quot;
            CLASS1[&quot;ClassRedefinition&lt;br/&gt;热替换（JVMTI）&quot;]
            CLASS2[&quot;ClassUnloading&lt;br/&gt;类卸载&quot;]
        end
        
        subgraph &quot;诊断相关&quot;
            DIAG1[&quot;ThreadDump&lt;br/&gt;线程转储（jstack）&quot;]
            DIAG2[&quot;HeapDump&lt;br/&gt;堆转储&quot;]
            DIAG3[&quot;PrintThreads&lt;br/&gt;打印线程信息&quot;]
        end
        
        style GC1 fill:#ffcdd2
        style GC2 fill:#ffcdd2
        style GC3 fill:#ffcdd2
        style LOCK1 fill:#fff9c4
        style LOCK2 fill:#fff9c4
        style LOCK3 fill:#fff9c4
        style CODE1 fill:#c8e6c9
        style CODE2 fill:#c8e6c9
        style CODE3 fill:#c8e6c9
        style CLASS1 fill:#e1f5ff
        style CLASS2 fill:#e1f5ff
        style DIAG1 fill:#e1bee7
        style DIAG2 fill:#e1bee7
        style DIAG3 fill:#e1bee7
    end</code></pre>
<table>
<thead>
<tr>
<th>操作类别</th>
<th>典型操作</th>
<th>为什么需要安全点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>GC</strong></td>
<td>Young GC、Full GC、并发 GC 的 STW 阶段</td>
<td>需要枚举所有 GC Roots，确保堆状态一致</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>RevokeBias、BulkRevokeBias</td>
<td>需要修改对象头，遍历线程栈查找 Lock Record</td>
</tr>
<tr>
<td><strong>代码去优化</strong></td>
<td>Deoptimize</td>
<td>需要将 JIT 编译的栈帧转换为解释器栈帧</td>
</tr>
<tr>
<td><strong>类重定义</strong></td>
<td>ClassRedefinition（热替换）</td>
<td>需要更新所有引用该类的代码和对象</td>
</tr>
<tr>
<td><strong>诊断</strong></td>
<td>ThreadDump、HeapDump</td>
<td>需要获取所有线程的一致状态快照</td>
</tr>
</tbody>
</table>
<h3 id="安全点-vs-安全区域">安全点 vs 安全区域</h3>
<p>除了安全点，还有一个相关概念——<strong>安全区域（Safe Region）</strong>。</p>
<p>如果一个线程正在 <code>Thread.sleep()</code> 或等待 I/O，它不会执行代码，也就不会到达安全点。此时 VM Thread 不需要等待它，因为存在<strong>安全区域</strong>机制：当线程进入阻塞状态时，它会标记自己处于&quot;安全区域&quot;。在安全区域内，线程不会修改任何对象引用，因此 GC 可以安全地进行。</p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;安全点 vs 安全区域&quot;
        SP[&quot;安全点（Safepoint）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;代码中的特定位置&lt;br/&gt;线程主动检查并响应&lt;br/&gt;适用于正在执行的线程&quot;]
        
        SR[&quot;安全区域（Safe Region）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;一段代码区间&lt;br/&gt;线程进入时标记，离开时检查&lt;br/&gt;适用于阻塞的线程&quot;]
        
        SP ---|&quot;互补关系&quot;| SR
        
        style SP fill:#c8e6c9
        style SR fill:#e1f5ff
    end</code></pre>
<h3 id="thread-handshake：更细粒度的线程协调">Thread Handshake：更细粒度的线程协调</h3>
<p>传统的安全点是<strong>全局的</strong>——要么所有线程都停，要么都不停。但有些操作只需要停止特定的线程，全局 STW 就显得过于&quot;重&quot;了。</p>
<p><strong>JEP 312: Thread-Local Handshakes</strong>（JDK 10 引入）解决了这个问题：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;全局 Safepoint vs Thread Handshake&quot;
        direction LR
        
        subgraph &quot;全局 Safepoint&quot;
            GS_VM[&quot;VM Thread&quot;]
            GS_T1[&quot;Thread 1 (暂停)&quot;]
            GS_T2[&quot;Thread 2 (暂停)&quot;]
            GS_T3[&quot;Thread 3 (暂停)&quot;]
            GS_T4[&quot;Thread 4 (暂停)&quot;]
            
            GS_VM --&gt;|&quot;停止所有线程&quot;| GS_T1
            GS_VM --&gt;|&quot;停止所有线程&quot;| GS_T2
            GS_VM --&gt;|&quot;停止所有线程&quot;| GS_T3
            GS_VM --&gt;|&quot;停止所有线程&quot;| GS_T4
            
            style GS_T1 fill:#ffcdd2
            style GS_T2 fill:#ffcdd2
            style GS_T3 fill:#ffcdd2
            style GS_T4 fill:#ffcdd2
        end
        
        subgraph &quot;Thread Handshake&quot;
            TH_VM[&quot;VM Thread&quot;]
            TH_T1[&quot;Thread 1 (暂停)&quot;]
            TH_T2[&quot;Thread 2 (运行)&quot;]
            TH_T3[&quot;Thread 3 (运行)&quot;]
            TH_T4[&quot;Thread 4 (运行)&quot;]
            
            TH_VM --&gt;|&quot;只停止目标线程&quot;| TH_T1
            
            style TH_T1 fill:#ffcdd2
            style TH_T2 fill:#c8e6c9
            style TH_T3 fill:#c8e6c9
            style TH_T4 fill:#c8e6c9
        end
    end</code></pre>
<p>Thread Handshake 允许 VM 对单个线程执行操作，而不影响其他线程。这对于以下场景特别有用：</p>
<ul>
<li>单个线程的栈遍历</li>
<li>单个对象的偏向锁撤销（JDK 15+ 的改进）</li>
<li>线程局部的去优化</li>
</ul>
<h3 id="安全点与锁的关系">安全点与锁的关系</h3>
<p><strong>STW 与安全点的关系：</strong> STW 的本质就是让所有应用线程到达安全点并阻塞。</p>
<p><strong>安全点的适用范围：</strong> 安全点是一个通用的线程协调机制，GC 只是最常见的使用者。偏向锁撤销、代码去优化、类重定义、线程转储等都需要安全点。</p>
<p><strong>偏向锁撤销需要安全点的原因：</strong></p>
<ol>
<li>修改对象头（Mark Word）</li>
<li>遍历偏向线程的栈帧，查找 Lock Record</li>
<li>确保没有线程正在使用这个锁</li>
</ol>
<p>这些操作必须在目标线程&quot;静止&quot;的状态下进行，否则会出现竞态条件。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;偏向锁撤销为什么需要安全点&quot;
        direction TB
        
        OBJ[&quot;锁对象&lt;br/&gt;Mark Word: threadId | 1 | 01&lt;br/&gt;（偏向线程 A）&quot;]
        
        TA[&quot;线程 A（偏向线程）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;可能正在执行 synchronized 块&lt;br/&gt;栈帧中可能有 Lock Record&quot;]
        
        TB[&quot;线程 B（竞争者）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;尝试获取锁&lt;br/&gt;触发偏向锁撤销&quot;]
        
        VM[&quot;VM Thread&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;执行 RevokeBias 操作&quot;]
        
        TB --&gt;|&quot;1. 发现锁被偏向&quot;| OBJ
        TB --&gt;|&quot;2. 请求撤销偏向&quot;| VM
        VM --&gt;|&quot;3. 触发安全点&quot;| TA
        TA --&gt;|&quot;4. 到达安全点，阻塞&quot;| TA
        VM --&gt;|&quot;5. 遍历线程 A 的栈帧&quot;| TA
        VM --&gt;|&quot;6. 修改 Mark Word&quot;| OBJ
        
        style OBJ fill:#fff9c4
        style TA fill:#ffcdd2
        style TB fill:#e1f5ff
        style VM fill:#c8e6c9
    end</code></pre>
<p>这也解释了为什么偏向锁在 JDK 15 被废弃——每次偏向锁撤销都需要全局安全点，在高并发场景下，频繁的安全点会严重影响性能。</p>
<p>偏向锁在 JVM 内部的实现实在太复杂了，<a target="_blank" rel="noopener" href="https://blog.csdn.net/guanshengg/article/details/126435955">从 Java 15 开始要逐步 deprecated</a>。偏向锁的废弃历程如下：</p>
<table>
<thead>
<tr>
<th>JDK 版本</th>
<th>偏向锁状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>JDK 6 ~ JDK 14</strong></td>
<td>默认开启</td>
<td>需要 <code>-XX:-UseBiasedLocking</code> 显式关闭</td>
</tr>
<tr>
<td><strong>JDK 15</strong></td>
<td>默认关闭</td>
<td>JEP 374 将其标记为废弃，需要 <code>-XX:+UseBiasedLocking</code> 显式开启</td>
</tr>
<tr>
<td><strong>JDK 18+</strong></td>
<td>废弃</td>
<td>偏向锁代码仍存在但标记为废弃，<code>-XX:+UseBiasedLocking</code> 会产生警告</td>
</tr>
</tbody>
</table>
<p>废弃偏向锁的主要原因：</p>
<ol>
<li><strong>实现复杂度高</strong>：偏向锁的撤销（revocation）需要在安全点（safepoint）进行，涉及复杂的栈遍历和对象头修改</li>
<li><strong>维护成本大</strong>：偏向锁的代码与 HotSpot 的其他子系统（如 GC、栈遍历）深度耦合，增加了代码维护难度</li>
<li><strong>收益递减</strong>：现代应用中，无竞争的同步场景越来越少，偏向锁的优化收益不再显著</li>
<li><strong>替代方案成熟</strong>：轻量级锁的 CAS 操作在现代 CPU 上已经足够高效</li>
</ol>
<p>在日常的 JVM 调优中，很多团队为了避免偏向锁撤销带来的性能抖动，也会主动关闭偏向锁。</p>
<h3 id="锁相关的-jvm-日志诊断">锁相关的 JVM 日志诊断</h3>
<p>锁的状态切换（尤其是偏向锁撤销和锁膨胀）会触发 <strong>Safepoint</strong>（安全点），导致所有应用线程暂停。通过 JVM 日志可以诊断这些问题。</p>
<p><strong>JDK 8 及之前版本的日志参数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打印安全点统计信息</span><br>-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1<br><br><span class="hljs-comment"># 追踪偏向锁行为（仅限 debug 版本或开启诊断选项）</span><br>-XX:+UnlockDiagnosticVMOptions -XX:+TraceBiasedLocking<br></code></pre></td></tr></table></figure>
<p><strong>JDK 9+ 的 Unified Logging（统一日志）：</strong></p>
<p>JDK 9 引入了 <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/158">JEP 158: Unified JVM Logging</a>，所有 JVM 日志统一使用 <code>-Xlog</code> 语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打印安全点日志（info 级别）</span><br>-Xlog:safepoint=info<br><br><span class="hljs-comment"># 打印安全点详细日志（debug 级别，包含更多细节）</span><br>-Xlog:safepoint=debug<br><br><span class="hljs-comment"># 同时输出到文件，带时间戳和线程 ID</span><br>-Xlog:safepoint=debug:file=safepoint.log:<span class="hljs-keyword">time</span>,tid,level,tags<br></code></pre></td></tr></table></figure>
<p><strong>典型的安全点日志输出示例：</strong></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[0.452s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Application</span> <span class="hljs-selector-tag">time</span>: <span class="hljs-number">0.1950250</span> <span class="hljs-selector-tag">seconds</span><br><span class="hljs-selector-attr">[0.452s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Entering</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span>: <span class="hljs-selector-tag">RevokeBias</span><br><span class="hljs-selector-attr">[0.453s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Leaving</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span><br><span class="hljs-selector-attr">[0.453s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Total</span> <span class="hljs-selector-tag">time</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">which</span> <span class="hljs-selector-tag">application</span> <span class="hljs-selector-tag">threads</span> <span class="hljs-selector-tag">were</span> <span class="hljs-selector-tag">stopped</span>: <span class="hljs-number">0.0008350</span> <span class="hljs-selector-tag">seconds</span><br></code></pre></td></tr></table></figure>
<p><strong>常见的锁相关 Safepoint 操作（vmop）：</strong></p>
<table>
<thead>
<tr>
<th>Safepoint 操作</th>
<th>含义</th>
<th>触发场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RevokeBias</strong></td>
<td>撤销单个对象的偏向锁</td>
<td>偏向锁对象被其他线程访问</td>
</tr>
<tr>
<td><strong>BulkRevokeBias</strong></td>
<td>批量撤销某个类的所有对象的偏向锁</td>
<td>某个类的对象频繁发生偏向锁撤销，触发批量撤销阈值</td>
</tr>
<tr>
<td><strong>EnableBiasedLocking</strong></td>
<td>启用偏向锁</td>
<td>JVM 启动后延迟启用偏向锁（默认延迟 4 秒）</td>
</tr>
<tr>
<td><strong>Deoptimize</strong></td>
<td>去优化</td>
<td>JIT 编译的代码需要回退到解释执行</td>
</tr>
<tr>
<td><strong>G1IncCollectionPause</strong></td>
<td>G1 增量收集暂停</td>
<td>G1 GC 的 Young GC</td>
</tr>
<tr>
<td><strong>CGC_Operation</strong></td>
<td>并发 GC 操作</td>
<td>CMS/G1 的并发标记等阶段</td>
</tr>
</tbody>
</table>
<p><strong>诊断偏向锁性能问题的实战示例：</strong></p>
<p>如果你在日志中看到大量短暂但频繁的 <code>RevokeBias</code> 安全点：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[8501.234s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Entering</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span>: <span class="hljs-selector-tag">RevokeBias</span><br><span class="hljs-selector-attr">[8501.234s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Leaving</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span><br><span class="hljs-selector-attr">[8501.234s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Total</span> <span class="hljs-selector-tag">time</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">which</span> <span class="hljs-selector-tag">application</span> <span class="hljs-selector-tag">threads</span> <span class="hljs-selector-tag">were</span> <span class="hljs-selector-tag">stopped</span>: <span class="hljs-number">0.0001420</span> <span class="hljs-selector-tag">seconds</span><br><span class="hljs-selector-attr">[8501.278s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Entering</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span>: <span class="hljs-selector-tag">RevokeBias</span><br><span class="hljs-selector-attr">[8501.278s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Leaving</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span><br><span class="hljs-selector-attr">[8501.278s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Total</span> <span class="hljs-selector-tag">time</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">which</span> <span class="hljs-selector-tag">application</span> <span class="hljs-selector-tag">threads</span> <span class="hljs-selector-tag">were</span> <span class="hljs-selector-tag">stopped</span>: <span class="hljs-number">0.0001380</span> <span class="hljs-selector-tag">seconds</span><br></code></pre></td></tr></table></figure>
<p>虽然每次暂停时间很短（约 0.1ms），但如果每秒发生数百次，累积的停顿时间就会显著影响应用的吞吐量和延迟。此时应考虑：</p>
<ol>
<li><strong>关闭偏向锁</strong>：<code>-XX:-UseBiasedLocking</code>（JDK 15+ 默认已关闭）</li>
<li><strong>分析锁竞争</strong>：使用 <code>jstack</code> 或 JFR（Java Flight Recorder）分析哪些锁存在竞争</li>
<li><strong>优化代码</strong>：减少锁的粒度或使用无锁数据结构</li>
</ol>
<p><strong>JDK 17+ 的注意事项：</strong></p>
<p>由于偏向锁在 JDK 15 被默认禁用并标记为废弃（JEP 374），在 JDK 15+ 中默认情况下你将不再看到 <code>RevokeBias</code> 和 <code>BulkRevokeBias</code> 相关的安全点日志。取而代之的是更多的轻量级锁 CAS 操作，这些操作不需要安全点，因此不会出现在安全点日志中。</p>
<h3 id="各种锁优化的可观测性对比">各种锁优化的可观测性对比</h3>
<p>除了偏向锁，其他锁优化<strong>大部分没有直接的运行时日志</strong>，因为它们要么发生在编译期，要么是纯用户态操作。</p>
<table>
<thead>
<tr>
<th>锁优化类型</th>
<th>是否有 JVM 日志</th>
<th>原因</th>
<th>观测方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>偏向锁</strong></td>
<td>有（间接）</td>
<td>偏向锁撤销<strong>必须在安全点进行</strong>，需要暂停所有线程修改对象头</td>
<td>Safepoint 日志：<code>RevokeBias</code>、<code>BulkRevokeBias</code></td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>无</td>
<td>纯 CAS 操作，用户态原子指令，不涉及 JVM 状态切换</td>
<td><code>jstack</code> 查看线程状态；JFR 记录锁竞争事件</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>有限</td>
<td>Monitor 膨胀/收缩可记录，但锁的获取/释放本身无日志</td>
<td><code>-Xlog:monitorinflation=debug</code>（JDK 11+）；<code>jstack</code> 查看 <code>BLOCKED</code> 状态</td>
</tr>
<tr>
<td><strong>锁消除</strong></td>
<td>无（运行时）</td>
<td>JIT 编译时优化，发生在编译阶段而非运行时</td>
<td><code>-XX:+PrintEliminateLocks</code>（需 debug 版本）；JIT 编译日志</td>
</tr>
<tr>
<td><strong>锁粗化</strong></td>
<td>无（运行时）</td>
<td>同上，JIT 编译时优化</td>
<td>JIT 编译日志</td>
</tr>
</tbody>
</table>
<p><strong>重量级锁的 Monitor 膨胀日志（JDK 11+）：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 观察 Monitor 的膨胀和收缩</span><br>-Xlog:monitorinflation=debug<br></code></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[0.234s][<span class="hljs-built_in">debug</span>][monitorinflation] inflate(has_locker): <span class="hljs-attribute">object</span>=0x00000007bfe00000, <span class="hljs-attribute">mark</span>=0x00007f8a1c0008c0, <span class="hljs-attribute">type</span>=java.lang.Object<br>[0.567s][<span class="hljs-built_in">debug</span>][monitorinflation] deflate_idle_monitors: deflated 1 monitors <span class="hljs-keyword">in</span> 0.0001234 secs<br></code></pre></td></tr></table></figure>
<p><strong>使用 jstack 观察锁竞争：</strong></p>
<p>当线程因为重量级锁而阻塞时，<code>jstack</code> 会显示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-string">&quot;Thread-1&quot;</span> #<span class="hljs-number">12</span> prio=<span class="hljs-number">5</span> os_prio=<span class="hljs-number">0</span> tid=<span class="hljs-number">0</span>x00007f8a1c0008c0 nid=<span class="hljs-number">0</span>x1234 waiting <span class="hljs-keyword">for</span> monitor entry <span class="hljs-selector-attr">[0x00007f8a1c000000]</span><br>   java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.State</span>: BLOCKED (on <span class="hljs-selector-tag">object</span> monitor)<br>        at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyClass</span><span class="hljs-selector-class">.syncMethod</span>(MyClass<span class="hljs-selector-class">.java</span>:<span class="hljs-number">42</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0</span>x00000007bfe00000&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.lang</span>.Object)<br>        at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyClass</span><span class="hljs-selector-class">.run</span>(MyClass<span class="hljs-selector-class">.java</span>:<span class="hljs-number">30</span>)<br><br><span class="hljs-string">&quot;Thread-0&quot;</span> #<span class="hljs-number">11</span> prio=<span class="hljs-number">5</span> os_prio=<span class="hljs-number">0</span> tid=<span class="hljs-number">0</span>x00007f8a1c0007b0 nid=<span class="hljs-number">0</span>x1233 runnable <span class="hljs-selector-attr">[0x00007f8a1bfff000]</span><br>   java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.State</span>: RUNNABLE<br>        at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyClass</span><span class="hljs-selector-class">.syncMethod</span>(MyClass<span class="hljs-selector-class">.java</span>:<span class="hljs-number">45</span>)<br>        - locked &lt;<span class="hljs-number">0</span>x00000007bfe00000&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.lang</span>.Object)<br></code></pre></td></tr></table></figure>
<p>关键信息：</p>
<ul>
<li><code>waiting for monitor entry</code>：线程正在等待获取 Monitor</li>
<li><code>BLOCKED (on object monitor)</code>：线程状态为阻塞</li>
<li><code>waiting to lock &lt;0x...&gt;</code>：等待锁定的对象地址</li>
<li><code>locked &lt;0x...&gt;</code>：已持有锁的对象地址</li>
</ul>
<p><strong>使用 JFR 记录锁竞争事件：</strong></p>
<p>Java Flight Recorder 可以记录详细的锁竞争信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动 JFR 记录</span><br>java -XX:StartFlightRecording=filename=recording.jfr,settings=profile ...<br><br><span class="hljs-comment"># 或使用 jcmd 动态开启</span><br>jcmd &lt;pid&gt; JFR.start filename=recording.jfr settings=profile<br></code></pre></td></tr></table></figure>
<p>JFR 可以记录的锁相关事件：</p>
<ul>
<li><code>jdk.JavaMonitorEnter</code>：进入 synchronized 块</li>
<li><code>jdk.JavaMonitorWait</code>：调用 <code>Object.wait()</code></li>
<li><code>jdk.JavaMonitorInflate</code>：Monitor 膨胀事件</li>
<li><code>jdk.ThreadPark</code>：<code>LockSupport.park()</code> 事件（AQS 相关）</li>
</ul>
<p><strong>小结：大部分锁操作没有日志的原因</strong></p>
<p>这是一个<strong>性能与可观测性的权衡</strong>：</p>
<ol>
<li><strong>轻量级锁</strong>的设计目标就是&quot;零开销&quot;，如果每次 CAS 都记录日志，性能损耗会远超锁本身的开销</li>
<li><strong>锁消除和锁粗化</strong>发生在 JIT 编译期，编译完成后就是普通的代码执行，没有&quot;锁&quot;的概念了</li>
<li><strong>偏向锁撤销</strong>之所以有日志，是因为它<strong>必须触发安全点</strong>，这本身就是一个&quot;重&quot;操作，记录日志的边际成本很低</li>
</ol>
<p>因此，在生产环境中诊断锁问题，通常需要结合多种工具：</p>
<ul>
<li><strong>Safepoint 日志</strong>：诊断偏向锁撤销问题</li>
<li><strong>jstack</strong>：快速查看当前的锁竞争状态</li>
<li><strong>JFR</strong>：长期记录和分析锁竞争模式</li>
<li><strong>Async-profiler</strong>：采样分析锁等待时间</li>
</ul>
<p>无锁和轻量级锁的差别是：</p>
<ul>
<li>无锁是自旋修改同步资源：无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</li>
<li>轻量级锁是自旋抢锁而不是阻塞抢锁：是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</li>
</ul>
<p>如果硬要对比：</p>
<ul>
<li><strong>无锁</strong>更像是直接使用 <code>AtomicInteger.compareAndSet()</code> 进行乐观更新，失败就重试，不涉及任何锁的概念</li>
<li><strong>轻量级锁</strong>更像是 AQS 中 <code>tryAcquire()</code> 的非阻塞尝试部分——通过 CAS 竞争锁，失败后自旋重试，但不会立即阻塞线程</li>
</ul>
<p>两者的本质区别在于：无锁是对<strong>数据</strong>的 CAS 操作（修改共享变量本身），而轻量级锁是对<strong>锁状态</strong>的 CAS 操作（竞争 Mark Word 的所有权）。</p>
<h2 id="从-aqs-看锁的抽象模型">从 AQS 看锁的抽象模型</h2>
<p>在深入 <code>LockSupport</code> 之前，有必要先建立一个关于锁的抽象模型。这个模型将帮助我们理解：无论是 <code>synchronized</code> 的 ObjectMonitor，还是 <code>ReentrantLock</code> 的 AQS，它们本质上都在管理相同的核心信息。</p>
<h3 id="锁的核心职责与次级职责">锁的核心职责与次级职责</h3>
<p>任何锁机制都需要回答以下问题：</p>
<table>
<thead>
<tr>
<th>职责类型</th>
<th>核心问题</th>
<th>必要性</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心职责</strong></td>
<td>谁拥有锁？（owner）</td>
<td>必须——这是锁存在的根本意义</td>
</tr>
<tr>
<td><strong>次级职责</strong></td>
<td>谁在等待锁？（entry queue）</td>
<td>可选——可以用自旋代替队列</td>
</tr>
<tr>
<td><strong>次级职责</strong></td>
<td>谁在等待条件？（wait set）</td>
<td>可选——只有支持条件变量时才需要</td>
</tr>
<tr>
<td><strong>次级职责</strong></td>
<td>锁被重入了多少次？（recursion count）</td>
<td>可选——只有可重入锁才需要</td>
</tr>
</tbody>
</table>
<p><strong>核心职责是不可或缺的</strong>：无论锁的实现多么简化，&quot;谁拥有锁&quot;这个信息必须存在。偏向锁把 threadId 写入 Mark Word，轻量级锁通过 Lock Record 指针隐含 owner，重量级锁在 ObjectMonitor 的 <code>_owner</code> 字段显式记录——形式不同，但本质相同。</p>
<p><strong>次级职责可以有不同的实现策略</strong>：</p>
<ul>
<li><strong>自旋实现</strong>：不显式维护等待队列，让竞争线程在 for 循环中反复尝试 CAS。这是轻量级锁的策略。</li>
<li><strong>队列实现</strong>：显式维护等待线程的队列，竞争失败的线程入队并阻塞。这是重量级锁和 AQS 的策略。</li>
</ul>
<h3 id="aqs-如何具象化这个抽象模型">AQS 如何具象化这个抽象模型</h3>
<p><code>AbstractQueuedSynchronizer</code>（AQS）是 Doug Lea 设计的同步器框架，它将上述抽象模型具象化为具体的数据结构：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;AQS 的核心数据结构&quot;
        direction TB
        
        STATE[&quot;state: int&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;锁状态的统一抽象&lt;br/&gt;• 0 = 未锁定&lt;br/&gt;• 1 = 已锁定&lt;br/&gt;• &gt;1 = 重入次数&quot;]
        
        OWNER[&quot;exclusiveOwnerThread: Thread&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;核心职责：谁拥有锁&lt;br/&gt;显式记录持锁线程&quot;]
        
        SYNC_QUEUE[&quot;同步队列（CLH 变体）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;次级职责：谁在等待锁&lt;br/&gt;head ↔ Node ↔ Node ↔ tail&lt;br/&gt;每个 Node 封装一个等待线程&quot;]
        
        COND_QUEUE[&quot;条件队列（ConditionObject）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;次级职责：谁在等待条件&lt;br/&gt;firstWaiter → Node → Node&lt;br/&gt;每个 Condition 一个队列&quot;]
        
        STATE --&gt; OWNER
        OWNER --&gt; SYNC_QUEUE
        SYNC_QUEUE --&gt; COND_QUEUE
        
        style STATE fill:#e1f5ff
        style OWNER fill:#c8e6c9
        style SYNC_QUEUE fill:#fff9c4
        style COND_QUEUE fill:#ffecb3
    end</code></pre>
<p><strong>AQS 与 ObjectMonitor 的对位关系：</strong></p>
<table>
<thead>
<tr>
<th>抽象概念</th>
<th>AQS 实现</th>
<th>ObjectMonitor 实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>谁拥有锁</strong></td>
<td><code>exclusiveOwnerThread</code></td>
<td><code>_owner</code></td>
</tr>
<tr>
<td><strong>锁状态/重入计数</strong></td>
<td><code>state</code></td>
<td><code>_recursions</code></td>
</tr>
<tr>
<td><strong>等待获取锁的线程</strong></td>
<td>同步队列（CLH 变体）</td>
<td><code>_EntryList</code> + <code>_cxq</code></td>
</tr>
<tr>
<td><strong>等待条件的线程</strong></td>
<td><code>ConditionObject</code> 的条件队列</td>
<td><code>_WaitSet</code></td>
</tr>
<tr>
<td><strong>线程阻塞原语</strong></td>
<td><code>LockSupport.park()</code></td>
<td><code>pthread_cond_wait()</code></td>
</tr>
</tbody>
</table>
<p><strong>锁对象 → 同步器 → 线程的引用关系：</strong></p>
<h3 id="synchronized-的内存引用关系">synchronized 的内存引用关系</h3>
<p>synchronized 的内存引用关系<strong>不是简单的循环引用</strong>，而是根据锁状态有不同的实现：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;偏向锁状态（无循环引用）&quot;
        direction TB
        OBJ1[&quot;锁对象&quot;]
        MW1[&quot;Mark Word: 线程ID&quot;]
        STACK1[&quot;线程栈帧&quot;]
        
        OBJ1 --&gt; MW1
        MW1 -.-&gt;|存储| STACK1
        
        style OBJ1 fill:#e1f5ff
        style MW1 fill:#c8e6c9
        style STACK1 fill:#fff9c4
    end
    
    subgraph &quot;轻量级锁状态（无循环引用）&quot;
        direction TB
        OBJ2[&quot;锁对象&quot;]
        MW2[&quot;Mark Word: LockRecord指针&quot;]
        LR[&quot;Lock Record&lt;br/&gt;(栈中)&quot;]
        OBJREF[&quot;Object Reference&lt;br/&gt;(堆引用)&quot;]
        STACK2[&quot;线程栈帧&quot;]
        
        OBJ2 --&gt; MW2
        MW2 --&gt; LR
        LR --&gt; OBJREF
        OBJREF --&gt; OBJ2
        LR --&gt; STACK2
        
        style OBJ2 fill:#e1f5ff
        style MW2 fill:#c8e6c9
        style LR fill:#fff9c4
    end
    
    subgraph &quot;重量级锁状态（有循环引用）&quot;
        direction TB
        OBJ3[&quot;锁对象&quot;]
        MW3[&quot;Mark Word: ObjectMonitor指针&quot;]
        OM[&quot;ObjectMonitor&lt;br/&gt;(堆中)&quot;]
        OWNER[&quot;_owner 字段&quot;]
        THREAD[&quot;线程&quot;]
        STACK3[&quot;线程栈帧&lt;br/&gt;(持有对象引用)&quot;]
        
        OBJ3 --&gt; MW3
        MW3 --&gt; OM
        OM --&gt; OWNER
        OWNER --&gt; THREAD
        THREAD --&gt; STACK3
        STACK3 --&gt; OBJ3
        
        style OBJ3 fill:#e1f5ff
        style MW3 fill:#c8e6c9
        style OM fill:#ffcdd2
    end</code></pre>
<p><strong>关键技术说明</strong>：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>MarkWord 内容</th>
<th>线程如何引用锁对象</th>
<th>是否循环引用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>偏向锁</strong></td>
<td>存储线程 ID（54 位）</td>
<td>线程栈帧不需要持有引用</td>
<td>❌ 否</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>指向 Lock Record（栈中）</td>
<td>Lock Record 包含对象引用字段</td>
<td>❌ 否</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>指向 ObjectMonitor（堆中）</td>
<td>栈帧局部变量持有对象引用</td>
<td>✅ 是</td>
</tr>
</tbody>
</table>
<p><strong>关键技术依据</strong>（OpenJDK HotSpot Wiki）：</p>
<blockquote>
<p>“When a method synchronizes on an object, the header word and a pointer to the object are stored in a lock record within the current stack frame.”</p>
</blockquote>
<p>这明确说明：<strong>线程栈帧直接持有锁对象的堆引用</strong>（通过 Lock Record 的 Object Reference 字段），<strong>不需要通过 MarkWord 来指回锁对象</strong>。</p>
<h3 id="reentrantlock-的内存引用关系">ReentrantLock 的内存引用关系</h3>
<p>ReentrantLock 是纯 Java 实现，不依赖 MarkWord 机制：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;ReentrantLock 内存引用（纯 Java 对象引用）&quot;
        direction TB
        LOCK[&quot;ReentrantLock&quot;]
        SYNC[&quot;Sync extends AQS&quot;]
        STATE[&quot;volatile int state&quot;]
        OWNER[&quot;exclusiveOwnerThread&quot;]
        HEAD[&quot;CLH 队列头节点&quot;]
        TAIL[&quot;CLH 队列尾节点&quot;]
        NODE1[&quot;Node 1&quot;]
        NODE2[&quot;Node 2&quot;]
        THREAD1[&quot;线程 1&quot;]
        THREAD2[&quot;线程 2&quot;]
        STACK1[&quot;线程栈帧 1&quot;]
        STACK2[&quot;线程栈帧 2&quot;]
        
        LOCK --&gt; SYNC
        SYNC --&gt; STATE
        SYNC --&gt; OWNER
        SYNC --&gt; HEAD
        SYNC --&gt; TAIL
        HEAD --&gt; NODE1
        NODE1 --&gt; NODE2
        NODE1 --&gt; THREAD1
        NODE2 --&gt; THREAD2
        THREAD1 --&gt; STACK1
        THREAD2 --&gt; STACK2
        STACK1 --&gt; LOCK
        STACK2 --&gt; LOCK
        
        style LOCK fill:#e1f5ff
        style SYNC fill:#c8e6c9
        style NODE1 fill:#fff9c4
        style NODE2 fill:#fff9c4
    end</code></pre>
<p><strong>关键点</strong>：</p>
<ol>
<li><strong>ReentrantLock 不依赖 MarkWord</strong>：所有同步状态都存储在 <code>volatile int state</code> 字段中</li>
<li><strong>所有引用都是正常的 Java 对象引用</strong>：不需要 JVM 特殊支持</li>
<li><strong>始终存在循环引用</strong>：但这在可达性分析的 GC 中不是问题</li>
</ol>
<h3 id="两种锁机制的对比">两种锁机制的对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>MarkWord 使用</strong></td>
<td>依赖（偏向锁和轻量级锁）</td>
<td>不使用</td>
</tr>
<tr>
<td><strong>线程引用锁对象</strong></td>
<td>栈帧直接持有引用</td>
<td>栈帧局部变量持有引用</td>
</tr>
<tr>
<td><strong>循环引用</strong></td>
<td>仅重量级锁有</td>
<td>始终有</td>
</tr>
<tr>
<td><strong>实现位置</strong></td>
<td>JVM 层面</td>
<td>Java 层面</td>
</tr>
</tbody>
</table>
<h3 id="gc-如何处理循环引用？">GC 如何处理循环引用？</h3>
<p>Java 的 GC 使用<strong>可达性分析</strong>（Reachability Analysis）而非引用计数：</p>
<ul>
<li><strong>GC Roots</strong>：线程栈、静态变量、JNI 引用等</li>
<li><strong>回收条件</strong>：从 GC Roots 无法到达的对象才会被回收</li>
<li><strong>循环引用</strong>：只要从 GC Roots 可以到达，循环引用不会导致内存泄漏</li>
</ul>
<p>因此，无论是 synchronized 的重量级锁还是 ReentrantLock，循环引用都不会造成内存泄漏问题。</p>
<h3 id="这个抽象模型的意义">这个抽象模型的意义</h3>
<p>理解这个模型有助于：</p>
<ul>
<li><strong>理解锁升级的本质</strong>：从偏向锁到重量级锁，本质上是&quot;次级职责&quot;的实现方式从&quot;无&quot;到&quot;自旋&quot;再到&quot;队列&quot;的演进</li>
<li><strong>理解 LockSupport 的定位</strong>：<code>park()</code>/<code>unpark()</code> 是实现&quot;队列等待&quot;的底层原语，它让线程能够阻塞和唤醒，但不负责管理队列本身</li>
</ul>
<h2 id="aqs-深入解析">AQS 深入解析</h2>
<p>前面我们介绍了锁的抽象模型，现在让我们深入 AQS（AbstractQueuedSynchronizer）的具体实现。AQS 是 Doug Lea 设计的同步器框架，是 <code>java.util.concurrent</code> 包中大多数同步器的基础。</p>
<h3 id="为什么-aqs-不使用-os-底层的-mutex-conditionvariable">为什么 AQS 不使用 OS 底层的 mutex/conditionVariable</h3>
<p>一个常见的问题是：既然操作系统已经提供了成熟的 mutex（互斥锁）和 condition variable（条件变量），为什么 AQS 要在 Java 层面重新实现一套同步机制？</p>
<p>答案的核心在于<strong>减少用户态与内核态之间的切换开销</strong>。</p>
<h4 id="os-原语的开销分析">OS 原语的开销分析</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant App as 应用程序（用户态）
    participant Kernel as 操作系统（内核态）
    
    Note over App,Kernel: 使用 OS mutex 的加锁过程
    App-&gt;&gt;Kernel: 系统调用 pthread_mutex_lock
    Note over Kernel: 上下文切换（保存寄存器、切换栈）
    Kernel-&gt;&gt;Kernel: 检查锁状态
    alt 锁可用
        Kernel-&gt;&gt;App: 返回（获得锁）
    else 锁被占用
        Kernel-&gt;&gt;Kernel: 将线程加入等待队列
        Kernel-&gt;&gt;Kernel: 调度其他线程
        Note over Kernel: 线程阻塞...
        Kernel-&gt;&gt;App: 被唤醒后返回
    end
    Note over App,Kernel: 每次加锁/解锁都需要系统调用</code></pre>
<p>使用 OS 原语的问题：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>开销来源</th>
<th>典型耗时</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>系统调用</strong></td>
<td>用户态→内核态切换</td>
<td>数百到数千 CPU 周期</td>
</tr>
<tr>
<td><strong>上下文保存</strong></td>
<td>保存/恢复寄存器、栈指针</td>
<td>数十到数百 CPU 周期</td>
</tr>
<tr>
<td><strong>调度开销</strong></td>
<td>内核调度器决策</td>
<td>不确定，可能很长</td>
</tr>
<tr>
<td><strong>缓存失效</strong></td>
<td>切换后 CPU 缓存可能失效</td>
<td>数百 CPU 周期</td>
</tr>
</tbody>
</table>
<h4 id="aqs-的设计策略">AQS 的设计策略</h4>
<p>AQS 采用了一种<strong>分层优化</strong>的策略：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;AQS 的分层设计&quot;
        TRY[&quot;tryAcquire()&lt;br/&gt;纯用户态 CAS 操作&quot;]
        SPIN[&quot;短暂自旋&lt;br/&gt;用户态循环&quot;]
        PARK[&quot;LockSupport.park()&lt;br/&gt;最终才进入内核态&quot;]
        
        TRY --&gt;|&quot;成功&quot;| SUCCESS[&quot;获得锁&lt;br/&gt;零内核开销&quot;]
        TRY --&gt;|&quot;失败&quot;| SPIN
        SPIN --&gt;|&quot;自旋成功&quot;| SUCCESS
        SPIN --&gt;|&quot;自旋失败&quot;| PARK
        PARK --&gt;|&quot;被唤醒&quot;| TRY
        
        style TRY fill:#c8e6c9
        style SPIN fill:#fff9c4
        style PARK fill:#ffcdd2
        style SUCCESS fill:#e1f5ff
    end</code></pre>
<p><strong>AQS 的核心优化思想</strong>：</p>
<ol>
<li><strong>快路径优化</strong>：在无竞争或低竞争场景下，通过 CAS 操作在用户态完成锁的获取和释放，完全避免系统调用</li>
<li><strong>延迟阻塞</strong>：只有在 CAS 失败且自旋无效后，才调用 <code>LockSupport.park()</code> 进入内核态阻塞</li>
<li><strong>精确唤醒</strong>：使用 <code>LockSupport.unpark(thread)</code> 精确唤醒特定线程，而不是像 <code>Object.notifyAll()</code> 那样唤醒所有等待线程</li>
</ol>
<h4 id="synchronized-与-aqs-进入内核态的时机对比">synchronized 与 AQS 进入内核态的时机对比</h4>
<p>理解两种同步机制何时进入内核态，是掌握 Java 并发性能特征的关键。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph SYNC[&quot;synchronized 进入内核态的时机&quot;]
        direction TB
        S1[&quot;synchronized(obj)&quot;]
        S2&#123;&quot;偏向锁检查&quot;&#125;
        S3[&quot;偏向成功&lt;br/&gt;纯用户态&quot;]
        S4&#123;&quot;轻量级锁 CAS&quot;&#125;
        S5[&quot;CAS 成功&lt;br/&gt;纯用户态&quot;]
        S6[&quot;自适应自旋&quot;]
        S7&#123;&quot;自旋成功?&quot;&#125;
        S8[&quot;获得锁&lt;br/&gt;纯用户态&quot;]
        S9[&quot;锁膨胀为重量级锁&quot;]
        S10[&quot;ObjectMonitor::enter()&quot;]
        S11[&quot;pthread_mutex_lock()&lt;br/&gt;进入内核态&quot;]
        
        S1 --&gt; S2
        S2 --&gt;|&quot;是当前线程&quot;| S3
        S2 --&gt;|&quot;否&quot;| S4
        S4 --&gt;|&quot;成功&quot;| S5
        S4 --&gt;|&quot;失败&quot;| S6
        S6 --&gt; S7
        S7 --&gt;|&quot;是&quot;| S8
        S7 --&gt;|&quot;否&quot;| S9
        S9 --&gt; S10
        S10 --&gt; S11
        
        style S3 fill:#c8e6c9
        style S5 fill:#c8e6c9
        style S8 fill:#c8e6c9
        style S11 fill:#ffcdd2
    end
    
    subgraph AQS_FLOW[&quot;AQS (ReentrantLock) 进入内核态的时机&quot;]
        direction TB
        A1[&quot;lock.lock()&quot;]
        A2&#123;&quot;tryAcquire() CAS&quot;&#125;
        A3[&quot;CAS 成功&lt;br/&gt;纯用户态&quot;]
        A4[&quot;addWaiter() 入队&quot;]
        A5[&quot;acquireQueued() 循环&quot;]
        A6&#123;&quot;前驱是 head?&quot;&#125;
        A7&#123;&quot;tryAcquire() 成功?&quot;&#125;
        A8[&quot;获得锁&lt;br/&gt;纯用户态&quot;]
        A9[&quot;shouldParkAfterFailedAcquire()&quot;]
        A10&#123;&quot;前驱状态?&quot;&#125;
        A11[&quot;设置 SIGNAL&lt;br/&gt;再循环一次&quot;]
        A12[&quot;LockSupport.park()&lt;br/&gt;进入内核态&quot;]
        
        A1 --&gt; A2
        A2 --&gt;|&quot;成功&quot;| A3
        A2 --&gt;|&quot;失败&quot;| A4
        A4 --&gt; A5
        A5 --&gt; A6
        A6 --&gt;|&quot;是&quot;| A7
        A6 --&gt;|&quot;否&quot;| A9
        A7 --&gt;|&quot;是&quot;| A8
        A7 --&gt;|&quot;否&quot;| A9
        A9 --&gt; A10
        A10 --&gt;|&quot;非 SIGNAL&quot;| A11
        A10 --&gt;|&quot;SIGNAL&quot;| A12
        A11 --&gt; A5
        
        style A3 fill:#c8e6c9
        style A8 fill:#c8e6c9
        style A12 fill:#ffcdd2
    end</code></pre>
<p><strong>关键差异总结</strong>：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>synchronized</th>
<th>AQS (ReentrantLock)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>进入内核态的触发条件</strong></td>
<td>轻量级锁自旋失败，膨胀为重量级锁后</td>
<td>CAS 失败入队，设置好 SIGNAL 状态后调用 park</td>
</tr>
<tr>
<td><strong>内核态切换的实现</strong></td>
<td>ObjectMonitor 调用 pthread_mutex_lock</td>
<td>LockSupport.park 调用 pthread_cond_wait 或 futex</td>
</tr>
<tr>
<td><strong>自旋策略</strong></td>
<td>自适应自旋（JVM 根据历史成功率动态调整）</td>
<td>无忙等待自旋，仅 2-3 次状态检查循环</td>
</tr>
<tr>
<td><strong>锁状态管理</strong></td>
<td>JVM 内置，对象头 Mark Word</td>
<td>用户态 volatile state 字段</td>
</tr>
<tr>
<td><strong>唤醒机制</strong></td>
<td>notify/notifyAll（可能唤醒多个）</td>
<td>unpark（精确唤醒单个线程）</td>
</tr>
</tbody>
</table>
<p><strong>简化理解</strong>：</p>
<ul>
<li><strong>synchronized</strong>：偏向锁/轻量级锁阶段在用户态；竞争激烈时膨胀为重量级锁，此后每次竞争失败都进入内核态</li>
<li><strong>AQS</strong>：首次 tryAcquire 的 CAS 在用户态；失败后入队，经过 2-3 次状态设置循环后 park 进入内核态</li>
</ul>
<h4 id="性能对比">性能对比</h4>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;OS mutex（每次都进内核）&quot;
        M1[&quot;lock()&quot;] --&gt;|&quot;系统调用&quot;| M2[&quot;内核处理&quot;]
        M2 --&gt;|&quot;返回&quot;| M3[&quot;临界区&quot;]
        M3 --&gt;|&quot;系统调用&quot;| M4[&quot;unlock()&quot;]
    end
    
    subgraph &quot;AQS（低竞争时不进内核）&quot;
        A1[&quot;lock()&quot;] --&gt;|&quot;CAS 成功&quot;| A2[&quot;临界区&quot;]
        A2 --&gt;|&quot;CAS&quot;| A3[&quot;unlock()&quot;]
        
        style A1 fill:#c8e6c9
        style A2 fill:#c8e6c9
        style A3 fill:#c8e6c9
    end</code></pre>
<table>
<thead>
<tr>
<th>场景</th>
<th>OS mutex</th>
<th>AQS</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无竞争</strong></td>
<td>2次系统调用</td>
<td>2次 CAS（纯用户态）</td>
</tr>
<tr>
<td><strong>低竞争</strong></td>
<td>2次系统调用 + 可能阻塞</td>
<td>几次 CAS + 短暂自旋</td>
</tr>
<tr>
<td><strong>高竞争</strong></td>
<td>系统调用 + 阻塞</td>
<td>CAS + 自旋 + park（进内核）</td>
</tr>
</tbody>
</table>
<p>在无竞争和低竞争场景下（这是大多数实际应用的常态），AQS 的性能优势非常明显。只有在高竞争场景下，两者的开销才趋于接近。</p>
<h4 id="为什么-aqs-的自旋是-短暂-的">为什么 AQS 的自旋是&quot;短暂&quot;的</h4>
<p>上表中&quot;低竞争&quot;场景提到的&quot;短暂自旋&quot;需要特别说明。与 synchronized 轻量级锁的自适应自旋不同，AQS 的&quot;自旋&quot;本质上是<strong>入队后到真正 park 之间的状态检查循环</strong>，而非忙等待式的自旋。</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;AQS 的短暂自旋过程&quot;
        direction TB
        
        ENQUEUE[&quot;线程入队成功&quot;]
        LOOP[&quot;进入 acquireQueued 循环&quot;]
        CHECK_PRED&#123;&quot;前驱是 head?&quot;&#125;
        TRY[&quot;tryAcquire()&quot;]
        SUCCESS&#123;&quot;获取成功?&quot;&#125;
        GOT_LOCK[&quot;获得锁，退出&quot;]
        
        SHOULD_PARK[&quot;shouldParkAfterFailedAcquire()&quot;]
        PRED_STATUS&#123;&quot;前驱状态?&quot;&#125;
        
        SIGNAL[&quot;前驱是 SIGNAL&quot;]
        PARK[&quot;返回 true → park&quot;]
        
        ZERO[&quot;前驱是 0&quot;]
        SET_SIGNAL[&quot;CAS 设置为 SIGNAL&quot;]
        RETRY1[&quot;返回 false → 再循环一次&quot;]
        
        CANCELLED[&quot;前驱 &gt; 0（已取消）&quot;]
        SKIP[&quot;跳过已取消节点&quot;]
        RETRY2[&quot;返回 false → 再循环一次&quot;]
        
        ENQUEUE --&gt; LOOP
        LOOP --&gt; CHECK_PRED
        CHECK_PRED --&gt;|是| TRY
        CHECK_PRED --&gt;|否| SHOULD_PARK
        TRY --&gt; SUCCESS
        SUCCESS --&gt;|是| GOT_LOCK
        SUCCESS --&gt;|否| SHOULD_PARK
        
        SHOULD_PARK --&gt; PRED_STATUS
        PRED_STATUS --&gt;|SIGNAL| SIGNAL
        PRED_STATUS --&gt;|0| ZERO
        PRED_STATUS --&gt;|&gt;0| CANCELLED
        
        SIGNAL --&gt; PARK
        ZERO --&gt; SET_SIGNAL --&gt; RETRY1
        CANCELLED --&gt; SKIP --&gt; RETRY2
        
        RETRY1 --&gt; LOOP
        RETRY2 --&gt; LOOP
        
        style PARK fill:#ffcdd2
        style GOT_LOCK fill:#c8e6c9
    end</code></pre>
<p><strong>关键点：AQS 最多循环 2-3 次就会 park</strong></p>
<ol>
<li><strong>第一次循环</strong>：前驱节点状态为 0（初始状态），<code>shouldParkAfterFailedAcquire</code> 将其 CAS 设置为 SIGNAL，返回 false</li>
<li><strong>第二次循环</strong>：前驱节点状态已是 SIGNAL，<code>shouldParkAfterFailedAcquire</code> 返回 true，线程 park</li>
</ol>
<p>这就是&quot;短暂自旋&quot;的真正含义：不是像 synchronized 那样在忙循环中等待锁释放，而是在设置好唤醒机制后立即阻塞。这种设计的优势在于：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>synchronized 自适应自旋</th>
<th>AQS “短暂自旋”</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>自旋目的</strong></td>
<td>等待锁持有者释放锁</td>
<td>设置前驱节点的 SIGNAL 状态</td>
</tr>
<tr>
<td><strong>自旋次数</strong></td>
<td>动态调整（几十到几百次）</td>
<td>固定 2-3 次</td>
</tr>
<tr>
<td><strong>CPU 消耗</strong></td>
<td>高（忙等待）</td>
<td>极低（仅状态检查）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>锁持有时间短</td>
<td>所有场景</td>
</tr>
</tbody>
</table>
<h4 id="locksupport-park-与-os-原语的关系">LockSupport.park() 与 OS 原语的关系</h4>
<p>虽然 AQS 避免了直接使用 OS 的 mutex，但 <code>LockSupport.park()</code> 最终仍然依赖操作系统的线程阻塞机制：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Java 层&quot;
        PARK[&quot;LockSupport.park()&quot;]
    end
    
    subgraph &quot;JVM 层（C++）&quot;
        UNSAFE[&quot;Unsafe.park()&quot;]
        PARKER[&quot;Parker::park()&quot;]
    end
    
    subgraph &quot;OS 层&quot;
        LINUX[&quot;Linux: pthread_cond_wait&quot;]
        MACOS[&quot;macOS: semaphore_wait&quot;]
        WIN[&quot;Windows: WaitForSingleObject&quot;]
    end
    
    PARK --&gt; UNSAFE
    UNSAFE --&gt; PARKER
    PARKER --&gt; LINUX
    PARKER --&gt; MACOS
    PARKER --&gt; WIN</code></pre>
<p><strong>关键区别</strong>：AQS 不是完全避免内核调用，而是<strong>尽可能延迟和减少</strong>内核调用。通过在用户态完成大部分同步逻辑，只在真正需要阻塞时才进入内核态，从而在整体上显著降低了同步开销。</p>
<h3 id="state：同步状态的统一抽象">state：同步状态的统一抽象</h3>
<p>AQS 的核心是一个 <code>volatile int state</code> 字段，它是<strong>锁状态的统一抽象</strong>。不同的同步器对 state 有不同的解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS 中的 state 定义</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br><br><span class="hljs-comment">// 访问方法</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> state; &#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123; state = newState; &#125;<br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>    <span class="hljs-keyword">return</span> U.compareAndSetInt(<span class="hljs-built_in">this</span>, STATE, expect, update);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="state-在不同同步器中的语义">state 在不同同步器中的语义</h4>
<table>
<thead>
<tr>
<th>同步器</th>
<th>state 的含义</th>
<th>值的解释</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ReentrantLock</strong></td>
<td>重入次数</td>
<td>0=未锁定，1=锁定一次，n=重入n次</td>
</tr>
<tr>
<td><strong>ReentrantReadWriteLock</strong></td>
<td>读写锁状态</td>
<td>高16位=读锁持有数，低16位=写锁重入数</td>
</tr>
<tr>
<td><strong>Semaphore</strong></td>
<td>可用许可数</td>
<td>n=剩余n个许可</td>
</tr>
<tr>
<td><strong>CountDownLatch</strong></td>
<td>剩余计数</td>
<td>n=还需等待n个countdown</td>
</tr>
<tr>
<td><strong>CyclicBarrier</strong></td>
<td>等待线程数</td>
<td>通过 ReentrantLock 间接使用</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;state 的多态语义&quot;
        direction LR
        
        subgraph &quot;ReentrantLock&quot;
            RL_STATE[&quot;state = 3&quot;]
            RL_MEANING[&quot;含义：线程重入了 3 次&quot;]
        end
        
        subgraph &quot;ReentrantReadWriteLock&quot;
            RWL_STATE[&quot;state = 0x00020001&quot;]
            RWL_MEANING[&quot;含义：2个读锁 + 1次写锁重入&quot;]
        end
        
        subgraph &quot;Semaphore&quot;
            SEM_STATE[&quot;state = 5&quot;]
            SEM_MEANING[&quot;含义：还剩 5 个许可&quot;]
        end
        
        subgraph &quot;CountDownLatch&quot;
            CDL_STATE[&quot;state = 3&quot;]
            CDL_MEANING[&quot;含义：还需 3 次 countdown&quot;]
        end
        
        style RL_STATE fill:#e1f5ff
        style RWL_STATE fill:#c8e6c9
        style SEM_STATE fill:#fff9c4
        style CDL_STATE fill:#ffecb3
    end</code></pre>
<h4 id="reentrantreadwritelock-的-state-位分割">ReentrantReadWriteLock 的 state 位分割</h4>
<p><code>ReentrantReadWriteLock</code> 巧妙地将 32 位的 state 分成两部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ReentrantReadWriteLock.Sync 中的位操作</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_SHIFT</span>   <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_UNIT</span>    <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT);  <span class="hljs-comment">// 65536</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span>      <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 65535</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCLUSIVE_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;  <span class="hljs-comment">// 0xFFFF</span><br><br><span class="hljs-comment">// 获取读锁持有数（高16位）</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sharedCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>    &#123; <span class="hljs-keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;<br><span class="hljs-comment">// 获取写锁重入数（低16位）</span><br><span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exclusiveCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123; <span class="hljs-keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;state 的位布局（32位）&quot;
        direction TB
        
        BITS[&quot;| 31 ... 16 | 15 ... 0 |&quot;]
        HIGH[&quot;高 16 位&lt;br/&gt;读锁持有数&lt;br/&gt;（共享锁计数）&quot;]
        LOW[&quot;低 16 位&lt;br/&gt;写锁重入数&lt;br/&gt;（独占锁计数）&quot;]
        
        BITS --&gt; HIGH
        BITS --&gt; LOW
        
        EXAMPLE[&quot;示例：state = 0x00030002&lt;br/&gt;= 3个读锁 + 写锁重入2次&quot;]
        
        style HIGH fill:#c8e6c9
        style LOW fill:#ffcdd2
        style EXAMPLE fill:#fff9c4
    end</code></pre>
<h3 id="state-在互斥模式与共享模式的本质差异">state 在互斥模式与共享模式的本质差异</h3>
<p>AQS 的设计精妙之处在于：<strong>同一个 state 字段，在不同的同步器中承载完全不同的语义</strong>。理解这一点是理解 AQS 灵活性的关键。</p>
<h4 id="互斥模式-vs-共享模式的-state-语义">互斥模式 vs 共享模式的 state 语义</h4>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;互斥模式（Exclusive Mode）&quot;
        direction TB
        EX_TITLE[&quot;代表：ReentrantLock&quot;]
        EX_STATE[&quot;state 语义：&lt;br/&gt;0 = 锁空闲&lt;br/&gt;1 = 锁被持有&lt;br/&gt;n = 重入 n 次&quot;]
        EX_RULE[&quot;规则：state &gt; 0 时&lt;br/&gt;只有 owner 线程可以继续获取&quot;]
        EX_ACQUIRE[&quot;tryAcquire：&lt;br/&gt;state == 0 → CAS 设为 1&lt;br/&gt;owner == self → state++&quot;]
        EX_RELEASE[&quot;tryRelease：&lt;br/&gt;state-- → 直到 state == 0&quot;]
        
        EX_TITLE --&gt; EX_STATE
        EX_STATE --&gt; EX_RULE
        EX_RULE --&gt; EX_ACQUIRE
        EX_ACQUIRE --&gt; EX_RELEASE
        
        style EX_TITLE fill:#ffcdd2
        style EX_STATE fill:#ffcdd2
    end
    
    subgraph &quot;共享模式（Shared Mode）&quot;
        direction TB
        SH_TITLE[&quot;代表：Semaphore、CountDownLatch&quot;]
        SH_STATE[&quot;state 语义：&lt;br/&gt;Semaphore: 可用许可数&lt;br/&gt;CountDownLatch: 剩余计数&quot;]
        SH_RULE[&quot;规则：state &gt; 0 时&lt;br/&gt;多个线程可以同时获取&quot;]
        SH_ACQUIRE[&quot;tryAcquireShared：&lt;br/&gt;state &gt;= acquires → CAS 减少&lt;br/&gt;返回剩余值（负数表示失败）&quot;]
        SH_RELEASE[&quot;tryReleaseShared：&lt;br/&gt;CAS 增加 state&quot;]
        
        SH_TITLE --&gt; SH_STATE
        SH_STATE --&gt; SH_RULE
        SH_RULE --&gt; SH_ACQUIRE
        SH_ACQUIRE --&gt; SH_RELEASE
        
        style SH_TITLE fill:#c8e6c9
        style SH_STATE fill:#c8e6c9
    end</code></pre>
<h4 id="reentrantlock-与-semaphore-的-state-使用对比">ReentrantLock 与 Semaphore 的 state 使用对比</h4>
<p>这两个同步器对 state 的使用方式体现了 AQS 设计的灵活性：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>ReentrantLock</th>
<th>Semaphore</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>state 初始值</strong></td>
<td>0（锁空闲）</td>
<td>n（n 个许可）</td>
</tr>
<tr>
<td><strong>获取时 state 变化</strong></td>
<td>0→1 或 n→n+1（重入）</td>
<td>n→n-1（消耗许可）</td>
</tr>
<tr>
<td><strong>释放时 state 变化</strong></td>
<td>n→n-1</td>
<td>n→n+1（归还许可）</td>
</tr>
<tr>
<td><strong>state=0 的含义</strong></td>
<td>锁空闲，可获取</td>
<td>无许可，必须等待</td>
</tr>
<tr>
<td><strong>state&gt;0 的含义</strong></td>
<td>锁被持有，其他线程等待</td>
<td>有许可，可以获取</td>
</tr>
<tr>
<td><strong>owner 概念</strong></td>
<td>有，记录持有锁的线程</td>
<td>无，许可不绑定线程</td>
</tr>
<tr>
<td><strong>可重入性</strong></td>
<td>支持（同一线程多次获取）</td>
<td>不适用（许可是资源计数）</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程1
    participant T2 as 线程2
    participant T3 as 线程3
    participant RL as ReentrantLock&lt;br/&gt;(state)
    participant SEM as Semaphore(3)&lt;br/&gt;(state)
    
    Note over RL: state=0
    Note over SEM: state=3
    
    T1-&gt;&gt;RL: lock()
    Note over RL: state=1, owner=T1
    T2-&gt;&gt;RL: lock()
    Note over T2: 阻塞（state&gt;0 且 owner≠T2）
    
    T1-&gt;&gt;SEM: acquire()
    Note over SEM: state=2
    T2-&gt;&gt;SEM: acquire()
    Note over SEM: state=1
    T3-&gt;&gt;SEM: acquire()
    Note over SEM: state=0
    
    Note over T1,T3: Semaphore: 3个线程同时持有许可
    Note over T1,T2: ReentrantLock: 只有T1持有锁</code></pre>
<h4 id="为什么这种设计是灵活的">为什么这种设计是灵活的</h4>
<p>AQS 的 state 设计体现了<strong>模板方法模式</strong>的精髓：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS 只定义框架，不定义 state 的具体语义</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br>    <br>    <span class="hljs-comment">// 模板方法：定义获取锁的流程</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 钩子方法：由子类定义 state 的语义</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;AQS 的模板方法设计&quot;
        AQS[&quot;AbstractQueuedSynchronizer&lt;br/&gt;（定义框架）&quot;]
        
        subgraph &quot;子类实现&quot;
            RL[&quot;ReentrantLock.Sync&lt;br/&gt;tryAcquire: state 表示重入次数&quot;]
            SEM[&quot;Semaphore.Sync&lt;br/&gt;tryAcquireShared: state 表示许可数&quot;]
            CDL[&quot;CountDownLatch.Sync&lt;br/&gt;tryAcquireShared: state 表示计数&quot;]
            RWL[&quot;ReentrantReadWriteLock.Sync&lt;br/&gt;state 高16位读锁，低16位写锁&quot;]
        end
        
        AQS --&gt;|&quot;tryAcquire&quot;| RL
        AQS --&gt;|&quot;tryAcquireShared&quot;| SEM
        AQS --&gt;|&quot;tryAcquireShared&quot;| CDL
        AQS --&gt;|&quot;tryAcquire + tryAcquireShared&quot;| RWL
    end
    
    style AQS fill:#e1f5ff
    style RL fill:#ffcdd2
    style SEM fill:#c8e6c9
    style CDL fill:#fff9c4
    style RWL fill:#e1bee7</code></pre>
<h4 id="aqs-不只是-reentrantlock-的实现方式">AQS 不只是 ReentrantLock 的实现方式</h4>
<p>一个常见的误解是把 AQS 等同于 ReentrantLock 的实现。实际上，AQS 是一个<strong>通用的同步器框架</strong>，支持多种完全不同的同步语义：</p>
<table>
<thead>
<tr>
<th>同步器</th>
<th>模式</th>
<th>state 语义</th>
<th>典型用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ReentrantLock</strong></td>
<td>独占</td>
<td>重入计数</td>
<td>互斥访问</td>
</tr>
<tr>
<td><strong>Semaphore</strong></td>
<td>共享</td>
<td>许可计数</td>
<td>限流、资源池</td>
</tr>
<tr>
<td><strong>CountDownLatch</strong></td>
<td>共享</td>
<td>倒计数</td>
<td>等待多个事件完成</td>
</tr>
<tr>
<td><strong>ReentrantReadWriteLock</strong></td>
<td>混合</td>
<td>读写计数</td>
<td>读多写少场景</td>
</tr>
<tr>
<td><strong>ThreadPoolExecutor.Worker</strong></td>
<td>独占</td>
<td>0/1</td>
<td>工作线程状态</td>
</tr>
</tbody>
</table>
<p><strong>关键洞察</strong>：</p>
<ol>
<li><strong>state 的语义完全由子类定义</strong>：AQS 只提供 CAS 操作和队列管理，不关心 state 代表什么</li>
<li><strong>独占和共享可以混合使用</strong>：如 ReentrantReadWriteLock 同时使用两种模式</li>
<li><strong>tryAcquire 的返回值语义不同</strong>：
<ul>
<li>独占模式：返回 boolean（成功/失败）</li>
<li>共享模式：返回 int（负数=失败，0=成功但后续不能继续，正数=成功且后续可继续）</li>
</ul>
</li>
</ol>
<h4 id="tryacquireshared-返回值与唤醒传播">tryAcquireShared 返回值与唤醒传播</h4>
<p>共享模式下 <code>tryAcquireShared</code> 的返回值不仅表示成功与否，还决定了<strong>是否需要传播唤醒后续等待线程</strong>：</p>
<table>
<thead>
<tr>
<th>返回值</th>
<th>含义</th>
<th>唤醒传播</th>
<th>典型场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>负数</strong></td>
<td>获取失败</td>
<td>不传播，当前线程入队等待</td>
<td>Semaphore 许可耗尽</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>获取成功，但资源已耗尽</td>
<td>不传播后续线程</td>
<td>Semaphore 获取最后一个许可</td>
</tr>
<tr>
<td><strong>正数</strong></td>
<td>获取成功，还有剩余资源</td>
<td>传播唤醒后续共享节点</td>
<td>Semaphore 还有剩余许可</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;tryAcquireShared 返回值的影响&quot;
        TRY[&quot;tryAcquireShared(arg)&quot;]
        
        TRY --&gt;|&quot;返回 &lt; 0&quot;| FAIL[&quot;获取失败&lt;br/&gt;线程入队阻塞&quot;]
        TRY --&gt;|&quot;返回 = 0&quot;| ZERO[&quot;获取成功&lt;br/&gt;资源刚好用完&lt;br/&gt;不唤醒后续线程&quot;]
        TRY --&gt;|&quot;返回 &gt; 0&quot;| POSITIVE[&quot;获取成功&lt;br/&gt;还有剩余资源&lt;br/&gt;唤醒后续共享节点&quot;]
        
        POSITIVE --&gt; PROPAGATE[&quot;doReleaseShared()&lt;br/&gt;传播唤醒&quot;]
        
        style FAIL fill:#ffcdd2
        style ZERO fill:#fff9c4
        style POSITIVE fill:#c8e6c9
        style PROPAGATE fill:#c8e6c9
    end</code></pre>
<p><strong>这个设计的精妙之处</strong>：</p>
<ul>
<li><strong>CountDownLatch</strong>：<code>tryAcquireShared</code> 在 state=0 时返回 1（正数），触发传播唤醒所有等待线程</li>
<li><strong>Semaphore</strong>：返回剩余许可数，如果还有许可就继续唤醒后续线程，实现&quot;批量放行&quot;</li>
<li><strong>ReadLock</strong>：返回 1 表示成功，允许多个读线程同时获取</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// CountDownLatch: state=0 时返回 1，唤醒所有等待者</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// Semaphore: 返回剩余许可数，决定是否继续唤醒</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>    <span class="hljs-comment">// remaining &gt; 0 时会触发传播唤醒</span><br>    <span class="hljs-keyword">return</span> remaining;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Semaphore 的 tryAcquireShared 实现</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;  <span class="hljs-comment">// 返回剩余许可数</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ReentrantLock 的 tryAcquire 实现</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这种设计使得 AQS 成为一个真正的<strong>同步器构建工具包</strong>，而不仅仅是某种特定锁的实现。</p>
<h3 id="aqs-的两种使用思路：直接继承-vs-包装组合">AQS 的两种使用思路：直接继承 vs 包装组合</h3>
<p>在实际开发中，使用 AQS 有两种主要的思路，它们代表了不同层次的抽象和复杂度。</p>
<h4 id="思路一：直接继承-aqs-实现自定义同步器">思路一：直接继承 AQS 实现自定义同步器</h4>
<p>这是<strong>底层框架实现者</strong>的方式，适用于需要创建新的同步器类型时。</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li>实现全新的同步器（如 JUC 框架开发者）</li>
<li>需要完全控制同步语义</li>
<li>对性能有极致要求</li>
</ul>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>继承 <code>AbstractQueuedSynchronizer</code></li>
<li>重写核心方法（<code>tryAcquire</code>、<code>tryRelease</code> 或 <code>tryAcquireShared</code>、<code>tryReleaseShared</code>）</li>
<li>定义 <code>state</code> 的语义</li>
<li>提供对外 API（通常通过组合方式暴露）</li>
</ol>
<p><strong>示例：实现一个简单的互斥锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 自定义同步器：直接继承 AQS</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleMutex</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-comment">// state: 0=未锁定, 1=已锁定</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        &#125;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>        setState(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 对外 API</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        release(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> isHeldExclusively();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>JUC 框架中的例子</strong>：</p>
<table>
<thead>
<tr>
<th>同步器</th>
<th>继承方式</th>
<th>实现的 AQS 方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ReentrantLock.Sync</strong></td>
<td>内部类继承 AQS</td>
<td><code>tryAcquire</code>, <code>tryRelease</code></td>
</tr>
<tr>
<td><strong>Semaphore.Sync</strong></td>
<td>内部类继承 AQS</td>
<td><code>tryAcquireShared</code>, <code>tryReleaseShared</code></td>
</tr>
<tr>
<td><strong>CountDownLatch.Sync</strong></td>
<td>内部类继承 AQS</td>
<td><code>tryAcquireShared</code>, <code>tryReleaseShared</code></td>
</tr>
<tr>
<td><strong>ReentrantReadWriteLock.Sync</strong></td>
<td>内部类继承 AQS</td>
<td>独占+共享模式混合实现</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ReentrantLock 的实际实现（简化版）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-comment">// 内部类直接继承 AQS</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-comment">// 重写 tryAcquire</span><br>        <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span>;<br>        <span class="hljs-comment">// 重写 tryRelease</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                free = <span class="hljs-literal">true</span>;<br>                setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            &#125;<br>            setState(c);<br>            <span class="hljs-keyword">return</span> free;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 非公平锁实现</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 公平锁实现</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-comment">// 公平性检查：检查是否有前驱节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                    compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                    setExclusiveOwnerThread(current);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                setState(nextc);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">()</span> &#123;<br>        sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>        sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="思路二：包装现有-aqs-同步器">思路二：包装现有 AQS 同步器</h4>
<p>这是<strong>应用开发者</strong>的方式，适用于使用已有的同步器构建更复杂的同步工具。</p>
<p><strong>使用场景</strong>：</p>
<ul>
<li>构建业务特定的同步工具</li>
<li>组合多个同步器实现复杂协调</li>
<li>快速实现线程安全的数据结构</li>
</ul>
<p><strong>实现步骤</strong>：</p>
<ol>
<li>组合现有同步器（如 <code>ReentrantLock</code>、<code>Semaphore</code> 等）</li>
<li>在其基础上添加业务逻辑</li>
<li>提供更高层次的抽象接口</li>
</ol>
<p><strong>示例：实现一个限流器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 包装 Semaphore 实现限流器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RateLimiter</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Semaphore semaphore;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> timeoutMillis;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">RateLimiter</span><span class="hljs-params">(<span class="hljs-type">int</span> maxPermits, <span class="hljs-type">long</span> timeoutMillis)</span> &#123;<br>        <span class="hljs-built_in">this</span>.semaphore = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(maxPermits, <span class="hljs-literal">true</span>); <span class="hljs-comment">// 公平模式</span><br>        <span class="hljs-built_in">this</span>.timeoutMillis = timeoutMillis;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> semaphore.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            Thread.currentThread().interrupt();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>        semaphore.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>示例：实现一个阻塞队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 包装 ReentrantLock 和 Condition 实现阻塞队列</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleBlockingQueue</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;T&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> capacity;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleBlockingQueue</span><span class="hljs-params">(<span class="hljs-type">int</span> capacity)</span> &#123;<br>        <span class="hljs-built_in">this</span>.capacity = capacity;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(T item)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.size() == capacity) &#123;<br>                notFull.await();  <span class="hljs-comment">// 队列满时等待</span><br>            &#125;<br>            queue.add(item);<br>            notEmpty.signal();  <span class="hljs-comment">// 唤醒消费者</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (queue.isEmpty()) &#123;<br>                notEmpty.await();  <span class="hljs-comment">// 队列空时等待</span><br>            &#125;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> queue.poll();<br>            notFull.signal();  <span class="hljs-comment">// 唤醒生产者</span><br>            <span class="hljs-keyword">return</span> item;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="两种思路的对比">两种思路的对比</h4>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>直接继承 AQS</th>
<th>包装现有同步器</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>抽象层次</strong></td>
<td>底层（框架级别）</td>
<td>高层（应用级别）</td>
</tr>
<tr>
<td><strong>复杂度</strong></td>
<td>高（需理解 AQS 内部机制）</td>
<td>低（使用已有的高级抽象）</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>极高（完全控制同步语义）</td>
<td>中等（受限于基础同步器的功能）</td>
</tr>
<tr>
<td><strong>开发成本</strong></td>
<td>高（需实现队列、状态管理等细节）</td>
<td>低（直接使用现成组件）</td>
</tr>
<tr>
<td><strong>适用对象</strong></td>
<td>JUC 框架开发者、库作者</td>
<td>应用开发者、业务开发</td>
</tr>
<tr>
<td><strong>典型例子</strong></td>
<td>ReentrantLock、Semaphore、CountDownLatch</td>
<td>阻塞队列、线程池、并发集合</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>可优化到极致</td>
<td>取决于基础同步器</td>
</tr>
<tr>
<td><strong>可维护性</strong></td>
<td>需要深入理解并发原理</td>
<td>更容易理解和维护</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;AQS 使用层次&quot;
        direction TB
        
        AQS[&quot;AbstractQueuedSynchronizer&lt;br/&gt;（底层框架）&quot;]
        
        subgraph &quot;直接继承 AQS&quot;
            RL[&quot;ReentrantLock&quot;]
            SEM[&quot;Semaphore&quot;]
            CDL[&quot;CountDownLatch&quot;]
            RWL[&quot;ReentrantReadWriteLock&quot;]
        end
        
        subgraph &quot;包装现有同步器&quot;
            BQ[&quot;BlockingQueue&lt;br/&gt;包装 ReentrantLock + Condition&quot;]
            TP[&quot;ThreadPoolExecutor&lt;br/&gt;包装 ReentrantLock + AQS&quot;]
            CHM[&quot;ConcurrentHashMap&lt;br/&gt;包装 CAS + synchronized&quot;]
            CC[&quot;并发集合&lt;br/&gt;包装各种同步器&quot;]
        end
        
        subgraph &quot;应用层&quot;
            APP[&quot;业务应用&lt;br/&gt;使用 BlockingQueue、ThreadPoolExecutor 等&quot;]
        end
        
        AQS --&gt; RL
        AQS --&gt; SEM
        AQS --&gt; CDL
        AQS --&gt; RWL
        
        RL --&gt; BQ
        RL --&gt; TP
        SEM --&gt;|&quot;组合&quot;| CC
        RWL --&gt; CHM
        
        BQ --&gt; APP
        TP --&gt; APP
        CHM --&gt; APP
        CC --&gt; APP
        
        style AQS fill:#e1f5ff
        style RL fill:#ffcdd2
        style SEM fill:#ffcdd2
        style BQ fill:#c8e6c9
        style TP fill:#c8e6c9
        style APP fill:#fff9c4
    end</code></pre>
<h4 id="文章中提到的同步器的使用思路分析">文章中提到的同步器的使用思路分析</h4>
<p>回顾文章中提到的同步基础设施：</p>
<table>
<thead>
<tr>
<th>同步器</th>
<th>使用思路</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ReentrantLock</strong></td>
<td>直接继承 AQS</td>
<td>内部类 <code>Sync</code> 继承 AQS，重写 <code>tryAcquire</code> 和 <code>tryRelease</code></td>
</tr>
<tr>
<td><strong>Semaphore</strong></td>
<td>直接继承 AQS</td>
<td>内部类 <code>Sync</code> 继承 AQS，重写 <code>tryAcquireShared</code> 和 <code>tryReleaseShared</code></td>
</tr>
<tr>
<td><strong>CountDownLatch</strong></td>
<td>直接继承 AQS</td>
<td>内部类 <code>Sync</code> 继承 AQS，实现共享模式的倒计数</td>
</tr>
<tr>
<td><strong>ReentrantReadWriteLock</strong></td>
<td>直接继承 AQS</td>
<td>内部类 <code>Sync</code> 继承 AQS，混合使用独占和共享模式</td>
</tr>
<tr>
<td><strong>CyclicBarrier</strong></td>
<td>包装 ReentrantLock</td>
<td>内部使用 <code>ReentrantLock</code> 和 <code>Condition</code>，不直接继承 AQS</td>
</tr>
</tbody>
</table>
<p><strong>关键发现</strong>：</p>
<ol>
<li><strong>JUC 框架中的核心同步器</strong>（ReentrantLock、Semaphore、CountDownLatch）都是<strong>直接继承 AQS</strong> 的实现</li>
<li><strong>更高级的同步工具</strong>（CyclicBarrier、ThreadPoolExecutor、BlockingQueue）通常是<strong>包装现有同步器</strong>的实现</li>
<li>这体现了<strong>分层设计</strong>的原则：底层提供基础构建块，上层组合构建复杂工具</li>
</ol>
<h4 id="两种思路的优缺点深度分析">两种思路的优缺点深度分析</h4>
<h5 id="直接继承-aqs-的优缺点">直接继承 AQS 的优缺点</h5>
<p><strong>优点</strong>：</p>
<ol>
<li>
<p><strong>极致的性能优化</strong></p>
<ul>
<li>可以针对特定场景优化同步逻辑</li>
<li>避免不必要的抽象层开销</li>
<li>精确控制队列行为</li>
</ul>
</li>
<li>
<p><strong>完全的语义控制</strong></p>
<ul>
<li>可以实现任意复杂的同步语义</li>
<li>不受限于现有同步器的功能</li>
<li>可以自定义公平性、超时、中断等行为</li>
</ul>
</li>
<li>
<p><strong>框架级别的复用</strong></p>
<ul>
<li>创建的可复用的同步器组件</li>
<li>可以被其他开发者包装使用</li>
<li>成为 JUC 生态系统的一部分</li>
</ul>
</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>
<p><strong>高学习成本</strong></p>
<ul>
<li>需要深入理解 AQS 的内部机制</li>
<li>需要理解 CLH 队列、waitStatus、节点状态等概念</li>
<li>容易出现并发 bug（死锁、活锁、饥饿等）</li>
</ul>
</li>
<li>
<p><strong>开发复杂度高</strong></p>
<ul>
<li>需要正确实现多个钩子方法</li>
<li>需要处理中断、超时、取消等边缘情况</li>
<li>测试和验证困难</li>
</ul>
</li>
<li>
<p><strong>维护成本高</strong></p>
<ul>
<li>代码难以理解和维护</li>
<li>需要并发专家级别的知识</li>
<li>文档和注释要求高</li>
</ul>
</li>
</ol>
<p><strong>适用场景</strong>：</p>
<ul>
<li>✅ 实现 JUC 框架级别的同步器</li>
<li>✅ 需要特殊的同步语义（如 StampedLock）</li>
<li>✅ 对性能有极致要求的场景</li>
<li>✅ 开发可复用的并发库</li>
<li>❌ 一般业务应用开发</li>
<li>❌ 快速实现简单的同步需求</li>
</ul>
<h5 id="包装现有同步器的优缺点">包装现有同步器的优缺点</h5>
<p><strong>优点</strong>：</p>
<ol>
<li>
<p><strong>开发简单快速</strong></p>
<ul>
<li>直接使用成熟的同步器</li>
<li>专注于业务逻辑而非同步细节</li>
<li>代码简洁易懂</li>
</ul>
</li>
<li>
<p><strong>可靠性高</strong></p>
<ul>
<li>基于经过充分测试的组件</li>
<li>避免常见的并发陷阱</li>
<li>降低 bug 风险</li>
</ul>
</li>
<li>
<p><strong>易于维护</strong></p>
<ul>
<li>代码可读性好</li>
<li>团队成员容易理解</li>
<li>便于调试和优化</li>
</ul>
</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>
<p><strong>性能可能不是最优</strong></p>
<ul>
<li>多层抽象可能带来开销</li>
<li>无法针对特定场景优化</li>
<li>受限于基础同步器的实现</li>
</ul>
</li>
<li>
<p><strong>灵活性受限</strong></p>
<ul>
<li>只能实现基础同步器支持的功能</li>
<li>无法改变核心同步语义</li>
<li>某些特殊需求无法满足</li>
</ul>
</li>
</ol>
<p><strong>适用场景</strong>：</p>
<ul>
<li>✅ 大部分业务应用开发</li>
<li>✅ 快速实现线程安全的数据结构</li>
<li>✅ 组合多个同步器实现复杂协调</li>
<li>✅ 团队成员并发经验有限</li>
<li>❌ 需要特殊的同步语义</li>
<li>❌ 对性能有极致要求</li>
</ul>
<h4 id="最佳实践建议">最佳实践建议</h4>
<p><strong>选择直接继承 AQS 的情况</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例：实现一个StampedLock风格的乐观读锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OptimisticLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-comment">// state: 高32位=版本号，低32位=写锁持有数</span><br>        <br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryOptimisticRead</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 读取版本号，不获取锁</span><br>            <span class="hljs-keyword">return</span> (getState() &gt;&gt;&gt; <span class="hljs-number">32</span>) != <span class="hljs-number">0</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">validate</span><span class="hljs-params">(<span class="hljs-type">int</span> stamp)</span> &#123;<br>            <span class="hljs-comment">// 验证版本号是否变化</span><br>            <span class="hljs-keyword">return</span> (getState() &gt;&gt;&gt; <span class="hljs-number">32</span>) == stamp;<br>        &#125;<br>        <br>        <span class="hljs-comment">// ... 其他方法实现</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryOptimisticRead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(sync.getState() &gt;&gt;&gt; <span class="hljs-number">32</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">validate</span><span class="hljs-params">(<span class="hljs-type">int</span> stamp)</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.validate(stamp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>选择包装现有同步器的情况</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例：实现一个带超时的缓存</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TimeoutCache</span>&lt;K, V&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;K, CacheEntry&lt;V&gt;&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">cleanupCondition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService cleanupExecutor;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheEntry</span>&lt;V&gt; &#123;<br>        V value;<br>        <span class="hljs-type">long</span> expireTime;<br>        <br>        CacheEntry(V value, <span class="hljs-type">long</span> ttl) &#123;<br>            <span class="hljs-built_in">this</span>.value = value;<br>            <span class="hljs-built_in">this</span>.expireTime = System.currentTimeMillis() + ttl;<br>        &#125;<br>        <br>        <span class="hljs-type">boolean</span> <span class="hljs-title function_">isExpired</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> System.currentTimeMillis() &gt; expireTime;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">TimeoutCache</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.cleanupExecutor = Executors.newSingleThreadScheduledExecutor();<br>        <span class="hljs-built_in">this</span>.cleanupExecutor.scheduleAtFixedRate(<br>            <span class="hljs-built_in">this</span>::cleanupExpiredEntries,<br>            <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, TimeUnit.MINUTES<br>        );<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(K key, V value, <span class="hljs-type">long</span> ttl)</span> &#123;<br>        map.put(key, <span class="hljs-keyword">new</span> <span class="hljs-title class_">CacheEntry</span>&lt;&gt;(value, ttl));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(K key)</span> &#123;<br>        CacheEntry&lt;V&gt; entry = map.get(key);<br>        <span class="hljs-keyword">if</span> (entry != <span class="hljs-literal">null</span> &amp;&amp; !entry.isExpired()) &#123;<br>            <span class="hljs-keyword">return</span> entry.value;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanupExpiredEntries</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            map.entrySet().removeIf(entry -&gt; entry.getValue().isExpired());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">shutdown</span><span class="hljs-params">()</span> &#123;<br>        cleanupExecutor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>决策树</strong>：</p>
<pre><code class="hljs mermaid">graph TB
    START[&quot;需要实现同步功能&quot;]
    
    Q1&#123;&quot;是否需要&lt;br/&gt;特殊的同步语义?&quot;&#125;
    Q2&#123;&quot;是否需要&lt;br/&gt;极致的性能?&quot;&#125;
    Q3&#123;&quot;是否开发&lt;br/&gt;可复用的库?&quot;&#125;
    
    INHERIT[&quot;直接继承 AQS&quot;]
    WRAP[&quot;包装现有同步器&quot;]
    
    START --&gt; Q1
    Q1 --&gt;|是| Q2
    Q1 --&gt;|否| WRAP
    
    Q2 --&gt;|是| Q3
    Q2 --&gt;|否| WRAP
    
    Q3 --&gt;|是| INHERIT
    Q3 --&gt;|否| WRAP
    
    style INHERIT fill:#ffcdd2
    style WRAP fill:#c8e6c9</code></pre>
<p><strong>关键原则</strong>：</p>
<ol>
<li><strong>优先使用现有同步器</strong>：除非有明确的需求，否则不要直接继承 AQS</li>
<li><strong>组合优于继承</strong>：包装现有同步器通常比直接继承更灵活</li>
<li><strong>渐进式复杂度</strong>：从简单的包装开始，遇到限制时再考虑继承</li>
<li><strong>团队技能匹配</strong>：选择团队有能力理解和维护的方式</li>
<li><strong>文档和测试</strong>：无论选择哪种方式，都要充分测试和文档化</li>
</ol>
<h3 id="clh-队列：等待线程的组织方式">CLH 队列：等待线程的组织方式</h3>
<p>AQS 使用一个 <strong>CLH 队列的变体</strong> 来管理等待获取锁的线程。CLH（Craig, Landin, and Hagersten）队列是一种基于链表的自旋锁队列。</p>
<h4 id="node-节点结构">Node 节点结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-comment">// 节点模式</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();    <span class="hljs-comment">// 共享模式标记</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;       <span class="hljs-comment">// 独占模式标记</span><br>    <br>    <span class="hljs-comment">// 等待状态</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">1</span>;  <span class="hljs-comment">// 线程已取消</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SIGNAL</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;  <span class="hljs-comment">// 后继节点需要被唤醒</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CONDITION</span> <span class="hljs-operator">=</span> -<span class="hljs-number">2</span>;  <span class="hljs-comment">// 节点在条件队列中</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">PROPAGATE</span> <span class="hljs-operator">=</span> -<span class="hljs-number">3</span>;  <span class="hljs-comment">// 共享模式下需要传播唤醒</span><br>    <br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> waitStatus;          <span class="hljs-comment">// 等待状态</span><br>    <span class="hljs-keyword">volatile</span> Node prev;               <span class="hljs-comment">// 前驱节点</span><br>    <span class="hljs-keyword">volatile</span> Node next;               <span class="hljs-comment">// 后继节点</span><br>    <span class="hljs-keyword">volatile</span> Thread thread;           <span class="hljs-comment">// 关联的线程</span><br>    Node nextWaiter;                  <span class="hljs-comment">// 条件队列中的下一个节点，或模式标记</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="waitstatus-状态转换">waitStatus 状态转换</h4>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; INITIAL: 新建节点
    INITIAL --&gt; SIGNAL: 后继节点入队
    INITIAL --&gt; CANCELLED: 线程被中断/超时
    SIGNAL --&gt; CANCELLED: 线程被中断/超时
    SIGNAL --&gt; [*]: 成功获取锁
    CANCELLED --&gt; [*]: 节点被移除
    
    note right of INITIAL: waitStatus = 0
    note right of SIGNAL: waitStatus = -1
    note right of CANCELLED: waitStatus = 1</code></pre>
<table>
<thead>
<tr>
<th>waitStatus</th>
<th>值</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CANCELLED</strong></td>
<td>1</td>
<td>线程已取消等待（超时或中断）</td>
</tr>
<tr>
<td><strong>SIGNAL</strong></td>
<td>-1</td>
<td>当前节点释放锁时需要唤醒后继节点</td>
</tr>
<tr>
<td><strong>CONDITION</strong></td>
<td>-2</td>
<td>节点在条件队列中等待</td>
</tr>
<tr>
<td><strong>PROPAGATE</strong></td>
<td>-3</td>
<td>共享模式下，释放操作需要传播</td>
</tr>
<tr>
<td><strong>0</strong></td>
<td>0</td>
<td>初始状态</td>
</tr>
</tbody>
</table>
<h4 id="同步队列结构">同步队列结构</h4>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;AQS 同步队列（CLH 变体）&quot;
        direction LR
        
        HEAD[&quot;head&lt;br/&gt;（哨兵节点）&lt;br/&gt;thread=null&quot;]
        N1[&quot;Node 1&lt;br/&gt;waitStatus=-1&lt;br/&gt;thread=T1&quot;]
        N2[&quot;Node 2&lt;br/&gt;waitStatus=-1&lt;br/&gt;thread=T2&quot;]
        N3[&quot;Node 3&lt;br/&gt;waitStatus=0&lt;br/&gt;thread=T3&quot;]
        TAIL[&quot;tail&quot;]
        
        HEAD --&gt;|next| N1
        N1 --&gt;|prev| HEAD
        N1 --&gt;|next| N2
        N2 --&gt;|prev| N1
        N2 --&gt;|next| N3
        N3 --&gt;|prev| N2
        TAIL -.-&gt;|指向| N3
        
        style HEAD fill:#e1f5ff
        style N1 fill:#fff9c4
        style N2 fill:#fff9c4
        style N3 fill:#c8e6c9
    end</code></pre>
<p><strong>关键设计点：</strong></p>
<ol>
<li><strong>head 是哨兵节点</strong>：head 节点的 thread 字段为 null，它代表当前持有锁的线程（或初始的空节点）</li>
<li><strong>双向链表</strong>：支持高效的节点取消和遍历</li>
<li><strong>FIFO 顺序</strong>：新节点从 tail 入队，从 head 后继出队</li>
<li><strong>waitStatus 的传递</strong>：节点的 waitStatus 表示的是<strong>后继节点</strong>的状态</li>
</ol>
<h4 id="为什么同步队列是双向链表-而条件队列是单向链表？">为什么同步队列是双向链表，而条件队列是单向链表？</h4>
<p>这是一个经常被问到的设计问题。AQS 中有两种队列：</p>
<table>
<thead>
<tr>
<th>队列类型</th>
<th>数据结构</th>
<th>链接方式</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>同步队列（Sync Queue）</strong></td>
<td>双向链表</td>
<td>prev + next</td>
<td>需要支持节点取消时的向前遍历</td>
</tr>
<tr>
<td><strong>条件队列（Condition Queue）</strong></td>
<td>单向链表</td>
<td>nextWaiter</td>
<td>只需要 FIFO 顺序转移到同步队列</td>
</tr>
</tbody>
</table>
<p><strong>同步队列为什么必须是双向的？</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;节点取消时的处理&quot;
        direction TB
        
        H[&quot;head&quot;] --&gt; N1[&quot;Node 1&lt;br/&gt;waitStatus=-1&quot;]
        N1 --&gt; N2[&quot;Node 2&lt;br/&gt;waitStatus=1&lt;br/&gt;（CANCELLED）&quot;]
        N2 --&gt; N3[&quot;Node 3&lt;br/&gt;waitStatus=-1&quot;]
        N3 --&gt; N4[&quot;Node 4&lt;br/&gt;waitStatus=0&quot;]
        
        N1 -.-&gt;|&quot;prev&quot;| H
        N2 -.-&gt;|&quot;prev&quot;| N1
        N3 -.-&gt;|&quot;prev&quot;| N2
        N4 -.-&gt;|&quot;prev&quot;| N3
        
        style N2 fill:#ffcdd2
    end</code></pre>
<p>当 Node 2 被取消时，需要：</p>
<ol>
<li><strong>向前遍历</strong>：找到前面第一个未取消的节点（Node 1）</li>
<li><strong>更新链接</strong>：让 Node 1 的 next 指向 Node 3</li>
<li><strong>唤醒后继</strong>：如果需要，唤醒 Node 3</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// cancelAcquire 中的关键代码</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// 向前遍历，跳过已取消的节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;<br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)  <span class="hljs-comment">// 需要 prev 指针！</span><br>        node.prev = pred = pred.prev;<br>    <br>    <span class="hljs-comment">// 更新前驱的 next 指针</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;<br>    node.waitStatus = Node.CANCELLED;<br>    <br>    <span class="hljs-comment">// ... 后续处理</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>如果没有 prev 指针会怎样？</strong></p>
<ul>
<li>取消节点时，无法高效地找到前驱节点</li>
<li>只能从 head 开始遍历整个队列，时间复杂度从 O(1) 变为 O(n)</li>
<li>在高并发场景下，这会严重影响性能</li>
</ul>
<p><strong>条件队列为什么只需要单向？</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;条件队列（单向）&quot;
        direction LR
        CQ_HEAD[&quot;firstWaiter&quot;] --&gt; CW1[&quot;Node 1&quot;]
        CW1 --&gt;|&quot;nextWaiter&quot;| CW2[&quot;Node 2&quot;]
        CW2 --&gt;|&quot;nextWaiter&quot;| CW3[&quot;Node 3&quot;]
        CW3 --&gt;|&quot;nextWaiter&quot;| CQ_TAIL[&quot;lastWaiter&quot;]
    end</code></pre>
<p>条件队列的操作特点：</p>
<ol>
<li><strong>只在持锁时操作</strong>：<code>await()</code> 和 <code>signal()</code> 都需要先获取锁，因此不存在并发修改</li>
<li><strong>只需要 FIFO 转移</strong>：<code>signal()</code> 只需要将头节点转移到同步队列</li>
<li><strong>不需要取消处理</strong>：条件队列中的节点不会被&quot;取消&quot;，只会被转移</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConditionObject.signal() - 只需要操作头节点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>        doSignal(first);  <span class="hljs-comment">// 转移头节点到同步队列</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么不使用循环队列？</strong></p>
<table>
<thead>
<tr>
<th>设计选择</th>
<th>循环队列</th>
<th>非循环链表</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>内存分配</strong></td>
<td>需要预分配固定大小数组</td>
<td>按需动态分配节点</td>
</tr>
<tr>
<td><strong>容量限制</strong></td>
<td>有最大容量限制</td>
<td>无限制（受内存限制）</td>
</tr>
<tr>
<td><strong>节点取消</strong></td>
<td>需要移动元素或标记空洞</td>
<td>直接修改指针</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>固定大小、高频入队出队</td>
<td>动态大小、需要灵活删除</td>
</tr>
</tbody>
</table>
<p>AQS 选择非循环链表的原因：</p>
<ol>
<li><strong>等待线程数量不可预测</strong>：无法预先确定队列大小</li>
<li><strong>节点取消是常见操作</strong>：超时、中断都会导致节点取消</li>
<li><strong>内存效率</strong>：只在需要时分配节点，不浪费空间</li>
</ol>
<h3 id="获取锁的核心流程">获取锁的核心流程</h3>
<p>以独占模式（如 ReentrantLock）为例，获取锁的核心流程如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS.acquire() - 获取独占锁的入口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;                    <span class="hljs-comment">// 1. 尝试获取锁</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="hljs-comment">// 2. 失败则入队等待</span><br>        selfInterrupt();                        <span class="hljs-comment">// 3. 恢复中断状态</span><br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">flowchart TB
    START[&quot;acquire(arg)&quot;]
    TRY[&quot;tryAcquire(arg)&lt;br/&gt;尝试获取锁&quot;]
    SUCCESS&#123;&quot;成功?&quot;&#125;
    ADD[&quot;addWaiter(Node.EXCLUSIVE)&lt;br/&gt;创建节点并入队&quot;]
    WAIT[&quot;acquireQueued(node, arg)&lt;br/&gt;在队列中等待&quot;]
    INTERRUPTED&#123;&quot;被中断?&quot;&#125;
    SELF_INT[&quot;selfInterrupt()&lt;br/&gt;恢复中断状态&quot;]
    END[&quot;获取锁成功&quot;]
    
    START --&gt; TRY
    TRY --&gt; SUCCESS
    SUCCESS --&gt;|是| END
    SUCCESS --&gt;|否| ADD
    ADD --&gt; WAIT
    WAIT --&gt; INTERRUPTED
    INTERRUPTED --&gt;|是| SELF_INT
    INTERRUPTED --&gt;|否| END
    SELF_INT --&gt; END
    
    style TRY fill:#c8e6c9
    style ADD fill:#fff9c4
    style WAIT fill:#ffcdd2</code></pre>
<h4 id="acquirequeued：在队列中自旋等待">acquireQueued：在队列中自旋等待</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;  <span class="hljs-comment">// 无限循环</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 只有前驱是 head 时才尝试获取锁</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);  <span class="hljs-comment">// 获取成功，成为新的 head</span><br>                p.next = <span class="hljs-literal">null</span>;  <span class="hljs-comment">// 帮助 GC</span><br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 判断是否需要阻塞</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node))<br>                interrupted |= parkAndCheckInterrupt();  <span class="hljs-comment">// 阻塞</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        cancelAcquire(node);<br>        <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T as 当前线程
    participant N as 当前节点
    participant P as 前驱节点
    participant H as head
    participant AQS as AQS
    
    loop 自旋
        T-&gt;&gt;N: predecessor()
        N-&gt;&gt;P: 获取前驱
        
        alt 前驱是 head
            T-&gt;&gt;AQS: tryAcquire(arg)
            alt 获取成功
                T-&gt;&gt;AQS: setHead(node)
                Note over T: 退出循环，获取锁成功
            else 获取失败
                T-&gt;&gt;AQS: shouldParkAfterFailedAcquire()
                alt 需要阻塞
                    T-&gt;&gt;T: parkAndCheckInterrupt()
                    Note over T: 线程阻塞
                else 不需要阻塞
                    Note over T: 继续自旋
                end
            end
        else 前驱不是 head
            T-&gt;&gt;AQS: shouldParkAfterFailedAcquire()
            Note over T: 检查是否需要阻塞
        end
    end</code></pre>
<h4 id="shouldparkafterfailedacquire：判断是否需要阻塞">shouldParkAfterFailedAcquire：判断是否需要阻塞</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-comment">// 前驱已经设置为 SIGNAL，可以安全阻塞</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 前驱已取消，跳过所有已取消的节点</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 将前驱的 waitStatus 设置为 SIGNAL</span><br>        pred.compareAndSetWaitStatus(ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>这个方法的设计精妙之处：</strong></p>
<ol>
<li><strong>延迟设置 SIGNAL</strong>：只有在确定要阻塞时才设置前驱的 SIGNAL 状态</li>
<li><strong>跳过已取消节点</strong>：自动清理队列中的无效节点</li>
<li><strong>返回 false 触发重试</strong>：设置 SIGNAL 后返回 false，让调用者再尝试一次获取锁</li>
</ol>
<h3 id="释放锁的核心流程">释放锁的核心流程</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS.release() - 释放独占锁的入口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;           <span class="hljs-comment">// 1. 尝试释放锁</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);      <span class="hljs-comment">// 2. 唤醒后继节点</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        node.compareAndSetWaitStatus(ws, <span class="hljs-number">0</span>);  <span class="hljs-comment">// 清除 SIGNAL 状态</span><br>    <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 后继为空或已取消，从 tail 向前找有效节点</span><br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> tail; p != node &amp;&amp; p != <span class="hljs-literal">null</span>; p = p.prev)<br>            <span class="hljs-keyword">if</span> (p.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = p;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        LockSupport.unpark(s.thread);  <span class="hljs-comment">// 唤醒后继线程</span><br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">flowchart TB
    START[&quot;release(arg)&quot;]
    TRY[&quot;tryRelease(arg)&lt;br/&gt;尝试释放锁&quot;]
    SUCCESS&#123;&quot;成功?&quot;&#125;
    CHECK[&quot;检查 head&quot;]
    NEED_WAKE&#123;&quot;head != null &amp;&amp;&lt;br/&gt;waitStatus != 0?&quot;&#125;
    UNPARK[&quot;unparkSuccessor(head)&lt;br/&gt;唤醒后继节点&quot;]
    END_TRUE[&quot;return true&quot;]
    END_FALSE[&quot;return false&quot;]
    
    START --&gt; TRY
    TRY --&gt; SUCCESS
    SUCCESS --&gt;|是| CHECK
    SUCCESS --&gt;|否| END_FALSE
    CHECK --&gt; NEED_WAKE
    NEED_WAKE --&gt;|是| UNPARK
    NEED_WAKE --&gt;|否| END_TRUE
    UNPARK --&gt; END_TRUE
    
    style TRY fill:#c8e6c9
    style UNPARK fill:#fff9c4</code></pre>
<h3 id="条件队列：condition-的实现">条件队列：Condition 的实现</h3>
<p>AQS 还支持条件变量，通过内部类 <code>ConditionObject</code> 实现。每个 Condition 对象维护一个独立的<strong>条件队列</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;  <span class="hljs-comment">// 条件队列头</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;   <span class="hljs-comment">// 条件队列尾</span><br>    <br>    <span class="hljs-comment">// await() 的核心逻辑</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();     <span class="hljs-comment">// 1. 加入条件队列</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);  <span class="hljs-comment">// 2. 完全释放锁</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;        <span class="hljs-comment">// 3. 等待被转移到同步队列</span><br>            LockSupport.park(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">// 4. 重新获取锁</span><br>        <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>            interruptMode = REINTERRUPT;<br>        <span class="hljs-comment">// 5. 清理已取消的节点</span><br>        <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>)<br>            unlinkCancelledWaiters();<br>        <span class="hljs-comment">// 6. 处理中断</span><br>        <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>            reportInterruptAfterWait(interruptMode);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="同步队列与条件队列的关系">同步队列与条件队列的关系</h4>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;AQS 的两个队列&quot;
        direction TB
        
        subgraph &quot;同步队列（Sync Queue）&quot;
            SH[&quot;head&quot;]
            SN1[&quot;Node&lt;br/&gt;T1&quot;]
            SN2[&quot;Node&lt;br/&gt;T2&quot;]
            ST[&quot;tail&quot;]
            
            SH --&gt; SN1 --&gt; SN2
            ST -.-&gt; SN2
        end
        
        subgraph &quot;条件队列 1（Condition Queue）&quot;
            C1F[&quot;firstWaiter&quot;]
            C1N1[&quot;Node&lt;br/&gt;T3&quot;]
            C1N2[&quot;Node&lt;br/&gt;T4&quot;]
            C1L[&quot;lastWaiter&quot;]
            
            C1F --&gt; C1N1 --&gt; C1N2
            C1L -.-&gt; C1N2
        end
        
        subgraph &quot;条件队列 2（Condition Queue）&quot;
            C2F[&quot;firstWaiter&quot;]
            C2N1[&quot;Node&lt;br/&gt;T5&quot;]
            C2L[&quot;lastWaiter&quot;]
            
            C2F --&gt; C2N1
            C2L -.-&gt; C2N1
        end
        
        SIGNAL[&quot;signal()&quot;]
        SIGNAL --&gt;|&quot;转移节点&quot;| SN2
        
        style SH fill:#e1f5ff
        style C1F fill:#c8e6c9
        style C2F fill:#fff9c4
    end</code></pre>
<p><strong>关键区别：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>同步队列</th>
<th>条件队列</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>用途</strong></td>
<td>等待获取锁</td>
<td>等待条件满足</td>
</tr>
<tr>
<td><strong>结构</strong></td>
<td>双向链表</td>
<td>单向链表</td>
</tr>
<tr>
<td><strong>入队条件</strong></td>
<td>获取锁失败</td>
<td>调用 await()</td>
</tr>
<tr>
<td><strong>出队条件</strong></td>
<td>获取锁成功</td>
<td>被 signal() 或中断</td>
</tr>
<tr>
<td><strong>节点状态</strong></td>
<td>SIGNAL, CANCELLED 等</td>
<td>CONDITION</td>
</tr>
</tbody>
</table>
<h4 id="await-和-signal-的完整流程">await 和 signal 的完整流程</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 1（持锁）
    participant CQ as 条件队列
    participant SQ as 同步队列
    participant T2 as 线程 2（持锁）
    
    Note over T1: 调用 await()
    T1-&gt;&gt;CQ: 1. 创建节点加入条件队列
    T1-&gt;&gt;SQ: 2. 完全释放锁
    T1-&gt;&gt;T1: 3. park() 阻塞
    
    Note over T2: 获取锁成功
    Note over T2: 调用 signal()
    T2-&gt;&gt;CQ: 4. 取出首节点
    T2-&gt;&gt;SQ: 5. 转移到同步队列尾部
    T2-&gt;&gt;T1: 6. unpark() 唤醒
    
    Note over T1: 被唤醒
    T1-&gt;&gt;SQ: 7. 在同步队列中等待获取锁
    Note over T1: 8. 获取锁成功，从 await() 返回</code></pre>
<h3 id="公平锁与非公平锁">公平锁与非公平锁</h3>
<p>AQS 本身不区分公平与非公平，这由具体的同步器实现决定。以 <code>ReentrantLock</code> 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 非公平锁的 tryAcquire</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 直接尝试 CAS，不检查队列</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-comment">// 重入</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 公平锁的 tryAcquire</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 先检查队列中是否有等待者</span><br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;公平锁 vs 非公平锁&quot;
        direction TB
        
        subgraph &quot;非公平锁&quot;
            NF_NEW[&quot;新线程到达&quot;]
            NF_TRY[&quot;直接尝试 CAS&quot;]
            NF_SUCCESS&#123;&quot;成功?&quot;&#125;
            NF_GET[&quot;获取锁&quot;]
            NF_QUEUE[&quot;入队等待&quot;]
            
            NF_NEW --&gt; NF_TRY
            NF_TRY --&gt; NF_SUCCESS
            NF_SUCCESS --&gt;|是| NF_GET
            NF_SUCCESS --&gt;|否| NF_QUEUE
            
            style NF_TRY fill:#ffcdd2
        end
        
        subgraph &quot;公平锁&quot;
            F_NEW[&quot;新线程到达&quot;]
            F_CHECK[&quot;检查队列&quot;]
            F_EMPTY&#123;&quot;队列为空?&quot;&#125;
            F_TRY[&quot;尝试 CAS&quot;]
            F_SUCCESS&#123;&quot;成功?&quot;&#125;
            F_GET[&quot;获取锁&quot;]
            F_QUEUE[&quot;入队等待&quot;]
            
            F_NEW --&gt; F_CHECK
            F_CHECK --&gt; F_EMPTY
            F_EMPTY --&gt;|是| F_TRY
            F_EMPTY --&gt;|否| F_QUEUE
            F_TRY --&gt; F_SUCCESS
            F_SUCCESS --&gt;|是| F_GET
            F_SUCCESS --&gt;|否| F_QUEUE
            
            style F_CHECK fill:#c8e6c9
        end
    end</code></pre>
<table>
<thead>
<tr>
<th>特性</th>
<th>公平锁</th>
<th>非公平锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>获取顺序</strong></td>
<td>严格 FIFO</td>
<td>允许插队</td>
</tr>
<tr>
<td><strong>吞吐量</strong></td>
<td>较低</td>
<td>较高</td>
</tr>
<tr>
<td><strong>饥饿风险</strong></td>
<td>无</td>
<td>有（但概率低）</td>
</tr>
<tr>
<td><strong>上下文切换</strong></td>
<td>较多</td>
<td>较少</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>对公平性有要求</td>
<td>大多数场景</td>
</tr>
</tbody>
</table>
<h4 id="非公平锁的详细机制：唤醒-head-的问题">非公平锁的详细机制：唤醒 head 的问题</h4>
<p>用户可能会有一个疑问：<strong>非公平锁是否免去了唤醒队列 head 的操作？</strong></p>
<p>答案是：<strong>不是的，非公平锁仍然会唤醒 head，只是允许新线程在 head 被唤醒之前抢先获取锁。</strong></p>
<p>让我们通过时序图来详细说明：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Owner as 持锁线程
    participant Head as 队列 Head（等待中）
    participant New as 新到达线程
    participant State as state/owner
    
    Note over Owner,State: 场景：非公平锁释放
    
    Owner-&gt;&gt;State: 1. 释放锁（state = 0）
    Owner-&gt;&gt;Head: 2. 唤醒队列 head（unpark）
    Note over Head: head 开始被唤醒...
    Note over Head: （唤醒需要时间）
    
    New-&gt;&gt;State: 3. 新线程到达，直接尝试 CAS
    Note over New,State: CAS(state, 0, 1) 成功！
    New-&gt;&gt;State: 4. 获取锁成功
    
    Note over Head: 5. head 完成唤醒
    Head-&gt;&gt;State: 6. 尝试获取锁
    Note over Head,State: CAS 失败（state 已是 1）
    Head-&gt;&gt;Head: 7. 重新 park，继续等待</code></pre>
<p><strong>关键理解</strong>：</p>
<ol>
<li><strong>非公平锁仍然会唤醒 head</strong>：释放锁时，<code>unparkSuccessor()</code> 仍然会被调用，head 节点的线程会被唤醒</li>
<li><strong>新线程可以&quot;插队&quot;</strong>：在 head 被唤醒的过程中（这需要时间），新到达的线程可以直接尝试 CAS 获取锁</li>
<li><strong>head 被唤醒后可能失败</strong>：如果新线程抢先获取了锁，head 唤醒后 CAS 会失败，需要重新 park</li>
</ol>
<p><strong>为什么非公平锁吞吐量更高？</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;公平锁的问题&quot;
        F1[&quot;线程 A 释放锁&quot;] --&gt; F2[&quot;唤醒队列 head（线程 B）&quot;]
        F2 --&gt; F3[&quot;等待 B 完成唤醒...&quot;]
        F3 --&gt; F4[&quot;B 获取锁&quot;]
        
        F5[&quot;新线程 C 到达&quot;] --&gt; F6[&quot;检查队列：有等待者&quot;]
        F6 --&gt; F7[&quot;入队等待&quot;]
        
        style F3 fill:#ffcdd2
        note1[&quot;问题：锁在 B 唤醒期间&lt;br/&gt;处于空闲状态&quot;]
    end
    
    subgraph &quot;非公平锁的优势&quot;
        NF1[&quot;线程 A 释放锁&quot;] --&gt; NF2[&quot;唤醒队列 head（线程 B）&quot;]
        NF2 --&gt; NF3[&quot;B 正在唤醒中...&quot;]
        
        NF5[&quot;新线程 C 到达&quot;] --&gt; NF6[&quot;直接尝试 CAS&quot;]
        NF6 --&gt; NF7[&quot;获取锁成功！&quot;]
        
        NF3 --&gt; NF8[&quot;B 唤醒完成&quot;]
        NF8 --&gt; NF9[&quot;CAS 失败，重新等待&quot;]
        
        style NF7 fill:#c8e6c9
        note2[&quot;优势：锁不会空闲&lt;br/&gt;减少上下文切换&quot;]
    end</code></pre>
<p><strong>AQS 中非公平锁的实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ReentrantLock.NonfairSync</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 关键：不检查队列，直接尝试 CAS</span><br>        <span class="hljs-comment">// 这就是&quot;非公平&quot;的体现</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 插队成功</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ... 重入逻辑</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 对比：公平锁</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 关键：先检查队列是否有等待者</span><br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;  <span class="hljs-comment">// 这一行是区别</span><br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>synchronized 的非公平性</strong>：</p>
<p>synchronized 也是非公平的，其机制类似：</p>
<ol>
<li>持锁线程释放锁时，会从 EntryList 或 cxq 中唤醒一个线程</li>
<li>新到达的线程可以直接尝试 CAS 获取 <code>_owner</code></li>
<li>如果新线程抢先成功，被唤醒的线程会重新进入等待状态</li>
</ol>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Owner as 持锁线程
    participant EL as EntryList 中的线程
    participant New as 新竞争线程
    participant Monitor as ObjectMonitor._owner
    
    Owner-&gt;&gt;Monitor: 1. 释放锁（_owner = null）
    Owner-&gt;&gt;EL: 2. 唤醒 EntryList 头部线程
    
    New-&gt;&gt;Monitor: 3. 新线程尝试 CAS _owner
    Note over New,Monitor: CAS 成功，获取锁
    
    Note over EL: 4. 被唤醒的线程
    EL-&gt;&gt;Monitor: 5. 尝试获取锁
    Note over EL,Monitor: 失败，重新进入 EntryList</code></pre>
<p><strong>总结</strong>：</p>
<table>
<thead>
<tr>
<th>方面</th>
<th>公平锁</th>
<th>非公平锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>是否唤醒 head</strong></td>
<td>是</td>
<td>是（仍然唤醒）</td>
</tr>
<tr>
<td><strong>新线程能否插队</strong></td>
<td>否（先检查队列）</td>
<td>是（直接 CAS）</td>
</tr>
<tr>
<td><strong>head 唤醒后</strong></td>
<td>一定能获取锁</td>
<td>可能失败，需重新等待</td>
</tr>
<tr>
<td><strong>锁空闲时间</strong></td>
<td>较长（等待唤醒）</td>
<td>较短（可被插队者利用）</td>
</tr>
</tbody>
</table>
<h3 id="小结">小结</h3>
<p>AQS 的设计体现了几个重要的工程智慧：</p>
<ol>
<li><strong>state 的多态性</strong>：一个 int 字段，通过不同的解释方式支持多种同步语义</li>
<li><strong>CLH 队列的变体</strong>：结合了 CLH 队列的低竞争特性和双向链表的灵活性</li>
<li><strong>模板方法模式</strong>：<code>acquire</code>/<code>release</code> 定义骨架，<code>tryAcquire</code>/<code>tryRelease</code> 由子类实现</li>
<li><strong>条件队列的分离</strong>：将&quot;等待锁&quot;和&quot;等待条件&quot;分成两个队列，职责清晰</li>
<li><strong>公平性的可选</strong>：通过简单的 <code>hasQueuedPredecessors()</code> 检查实现公平锁</li>
</ol>
<p>理解 AQS 的实现细节，有助于：</p>
<ul>
<li>正确使用 <code>ReentrantLock</code>、<code>Semaphore</code> 等同步器</li>
<li>在需要时实现自定义的同步器</li>
<li>分析和解决并发问题</li>
</ul>
<h2 id="aqs-源码深度分析">AQS 源码深度分析</h2>
<p>前面我们介绍了 AQS 的核心设计和基于 AQS 的同步器实现。本节将深入 AQS 的源码实现细节，帮助读者理解其内部工作机制。</p>
<h3 id="aqs-的五层结构">AQS 的五层结构</h3>
<p>从整体架构来看，AQS 框架可以分为五层，自上而下由浅入深：</p>
<p><img src="AQS%E7%9A%84%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="AQS的五层结构"></p>
<blockquote>
<p>上图中有颜色的为 Method，无颜色的为 Attribution。</p>
<p>总的来说，AQS 框架共分为五层，自上而下由浅入深，从 AQS 对外暴露的 API 到底层基础数据。</p>
</blockquote>
<h3 id="同步队列与条件队列">同步队列与条件队列</h3>
<p>AQS 内部维护两种队列：<strong>同步队列（Sync Queue）</strong> 和 <strong>条件队列（Condition Queue）</strong>。</p>
<p>Condition 有一个单独的 condition queue，和 main queue 使用同一批节点，但使用 additional link。</p>
<p><img src="CLH%E5%8F%98%E4%BD%93%E9%98%9F%E5%88%97.png" alt="CLH变体队列"></p>
<p><strong>为什么同步队列是 CLH 变体，而条件队列不是？</strong></p>
<p>这是一个很好的问题。两种队列的设计差异源于它们面临的不同需求：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>同步队列（Sync Queue）</th>
<th>条件队列（Condition Queue）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>队列类型</strong></td>
<td>CLH 变体（双向链表）</td>
<td>普通单向链表</td>
</tr>
<tr>
<td><strong>链接方式</strong></td>
<td><code>prev</code> + <code>next</code> 双向链接</td>
<td>只有 <code>nextWaiter</code> 单向链接</td>
</tr>
<tr>
<td><strong>是否需要取消</strong></td>
<td>✅ 需要支持取消（如 <code>tryLock(timeout)</code>）</td>
<td>❌ 不需要，await 被中断时直接转移到同步队列</td>
</tr>
<tr>
<td><strong>是否需要从中间移除</strong></td>
<td>✅ 需要（取消的节点需要从队列中移除）</td>
<td>❌ 不需要</td>
</tr>
<tr>
<td><strong>遍历方向</strong></td>
<td>需要双向遍历（找前驱、找后继）</td>
<td>只需单向遍历（signal 时从头开始）</td>
</tr>
</tbody>
</table>
<p><strong>CLH 变体的核心特性</strong>：</p>
<p>原始的 CLH 队列是单向的，每个节点只需要知道前驱。但 AQS 的同步队列做了以下改进：</p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;原始 CLH 队列（单向）&quot;
        A1[&quot;Node&quot;] --&gt; B1[&quot;Node&quot;] --&gt; C1[&quot;Node&quot;]
    end
    
    subgraph &quot;AQS 同步队列（双向）&quot;
        A2[&quot;Node&quot;] &lt;--&gt; B2[&quot;Node&quot;] &lt;--&gt; C2[&quot;Node&quot;]
    end</code></pre>
<ol>
<li><strong>添加了 <code>next</code> 指针</strong>：用于唤醒后继节点</li>
<li><strong>添加了 <code>prev</code> 指针</strong>：用于取消时找到有效的前驱节点</li>
</ol>
<p><strong>为什么同步队列需要支持取消？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这种场景需要取消</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">acquired</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS);<br><span class="hljs-keyword">if</span> (!acquired) &#123;<br>    <span class="hljs-comment">// 超时了，需要从同步队列中移除当前节点</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>当 <code>tryLock</code> 超时或被中断时，当前线程的节点需要从同步队列中移除。这需要：</p>
<ol>
<li>找到前驱节点（通过 <code>prev</code>）</li>
<li>将前驱的 <code>next</code> 指向当前节点的后继</li>
<li>将后继的 <code>prev</code> 指向当前节点的前驱</li>
</ol>
<p><strong>为什么条件队列不需要 CLH 变体？</strong></p>
<p>条件队列的操作模式更简单：</p>
<ol>
<li><strong>await</strong>：将节点加入条件队列尾部（只需 <code>nextWaiter</code>）</li>
<li><strong>signal</strong>：将节点从条件队列头部移除，转移到同步队列</li>
<li><strong>中断处理</strong>：如果 await 被中断，节点直接转移到同步队列，不需要从条件队列中间移除</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 条件队列的典型操作</span><br>condition.await();   <span class="hljs-comment">// 加入条件队列尾部</span><br>condition.signal();  <span class="hljs-comment">// 从条件队列头部取出，转移到同步队列</span><br></code></pre></td></tr></table></figure>
<p>由于条件队列只需要 FIFO 的入队和出队操作，不需要从中间移除节点，所以简单的单向链表就足够了。</p>
<h3 id="node-节点的详细结构">Node 节点的详细结构</h3>
<p><img src="Node%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="Node的结构"></p>
<p>Node 的构造器有两种形式：一个需要 waitStatus，一个需要 nextWaiter，但都需要 Thread。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于 addWaiter</span><br><span class="hljs-comment"> */</span><br>Node(Thread thread, Node mode) &#123;<br>    <span class="hljs-built_in">this</span>.nextWaiter = mode;<br>    <span class="hljs-built_in">this</span>.thread = thread;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于 Condition</span><br><span class="hljs-comment"> */</span><br>Node(Thread thread, <span class="hljs-type">int</span> waitStatus) &#123;<br>    <span class="hljs-built_in">this</span>.waitStatus = waitStatus;<br>    <span class="hljs-built_in">this</span>.thread = thread;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="独占模式源码详解">独占模式源码详解</h3>
<h4 id="addwaiter：入队操作">addWaiter：入队操作</h4>
<p>这是一个 AQS 自身的成员方法，会生成一个节点，加入到自身的队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 每一个 node 天然出现的时候，自己的 next 都是 mode 参数本身，tail 的 next 是 mode</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// 最快入队的方法是在把新节点的 pred 设置成队尾，所以 FIFO 的 I 指的是对 tail 的追加</span><br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-comment">// 如果存在队尾-此时这不是一个空链表，否则必定走入一个 enq</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 先设置 node 的 prev，在并发入队时，会有多个 node 的 prev 设置为 pred</span><br>        node.prev = pred;<br>        <span class="hljs-comment">// 这一步的实现，是把当前 AQS 的 tail 节点设置为新的 node，之前的 tail 的 prev 本身是不变的</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            <span class="hljs-comment">// 然后把老 tail 的 next 设置为本 node，只有成功通过 CAS 的 node 能够得到 pred 的 next，其他节点还维持错误的 prev</span><br>            pred.next = node;<br>            <span class="hljs-comment">// 然后就可以从快路线返回了，此处返回的是 node 本身</span><br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 进入这里的 node 的 prev 还是错的，在这一步返回的 node 是 alreadyLinked 了的</span><br>    enq(node);<br>    <span class="hljs-comment">// 然后就算入队成功，可以返回了</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在外面虽然有一个 enqued 的操作，但实质上对 tail 的修改——也就是入队，是被收敛到 <code>enq(node)</code> 这个方法调用里的，这一个 <code>addWaiter</code> 方法里完成了全部的入队操作。</p>
<h4 id="enq：完整入队">enq：完整入队</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Inserts node into queue, initializing if necessary.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node to insert</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> node&#x27;s predecessor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-comment">// 无限循环，直到能够返回一个 t 为止，enq 的存在是为了实现一个多线程 for 循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 因为 tail 为空 head 必为空，所以此处用局部变量来节省性能</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-comment">// 在 for 循环里，只会进入这一步一次</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-comment">// 设计一个空的队头，然后把本 AQS 的 head 设置为 tail</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                <span class="hljs-comment">// head 和 tail 只要有一个为空，就全部为空。上一个 CAS 已经卡住其他操作，这里的操作就不用 CAS，直接 set 即可</span><br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这一段代码就是外部代码的一部分，只不过移到一个 for loop 里来</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>            <span class="hljs-comment">// 如果 CAS 失败，则下一轮的 node.prev 会被覆写</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="acquirequeued：在队列中自旋等待">acquireQueued：在队列中自旋等待</h4>
<p>这个方法提供了一个内部的自旋和 park 和从 unpark 中醒来的全部流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Acquires in exclusive uninterruptible mode for thread already in queue.</span><br><span class="hljs-comment"> * 在互斥且不可中断模式下（与之相对地是 doAcquireShared）</span><br><span class="hljs-comment"> * 每一个节点进入 queue 的顺序是这样的：</span><br><span class="hljs-comment"> * 1. 先看看自己是不是 head 后的第一个 node，如果是的话，带着 interrupted 返回</span><br><span class="hljs-comment"> * 2. 检查 pred 的状态 ws：</span><br><span class="hljs-comment"> *    2.1 ws 此时是 SIGNAL，意味着上次已经设值过了，此节点需要做的就是 park</span><br><span class="hljs-comment"> *    2.2 如果 ws 此时是 CANCELLED，寻找一个新的 pred（做 pred 收窄）</span><br><span class="hljs-comment"> *    2.3 尝试把它设置为 SIGNAL</span><br><span class="hljs-comment"> *    2.4 2.2 和 2.3 会直接导致 false 退出，然后进入下一轮的求锁循环</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 阻塞由两部分组成，一部分是这里的 for 循环，一部分是下面的检查 park</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// node 在循环里是不会变的，每个循环里都只取 node 的前置</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 如果它的前驱为 head，则尝试获取锁</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 如果获锁成功，则把本节点设置为头</span><br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 第一个条件检查状态机，看看是不是 shouldPark</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) <br>                <span class="hljs-comment">// 第二个条件用 park 来实现阻塞</span><br>                &amp;&amp; parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="acquireQueued%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="acquireQueued的实现"></p>
<h4 id="shouldparkafterfailedacquire：判断是否需要阻塞">shouldParkAfterFailedAcquire：判断是否需要阻塞</h4>
<table>
<thead>
<tr>
<th>waitStatus</th>
<th>值</th>
<th>含义</th>
<th>设置时机</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0</td>
<td>初始状态</td>
<td>节点创建时</td>
</tr>
<tr>
<td>-1</td>
<td>SIGNAL</td>
<td>后继节点需要被唤醒</td>
<td>后继节点入队时设置前驱为 SIGNAL</td>
</tr>
<tr>
<td>-2</td>
<td>CONDITION</td>
<td>节点在条件队列中</td>
<td>await() 时创建条件节点</td>
</tr>
<tr>
<td>-3</td>
<td>PROPAGATE</td>
<td>共享模式下传播唤醒</td>
<td>releaseShared 时设置</td>
</tr>
<tr>
<td>1</td>
<td>CANCELLED</td>
<td>节点已取消</td>
<td>超时、中断、异常时</td>
</tr>
</tbody>
</table>
<p><img src="shouldParkAfterFailedAcquire.png" alt="shouldParkAfterFailedAcquire"></p>
<h4 id="cancelacquire：取消获取锁">cancelAcquire：取消获取锁</h4>
<p><code>cancelAcquire</code> 方法在节点取消时被调用，它需要处理三种不同的场景：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>条件</th>
<th>处理方式</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>尾节点</td>
<td>node == tail</td>
<td>CAS 更新 tail，清空 pred.next</td>
<td>直接移除尾节点</td>
</tr>
<tr>
<td>中间节点</td>
<td>pred != head &amp;&amp; pred 有效</td>
<td>CAS 连接 pred.next → node.next</td>
<td>跳过当前节点</td>
</tr>
<tr>
<td>head 后继</td>
<td>pred == head 或 pred 无效</td>
<td>unparkSuccessor(node)</td>
<td>唤醒后继让其重新竞争</td>
</tr>
</tbody>
</table>
<p><img src="cancelledAcquire-%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%98%AF%E5%B0%BE%E8%8A%82%E7%82%B9.png" alt="cancelledAcquire-当前节点是尾节点"><br>
<img src="cancellAcquire-%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%98%AFhead%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9.png" alt="cancellAcquire-当前节点是head的后继节点"><br>
<img src="cancellAcquire-%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%98%AF%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.png" alt="cancellAcquire-当前节点是中间节点"></p>
<h3 id="公平锁与非公平锁流程对比">公平锁与非公平锁流程对比</h3>
<p><img src="%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%B5%81%E7%A8%8B1.png" alt="非公平锁流程1"><br>
<img src="%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%B5%81%E7%A8%8B2.png" alt="非公平锁流程2"></p>
<p><strong>关于公平锁/非公平锁的经典面试题：</strong></p>
<ol>
<li>
<p><strong>ReentrantLock 和 synchronized 默认是公平还是非公平？</strong></p>
<ul>
<li>答：都是非公平。synchronized 偏向锁/轻量级锁/重量级锁的升级过程本身就是带有竞争和插队的，重量级锁底层 ObjectMonitor 的 EntryList 竞争也不保证顺序。</li>
</ul>
</li>
<li>
<p><strong>什么情况下应该强制使用公平锁？</strong></p>
<ul>
<li>答：当持有锁的时间相对较长，或者业务上强烈要求&quot;先来后到&quot;的顺序（例如按顺序打印、按顺序处理请求），且不在乎吞吐量下降时。</li>
</ul>
</li>
<li>
<p><strong>非公平锁会导致&quot;线程饥饿&quot;吗？如何解决？</strong></p>
<ul>
<li>答：理论上会，如果不断有新线程插队，队列里的线程可能一直等。但在 AQS 设计中，一旦插队失败进入队列，就只能排队，所以长期来看不会完全饿死，只是等待时间变数大。如果必须避免，请用公平锁。</li>
</ul>
</li>
<li>
<p><strong>AQS 中 hasQueuedPredecessors() 的作用是什么？</strong></p>
<ul>
<li>答：这是公平锁判断&quot;是否需要排队&quot;的核心逻辑。如果队列不为空且头节点的后继不是当前线程，说明有人在排队，当前线程必须放弃 CAS，去排队。</li>
</ul>
</li>
</ol>
<h3 id="独占与共享模式">独占与共享模式</h3>
<p><img src="%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F.png" alt="独占模式与共享模式"></p>
<h3 id="condition-条件队列详解">Condition 条件队列详解</h3>
<p>从 Doug Lea 的原始设计思路来讲，一个 Condition 是要引出一组多线程共用的 wait-set。它和锁的抽象实现了 arbitrary lock 和 condition implementation 的正交组合。</p>
<p>Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods. 在原始的 Java 锁机制里面，synchronized 被叫作 synchronized methods，而 condition 被叫作 monitor methods。</p>
<p>条件有很多种叫法，可以叫作 condition queue，也可以叫作 condition variable。一个线程的使用语序总是先 wait，然后再由外部 notify，由内外协同来实现对执行上下文的切换。</p>
<p><img src="%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97.png" alt="条件队列"></p>
<h4 id="conditionobject-的结构">ConditionObject 的结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;<br>    <span class="hljs-comment">// 条件队列的第一个节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br>    <span class="hljs-comment">// 条件队列的最后一个节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们可以看到，Node 仍然是 AQS 的 node，但它们的 ws 是 <code>Node.CONDITION</code>。</p>
<h4 id="条件等待的三种形式">条件等待的三种形式</h4>
<ol>
<li><strong>interruptible waiting</strong>：会抛出中断异常</li>
<li><strong>non-interruptible waiting</strong>：不会抛出中断异常</li>
<li><strong>timed waiting</strong>：带超时的等待</li>
</ol>
<p>不管采用哪种形式，从 await 中返回过来，这个线程要 guaranteed to hold this lock。</p>
<h3 id="countdownlatch-源码分析">CountDownLatch 源码分析</h3>
<p><img src="countDownLatch.png" alt="countDownLatch"></p>
<p>CountDownLatch 是一个 one-shot phenomenon，它的 state 是不能被复用的。</p>
<p>这个类的功能底层依赖于自身的 sync 的两个实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>    Sync(<span class="hljs-type">int</span> count) &#123;<br>        setState(count);<br>    &#125;<br><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> getState();<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>        <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="await-的入队过程">await 的入队过程</h4>
<p><img src="CountDownLatch%E5%85%A5%E9%98%9F1.png" alt="CountDownLatch入队1"></p>
<p>在互斥类的 acquire 里面，只有 state 不为 0（已被其他线程获取锁）会导致入队。在共享类的 acquire 里，只要 state 不为 0，也入队，反复自旋，直到 state 为 0 才导致出队，让 await 降为 0。</p>
<p><img src="CountDownLatch%E5%85%A5%E9%98%9F2.png" alt="CountDownLatch入队2"><br>
<img src="CountDownLatch%E5%85%A5%E9%98%9F3.png" alt="CountDownLatch入队3"></p>
<h4 id="countdown-的释放过程">countDown 的释放过程</h4>
<p><img src="CountDownLatch%E9%87%8A%E6%94%BE.png" alt="CountDownLatch释放"></p>
<p><code>countDown()</code> -&gt; <code>releaseShared(1)</code> -&gt; <code>tryReleaseShared(1)</code> -&gt; <code>doReleaseShared()</code></p>
<h3 id="cyclicbarrier-详解">CyclicBarrier 详解</h3>
<p>cyclic 既有周期的意思，也有循环的意思。</p>
<p><img src="cyclicbarrier-1.png" alt="cyclicbarrier-1"><br>
<img src="cyclicbarrier-2.png" alt="cyclicbarrier-2"></p>
<blockquote>
<p>CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS 的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p>
</blockquote>
<h4 id="cyclicbarrier-和-countdownlatch-的区别">CyclicBarrier 和 CountDownLatch 的区别</h4>
<ol>
<li><strong>CyclicBarrier</strong> 使用互斥而不是共享机制来实现多线程协同，共享状态是由 party 生成的 count。CyclicBarrier 依托 Condition。</li>
<li><strong>CountDownLatch</strong> 通过共享而不是互斥来实现多线程协同，共享状态是 AQS 的 state。CountDownLatch 有自己的 sync。</li>
<li><strong>CyclicBarrier</strong> 只需要每个内线程做完自己的事自动 <strong>await</strong>，不需要 signal，到齐了自动就通过；<strong>CountDownLatch</strong> 让内线程 <strong>countDown</strong>。CyclicBarrier 外线程等待这个到齐结果 join 所有内线程；CountDownLatch 对 latch 进行 <strong>await</strong>。</li>
</ol>
<h4 id="cyclicbarrier-状态转换">CyclicBarrier 状态转换</h4>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; 初始状态: new CyclicBarrier(n)
    
    初始状态 --&gt; 等待中: 线程调用 await()&lt;br/&gt;count--
    等待中 --&gt; 等待中: 更多线程 await()&lt;br/&gt;count--
    
    等待中 --&gt; 触发: count == 0&lt;br/&gt;最后一个线程到达
    触发 --&gt; 初始状态: nextGeneration()&lt;br/&gt;重置 count，新建 Generation
    
    等待中 --&gt; 破损: 中断/超时/reset
    破损 --&gt; 初始状态: reset() 调用&lt;br/&gt;breakBarrier + nextGeneration
    
    note right of 初始状态
        count = parties
        generation.broken = false
    end note</code></pre>
<h3 id="semaphore-源码分析">Semaphore 源码分析</h3>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;三种同步器的对比&quot;
        subgraph &quot;Semaphore&quot;
            SEM[&quot;Semaphore&quot;]
            S1[&quot;• state = 可用许可数&lt;br/&gt;• acquire: state--&lt;br/&gt;• release: state++&lt;br/&gt;• 可双向变化&quot;]
        end
        
        subgraph &quot;CountDownLatch&quot;
            CDL[&quot;CountDownLatch&quot;]
            C1[&quot;• state = 剩余计数&lt;br/&gt;• countDown: state--&lt;br/&gt;• 只能单向减少&lt;br/&gt;• 一次性使用&quot;]
        end
        
        subgraph &quot;CyclicBarrier&quot;
            CB[&quot;CyclicBarrier&quot;]
            B1[&quot;• count = 等待线程数&lt;br/&gt;• await: count--&lt;br/&gt;• 最后线程触发&lt;br/&gt;• 可重复使用&lt;br/&gt;• 可重置&quot;]
        end
    end
    
    style SEM fill:#e3f2fd
    style CDL fill:#fff3e0
    style CB fill:#e8f5e9</code></pre>
<table>
<thead>
<tr>
<th>特性</th>
<th>Semaphore</th>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>state 语义</strong></td>
<td>可用许可数</td>
<td>剩余计数</td>
<td>等待线程数</td>
</tr>
<tr>
<td><strong>增减方向</strong></td>
<td>双向（acquire-/release+）</td>
<td>单向（只减）</td>
<td>单向（只减）</td>
</tr>
<tr>
<td><strong>可重用</strong></td>
<td>是</td>
<td>否</td>
<td>是（自动重置）</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>资源池限流</td>
<td>等待多任务完成</td>
<td>多线程同步点</td>
</tr>
</tbody>
</table>
<p>Semaphore 使用数字维护一个共享状态池，使用共享加解锁的思路来修改 state。</p>
<blockquote>
<p>创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用 acquire 的时候，执行 state = state - 1，release 的时候执行 state = state + 1，当然，acquire 的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p>
</blockquote>
<h4 id="官方示例">官方示例</h4>
<p>作者认为这是一个 permit pool：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_AVAILABLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(MAX_AVAILABLE, <span class="hljs-literal">true</span>);<br> <br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getItem</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        available.acquire();<br>        <span class="hljs-keyword">return</span> getNextAvailableItem();<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putItem</span><span class="hljs-params">(Object x)</span> &#123;<br>        <span class="hljs-keyword">if</span> (markAsUnused(x))<br>            available.release();<br>    &#125;<br> <br>    <span class="hljs-keyword">protected</span> Object[] items = ... <span class="hljs-comment">// whatever kinds of items being managed</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[MAX_AVAILABLE];<br> <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title function_">getNextAvailableItem</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>                used[i] = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">return</span> items[i];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// not reached</span><br>    &#125;<br> <br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markAsUnused</span><span class="hljs-params">(Object item)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;<br>            <span class="hljs-keyword">if</span> (item == items[i]) &#123;<br>                <span class="hljs-keyword">if</span> (used[i]) &#123;<br>                    used[i] = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例里对称很重要，在 op 以前就要 acquire permit，在 op 成功以后才 release permit。它的 state 恰好不是以互斥的方式 accumulated 的，是以共享的方式 accumulated 的。</p>
<p>mutex = binary semaphore = nonreentrant exclusive lock</p>
<p>这种锁是不计较 owner 的，在死锁恢复场景下尤其有用。比如有个线程 a 拿走了一个 permit 没有还，其他线程可以通过把自己的 permit 归还，来暂时制造流动性。</p>
<h4 id="构造器">构造器</h4>
<p>因为信号量也是不易察觉的&quot;类锁&quot;的方案，所以它也有公平和非公平的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(<span class="hljs-keyword">permits</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不公平抢锁可以减少调度，被称作 barging；公平抢锁可以减少饥饿。</p>
<h4 id="获取资源：四大-acquire-方法">获取资源：四大 acquire 方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>    sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">permits</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    sync.acquireSharedInterruptibly(<span class="hljs-keyword">permits</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">permits</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    sync.acquireShared(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有可中断和不可中断两大类 API，也有无参数和固定参数两大 API，不过 API 命名的习惯没有得到遵循，默认的 Semaphore 的方法是响应中断的。</p>
<h4 id="tryacquireshared-的公平与非公平实现">tryAcquireShared 的公平与非公平实现</h4>
<p><strong>公平实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (hasQueuedPredecessors())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>非公平实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br>&#125;<br><br><span class="hljs-comment">// 在父类里</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>公平和非公平的差别只在 <code>hasQueuedPredecessors</code> 的调用结果里。</p>
<h4 id="释放资源">释放资源</h4>
<p>不管用什么方式获取，释放总是用同一个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>        <span class="hljs-comment">// 溢出检查</span><br>        <span class="hljs-keyword">if</span> (next &lt; current)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="locksupport：线程阻塞的基础设施">LockSupport：线程阻塞的基础设施</h2>
<p>有了上述抽象模型的铺垫，我们现在可以深入理解 <code>LockSupport</code>。它是 JDK 提供的线程阻塞原语，是 AQS 等高级同步器的基础设施。</p>
<h3 id="aqs-与-locksupport-的关系">AQS 与 LockSupport 的关系</h3>
<p>在深入细节之前，先澄清一个常见的误解：</p>
<p><strong>AQS 不是 LockSupport 的&quot;封装&quot;，而是 LockSupport 的&quot;使用者&quot;。</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;应用层&quot;
        APP[&quot;用户代码&lt;br/&gt;lock.lock() / lock.unlock()&quot;]
    end
    
    subgraph &quot;具体锁实现层&quot;
        RL[&quot;ReentrantLock&quot;]
        SEM[&quot;Semaphore&quot;]
        CDL[&quot;CountDownLatch&quot;]
        FJP[&quot;ForkJoinPool&quot;]
        PHASER[&quot;Phaser&quot;]
        CUSTOM[&quot;用户自定义同步器&quot;]
    end
    
    subgraph &quot;同步器框架层&quot;
        AQS[&quot;AbstractQueuedSynchronizer&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;管理：state（锁状态）&lt;br/&gt;管理：CLH 等待队列&lt;br/&gt;管理：exclusiveOwnerThread&quot;]
    end
    
    subgraph &quot;线程阻塞原语层&quot;
        LS[&quot;LockSupport&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;park() / unpark()&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;只管理：线程 ↔ CPU 的让渡关系&lt;br/&gt;不管理：任何锁状态&quot;]
    end
    
    subgraph &quot;JVM 层（HotSpot C++）&quot;
        PARKER[&quot;Parker 对象&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;_counter（permit: 0/1）&lt;br/&gt;_cond（条件变量）&lt;br/&gt;_mutex（互斥量）&quot;]
    end
    
    subgraph &quot;操作系统层&quot;
        POSIX[&quot;POSIX: pthread_cond_wait()&lt;br/&gt;pthread_cond_signal()&quot;]
        WIN[&quot;Windows: WaitForSingleObject()&lt;br/&gt;SetEvent()&quot;]
    end
    
    APP --&gt; RL &amp; SEM &amp; CDL
    RL &amp; SEM &amp; CDL --&gt; AQS
    AQS --&gt; LS
    FJP --&gt; LS
    PHASER --&gt; LS
    CUSTOM --&gt; LS
    LS --&gt; PARKER
    PARKER --&gt; POSIX &amp; WIN
    
    style LS fill:#e1f5ff,stroke:#0288d1,stroke-width:3px
    style AQS fill:#c8e6c9,stroke:#388e3c,stroke-width:2px
    style PARKER fill:#fff9c4,stroke:#f9a825</code></pre>
<p><strong>关键理解：LockSupport 的职责边界</strong></p>
<table>
<thead>
<tr>
<th>层次</th>
<th>组件</th>
<th>管理的状态</th>
<th>不管理的状态</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>LockSupport</strong></td>
<td><code>park()</code>/<code>unpark()</code></td>
<td>线程是否阻塞（permit: 0/1）</td>
<td>锁被谁持有、重入次数、等待队列</td>
</tr>
<tr>
<td><strong>AQS</strong></td>
<td>同步器框架</td>
<td>state、owner、CLH 队列</td>
<td>线程如何阻塞（委托给 LockSupport）</td>
</tr>
<tr>
<td><strong>ReentrantLock</strong></td>
<td>具体锁</td>
<td>公平/非公平策略</td>
<td>底层状态管理（委托给 AQS）</td>
</tr>
</tbody>
</table>
<p><strong>LockSupport 的使用者不只有 AQS：</strong></p>
<ul>
<li><code>ForkJoinPool</code> 直接使用 <code>LockSupport.park()</code> 实现工作窃取的等待</li>
<li><code>Phaser</code> 在某些路径上直接使用 <code>LockSupport</code></li>
<li>用户代码也可以直接使用 <code>LockSupport</code> 实现自定义的线程协调</li>
</ul>
<p>因此，正确的理解是：<strong>LockSupport 是一个通用的线程阻塞原语，它只管理&quot;线程是否让出 CPU&quot;这一件事。锁的状态（谁持有锁、重入次数、等待队列）由上层的 AQS 或其他同步器管理。AQS 是 LockSupport 最重要的使用者之一，但不是唯一的使用者，更不是它的&quot;封装&quot;。</strong></p>
<p>本节将从以下维度全面剖析 LockSupport：</p>
<ol>
<li><strong>API 概览</strong>：park/unpark 的基本语义与设计哲学</li>
<li><strong>permit 机制</strong>：解决唤醒丢失问题的核心设计</li>
<li><strong>与其他阻塞方式的对比</strong>：sleep、wait/notify、park/unpark 的本质差异</li>
<li><strong>blocker 参数</strong>：诊断与可观测性支持</li>
</ol>
<h3 id="api-概览：park-unpark-的设计哲学">API 概览：park/unpark 的设计哲学</h3>
<p><code>LockSupport</code> 提供了一组静态方法，用于阻塞和唤醒线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞当前线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span>;                              <span class="hljs-comment">// 无限期阻塞</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span>;                <span class="hljs-comment">// 无限期阻塞，带诊断标记</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanos)</span>;               <span class="hljs-comment">// 阻塞指定纳秒</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> nanos)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(<span class="hljs-type">long</span> deadline)</span>;            <span class="hljs-comment">// 阻塞到指定时间点</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> deadline)</span>;<br><br><span class="hljs-comment">// 唤醒指定线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span>;<br></code></pre></td></tr></table></figure>
<p><strong>设计哲学的核心体现：</strong></p>
<table>
<thead>
<tr>
<th>设计决策</th>
<th>体现</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>阻塞是自愿的</strong></td>
<td><code>park()</code> 总是阻塞调用它的当前线程</td>
<td>线程只能阻塞自己，不能强制阻塞别人</td>
</tr>
<tr>
<td><strong>唤醒是外部的</strong></td>
<td><code>unpark(Thread)</code> 必须指定目标线程</td>
<td>线程需要被别人唤醒，必须知道唤醒谁</td>
</tr>
<tr>
<td><strong>诊断与功能分离</strong></td>
<td>blocker 参数仅用于诊断，不影响行为</td>
<td>核心逻辑保持简洁，诊断作为可选旁路</td>
</tr>
<tr>
<td><strong>不抛受检异常</strong></td>
<td>park 不抛 InterruptedException</td>
<td>作为底层原语，让上层决定如何处理中断</td>
</tr>
</tbody>
</table>
<h3 id="park-与-sleep-wait-的对比">park 与 sleep/wait 的对比</h3>
<p>从 API 形态上看，<code>LockSupport.park()</code> 与 <code>Thread.sleep()</code> 存在显著的相似性：两者都是使当前线程进入阻塞状态的静态方法，都不需要持有任何锁，都可以响应中断。然而，它们在语义设计上存在本质差异。</p>
<h4 id="api-签名对比">API 签名对比</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(Duration duration)</span> <span class="hljs-keyword">throws</span> InterruptedException;  <span class="hljs-comment">// JDK 19+</span><br><br><span class="hljs-comment">// LockSupport 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanos)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> nanos)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(<span class="hljs-type">long</span> deadline)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> deadline)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span>;<br></code></pre></td></tr></table></figure>
<h4 id="核心差异分析">核心差异分析</h4>
<table>
<thead>
<tr>
<th>维度</th>
<th><code>Thread.sleep()</code></th>
<th><code>LockSupport.park()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>唤醒机制</strong></td>
<td>仅时间到期或中断</td>
<td><code>unpark()</code>、中断、虚假唤醒、时间到期</td>
</tr>
<tr>
<td><strong>配对方法</strong></td>
<td>无</td>
<td><code>unpark(Thread)</code></td>
</tr>
<tr>
<td><strong>permit 机制</strong></td>
<td>无</td>
<td>有（二元许可）</td>
</tr>
<tr>
<td><strong>唤醒顺序</strong></td>
<td>不适用</td>
<td><code>unpark()</code> 可先于 <code>park()</code> 调用</td>
</tr>
<tr>
<td><strong>中断响应</strong></td>
<td>抛出 <code>InterruptedException</code>，清除中断状态</td>
<td>静默返回，保留中断状态</td>
</tr>
<tr>
<td><strong>线程状态</strong></td>
<td><code>TIMED_WAITING</code></td>
<td><code>WAITING</code> 或 <code>TIMED_WAITING</code></td>
</tr>
<tr>
<td><strong>设计目的</strong></td>
<td>简单的定时等待</td>
<td>构建同步器的底层原语</td>
</tr>
</tbody>
</table>
<p><strong><code>sleep()</code> 没有对应 <code>unsleep()</code> 方法的原因</strong></p>
<p>这触及了两者设计哲学的核心差异。<code>sleep()</code> 的语义是&quot;休眠指定时长&quot;，其唤醒条件在调用时就已完全确定——时间到期。这是一个<strong>自包含的操作</strong>，不需要外部协作。如果需要提前唤醒，使用 <code>interrupt()</code> 即可，这与 <code>sleep()</code> 的&quot;可中断休眠&quot;语义一致。</p>
<p>相比之下，<code>park()</code> 的语义是&quot;等待许可&quot;，其唤醒条件依赖于外部线程的协作——调用 <code>unpark()</code>。这是一个<strong>协作式操作</strong>，必须有配对的唤醒机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sleep 的语义：自包含的定时等待</span><br>Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">// 语义完整：休眠 1 秒</span><br><br><span class="hljs-comment">// park 的语义：等待外部许可</span><br>LockSupport.park();  <span class="hljs-comment">// 语义不完整：谁来唤醒我？</span><br><span class="hljs-comment">// 必须有另一个线程执行：</span><br>LockSupport.unpark(parkedThread);  <span class="hljs-comment">// 配对的唤醒操作</span><br></code></pre></td></tr></table></figure>
<h3 id="中断处理：park-与-sleep-的差异">中断处理：park 与 sleep 的差异</h3>
<p>两者对中断的处理方式体现了不同的设计取向：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sleep：中断即异常，必须显式处理</span><br><span class="hljs-keyword">try</span> &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// 中断状态已被清除</span><br>    <span class="hljs-comment">// 必须决定如何处理：重新中断、退出、忽略...</span><br>    Thread.currentThread().interrupt();  <span class="hljs-comment">// 恢复中断状态</span><br>&#125;<br><br><span class="hljs-comment">// park：中断即返回，由调用者检查</span><br>LockSupport.park();<br><span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;  <span class="hljs-comment">// 检查并清除中断状态</span><br>    <span class="hljs-comment">// 处理中断</span><br>&#125;<br><span class="hljs-comment">// 或者保留中断状态，让上层处理</span><br></code></pre></td></tr></table></figure>
<h4 id="深入理解-thread-interrupted-：清除还是恢复？">深入理解 Thread.interrupted()：清除还是恢复？</h4>
<p>这是一个容易困惑的问题：为什么 <code>Thread.interrupted()</code> 要清除中断状态？什么时候应该恢复中断状态？</p>
<p><strong>中断状态的本质：一个&quot;一次性消费&quot;的信号</strong></p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; NotInterrupted: 初始状态
    
    NotInterrupted: 中断标志 = false
    Interrupted: 中断标志 = true
    
    NotInterrupted --&gt; Interrupted: thread.interrupt()
    Interrupted --&gt; Interrupted: thread.interrupt()（幂等）
    
    Interrupted --&gt; NotInterrupted: Thread.interrupted()（检查并清除）
    Interrupted --&gt; Interrupted: thread.isInterrupted()（仅检查，不清除）
    
    note right of Interrupted
        中断是一个&quot;请求&quot;
        需要被&quot;消费&quot;
    end note</code></pre>
<p><strong>两种检查方法的区别：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
<th>是否清除中断状态</th>
<th>典型使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Thread.interrupted()</code></td>
<td>检查<strong>当前线程</strong>的中断状态</td>
<td><strong>是</strong></td>
<td>响应中断后，表示&quot;我已处理&quot;</td>
</tr>
<tr>
<td><code>thread.isInterrupted()</code></td>
<td>检查<strong>指定线程</strong>的中断状态</td>
<td><strong>否</strong></td>
<td>仅查询，不改变状态</td>
</tr>
</tbody>
</table>
<p><strong>为什么要清除中断状态？——&quot;消费&quot;语义</strong></p>
<p>中断状态类似于 permit：它是一个&quot;信号&quot;，被检测到后应该被&quot;消费&quot;。如果不清除：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：不清除中断状态</span><br><span class="hljs-keyword">while</span> (!done) &#123;<br>    LockSupport.park();<br>    <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;  <span class="hljs-comment">// 仅检查，不清除</span><br>        <span class="hljs-comment">// 处理中断...</span><br>        <span class="hljs-comment">// 但中断状态仍然是 true！</span><br>    &#125;<br>    <span class="hljs-comment">// 下一次循环，park() 会立即返回（因为中断状态仍为 true）</span><br>    <span class="hljs-comment">// 导致忙循环！</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么有时要恢复中断状态？——&quot;传递&quot;语义</strong></p>
<p>这是另一个关键问题。考虑以下场景：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Caller as 调用者
    participant Library as 库代码
    participant Blocking as 阻塞操作
    
    Caller-&gt;&gt;Library: 调用库方法
    Library-&gt;&gt;Blocking: 执行阻塞操作
    Note over Blocking: 被中断！
    Blocking--&gt;&gt;Library: 抛出 InterruptedException&lt;br/&gt;（中断状态已被清除）
    
    alt 库代码&quot;吞掉&quot;中断
        Library--&gt;&gt;Caller: 返回结果
        Note over Caller: 调用者不知道发生过中断！&lt;br/&gt;无法做出正确响应
    else 库代码&quot;传递&quot;中断
        Library-&gt;&gt;Library: Thread.currentThread().interrupt()
        Library--&gt;&gt;Caller: 返回结果
        Note over Caller: 调用者可以检测到中断&lt;br/&gt;并做出响应
    end</code></pre>
<p><strong>核心原则：谁应该&quot;消费&quot;中断？</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 场景 1：你是最终的中断处理者（如：任务的 run 方法）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123;  <span class="hljs-comment">// 检查并清除——我来处理中断</span><br>        doWork();<br>    &#125;<br>    <span class="hljs-comment">// 线程正常退出，中断已被&quot;消费&quot;</span><br>&#125;<br><br><span class="hljs-comment">// 场景 2：你是中间层，不应该&quot;吞掉&quot;中断</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">libraryMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-comment">// sleep 抛出异常时已清除中断状态</span><br>        <span class="hljs-comment">// 必须恢复，让调用者知道发生过中断！</span><br>        Thread.currentThread().interrupt();<br>        <span class="hljs-comment">// 然后可以返回或抛出异常</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 场景 3：AQS 的做法——记录但不立即处理</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (tryAcquire(arg)) &#123;<br>            <span class="hljs-keyword">return</span> interrupted;  <span class="hljs-comment">// 返回&quot;是否被中断过&quot;，让调用者决定</span><br>        &#125;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())  <span class="hljs-comment">// 清除中断状态</span><br>            interrupted = <span class="hljs-literal">true</span>;   <span class="hljs-comment">// 但记录下来</span><br>        <span class="hljs-comment">// 继续尝试获取锁，不因中断而放弃</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>决策流程图：</strong></p>
<pre><code class="hljs mermaid">flowchart TD
    A[检测到中断] --&gt; B&#123;你是最终处理者吗？&#125;
    B --&gt;|是| C[Thread.interrupted\n清除并处理]
    B --&gt;|否| D&#123;你能完成当前操作吗？&#125;
    D --&gt;|能| E[完成操作后\nThread.currentThread.interrupt\n恢复中断状态]
    D --&gt;|不能| F[Thread.currentThread.interrupt\n恢复中断状态\n然后抛出异常或返回]
    
    C --&gt; G[中断被消费\n线程可以正常退出]
    E --&gt; H[调用者可以检测到中断]
    F --&gt; H
    
    style C fill:#c8e6c9
    style E fill:#fff9c4
    style F fill:#fff9c4</code></pre>
<p><strong>总结：中断处理的三条黄金法则</strong></p>
<ol>
<li><strong>不要吞掉中断</strong>：如果你不是最终处理者，必须恢复中断状态或抛出 <code>InterruptedException</code></li>
<li><strong>清除意味着消费</strong>：调用 <code>Thread.interrupted()</code> 表示&quot;我已经处理了这个中断&quot;</li>
<li><strong>恢复意味着传递</strong>：调用 <code>Thread.currentThread().interrupt()</code> 表示&quot;让上层来处理&quot;</li>
</ol>
<p><code>park()</code> 的这种设计使其更适合作为同步器的构建块。AQS 中的 <code>acquireQueued()</code> 方法正是利用了这一特性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS.acquireQueued 的简化逻辑</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (tryAcquire(arg)) &#123;<br>            <span class="hljs-keyword">return</span> interrupted;  <span class="hljs-comment">// 返回是否被中断过</span><br>        &#125;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            interrupted = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 记录中断，但继续尝试获取锁</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="permit-机制解决的问题">permit 机制解决的问题</h4>
<p><code>park()</code>/<code>unpark()</code> 的 permit 机制解决了一个 <code>sleep()</code> 无法处理的经典问题：<strong>唤醒信号与等待操作的执行顺序不确定性</strong>。</p>
<p>考虑以下场景：线程 A 需要等待线程 B 完成某项工作后再继续。</p>
<p><strong>使用 sleep 的错误尝试：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br><span class="hljs-keyword">while</span> (!workDone) &#123;<br>    Thread.sleep(<span class="hljs-number">100</span>);  <span class="hljs-comment">// 轮询等待，浪费 CPU</span><br>&#125;<br><br><span class="hljs-comment">// 线程 B</span><br>doWork();<br>workDone = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 无法主动唤醒 A，只能等 A 的下一次轮询</span><br></code></pre></td></tr></table></figure>
<p><strong>使用 wait/notify 的经典问题：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-keyword">while</span> (!workDone) &#123;<br>        lock.wait();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线程 B</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    doWork();<br>    workDone = <span class="hljs-literal">true</span>;<br>    lock.notify();<br>&#125;<br><br><span class="hljs-comment">// 问题：如果 B 先执行完，notify 信号丢失，A 将永远等待</span><br></code></pre></td></tr></table></figure>
<p><strong>使用 park/unpark 的解决方案：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A（等待方）</span><br><span class="hljs-keyword">while</span> (!workDone) &#123;       <span class="hljs-comment">// 1. 先检查条件</span><br>    LockSupport.park();   <span class="hljs-comment">// 2. 条件不满足才 park</span><br>&#125;                         <span class="hljs-comment">// 3. 被唤醒后回到循环开头重新检查</span><br><br><span class="hljs-comment">// 线程 B（唤醒方）</span><br>doWork();<br>workDone = <span class="hljs-literal">true</span>;          <span class="hljs-comment">// 1. 先设置条件</span><br>LockSupport.unpark(threadA);  <span class="hljs-comment">// 2. 然后才 unpark</span><br></code></pre></td></tr></table></figure>
<p><strong>这个模式的关键在于：</strong></p>
<ul>
<li><strong>等待方</strong>：先检查条件，条件不满足才 park。被唤醒后必须重新检查条件（因为可能是虚假唤醒）。</li>
<li><strong>唤醒方</strong>：先设置条件，然后才 unpark。这确保了即使 unpark 先于 park 执行，等待方在下一次检查条件时也能发现条件已满足。</li>
</ul>
<p><strong>permit 机制解决的问题</strong>：即使 B 先执行 unpark，permit 会被保存。A 随后调用 park 时立即返回，不会阻塞。但 A 仍然会重新检查条件，发现 <code>workDone == true</code>，于是退出循环。</p>
<h3 id="底层实现：从-java-到操作系统">底层实现：从 Java 到操作系统</h3>
<p>尽管 API 语义不同，<code>sleep()</code> 和 <code>park()</code> 在 HotSpot JVM 中的底层实现存在共性。两者最终都会调用操作系统的线程阻塞原语：</p>
<ul>
<li><strong>POSIX 系统</strong>：<code>pthread_cond_wait()</code> / <code>pthread_cond_timedwait()</code></li>
<li><strong>Windows</strong>：<code>WaitForSingleObject()</code> / <code>WaitForMultipleObjects()</code></li>
</ul>
<p>关键差异在于唤醒条件的管理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// HotSpot 中 Parker 的核心结构（简化）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parker</span> : <span class="hljs-keyword">public</span> os::PlatformParker &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> _counter;  <span class="hljs-comment">// permit 计数器（0 或 1）</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">park</span><span class="hljs-params">(<span class="hljs-type">bool</span> isAbsolute, jlong time)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// park 的核心逻辑</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parker::park</span><span class="hljs-params">(<span class="hljs-type">bool</span> isAbsolute, jlong time)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">xchg</span>(&amp;_counter, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 有 permit，立即返回</span><br>    <span class="hljs-comment">// ... 进入条件等待 ...</span><br>&#125;<br><br><span class="hljs-comment">// unpark 的核心逻辑</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parker::unpark</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> s = Atomic::<span class="hljs-built_in">xchg</span>(&amp;_counter, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 设置 permit</span><br>    <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 唤醒等待的线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>sleep()</code> 则没有这个 permit 机制，它直接进入定时等待，唯一的提前唤醒途径是中断。</p>
<h3 id="使用场景的选择">使用场景的选择</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐使用</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单的定时延迟</td>
<td><code>Thread.sleep()</code></td>
<td>语义清晰，无需配对操作</td>
</tr>
<tr>
<td>限流、节流</td>
<td><code>Thread.sleep()</code></td>
<td>固定时间间隔，无需外部唤醒</td>
</tr>
<tr>
<td>线程间协调</td>
<td><code>LockSupport.park()/unpark()</code></td>
<td>精确的一对一唤醒</td>
</tr>
<tr>
<td>构建同步器</td>
<td><code>LockSupport.park()/unpark()</code></td>
<td>permit 机制避免信号丢失</td>
</tr>
<tr>
<td>等待条件变量</td>
<td><code>Condition.await()</code></td>
<td>高层抽象，内部使用 park</td>
</tr>
<tr>
<td>等待对象监视器</td>
<td><code>Object.wait()</code></td>
<td>与 synchronized 配合使用</td>
</tr>
</tbody>
</table>
<h3 id="小结：park-与-sleep-的本质差异">小结：park 与 sleep 的本质差异</h3>
<p><code>park()</code> 与 <code>sleep()</code> 的关系可以这样理解：<code>sleep()</code> 是一个<strong>自给自足的定时等待</strong>，而 <code>park()</code> 是一个<strong>需要外部配合的协作等待</strong>。<code>sleep()</code> 没有 <code>unsleep()</code> 方法，正如 <code>park()</code> 必须有 <code>unpark()</code> 方法一样，这不是 API 设计的疏漏，而是两者语义本质差异的必然体现。</p>
<p>从同步原语的角度看，<code>park()</code>/<code>unpark()</code> 提供了比 <code>sleep()</code> 更底层、更灵活的线程阻塞机制，它是 <code>java.util.concurrent</code> 包中各种同步器的基石。而 <code>sleep()</code> 则保持了其简单直接的定位：当你只需要让线程暂停一段时间时，它仍然是最佳选择。</p>
<h3 id="从-java-线程-api-到操作系统：自愿-vs-强制操作的统一视角">从 Java 线程 API 到操作系统：自愿 vs 强制操作的统一视角</h3>
<p><code>park</code>/<code>unpark</code> 的参数不对称性并非孤例，而是反映了并发编程中一个更深层的设计原则：<strong>自愿操作作用于当前线程，强制操作必须指定目标线程</strong>。</p>
<p><strong>Java 线程 API 的参数模式：</strong></p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>方法签名</th>
<th>作用目标</th>
<th>设计原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>自愿阻塞</strong></td>
<td><code>Thread.sleep(long millis)</code></td>
<td>当前线程</td>
<td>线程主动让出 CPU，无需指定自己</td>
</tr>
<tr>
<td><strong>自愿阻塞</strong></td>
<td><code>Object.wait()</code></td>
<td>当前线程</td>
<td>线程主动进入等待，释放锁</td>
</tr>
<tr>
<td><strong>自愿阻塞</strong></td>
<td><code>LockSupport.park(Object blocker)</code></td>
<td>当前线程</td>
<td>blocker 仅用于诊断</td>
</tr>
<tr>
<td><strong>强制唤醒</strong></td>
<td><code>Object.notify()/notifyAll()</code></td>
<td>等待队列中的线程</td>
<td>由 Monitor 管理目标选择</td>
</tr>
<tr>
<td><strong>强制唤醒</strong></td>
<td><code>LockSupport.unpark(Thread t)</code></td>
<td>指定线程</td>
<td>必须明确唤醒谁</td>
</tr>
<tr>
<td><strong>强制中断</strong></td>
<td><code>thread.interrupt()</code></td>
<td>指定线程</td>
<td>必须明确中断谁</td>
</tr>
<tr>
<td><strong>强制终止</strong></td>
<td><code>thread.stop()</code> (已废弃)</td>
<td>指定线程</td>
<td>必须明确终止谁</td>
</tr>
<tr>
<td><strong>强制挂起</strong></td>
<td><code>thread.suspend()</code> (已废弃)</td>
<td>指定线程</td>
<td>必须明确挂起谁</td>
</tr>
</tbody>
</table>
<p><strong>操作系统层面的对应关系：</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;自愿操作（作用于当前进程/线程）&quot;
        SLEEP[&quot;sleep()&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;主动让出 CPU&lt;br/&gt;进入 SLEEPING 状态&quot;]
        WAIT[&quot;wait()/park()&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;主动等待条件&lt;br/&gt;进入 WAITING 状态&quot;]
        YIELD[&quot;yield()&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;主动让出时间片&lt;br/&gt;仍为 RUNNABLE&quot;]
        EXIT[&quot;exit()&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;主动终止自己&quot;]
        
        style SLEEP fill:#c8e6c9
        style WAIT fill:#c8e6c9
        style YIELD fill:#c8e6c9
        style EXIT fill:#c8e6c9
    end
    
    subgraph &quot;强制操作（必须指定目标）&quot;
        KILL[&quot;kill(pid, signal)&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;向指定进程发信号&lt;br/&gt;必须知道 PID&quot;]
        SIGNAL[&quot;pthread_kill(tid, sig)&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;向指定线程发信号&lt;br/&gt;必须知道 TID&quot;]
        CANCEL[&quot;pthread_cancel(tid)&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;请求取消指定线程&lt;br/&gt;必须知道 TID&quot;]
        UNPARK[&quot;unpark(thread)&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;唤醒指定线程&lt;br/&gt;必须持有引用&quot;]
        
        style KILL fill:#ffcdd2
        style SIGNAL fill:#ffcdd2
        style CANCEL fill:#ffcdd2
        style UNPARK fill:#ffcdd2
    end</code></pre>
<p><strong>为什么会有这种设计？</strong></p>
<ol>
<li>
<p><strong>安全性考量</strong>：如果允许线程 A 强制阻塞线程 B，可能导致死锁或资源泄漏。线程 B 可能正持有锁、正在执行关键操作，强制阻塞它会破坏系统一致性。</p>
</li>
<li>
<p><strong>协作式 vs 抢占式</strong>：</p>
<ul>
<li><strong>阻塞是协作式的</strong>：线程在安全点主动放弃执行权</li>
<li><strong>唤醒/中断是抢占式的</strong>：外部力量介入改变线程状态</li>
</ul>
</li>
<li>
<p><strong>信息不对称</strong>：</p>
<ul>
<li>当前线程知道自己的状态，可以安全地阻塞自己</li>
<li>外部线程不知道目标线程的内部状态，只能发送&quot;请求&quot;（如中断），由目标线程决定如何响应</li>
</ul>
</li>
<li>
<p><strong>POSIX 信号模型的影响</strong>：Unix/Linux 的信号机制（<code>kill(pid, signal)</code>）就是&quot;向指定目标发送异步通知&quot;的典范，Java 的 <code>interrupt()</code> 和 <code>unpark()</code> 继承了这一思想。</p>
</li>
</ol>
<p><strong><code>stop()</code>/<code>suspend()</code> 被废弃的教训：</strong></p>
<p>Java 早期提供的 <code>Thread.stop()</code> 和 <code>Thread.suspend()</code> 正是&quot;强制阻塞/终止其他线程&quot;的尝试，但它们被证明是危险的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 危险！stop() 会立即终止线程，可能导致：</span><br><span class="hljs-comment">// 1. 锁未释放 → 死锁</span><br><span class="hljs-comment">// 2. 数据结构更新到一半 → 不一致状态</span><br><span class="hljs-comment">// 3. 资源未清理 → 泄漏</span><br>thread.stop();  <span class="hljs-comment">// @Deprecated since JDK 1.2</span><br><br><span class="hljs-comment">// 危险！suspend() 会冻结线程但不释放锁</span><br><span class="hljs-comment">// 如果被挂起的线程持有锁，其他线程将永远等待</span><br>thread.suspend();  <span class="hljs-comment">// @Deprecated since JDK 1.2</span><br></code></pre></td></tr></table></figure>
<p>这些 API 的废弃证明了：<strong>强制改变其他线程的执行状态是危险的</strong>。正确的做法是：</p>
<ul>
<li>使用 <code>interrupt()</code> 发送中断请求，由目标线程自己决定如何响应</li>
<li>使用 <code>volatile</code> 标志位进行协作式停止</li>
<li>使用 <code>park()</code>/<code>unpark()</code> 进行精确的线程协调</li>
</ul>
<h3 id="permit-机制：二元许可的设计与实现">permit 机制：二元许可的设计与实现</h3>
<p><code>park</code>/<code>unpark</code> 的核心是一个<strong>二元许可（permit）机制</strong>。这是 LockSupport 区别于其他阻塞方式的关键特性，也是理解 AQS 等同步器实现的基础。</p>
<h4 id="从-dijkstra-的-p-v-信号量说起">从 Dijkstra 的 P/V 信号量说起</h4>
<p>1965 年，Dijkstra 提出了信号量（Semaphore）概念，使用两个原子操作：</p>
<ul>
<li><strong>P 操作（Proberen，荷兰语&quot;测试&quot;）</strong>：如果信号量 &gt; 0，则减 1 并继续；否则阻塞</li>
<li><strong>V 操作（Verhogen，荷兰语&quot;增加&quot;）</strong>：信号量加 1，唤醒一个等待者</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">Semaphore</span>(n)：初始值为 n 的计数器<br><span class="hljs-selector-tag">P</span>(S)：while (S &lt;= <span class="hljs-number">0</span>) wait; S--<br><span class="hljs-built_in">V</span>(S)：S++; <span class="hljs-built_in">wakeup_one</span>()<br></code></pre></td></tr></table></figure>
<p><strong>park/unpark 是&quot;退化的二元信号量&quot;</strong></p>
<p><code>LockSupport</code> 的 permit 机制可以理解为<strong>计数上限为 1 的信号量</strong>：</p>
<table>
<thead>
<tr>
<th>信号量概念</th>
<th>park/unpark 对应</th>
<th>关键差异</th>
</tr>
</thead>
<tbody>
<tr>
<td>P 操作</td>
<td><code>park()</code></td>
<td>消耗 permit，若无则阻塞</td>
</tr>
<tr>
<td>V 操作</td>
<td><code>unpark()</code></td>
<td>发放 permit，但<strong>最多累积 1 个</strong></td>
</tr>
<tr>
<td>计数器</td>
<td>permit（0 或 1）</td>
<td>不是任意整数，只有两个状态</td>
</tr>
</tbody>
</table>
<p><strong>为什么 permit 最多只能累积 1 个？</strong></p>
<p>这是一个关键的设计决策。考虑以下场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果 permit 可以累积多个...</span><br>unpark(thread);  <span class="hljs-comment">// permit = 1</span><br>unpark(thread);  <span class="hljs-comment">// permit = 2（假设可以累积）</span><br>unpark(thread);  <span class="hljs-comment">// permit = 3</span><br><br><span class="hljs-comment">// 那么线程可以连续 park 三次而不阻塞</span><br>park();  <span class="hljs-comment">// permit = 2，立即返回</span><br>park();  <span class="hljs-comment">// permit = 1，立即返回</span><br>park();  <span class="hljs-comment">// permit = 0，立即返回</span><br>park();  <span class="hljs-comment">// 才会阻塞</span><br></code></pre></td></tr></table></figure>
<p>这会导致<strong>唤醒信号的语义混乱</strong>：一次 <code>unpark</code> 本意是&quot;唤醒一次&quot;，但如果可以累积，就变成了&quot;预支多次唤醒&quot;。<code>park</code>/<code>unpark</code> 的设计目标是<strong>精确的一对一唤醒</strong>，而非通用的计数信号量。</p>
<h4 id="permit-与-aqs-state-的本质区别">permit 与 AQS state 的本质区别</h4>
<p>这是一个容易混淆的概念。<code>LockSupport</code> 的 permit 和 <code>AQS</code> 的 state 虽然都是整数，但语义完全不同：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>LockSupport permit</th>
<th>AQS state</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>取值范围</strong></td>
<td>只有 0 和 1（二元）</td>
<td>任意 int 值（可累加）</td>
</tr>
<tr>
<td><strong>累加性</strong></td>
<td>多次 unpark 只累积 1 个 permit</td>
<td>多次 release 可累加 state</td>
</tr>
<tr>
<td><strong>语义</strong></td>
<td>“线程是否可以继续执行”</td>
<td>“锁的状态/资源的数量”</td>
</tr>
<tr>
<td><strong>管理者</strong></td>
<td>JVM（Parker 对象）</td>
<td>用户代码（AQS 子类）</td>
</tr>
</tbody>
</table>
<p><strong>具体示例：多次 unpark 不能多次唤醒 park</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;第一次 park&quot;</span>);<br>    LockSupport.park();  <span class="hljs-comment">// 消耗 permit，立即返回</span><br>    System.out.println(<span class="hljs-string">&quot;第一次 park 返回&quot;</span>);<br>    <br>    System.out.println(<span class="hljs-string">&quot;第二次 park&quot;</span>);<br>    LockSupport.park();  <span class="hljs-comment">// permit 已被消耗，阻塞！</span><br>    System.out.println(<span class="hljs-string">&quot;第二次 park 返回&quot;</span>);  <span class="hljs-comment">// 永远不会执行</span><br>&#125;);<br><br><span class="hljs-comment">// 在 worker 启动前，连续调用 3 次 unpark</span><br>LockSupport.unpark(worker);  <span class="hljs-comment">// permit: 0 → 1</span><br>LockSupport.unpark(worker);  <span class="hljs-comment">// permit: 1 → 1（不累加！）</span><br>LockSupport.unpark(worker);  <span class="hljs-comment">// permit: 1 → 1（不累加！）</span><br><br>worker.start();<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// 第一次 park</span><br><span class="hljs-comment">// 第一次 park 返回</span><br><span class="hljs-comment">// 第二次 park</span><br><span class="hljs-comment">// （阻塞，不会输出&quot;第二次 park 返回&quot;）</span><br></code></pre></td></tr></table></figure>
<p><strong>对比 Semaphore（基于 AQS state）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 连续 release 3 次，state 累加到 3</span><br>semaphore.release();  <span class="hljs-comment">// state: 0 → 1</span><br>semaphore.release();  <span class="hljs-comment">// state: 1 → 2</span><br>semaphore.release();  <span class="hljs-comment">// state: 2 → 3</span><br><br><span class="hljs-comment">// 可以连续 acquire 3 次而不阻塞</span><br>semaphore.acquire();  <span class="hljs-comment">// state: 3 → 2，立即返回</span><br>semaphore.acquire();  <span class="hljs-comment">// state: 2 → 1，立即返回</span><br>semaphore.acquire();  <span class="hljs-comment">// state: 1 → 0，立即返回</span><br>semaphore.acquire();  <span class="hljs-comment">// state: 0，阻塞</span><br></code></pre></td></tr></table></figure>
<p><strong>设计意图的差异：</strong></p>
<ul>
<li><strong>permit</strong>：解决&quot;唤醒丢失&quot;问题，确保 unpark 先于 park 时不会丢失信号。但它不是用来&quot;预支多次唤醒&quot;的。</li>
<li><strong>AQS state</strong>：表达&quot;资源数量&quot;或&quot;锁状态&quot;，支持可重入锁（state 表示重入次数）、信号量（state 表示可用许可数）等语义。</li>
</ul>
<p><strong>permit 机制解决的核心问题：竞态条件下的唤醒丢失</strong></p>
<p>传统的 <code>wait()</code>/<code>notify()</code> 存在一个经典问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A（等待方）</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-keyword">while</span> (!condition) &#123;<br>        lock.wait();  <span class="hljs-comment">// 必须在 synchronized 块内</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线程 B（唤醒方）</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    condition = <span class="hljs-literal">true</span>;<br>    lock.notify();  <span class="hljs-comment">// 必须在 synchronized 块内</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果线程 B 在线程 A 调用 <code>wait()</code> <strong>之前</strong>就调用了 <code>notify()</code>，这个唤醒信号就<strong>丢失</strong>了。线程 A 随后调用 <code>wait()</code> 会永远阻塞。</p>
<p><code>park</code>/<code>unpark</code> 的 permit 机制优雅地解决了这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 B 先执行</span><br>LockSupport.unpark(threadA);  <span class="hljs-comment">// permit = 1（即使 A 还没 park）</span><br><br><span class="hljs-comment">// 线程 A 后执行</span><br>LockSupport.park();           <span class="hljs-comment">// permit = 0，立即返回，不阻塞！</span><br></code></pre></td></tr></table></figure>
<p><strong>permit 的状态机：</strong></p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; NoPermit: 初始状态
    
    NoPermit: 无许可状态
    HasPermit: 有许可状态 (permit最多为1)
    Blocked: 阻塞状态 (线程进入dormant状态)
    
    NoPermit --&gt; HasPermit: unpark()
    NoPermit --&gt; Blocked: park()
    
    HasPermit --&gt; NoPermit: park()(立即返回)
    HasPermit --&gt; HasPermit: unpark()(幂等不累积)
    
    Blocked --&gt; NoPermit: unpark()(唤醒)
    Blocked --&gt; NoPermit: interrupt()(中断唤醒)
    Blocked --&gt; NoPermit: 虚假唤醒</code></pre>
<p><strong>为什么 JVM 使用 “dormant” 而非 “sleeping”？</strong></p>
<p>JVM 规范中使用 <strong>dormant</strong>（休眠/蛰伏）而非 <strong>sleeping</strong>（睡眠）来描述 <code>park()</code> 后的线程状态，这是一个精确的术语选择：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>含义</th>
<th>对应 API</th>
<th>唤醒方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Sleeping</strong></td>
<td>定时休眠，时间到自动醒来</td>
<td><code>Thread.sleep(millis)</code></td>
<td>时间到期、中断</td>
</tr>
<tr>
<td><strong>Dormant</strong></td>
<td>无限期蛰伏，必须被外部唤醒</td>
<td><code>LockSupport.park()</code></td>
<td><code>unpark()</code>、中断、虚假唤醒</td>
</tr>
</tbody>
</table>
<p><code>dormant</code> 强调的是：</p>
<ol>
<li><strong>无自主唤醒能力</strong>：线程不会因为时间流逝而自动醒来</li>
<li><strong>依赖外部干预</strong>：必须有其他线程调用 <code>unpark()</code> 或发送中断</li>
<li><strong>生物学隐喻</strong>：如同冬眠的动物，需要外部刺激才能苏醒</li>
</ol>
<p><strong>permit 使用不当的风险：无条件 park 的陷阱</strong></p>
<p>虽然 permit 机制解决了唤醒丢失问题，但使用不当仍会导致问题。考虑以下错误示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：无条件循环 park</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    LockSupport.park();<br>    doSomeWork();  <span class="hljs-comment">// 被唤醒后执行某些工作</span><br>    <span class="hljs-comment">// 然后无条件地再次 park</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个模式的问题在于 <strong>permit 的一次性消耗特性</strong>：</p>
<ol>
<li><strong>第一次循环</strong>：假设 <code>unpark()</code> 先于 <code>park()</code> 调用，permit 被设置为 1</li>
<li><strong><code>park()</code> 调用</strong>：发现 permit = 1，立即返回并将 permit 置为 0</li>
<li><strong>执行 <code>doSomeWork()</code></strong>：正常执行</li>
<li><strong>第二次循环</strong>：再次调用 <code>park()</code>，此时 permit = 0，线程真正阻塞</li>
<li><strong>问题</strong>：如果没有新的 <code>unpark()</code> 调用，线程将永远阻塞</li>
</ol>
<p>这不是活锁（活锁是线程一直运行但无法取得进展），而是<strong>意外阻塞</strong>——线程在不应该阻塞的时候被阻塞了。问题的根源是：<strong>permit 最多只能累积 1 个，一次 <code>unpark()</code> 只能抵消一次 <code>park()</code></strong>。</p>
<p><strong>正确的使用模式必须包含条件检查：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!condition) &#123;           <span class="hljs-comment">// 1. 检查条件</span><br>    LockSupport.park(blocker); <span class="hljs-comment">// 2. 条件不满足才 park</span><br>    <span class="hljs-comment">// 3. 被唤醒后回到循环开头重新检查条件</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个模式的关键在于：</p>
<ul>
<li><strong>条件检查在循环开头</strong>：即使因为虚假唤醒或 permit 提前消耗而从 <code>park()</code> 返回，也会重新检查条件</li>
<li><strong>条件满足时退出循环</strong>：不会无谓地再次 <code>park()</code></li>
<li><strong>条件不满足时才 <code>park()</code></strong>：确保每次 <code>park()</code> 都是有意义的等待</li>
</ul>
<p><strong>AQS 如何利用 permit 机制？</strong></p>
<p>AQS 在 <code>acquireQueued()</code> 方法中展示了 permit 的正确使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>        <span class="hljs-comment">// 1. 先尝试获取锁（条件检查）</span><br>        <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>            setHead(node);<br>            p.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> interrupted;<br>        &#125;<br>        <span class="hljs-comment">// 2. 获取失败才考虑 park</span><br>        <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>            parkAndCheckInterrupt())  <span class="hljs-comment">// 这里调用 park</span><br>            interrupted = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 3. 被唤醒后回到循环开头重新尝试获取锁</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>AQS 的设计确保了：</p>
<ul>
<li><strong>不会丢失唤醒</strong>：即使 <code>unpark</code> 先于 <code>park</code>，permit 会保证 <code>park</code> 立即返回</li>
<li><strong>不会无限阻塞</strong>：每次唤醒后都会重新检查获取锁的条件</li>
<li><strong>不会活锁</strong>：通过 <code>shouldParkAfterFailedAcquire</code> 确保只有在确实需要等待时才 park</li>
</ul>
<h3 id="blocker-参数：诊断与可观测性">blocker 参数：诊断与可观测性</h3>
<p>在深入实践之前，我们需要理解 <code>LockSupport.park(Object blocker)</code> 中的 blocker 参数。这是一个容易被忽视但对生产环境诊断至关重要的设计。</p>
<h4 id="blocker-的本质">blocker 的本质</h4>
<p><strong>blocker 是一个纯粹用于诊断目的的标记对象</strong>，它告诉 JVM 和诊断工具&quot;这个线程为什么被阻塞了&quot;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread 类中的字段</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The argument supplied to the current call to</span><br><span class="hljs-comment">     * java.util.concurrent.locks.LockSupport.park.</span><br><span class="hljs-comment">     * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker</span><br><span class="hljs-comment">     * Accessed using java.util.concurrent.locks.LockSupport.getBlocker</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">volatile</span> Object parkBlocker;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="blocker-的关键特性">blocker 的关键特性</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>不参与锁逻辑</strong></td>
<td>blocker 纯粹是一个&quot;标签&quot;，不影响 park/unpark 的行为</td>
</tr>
<tr>
<td><strong>不记录锁状态</strong></td>
<td>它不知道锁被持有了多少次、有多少线程在等待</td>
</tr>
<tr>
<td><strong>可传 null</strong></td>
<td>即使传 null，park 也能正常工作</td>
</tr>
<tr>
<td><strong>唯一作用是可观测性</strong></td>
<td>让 <code>jstack</code>、JFR 等工具能显示线程在等待什么</td>
</tr>
</tbody>
</table>
<h4 id="在-jstack-中的体现">在 jstack 中的体现</h4>
<p>当使用 <code>jstack</code> 查看线程状态时，blocker 参数会显示在输出中：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-string">&quot;Thread-1&quot;</span> #<span class="hljs-number">12</span> prio=<span class="hljs-number">5</span> os_prio=<span class="hljs-number">0</span> tid=<span class="hljs-number">0</span>x00007f... nid=<span class="hljs-number">0</span>x... waiting on condition<br>   java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.State</span>: WAITING (parking)<br>        at sun<span class="hljs-selector-class">.misc</span><span class="hljs-selector-class">.Unsafe</span><span class="hljs-selector-class">.park</span>(Native Method)<br>        - parking to wait <span class="hljs-keyword">for</span>  &lt;<span class="hljs-number">0</span>x000000076b4a8f90&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.LockSupport</span><span class="hljs-selector-class">.park</span>(LockSupport<span class="hljs-selector-class">.java</span>:<span class="hljs-number">175</span>)<br>        ...<br></code></pre></td></tr></table></figure>
<p>其中 <code>parking to wait for &lt;0x000000076b4a8f90&gt;</code> 就是 blocker 对象的信息。</p>
<h4 id="blocker-的生命周期">blocker 的生命周期</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LockSupport.park(Object blocker) 的实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    setBlocker(t, blocker);  <span class="hljs-comment">// 1. 设置 blocker</span><br>    UNSAFE.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);  <span class="hljs-comment">// 2. 阻塞</span><br>    setBlocker(t, <span class="hljs-literal">null</span>);     <span class="hljs-comment">// 3. 清除 blocker</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个&quot;设置 → 阻塞 → 清除&quot;的三段式确保了：</p>
<ul>
<li>阻塞期间，诊断工具可以看到 blocker</li>
<li>唤醒后，blocker 被清除，不会造成内存泄漏</li>
</ul>
<h3 id="脱离-aqs-直接使用-park-unpark-实现线程协调">脱离 AQS 直接使用 park/unpark 实现线程协调</h3>
<p>如果不依赖 AQS，仅使用 <code>park</code>/<code>unpark</code> 原语实现简单的线程阻塞与唤醒，需要解决一个核心问题：<strong>唤醒方如何获得被阻塞线程的引用？</strong></p>
<p><strong>基本模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 共享的线程引用——唤醒方需要知道要唤醒谁</span><br><span class="hljs-keyword">volatile</span> Thread waitingThread;<br><br><span class="hljs-comment">// 等待方（线程 A）</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">waiter</span><span class="hljs-params">()</span> &#123;<br>    waitingThread = Thread.currentThread();  <span class="hljs-comment">// 1. 发布自己的引用</span><br>    <span class="hljs-keyword">while</span> (!condition) &#123;                      <span class="hljs-comment">// 2. 检查条件</span><br>        LockSupport.park(<span class="hljs-built_in">this</span>);               <span class="hljs-comment">// 3. 阻塞（blocker 可选）</span><br>    &#125;<br>    waitingThread = <span class="hljs-literal">null</span>;                     <span class="hljs-comment">// 4. 清理引用</span><br>&#125;<br><br><span class="hljs-comment">// 唤醒方（线程 B）</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">signaler</span><span class="hljs-params">()</span> &#123;<br>    condition = <span class="hljs-literal">true</span>;                         <span class="hljs-comment">// 1. 设置条件</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> waitingThread;                 <span class="hljs-comment">// 2. 获取等待线程引用</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>        LockSupport.unpark(t);                <span class="hljs-comment">// 3. 唤醒指定线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="从零构建：基于-cas-park-unpark-的简易互斥锁">从零构建：基于 CAS + park/unpark 的简易互斥锁</h4>
<p>下面展示如何仅使用 <code>Unsafe.compareAndSwapInt</code>（CAS）和 <code>LockSupport.park/unpark</code> 构建一个可工作的互斥锁，不依赖 AQS 的队列机制。</p>
<p><strong>设计目标：</strong></p>
<ul>
<li>互斥性：同一时刻只有一个线程持有锁</li>
<li>可重入性：同一线程可以多次获取锁</li>
<li>阻塞等待：获取失败的线程阻塞而非忙等</li>
</ul>
<p><strong>Version 1：最简单的自旋锁（无 park）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> Thread owner;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-comment">// 自旋直到获取成功</span><br>        <span class="hljs-keyword">while</span> (!state.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-comment">// 忙等待，消耗 CPU</span><br>        &#125;<br>        owner = current;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        owner = <span class="hljs-literal">null</span>;<br>        state.set(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>问题</strong>：纯自旋在高竞争下会浪费大量 CPU 时间。</p>
<p><strong>Version 2：自旋 + park 的混合锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinParkLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNLOCKED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LOCKED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(UNLOCKED);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread owner;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread waiter;  <span class="hljs-comment">// 简化：只支持一个等待者</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <br>        <span class="hljs-comment">// 阶段1：快速路径——尝试直接 CAS 获取</span><br>        <span class="hljs-keyword">if</span> (state.compareAndSet(UNLOCKED, LOCKED)) &#123;<br>            owner = current;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 阶段2：自旋若干次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (state.compareAndSet(UNLOCKED, LOCKED)) &#123;<br>                owner = current;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            Thread.onSpinWait();  <span class="hljs-comment">// JDK 9+ 的自旋提示</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// 阶段3：自旋失败，准备阻塞</span><br>        waiter = current;  <span class="hljs-comment">// 发布自己的引用，让 unlock 知道要唤醒谁</span><br>        <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 再次尝试获取（可能在我们设置 waiter 时锁已释放）</span><br>            <span class="hljs-keyword">if</span> (state.compareAndSet(UNLOCKED, LOCKED)) &#123;<br>                owner = current;<br>                waiter = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 获取失败，阻塞等待</span><br>            LockSupport.park(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-comment">// 被唤醒后回到循环开头重新尝试</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        owner = <span class="hljs-literal">null</span>;<br>        state.set(UNLOCKED);<br>        <br>        <span class="hljs-comment">// 唤醒等待者</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> waiter;<br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>) &#123;<br>            LockSupport.unpark(w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Version 3：支持可重入的完整实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantSpinParkLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNLOCKED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(UNLOCKED);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread owner;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread waiter;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SPIN_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <br>        <span class="hljs-comment">// 可重入检查：如果当前线程已持有锁，直接增加计数</span><br>        <span class="hljs-keyword">if</span> (owner == current) &#123;<br>            state.incrementAndGet();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 快速路径</span><br>        <span class="hljs-keyword">if</span> (state.compareAndSet(UNLOCKED, <span class="hljs-number">1</span>)) &#123;<br>            owner = current;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 自旋阶段</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; SPIN_COUNT; i++) &#123;<br>            <span class="hljs-keyword">if</span> (state.compareAndSet(UNLOCKED, <span class="hljs-number">1</span>)) &#123;<br>                owner = current;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            Thread.onSpinWait();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 阻塞阶段</span><br>        waiter = current;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (state.compareAndSet(UNLOCKED, <span class="hljs-number">1</span>)) &#123;<br>                owner = current;<br>                waiter = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            LockSupport.park(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (owner != Thread.currentThread()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">newState</span> <span class="hljs-operator">=</span> state.decrementAndGet();<br>        <span class="hljs-keyword">if</span> (newState == <span class="hljs-number">0</span>) &#123;<br>            owner = <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> waiter;<br>            <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>) &#123;<br>                LockSupport.unpark(w);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldByCurrentThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> owner == Thread.currentThread();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>时序图：两个线程竞争锁</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 1
    participant Lock as SpinParkLock
    participant T2 as 线程 2
    
    Note over T1: 获取锁
    T1-&gt;&gt;Lock: CAS(0→1) 成功
    T1-&gt;&gt;Lock: owner = T1
    
    Note over T2: 尝试获取锁
    T2-&gt;&gt;Lock: CAS(0→1) 失败
    T2-&gt;&gt;Lock: 自旋 64 次...
    T2-&gt;&gt;Lock: 仍然失败
    T2-&gt;&gt;Lock: waiter = T2
    T2-&gt;&gt;Lock: CAS(0→1) 再次失败
    T2-&gt;&gt;T2: park(lock)&lt;br/&gt;阻塞
    
    Note over T1: 释放锁
    T1-&gt;&gt;Lock: owner = null
    T1-&gt;&gt;Lock: state = 0
    T1-&gt;&gt;Lock: 读取 waiter = T2
    T1-&gt;&gt;T2: unpark(T2)
    
    Note over T2: 被唤醒
    T2-&gt;&gt;Lock: CAS(0→1) 成功
    T2-&gt;&gt;Lock: owner = T2
    T2-&gt;&gt;Lock: waiter = null</code></pre>
<p><strong>这个简易锁的局限性：</strong></p>
<table>
<thead>
<tr>
<th>局限</th>
<th>原因</th>
<th>AQS 的解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>只支持一个等待者</strong></td>
<td><code>waiter</code> 是单个引用</td>
<td>CLH 队列支持任意数量的等待者</td>
</tr>
<tr>
<td><strong>不保证公平性</strong></td>
<td>新来的线程可能抢先获取锁</td>
<td>公平模式下按队列顺序唤醒</td>
</tr>
<tr>
<td><strong>无超时支持</strong></td>
<td><code>park()</code> 无限等待</td>
<td><code>parkNanos()</code> 支持超时</td>
</tr>
<tr>
<td><strong>无中断响应</strong></td>
<td>被中断后继续尝试获取</td>
<td><code>lockInterruptibly()</code> 响应中断</td>
</tr>
<tr>
<td><strong>无条件变量</strong></td>
<td>不支持 <code>await()</code>/<code>signal()</code></td>
<td><code>ConditionObject</code> 提供完整支持</td>
</tr>
</tbody>
</table>
<p><strong>为什么需要 volatile？</strong></p>
<p>在上述实现中，<code>owner</code> 和 <code>waiter</code> 都声明为 <code>volatile</code>，原因如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> Thread owner;   <span class="hljs-comment">// 必须 volatile</span><br><span class="hljs-keyword">volatile</span> Thread waiter;  <span class="hljs-comment">// 必须 volatile</span><br></code></pre></td></tr></table></figure>
<ol>
<li>
<p><strong><code>owner</code> 的可见性</strong>：<code>unlock()</code> 中设置 <code>owner = null</code> 必须对其他线程立即可见，否则可重入检查 <code>owner == current</code> 可能读到过期值。</p>
</li>
<li>
<p><strong><code>waiter</code> 的可见性</strong>：<code>lock()</code> 中设置 <code>waiter = current</code> 必须对 <code>unlock()</code> 线程可见，否则 <code>unlock()</code> 可能读到 <code>null</code> 而不唤醒等待者。</p>
</li>
<li>
<p><strong>与 CAS 的配合</strong>：虽然 <code>AtomicInteger.compareAndSet</code> 本身有内存屏障效果，但 <code>owner</code> 和 <code>waiter</code> 的读写发生在 CAS 之外，需要 <code>volatile</code> 保证顺序。</p>
</li>
</ol>
<p><strong>不使用 volatile 的替代方案：</strong></p>
<p>如果想避免 <code>volatile</code>，可以将所有状态打包到一个原子变量中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackedLock</span> &#123;<br>    <span class="hljs-comment">// 高 32 位：owner 线程的 hashCode（简化标识）</span><br>    <span class="hljs-comment">// 低 32 位：重入计数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// 但 waiter 仍然需要单独存储...</span><br>    <span class="hljs-comment">// 这就是为什么 AQS 使用 Node 队列的原因</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>结论</strong>：直接使用 <code>park</code>/<code>unpark</code> 构建锁是可行的，但一旦需要支持多等待者、公平性、超时、中断等特性，复杂度会急剧上升。AQS 的价值在于提供了一个经过充分测试的、功能完备的框架，让开发者只需实现 <code>tryAcquire</code>/<code>tryRelease</code> 即可获得完整的锁语义。</p>
<p><strong>必须处理的边界情况：</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>问题</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>unpark 先于 park</strong></td>
<td>线程 B 在线程 A 调用 park 前就调用了 unpark</td>
<td><code>unpark</code> 会设置一个&quot;许可&quot;，后续的 <code>park</code> 会立即返回而不阻塞</td>
</tr>
</tbody>
</table>
<h4 id="locksupport-实战示例">LockSupport 实战示例</h4>
<p>以下示例展示 <code>LockSupport</code> 的核心特性，帮助理解 permit 机制的实际行为。</p>
<p><strong>示例 1：park/unpark 与 wait/notify 的对比</strong></p>
<p>使用 <code>wait/notify</code> 实现线程协调需要 <code>synchronized</code> 块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// wait/notify 方式：必须在 synchronized 块内</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotifyExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (WaitNotifyExample.class) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Worker: 准备等待&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    WaitNotifyExample.class.wait();  <span class="hljs-comment">// 必须持有监视器锁</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;Worker: 被唤醒，继续执行&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <br>        worker.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);  <span class="hljs-comment">// 确保 worker 先进入 wait</span><br>        <br>        <span class="hljs-keyword">synchronized</span> (WaitNotifyExample.class) &#123;<br>            WaitNotifyExample.class.notify();  <span class="hljs-comment">// 必须持有监视器锁</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用 <code>LockSupport</code> 则无需 <code>synchronized</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// park/unpark 方式：无需 synchronized</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Thread workerThread;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        workerThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Worker: 准备阻塞&quot;</span>);<br>            LockSupport.park();  <span class="hljs-comment">// 无需持有任何锁</span><br>            System.out.println(<span class="hljs-string">&quot;Worker: 被唤醒，继续执行&quot;</span>);<br>        &#125;);<br>        <br>        workerThread.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <br>        LockSupport.unpark(workerThread);  <span class="hljs-comment">// 精确唤醒指定线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键区别</strong>：</p>
<ul>
<li><code>wait()</code> 必须在 <code>synchronized</code> 块内调用，否则抛出 <code>IllegalMonitorStateException</code></li>
<li><code>park()</code> 可以在任何地方调用，无需持有任何锁</li>
<li><code>notify()</code> 随机唤醒一个等待线程，<code>unpark(thread)</code> 精确唤醒指定线程</li>
</ul>
<p><strong>示例 2：unpark 可以先于 park 调用</strong></p>
<p>这是 permit 机制最重要的特性——解决了 <code>wait/notify</code> 的时序问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnparkBeforePark</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <br>        <span class="hljs-comment">// 先 unpark（发放许可）</span><br>        LockSupport.unpark(current);<br>        System.out.println(<span class="hljs-string">&quot;已发放许可&quot;</span>);<br>        <br>        <span class="hljs-comment">// 后 park（消费许可）——立即返回，不阻塞</span><br>        LockSupport.park();<br>        System.out.println(<span class="hljs-string">&quot;park 立即返回，未阻塞&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// 已发放许可</span><br><span class="hljs-comment">// park 立即返回，未阻塞</span><br></code></pre></td></tr></table></figure>
<p>这个特性在生产者-消费者模型中非常有用：生产者可能先于消费者准备好，此时 <code>unpark</code> 发放的许可会被保留，消费者随后调用 <code>park</code> 时立即返回。</p>
<p><strong>示例 3：permit 不可累积（二元信号量语义）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PermitNotAccumulate</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <br>        <span class="hljs-comment">// 连续三次 unpark</span><br>        LockSupport.unpark(current);<br>        LockSupport.unpark(current);<br>        LockSupport.unpark(current);<br>        <span class="hljs-comment">// permit 仍然只有 1 个，不会累积到 3</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>        LockSupport.park();   <span class="hljs-comment">// 消费唯一的 permit，立即返回</span><br>        System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>        LockSupport.park();   <span class="hljs-comment">// 没有 permit 了，永久阻塞！</span><br>        System.out.println(<span class="hljs-string">&quot;c&quot;</span>);  <span class="hljs-comment">// 永远不会执行</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// b</span><br><span class="hljs-comment">// （程序阻塞，不会打印 c）</span><br></code></pre></td></tr></table></figure>
<p><strong>这就是为什么 permit 最多只能累积 1 个</strong>：<code>LockSupport</code> 设计为精确的一对一唤醒机制，而非通用的计数信号量。</p>
<p><strong>示例 4：park 响应中断但不抛出 InterruptedException</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkInterruptBehavior</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Worker: 准备 park&quot;</span>);<br>            LockSupport.park();<br>            <span class="hljs-comment">// park 被中断后返回，但不抛出异常</span><br>            System.out.println(<span class="hljs-string">&quot;Worker: park 返回，中断状态 = &quot;</span> <br>                + Thread.currentThread().isInterrupted());<br>        &#125;);<br>        <br>        worker.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <br>        worker.interrupt();  <span class="hljs-comment">// 中断 worker 线程</span><br>        worker.join();<br>        System.out.println(<span class="hljs-string">&quot;Main: 结束&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Worker: 准备 park</span><br><span class="hljs-comment">// Worker: park 返回，中断状态 = true</span><br><span class="hljs-comment">// Main: 结束</span><br></code></pre></td></tr></table></figure>
<p><strong>关键行为</strong>：</p>
<ul>
<li><code>park()</code> 会响应中断——被中断后立即返回</li>
<li>但 <code>park()</code> <strong>不会抛出 <code>InterruptedException</code></strong></li>
<li>中断状态被<strong>保留</strong>（<code>isInterrupted()</code> 返回 <code>true</code>）</li>
<li>这与 <code>wait()</code>、<code>sleep()</code> 不同，后者会抛出异常并<strong>清除</strong>中断状态</li>
</ul>
<p><strong>这就是为什么 AQS 中的 <code>parkAndCheckInterrupt()</code> 要检查中断状态：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS 中的实现</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();  <span class="hljs-comment">// 检查并清除中断状态</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>示例 5：blocker 参数的诊断价值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockerDiagnostics</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">BLOCKER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyCustomBlocker&quot;</span>;<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            LockSupport.park(BLOCKER);  <span class="hljs-comment">// 传入 blocker 对象</span><br>        &#125;, <span class="hljs-string">&quot;WorkerThread&quot;</span>);<br>        <br>        worker.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <br>        <span class="hljs-comment">// 获取 blocker 信息（用于诊断）</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">blocker</span> <span class="hljs-operator">=</span> LockSupport.getBlocker(worker);<br>        System.out.println(<span class="hljs-string">&quot;Worker 的 blocker: &quot;</span> + blocker);<br>        <br>        LockSupport.unpark(worker);<br>        worker.join();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Worker 的 blocker: MyCustomBlocker</span><br></code></pre></td></tr></table></figure>
<p>在 <code>jstack</code> 输出中，blocker 信息会显示为：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-string">&quot;WorkerThread&quot;</span> #12 <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">os_prio</span>=0 <span class="hljs-attribute">tid</span>=0x... <span class="hljs-attribute">nid</span>=0x... waiting on condition<br>   java.lang.Thread.State: WAITING (parking)<br>        at sun.misc.Unsafe.park(Native Method)<br>        - parking <span class="hljs-keyword">to</span> wait <span class="hljs-keyword">for</span>  &lt;0x<span class="hljs-built_in">..</span>.&gt; (a MyCustomBlocker)<br></code></pre></td></tr></table></figure>
<p>| <strong>虚假唤醒</strong> | park 可能在没有 unpark 的情况下返回 | 必须在循环中检查条件：<code>while (!condition) park()</code> |</p>
<h4 id="hotspot-源码解析：parker-类如何实现-permit-语义">HotSpot 源码解析：Parker 类如何实现 permit 语义</h4>
<p><code>LockSupport.park()</code> 和 <code>unpark()</code> 最终调用的是 <code>Unsafe.park()</code> 和 <code>Unsafe.unpark()</code>，而这两个 native 方法在 HotSpot 中由 <code>Parker</code> 类实现。理解 <code>Parker</code> 的实现是理解 permit 机制的关键。</p>
<p><strong>Parker 类的核心结构（Linux 平台）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// hotspot/src/os/posix/os_posix.hpp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PlatformParker</span> : <span class="hljs-keyword">public</span> CHeapObj&lt;mtInternal&gt; &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">pthread_mutex_t</span> _mutex[<span class="hljs-number">1</span>];    <span class="hljs-comment">// POSIX 互斥量</span><br>    <span class="hljs-type">pthread_cond_t</span>  _cond[<span class="hljs-number">1</span>];     <span class="hljs-comment">// POSIX 条件变量</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// hotspot/src/share/runtime/park.hpp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parker</span> : <span class="hljs-keyword">public</span> os::PlatformParker &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> _counter;  <span class="hljs-comment">// 核心：permit 计数器（0 或 1）</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">park</span><span class="hljs-params">(<span class="hljs-type">bool</span> isAbsolute, jlong time)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>关键字段 <code>_counter</code> 的语义：</strong></p>
<ul>
<li><code>_counter == 0</code>：没有可用的 permit，<code>park()</code> 将阻塞</li>
<li><code>_counter == 1</code>：有一个可用的 permit，<code>park()</code> 将立即返回并消费它</li>
</ul>
<p><strong><code>Parker::park()</code> 的核心实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parker::park</span><span class="hljs-params">(<span class="hljs-type">bool</span> isAbsolute, jlong time)</span> </span>&#123;<br>    <span class="hljs-comment">// 快速路径：尝试原子地消费 permit</span><br>    <span class="hljs-comment">// 如果 _counter &gt; 0，将其设为 0 并立即返回</span><br>    <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">xchg</span>(<span class="hljs-number">0</span>, &amp;_counter) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 慢速路径：需要阻塞等待</span><br>    Thread* thread = Thread::<span class="hljs-built_in">current</span>();<br>    <br>    <span class="hljs-comment">// 获取互斥锁</span><br>    <span class="hljs-type">int</span> status = <span class="hljs-built_in">pthread_mutex_lock</span>(_mutex);<br>    <br>    <span class="hljs-comment">// 双重检查：在持有锁的情况下再次检查 _counter</span><br>    <span class="hljs-comment">// 这是为了处理在获取锁之前 unpark 被调用的情况</span><br>    <span class="hljs-keyword">if</span> (_counter &gt; <span class="hljs-number">0</span>) &#123;<br>        _counter = <span class="hljs-number">0</span>;<br>        status = <span class="hljs-built_in">pthread_mutex_unlock</span>(_mutex);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 真正的阻塞等待</span><br>    <span class="hljs-keyword">if</span> (time == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 无限等待</span><br>        status = <span class="hljs-built_in">pthread_cond_wait</span>(_cond, _mutex);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 带超时的等待</span><br>        status = <span class="hljs-built_in">pthread_cond_timedwait</span>(_cond, _mutex, &amp;absTime);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 被唤醒后，消费 permit 并释放锁</span><br>    _counter = <span class="hljs-number">0</span>;<br>    status = <span class="hljs-built_in">pthread_mutex_unlock</span>(_mutex);<br>    <br>    <span class="hljs-comment">// 内存屏障，确保可见性</span><br>    OrderAccess::<span class="hljs-built_in">fence</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong><code>Parker::unpark()</code> 的核心实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parker::unpark</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> status = <span class="hljs-built_in">pthread_mutex_lock</span>(_mutex);<br>    <br>    <span class="hljs-type">int</span> s = _counter;<br>    _counter = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 发放 permit（无论之前是 0 还是 1）</span><br>    <br>    <span class="hljs-comment">// 只有当之前没有 permit 时才需要唤醒</span><br>    <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 唤醒在 pthread_cond_wait 上阻塞的线程</span><br>        status = <span class="hljs-built_in">pthread_cond_signal</span>(_cond);<br>    &#125;<br>    <br>    status = <span class="hljs-built_in">pthread_mutex_unlock</span>(_mutex);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>permit 语义的实现要点：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 A (parker)
    participant Counter as _counter
    participant T2 as 线程 B (unparker)
    
    Note over Counter: 初始值 = 0
    
    alt 场景1：park 先于 unpark
        T1-&gt;&gt;Counter: Atomic::xchg(0, &amp;_counter)
        Note over Counter: 返回 0，需要阻塞
        T1-&gt;&gt;T1: pthread_cond_wait() 阻塞
        T2-&gt;&gt;Counter: _counter = 1
        T2-&gt;&gt;T1: pthread_cond_signal()
        T1-&gt;&gt;Counter: _counter = 0（消费 permit）
        Note over T1: park() 返回
    end
    
    alt 场景2：unpark 先于 park
        T2-&gt;&gt;Counter: _counter = 1
        Note over Counter: permit 已发放
        T1-&gt;&gt;Counter: Atomic::xchg(0, &amp;_counter)
        Note over Counter: 返回 1，立即消费
        Note over T1: park() 立即返回，不阻塞
    end
    
    alt 场景3：多次 unpark
        T2-&gt;&gt;Counter: _counter = 1
        T2-&gt;&gt;Counter: _counter = 1（幂等，仍为 1）
        T2-&gt;&gt;Counter: _counter = 1（幂等，仍为 1）
        T1-&gt;&gt;Counter: Atomic::xchg(0, &amp;_counter)
        Note over Counter: 返回 1，消费唯一的 permit
        T1-&gt;&gt;Counter: Atomic::xchg(0, &amp;_counter)
        Note over Counter: 返回 0，需要阻塞
        Note over T1: 第二次 park() 阻塞
    end</code></pre>
<p><strong>为什么使用 <code>Atomic::xchg</code> 而非简单的读取？</strong></p>
<p><code>Atomic::xchg(0, &amp;_counter)</code> 是一个原子交换操作，它同时完成两件事：</p>
<ol>
<li>读取 <code>_counter</code> 的当前值</li>
<li>将 <code>_counter</code> 设置为 0</li>
</ol>
<p>这个操作具有完整的内存屏障语义，确保：</p>
<ul>
<li>如果 permit 可用（<code>_counter == 1</code>），立即消费它并返回</li>
<li>如果 permit 不可用（<code>_counter == 0</code>），进入慢速路径</li>
</ul>
<p>使用原子操作而非普通读取是为了避免竞态条件：如果先读取再设置，可能在读取和设置之间被其他线程的 <code>unpark</code> 打断。</p>
<h4 id="虚假唤醒-spurious-wakeup-：为什么必须在循环中检查条件">虚假唤醒（Spurious Wakeup）：为什么必须在循环中检查条件</h4>
<p><code>park()</code> 可能在以下情况下返回，即使没有对应的 <code>unpark()</code> 调用：</p>
<ol>
<li><strong>POSIX 条件变量的虚假唤醒</strong>：<code>pthread_cond_wait()</code> 规范允许虚假唤醒</li>
<li><strong>中断</strong>：线程被 <code>interrupt()</code> 中断</li>
<li><strong>超时</strong>：使用 <code>parkNanos()</code> 或 <code>parkUntil()</code> 时超时返回</li>
</ol>
<p><strong>虚假唤醒的根本原因：</strong></p>
<p>POSIX 标准明确指出，<code>pthread_cond_wait()</code> 可能在没有对应 <code>pthread_cond_signal()</code> 的情况下返回。这是一个有意的设计决策，允许实现在某些情况下（如信号处理、多处理器同步）更高效地工作。</p>
<p><strong>错误的使用方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：不检查条件，假设 park 返回意味着条件满足</span><br>LockSupport.park();<br><span class="hljs-comment">// 直接执行后续逻辑，可能条件并未满足！</span><br>doSomething();<br></code></pre></td></tr></table></figure>
<p><strong>正确的使用方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正确示例：在循环中检查条件</span><br><span class="hljs-keyword">while</span> (!conditionSatisfied()) &#123;<br>    LockSupport.park(blocker);<br>    <span class="hljs-comment">// 被唤醒后回到循环开头，重新检查条件</span><br>    <span class="hljs-comment">// 如果是虚假唤醒，条件不满足，继续 park</span><br>    <span class="hljs-comment">// 如果是真正的唤醒，条件满足，退出循环</span><br>&#125;<br>doSomething();<br></code></pre></td></tr></table></figure>
<p><strong>AQS 中的正确模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.acquireQueued()</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;  <span class="hljs-comment">// 无限循环</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>        <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  <span class="hljs-comment">// 检查条件</span><br>            setHead(node);<br>            p.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> interrupted;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>            parkAndCheckInterrupt())  <span class="hljs-comment">// park 在循环内</span><br>            interrupted = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 被唤醒后回到循环开头，重新检查条件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>虚假唤醒与 permit 机制的关系：</strong></p>
<table>
<thead>
<tr>
<th>唤醒类型</th>
<th>permit 状态</th>
<th>条件检查结果</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>正常唤醒（unpark）</td>
<td>被消费</td>
<td>条件满足</td>
<td>退出循环，继续执行</td>
</tr>
<tr>
<td>虚假唤醒</td>
<td>未变化（仍为 0）</td>
<td>条件不满足</td>
<td>继续循环，再次 park</td>
</tr>
<tr>
<td>中断唤醒</td>
<td>未变化（仍为 0）</td>
<td>条件不满足</td>
<td>根据策略处理中断</td>
</tr>
</tbody>
</table>
<p><strong>关键理解</strong>：permit 机制解决的是&quot;唤醒丢失&quot;问题（unpark 先于 park），而循环检查解决的是&quot;虚假唤醒&quot;问题。两者相辅相成，缺一不可。</p>
<h4 id="超时等待的实现：reentrantlock-trylock-timeout-unit-原理">超时等待的实现：ReentrantLock.tryLock(timeout, unit) 原理</h4>
<p><code>tryLock(long timeout, TimeUnit unit)</code> 是 <code>ReentrantLock</code> 提供的带超时的锁获取方法，它基于 <code>LockSupport.parkNanos()</code> 实现。理解其实现原理有助于掌握超时等待的正确模式。</p>
<p><strong>tryLock 超时版本的使用场景：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomethingWithTimeout</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">acquired</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 尝试在 5 秒内获取锁</span><br>        acquired = lock.tryLock(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (acquired) &#123;<br>            <span class="hljs-comment">// 成功获取锁，执行临界区代码</span><br>            doCriticalWork();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 超时未获取到锁，执行降级逻辑</span><br>            handleTimeout();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt();<br>        handleInterruption();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (acquired) &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>AQS 中 tryAcquireNanos 的核心实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <br>    <span class="hljs-comment">// 先尝试快速获取，成功则直接返回</span><br>    <span class="hljs-keyword">return</span> tryAcquire(arg) ||<br>           doAcquireNanos(arg, nanosTimeout);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 计算截止时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>    <br>    <span class="hljs-comment">// 创建节点并加入队列</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>;<br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 成功获取锁</span><br>            &#125;<br>            <br>            <span class="hljs-comment">// 计算剩余等待时间</span><br>            nanosTimeout = deadline - System.nanoTime();<br>            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 超时，获取失败</span><br>            <br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                nanosTimeout &gt; spinForTimeoutThreshold)<br>                <span class="hljs-comment">// 使用 parkNanos 进行带超时的阻塞</span><br>                LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br>            <br>            <span class="hljs-comment">// 检查中断</span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>超时等待的时序图：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T as 线程
    participant AQS as AQS
    participant LS as LockSupport
    participant OS as 操作系统
    
    Note over T: tryLock(5, SECONDS)
    
    T-&gt;&gt;AQS: tryAcquireNanos(1, 5_000_000_000L)
    AQS-&gt;&gt;AQS: tryAcquire(1)
    Note over AQS: 快速路径失败
    
    AQS-&gt;&gt;AQS: doAcquireNanos()
    Note over AQS: deadline = now + 5s
    
    AQS-&gt;&gt;AQS: addWaiter(EXCLUSIVE)
    
    loop 自旋 + 超时检查
        AQS-&gt;&gt;AQS: tryAcquire(1)
        Note over AQS: 获取失败
        
        AQS-&gt;&gt;AQS: 计算 nanosTimeout
        
        alt nanosTimeout &lt;= 0
            Note over AQS: 超时！
            AQS--&gt;&gt;T: return false
        else nanosTimeout &gt; spinThreshold
            AQS-&gt;&gt;LS: parkNanos(this, nanosTimeout)
            LS-&gt;&gt;OS: pthread_cond_timedwait()
            Note over T: 阻塞等待&lt;br/&gt;最多 nanosTimeout 纳秒
            
            alt 被 unpark 唤醒
                OS--&gt;&gt;LS: 返回
                LS--&gt;&gt;AQS: 返回
                Note over AQS: 继续循环尝试获取
            else 超时返回
                OS--&gt;&gt;LS: 超时返回
                LS--&gt;&gt;AQS: 返回
                Note over AQS: 检查剩余时间
            end
        else nanosTimeout &lt;= spinThreshold
            Note over AQS: 剩余时间太短&lt;br/&gt;自旋而非 park
        end
    end</code></pre>
<p><strong>spinForTimeoutThreshold 的设计意图：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS 中的常量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">spinForTimeoutThreshold</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span>;  <span class="hljs-comment">// 1 微秒</span><br></code></pre></td></tr></table></figure>
<p>当剩余等待时间小于 1 微秒时，AQS 选择自旋而非调用 <code>parkNanos()</code>。原因是：</p>
<ol>
<li><strong>系统调用开销</strong>：<code>parkNanos()</code> 最终会调用操作系统的 <code>pthread_cond_timedwait()</code>，这是一个系统调用，开销约为几微秒</li>
<li><strong>精度问题</strong>：操作系统的定时器精度有限，极短的超时可能不准确</li>
<li><strong>性能权衡</strong>：对于极短的等待，自旋的 CPU 开销小于系统调用的开销</li>
</ol>
<p><strong>Condition.awaitNanos() 的类似实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConditionObject.awaitNanos()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;<br>            <span class="hljs-comment">// 超时，自己转移到同步队列</span><br>            transferAfterCancelledWait(node);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)<br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br>        <br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        nanosTimeout = deadline - System.nanoTime();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重新获取锁...</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <br>    <span class="hljs-comment">// 返回剩余时间（可能为负，表示超时）</span><br>    <span class="hljs-keyword">return</span> deadline - System.nanoTime();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>超时等待的返回值语义：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值类型</th>
<th>成功</th>
<th>超时</th>
<th>中断</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tryLock(timeout, unit)</code></td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>抛出 <code>InterruptedException</code></td>
</tr>
<tr>
<td><code>awaitNanos(nanos)</code></td>
<td><code>long</code></td>
<td>剩余时间 &gt; 0</td>
<td>剩余时间 ≤ 0</td>
<td>抛出 <code>InterruptedException</code></td>
</tr>
<tr>
<td><code>await(time, unit)</code></td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>抛出 <code>InterruptedException</code></td>
</tr>
<tr>
<td><code>awaitUntil(deadline)</code></td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>抛出 <code>InterruptedException</code></td>
</tr>
</tbody>
</table>
<p>| <strong>引用发布时机</strong> | 线程 A 发布引用后、park 前，线程 B 就调用了 unpark | 同上，许可机制保证不会丢失唤醒 |<br>
| <strong>多个等待者</strong> | 多个线程都在等待同一个条件 | 需要使用队列管理等待线程，这正是 AQS 所做的事情 |</p>
<p><strong>为什么 AQS 不直接暴露这些细节？</strong></p>
<p>AQS 封装了上述所有复杂性：</p>
<ol>
<li><strong>CLH 队列</strong>：管理多个等待线程的引用</li>
<li><strong>Node 节点</strong>：每个节点持有等待线程的引用（<code>Node.thread</code>）</li>
<li><strong>状态机</strong>：通过 <code>waitStatus</code> 管理节点状态，确保正确的唤醒顺序</li>
<li><strong>自旋 + park</strong>：在 park 前先自旋尝试，减少不必要的阻塞</li>
</ol>
<p>直接使用 <code>park</code>/<code>unpark</code> 虽然可行，但一旦涉及多线程竞争、公平性、可重入等需求，手工管理的复杂度会急剧上升。AQS 的价值正在于此。</p>
<h3 id="重要区分：blocker-与本文其他-记录对象-的本质区别">重要区分：blocker 与本文其他&quot;记录对象&quot;的本质区别</h3>
<p>在本文中，我们讨论了多种&quot;记录对象&quot;：锁对象、Lock Record、ObjectMonitor 等。<strong>blocker 与它们有本质的不同</strong>，这一点必须强调：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;参与锁逻辑的记录对象&quot;
        direction TB
        
        LR[&quot;Lock Record&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 存储 Displaced Mark Word&lt;br/&gt;• owner 指向锁对象&lt;br/&gt;• Mark Word 指向它表示持锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;删除它 = 锁逻辑崩溃&quot;]
        
        MON[&quot;ObjectMonitor&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• _owner 记录持锁线程&lt;br/&gt;• _EntryList 管理等待队列&lt;br/&gt;• _WaitSet 管理 wait 队列&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;删除它 = 锁逻辑崩溃&quot;]
        
        AQS_STATE[&quot;AQS.state&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 记录锁的持有状态&lt;br/&gt;• 0 = 无锁，&gt;0 = 已锁定&lt;br/&gt;• CAS 修改它 = 获取/释放锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;删除它 = 锁逻辑崩溃&quot;]
        
        style LR fill:#ffcdd2
        style MON fill:#ffcdd2
        style AQS_STATE fill:#ffcdd2
    end
    
    subgraph &quot;纯诊断用途的标记&quot;
        direction TB
        
        BLOCKER[&quot;Thread.parkBlocker&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 仅用于 jstack/JFR 显示&lt;br/&gt;• 不参与任何锁逻辑&lt;br/&gt;• 传 null 也能正常 park&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;删除它 = 锁照常工作&lt;br/&gt;   只是诊断信息丢失&quot;]
        
        style BLOCKER fill:#c8e6c9
    end</code></pre>
<p><strong>对比表：blocker vs 其他记录对象</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Lock Record / Monitor / AQS.state</th>
<th>Thread.parkBlocker</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>是否参与锁逻辑</strong></td>
<td>是，核心组成部分</td>
<td>否，完全不参与</td>
</tr>
<tr>
<td><strong>删除后果</strong></td>
<td>锁机制崩溃</td>
<td>锁照常工作，仅丢失诊断信息</td>
</tr>
<tr>
<td><strong>记录的信息</strong></td>
<td>持锁线程、等待队列、锁状态</td>
<td>“线程在等待什么”（纯标签）</td>
</tr>
<tr>
<td><strong>谁读取它</strong></td>
<td>JVM 锁实现代码</td>
<td>jstack、JFR 等诊断工具</td>
</tr>
<tr>
<td><strong>设置时机</strong></td>
<td>获取锁时</td>
<td>park() 前设置，unpark() 后清除</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>与锁的持有周期一致</td>
<td>仅在线程阻塞期间有效</td>
</tr>
</tbody>
</table>
<p><strong>一句话总结：blocker 是&quot;旁观者&quot;，不是&quot;参与者&quot;。</strong> 它就像一个便利贴，贴在线程上告诉诊断工具&quot;我在等什么&quot;，但撕掉这个便利贴，线程该怎么等还是怎么等。</p>
<h3 id="blocker-来自哪里？">blocker 来自哪里？</h3>
<p>blocker 的来源取决于调用 <code>LockSupport.park()</code> 的上下文。在 AQS 体系中，主要有两种来源：</p>
<p><strong>1. 在 Sync Queue（同步队列）中等待锁时：blocker = AQS 实例本身</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// this = AQS 子类实例（如 ReentrantLock.Sync）</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时 <code>this</code> 就是 <code>ReentrantLock</code> 内部的 <code>Sync</code> 对象（继承自 AQS）。</p>
<p><strong>2. 在 Condition Queue（条件队列）中等待条件时：blocker = ConditionObject 实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.ConditionObject.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// this = ConditionObject 实例</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时 <code>this</code> 是 <code>ConditionObject</code>，它是 AQS 的内部类。</p>
<h3 id="condition-await-与-signal-的完整时序图">Condition.await() 与 signal() 的完整时序图</h3>
<p><code>Condition</code> 的 <code>await()</code> 和 <code>signal()</code> 是基于 <code>LockSupport.park()</code> 和 <code>unpark()</code> 实现的。理解它们的交互时序是掌握条件变量的关键。</p>
<p><strong>完整时序图：await() 与 signal() 的协作</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant TA as 线程 A（等待者）
    participant Lock as ReentrantLock
    participant Sync as AQS.Sync
    participant Cond as ConditionObject
    participant CQ as 条件队列
    participant SQ as 同步队列
    participant TB as 线程 B（唤醒者）
    
    Note over TA,TB: 阶段1：线程 A 调用 await()
    
    TA-&gt;&gt;Lock: lock.lock()
    Lock-&gt;&gt;Sync: acquire(1)
    Note over Sync: 线程 A 获取锁成功
    
    TA-&gt;&gt;Cond: condition.await()
    Cond-&gt;&gt;Cond: addConditionWaiter()
    Note over Cond: 创建 Node(CONDITION)
    Cond-&gt;&gt;CQ: 加入条件队列尾部
    
    Cond-&gt;&gt;Sync: fullyRelease(node)
    Note over Sync: 完全释放锁&lt;br/&gt;savedState = state&lt;br/&gt;state = 0
    
    Note over TA: 进入等待循环
    
    loop while (!isOnSyncQueue(node))
        TA-&gt;&gt;TA: LockSupport.park(this)
        Note over TA: blocker = ConditionObject&lt;br/&gt;线程 A 阻塞在条件队列
    end
    
    Note over TA,TB: 阶段2：线程 B 调用 signal()
    
    TB-&gt;&gt;Lock: lock.lock()
    Lock-&gt;&gt;Sync: acquire(1)
    Note over Sync: 线程 B 获取锁成功
    
    TB-&gt;&gt;Cond: condition.signal()
    Cond-&gt;&gt;CQ: 取出 firstWaiter
    Cond-&gt;&gt;Cond: transferForSignal(node)
    
    Note over Cond: 1. CAS: waitStatus&lt;br/&gt;   CONDITION → 0
    Cond-&gt;&gt;SQ: enq(node)
    Note over SQ: 节点转移到同步队列
    
    Note over Cond: 2. 设置前驱节点&lt;br/&gt;   waitStatus = SIGNAL
    
    Cond-&gt;&gt;TA: LockSupport.unpark(node.thread)
    Note over TA: 线程 A 被唤醒
    
    TB-&gt;&gt;Lock: lock.unlock()
    Lock-&gt;&gt;Sync: release(1)
    Note over Sync: 线程 B 释放锁
    
    Note over TA,TB: 阶段3：线程 A 重新竞争锁
    
    Note over TA: park() 返回&lt;br/&gt;isOnSyncQueue = true&lt;br/&gt;退出等待循环
    
    TA-&gt;&gt;Sync: acquireQueued(node, savedState)
    
    loop 自旋获取锁
        TA-&gt;&gt;Sync: tryAcquire(savedState)
        alt 获取成功
            Note over TA: 恢复之前的锁状态
        else 获取失败
            TA-&gt;&gt;TA: LockSupport.park(this)
            Note over TA: blocker = Sync&lt;br/&gt;在同步队列中等待
        end
    end
    
    Note over TA: await() 返回&lt;br/&gt;线程 A 继续执行</code></pre>
<p><strong>关键状态转换：节点在两个队列间的迁移</strong></p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; HoldLock: lock.lock() 成功
    
    HoldLock: 持有锁
    HoldLock: await() 返回后继续执行临界区代码
    
    ConditionWait: 条件队列等待
    ConditionWait: Node.waitStatus = CONDITION (-2)
    ConditionWait: blocker = ConditionObject
    ConditionWait: 锁已释放
    
    SyncWait: 同步队列等待
    SyncWait: Node.waitStatus = 0 → SIGNAL
    SyncWait: blocker = Sync
    SyncWait: 等待重新获取锁
    
    HoldLock --&gt; ConditionWait: await() 调用
    ConditionWait --&gt; SyncWait: signal() 调用
    SyncWait --&gt; HoldLock: 获取锁成功
    HoldLock --&gt; [*]: lock.unlock()</code></pre>
<p><strong>blocker 的切换过程详解：</strong></p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>线程状态</th>
<th>所在队列</th>
<th>blocker 值</th>
<th>park 调用位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取锁成功</td>
<td>RUNNABLE</td>
<td>无</td>
<td>null</td>
<td>-</td>
</tr>
<tr>
<td>await() 阻塞</td>
<td>WAITING</td>
<td>条件队列</td>
<td>ConditionObject</td>
<td><code>ConditionObject.await()</code></td>
</tr>
<tr>
<td>signal() 唤醒</td>
<td>RUNNABLE</td>
<td>同步队列</td>
<td>null（短暂）</td>
<td>-</td>
</tr>
<tr>
<td>竞争锁失败</td>
<td>WAITING</td>
<td>同步队列</td>
<td>Sync</td>
<td><code>AQS.acquireQueued()</code></td>
</tr>
<tr>
<td>获取锁成功</td>
<td>RUNNABLE</td>
<td>无</td>
<td>null</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong>await() 的核心代码路径：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.ConditionObject</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <br>    <span class="hljs-comment">// 1. 创建节点，加入条件队列</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <br>    <span class="hljs-comment">// 2. 完全释放锁，保存之前的状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 3. 等待被转移到同步队列</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// blocker = ConditionObject</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 4. 重新获取锁（此时已在同步队列中）</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <br>    <span class="hljs-comment">// 5. 清理和中断处理</span><br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>)<br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>signal() 的核心代码路径：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.ConditionObject</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>        doSignal(first);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 从条件队列移除</span><br>        <span class="hljs-keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>            lastWaiter = <span class="hljs-literal">null</span>;<br>        first.nextWaiter = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;  <span class="hljs-comment">// 转移到同步队列</span><br>             (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// CAS 修改状态：CONDITION → 0</span><br>    <span class="hljs-keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 加入同步队列</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>    <br>    <span class="hljs-comment">// 设置前驱为 SIGNAL，或直接唤醒</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="aqs-中-park-unpark-的调用时机与状态变化">AQS 中 park/unpark 的调用时机与状态变化</h3>
<p>理解 AQS 何时调用 <code>park()</code> 和 <code>unpark()</code> 是理解 blocker 的关键。下面我们通过图解来说明 AQS 内部的调用时机、方法参数以及调用后的状态变化。</p>
<p><strong>图1：ReentrantLock.lock() 的 park 调用时机</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T as 线程B
    participant RL as ReentrantLock
    participant AQS as AQS_Sync
    participant LS as LockSupport
    participant TB as ThreadB
    
    Note over T,TB: 假设线程A已持有锁,线程B尝试获取
    
    T-&gt;&gt;RL: lock()
    RL-&gt;&gt;AQS: acquire(1)
    AQS-&gt;&gt;AQS: tryAcquire(1)
    Note over AQS: 返回false,锁被A持有
    
    AQS-&gt;&gt;AQS: addWaiter(Node.EXCLUSIVE)
    Note over AQS: 创建Node,加入同步队列
    
    AQS-&gt;&gt;AQS: acquireQueued(node, 1)
    
    rect rgb(255, 245, 238)
        Note over AQS: 自旋尝试阶段
        AQS-&gt;&gt;AQS: tryAcquire(1)
        Note over AQS: 返回false
        AQS-&gt;&gt;AQS: shouldParkAfterFailedAcquire()
        Note over AQS: 返回true,前驱节点状态正确
        
        AQS-&gt;&gt;AQS: parkAndCheckInterrupt()
        Note over AQS: 准备阻塞线程
        
        AQS-&gt;&gt;LS: park(this)
        Note over LS: blocker=AQS实例即ReentrantLock$Sync
        
        LS-&gt;&gt;TB: setBlocker(blocker)
        Note over TB: parkBlocker=Sync
        
        LS-&gt;&gt;TB: Unsafe.park()
        Note over TB: 线程B阻塞,jstack可见parking to wait for
    end</code></pre>
<p><strong>图2：ReentrantLock.unlock() 的 unpark 调用时机</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant TA as 线程 A（持锁者）
    participant RL as ReentrantLock
    participant AQS as AQS (Sync)
    participant LS as LockSupport
    participant TB as Thread B（等待者）
    
    Note over TA,TB: 线程 A 释放锁，唤醒等待的线程 B
    
    TA-&gt;&gt;RL: unlock()
    RL-&gt;&gt;AQS: release(1)
    AQS-&gt;&gt;AQS: tryRelease(1)
    Note over AQS: state: 1 → 0&lt;br/&gt;exclusiveOwnerThread: A → null
    
    AQS-&gt;&gt;AQS: unparkSuccessor(head)
    Note over AQS: 找到队列中第一个等待的节点
    
    AQS-&gt;&gt;LS: unpark(thread B)
    Note over LS: 参数是线程对象，不是 blocker
    
    LS-&gt;&gt;TB: Unsafe.unpark(thread B)
    Note over TB: 线程 B 被唤醒
    
    Note over TB: park() 返回
    TB-&gt;&gt;TB: setBlocker(null)
    Note over TB: parkBlocker = null&lt;br/&gt;（自动清除）
    
    TB-&gt;&gt;AQS: 继续 acquireQueued 循环
    AQS-&gt;&gt;AQS: tryAcquire(1)
    Note over AQS: 返回 true（锁已释放）&lt;br/&gt;state: 0 → 1&lt;br/&gt;exclusiveOwnerThread: null → B
    
    Note over TB: 线程 B 获取锁成功</code></pre>
<p><strong>图3：AQS 状态变化与 park/unpark 的关系</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;AQS 内部状态&quot;
        STATE[&quot;state 字段&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;0 = 无锁&lt;br/&gt;1 = 已锁定（非重入）&lt;br/&gt;n = 重入 n 次&quot;]
        
        OWNER[&quot;exclusiveOwnerThread&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;null = 无持有者&lt;br/&gt;Thread = 持锁线程&quot;]
        
        QUEUE[&quot;同步队列（简化）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;head → Node1 → Node2 → ...&lt;br/&gt;每个 Node 包含：&lt;br/&gt;• thread: 等待的线程&lt;br/&gt;• waitStatus: 节点状态&quot;]
        
        style STATE fill:#e1f5ff
        style OWNER fill:#e1f5ff
        style QUEUE fill:#fff9c4
    end
    
    subgraph &quot;park 调用时机&quot;
        PARK_WHEN[&quot;何时调用 park？&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;1. tryAcquire() 返回 false&lt;br/&gt;2. 前驱节点状态正确&lt;br/&gt;3. 调用 parkAndCheckInterrupt()&quot;]
        
        PARK_PARAMS[&quot;park 参数&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;LockSupport.park(this)&lt;br/&gt;• this = AQS 子类实例&lt;br/&gt;• 如 ReentrantLock$Sync&quot;]
        
        PARK_EFFECT[&quot;park 后状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 线程阻塞&lt;br/&gt;• parkBlocker = this&lt;br/&gt;• state 不变&lt;br/&gt;• 队列不变&quot;]
        
        style PARK_WHEN fill:#ffcdd2
        style PARK_PARAMS fill:#ffcdd2
        style PARK_EFFECT fill:#ffcdd2
    end
    
    subgraph &quot;unpark 调用时机&quot;
        UNPARK_WHEN[&quot;何时调用 unpark？&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;1. tryRelease() 返回 true&lt;br/&gt;2. 队列中有等待节点&lt;br/&gt;3. 调用 unparkSuccessor()&quot;]
        
        UNPARK_PARAMS[&quot;unpark 参数&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;LockSupport.unpark(thread)&lt;br/&gt;• thread = 等待线程&lt;br/&gt;• 注意：不是 blocker！&quot;]
        
        UNPARK_EFFECT[&quot;unpark 后状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 线程被唤醒&lt;br/&gt;• parkBlocker = null&lt;br/&gt;• 线程继续竞争锁&quot;]
        
        style UNPARK_WHEN fill:#c8e6c9
        style UNPARK_PARAMS fill:#c8e6c9
        style UNPARK_EFFECT fill:#c8e6c9
    end
    
    STATE --&gt; PARK_WHEN
    OWNER --&gt; PARK_WHEN
    QUEUE --&gt; UNPARK_WHEN
    PARK_WHEN --&gt; PARK_PARAMS
    PARK_PARAMS --&gt; PARK_EFFECT
    UNPARK_WHEN --&gt; UNPARK_PARAMS
    UNPARK_PARAMS --&gt; UNPARK_EFFECT</code></pre>
<p><strong>关键代码路径（简化）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ===== 获取锁路径 =====</span><br><br><span class="hljs-comment">// 1. ReentrantLock.lock()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 2. AQS.acquire()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;                    <span class="hljs-comment">// 尝试获取锁</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="hljs-comment">// 失败则入队等待</span><br>        selfInterrupt();<br>&#125;<br><br><span class="hljs-comment">// 3. AQS.acquireQueued() - 核心循环</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>        <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;    <span class="hljs-comment">// 前驱是 head 且获取成功</span><br>            setHead(node);<br>            <span class="hljs-keyword">return</span> interrupted;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>            parkAndCheckInterrupt())            <span class="hljs-comment">// &lt;-- 这里调用 park</span><br>            interrupted = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 4. AQS.parkAndCheckInterrupt() - park 调用点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// blocker = this (AQS 子类实例)</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br><br><span class="hljs-comment">// ===== 释放锁路径 =====</span><br><br><span class="hljs-comment">// 1. ReentrantLock.unlock()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 2. AQS.release()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;                     <span class="hljs-comment">// 尝试释放锁</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);                 <span class="hljs-comment">// &lt;-- 这里调用 unpark</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 3. AQS.unparkSuccessor() - unpark 调用点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;                        <span class="hljs-comment">// 找到后继节点</span><br>    <span class="hljs-comment">// ... 省略边界处理 ...</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        LockSupport.unpark(s.thread);          <span class="hljs-comment">// 参数是线程，不是 blocker</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>park 与 unpark 参数对比：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>参数含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LockSupport.park(Object blocker)</code></td>
<td>blocker</td>
<td>诊断标记，告诉工具&quot;线程在等什么&quot;</td>
<td><code>park(this)</code> → blocker = Sync</td>
</tr>
<tr>
<td><code>LockSupport.unpark(Thread thread)</code></td>
<td>thread</td>
<td>要唤醒的线程对象</td>
<td><code>unpark(node.thread)</code></td>
</tr>
</tbody>
</table>
<p><strong>注意：unpark 的参数是线程对象，不是 blocker！</strong> 这是因为 unpark 的目的是唤醒特定线程，而 blocker 只是诊断信息，唤醒时不需要。</p>
<p><strong>3. 其他场景的 blocker</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>blocker 是什么</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ReentrantLock.lock()</code></td>
<td><code>ReentrantLock$Sync</code></td>
<td>等待获取锁</td>
</tr>
<tr>
<td><code>Condition.await()</code></td>
<td><code>ConditionObject</code></td>
<td>等待条件满足</td>
</tr>
<tr>
<td><code>Semaphore.acquire()</code></td>
<td><code>Semaphore$Sync</code></td>
<td>等待许可</td>
</tr>
<tr>
<td><code>CountDownLatch.await()</code></td>
<td><code>CountDownLatch$Sync</code></td>
<td>等待计数归零</td>
</tr>
<tr>
<td><code>FutureTask.get()</code></td>
<td><code>FutureTask</code> 自身</td>
<td>等待任务完成</td>
</tr>
<tr>
<td><code>SynchronousQueue.take()</code></td>
<td><code>SynchronousQueue$TransferStack</code> 或 <code>TransferQueue</code></td>
<td>等待配对</td>
</tr>
</tbody>
</table>
<h3 id="选择-this-作为-blocker-的原因">选择 this 作为 blocker 的原因</h3>
<p>设计者选择 <code>this</code>（即当前的同步器对象）作为 blocker，有几个重要原因：</p>
<p><strong>1. 语义清晰</strong>：blocker 应该回答&quot;线程在等待什么&quot;，而 AQS 子类正是&quot;锁&quot;的抽象。当你看到 <code>parking to wait for &lt;0x000000076ab12345&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</code> 时，立刻就知道线程在等待一个非公平锁。</p>
<p><strong>2. 便于死锁检测</strong>：通过 blocker 可以构建&quot;线程 → 锁 → 持有者线程&quot;的等待链，这是死锁检测的基础。</p>
<p><strong>3. 与 synchronized 对称</strong>：synchronized 的重量级锁会将 <code>ObjectMonitor</code> 记录到线程的 <code>_current_pending_monitor</code> 字段，AQS 用 <code>parkBlocker</code> 实现了相同的功能。</p>
<h3 id="synchronized-与-park-底层机制的差异">synchronized 与 park 底层机制的差异</h3>
<p>synchronized 的重量级锁<strong>不使用</strong> <code>LockSupport.park()</code> 来阻塞线程。synchronized 和 AQS 在底层使用了完全不同的线程阻塞机制。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>synchronized（重量级锁）</th>
<th>AQS（ReentrantLock 等）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>阻塞机制</strong></td>
<td>OS 原生的 Mutex/Condition</td>
<td><code>LockSupport.park()/unpark()</code></td>
</tr>
<tr>
<td><strong>实现层次</strong></td>
<td>JVM C++ 层（<code>ObjectMonitor</code>）</td>
<td>Java 层 + <code>Unsafe.park()</code></td>
</tr>
<tr>
<td><strong>线程状态</strong></td>
<td><code>BLOCKED</code></td>
<td><code>WAITING</code> 或 <code>TIMED_WAITING</code></td>
</tr>
<tr>
<td><strong>可中断性</strong></td>
<td>不可中断（<code>monitorenter</code> 不响应中断）</td>
<td>可中断（<code>lockInterruptibly()</code>）</td>
</tr>
<tr>
<td><strong>诊断信息</strong></td>
<td><code>_current_pending_monitor</code>（C++ 层）</td>
<td><code>Thread.parkBlocker</code>（Java 层）</td>
</tr>
</tbody>
</table>
<p><strong>这种设计差异的原因：</strong></p>
<ol>
<li>
<p><strong>历史原因</strong>：synchronized 是 Java 1.0 就存在的语言特性，其实现深度嵌入 JVM 内部。当时 Java 还没有 <code>LockSupport</code>（JDK 1.5 才引入），只能依赖 OS 原生的同步原语。</p>
</li>
<li>
<p><strong>语义差异</strong>：synchronized 的 <code>monitorenter</code> 指令被设计为<strong>不可中断</strong>的阻塞操作。而 <code>LockSupport.park()</code> 天然支持中断，这使得 AQS 可以实现 <code>lockInterruptibly()</code> 等可中断的锁获取方式。</p>
</li>
<li>
<p><strong>性能优化空间</strong>：synchronized 的实现在 JVM 内部，可以做偏向锁、轻量级锁等深度优化。AQS 在 Java 层实现，虽然灵活性更高，但无法享受这些 JVM 级别的优化。</p>
</li>
</ol>
<p><strong>ObjectMonitor 的阻塞实现（简化）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// HotSpot ObjectMonitor::enter() 中的阻塞逻辑</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectMonitor::enter</span><span class="hljs-params">(TRAPS)</span> </span>&#123;<br>    <span class="hljs-comment">// ... 自旋尝试 ...</span><br>    <br>    <span class="hljs-comment">// 自旋失败，准备阻塞</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-built_in">EnterI</span>(THREAD);  <span class="hljs-comment">// 进入等待队列并阻塞</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectMonitor::EnterI</span><span class="hljs-params">(TRAPS)</span> </span>&#123;<br>    <span class="hljs-comment">// 将当前线程加入 _EntryList</span><br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-comment">// 使用 OS 原生的 park 机制阻塞线程</span><br>    <span class="hljs-comment">// 注意：这里调用的是 os::PlatformEvent::park()</span><br>    <span class="hljs-comment">// 而不是 LockSupport.park()</span><br>    Self-&gt;_ParkEvent-&gt;<span class="hljs-built_in">park</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键区别：</strong> <code>os::PlatformEvent::park()</code> 是 JVM 内部的 C++ 实现，直接调用操作系统的 <code>pthread_cond_wait()</code>（Linux）或 <code>WaitForSingleObject()</code>（Windows）。而 <code>LockSupport.park()</code> 虽然最终也会调用类似的系统调用，但它是通过 <code>Unsafe.park()</code> 暴露给 Java 层的，并且额外支持了 <code>blocker</code> 参数和中断响应。</p>
<h3 id="blocker-在锁竞争中的切换">blocker 在锁竞争中的切换</h3>
<p>以 <code>ReentrantLock</code> + <code>Condition</code> 场景为例，追踪 blocker 的变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br><span class="hljs-comment">// 线程 A</span><br>lock.lock();          <span class="hljs-comment">// 假设获取成功，不需要 park</span><br>condition.await();    <span class="hljs-comment">// 释放锁，进入条件队列，park</span><br><span class="hljs-comment">// ... 被 signal 唤醒后 ...</span><br><span class="hljs-comment">// 重新竞争锁，可能需要 park</span><br>lock.unlock();<br></code></pre></td></tr></table></figure>
<p><strong>blocker 的切换过程：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant ThreadA as 线程 A
    participant Sync as ReentrantLock.Sync
    participant Cond as ConditionObject
    participant PB as Thread.parkBlocker

    Note over ThreadA: 初始状态
    ThreadA-&gt;&gt;PB: parkBlocker = null
    
    Note over ThreadA: lock.lock() 成功
    ThreadA-&gt;&gt;PB: parkBlocker = null（无需 park）
    
    Note over ThreadA: condition.await() 开始
    ThreadA-&gt;&gt;Cond: 进入条件队列
    ThreadA-&gt;&gt;PB: setBlocker(ConditionObject)
    Note over PB: parkBlocker = ConditionObject
    ThreadA-&gt;&gt;ThreadA: park() 阻塞
    
    Note over ThreadA: 被 signal() 唤醒
    ThreadA-&gt;&gt;PB: setBlocker(null)
    Note over PB: parkBlocker = null
    ThreadA-&gt;&gt;Sync: 转移到同步队列，竞争锁
    
    Note over ThreadA: 竞争锁失败，需要 park
    ThreadA-&gt;&gt;PB: setBlocker(Sync)
    Note over PB: parkBlocker = Sync
    ThreadA-&gt;&gt;ThreadA: park() 阻塞
    
    Note over ThreadA: 获取锁成功
    ThreadA-&gt;&gt;PB: setBlocker(null)
    Note over PB: parkBlocker = null</code></pre>
<p><strong>关键观察：</strong></p>
<ol>
<li><strong>blocker 在 park 前设置，在 unpark 后清除</strong>：这是 <code>LockSupport.park(Object blocker)</code> 的标准模式</li>
<li><strong>blocker 会随着线程在不同队列间移动而切换</strong>：
<ul>
<li>在同步队列等待锁时：blocker = Sync</li>
<li>在条件队列等待条件时：blocker = ConditionObject</li>
</ul>
</li>
<li><strong>blocker 只在线程被阻塞时有意义</strong>：一旦线程被唤醒，blocker 立即被清除为 null</li>
</ol>
<p><strong>代码层面的切换逻辑：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LockSupport.park 的实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    setBlocker(t, blocker);  <span class="hljs-comment">// 1. park 前设置 blocker</span><br>    U.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);       <span class="hljs-comment">// 2. 真正阻塞</span><br>    setBlocker(t, <span class="hljs-literal">null</span>);     <span class="hljs-comment">// 3. 唤醒后清除 blocker</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个&quot;设置 → 阻塞 → 清除&quot;的三段式是理解 blocker 生命周期的关键。</p>
<h3 id="blocker-与-monitor-的对位关系">blocker 与 Monitor 的对位关系</h3>
<p>blocker 和 Monitor 在功能上是对位的，但实现层次不同。以下是精确的对比：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>synchronized (Monitor)</th>
<th>AQS (blocker)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>存储位置</strong></td>
<td><code>Thread._current_pending_monitor</code>（C++ 层）</td>
<td><code>Thread.parkBlocker</code>（Java 层）</td>
</tr>
<tr>
<td><strong>记录的对象</strong></td>
<td><code>ObjectMonitor*</code>（C++ 对象）</td>
<td>AQS 子类实例（Java 对象）</td>
</tr>
<tr>
<td><strong>设置时机</strong></td>
<td>进入 <code>_EntryList</code> 或 <code>_WaitSet</code> 时</td>
<td>调用 <code>LockSupport.park()</code> 前</td>
</tr>
<tr>
<td><strong>清除时机</strong></td>
<td>离开等待队列时</td>
<td><code>park()</code> 返回后立即清除</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>死锁检测、jstack 输出</td>
<td>死锁检测、jstack 输出</td>
</tr>
<tr>
<td><strong>是否参与锁逻辑</strong></td>
<td>否（纯诊断）</td>
<td>否（纯诊断）</td>
</tr>
</tbody>
</table>
<p><strong>它们的对位关系体现在：</strong></p>
<ol>
<li><strong>功能对位</strong>：都是为了回答&quot;这个线程在等待哪个锁&quot;</li>
<li><strong>诊断对位</strong>：<code>jstack</code> 对两者的输出格式类似：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// synchronized</span><br>- waiting to lock &lt;<span class="hljs-number">0</span>x000000076ab12345&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.lang</span>.Object)<br><br><span class="hljs-comment">// AQS</span><br>- parking to wait <span class="hljs-keyword">for</span> &lt;<span class="hljs-number">0</span>x000000076ab67890&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span>)<br></code></pre></td></tr></table></figure>
</li>
<li><strong>设计意图对位</strong>：都是为了在不影响锁性能的前提下，提供可观测性</li>
</ol>
<p><strong>但它们也有本质区别：</strong></p>
<ol>
<li><strong>层次不同</strong>：<code>_current_pending_monitor</code> 在 JVM 的 C++ 层，<code>parkBlocker</code> 在 Java 层</li>
<li><strong>生命周期不同</strong>：<code>_current_pending_monitor</code> 的生命周期由 JVM 管理，<code>parkBlocker</code> 由 <code>LockSupport</code> 显式管理</li>
<li><strong>灵活性不同</strong>：<code>parkBlocker</code> 可以是任意对象，而 <code>_current_pending_monitor</code> 只能是 <code>ObjectMonitor</code></li>
</ol>
<p><strong>图：Monitor 与 blocker 的对位关系</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;synchronized 的诊断信息流&quot;
        direction LR
        T1_SYNC[&quot;Thread（C++ JavaThread）&quot;]
        MON[&quot;ObjectMonitor&quot;]
        JSTACK1[&quot;jstack 输出&quot;]
        
        T1_SYNC --&gt;|&quot;_current_pending_monitor&quot;| MON
        MON --&gt;|&quot;读取&quot;| JSTACK1
    end
    
    subgraph &quot;AQS 的诊断信息流&quot;
        direction LR
        T1_AQS[&quot;Thread（Java Thread）&quot;]
        BLOCKER[&quot;AQS 子类实例&quot;]
        JSTACK2[&quot;jstack 输出&quot;]
        
        T1_AQS --&gt;|&quot;parkBlocker&quot;| BLOCKER
        BLOCKER --&gt;|&quot;读取&quot;| JSTACK2
    end
    
    JSTACK1 -.-&gt;|&quot;功能等价&quot;| JSTACK2</code></pre>
<h3 id="实战：通过-jstack-观察-blocker">实战：通过 jstack 观察 blocker</h3>
<p>以下是一个实际的 jstack 输出，展示 blocker 如何帮助诊断问题：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-string">&quot;Thread-1&quot;</span> #<span class="hljs-number">12</span> prio=<span class="hljs-number">5</span> os_prio=<span class="hljs-number">0</span> tid=<span class="hljs-number">0</span>x00007f8a1c0008c0 nid=<span class="hljs-number">0</span>x1234 waiting on condition <span class="hljs-selector-attr">[0x00007f8a1c000000]</span><br>   java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.State</span>: WAITING (parking)<br>        at sun<span class="hljs-selector-class">.misc</span><span class="hljs-selector-class">.Unsafe</span><span class="hljs-selector-class">.park</span>(Native Method)<br>        - parking to wait <span class="hljs-keyword">for</span>  &lt;<span class="hljs-number">0</span>x000000076ab67890&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.LockSupport</span><span class="hljs-selector-class">.park</span>(LockSupport<span class="hljs-selector-class">.java</span>:<span class="hljs-number">175</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.parkAndCheckInterrupt</span>(AbstractQueuedSynchronizer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">836</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquireQueued</span>(AbstractQueuedSynchronizer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">870</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquire</span>(AbstractQueuedSynchronizer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1199</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span><span class="hljs-selector-class">.lock</span>(ReentrantLock<span class="hljs-selector-class">.java</span>:<span class="hljs-number">209</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.ReentrantLock</span><span class="hljs-selector-class">.lock</span>(ReentrantLock<span class="hljs-selector-class">.java</span>:<span class="hljs-number">285</span>)<br>        at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyService</span><span class="hljs-selector-class">.doSomething</span>(MyService<span class="hljs-selector-class">.java</span>:<span class="hljs-number">42</span>)<br></code></pre></td></tr></table></figure>
<p>从这个输出中，我们可以读出：</p>
<ol>
<li><strong>线程状态</strong>：<code>WAITING (parking)</code> — 线程被 <code>LockSupport.park()</code> 阻塞</li>
<li><strong>blocker 对象</strong>：<code>&lt;0x000000076ab67890&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</code> — 线程在等待一个非公平锁</li>
<li><strong>调用栈</strong>：从 <code>MyService.doSomething</code> 到 <code>ReentrantLock.lock</code> 的完整路径</li>
</ol>
<p>如果同时有另一个线程持有这个锁：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-string">&quot;Thread-0&quot;</span> #<span class="hljs-number">11</span> prio=<span class="hljs-number">5</span> os_prio=<span class="hljs-number">0</span> tid=<span class="hljs-number">0</span>x00007f8a1c0007b0 nid=<span class="hljs-number">0</span>x1233 runnable <span class="hljs-selector-attr">[0x00007f8a1bfff000]</span><br>   java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.State</span>: RUNNABLE<br>        at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyService</span><span class="hljs-selector-class">.doSomethingElse</span>(MyService<span class="hljs-selector-class">.java</span>:<span class="hljs-number">55</span>)<br>        - locked &lt;<span class="hljs-number">0</span>x000000076ab67890&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span>)<br></code></pre></td></tr></table></figure>
<p>通过对比两个线程的 blocker 地址（<code>0x000000076ab67890</code>），我们可以确定 Thread-1 在等待 Thread-0 持有的锁。这就是 blocker 的诊断价值。</p>
<h3 id="小结：blocker-的设计哲学">小结：blocker 的设计哲学</h3>
<p><code>LockSupport.park(Object blocker)</code> 的 blocker 参数体现了一个重要的设计哲学：<strong>在不影响核心功能的前提下，提供最大化的可观测性</strong>。</p>
<ol>
<li><strong>零性能开销</strong>：blocker 只是一个引用赋值，不涉及任何同步操作</li>
<li><strong>完全可选</strong>：即使传 null，park 也能正常工作</li>
<li><strong>诊断友好</strong>：让 jstack、JFR 等工具能够准确报告线程的等待原因</li>
<li><strong>与 synchronized 对称</strong>：在 Java 层实现了与 JVM 层 <code>_current_pending_monitor</code> 相同的功能</li>
</ol>
<p>这种设计思想值得我们在自己的代码中借鉴：<strong>核心逻辑保持简洁，诊断信息作为可选的&quot;旁路&quot;提供</strong>。</p>
<h2 id="基于-aqs-的同步器实现">基于 AQS 的同步器实现</h2>
<p>有了对 AQS 的深入理解，现在让我们看看 JDK 中几个重要的同步器是如何基于 AQS 实现的。</p>
<h3 id="reentrantlock：可重入独占锁">ReentrantLock：可重入独占锁</h3>
<p><code>ReentrantLock</code> 是最常用的显式锁，它提供了与 <code>synchronized</code> 类似的互斥语义，但具有更丰富的功能。</p>
<h4 id="核心结构">核心结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br>    <br>    <span class="hljs-comment">// 抽象同步器</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-keyword">abstract</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">initialTryLock</span><span class="hljs-params">()</span>;<br>        <br>        <span class="hljs-comment">// 非公平尝试获取锁</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                    setExclusiveOwnerThread(current);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                setState(nextc);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 释放锁</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                free = <span class="hljs-literal">true</span>;<br>                setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            &#125;<br>            setState(c);<br>            <span class="hljs-keyword">return</span> free;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 非公平锁实现</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 公平锁实现</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Sync</span> &#123;<br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 关键区别：先检查队列</span><br>                <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                    compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                    setExclusiveOwnerThread(current);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                setState(nextc);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="state-的语义">state 的语义</h4>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;ReentrantLock 的 state 语义&quot;
        direction TB
        
        S0[&quot;state = 0&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;锁未被持有&quot;]
        S1[&quot;state = 1&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;锁被持有一次&quot;]
        SN[&quot;state = n&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;锁被重入 n 次&quot;]
        
        S0 --&gt;|&quot;lock()&quot;| S1
        S1 --&gt;|&quot;lock()（同一线程）&quot;| SN
        SN --&gt;|&quot;unlock()&quot;| S1
        S1 --&gt;|&quot;unlock()&quot;| S0
        
        style S0 fill:#c8e6c9
        style S1 fill:#fff9c4
        style SN fill:#ffcdd2
    end</code></pre>
<h4 id="reentrantlock-vs-synchronized">ReentrantLock vs synchronized</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>ReentrantLock</th>
<th>synchronized</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>实现层次</strong></td>
<td>Java 层（AQS）</td>
<td>JVM 层（ObjectMonitor）</td>
</tr>
<tr>
<td><strong>锁获取方式</strong></td>
<td>显式 lock()/unlock()</td>
<td>隐式（进入/退出同步块）</td>
</tr>
<tr>
<td><strong>公平性</strong></td>
<td>可选（构造函数参数）</td>
<td>非公平</td>
</tr>
<tr>
<td><strong>可中断</strong></td>
<td>lockInterruptibly()</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>超时获取</strong></td>
<td>tryLock(timeout)</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>条件变量</strong></td>
<td>多个 Condition</td>
<td>单个（wait/notify）</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>高竞争下更好</td>
<td>低竞争下更好（偏向锁优化）</td>
</tr>
</tbody>
</table>
<h4 id="condition-接口：显式锁的条件变量">Condition 接口：显式锁的条件变量</h4>
<p><code>Condition</code> 接口是 <code>Lock</code> 的配套接口，提供了比 <code>Object.wait()/notify()</code> 更灵活的线程等待/通知机制。</p>
<h5 id="condition-接口方法">Condition 接口方法</h5>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>await()</code></td>
<td>释放锁并等待，直到被 signal 或中断</td>
</tr>
<tr>
<td><code>awaitUninterruptibly()</code></td>
<td>不响应中断的等待</td>
</tr>
<tr>
<td><code>awaitNanos(long)</code></td>
<td>带超时的等待，返回剩余时间</td>
</tr>
<tr>
<td><code>awaitUntil(Date)</code></td>
<td>等待直到指定时间点</td>
</tr>
<tr>
<td><code>signal()</code></td>
<td>唤醒一个等待线程</td>
</tr>
<tr>
<td><code>signalAll()</code></td>
<td>唤醒所有等待线程</td>
</tr>
</tbody>
</table>
<h5 id="condition-vs-object-monitor">Condition vs Object Monitor</h5>
<table>
<thead>
<tr>
<th>特性</th>
<th>Condition</th>
<th>Object.wait/notify</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>绑定对象</strong></td>
<td>Lock</td>
<td>synchronized 对象</td>
</tr>
<tr>
<td><strong>条件队列数量</strong></td>
<td>多个（每个 Condition 一个）</td>
<td>单个</td>
</tr>
<tr>
<td><strong>等待方式</strong></td>
<td><code>await()</code></td>
<td><code>wait()</code></td>
</tr>
<tr>
<td><strong>唤醒方式</strong></td>
<td><code>signal()</code>/<code>signalAll()</code></td>
<td><code>notify()</code>/<code>notifyAll()</code></td>
</tr>
<tr>
<td><strong>超时等待</strong></td>
<td><code>awaitNanos()</code>、<code>awaitUntil()</code></td>
<td><code>wait(long)</code></td>
</tr>
<tr>
<td><strong>不响应中断</strong></td>
<td><code>awaitUninterruptibly()</code></td>
<td>不支持</td>
</tr>
</tbody>
</table>
<h5 id="使用示例：生产者-消费者">使用示例：生产者-消费者</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedBuffer</span>&lt;E&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span> <span class="hljs-operator">=</span> lock.newCondition();   <span class="hljs-comment">// 条件1：不满</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition();  <span class="hljs-comment">// 条件2：不空</span><br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> putIndex, takeIndex, count;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == items.length) &#123;<br>                notFull.await();  <span class="hljs-comment">// 满了，等待&quot;不满&quot;条件</span><br>            &#125;<br>            items[putIndex] = e;<br>            <span class="hljs-keyword">if</span> (++putIndex == items.length) putIndex = <span class="hljs-number">0</span>;<br>            ++count;<br>            notEmpty.signal();  <span class="hljs-comment">// 通知&quot;不空&quot;条件</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>) &#123;<br>                notEmpty.await();  <span class="hljs-comment">// 空了，等待&quot;不空&quot;条件</span><br>            &#125;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (E) items[takeIndex];<br>            items[takeIndex] = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (++takeIndex == items.length) takeIndex = <span class="hljs-number">0</span>;<br>            --count;<br>            notFull.signal();  <span class="hljs-comment">// 通知&quot;不满&quot;条件</span><br>            <span class="hljs-keyword">return</span> e;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>多条件队列的优势</strong>：上例中使用两个 Condition（<code>notFull</code> 和 <code>notEmpty</code>），生产者只唤醒消费者，消费者只唤醒生产者，避免了 <code>notifyAll()</code> 的惊群效应。</p>
<blockquote>
<p><strong>实现细节</strong>：<code>Condition</code> 的标准实现是 AQS 的内部类 <code>ConditionObject</code>，它维护了独立的条件队列。关于 <code>await()</code> 和 <code>signal()</code> 的实现原理，详见本文 <a href="#aqs-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90">AQS 深入解析</a> 章节中的&quot;Condition 条件队列详解&quot;部分。</p>
</blockquote>
<h3 id="reentrantreadwritelock：读写锁">ReentrantReadWriteLock：读写锁</h3>
<p><code>ReentrantReadWriteLock</code> 允许多个读线程同时访问，但写线程独占。这在读多写少的场景下能显著提高并发性能。</p>
<h4 id="核心结构">核心结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantReadWriteLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ReadWriteLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReadLock readerLock;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WriteLock writerLock;<br>    <span class="hljs-keyword">final</span> Sync sync;<br>    <br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-comment">// state 的位分割</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_SHIFT</span>   <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHARED_UNIT</span>    <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT);<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span>      <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCLUSIVE_MASK</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-comment">// 读锁计数（高16位）</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">sharedCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>    &#123; <span class="hljs-keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;<br>        <span class="hljs-comment">// 写锁计数（低16位）</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">exclusiveCount</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span> &#123; <span class="hljs-keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;<br>        <br>        <span class="hljs-comment">// 每个线程的读锁重入计数</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ThreadLocalHoldCounter readHolds;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HoldCounter cachedHoldCounter;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Thread firstReader;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-type">int</span> firstReaderHoldCount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="读写锁的获取规则">读写锁的获取规则</h4>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;读写锁的互斥规则&quot;
        direction TB
        
        subgraph &quot;当前状态&quot;
            NONE[&quot;无锁&quot;]
            READ[&quot;有读锁&quot;]
            WRITE[&quot;有写锁&quot;]
        end
        
        subgraph &quot;请求类型&quot;
            REQ_R[&quot;请求读锁&quot;]
            REQ_W[&quot;请求写锁&quot;]
        end
        
        NONE --&gt;|&quot;读请求&quot;| READ_OK[&quot;获取成功&quot;]
        NONE --&gt;|&quot;写请求&quot;| WRITE_OK[&quot;获取成功&quot;]
        
        READ --&gt;|&quot;读请求&quot;| READ_OK2[&quot;获取成功（共享）&quot;]
        READ --&gt;|&quot;写请求&quot;| WRITE_WAIT[&quot;等待&quot;]
        
        WRITE --&gt;|&quot;读请求（其他线程）&quot;| READ_WAIT[&quot;等待&quot;]
        WRITE --&gt;|&quot;写请求（其他线程）&quot;| WRITE_WAIT2[&quot;等待&quot;]
        WRITE --&gt;|&quot;读请求（同一线程）&quot;| READ_OK3[&quot;锁降级&quot;]
        WRITE --&gt;|&quot;写请求（同一线程）&quot;| WRITE_OK2[&quot;重入&quot;]
        
        style READ_OK fill:#c8e6c9
        style READ_OK2 fill:#c8e6c9
        style READ_OK3 fill:#c8e6c9
        style WRITE_OK fill:#c8e6c9
        style WRITE_OK2 fill:#c8e6c9
        style WRITE_WAIT fill:#ffcdd2
        style WRITE_WAIT2 fill:#ffcdd2
        style READ_WAIT fill:#ffcdd2
    end</code></pre>
<h4 id="锁降级">锁降级</h4>
<p><code>ReentrantReadWriteLock</code> 支持<strong>锁降级</strong>（写锁 → 读锁），但不支持<strong>锁升级</strong>（读锁 → 写锁）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 锁降级示例</span><br><span class="hljs-type">ReentrantReadWriteLock</span> <span class="hljs-variable">rwl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantReadWriteLock</span>();<br>ReentrantReadWriteLock.<span class="hljs-type">ReadLock</span> <span class="hljs-variable">readLock</span> <span class="hljs-operator">=</span> rwl.readLock();<br>ReentrantReadWriteLock.<span class="hljs-type">WriteLock</span> <span class="hljs-variable">writeLock</span> <span class="hljs-operator">=</span> rwl.writeLock();<br><br>writeLock.lock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 修改数据</span><br>    data = newValue;<br>    <br>    <span class="hljs-comment">// 在释放写锁之前获取读锁（锁降级）</span><br>    readLock.lock();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    writeLock.unlock();  <span class="hljs-comment">// 释放写锁，但仍持有读锁</span><br>&#125;<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 使用数据（此时只持有读锁）</span><br>    <span class="hljs-keyword">return</span> data;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    readLock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>为什么不支持锁升级？</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 1
    participant T2 as 线程 2
    participant RWL as 读写锁
    
    T1-&gt;&gt;RWL: 获取读锁（成功）
    T2-&gt;&gt;RWL: 获取读锁（成功）
    T1-&gt;&gt;RWL: 尝试升级为写锁（阻塞，等待 T2 释放读锁）
    T2-&gt;&gt;RWL: 尝试升级为写锁（阻塞，等待 T1 释放读锁）
    
    Note over T1,T2: 死锁！</code></pre>
<h3 id="stampedlock：java-8-的高性能读写锁">StampedLock：Java 8 的高性能读写锁</h3>
<p><code>StampedLock</code> 是 Java 8 在 <code>java.util.concurrent.locks</code> 包中新增的锁实现，它通过引入**乐观读（Optimistic Reading）**机制，在读多写少的场景下提供了比 <code>ReentrantReadWriteLock</code> 更高的并发性能。</p>
<h4 id="核心设计理念">核心设计理念</h4>
<ol>
<li><strong>票据（Stamp）机制</strong>：所有锁获取方法都返回一个 <code>long</code> 类型的 <code>stamp</code>，用于表示锁的状态和版本</li>
<li><strong>三种访问模式</strong>：写锁、悲观读锁、乐观读</li>
<li><strong>非基于 AQS</strong>：<code>StampedLock</code> 没有使用 AQS 框架，而是自己实现了基于 CLH 队列的同步机制</li>
<li><strong>不可重入</strong>：不支持重入，这是设计上的权衡，换取了更高的性能</li>
</ol>
<h4 id="三种访问模式">三种访问模式</h4>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;StampedLock 三种模式&quot;
        direction TB
        
        WRITE[&quot;写锁 (writeLock)&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;独占锁，完全排他&quot;]
        PREAD[&quot;悲观读锁 (readLock)&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;共享锁，阻塞写线程&quot;]
        OREAD[&quot;乐观读 (tryOptimisticRead)&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;无锁，需验证&quot;]
        
        WRITE --&gt;|&quot;tryConvertToReadLock()&quot;| PREAD
        PREAD --&gt;|&quot;tryConvertToWriteLock()&quot;| WRITE
        PREAD --&gt;|&quot;tryConvertToOptimisticRead()&quot;| OREAD
        OREAD --&gt;|&quot;validate() 失败&quot;| PREAD
        
        style WRITE fill:#ffcdd2
        style PREAD fill:#fff9c4
        style OREAD fill:#c8e6c9
    end</code></pre>
<h5 id="1-写锁-write-lock">1. 写锁（Write Lock）</h5>
<p>独占锁，与 <code>ReentrantLock</code> 类似，写锁被持有时，其他任何锁都无法获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">StampedLock</span> <span class="hljs-variable">sl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StampedLock</span>();<br><br><span class="hljs-comment">// 获取写锁</span><br><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.writeLock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 临界区代码：修改共享数据</span><br>    x += deltaX;<br>    y += deltaY;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    sl.unlockWrite(stamp);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="2-悲观读锁-pessimistic-read-lock">2. 悲观读锁（Pessimistic Read Lock）</h5>
<p>共享锁，允许多个线程同时持有读锁，但会阻塞写锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取读锁</span><br><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.readLock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 临界区代码：读取共享数据</span><br>    <span class="hljs-keyword">return</span> Math.sqrt(x * x + y * y);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    sl.unlockRead(stamp);<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="3-乐观读-optimistic-read">3. 乐观读（Optimistic Read）</h5>
<p>乐观读是 <code>StampedLock</code> 的核心创新。它不阻塞写线程，但需要通过 <code>validate()</code> 验证数据一致性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 乐观读的标准模式</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">double</span> <span class="hljs-title function_">distanceFromOrigin</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1. 获取乐观读票据</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.tryOptimisticRead();<br>    <br>    <span class="hljs-comment">// 2. 读取数据到局部变量</span><br>    <span class="hljs-type">double</span> <span class="hljs-variable">currentX</span> <span class="hljs-operator">=</span> x;<br>    <span class="hljs-type">double</span> <span class="hljs-variable">currentY</span> <span class="hljs-operator">=</span> y;<br>    <br>    <span class="hljs-comment">// 3. 验证读取期间是否有写操作</span><br>    <span class="hljs-keyword">if</span> (!sl.validate(stamp)) &#123;<br>        <span class="hljs-comment">// 验证失败，降级为悲观读锁</span><br>        stamp = sl.readLock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            currentX = x;<br>            currentY = y;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            sl.unlockRead(stamp);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 4. 使用数据</span><br>    <span class="hljs-keyword">return</span> Math.sqrt(currentX * currentX + currentY * currentY);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="validate-工作原理">validate() 工作原理</h4>
<p><code>StampedLock</code> 使用一个 <code>long</code> 类型的 <code>state</code> 变量来维护锁状态：</p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;state 位结构（64位）&quot;
        direction LR
        
        V[&quot;bit 8-63&lt;br/&gt;版本号（56位）&lt;br/&gt;（每次写锁释放递增）&quot;]
        W[&quot;bit 7&lt;br/&gt;写锁标志&lt;br/&gt;（WBIT = 128）&quot;]
        R[&quot;bit 0-6&lt;br/&gt;读锁计数（7位）&lt;br/&gt;（最大 126）&quot;]
        
        style V fill:#e1bee7
        style W fill:#ffcdd2
        style R fill:#c8e6c9
    end</code></pre>
<p><strong>依据</strong>：根据 <code>java.util.concurrent.locks.StampedLock</code> 源码（JDK 21）中的常量定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// StampedLock 源码中的关键常量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LG_READERS</span> <span class="hljs-operator">=</span> <span class="hljs-number">7</span>;           <span class="hljs-comment">// 读锁计数位数</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">RUNIT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;              <span class="hljs-comment">// 读锁单位</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">WBIT</span>  <span class="hljs-operator">=</span> <span class="hljs-number">1L</span> &lt;&lt; LG_READERS; <span class="hljs-comment">// 写锁标志位 = 128 (bit 7)</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">RBITS</span> <span class="hljs-operator">=</span> WBIT - <span class="hljs-number">1L</span>;       <span class="hljs-comment">// 读锁掩码 = 127 (bit 0-6)</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">RFULL</span> <span class="hljs-operator">=</span> RBITS - <span class="hljs-number">1L</span>;      <span class="hljs-comment">// 最大读锁数 = 126</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ABITS</span> <span class="hljs-operator">=</span> RBITS | WBIT;    <span class="hljs-comment">// 读写锁掩码 = 255 (bit 0-7)</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">SBITS</span> <span class="hljs-operator">=</span> ~RBITS;          <span class="hljs-comment">// 版本号掩码 (bit 7-63)</span><br></code></pre></td></tr></table></figure>
<p><strong>位结构详解</strong>：</p>
<ul>
<li><strong>bit 0-6</strong>（7位）：读锁计数，最大值为 126（RFULL），超过时使用溢出机制</li>
<li><strong>bit 7</strong>（1位）：写锁标志位（WBIT = 128），1 表示写锁被持有</li>
<li><strong>bit 8-63</strong>（56位）：版本号，每次写锁释放时递增，用于乐观读验证</li>
</ul>
<p>验证逻辑：</p>
<ul>
<li><code>tryOptimisticRead()</code> 返回当前 <code>state</code> 的快照（版本号）</li>
<li>如果读取期间有写操作，写锁获取和释放会改变 <code>state</code> 的值（版本号递增）</li>
<li><code>validate(stamp)</code> 比较当前 <code>state</code> 与保存的 <code>stamp</code>，如果相等则验证成功</li>
</ul>
<h4 id="锁转换方法">锁转换方法</h4>
<p><code>StampedLock</code> 提供了三个锁转换方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>功能</th>
<th>返回值</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tryConvertToWriteLock(stamp)</code></td>
<td>读锁/乐观读 → 写锁</td>
<td>成功返回新 stamp，失败返回 0</td>
</tr>
<tr>
<td><code>tryConvertToReadLock(stamp)</code></td>
<td>写锁 → 读锁（锁降级）</td>
<td>成功返回新 stamp，失败返回 0</td>
</tr>
<tr>
<td><code>tryConvertToOptimisticRead(stamp)</code></td>
<td>读锁/写锁 → 乐观读</td>
<td>成功返回新 stamp，失败返回 0</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 锁升级示例：读后写</span><br><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> sl.readLock();<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">while</span> (x == <span class="hljs-number">0.0</span> &amp;&amp; y == <span class="hljs-number">0.0</span>) &#123;<br>        <span class="hljs-comment">// 尝试升级为写锁</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> sl.tryConvertToWriteLock(stamp);<br>        <span class="hljs-keyword">if</span> (ws != <span class="hljs-number">0L</span>) &#123;<br>            stamp = ws;<br>            x = newX;<br>            y = newY;<br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 升级失败，释放读锁，获取写锁</span><br>            sl.unlockRead(stamp);<br>            stamp = sl.writeLock();<br>        &#125;<br>    &#125;<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    sl.unlock(stamp);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="stampedlock-vs-reentrantreadwritelock">StampedLock vs ReentrantReadWriteLock</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>StampedLock</th>
<th>ReentrantReadWriteLock</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>可重入性</strong></td>
<td>不可重入</td>
<td>支持重入</td>
</tr>
<tr>
<td><strong>公平性</strong></td>
<td>非公平锁</td>
<td>支持公平/非公平</td>
</tr>
<tr>
<td><strong>Condition 支持</strong></td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>锁降级</strong></td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td><strong>锁升级</strong></td>
<td>支持（tryConvertToWriteLock）</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>乐观读</strong></td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>读锁饥饿</strong></td>
<td>乐观读可避免写线程饥饿</td>
<td>读线程多时写线程可能饥饿</td>
</tr>
<tr>
<td><strong>性能（读多写少）</strong></td>
<td>极高</td>
<td>一般</td>
</tr>
<tr>
<td><strong>API 复杂度</strong></td>
<td>复杂</td>
<td>简单</td>
</tr>
<tr>
<td><strong>基于框架</strong></td>
<td>自实现（CLH 队列）</td>
<td>基于 AQS</td>
</tr>
</tbody>
</table>
<h4 id="使用注意事项">使用注意事项</h4>
<h5 id="1-不可重入导致的死锁">1. 不可重入导致的死锁</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：不可重入导致死锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        method2();  <span class="hljs-comment">// 死锁！</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlockWrite(stamp);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();  <span class="hljs-comment">// 死锁！</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 业务逻辑</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlockWrite(stamp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="2-中断导致-cpu-飙升">2. 中断导致 CPU 飙升</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 危险：阻塞时中断可能导致 CPU 100%</span><br><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLock();<br><br><span class="hljs-comment">// 正确：使用可中断方法</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.writeLockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 业务逻辑</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlockWrite(stamp);<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    Thread.currentThread().interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="3-乐观读必须验证">3. 乐观读必须验证</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正确：乐观读后验证</span><br><span class="hljs-type">long</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> lock.tryOptimisticRead();<br><span class="hljs-type">double</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> sharedValue;<br><span class="hljs-keyword">if</span> (!lock.validate(stamp)) &#123;<br>    <span class="hljs-comment">// 验证失败，降级为悲观读</span><br>    stamp = lock.readLock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        value = sharedValue;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlockRead(stamp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="适用场景">适用场景</h4>
<p><strong>推荐使用：</strong></p>
<ul>
<li>读多写少，对性能要求高</li>
<li>短临界区，减少验证失败概率</li>
<li>无重入需求，无 Condition 需求</li>
</ul>
<p><strong>不推荐使用：</strong></p>
<ul>
<li>需要重入（递归调用）</li>
<li>需要 Condition 条件变量</li>
<li>写操作频繁，乐观读验证失败率高</li>
<li>简单场景，<code>synchronized</code> 或 <code>ReentrantLock</code> 足够</li>
</ul>
<h3 id="semaphore：信号量">Semaphore：信号量</h3>
<p><code>Semaphore</code> 维护一组许可（permits），用于限制同时访问某个资源的线程数量。</p>
<h4 id="核心实现">核心实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Semaphore</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br>    <br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        Sync(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>) &#123;<br>            setState(<span class="hljs-keyword">permits</span>);  <span class="hljs-comment">// state = 许可数量</span><br>        &#125;<br>        <br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getPermits</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 非公平获取</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>                <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>                    compareAndSetState(available, remaining))<br>                    <span class="hljs-keyword">return</span> remaining;<br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 释放</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>                <span class="hljs-keyword">if</span> (next &lt; current)  <span class="hljs-comment">// 溢出检查</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>                <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="state-的语义">state 的语义</h4>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Semaphore 的 state 语义&quot;
        direction TB
        
        INIT[&quot;初始化&lt;br/&gt;state = permits（如 3）&quot;]
        
        ACQ1[&quot;acquire()&lt;br/&gt;state = 2&quot;]
        ACQ2[&quot;acquire()&lt;br/&gt;state = 1&quot;]
        ACQ3[&quot;acquire()&lt;br/&gt;state = 0&quot;]
        WAIT[&quot;acquire()&lt;br/&gt;阻塞等待&quot;]
        
        REL[&quot;release()&lt;br/&gt;state++&quot;]
        
        INIT --&gt; ACQ1 --&gt; ACQ2 --&gt; ACQ3 --&gt; WAIT
        ACQ3 --&gt; REL
        REL --&gt; ACQ3
        
        style INIT fill:#c8e6c9
        style WAIT fill:#ffcdd2
    end</code></pre>
<h4 id="使用场景">使用场景</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 限制数据库连接池的并发访问</span><br><span class="hljs-type">Semaphore</span> <span class="hljs-variable">dbSemaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 最多10个并发连接</span><br><br><span class="hljs-keyword">public</span> Connection <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    dbSemaphore.acquire();  <span class="hljs-comment">// 获取许可</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> pool.getConnection();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        dbSemaphore.release();  <span class="hljs-comment">// 获取失败时释放许可</span><br>        <span class="hljs-keyword">throw</span> e;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">releaseConnection</span><span class="hljs-params">(Connection conn)</span> &#123;<br>    pool.releaseConnection(conn);<br>    dbSemaphore.release();  <span class="hljs-comment">// 释放许可</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="countdownlatch：倒计时门闩">CountDownLatch：倒计时门闩</h3>
<p><code>CountDownLatch</code> 允许一个或多个线程等待其他线程完成操作。</p>
<h4 id="核心实现">核心实现</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CountDownLatch</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        Sync(<span class="hljs-type">int</span> count) &#123;<br>            setState(count);  <span class="hljs-comment">// state = 计数值</span><br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState();<br>        &#125;<br>        <br>        <span class="hljs-comment">// await() 调用此方法</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>            <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;  <span class="hljs-comment">// state=0 时返回成功</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// countDown() 调用此方法</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c - <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                    <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;  <span class="hljs-comment">// 减到0时返回true，唤醒等待线程</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="工作流程">工作流程</h4>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Main as 主线程
    participant CDL as CountDownLatch(3)
    participant W1 as 工作线程 1
    participant W2 as 工作线程 2
    participant W3 as 工作线程 3
    
    Main-&gt;&gt;CDL: await()（阻塞，state=3）
    
    W1-&gt;&gt;W1: 执行任务
    W1-&gt;&gt;CDL: countDown()（state=2）
    
    W2-&gt;&gt;W2: 执行任务
    W2-&gt;&gt;CDL: countDown()（state=1）
    
    W3-&gt;&gt;W3: 执行任务
    W3-&gt;&gt;CDL: countDown()（state=0）
    
    CDL-&gt;&gt;Main: 唤醒（state=0）
    Main-&gt;&gt;Main: 继续执行</code></pre>
<h4 id="使用场景">使用场景</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 等待多个服务初始化完成</span><br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 启动多个初始化任务</span><br>executor.submit(() -&gt; &#123;<br>    initDatabase();<br>    latch.countDown();<br>&#125;);<br>executor.submit(() -&gt; &#123;<br>    initCache();<br>    latch.countDown();<br>&#125;);<br>executor.submit(() -&gt; &#123;<br>    initMessageQueue();<br>    latch.countDown();<br>&#125;);<br><br><span class="hljs-comment">// 等待所有初始化完成</span><br>latch.await();<br>System.out.println(<span class="hljs-string">&quot;All services initialized!&quot;</span>);<br></code></pre></td></tr></table></figure>
<h3 id="cyclicbarrier：循环栅栏">CyclicBarrier：循环栅栏</h3>
<p><code>CyclicBarrier</code> 让一组线程互相等待，直到所有线程都到达某个屏障点。与 <code>CountDownLatch</code> 不同，它可以重复使用。</p>
<h4 id="核心结构">核心结构</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CyclicBarrier</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> parties;          <span class="hljs-comment">// 参与者数量</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable barrierCommand;  <span class="hljs-comment">// 屏障动作</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">generation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;                  <span class="hljs-comment">// 还未到达的线程数</span><br>    <br>    <span class="hljs-comment">// 核心等待方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> --count;<br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 最后一个到达</span><br>                <span class="hljs-comment">// 执行屏障动作</span><br>                <span class="hljs-keyword">if</span> (barrierCommand != <span class="hljs-literal">null</span>)<br>                    barrierCommand.run();<br>                <span class="hljs-comment">// 开启新一代，唤醒所有等待线程</span><br>                nextGeneration();<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <br>            <span class="hljs-comment">// 不是最后一个，等待</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">if</span> (!timed)<br>                    trip.await();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)<br>                    nanos = trip.awaitNanos(nanos);<br>                <span class="hljs-comment">// 检查是否被唤醒或中断</span><br>                <span class="hljs-comment">// ...</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="cyclicbarrier-vs-countdownlatch">CyclicBarrier vs CountDownLatch</h4>
<table>
<thead>
<tr>
<th>特性</th>
<th>CyclicBarrier</th>
<th>CountDownLatch</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>重用性</strong></td>
<td>可重复使用</td>
<td>一次性</td>
</tr>
<tr>
<td><strong>计数方向</strong></td>
<td>递减到0后重置</td>
<td>递减到0后结束</td>
</tr>
<tr>
<td><strong>等待方式</strong></td>
<td>线程互相等待</td>
<td>线程等待计数归零</td>
</tr>
<tr>
<td><strong>屏障动作</strong></td>
<td>支持（最后一个线程执行）</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td>ReentrantLock + Condition</td>
<td>AQS 共享模式</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>多阶段并行计算</td>
<td>等待多个任务完成</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;CyclicBarrier vs CountDownLatch&quot;
        direction LR
        
        subgraph &quot;CountDownLatch&quot;
            CDL_W[&quot;等待线程&quot;]
            CDL_C1[&quot;工作线程 1&quot;]
            CDL_C2[&quot;工作线程 2&quot;]
            CDL_C3[&quot;工作线程 3&quot;]
            
            CDL_C1 --&gt;|&quot;countDown()&quot;| CDL_W
            CDL_C2 --&gt;|&quot;countDown()&quot;| CDL_W
            CDL_C3 --&gt;|&quot;countDown()&quot;| CDL_W
        end
        
        subgraph &quot;CyclicBarrier&quot;
            CB_T1[&quot;线程 1&quot;]
            CB_T2[&quot;线程 2&quot;]
            CB_T3[&quot;线程 3&quot;]
            CB_B[&quot;屏障点&quot;]
            
            CB_T1 --&gt;|&quot;await()&quot;| CB_B
            CB_T2 --&gt;|&quot;await()&quot;| CB_B
            CB_T3 --&gt;|&quot;await()&quot;| CB_B
            CB_B --&gt;|&quot;全部到达后继续&quot;| CB_T1
            CB_B --&gt;|&quot;全部到达后继续&quot;| CB_T2
            CB_B --&gt;|&quot;全部到达后继续&quot;| CB_T3
        end
    end</code></pre>
<h3 id="同步器对比总结">同步器对比总结</h3>
<table>
<thead>
<tr>
<th>同步器</th>
<th>state 语义</th>
<th>获取模式</th>
<th>典型场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ReentrantLock</strong></td>
<td>重入次数</td>
<td>独占</td>
<td>互斥访问</td>
</tr>
<tr>
<td><strong>ReentrantReadWriteLock</strong></td>
<td>高16位读/低16位写</td>
<td>共享+独占</td>
<td>读多写少</td>
</tr>
<tr>
<td><strong>Semaphore</strong></td>
<td>可用许可数</td>
<td>共享</td>
<td>限流、资源池</td>
</tr>
<tr>
<td><strong>CountDownLatch</strong></td>
<td>剩余计数</td>
<td>共享</td>
<td>等待多任务完成</td>
</tr>
<tr>
<td><strong>CyclicBarrier</strong></td>
<td>通过 Lock+Condition</td>
<td>N/A</td>
<td>多阶段并行计算</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;AQS 同步器家族&quot;
        direction TB
        
        AQS[&quot;AbstractQueuedSynchronizer&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;state + CLH Queue&quot;]
        
        subgraph &quot;独占模式&quot;
            RL[&quot;ReentrantLock&quot;]
            WL[&quot;WriteLock&quot;]
        end
        
        subgraph &quot;共享模式&quot;
            SEM[&quot;Semaphore&quot;]
            CDL[&quot;CountDownLatch&quot;]
            RL_R[&quot;ReadLock&quot;]
        end
        
        subgraph &quot;混合模式&quot;
            RWL[&quot;ReentrantReadWriteLock&quot;]
        end
        
        subgraph &quot;基于 Lock+Condition&quot;
            CB[&quot;CyclicBarrier&quot;]
        end
        
        AQS --&gt; RL
        AQS --&gt; WL
        AQS --&gt; SEM
        AQS --&gt; CDL
        AQS --&gt; RL_R
        RWL --&gt; WL
        RWL --&gt; RL_R
        RL --&gt; CB
        
        style AQS fill:#e1f5ff,stroke:#0288d1,stroke-width:3px
    end</code></pre>
<h3 id="自定义同步器示例">自定义同步器示例</h3>
<p>理解了 AQS 的原理后，我们可以轻松实现自定义同步器。以下是一个简单的<strong>二元闭锁</strong>（只能打开一次的门）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BinaryLatch</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-comment">// state = 0: 门关闭</span><br>        <span class="hljs-comment">// state = 1: 门打开</span><br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-comment">// 门打开时返回成功</span><br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-comment">// 打开门</span><br>            setState(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 等待门打开</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 打开门</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">BinaryLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BinaryLatch</span>();<br><br><span class="hljs-comment">// 等待线程</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    System.out.println(<span class="hljs-string">&quot;Waiting for signal...&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        latch.await();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt();<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;Got signal!&quot;</span>);<br>&#125;).start();<br><br><span class="hljs-comment">// 信号线程</span><br>Thread.sleep(<span class="hljs-number">1000</span>);<br>latch.signal();  <span class="hljs-comment">// 打开门，唤醒所有等待线程</span><br></code></pre></td></tr></table></figure>
<h2 id="锁的活性问题">锁的活性问题</h2>
<p>在并发编程中，正确性不仅仅意味着&quot;不出错&quot;，还意味着程序能够持续向前推进。<strong>活性（Liveness）<strong>是指程序最终能够完成其预期工作的能力。与活性相对的是</strong>活性问题</strong>，主要包括死锁、活锁和饥饿。</p>
<h3 id="死锁-deadlock">死锁（Deadlock）</h3>
<p><strong>定义</strong>：两个或多个线程互相等待对方持有的资源，导致所有线程都无法继续执行。</p>
<h4 id="死锁的四个必要条件">死锁的四个必要条件</h4>
<p>死锁的发生必须同时满足以下四个条件（Coffman 条件）：</p>
<table>
<thead>
<tr>
<th>条件</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>互斥条件</strong></td>
<td>资源不能被多个线程同时使用</td>
</tr>
<tr>
<td><strong>持有并等待</strong></td>
<td>线程持有至少一个资源，同时等待获取其他资源</td>
</tr>
<tr>
<td><strong>不可剥夺</strong></td>
<td>资源只能由持有它的线程主动释放，不能被强制剥夺</td>
</tr>
<tr>
<td><strong>循环等待</strong></td>
<td>存在一个线程等待链，形成环路</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;死锁的循环等待&quot;
        T1[&quot;线程 1&lt;br/&gt;持有：锁 A&lt;br/&gt;等待：锁 B&quot;]
        T2[&quot;线程 2&lt;br/&gt;持有：锁 B&lt;br/&gt;等待：锁 A&quot;]
        
        T1 --&gt;|&quot;等待&quot;| T2
        T2 --&gt;|&quot;等待&quot;| T1
        
        style T1 fill:#ffcdd2
        style T2 fill:#ffcdd2
    end</code></pre>
<h4 id="经典死锁示例">经典死锁示例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DeadlockExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lockA</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lockB</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lockA) &#123;           <span class="hljs-comment">// 1. 获取锁 A</span><br>            System.out.println(<span class="hljs-string">&quot;Thread 1: Holding lock A&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">100</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>            <br>            <span class="hljs-keyword">synchronized</span> (lockB) &#123;       <span class="hljs-comment">// 2. 尝试获取锁 B（可能死锁）</span><br>                System.out.println(<span class="hljs-string">&quot;Thread 1: Holding lock A &amp; B&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lockB) &#123;           <span class="hljs-comment">// 1. 获取锁 B</span><br>            System.out.println(<span class="hljs-string">&quot;Thread 2: Holding lock B&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">100</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>            <br>            <span class="hljs-keyword">synchronized</span> (lockA) &#123;       <span class="hljs-comment">// 2. 尝试获取锁 A（可能死锁）</span><br>                System.out.println(<span class="hljs-string">&quot;Thread 2: Holding lock A &amp; B&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 1
    participant LA as 锁 A
    participant LB as 锁 B
    participant T2 as 线程 2
    
    T1-&gt;&gt;LA: 获取锁 A（成功）
    T2-&gt;&gt;LB: 获取锁 B（成功）
    T1-&gt;&gt;LB: 尝试获取锁 B（阻塞）
    T2-&gt;&gt;LA: 尝试获取锁 A（阻塞）
    
    Note over T1,T2: 死锁！双方互相等待</code></pre>
<h4 id="死锁的预防策略">死锁的预防策略</h4>
<p><strong>1. 破坏&quot;持有并等待&quot;条件：一次性获取所有资源</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用一个全局锁来保护资源获取</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">safeMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (globalLock) &#123;<br>        <span class="hljs-comment">// 一次性获取所有需要的资源</span><br>        <span class="hljs-keyword">synchronized</span> (lockA) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lockB) &#123;<br>                <span class="hljs-comment">// 执行操作</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>2. 破坏&quot;循环等待&quot;条件：按固定顺序获取锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 始终按照 lockA -&gt; lockB 的顺序获取锁</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method1</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lockA) &#123;<br>        <span class="hljs-keyword">synchronized</span> (lockB) &#123;<br>            <span class="hljs-comment">// 执行操作</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">method2</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lockA) &#123;  <span class="hljs-comment">// 改为先获取 lockA</span><br>        <span class="hljs-keyword">synchronized</span> (lockB) &#123;<br>            <span class="hljs-comment">// 执行操作</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>3. 使用 tryLock 超时机制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">safeMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (lockA.tryLock(<span class="hljs-number">100</span>, TimeUnit.MILLISECONDS)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (lockB.tryLock(<span class="hljs-number">100</span>, TimeUnit.MILLISECONDS)) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// 执行操作</span><br>                        <span class="hljs-keyword">return</span>;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        lockB.unlock();<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lockA.unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 获取失败，稍后重试</span><br>        Thread.sleep(<span class="hljs-number">50</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="死锁的检测">死锁的检测</h4>
<p><strong>使用 jstack 检测死锁：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">jstack &lt;pid&gt; | grep -A 50 <span class="hljs-string">&quot;Found one Java-level deadlock&quot;</span><br></code></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">Found one Java-level deadlock:</span><br><span class="hljs-section">=============================</span><br>&quot;Thread-1&quot;:<br><span class="hljs-code">  waiting to lock monitor 0x00007f8a1c000000 (object 0x000000076ab12345, a java.lang.Object),</span><br><span class="hljs-code">  which is held by &quot;Thread-0&quot;</span><br>&quot;Thread-0&quot;:<br><span class="hljs-code">  waiting to lock monitor 0x00007f8a1c000100 (object 0x000000076ab67890, a java.lang.Object),</span><br><span class="hljs-code">  which is held by &quot;Thread-1&quot;</span><br><br><span class="hljs-section">Java stack information for the threads listed above:</span><br><span class="hljs-section">===================================================</span><br>...<br></code></pre></td></tr></table></figure>
<p><strong>使用 ThreadMXBean 编程检测：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadMXBean</span> <span class="hljs-variable">threadMXBean</span> <span class="hljs-operator">=</span> ManagementFactory.getThreadMXBean();<br><span class="hljs-type">long</span>[] deadlockedThreads = threadMXBean.findDeadlockedThreads();<br><span class="hljs-keyword">if</span> (deadlockedThreads != <span class="hljs-literal">null</span>) &#123;<br>    ThreadInfo[] threadInfos = threadMXBean.getThreadInfo(deadlockedThreads);<br>    <span class="hljs-keyword">for</span> (ThreadInfo info : threadInfos) &#123;<br>        System.out.println(<span class="hljs-string">&quot;Deadlocked thread: &quot;</span> + info.getThreadName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="活锁-livelock">活锁（Livelock）</h3>
<p><strong>定义</strong>：线程没有被阻塞，但由于某些条件不满足，一直在重复尝试某个操作，无法向前推进。</p>
<p>活锁与死锁的区别：</p>
<ul>
<li><strong>死锁</strong>：线程被阻塞，完全不执行</li>
<li><strong>活锁</strong>：线程在执行，但做的是无用功</li>
</ul>
<h4 id="活锁示例：过于礼貌的线程">活锁示例：过于礼貌的线程</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LivelockExample</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Spoon</span> &#123;<br>        <span class="hljs-keyword">private</span> Diner owner;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">use</span><span class="hljs-params">()</span> &#123;<br>            System.out.println(owner.name + <span class="hljs-string">&quot; is eating&quot;</span>);<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setOwner</span><span class="hljs-params">(Diner diner)</span> &#123;<br>            <span class="hljs-built_in">this</span>.owner = diner;<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Diner <span class="hljs-title function_">getOwner</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> owner;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Diner</span> &#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> isHungry;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatWith</span><span class="hljs-params">(Spoon spoon, Diner partner)</span> &#123;<br>            <span class="hljs-keyword">while</span> (isHungry) &#123;<br>                <span class="hljs-comment">// 如果勺子不是自己的，等待</span><br>                <span class="hljs-keyword">if</span> (spoon.getOwner() != <span class="hljs-built_in">this</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 如果对方也饿，&quot;礼貌地&quot;让出勺子</span><br>                <span class="hljs-keyword">if</span> (partner.isHungry) &#123;<br>                    System.out.println(name + <span class="hljs-string">&quot;: 你先吃吧，&quot;</span> + partner.name);<br>                    spoon.setOwner(partner);<br>                    <span class="hljs-keyword">continue</span>;  <span class="hljs-comment">// 活锁！双方不断互相让</span><br>                &#125;<br>                <br>                <span class="hljs-comment">// 吃饭</span><br>                spoon.use();<br>                isHungry = <span class="hljs-literal">false</span>;<br>                spoon.setOwner(partner);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant A as 线程 A
    participant S as 勺子
    participant B as 线程 B
    
    A-&gt;&gt;S: 获取勺子
    A-&gt;&gt;A: 检查：B 也饿
    A-&gt;&gt;S: &quot;你先吃&quot; → 让出勺子
    B-&gt;&gt;S: 获取勺子
    B-&gt;&gt;B: 检查：A 也饿
    B-&gt;&gt;S: &quot;你先吃&quot; → 让出勺子
    A-&gt;&gt;S: 获取勺子
    A-&gt;&gt;A: 检查：B 也饿
    A-&gt;&gt;S: &quot;你先吃&quot; → 让出勺子
    
    Note over A,B: 活锁！双方不断互相让，&lt;br/&gt;但谁都没吃到</code></pre>
<h4 id="活锁的解决方案">活锁的解决方案</h4>
<p><strong>1. 引入随机性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatWith</span><span class="hljs-params">(Spoon spoon, Diner partner)</span> &#123;<br>    <span class="hljs-keyword">while</span> (isHungry) &#123;<br>        <span class="hljs-keyword">if</span> (spoon.getOwner() != <span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (partner.isHungry) &#123;<br>            <span class="hljs-comment">// 引入随机等待，打破同步</span><br>            <span class="hljs-keyword">if</span> (Math.random() &lt; <span class="hljs-number">0.5</span>) &#123;<br>                spoon.setOwner(partner);<br>                <span class="hljs-keyword">try</span> &#123; Thread.sleep((<span class="hljs-type">long</span>)(Math.random() * <span class="hljs-number">10</span>)); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>            &#125;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        spoon.use();<br>        isHungry = <span class="hljs-literal">false</span>;<br>        spoon.setOwner(partner);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>2. 引入优先级或仲裁机制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用时间戳作为优先级</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">eatWith</span><span class="hljs-params">(Spoon spoon, Diner partner)</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">myPriority</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    <br>    <span class="hljs-keyword">while</span> (isHungry) &#123;<br>        <span class="hljs-keyword">if</span> (spoon.getOwner() != <span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (partner.isHungry &amp;&amp; partner.priority &lt; myPriority) &#123;<br>            <span class="hljs-comment">// 只有优先级更低的才让出</span><br>            spoon.setOwner(partner);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <br>        spoon.use();<br>        isHungry = <span class="hljs-literal">false</span>;<br>        spoon.setOwner(partner);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="饥饿-starvation">饥饿（Starvation）</h3>
<p><strong>定义</strong>：某个线程长时间无法获取所需的资源，导致无法执行。</p>
<p>饥饿通常发生在以下场景：</p>
<ol>
<li><strong>优先级不公平</strong>：高优先级线程持续抢占资源</li>
<li><strong>锁的非公平性</strong>：非公平锁可能导致某些线程长期等待</li>
<li><strong>资源竞争激烈</strong>：某些线程运气不好，总是抢不到资源</li>
</ol>
<h4 id="饥饿示例">饥饿示例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StarvationExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">highPriorityTask</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>                <span class="hljs-comment">// 高优先级任务频繁获取锁</span><br>                doWork();<br>            &#125;<br>            <span class="hljs-comment">// 几乎不释放锁</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lowPriorityTask</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// 低优先级任务可能永远无法获取锁</span><br>            doWork();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;饥饿场景&quot;
        direction TB
        
        HP1[&quot;高优先级线程 1&quot;]
        HP2[&quot;高优先级线程 2&quot;]
        HP3[&quot;高优先级线程 3&quot;]
        LP[&quot;低优先级线程&lt;br/&gt;（饥饿）&quot;]
        
        LOCK[&quot;锁资源&quot;]
        
        HP1 --&gt;|&quot;频繁获取&quot;| LOCK
        HP2 --&gt;|&quot;频繁获取&quot;| LOCK
        HP3 --&gt;|&quot;频繁获取&quot;| LOCK
        LP -.-&gt;|&quot;长期等待&quot;| LOCK
        
        style LP fill:#ffcdd2
        style LOCK fill:#fff9c4
    end</code></pre>
<h4 id="饥饿的解决方案">饥饿的解决方案</h4>
<p><strong>1. 使用公平锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 公平锁保证 FIFO 顺序</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">fairLock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span> &#123;<br>    fairLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        doWork();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        fairLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>2. 避免长时间持有锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-comment">// 只在必要时持有锁</span><br>        <span class="hljs-type">Data</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> readData();<br>    &#125;<br>    <span class="hljs-comment">// 锁外处理数据</span><br>    processData(data);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>3. 使用信号量限制并发</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 限制同时访问资源的线程数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 公平信号量</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    semaphore.acquire();<br>    <span class="hljs-keyword">try</span> &#123;<br>        doWork();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        semaphore.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="三种活性问题的对比">三种活性问题的对比</h3>
<table>
<thead>
<tr>
<th>问题</th>
<th>线程状态</th>
<th>原因</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>死锁</strong></td>
<td>阻塞（BLOCKED/WAITING）</td>
<td>循环等待资源</td>
<td>破坏四个必要条件之一</td>
</tr>
<tr>
<td><strong>活锁</strong></td>
<td>运行（RUNNABLE）</td>
<td>不断重试但无进展</td>
<td>引入随机性或优先级</td>
</tr>
<tr>
<td><strong>饥饿</strong></td>
<td>就绪/阻塞</td>
<td>资源分配不公平</td>
<td>使用公平锁、限制持锁时间</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;活性问题对比&quot;
        direction LR
        
        subgraph &quot;死锁&quot;
            DL_T1[&quot;线程 1&lt;br/&gt;BLOCKED&quot;]
            DL_T2[&quot;线程 2&lt;br/&gt;BLOCKED&quot;]
            DL_T1 &lt;--&gt;|&quot;互相等待&quot;| DL_T2
            style DL_T1 fill:#ffcdd2
            style DL_T2 fill:#ffcdd2
        end
        
        subgraph &quot;活锁&quot;
            LL_T1[&quot;线程 1&lt;br/&gt;RUNNABLE&quot;]
            LL_T2[&quot;线程 2&lt;br/&gt;RUNNABLE&quot;]
            LL_T1 &lt;--&gt;|&quot;互相让步&quot;| LL_T2
            style LL_T1 fill:#fff9c4
            style LL_T2 fill:#fff9c4
        end
        
        subgraph &quot;饥饿&quot;
            ST_HP[&quot;高优先级&lt;br/&gt;RUNNABLE&quot;]
            ST_LP[&quot;低优先级&lt;br/&gt;WAITING&quot;]
            ST_HP --&gt;|&quot;持续抢占&quot;| ST_LP
            style ST_HP fill:#c8e6c9
            style ST_LP fill:#ffcdd2
        end
    end</code></pre>
<h3 id="小结">小结</h3>
<p>活性问题是并发编程中必须关注的重要问题：</p>
<ol>
<li>
<p><strong>死锁</strong>：最严重的活性问题，程序完全停止。预防的关键是破坏四个必要条件之一，最常用的方法是按固定顺序获取锁。</p>
</li>
<li>
<p><strong>活锁</strong>：线程在执行但无进展。解决方法是引入随机性或优先级机制，打破同步的&quot;礼貌&quot;行为。</p>
</li>
<li>
<p><strong>饥饿</strong>：某些线程长期无法获取资源。解决方法是使用公平锁、限制持锁时间、合理设置优先级。</p>
</li>
</ol>
<p>在实际开发中，应该：</p>
<ul>
<li>尽量减少锁的使用范围和持有时间</li>
<li>使用成熟的并发工具类（如 <code>java.util.concurrent</code> 包）</li>
<li>定期使用 jstack 等工具检测潜在的活性问题</li>
<li>在设计阶段就考虑并发安全，而不是事后修补</li>
</ul>
<h1>java.util.concurrent.atomic 包体系</h1>
<p><code>java.util.concurrent.atomic</code> 包提供了一组原子类，用于在无锁的情况下实现线程安全的操作。这些类基于 CAS（Compare-And-Swap）指令实现，避免了传统锁带来的线程阻塞和上下文切换开销。</p>
<h2 id="原子类的分类">原子类的分类</h2>
<p>atomic 包中的原子类可以分为以下五类：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;java.util.concurrent.atomic 包体系&quot;
        direction TB
        
        subgraph &quot;基本类型原子类&quot;
            AI[&quot;AtomicInteger&quot;]
            AL[&quot;AtomicLong&quot;]
            AB[&quot;AtomicBoolean&quot;]
        end
        
        subgraph &quot;引用类型原子类&quot;
            AR[&quot;AtomicReference&amp;lt;V&amp;gt;&quot;]
            ASR[&quot;AtomicStampedReference&amp;lt;V&amp;gt;&lt;br/&gt;（解决 ABA 问题）&quot;]
            AMR[&quot;AtomicMarkableReference&amp;lt;V&amp;gt;&lt;br/&gt;（带标记位）&quot;]
        end
        
        subgraph &quot;数组原子类&quot;
            AIA[&quot;AtomicIntegerArray&quot;]
            ALA[&quot;AtomicLongArray&quot;]
            ARA[&quot;AtomicReferenceArray&amp;lt;E&amp;gt;&quot;]
        end
        
        subgraph &quot;字段更新器&quot;
            AIFU[&quot;AtomicIntegerFieldUpdater&amp;lt;T&amp;gt;&quot;]
            ALFU[&quot;AtomicLongFieldUpdater&amp;lt;T&amp;gt;&quot;]
            ARFU[&quot;AtomicReferenceFieldUpdater&amp;lt;T,V&amp;gt;&quot;]
        end
        
        subgraph &quot;累加器（Java 8+）&quot;
            LA[&quot;LongAdder&quot;]
            DA[&quot;DoubleAdder&quot;]
            LAC[&quot;LongAccumulator&quot;]
            DAC[&quot;DoubleAccumulator&quot;]
            S64[&quot;Striped64&lt;br/&gt;（累加器基类）&quot;]
        end
        
        style AI fill:#c8e6c9
        style AL fill:#c8e6c9
        style AB fill:#c8e6c9
        style AR fill:#fff9c4
        style ASR fill:#fff9c4
        style AMR fill:#fff9c4
        style AIA fill:#bbdefb
        style ALA fill:#bbdefb
        style ARA fill:#bbdefb
        style AIFU fill:#ffcc80
        style ALFU fill:#ffcc80
        style ARFU fill:#ffcc80
        style LA fill:#e1bee7
        style DA fill:#e1bee7
        style LAC fill:#e1bee7
        style DAC fill:#e1bee7
        style S64 fill:#e1bee7
    end</code></pre>
<h3 id="基本类型原子类">基本类型原子类</h3>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
<th>核心方法</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>AtomicInteger</strong></td>
<td>原子更新 int 值</td>
<td><code>get()</code>, <code>set()</code>, <code>getAndIncrement()</code>, <code>compareAndSet()</code></td>
</tr>
<tr>
<td><strong>AtomicLong</strong></td>
<td>原子更新 long 值</td>
<td>同上</td>
</tr>
<tr>
<td><strong>AtomicBoolean</strong></td>
<td>原子更新 boolean 值</td>
<td><code>get()</code>, <code>set()</code>, <code>compareAndSet()</code></td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AtomicInteger 基本用法</span><br><span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">counter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 原子递增，返回旧值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> counter.getAndIncrement();  <span class="hljs-comment">// 0</span><br><br><span class="hljs-comment">// 原子递增，返回新值</span><br><span class="hljs-type">int</span> <span class="hljs-variable">newValue</span> <span class="hljs-operator">=</span> counter.incrementAndGet();  <span class="hljs-comment">// 2</span><br><br><span class="hljs-comment">// CAS 操作</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> counter.compareAndSet(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment">// true, counter = 10</span><br><br><span class="hljs-comment">// 原子更新（Java 8+ lambda）</span><br><span class="hljs-type">int</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> counter.updateAndGet(x -&gt; x * <span class="hljs-number">2</span>);  <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure>
<h3 id="引用类型原子类">引用类型原子类</h3>
<table>
<thead>
<tr>
<th>类名</th>
<th>说明</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>AtomicReference&lt;V&gt;</strong></td>
<td>原子更新引用类型</td>
<td>需要原子更新对象引用</td>
</tr>
<tr>
<td><strong>AtomicStampedReference&lt;V&gt;</strong></td>
<td>带版本号的原子引用</td>
<td>解决 ABA 问题</td>
</tr>
<tr>
<td><strong>AtomicMarkableReference&lt;V&gt;</strong></td>
<td>带标记位的原子引用</td>
<td>需要标记状态的场景</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AtomicReference 基本用法</span><br>AtomicReference&lt;User&gt; userRef = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Alice&quot;</span>));<br><br><span class="hljs-type">User</span> <span class="hljs-variable">oldUser</span> <span class="hljs-operator">=</span> userRef.get();<br><span class="hljs-type">User</span> <span class="hljs-variable">newUser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;Bob&quot;</span>);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> userRef.compareAndSet(oldUser, newUser);<br></code></pre></td></tr></table></figure>
<h3 id="数组原子类">数组原子类</h3>
<p>数组原子类可以原子地更新数组中的某个元素：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AtomicIntegerArray 用法</span><br><span class="hljs-type">int</span>[] array = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;;<br><span class="hljs-type">AtomicIntegerArray</span> <span class="hljs-variable">atomicArray</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicIntegerArray</span>(array);<br><br><span class="hljs-comment">// 原子更新索引 2 的元素</span><br>atomicArray.getAndIncrement(<span class="hljs-number">2</span>);  <span class="hljs-comment">// array[2] = 4</span><br><br><span class="hljs-comment">// CAS 更新</span><br>atomicArray.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100</span>);  <span class="hljs-comment">// array[0] = 100</span><br></code></pre></td></tr></table></figure>
<h3 id="字段更新器">字段更新器</h3>
<p>字段更新器用于原子更新某个类的 volatile 字段，适用于无法修改类定义的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Account</span> &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> balance;  <span class="hljs-comment">// 必须是 volatile</span><br>    <br>    <span class="hljs-comment">// 创建字段更新器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> AtomicIntegerFieldUpdater&lt;Account&gt; BALANCE_UPDATER =<br>        AtomicIntegerFieldUpdater.newUpdater(Account.class, <span class="hljs-string">&quot;balance&quot;</span>);<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deposit</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;<br>        BALANCE_UPDATER.addAndGet(<span class="hljs-built_in">this</span>, amount);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">withdraw</span><span class="hljs-params">(<span class="hljs-type">int</span> amount)</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> balance;<br>            <span class="hljs-keyword">if</span> (current &lt; amount) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">if</span> (BALANCE_UPDATER.compareAndSet(<span class="hljs-built_in">this</span>, current, current - amount)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>字段更新器的限制：</strong></p>
<ul>
<li>字段必须是 <code>volatile</code> 修饰的</li>
<li>字段不能是 <code>static</code> 的（对于实例字段更新器）</li>
<li>字段不能是 <code>final</code> 的</li>
<li>字段的可见性必须允许更新器访问</li>
</ul>
<h2 id="aba-问题与解决方案">ABA 问题与解决方案</h2>
<h3 id="什么是-aba-问题">什么是 ABA 问题</h3>
<p>ABA 问题是 CAS 操作的一个经典问题：当一个值从 A 变成 B，再变回 A 时，CAS 操作无法检测到这个变化，仍然认为值没有被修改过。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 1
    participant V as 共享变量
    participant T2 as 线程 2
    
    Note over V: 初始值 = A
    
    T1-&gt;&gt;V: 读取值 A
    T1-&gt;&gt;T1: 准备 CAS(A → C)
    
    Note over T1: 线程 1 被挂起
    
    T2-&gt;&gt;V: CAS(A → B) 成功
    Note over V: 值 = B
    T2-&gt;&gt;V: CAS(B → A) 成功
    Note over V: 值 = A
    
    Note over T1: 线程 1 恢复
    T1-&gt;&gt;V: CAS(A → C) 成功！
    Note over V: 值 = C
    
    Note over T1,T2: 问题：线程 1 不知道值曾经被修改过</code></pre>
<h3 id="aba-问题的实际影响">ABA 问题的实际影响</h3>
<p>在大多数场景下，ABA 问题不会造成实际问题。但在某些场景下会导致严重错误：</p>
<p><strong>场景：无锁栈的 pop 操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无锁栈结构</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-type">int</span> value;<br>    Node next;<br>&#125;<br><br>AtomicReference&lt;Node&gt; top = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br><br><span class="hljs-comment">// 有 ABA 问题的 pop 实现</span><br><span class="hljs-keyword">public</span> Node <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>    Node oldTop, newTop;<br>    <span class="hljs-keyword">do</span> &#123;<br>        oldTop = top.get();<br>        <span class="hljs-keyword">if</span> (oldTop == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        newTop = oldTop.next;<br>    &#125; <span class="hljs-keyword">while</span> (!top.compareAndSet(oldTop, newTop));  <span class="hljs-comment">// ABA 问题！</span><br>    <span class="hljs-keyword">return</span> oldTop;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 1
    participant Stack as 栈 [A→B→C]
    participant T2 as 线程 2
    
    T1-&gt;&gt;Stack: pop() 读取 top=A, next=B
    Note over T1: 准备 CAS(A → B)
    
    Note over T1: 线程 1 被挂起
    
    T2-&gt;&gt;Stack: pop() 成功，栈变为 [B→C]
    T2-&gt;&gt;Stack: pop() 成功，栈变为 [C]
    T2-&gt;&gt;Stack: push(A)，栈变为 [A→C]
    Note over Stack: A 被重新使用，但 A.next 已变
    
    Note over T1: 线程 1 恢复
    T1-&gt;&gt;Stack: CAS(A → B) 成功！
    Note over Stack: 栈变为 [B→?]，B 已被释放！
    
    Note over T1,T2: 严重错误：栈结构被破坏</code></pre>
<h3 id="atomicstampedreference：版本号方案">AtomicStampedReference：版本号方案</h3>
<p><code>AtomicStampedReference</code> 通过维护一个版本号（stamp）来解决 ABA 问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建带版本号的原子引用</span><br>AtomicStampedReference&lt;String&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicStampedReference</span>&lt;&gt;(<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 获取当前值和版本号</span><br><span class="hljs-type">int</span>[] stampHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">1</span>];<br><span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> ref.get(stampHolder);<br><span class="hljs-type">int</span> <span class="hljs-variable">stamp</span> <span class="hljs-operator">=</span> stampHolder[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// CAS 时同时检查值和版本号</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> ref.compareAndSet(<br>    <span class="hljs-string">&quot;A&quot;</span>,      <span class="hljs-comment">// 期望的值</span><br>    <span class="hljs-string">&quot;B&quot;</span>,      <span class="hljs-comment">// 新值</span><br>    stamp,    <span class="hljs-comment">// 期望的版本号</span><br>    stamp + <span class="hljs-number">1</span> <span class="hljs-comment">// 新版本号</span><br>);<br></code></pre></td></tr></table></figure>
<p><strong>工作原理：</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;AtomicStampedReference 内部结构&quot;
        PAIR[&quot;Pair&amp;lt;V&amp;gt;&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;reference: V&lt;br/&gt;stamp: int&quot;]
        
        CAS[&quot;CAS 操作&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;同时比较 reference 和 stamp&lt;br/&gt;只有两者都匹配才更新&quot;]
        
        PAIR --&gt; CAS
    end
    
    style PAIR fill:#c8e6c9
    style CAS fill:#fff9c4</code></pre>
<h3 id="atomicmarkablereference：标记位方案">AtomicMarkableReference：标记位方案</h3>
<p><code>AtomicMarkableReference</code> 使用一个 boolean 标记位，适用于只需要知道&quot;是否被修改过&quot;的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建带标记位的原子引用</span><br>AtomicMarkableReference&lt;Node&gt; ref = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicMarkableReference</span>&lt;&gt;(node, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 获取当前值和标记</span><br><span class="hljs-type">boolean</span>[] markHolder = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[<span class="hljs-number">1</span>];<br><span class="hljs-type">Node</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> ref.get(markHolder);<br><span class="hljs-type">boolean</span> <span class="hljs-variable">marked</span> <span class="hljs-operator">=</span> markHolder[<span class="hljs-number">0</span>];<br><br><span class="hljs-comment">// CAS 时同时检查值和标记</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> ref.compareAndSet(<br>    node,   <span class="hljs-comment">// 期望的值</span><br>    newNode,<span class="hljs-comment">// 新值</span><br>    <span class="hljs-literal">false</span>,  <span class="hljs-comment">// 期望的标记</span><br>    <span class="hljs-literal">true</span>    <span class="hljs-comment">// 新标记</span><br>);<br></code></pre></td></tr></table></figure>
<h3 id="两种方案的对比">两种方案的对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>AtomicStampedReference</th>
<th>AtomicMarkableReference</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>额外信息</strong></td>
<td>int 版本号（可无限递增）</td>
<td>boolean 标记位</td>
</tr>
<tr>
<td><strong>检测能力</strong></td>
<td>可检测任意次数的修改</td>
<td>只能检测&quot;是否被修改过&quot;</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>较大（需要存储 int）</td>
<td>较小（只需 boolean）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>需要精确追踪修改次数</td>
<td>只需知道是否被修改</td>
</tr>
</tbody>
</table>
<h2 id="longadder：高并发累加器">LongAdder：高并发累加器</h2>
<h3 id="atomiclong-的性能瓶颈">AtomicLong 的性能瓶颈</h3>
<p>在高并发场景下，<code>AtomicLong</code> 的性能会急剧下降。原因是所有线程都在竞争同一个变量，CAS 失败率很高：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;AtomicLong 的竞争问题&quot;
        T1[&quot;线程 1&quot;] --&gt;|&quot;CAS&quot;| VALUE[&quot;value = 100&quot;]
        T2[&quot;线程 2&quot;] --&gt;|&quot;CAS&quot;| VALUE
        T3[&quot;线程 3&quot;] --&gt;|&quot;CAS&quot;| VALUE
        T4[&quot;线程 4&quot;] --&gt;|&quot;CAS&quot;| VALUE
        
        NOTE[&quot;问题：所有线程竞争同一个变量&lt;br/&gt;CAS 失败率高，大量自旋&quot;]
        
        style VALUE fill:#ffcdd2
        style NOTE fill:#fff9c4
    end</code></pre>
<h3 id="longadder-的分段累加策略">LongAdder 的分段累加策略</h3>
<p><code>LongAdder</code> 采用<strong>分段累加</strong>策略：将一个变量拆分成多个 Cell，不同线程更新不同的 Cell，最后汇总求和。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;LongAdder 的分段累加&quot;
        direction TB
        
        T1[&quot;线程 1&quot;] --&gt;|&quot;更新&quot;| C1[&quot;Cell[0]&lt;br/&gt;value = 25&quot;]
        T2[&quot;线程 2&quot;] --&gt;|&quot;更新&quot;| C2[&quot;Cell[1]&lt;br/&gt;value = 30&quot;]
        T3[&quot;线程 3&quot;] --&gt;|&quot;更新&quot;| C3[&quot;Cell[2]&lt;br/&gt;value = 20&quot;]
        T4[&quot;线程 4&quot;] --&gt;|&quot;更新&quot;| C4[&quot;Cell[3]&lt;br/&gt;value = 25&quot;]
        
        BASE[&quot;base = 0&quot;]
        
        SUM[&quot;sum() = base + Cell[0] + Cell[1] + Cell[2] + Cell[3]&lt;br/&gt;= 0 + 25 + 30 + 20 + 25 = 100&quot;]
        
        C1 --&gt; SUM
        C2 --&gt; SUM
        C3 --&gt; SUM
        C4 --&gt; SUM
        BASE --&gt; SUM
        
        style C1 fill:#c8e6c9
        style C2 fill:#c8e6c9
        style C3 fill:#c8e6c9
        style C4 fill:#c8e6c9
        style SUM fill:#fff9c4
    end</code></pre>
<h3 id="longadder-的内部结构">LongAdder 的内部结构</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LongAdder 继承自 Striped64</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Striped64</span> &#123;<br>    <span class="hljs-comment">// Cell 数组，长度为 2 的幂次</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Cell[] cells;<br>    <br>    <span class="hljs-comment">// 基础值，无竞争时直接更新这个值</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> base;<br>    <br>    <span class="hljs-comment">// Cell 数组初始化/扩容时的锁</span><br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> cellsBusy;<br>    <br>    <span class="hljs-comment">// Cell 类，使用 @Contended 避免伪共享</span><br>    <span class="hljs-meta">@sun</span>.misc.Contended<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Cell</span> &#123;<br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> value;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键设计：</strong></p>
<ol>
<li><strong>base 字段</strong>：无竞争时直接更新 base，避免创建 Cell 数组</li>
<li><strong>Cell 数组</strong>：竞争激烈时，不同线程更新不同的 Cell</li>
<li><strong>@Contended 注解</strong>：避免 Cell 之间的伪共享（False Sharing）</li>
<li><strong>动态扩容</strong>：Cell 数组会根据竞争程度动态扩容</li>
</ol>
<h3 id="longadder-的工作流程">LongAdder 的工作流程</h3>
<pre><code class="hljs mermaid">flowchart TB
    START[&quot;add(x)&quot;] --&gt; CHECK_CELLS&#123;&quot;cells == null?&quot;&#125;
    
    CHECK_CELLS --&gt;|&quot;是&quot;| CAS_BASE[&quot;CAS 更新 base&quot;]
    CAS_BASE --&gt;|&quot;成功&quot;| END[&quot;完成&quot;]
    CAS_BASE --&gt;|&quot;失败&quot;| INIT_CELLS[&quot;初始化 cells 数组&quot;]
    
    CHECK_CELLS --&gt;|&quot;否&quot;| GET_CELL[&quot;根据线程 hash 定位 Cell&quot;]
    GET_CELL --&gt; CAS_CELL[&quot;CAS 更新 Cell.value&quot;]
    CAS_CELL --&gt;|&quot;成功&quot;| END
    CAS_CELL --&gt;|&quot;失败&quot;| REHASH[&quot;重新 hash，尝试其他 Cell&quot;]
    REHASH --&gt; EXPAND&#123;&quot;需要扩容?&quot;&#125;
    EXPAND --&gt;|&quot;是&quot;| DO_EXPAND[&quot;扩容 cells 数组&quot;]
    EXPAND --&gt;|&quot;否&quot;| GET_CELL
    DO_EXPAND --&gt; GET_CELL
    
    INIT_CELLS --&gt; GET_CELL
    
    style START fill:#c8e6c9
    style END fill:#c8e6c9
    style CAS_BASE fill:#fff9c4
    style CAS_CELL fill:#fff9c4</code></pre>
<h3 id="性能对比">性能对比</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>AtomicLong</th>
<th>LongAdder</th>
<th>性能差异</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>低并发（1-2 线程）</strong></td>
<td>快</td>
<td>略慢</td>
<td>AtomicLong 更优</td>
</tr>
<tr>
<td><strong>中等并发（4-8 线程）</strong></td>
<td>较慢</td>
<td>快</td>
<td>LongAdder 2-3 倍</td>
</tr>
<tr>
<td><strong>高并发（16+ 线程）</strong></td>
<td>很慢</td>
<td>很快</td>
<td>LongAdder 10-15 倍</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 性能测试示例</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AdderBenchmark</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THREAD_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INCREMENT_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">10_000_000</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// AtomicLong 测试</span><br>        <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">atomicLong</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">atomicTime</span> <span class="hljs-operator">=</span> benchmark(() -&gt; atomicLong.incrementAndGet());<br>        <br>        <span class="hljs-comment">// LongAdder 测试</span><br>        <span class="hljs-type">LongAdder</span> <span class="hljs-variable">longAdder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAdder</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">adderTime</span> <span class="hljs-operator">=</span> benchmark(() -&gt; longAdder.increment());<br>        <br>        System.out.println(<span class="hljs-string">&quot;AtomicLong: &quot;</span> + atomicTime + <span class="hljs-string">&quot;ms&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;LongAdder: &quot;</span> + adderTime + <span class="hljs-string">&quot;ms&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Speedup: &quot;</span> + (<span class="hljs-type">double</span>) atomicTime / adderTime + <span class="hljs-string">&quot;x&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="longadder-vs-atomiclong：如何选择">LongAdder vs AtomicLong：如何选择</h3>
<table>
<thead>
<tr>
<th>考虑因素</th>
<th>选择 AtomicLong</th>
<th>选择 LongAdder</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>并发度</strong></td>
<td>低并发（&lt; 4 线程）</td>
<td>高并发（&gt; 8 线程）</td>
</tr>
<tr>
<td><strong>操作类型</strong></td>
<td>需要精确的当前值</td>
<td>只需要最终累加结果</td>
</tr>
<tr>
<td><strong>内存敏感</strong></td>
<td>内存受限</td>
<td>内存充足</td>
</tr>
<tr>
<td><strong>一致性要求</strong></td>
<td>需要强一致性</td>
<td>可接受最终一致性</td>
</tr>
</tbody>
</table>
<p><strong>注意事项：</strong></p>
<ul>
<li><code>LongAdder.sum()</code> 不是原子操作，在并发更新时可能返回不精确的值</li>
<li><code>LongAdder</code> 不支持 <code>compareAndSet</code> 操作</li>
<li>如果需要精确的当前值，应使用 <code>AtomicLong</code></li>
</ul>
<h3 id="longaccumulator：通用累加器">LongAccumulator：通用累加器</h3>
<p><code>LongAccumulator</code> 是 <code>LongAdder</code> 的通用版本，支持自定义累加函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建一个求最大值的累加器</span><br><span class="hljs-type">LongAccumulator</span> <span class="hljs-variable">maxAccumulator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LongAccumulator</span>(<br>    Long::max,  <span class="hljs-comment">// 累加函数</span><br>    Long.MIN_VALUE  <span class="hljs-comment">// 初始值</span><br>);<br><br><span class="hljs-comment">// 多线程更新</span><br>maxAccumulator.accumulate(<span class="hljs-number">100</span>);<br>maxAccumulator.accumulate(<span class="hljs-number">50</span>);<br>maxAccumulator.accumulate(<span class="hljs-number">200</span>);<br><br><span class="hljs-comment">// 获取结果</span><br><span class="hljs-type">long</span> <span class="hljs-variable">max</span> <span class="hljs-operator">=</span> maxAccumulator.get();  <span class="hljs-comment">// 200</span><br></code></pre></td></tr></table></figure>
<h2 id="java-9-的-varhandle">Java 9+ 的 VarHandle</h2>
<p>Java 9 引入了 <code>VarHandle</code>，作为 <code>Unsafe</code> 和原子类的替代方案，提供了更安全、更灵活的变量访问方式。</p>
<h3 id="varhandle-的优势">VarHandle 的优势</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>Unsafe</th>
<th>原子类</th>
<th>VarHandle</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>安全性</strong></td>
<td>不安全</td>
<td>安全</td>
<td>安全</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>最高</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>高</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td><strong>内存访问模式</strong></td>
<td>无</td>
<td>固定</td>
<td>可选</td>
</tr>
<tr>
<td><strong>官方支持</strong></td>
<td>不推荐</td>
<td>推荐</td>
<td>推荐</td>
</tr>
</tbody>
</table>
<h3 id="varhandle-的使用">VarHandle 的使用</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VarHandleExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> value;<br>    <br>    <span class="hljs-comment">// 获取 VarHandle</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> VarHandle VALUE_HANDLE;<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            VALUE_HANDLE = MethodHandles.lookup()<br>                .findVarHandle(VarHandleExample.class, <span class="hljs-string">&quot;value&quot;</span>, <span class="hljs-type">int</span>.class);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(e);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">increment</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// CAS 操作</span><br>        <span class="hljs-type">int</span> oldValue;<br>        <span class="hljs-keyword">do</span> &#123;<br>            oldValue = (<span class="hljs-type">int</span>) VALUE_HANDLE.getVolatile(<span class="hljs-built_in">this</span>);<br>        &#125; <span class="hljs-keyword">while</span> (!VALUE_HANDLE.compareAndSet(<span class="hljs-built_in">this</span>, oldValue, oldValue + <span class="hljs-number">1</span>));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) VALUE_HANDLE.getVolatile(<span class="hljs-built_in">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="varhandle-的内存访问模式">VarHandle 的内存访问模式</h3>
<p>VarHandle 提供了四种内存访问模式，对应不同的内存语义：</p>
<table>
<thead>
<tr>
<th>访问模式</th>
<th>方法</th>
<th>内存语义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Plain</strong></td>
<td><code>get()</code>, <code>set()</code></td>
<td>无内存屏障，最弱保证</td>
</tr>
<tr>
<td><strong>Opaque</strong></td>
<td><code>getOpaque()</code>, <code>setOpaque()</code></td>
<td>保证原子性，不保证顺序</td>
</tr>
<tr>
<td><strong>Acquire/Release</strong></td>
<td><code>getAcquire()</code>, <code>setRelease()</code></td>
<td>单向内存屏障</td>
</tr>
<tr>
<td><strong>Volatile</strong></td>
<td><code>getVolatile()</code>, <code>setVolatile()</code></td>
<td>完整的 volatile 语义</td>
</tr>
</tbody>
</table>
<h1>并发数据结构</h1>
<p><code>java.util.concurrent</code> 包提供了丰富的线程安全数据结构，它们采用不同的同步策略来实现线程安全。本节将按照实现机制对这些数据结构进行分类介绍。</p>
<h2 id="并发数据结构总览">并发数据结构总览</h2>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;java.util.concurrent 并发数据结构&quot;
        direction TB
        
        subgraph &quot;基于 AQS 的阻塞容器&quot;
            ABQ[&quot;ArrayBlockingQueue&quot;]
            LBQ[&quot;LinkedBlockingQueue&quot;]
            PBQ[&quot;PriorityBlockingQueue&quot;]
            DQ[&quot;DelayQueue&quot;]
            SQ[&quot;SynchronousQueue&quot;]
            LTQ[&quot;LinkedTransferQueue&quot;]
            LBD[&quot;LinkedBlockingDeque&quot;]
        end
        
        subgraph &quot;基于 CAS 的非阻塞容器&quot;
            CHM[&quot;ConcurrentHashMap&quot;]
            CSLM[&quot;ConcurrentSkipListMap&quot;]
            CSLS[&quot;ConcurrentSkipListSet&quot;]
            CLQ[&quot;ConcurrentLinkedQueue&quot;]
            CLD[&quot;ConcurrentLinkedDeque&quot;]
        end
        
        subgraph &quot;基于 Copy-On-Write 的容器&quot;
            COWAL[&quot;CopyOnWriteArrayList&quot;]
            COWAS[&quot;CopyOnWriteArraySet&quot;]
        end
        
        subgraph &quot;同步器&quot;
            CDL[&quot;CountDownLatch&quot;]
            CB[&quot;CyclicBarrier&quot;]
            SEM[&quot;Semaphore&quot;]
            PH[&quot;Phaser&quot;]
            EX[&quot;Exchanger&quot;]
        end
        
        subgraph &quot;Fork/Join 框架&quot;
            FJP[&quot;ForkJoinPool&quot;]
            FJT[&quot;ForkJoinTask&quot;]
            RA[&quot;RecursiveAction&quot;]
            RT[&quot;RecursiveTask&quot;]
            CC[&quot;CountedCompleter&quot;]
        end
        
        subgraph &quot;异步编程&quot;
            CF[&quot;CompletableFuture&quot;]
            FT[&quot;FutureTask&quot;]
        end
        
        style ABQ fill:#c8e6c9
        style LBQ fill:#c8e6c9
        style PBQ fill:#c8e6c9
        style DQ fill:#c8e6c9
        style SQ fill:#c8e6c9
        style LTQ fill:#c8e6c9
        style LBD fill:#c8e6c9
        
        style CHM fill:#fff9c4
        style CSLM fill:#fff9c4
        style CSLS fill:#fff9c4
        style CLQ fill:#fff9c4
        style CLD fill:#fff9c4
        
        style COWAL fill:#bbdefb
        style COWAS fill:#bbdefb
        
        style CDL fill:#ffcc80
        style CB fill:#ffcc80
        style SEM fill:#ffcc80
        style PH fill:#ffcc80
        style EX fill:#ffcc80
        
        style FJP fill:#e1bee7
        style FJT fill:#e1bee7
        style RA fill:#e1bee7
        style RT fill:#e1bee7
        style CC fill:#e1bee7
        
        style CF fill:#ffcdd2
        style FT fill:#ffcdd2
    end</code></pre>
<h2 id="基于-aqs-的阻塞容器">基于 AQS 的阻塞容器</h2>
<p>这类容器的阻塞操作（如 <code>put()</code>、<code>take()</code>）依赖 <code>ReentrantLock</code> + <code>Condition</code> 实现，而 <code>ReentrantLock</code> 基于 AQS。</p>
<h3 id="blockingqueue-接口体系">BlockingQueue 接口体系</h3>
<table>
<thead>
<tr>
<th>类名</th>
<th>底层结构</th>
<th>有界性</th>
<th>锁策略</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ArrayBlockingQueue</strong></td>
<td>数组</td>
<td>有界</td>
<td>单锁</td>
<td>FIFO，支持公平/非公平</td>
</tr>
<tr>
<td><strong>LinkedBlockingQueue</strong></td>
<td>链表</td>
<td>可选</td>
<td>双锁（读写分离）</td>
<td>高吞吐，默认无界</td>
</tr>
<tr>
<td><strong>PriorityBlockingQueue</strong></td>
<td>堆</td>
<td>无界</td>
<td>单锁</td>
<td>优先级排序</td>
</tr>
<tr>
<td><strong>DelayQueue</strong></td>
<td>堆</td>
<td>无界</td>
<td>单锁</td>
<td>延迟元素，需实现 Delayed</td>
</tr>
<tr>
<td><strong>SynchronousQueue</strong></td>
<td>无存储</td>
<td>零容量</td>
<td>无锁/CAS</td>
<td>直接传递，生产者等待消费者</td>
</tr>
<tr>
<td><strong>LinkedTransferQueue</strong></td>
<td>链表</td>
<td>无界</td>
<td>无锁/CAS</td>
<td>支持 transfer()，Java 7+</td>
</tr>
</tbody>
</table>
<h4 id="arrayblockingqueue-vs-linkedblockingqueue">ArrayBlockingQueue vs LinkedBlockingQueue</h4>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;ArrayBlockingQueue&quot;
        direction TB
        ABQ_LOCK[&quot;单个 ReentrantLock&quot;]
        ABQ_ARR[&quot;Object[] items&quot;]
        ABQ_PUT[&quot;notFull Condition&quot;]
        ABQ_TAKE[&quot;notEmpty Condition&quot;]
        
        ABQ_LOCK --&gt; ABQ_ARR
        ABQ_LOCK --&gt; ABQ_PUT
        ABQ_LOCK --&gt; ABQ_TAKE
        
        style ABQ_LOCK fill:#ffcdd2
    end
    
    subgraph &quot;LinkedBlockingQueue&quot;
        direction TB
        LBQ_PLOCK[&quot;putLock&quot;]
        LBQ_TLOCK[&quot;takeLock&quot;]
        LBQ_HEAD[&quot;head&quot;]
        LBQ_TAIL[&quot;tail&quot;]
        
        LBQ_PLOCK --&gt; LBQ_TAIL
        LBQ_TLOCK --&gt; LBQ_HEAD
        
        style LBQ_PLOCK fill:#c8e6c9
        style LBQ_TLOCK fill:#c8e6c9
    end</code></pre>
<p><strong>选择建议：</strong></p>
<ul>
<li><strong>ArrayBlockingQueue</strong>：容量固定，内存占用可控，适合资源受限场景</li>
<li><strong>LinkedBlockingQueue</strong>：读写分离锁，吞吐量更高，适合高并发场景</li>
</ul>
<h4 id="synchronousqueue：零容量队列">SynchronousQueue：零容量队列</h4>
<p><code>SynchronousQueue</code> 不存储任何元素，每个 <code>put()</code> 必须等待一个 <code>take()</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">SynchronousQueue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SynchronousQueue</span>&lt;&gt;();<br><br><span class="hljs-comment">// 生产者线程</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        queue.put(<span class="hljs-string">&quot;data&quot;</span>);  <span class="hljs-comment">// 阻塞，直到有消费者</span><br>        System.out.println(<span class="hljs-string">&quot;Data sent&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>&#125;).start();<br><br><span class="hljs-comment">// 消费者线程</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> queue.take();  <span class="hljs-comment">// 阻塞，直到有生产者</span><br>        System.out.println(<span class="hljs-string">&quot;Received: &quot;</span> + data);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p><strong>适用场景：</strong></p>
<ul>
<li>线程间直接传递数据</li>
<li><code>Executors.newCachedThreadPool()</code> 使用 SynchronousQueue</li>
</ul>
<h4 id="delayqueue：延迟队列">DelayQueue：延迟队列</h4>
<p><code>DelayQueue</code> 中的元素必须实现 <code>Delayed</code> 接口，只有到期的元素才能被取出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DelayedTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Delayed</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> expireTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DelayedTask</span><span class="hljs-params">(String name, <span class="hljs-type">long</span> delayMs)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.expireTime = System.currentTimeMillis() + delayMs;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> &#123;<br>        <span class="hljs-keyword">return</span> unit.convert(expireTime - System.currentTimeMillis(), TimeUnit.MILLISECONDS);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Delayed o)</span> &#123;<br>        <span class="hljs-keyword">return</span> Long.compare(<span class="hljs-built_in">this</span>.expireTime, ((DelayedTask) o).expireTime);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用示例</span><br>DelayQueue&lt;DelayedTask&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayQueue</span>&lt;&gt;();<br>queue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedTask</span>(<span class="hljs-string">&quot;Task1&quot;</span>, <span class="hljs-number">5000</span>));  <span class="hljs-comment">// 5秒后到期</span><br>queue.put(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelayedTask</span>(<span class="hljs-string">&quot;Task2&quot;</span>, <span class="hljs-number">2000</span>));  <span class="hljs-comment">// 2秒后到期</span><br><br><span class="hljs-type">DelayedTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> queue.take();  <span class="hljs-comment">// 阻塞，2秒后返回 Task2</span><br></code></pre></td></tr></table></figure>
<p><strong>适用场景：</strong></p>
<ul>
<li>定时任务调度</li>
<li>缓存过期处理</li>
<li>订单超时取消</li>
</ul>
<h3 id="blockingdeque-接口">BlockingDeque 接口</h3>
<p><code>LinkedBlockingDeque</code> 是唯一的 <code>BlockingDeque</code> 实现，支持双端操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">LinkedBlockingDeque&lt;String&gt; deque = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingDeque</span>&lt;&gt;(<span class="hljs-number">100</span>);<br><br><span class="hljs-comment">// 队首操作</span><br>deque.putFirst(<span class="hljs-string">&quot;first&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> deque.takeFirst();<br><br><span class="hljs-comment">// 队尾操作</span><br>deque.putLast(<span class="hljs-string">&quot;last&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> deque.takeLast();<br></code></pre></td></tr></table></figure>
<p><strong>适用场景：</strong></p>
<ul>
<li>工作窃取（Work Stealing）模式</li>
<li>需要 LIFO 和 FIFO 混合操作的场景</li>
</ul>
<h2 id="基于-cas-的非阻塞容器">基于 CAS 的非阻塞容器</h2>
<p>这类容器使用 CAS 操作实现线程安全，不会阻塞线程，适合高并发读写场景。</p>
<h3 id="concurrenthashmap">ConcurrentHashMap</h3>
<p><code>ConcurrentHashMap</code> 是最常用的并发 Map 实现，其实现在不同 Java 版本有显著变化：</p>
<table>
<thead>
<tr>
<th>版本</th>
<th>实现方式</th>
<th>锁粒度</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Java 7</strong></td>
<td>分段锁（Segment）</td>
<td>16 个段，每段一把锁</td>
</tr>
<tr>
<td><strong>Java 8+</strong></td>
<td>CAS + synchronized</td>
<td>Node 级别，更细粒度</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Java 7: 分段锁&quot;
        direction TB
        SEG0[&quot;Segment[0]&lt;br/&gt;ReentrantLock&quot;]
        SEG1[&quot;Segment[1]&lt;br/&gt;ReentrantLock&quot;]
        SEGN[&quot;Segment[15]&lt;br/&gt;ReentrantLock&quot;]
        
        SEG0 --&gt; HASH0[&quot;HashEntry[]&quot;]
        SEG1 --&gt; HASH1[&quot;HashEntry[]&quot;]
        SEGN --&gt; HASHN[&quot;HashEntry[]&quot;]
        
        style SEG0 fill:#ffcdd2
        style SEG1 fill:#ffcdd2
        style SEGN fill:#ffcdd2
    end
    
    subgraph &quot;Java 8+: CAS + synchronized&quot;
        direction TB
        TABLE[&quot;Node[] table&quot;]
        
        NODE0[&quot;Node&lt;br/&gt;synchronized&quot;]
        NODE1[&quot;Node&lt;br/&gt;synchronized&quot;]
        NODEN[&quot;Node&lt;br/&gt;synchronized&quot;]
        
        TABLE --&gt; NODE0
        TABLE --&gt; NODE1
        TABLE --&gt; NODEN
        
        CAS[&quot;CAS 操作&lt;br/&gt;用于插入首节点&quot;]
        
        style NODE0 fill:#c8e6c9
        style NODE1 fill:#c8e6c9
        style NODEN fill:#c8e6c9
        style CAS fill:#fff9c4
    end</code></pre>
<p><strong>Java 8+ 的关键优化：</strong></p>
<ol>
<li><strong>取消分段锁</strong>：锁粒度从 Segment 级别细化到 Node 级别</li>
<li><strong>CAS 插入首节点</strong>：桶为空时使用 CAS 插入，无需加锁</li>
<li><strong>synchronized 锁链表头</strong>：桶非空时，只锁链表头节点</li>
<li><strong>红黑树优化</strong>：链表长度超过 8 时转为红黑树</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConcurrentHashMap 常用操作</span><br>ConcurrentHashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br><span class="hljs-comment">// 原子操作</span><br>map.putIfAbsent(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1</span>);<br>map.computeIfAbsent(<span class="hljs-string">&quot;key&quot;</span>, k -&gt; expensiveComputation(k));<br>map.merge(<span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-number">1</span>, Integer::sum);<br><br><span class="hljs-comment">// Java 8+ 批量操作</span><br>map.forEach(<span class="hljs-number">1</span>, (k, v) -&gt; System.out.println(k + <span class="hljs-string">&quot;=&quot;</span> + v));<br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> map.reduceValues(<span class="hljs-number">1</span>, v -&gt; v &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">1L</span> : <span class="hljs-number">0L</span>, Long::sum);<br></code></pre></td></tr></table></figure>
<h3 id="concurrentskiplistmap-concurrentskiplistset">ConcurrentSkipListMap / ConcurrentSkipListSet</h3>
<p>基于**跳表（Skip List）**实现的有序并发容器：</p>
<h4 id="concurrenthashmap-的-size-与-mappingcount">ConcurrentHashMap 的 size() 与 mappingCount()</h4>
<p><code>ConcurrentHashMap</code> 提供两种获取元素数量的方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>size()</code></td>
<td>int</td>
<td>返回元素数量，最大值为 Integer.MAX_VALUE</td>
</tr>
<tr>
<td><code>mappingCount()</code></td>
<td>long</td>
<td>Java 8+ 新增，返回 long 类型，适合大容量场景</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">ConcurrentHashMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><span class="hljs-comment">// 当元素数量超过 Integer.MAX_VALUE 时</span><br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> map.size();           <span class="hljs-comment">// 可能溢出，返回 Integer.MAX_VALUE</span><br><span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> map.mappingCount(); <span class="hljs-comment">// 返回准确的 long 值</span><br></code></pre></td></tr></table></figure>
<h3 id="concurrentskiplistmap-set">ConcurrentSkipListMap/Set</h3>
<p><code>ConcurrentSkipListMap</code> 是基于跳表（Skip List）实现的并发有序 Map，<code>ConcurrentSkipListSet</code> 基于它实现。</p>
<h4 id="跳表结构">跳表结构</h4>
<p>跳表是一种基于链表的数据结构，通过多层索引实现 O(log n) 的查找效率：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;跳表结构示意&quot;
        direction LR
        
        subgraph &quot;Level 3&quot;
            L3_HEAD[&quot;HEAD&quot;] --&gt; L3_30[&quot;30&quot;] --&gt; L3_NIL[&quot;NIL&quot;]
        end
        
        subgraph &quot;Level 2&quot;
            L2_HEAD[&quot;HEAD&quot;] --&gt; L2_10[&quot;10&quot;] --&gt; L2_30[&quot;30&quot;] --&gt; L2_50[&quot;50&quot;] --&gt; L2_NIL[&quot;NIL&quot;]
        end
        
        subgraph &quot;Level 1&quot;
            L1_HEAD[&quot;HEAD&quot;] --&gt; L1_10[&quot;10&quot;] --&gt; L1_20[&quot;20&quot;] --&gt; L1_30[&quot;30&quot;] --&gt; L1_40[&quot;40&quot;] --&gt; L1_50[&quot;50&quot;] --&gt; L1_NIL[&quot;NIL&quot;]
        end
        
        subgraph &quot;Level 0 (底层链表)&quot;
            L0_HEAD[&quot;HEAD&quot;] --&gt; L0_5[&quot;5&quot;] --&gt; L0_10[&quot;10&quot;] --&gt; L0_15[&quot;15&quot;] --&gt; L0_20[&quot;20&quot;] --&gt; L0_25[&quot;25&quot;] --&gt; L0_30[&quot;30&quot;] --&gt; L0_35[&quot;35&quot;] --&gt; L0_40[&quot;40&quot;] --&gt; L0_45[&quot;45&quot;] --&gt; L0_50[&quot;50&quot;] --&gt; L0_NIL[&quot;NIL&quot;]
        end
        
        L3_30 -.-&gt; L2_30
        L2_10 -.-&gt; L1_10
        L2_30 -.-&gt; L1_30
        L2_50 -.-&gt; L1_50
        L1_10 -.-&gt; L0_10
        L1_20 -.-&gt; L0_20
        L1_30 -.-&gt; L0_30
        L1_40 -.-&gt; L0_40
        L1_50 -.-&gt; L0_50
    end</code></pre>
<p><strong>跳表 vs 红黑树：</strong></p>
<table>
<thead>
<tr>
<th>特性</th>
<th>跳表</th>
<th>红黑树</th>
</tr>
</thead>
<tbody>
<tr>
<td>时间复杂度</td>
<td>O(log n) 平均</td>
<td>O(log n) 最坏</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>简单</td>
<td>复杂</td>
</tr>
<tr>
<td>并发友好性</td>
<td>高（局部锁）</td>
<td>低（需要全局锁）</td>
</tr>
<tr>
<td>范围查询</td>
<td>高效</td>
<td>需要中序遍历</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">ConcurrentSkipListMap&lt;String, Integer&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentSkipListMap</span>&lt;&gt;();<br>map.put(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-number">1</span>);<br>map.put(<span class="hljs-string">&quot;banana&quot;</span>, <span class="hljs-number">2</span>);<br>map.put(<span class="hljs-string">&quot;cherry&quot;</span>, <span class="hljs-number">3</span>);<br><br><span class="hljs-comment">// 有序遍历</span><br>map.forEach((k, v) -&gt; System.out.println(k + <span class="hljs-string">&quot;=&quot;</span> + v));<br><br><span class="hljs-comment">// 范围查询</span><br>SortedMap&lt;String, Integer&gt; subMap = map.subMap(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;cherry&quot;</span>);<br><br><span class="hljs-comment">// 导航方法</span><br><span class="hljs-type">String</span> <span class="hljs-variable">firstKey</span> <span class="hljs-operator">=</span> map.firstKey();      <span class="hljs-comment">// &quot;apple&quot;</span><br><span class="hljs-type">String</span> <span class="hljs-variable">higherKey</span> <span class="hljs-operator">=</span> map.higherKey(<span class="hljs-string">&quot;banana&quot;</span>);  <span class="hljs-comment">// &quot;cherry&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="concurrentlinkedqueue-concurrentlinkeddeque">ConcurrentLinkedQueue / ConcurrentLinkedDeque</h3>
<p>基于 <strong>Michael-Scott 算法</strong> 实现的无锁并发队列：</p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;ConcurrentLinkedQueue 结构&quot;
        HEAD[&quot;head&lt;br/&gt;(volatile)&quot;] --&gt; N1[&quot;Node 1&quot;]
        N1 --&gt; N2[&quot;Node 2&quot;]
        N2 --&gt; N3[&quot;Node 3&quot;]
        N3 --&gt; TAIL[&quot;tail&lt;br/&gt;(volatile)&quot;]
        
        style HEAD fill:#c8e6c9
        style TAIL fill:#c8e6c9
    end</code></pre>
<p><strong>Michael-Scott 算法特点：</strong></p>
<ol>
<li><strong>两阶段入队</strong>：先 CAS 更新 tail.next，再 CAS 更新 tail</li>
<li><strong>惰性更新 tail</strong>：tail 可能落后于实际尾节点</li>
<li><strong>无锁设计</strong>：所有操作通过 CAS 完成</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">ConcurrentLinkedQueue&lt;String&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentLinkedQueue</span>&lt;&gt;();<br><br><span class="hljs-comment">// 入队（永不阻塞）</span><br>queue.offer(<span class="hljs-string">&quot;item1&quot;</span>);<br>queue.add(<span class="hljs-string">&quot;item2&quot;</span>);<br><br><span class="hljs-comment">// 出队（返回 null 而非阻塞）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> queue.poll();  <span class="hljs-comment">// 可能返回 null</span><br><br><span class="hljs-comment">// 查看队首（不移除）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">head</span> <span class="hljs-operator">=</span> queue.peek();<br></code></pre></td></tr></table></figure>
<p><strong>ConcurrentLinkedDeque</strong> 是双端版本，支持 <code>addFirst()</code>、<code>addLast()</code>、<code>pollFirst()</code>、<code>pollLast()</code> 等操作。</p>
<h2 id="基于-copy-on-write-的容器">基于 Copy-On-Write 的容器</h2>
<p>Copy-On-Write（写时复制）容器在写操作时复制整个底层数组，读操作无需加锁。</p>
<h3 id="copyonwritearraylist">CopyOnWriteArrayList</h3>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;写操作过程&quot;
        direction TB
        
        ORIG[&quot;原数组&lt;br/&gt;[A, B, C]&quot;]
        COPY[&quot;复制数组&lt;br/&gt;[A, B, C]&quot;]
        NEW[&quot;修改后&lt;br/&gt;[A, B, C, D]&quot;]
        REF[&quot;array 引用&quot;]
        
        ORIG --&gt; |&quot;1. 复制&quot;| COPY
        COPY --&gt; |&quot;2. 修改&quot;| NEW
        REF --&gt; |&quot;3. 原子替换&quot;| NEW
        
        style ORIG fill:#ffcdd2
        style NEW fill:#c8e6c9
    end</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">CopyOnWriteArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br><br><span class="hljs-comment">// 写操作（加锁 + 复制数组）</span><br>list.add(<span class="hljs-string">&quot;item&quot;</span>);<br><br><span class="hljs-comment">// 读操作（无锁，直接读取当前数组）</span><br><span class="hljs-type">String</span> <span class="hljs-variable">item</span> <span class="hljs-operator">=</span> list.get(<span class="hljs-number">0</span>);<br><br><span class="hljs-comment">// 迭代器是快照，不会抛出 ConcurrentModificationException</span><br><span class="hljs-keyword">for</span> (String s : list) &#123;<br>    list.add(<span class="hljs-string">&quot;new item&quot;</span>);  <span class="hljs-comment">// 安全，但迭代器看不到新元素</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="copyonwritearrayset">CopyOnWriteArraySet</h3>
<p><code>CopyOnWriteArraySet</code> 基于 <code>CopyOnWriteArrayList</code> 实现，通过 <code>addIfAbsent()</code> 保证元素唯一性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">CopyOnWriteArraySet&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArraySet</span>&lt;&gt;();<br>set.add(<span class="hljs-string">&quot;item1&quot;</span>);<br>set.add(<span class="hljs-string">&quot;item1&quot;</span>);  <span class="hljs-comment">// 不会重复添加</span><br>System.out.println(set.size());  <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>
<p><strong>适用场景：</strong></p>
<ul>
<li>读多写少（读写比例 &gt; 10:1）</li>
<li>数据量较小（复制成本可接受）</li>
<li>需要迭代器弱一致性（不抛出 ConcurrentModificationException）</li>
</ul>
<p><strong>不适用场景：</strong></p>
<ul>
<li>写操作频繁</li>
<li>数据量大（复制成本高）</li>
<li>需要强一致性迭代</li>
</ul>
<h2 id="同步器">同步器</h2>
<h3 id="phaser：多阶段屏障">Phaser：多阶段屏障</h3>
<p><code>Phaser</code> 是 Java 7 引入的灵活同步器，可以看作 <code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 的增强版：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
<th>Phaser</th>
</tr>
</thead>
<tbody>
<tr>
<td>可重用</td>
<td>否</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>动态参与者</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>多阶段</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>层次结构</td>
<td>否</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Phaser</span> <span class="hljs-variable">phaser</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Phaser</span>(<span class="hljs-number">3</span>);  <span class="hljs-comment">// 3 个参与者</span><br><br><span class="hljs-comment">// 动态注册/注销</span><br>phaser.register();      <span class="hljs-comment">// 增加参与者</span><br>phaser.arriveAndDeregister();  <span class="hljs-comment">// 到达并注销</span><br><br><span class="hljs-comment">// 多阶段同步</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">phase</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; phase &lt; <span class="hljs-number">3</span>; phase++) &#123;<br>    <span class="hljs-comment">// 执行本阶段任务</span><br>    doPhaseWork(phase);<br>    <br>    <span class="hljs-comment">// 等待所有参与者完成本阶段</span><br>    phaser.arriveAndAwaitAdvance();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Phaser 状态机：</strong></p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; Phase0: 初始化
    Phase0 --&gt; Phase1: 所有参与者到达
    Phase1 --&gt; Phase2: 所有参与者到达
    Phase2 --&gt; Phase0: 所有参与者到达（循环）
    Phase0 --&gt; Terminated: onAdvance() 返回 true
    Phase1 --&gt; Terminated: onAdvance() 返回 true
    Phase2 --&gt; Terminated: onAdvance() 返回 true</code></pre>
<h3 id="exchanger：线程间数据交换">Exchanger：线程间数据交换</h3>
<p><code>Exchanger</code> 用于两个线程之间交换数据：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">Exchanger&lt;String&gt; exchanger = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exchanger</span>&lt;&gt;();<br><br><span class="hljs-comment">// 线程 A</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dataFromB</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;Data from A&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;A received: &quot;</span> + dataFromB);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>&#125;).start();<br><br><span class="hljs-comment">// 线程 B</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">dataFromA</span> <span class="hljs-operator">=</span> exchanger.exchange(<span class="hljs-string">&quot;Data from B&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;B received: &quot;</span> + dataFromA);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p><strong>适用场景：</strong></p>
<ul>
<li>遗传算法中的基因交换</li>
<li>流水线设计中的数据传递</li>
<li>双缓冲技术</li>
</ul>
<h2 id="fork-join-框架">Fork/Join 框架</h2>
<p>Fork/Join 框架是 Java 7 引入的并行计算框架，采用<strong>分治策略</strong>和<strong>工作窃取算法</strong>。</p>
<h3 id="工作窃取算法">工作窃取算法</h3>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;工作窃取示意&quot;
        direction TB
        
        subgraph &quot;Worker 1 (忙碌)&quot;
            W1_DEQUE[&quot;双端队列&quot;]
            W1_T1[&quot;Task 1&quot;]
            W1_T2[&quot;Task 2&quot;]
            W1_T3[&quot;Task 3&quot;]
            W1_DEQUE --&gt; W1_T1
            W1_T1 --&gt; W1_T2
            W1_T2 --&gt; W1_T3
        end
        
        subgraph &quot;Worker 2 (空闲)&quot;
            W2_DEQUE[&quot;双端队列&quot;]
            W2_EMPTY[&quot;(空)&quot;]
            W2_DEQUE --&gt; W2_EMPTY
        end
        
        W1_T3 -.-&gt; |&quot;窃取&quot;| W2_DEQUE
        
        style W1_T3 fill:#ffcdd2
        style W2_EMPTY fill:#c8e6c9
    end</code></pre>
<p><strong>工作窃取特点：</strong></p>
<ol>
<li>每个工作线程有自己的双端队列</li>
<li>工作线程从队列<strong>头部</strong>取任务（LIFO）</li>
<li>空闲线程从其他队列<strong>尾部</strong>窃取任务（FIFO）</li>
<li>减少竞争，提高并行效率</li>
</ol>
<h3 id="forkjoinpool">ForkJoinPool</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 ForkJoinPool</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ForkJoinPool.commonPool();  <span class="hljs-comment">// 公共池</span><br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">customPool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ForkJoinPool</span>(<span class="hljs-number">4</span>);  <span class="hljs-comment">// 自定义并行度</span><br><br><span class="hljs-comment">// 提交任务</span><br>pool.submit(task);<br>pool.invoke(task);  <span class="hljs-comment">// 同步等待结果</span><br></code></pre></td></tr></table></figure>
<h3 id="recursiveaction-vs-recursivetask">RecursiveAction vs RecursiveTask</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>返回值</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RecursiveAction</strong></td>
<td>void</td>
<td>无返回值的并行任务（如并行排序）</td>
</tr>
<tr>
<td><strong>RecursiveTask<V></strong></td>
<td>V</td>
<td>有返回值的并行任务（如并行求和）</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// RecursiveTask 示例：并行求和</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SumTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">RecursiveTask</span>&lt;Long&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">THRESHOLD</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>[] array;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> start, end;<br>    <br>    SumTask(<span class="hljs-type">long</span>[] array, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end) &#123;<br>        <span class="hljs-built_in">this</span>.array = array;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Long <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (end - start &lt;= THRESHOLD) &#123;<br>            <span class="hljs-comment">// 直接计算</span><br>            <span class="hljs-type">long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; i++) &#123;<br>                sum += array[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 分治</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">SumTask</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SumTask</span>(array, start, mid);<br>            <span class="hljs-type">SumTask</span> <span class="hljs-variable">right</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SumTask</span>(array, mid, end);<br>            <br>            left.fork();  <span class="hljs-comment">// 异步执行左半部分</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">rightResult</span> <span class="hljs-operator">=</span> right.compute();  <span class="hljs-comment">// 同步执行右半部分</span><br>            <span class="hljs-type">Long</span> <span class="hljs-variable">leftResult</span> <span class="hljs-operator">=</span> left.join();  <span class="hljs-comment">// 等待左半部分结果</span><br>            <br>            <span class="hljs-keyword">return</span> leftResult + rightResult;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 使用</span><br><span class="hljs-type">long</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">long</span>[<span class="hljs-number">10000</span>];<br><span class="hljs-type">ForkJoinPool</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> ForkJoinPool.commonPool();<br><span class="hljs-type">Long</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> pool.invoke(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SumTask</span>(array, <span class="hljs-number">0</span>, array.length));<br></code></pre></td></tr></table></figure>
<h3 id="countedcompleter">CountedCompleter</h3>
<p><code>CountedCompleter</code> 是 Java 8 引入的抽象类，适合处理<strong>异步完成</strong>的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SearchTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CountedCompleter</span>&lt;String&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String[] data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> start, end;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String target;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> String result;<br>    <br>    SearchTask(CountedCompleter&lt;?&gt; parent, String[] data, <span class="hljs-type">int</span> start, <span class="hljs-type">int</span> end, String target) &#123;<br>        <span class="hljs-built_in">super</span>(parent);<br>        <span class="hljs-built_in">this</span>.data = data;<br>        <span class="hljs-built_in">this</span>.start = start;<br>        <span class="hljs-built_in">this</span>.end = end;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">compute</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (end - start &lt; <span class="hljs-number">100</span>) &#123;<br>            <span class="hljs-comment">// 直接搜索</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> start; i &lt; end; i++) &#123;<br>                <span class="hljs-keyword">if</span> (target.equals(data[i])) &#123;<br>                    result = data[i];<br>                    quietlyCompleteRoot();  <span class="hljs-comment">// 找到后立即完成整个任务树</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            tryComplete();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (start + end) / <span class="hljs-number">2</span>;<br>            addToPendingCount(<span class="hljs-number">2</span>);  <span class="hljs-comment">// 增加待完成计数</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchTask</span>(<span class="hljs-built_in">this</span>, data, start, mid, target).fork();<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">SearchTask</span>(<span class="hljs-built_in">this</span>, data, mid, end, target).fork();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="异步编程工具">异步编程工具</h2>
<h3 id="completablefuture">CompletableFuture</h3>
<p><code>CompletableFuture</code> 是 Java 8 引入的异步编程工具，支持链式调用和组合操作：</p>
<h4 id="创建方式">创建方式</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>supplyAsync(Supplier)</code></td>
<td>异步执行有返回值的任务</td>
</tr>
<tr>
<td><code>runAsync(Runnable)</code></td>
<td>异步执行无返回值的任务</td>
</tr>
<tr>
<td><code>completedFuture(value)</code></td>
<td>创建已完成的 Future</td>
</tr>
</tbody>
</table>
<h4 id="转换操作">转换操作</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>thenApply(Function)</code></td>
<td>同步转换结果</td>
</tr>
<tr>
<td><code>thenApplyAsync(Function)</code></td>
<td>异步转换结果</td>
</tr>
<tr>
<td><code>thenCompose(Function)</code></td>
<td>扁平化嵌套的 CompletableFuture</td>
</tr>
</tbody>
</table>
<h4 id="消费操作">消费操作</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>thenAccept(Consumer)</code></td>
<td>消费结果，无返回值</td>
</tr>
<tr>
<td><code>thenRun(Runnable)</code></td>
<td>执行动作，不使用结果</td>
</tr>
</tbody>
</table>
<h4 id="组合操作">组合操作</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>thenCombine(other, BiFunction)</code></td>
<td>合并两个 Future 的结果</td>
</tr>
<tr>
<td><code>allOf(futures...)</code></td>
<td>等待所有 Future 完成</td>
</tr>
<tr>
<td><code>anyOf(futures...)</code></td>
<td>等待任一 Future 完成</td>
</tr>
</tbody>
</table>
<h4 id="异常处理">异常处理</h4>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>exceptionally(Function)</code></td>
<td>处理异常，返回默认值</td>
</tr>
<tr>
<td><code>handle(BiFunction)</code></td>
<td>同时处理结果和异常</td>
</tr>
<tr>
<td><code>whenComplete(BiConsumer)</code></td>
<td>完成时回调（不改变结果）</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture&lt;String&gt; future = CompletableFuture<br>    .supplyAsync(() -&gt; fetchData())<br>    .thenApply(data -&gt; process(data))<br>    .thenCompose(result -&gt; saveAsync(result))<br>    .exceptionally(ex -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Error&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;default&quot;</span>;<br>    &#125;);<br><br><span class="hljs-comment">// 组合多个 Future</span><br>CompletableFuture&lt;Void&gt; all = CompletableFuture.allOf(future1, future2, future3);<br>all.thenRun(() -&gt; System.out.println(<span class="hljs-string">&quot;All completed&quot;</span>));<br></code></pre></td></tr></table></figure>
<h3 id="futuretask">FutureTask</h3>
<p><code>FutureTask</code> 是 <code>Future</code> 接口的基本实现，可以包装 <code>Callable</code> 或 <code>Runnable</code>：</p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; NEW: 创建
    NEW --&gt; COMPLETING: 任务执行完成
    NEW --&gt; CANCELLED: cancel(false)
    NEW --&gt; INTERRUPTING: cancel(true)
    COMPLETING --&gt; NORMAL: 设置结果成功
    COMPLETING --&gt; EXCEPTIONAL: 设置异常
    INTERRUPTING --&gt; INTERRUPTED: 中断完成
    
    NORMAL --&gt; [*]
    EXCEPTIONAL --&gt; [*]
    CANCELLED --&gt; [*]
    INTERRUPTED --&gt; [*]</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建 FutureTask</span><br>FutureTask&lt;String&gt; task = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(() -&gt; &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result&quot;</span>;<br>&#125;);<br><br><span class="hljs-comment">// 提交执行</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(task).start();<br><span class="hljs-comment">// 或</span><br>executor.submit(task);<br><br><span class="hljs-comment">// 获取结果</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> task.get();  <span class="hljs-comment">// 阻塞等待</span><br><span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> task.get(<span class="hljs-number">1</span>, TimeUnit.SECONDS);  <span class="hljs-comment">// 超时等待</span><br><br><span class="hljs-comment">// 取消任务</span><br>task.cancel(<span class="hljs-literal">true</span>);  <span class="hljs-comment">// mayInterruptIfRunning</span><br></code></pre></td></tr></table></figure>
<p><strong>FutureTask 状态常量：</strong></p>
<table>
<thead>
<tr>
<th>状态</th>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>NEW</td>
<td>0</td>
<td>初始状态</td>
</tr>
<tr>
<td>COMPLETING</td>
<td>1</td>
<td>正在设置结果</td>
</tr>
<tr>
<td>NORMAL</td>
<td>2</td>
<td>正常完成</td>
</tr>
<tr>
<td>EXCEPTIONAL</td>
<td>3</td>
<td>异常完成</td>
</tr>
<tr>
<td>CANCELLED</td>
<td>4</td>
<td>已取消</td>
</tr>
<tr>
<td>INTERRUPTING</td>
<td>5</td>
<td>正在中断</td>
</tr>
<tr>
<td>INTERRUPTED</td>
<td>6</td>
<td>已中断</td>
</tr>
</tbody>
</table>
<p><img src="juc-class-diagram.png" alt="juc-class-diagram.png"></p>
<h2 id="volatile-的可见性影响">volatile 的可见性影响</h2>
<p>下图展示了 volatile 变量如何影响线程间的可见性：</p>
<p><img src="volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="volatile的可见性影响.png"></p>
<h2 id="锁的分类与选择">锁的分类与选择</h2>
<h3 id="java-主流锁概览">Java 主流锁概览</h3>
<p><img src="Java%E7%9A%84%E4%B8%BB%E6%B5%81%E9%94%81.png" alt="Java的主流锁.png"></p>
<h3 id="乐观锁与悲观锁">乐观锁与悲观锁</h3>
<p><img src="%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81.png" alt="乐观锁与悲观锁.png"></p>
<ul>
<li><strong>悲观锁</strong>适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li><strong>乐观锁</strong>适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<h3 id="自旋锁与非自旋锁">自旋锁与非自旋锁</h3>
<p><img src="%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E9%9D%9E%E8%87%AA%E6%97%8B%E9%94%81.png" alt="自旋锁与非自旋锁.png"></p>
<h3 id="锁升级的思路">锁升级的思路</h3>
<p><img src="%E5%9B%9B%E7%A7%8D%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%80%9D%E8%B7%AF.png" alt="四种锁升级的思路.png"></p>
<h2 id="线程状态的可视化观察">线程状态的可视化观察</h2>
<h3 id="synchronized-导致的-blocked-状态">synchronized 导致的 BLOCKED 状态</h3>
<p>使用 JVisualVM 和 JMC 观察 synchronized 导致的线程阻塞状态：</p>
<p><img src="jvisualvm%E8%A7%82%E5%AF%9F%E5%88%B0monitored%E6%80%81.png" alt="jvisualvm观察到monitored态.png"><br>
<img src="jmc%E5%BE%97%E5%88%B0blocked%E6%80%81.png" alt="jmc得到blocked态.png"></p>
<p>JVisualVM 会专门把 BLOCKED 状态显示为 “Monitor” 态。</p>
<h3 id="locksupport-park-导致的-waiting-状态">LockSupport.park() 导致的 WAITING 状态</h3>
<p>使用 JVisualVM 和 JMC 观察 <code>LockSupport.park()</code> 导致的线程等待状态：</p>
<p><img src="JVisualVM%E7%9A%84%E9%A9%BB%E7%95%99%E7%8A%B6%E6%80%81.png" alt="JVisualVM的驻留状态.png"><br>
<img src="JMC%E7%9C%8Bwaiting%E7%8A%B6%E6%80%81.jpeg" alt="JMC看waiting状态.jpeg"></p>
<p>需要注意的是，只有 JVisualVM 会显示&quot;驻留&quot;这个状态，JMC 和 JConsole 都是直接显示标准的 WAITING 状态。基于 AQS 的 Lock 和 await 语义都会导致 WAITING 状态，这会和 <code>Object.wait()</code> 产生的 WAITING 状态混淆。JVisualVM 能够把 <code>Object.wait()</code> 和 <code>LockSupport.park()</code> 导致的 WAITING 状态区分开来。</p>
<h2 id="java-线程模型的演化：从绿色线程到虚拟线程">Java 线程模型的演化：从绿色线程到虚拟线程</h2>
<p>Java 的线程模型经历了三个重要阶段：<strong>绿色线程（Green Threads）→ 原生线程（Native Threads）→ 虚拟线程（Virtual Threads）</strong>。理解这一演化历程，有助于我们理解为什么 Java 在 JDK 21 中重新引入了用户态线程。</p>
<h3 id="三种线程模型对比">三种线程模型对比</h3>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;1:1 模型（原生线程）&quot;
        direction TB
        JT1[&quot;Java Thread 1&quot;] --&gt; KT1[&quot;Kernel Thread 1&quot;]
        JT2[&quot;Java Thread 2&quot;] --&gt; KT2[&quot;Kernel Thread 2&quot;]
        JT3[&quot;Java Thread 3&quot;] --&gt; KT3[&quot;Kernel Thread 3&quot;]
        JT4[&quot;Java Thread N&quot;] --&gt; KT4[&quot;Kernel Thread N&quot;]
        
        KT1 --&gt; OS1[&quot;OS 调度器&quot;]
        KT2 --&gt; OS1
        KT3 --&gt; OS1
        KT4 --&gt; OS1
        
        style JT1 fill:#e1f5ff
        style JT2 fill:#e1f5ff
        style JT3 fill:#e1f5ff
        style JT4 fill:#e1f5ff
        style KT1 fill:#ffcdd2
        style KT2 fill:#ffcdd2
        style KT3 fill:#ffcdd2
        style KT4 fill:#ffcdd2
    end</code></pre>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;N:1 模型（绿色线程）&quot;
        direction TB
        GT1[&quot;Green Thread 1&quot;]
        GT2[&quot;Green Thread 2&quot;]
        GT3[&quot;Green Thread 3&quot;]
        GT4[&quot;Green Thread N&quot;]
        
        GT1 --&gt; JVM[&quot;JVM 用户态调度器&quot;]
        GT2 --&gt; JVM
        GT3 --&gt; JVM
        GT4 --&gt; JVM
        
        JVM --&gt; KT[&quot;单个 Kernel Thread&quot;]
        KT --&gt; OS[&quot;OS 调度器&quot;]
        
        style GT1 fill:#c8e6c9
        style GT2 fill:#c8e6c9
        style GT3 fill:#c8e6c9
        style GT4 fill:#c8e6c9
        style JVM fill:#fff9c4
        style KT fill:#ffcdd2
    end</code></pre>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;M:N 模型（虚拟线程）&quot;
        direction TB
        VT1[&quot;Virtual Thread 1&quot;]
        VT2[&quot;Virtual Thread 2&quot;]
        VT3[&quot;Virtual Thread 3&quot;]
        VT4[&quot;Virtual Thread ...&quot;]
        VT5[&quot;Virtual Thread M&quot;]
        
        VT1 --&gt; CT1[&quot;Carrier Thread 1&quot;]
        VT2 --&gt; CT1
        VT3 --&gt; CT2[&quot;Carrier Thread 2&quot;]
        VT4 --&gt; CT2
        VT5 --&gt; CTN[&quot;Carrier Thread N&quot;]
        
        CT1 --&gt; KT1[&quot;Kernel Thread 1&quot;]
        CT2 --&gt; KT2[&quot;Kernel Thread 2&quot;]
        CTN --&gt; KTN[&quot;Kernel Thread N&quot;]
        
        KT1 --&gt; OS[&quot;OS 调度器&quot;]
        KT2 --&gt; OS
        KTN --&gt; OS
        
        style VT1 fill:#c8e6c9
        style VT2 fill:#c8e6c9
        style VT3 fill:#c8e6c9
        style VT4 fill:#c8e6c9
        style VT5 fill:#c8e6c9
        style CT1 fill:#fff9c4
        style CT2 fill:#fff9c4
        style CTN fill:#fff9c4
        style KT1 fill:#ffcdd2
        style KT2 fill:#ffcdd2
        style KTN fill:#ffcdd2
    end</code></pre>
<h3 id="演化历程详解">演化历程详解</h3>
<h4 id="第一阶段：绿色线程-jdk-1-0-jdk-1-2">第一阶段：绿色线程（JDK 1.0 ~ JDK 1.2）</h4>
<p><strong>背景</strong>：1995 年 Java 诞生时，许多操作系统（如早期的 Solaris、经典 Mac OS）要么不支持原生线程，要么线程实现不成熟。为了实现&quot;Write Once, Run Anywhere&quot;的目标，Sun 选择在 JVM 层面实现线程调度。</p>
<p><strong>实现方式</strong>：</p>
<ul>
<li>所有 Java 线程由 JVM 在用户态调度</li>
<li>多个绿色线程映射到单个操作系统进程/线程</li>
<li>JVM 自己实现线程切换、调度算法</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>线程创建和切换开销极低（无需系统调用）</li>
<li>跨平台一致性好</li>
<li>不依赖操作系统的线程支持</li>
</ul>
<p><strong>致命缺陷</strong>：</p>
<ul>
<li><strong>无法利用多核 CPU</strong>：所有绿色线程共享一个内核线程，即使有多个 CPU 核心也只能使用一个</li>
<li><strong>阻塞问题</strong>：任何一个绿色线程执行阻塞系统调用（如 I/O），整个进程都会阻塞</li>
<li><strong>无法利用操作系统的抢占式调度</strong>：需要线程主动让出 CPU</li>
</ul>
<pre><code class="hljs mermaid">sequenceDiagram
    participant GT1 as 绿色线程 1
    participant GT2 as 绿色线程 2
    participant JVM as JVM 调度器
    participant KT as 内核线程
    participant OS as 操作系统
    
    Note over GT1,OS: 绿色线程的阻塞问题
    
    GT1-&gt;&gt;JVM: 执行
    JVM-&gt;&gt;KT: 运行
    GT1-&gt;&gt;OS: 阻塞 I/O 调用
    Note over KT,OS: 内核线程被阻塞！
    Note over GT2: 无法执行，必须等待
    OS--&gt;&gt;GT1: I/O 完成
    GT1-&gt;&gt;JVM: 让出 CPU
    JVM-&gt;&gt;GT2: 调度执行</code></pre>
<h4 id="第二阶段：原生线程-jdk-1-3-jdk-20">第二阶段：原生线程（JDK 1.3 ~ JDK 20）</h4>
<p><strong>背景</strong>：到 1990 年代末，主流操作系统（Windows NT、Solaris、Linux）都提供了成熟的内核级线程支持。多核 CPU 开始普及，绿色线程的单核限制成为严重瓶颈。</p>
<p><strong>转变原因</strong>：</p>
<table>
<thead>
<tr>
<th>因素</th>
<th>绿色线程的问题</th>
<th>原生线程的优势</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>多核利用</strong></td>
<td>只能使用单核</td>
<td>可以并行使用所有 CPU 核心</td>
</tr>
<tr>
<td><strong>阻塞处理</strong></td>
<td>一个线程阻塞，全部阻塞</td>
<td>一个线程阻塞，其他线程继续运行</td>
</tr>
<tr>
<td><strong>调度质量</strong></td>
<td>JVM 实现的协作式调度</td>
<td>OS 提供的抢占式调度，更公平</td>
</tr>
<tr>
<td><strong>系统集成</strong></td>
<td>无法与 OS 工具集成</td>
<td>可以用 top、ps 等工具监控</td>
</tr>
<tr>
<td><strong>Native 代码</strong></td>
<td>与 JNI 交互困难</td>
<td>与 C/C++ 库无缝集成</td>
</tr>
</tbody>
</table>
<p><strong>实现方式</strong>：</p>
<ul>
<li>每个 <code>java.lang.Thread</code> 直接映射到一个操作系统线程</li>
<li>线程调度完全由操作系统负责</li>
<li>JVM 只负责线程的创建和生命周期管理</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>真正的并行执行，充分利用多核 CPU</li>
<li>阻塞操作不影响其他线程</li>
<li>与操作系统深度集成</li>
</ul>
<p><strong>新的问题</strong>：</p>
<ul>
<li><strong>线程创建成本高</strong>：每个线程需要分配 1MB 左右的栈空间</li>
<li><strong>上下文切换开销大</strong>：涉及用户态/内核态切换</li>
<li><strong>线程数量受限</strong>：通常只能创建数千个线程</li>
<li><strong>C10K 问题</strong>：难以处理大量并发连接</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 原生线程的资源消耗示例</span><br><span class="hljs-comment">// 创建 10000 个线程，每个线程栈 1MB，需要约 10GB 内存</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(Long.MAX_VALUE);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>    &#125;).start();<br>&#125;<br><span class="hljs-comment">// 很可能抛出 OutOfMemoryError: unable to create new native thread</span><br></code></pre></td></tr></table></figure>
<h4 id="第三阶段：虚拟线程-jdk-21">第三阶段：虚拟线程（JDK 21+）</h4>
<p><strong>背景</strong>：随着微服务、云原生架构的普及，应用需要处理的并发连接数从数千增长到数十万甚至数百万。Go 语言的 goroutine 证明了 M:N 线程模型在高并发场景下的优势。</p>
<p><strong>为什么不是简单回归绿色线程？</strong></p>
<p>虚拟线程与早期绿色线程有本质区别：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>绿色线程（JDK 1.x）</th>
<th>虚拟线程（JDK 21+）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>映射模型</strong></td>
<td>N:1（多对一）</td>
<td>M:N（多对多）</td>
</tr>
<tr>
<td><strong>多核利用</strong></td>
<td>无法利用</td>
<td>完全利用</td>
</tr>
<tr>
<td><strong>阻塞处理</strong></td>
<td>阻塞整个进程</td>
<td>只阻塞当前虚拟线程，载体线程可执行其他虚拟线程</td>
</tr>
<tr>
<td><strong>调度器</strong></td>
<td>简单的协作式调度</td>
<td>基于 ForkJoinPool 的工作窃取调度</td>
</tr>
<tr>
<td><strong>栈管理</strong></td>
<td>固定大小栈</td>
<td>动态增长的栈（初始仅几百字节）</td>
</tr>
<tr>
<td><strong>与平台线程关系</strong></td>
<td>替代关系</td>
<td>共存关系（虚拟线程运行在平台线程之上）</td>
</tr>
</tbody>
</table>
<p><strong>虚拟线程的核心创新</strong>：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;虚拟线程的阻塞处理&quot;
        VT[&quot;虚拟线程执行&quot;]
        BLOCK&#123;&quot;遇到阻塞操作?&quot;&#125;
        UNMOUNT[&quot;卸载（unmount）&lt;br/&gt;保存栈到堆内存&quot;]
        CARRIER[&quot;载体线程空闲&lt;br/&gt;可执行其他虚拟线程&quot;]
        COMPLETE[&quot;阻塞操作完成&quot;]
        MOUNT[&quot;重新挂载（mount）&lt;br/&gt;恢复执行&quot;]
        
        VT --&gt; BLOCK
        BLOCK --&gt;|是| UNMOUNT
        UNMOUNT --&gt; CARRIER
        CARRIER --&gt; COMPLETE
        COMPLETE --&gt; MOUNT
        MOUNT --&gt; VT
        BLOCK --&gt;|否| VT
        
        style UNMOUNT fill:#c8e6c9
        style CARRIER fill:#c8e6c9
        style MOUNT fill:#c8e6c9
    end</code></pre>
<p><strong>关键技术突破</strong>：</p>
<ol>
<li><strong>Continuation（续体）</strong>：虚拟线程的栈可以被&quot;冻结&quot;并保存到堆内存，之后再&quot;解冻&quot;恢复执行</li>
<li><strong>非阻塞 I/O 透明化</strong>：JDK 内部将阻塞 I/O 改造为非阻塞实现，对用户代码透明</li>
<li><strong>工作窃取调度</strong>：基于 ForkJoinPool，空闲的载体线程可以窃取其他载体线程的虚拟线程</li>
</ol>
<h3 id="三种模型的综合对比">三种模型的综合对比</h3>
<table>
<thead>
<tr>
<th>维度</th>
<th>绿色线程（N:1）</th>
<th>原生线程（1:1）</th>
<th>虚拟线程（M:N）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线程创建成本</strong></td>
<td>极低（~1μs）</td>
<td>高（~1ms）</td>
<td>极低（~1μs）</td>
</tr>
<tr>
<td><strong>内存占用/线程</strong></td>
<td>低（~KB）</td>
<td>高（~1MB）</td>
<td>极低（~几百字节起）</td>
</tr>
<tr>
<td><strong>最大线程数</strong></td>
<td>理论无限</td>
<td>数千~数万</td>
<td>数百万</td>
</tr>
<tr>
<td><strong>多核利用</strong></td>
<td>无法利用</td>
<td>完全利用</td>
<td>完全利用</td>
</tr>
<tr>
<td><strong>阻塞处理</strong></td>
<td>阻塞整个进程</td>
<td>只阻塞当前线程</td>
<td>只阻塞当前虚拟线程</td>
</tr>
<tr>
<td><strong>调度开销</strong></td>
<td>低（用户态）</td>
<td>高（内核态切换）</td>
<td>低（用户态为主）</td>
</tr>
<tr>
<td><strong>与 OS 集成</strong></td>
<td>差</td>
<td>好</td>
<td>中等</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>早期单核系统</td>
<td>计算密集型、线程数适中</td>
<td>I/O 密集型、高并发</td>
</tr>
</tbody>
</table>
<h3 id="jvm-的设计考量">JVM 的设计考量</h3>
<p><strong>为什么 JDK 1.3 放弃绿色线程？</strong></p>
<ol>
<li><strong>多核 CPU 普及</strong>：绿色线程无法利用多核是致命缺陷</li>
<li><strong>操作系统线程成熟</strong>：主流 OS 都提供了高质量的线程实现</li>
<li><strong>阻塞问题无解</strong>：在 N:1 模型下，阻塞系统调用会阻塞所有线程</li>
<li><strong>JNI 兼容性</strong>：原生代码期望与真正的 OS 线程交互</li>
</ol>
<p><strong>为什么 JDK 21 引入虚拟线程？</strong></p>
<ol>
<li><strong>高并发需求</strong>：现代应用需要处理数十万并发连接</li>
<li><strong>I/O 密集型负载</strong>：大多数服务器应用是 I/O 密集型，线程大部分时间在等待</li>
<li><strong>Go 的成功验证</strong>：goroutine 证明了 M:N 模型的可行性</li>
<li><strong>技术突破</strong>：Continuation 技术使得栈的保存/恢复成为可能</li>
<li><strong>保持编程模型</strong>：虚拟线程与传统线程 API 兼容，无需学习新的异步编程模型</li>
</ol>
<pre><code class="hljs mermaid">timeline
    title Java 线程模型演化时间线
    1995 : JDK 1.0 发布
         : 使用绿色线程
         : 跨平台一致性优先
    1998 : JDK 1.2
         : 绿色线程仍在使用
         : 多核 CPU 开始出现
    2000 : JDK 1.3 发布
         : 切换到原生线程
         : 利用多核 CPU
    2004 : JDK 5.0
         : java.util.concurrent 包
         : 线程池成为标准实践
    2014 : JDK 8
         : CompletableFuture
         : 异步编程支持
    2017 : Project Loom 启动
         : 探索轻量级线程
    2021 : JDK 19 预览
         : 虚拟线程首次预览
    2023 : JDK 21 正式发布
         : 虚拟线程正式 GA
         : M:N 模型回归</code></pre>
<h3 id="小结">小结</h3>
<p>Java 线程模型的演化体现了工程上的务实选择：</p>
<ol>
<li><strong>绿色线程时代</strong>：在操作系统线程不成熟时，JVM 自己实现线程是合理的</li>
<li><strong>原生线程时代</strong>：当 OS 线程成熟且多核 CPU 普及时，1:1 模型是最佳选择</li>
<li><strong>虚拟线程时代</strong>：当并发需求超过原生线程的承载能力时，M:N 模型成为必然</li>
</ol>
<p>虚拟线程不是简单地&quot;回到过去&quot;，而是在保留原生线程优势（多核利用、阻塞隔离）的基础上，解决了其资源消耗问题。这是技术螺旋式上升的典型案例。</p>
<h3 id="为什么虚拟线程在当今时代更具优势">为什么虚拟线程在当今时代更具优势</h3>
<p>前文解释了 Java 线程模型的演化历程，但一个核心问题尚未深入分析：<strong>为什么虚拟线程（或更广义的协程）在当今时代突然比平台线程更受欢迎？</strong> 这不是简单的技术时尚，而是由工作负载特征、硬件架构和编程模型三个维度的根本变化所驱动的。</p>
<h4 id="工作负载特征的根本转变">工作负载特征的根本转变</h4>
<p>现代服务端应用的工作负载已经从 <strong>CPU 密集型</strong> 转变为 <strong>I/O 密集型</strong>。这一转变是理解虚拟线程价值的关键。</p>
<pre><code class="hljs mermaid">pie showData
    title 典型微服务请求的时间分布
    &quot;等待数据库&quot; : 35
    &quot;等待 RPC 调用&quot; : 30
    &quot;等待外部 API&quot; : 20
    &quot;等待消息队列&quot; : 10
    &quot;实际 CPU 计算&quot; : 5</code></pre>
<p>一个典型的微服务请求处理过程中，线程的实际 CPU 执行时间可能只占总时间的 1-5%，其余 95-99% 的时间都在等待：</p>
<ul>
<li>等待数据库查询返回（网络 I/O + 磁盘 I/O）</li>
<li>等待下游 RPC 服务响应（网络 I/O）</li>
<li>等待外部 HTTP API 响应（网络 I/O）</li>
<li>等待消息队列确认（网络 I/O）</li>
</ul>
<p>在这种场景下，平台线程的 1MB 栈空间和内核调度开销成为纯粹的资源浪费。线程大部分时间处于 WAITING 或 TIMED_WAITING 状态，却仍然占用着宝贵的内存资源。</p>
<h4 id="并发规模的数量级跃升">并发规模的数量级跃升</h4>
<p>从 <strong>C10K 问题</strong>（单机处理 1 万并发连接）到 <strong>C10M 问题</strong>（单机处理 1000 万并发连接），并发连接数增长了三个数量级。</p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;平台线程的资源消耗&quot;
        PT1[&quot;10,000 个平台线程&quot;]
        PT2[&quot;≈ 10GB 内存&lt;br/&gt;（仅栈空间）&quot;]
        PT3[&quot;+ 内核调度开销&quot;]
        PT4[&quot;+ 上下文切换成本&quot;]
        
        PT1 --&gt; PT2 --&gt; PT3 --&gt; PT4
        
        style PT1 fill:#ffcdd2
        style PT2 fill:#ffcdd2
        style PT3 fill:#ffcdd2
        style PT4 fill:#ffcdd2
    end
    
    subgraph &quot;虚拟线程的资源消耗&quot;
        VT1[&quot;1,000,000 个虚拟线程&quot;]
        VT2[&quot;≈ 几百 MB 内存&quot;]
        VT3[&quot;用户态调度&quot;]
        VT4[&quot;极低切换成本&quot;]
        
        VT1 --&gt; VT2 --&gt; VT3 --&gt; VT4
        
        style VT1 fill:#c8e6c9
        style VT2 fill:#c8e6c9
        style VT3 fill:#c8e6c9
        style VT4 fill:#c8e6c9
    end</code></pre>
<p>平台线程的资源消耗使其无法支撑这种规模的并发。即使不考虑业务逻辑的内存占用，仅线程栈空间就会耗尽服务器内存。</p>
<h4 id="编程模型的权衡：阻塞-vs-异步">编程模型的权衡：阻塞 vs 异步</h4>
<p>在虚拟线程出现之前，处理高并发 I/O 有两条主要路径：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;路径一：阻塞 I/O + 线程池&quot;
        B1[&quot;同步阻塞代码&lt;br/&gt;编程简单&quot;]
        B2[&quot;线程池限制并发数&quot;]
        B3[&quot;线程资源成为瓶颈&quot;]
        B4[&quot;吞吐量受限&quot;]
        
        B1 --&gt; B2 --&gt; B3 --&gt; B4
        
        style B1 fill:#c8e6c9
        style B2 fill:#fff9c4
        style B3 fill:#ffcdd2
        style B4 fill:#ffcdd2
    end
    
    subgraph &quot;路径二：非阻塞 I/O + 回调/响应式&quot;
        A1[&quot;异步回调/响应式代码&lt;br/&gt;编程复杂&quot;]
        A2[&quot;Callback Hell&lt;br/&gt;调试困难&quot;]
        A3[&quot;堆栈信息丢失&quot;]
        A4[&quot;高并发能力&quot;]
        
        A1 --&gt; A2 --&gt; A3 --&gt; A4
        
        style A1 fill:#ffcdd2
        style A2 fill:#ffcdd2
        style A3 fill:#ffcdd2
        style A4 fill:#c8e6c9
    end
    
    subgraph &quot;路径三：虚拟线程&quot;
        V1[&quot;同步阻塞语义&lt;br/&gt;编程简单&quot;]
        V2[&quot;底层非阻塞实现&lt;br/&gt;对用户透明&quot;]
        V3[&quot;完整堆栈信息&quot;]
        V4[&quot;高并发能力&quot;]
        
        V1 --&gt; V2 --&gt; V3 --&gt; V4
        
        style V1 fill:#c8e6c9
        style V2 fill:#c8e6c9
        style V3 fill:#c8e6c9
        style V4 fill:#c8e6c9
    end</code></pre>
<p>虚拟线程提供了第三条路径：<strong>阻塞语义 + 非阻塞实现</strong>，兼顾了编程简单性和高并发能力。这正是 JEP 444 所追求的目标——让开发者用熟悉的同步代码风格，获得异步编程的性能收益。</p>
<h4 id="不同场景下的适用性分析">不同场景下的适用性分析</h4>
<p>虚拟线程并非在所有场景下都优于平台线程。选择的核心因素取决于 <strong>任务的阻塞特征</strong> 和 <strong>并发规模需求</strong>。</p>
<table>
<thead>
<tr>
<th>场景特征</th>
<th>平台线程</th>
<th>虚拟线程</th>
<th>分析</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CPU 密集型计算</strong></td>
<td>适合</td>
<td>无优势</td>
<td>线程数应等于 CPU 核心数，虚拟线程无法提供额外收益。计算密集型任务不会主动让出 CPU，虚拟线程的调度优势无从发挥。</td>
</tr>
<tr>
<td><strong>I/O 密集型 + 短等待（&lt;1ms）</strong></td>
<td>可用</td>
<td>略优</td>
<td>短等待场景下，平台线程的上下文切换开销相对可接受，虚拟线程优势不明显。</td>
</tr>
<tr>
<td><strong>I/O 密集型 + 长等待（&gt;10ms）</strong></td>
<td>浪费资源</td>
<td>显著更优</td>
<td>等待期间虚拟线程不占用平台线程资源，系统可以用有限的载体线程服务大量并发请求。</td>
</tr>
<tr>
<td><strong>高并发连接（&gt;10K）</strong></td>
<td>受限</td>
<td>显著更优</td>
<td>突破平台线程数量限制，支持百万级并发。</td>
</tr>
<tr>
<td><strong>需要 I/O 多路复用</strong></td>
<td>需要 Selector API</td>
<td>透明支持</td>
<td>JDK 内部已将阻塞 I/O 改造为非阻塞实现，开发者无需直接使用 Selector。</td>
</tr>
<tr>
<td><strong>需要与 native 代码交互</strong></td>
<td>适合</td>
<td>需注意 Pinning</td>
<td>JNI 调用可能导致虚拟线程被钉住，需要评估影响。</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">quadrantChart
    title 线程模型选择决策矩阵
    x-axis 低并发需求 --&gt; 高并发需求
    y-axis CPU密集型 --&gt; I/O密集型
    quadrant-1 虚拟线程最佳
    quadrant-2 虚拟线程可用
    quadrant-3 平台线程最佳
    quadrant-4 平台线程可用
    &quot;数据库连接池&quot;: [0.8, 0.9]
    &quot;Web服务器&quot;: [0.9, 0.85]
    &quot;微服务网关&quot;: [0.95, 0.8]
    &quot;批量数据处理&quot;: [0.3, 0.2]
    &quot;科学计算&quot;: [0.2, 0.1]
    &quot;图像渲染&quot;: [0.4, 0.15]
    &quot;日志收集&quot;: [0.6, 0.7]
    &quot;消息队列消费&quot;: [0.75, 0.75]</code></pre>
<h4 id="关键洞察">关键洞察</h4>
<p>虚拟线程的价值不在于让单个任务执行更快，而在于：</p>
<ol>
<li><strong>资源效率</strong>：让系统能够同时处理更多的等待中的任务，而不浪费平台线程资源</li>
<li><strong>编程简单性</strong>：保持简单的同步编程模型，避免回调地狱和响应式编程的复杂性</li>
<li><strong>可观测性</strong>：保留完整的调用栈信息，便于调试和问题定位</li>
</ol>
<p><strong>何时应该选择虚拟线程</strong>：</p>
<ul>
<li>应用是 I/O 密集型，大部分时间在等待外部资源</li>
<li>需要处理大量并发连接或请求</li>
<li>希望保持简单的同步编程模型</li>
<li>不需要频繁与 native 代码交互</li>
</ul>
<p><strong>何时应该继续使用平台线程</strong>：</p>
<ul>
<li>应用是 CPU 密集型，计算是主要瓶颈</li>
<li>并发需求适中（数百到数千）</li>
<li>需要与 synchronized 块内的阻塞操作共存（Pinning 问题）</li>
<li>需要精确控制线程优先级和调度</li>
</ul>
<h4 id="i-o-多路复用与虚拟线程的关系">I/O 多路复用与虚拟线程的关系</h4>
<p>一个常见的疑问是：既然 Java NIO 已经提供了 I/O 多路复用（Selector），为什么还需要虚拟线程？</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;传统 NIO 方式&quot;
        NIO1[&quot;开发者直接使用 Selector&quot;]
        NIO2[&quot;手动管理 Channel 注册&quot;]
        NIO3[&quot;事件驱动编程模型&quot;]
        NIO4[&quot;代码复杂度高&quot;]
        
        NIO1 --&gt; NIO2 --&gt; NIO3 --&gt; NIO4
    end
    
    subgraph &quot;虚拟线程方式&quot;
        VT1[&quot;开发者使用阻塞 API&quot;]
        VT2[&quot;JDK 内部使用非阻塞 I/O&quot;]
        VT3[&quot;同步编程模型&quot;]
        VT4[&quot;代码简单直观&quot;]
        
        VT1 --&gt; VT2 --&gt; VT3 --&gt; VT4
    end
    
    NIO4 -.-&gt;|&quot;相同的底层机制&lt;br/&gt;不同的抽象层次&quot;| VT2
    
    style NIO4 fill:#ffcdd2
    style VT4 fill:#c8e6c9</code></pre>
<p>虚拟线程并没有取代 I/O 多路复用，而是在其之上提供了更高层次的抽象。JDK 内部将 <code>java.net.Socket</code>、<code>java.io.InputStream</code> 等阻塞 API 改造为基于非阻塞 I/O 的实现。当虚拟线程执行阻塞 I/O 操作时：</p>
<ol>
<li>JDK 内部将其转换为非阻塞操作</li>
<li>虚拟线程被挂起（unmount），释放载体线程</li>
<li>I/O 完成后，虚拟线程被重新调度执行</li>
</ol>
<p>这种设计让开发者享受同步编程的简单性，同时获得非阻塞 I/O 的性能优势。</p>
<h3 id="虚拟线程与其他语言并发方案的对比">虚拟线程与其他语言并发方案的对比</h3>
<p>Java 虚拟线程并非凭空出现，而是在借鉴其他语言并发方案的基础上，结合 Java 生态的特点做出的设计选择。理解这些差异有助于更准确地把握虚拟线程的定位和适用场景。</p>
<h4 id="核心概念辨析">核心概念辨析</h4>
<p>在讨论具体实现之前，需要明确几个经常被混淆的概念：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>定义</th>
<th>调度方式</th>
<th>代表实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>协程（Coroutine）</strong></td>
<td>可以在特定点暂停和恢复执行的程序组件</td>
<td>协作式，需显式让出</td>
<td>Kotlin Coroutines、Lua coroutines</td>
</tr>
<tr>
<td><strong>半协程（Semi-coroutine）</strong></td>
<td>只能让出到调用者的协程，不能让出到任意协程</td>
<td>协作式，受限让出</td>
<td>Python generators、JavaScript generators</td>
</tr>
<tr>
<td><strong>纤程（Fiber）</strong></td>
<td>用户态线程，由运行时而非操作系统调度</td>
<td>通常协作式</td>
<td>Ruby Fiber、Windows Fiber API</td>
</tr>
<tr>
<td><strong>绿色线程（Green Thread）</strong></td>
<td>由虚拟机/运行时调度的轻量级线程</td>
<td>可协作或抢占</td>
<td>早期 Java（JDK 1.1）、Erlang processes</td>
</tr>
<tr>
<td><strong>虚拟线程（Virtual Thread）</strong></td>
<td>Java 21 引入的轻量级线程，由 JVM 调度</td>
<td>协作式（阻塞点让出）</td>
<td>Java Virtual Threads</td>
</tr>
</tbody>
</table>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;并发抽象的分类&quot;
        direction TB
        
        subgraph &quot;按调度主体分类&quot;
            OS[&quot;操作系统调度&quot;]
            RT[&quot;运行时/VM调度&quot;]
        end
        
        subgraph &quot;按让出方式分类&quot;
            EXPLICIT[&quot;显式让出&lt;br/&gt;（yield/await）&quot;]
            IMPLICIT[&quot;隐式让出&lt;br/&gt;（阻塞操作自动让出）&quot;]
            PREEMPT[&quot;抢占式&lt;br/&gt;（时间片/信号）&quot;]
        end
        
        OS --&gt; PREEMPT
        RT --&gt; EXPLICIT
        RT --&gt; IMPLICIT
        RT --&gt; PREEMPT
    end
    
    subgraph &quot;各语言实现&quot;
        JAVA_PT[&quot;Java 平台线程&quot;] --&gt; OS
        GO[&quot;Go goroutine&quot;] --&gt; RT
        GO --&gt; PREEMPT
        RUBY[&quot;Ruby Fiber&quot;] --&gt; RT
        RUBY --&gt; EXPLICIT
        JS[&quot;JavaScript async/await&quot;] --&gt; RT
        JS --&gt; EXPLICIT
        JAVA_VT[&quot;Java 虚拟线程&quot;] --&gt; RT
        JAVA_VT --&gt; IMPLICIT
    end
    
    style JAVA_VT fill:#c8e6c9
    style IMPLICIT fill:#c8e6c9</code></pre>
<h4 id="go-goroutine：m-n-调度的先驱">Go Goroutine：M:N 调度的先驱</h4>
<p>Go 语言的 goroutine 是现代 M:N 调度模型的成功实践，其调度器采用 GMP 模型：</p>
<ul>
<li><strong>G（Goroutine）</strong>：轻量级执行单元</li>
<li><strong>M（Machine）</strong>：操作系统线程</li>
<li><strong>P（Processor）</strong>：逻辑处理器，持有本地运行队列</li>
</ul>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;Go GMP 调度模型&quot;
        subgraph &quot;全局队列&quot;
            GQ[&quot;Global Queue&lt;br/&gt;待运行的 G&quot;]
        end
        
        subgraph &quot;P1 本地&quot;
            P1[&quot;P1&quot;]
            LQ1[&quot;Local Queue&quot;]
            P1 --&gt; LQ1
        end
        
        subgraph &quot;P2 本地&quot;
            P2[&quot;P2&quot;]
            LQ2[&quot;Local Queue&quot;]
            P2 --&gt; LQ2
        end
        
        M1[&quot;M1&lt;br/&gt;OS Thread&quot;]
        M2[&quot;M2&lt;br/&gt;OS Thread&quot;]
        M3[&quot;M3&lt;br/&gt;（空闲）&quot;]
        
        P1 --&gt; M1
        P2 --&gt; M2
        
        GQ -.-&gt;|&quot;窃取&quot;| LQ1
        GQ -.-&gt;|&quot;窃取&quot;| LQ2
        LQ1 -.-&gt;|&quot;工作窃取&quot;| LQ2
    end</code></pre>
<p><strong>Go goroutine 的关键特性</strong>：</p>
<ol>
<li><strong>异步抢占（Go 1.14+）</strong>：通过信号机制实现，goroutine 可在任意安全点被抢占，解决了长时间运行的 goroutine 阻塞调度的问题</li>
<li><strong>动态栈</strong>：初始栈仅 2KB，可动态增长和收缩</li>
<li><strong>channel 通信</strong>：遵循 CSP（Communicating Sequential Processes）模型，通过通信共享内存而非通过共享内存通信</li>
<li><strong>网络轮询器集成</strong>：所有网络 I/O 都通过 netpoller 实现非阻塞</li>
</ol>
<p><strong>与 Java 虚拟线程的关键差异</strong>：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Go goroutine</th>
<th>Java 虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>调度方式</strong></td>
<td>异步抢占（信号驱动）</td>
<td>协作式（阻塞点让出）</td>
</tr>
<tr>
<td><strong>栈管理</strong></td>
<td>连续栈，动态增长/收缩</td>
<td>栈帧存储在堆上，按需分配</td>
</tr>
<tr>
<td><strong>同步原语</strong></td>
<td>channel 为主，mutex 为辅</td>
<td>传统锁机制，ReentrantLock 推荐</td>
</tr>
<tr>
<td><strong>线程局部存储</strong></td>
<td>无 goroutine-local storage</td>
<td>保留 ThreadLocal（但不推荐）</td>
</tr>
<tr>
<td><strong>与现有代码兼容</strong></td>
<td>需要使用 Go 风格编写</td>
<td>现有 Java 代码无需修改</td>
</tr>
<tr>
<td><strong>阻塞系统调用</strong></td>
<td>自动创建新 M 处理</td>
<td>可能导致 Pinning</td>
</tr>
</tbody>
</table>
<p>Go 的设计更加激进，完全重新定义了并发编程模型；Java 虚拟线程则更保守，优先保证与现有生态的兼容性。</p>
<h4 id="ruby-fiber：显式协作的半协程">Ruby Fiber：显式协作的半协程</h4>
<p>Ruby 的 Fiber 是典型的半协程实现，需要显式让出控制权：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby">fiber = <span class="hljs-title class_">Fiber</span>.new <span class="hljs-keyword">do</span><br>  puts <span class="hljs-string">&quot;Step 1&quot;</span><br>  <span class="hljs-title class_">Fiber</span>.<span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;暂停点&quot;</span>  <span class="hljs-comment"># 显式让出，返回值传给调用者</span><br>  puts <span class="hljs-string">&quot;Step 2&quot;</span><br><span class="hljs-keyword">end</span><br><br>result = fiber.resume  <span class="hljs-comment"># 输出 &quot;Step 1&quot;，result = &quot;暂停点&quot;</span><br>fiber.resume           <span class="hljs-comment"># 输出 &quot;Step 2&quot;</span><br></code></pre></td></tr></table></figure>
<p><strong>Ruby 3.0+ 的 Fiber Scheduler</strong>：</p>
<p>Ruby 3.0 引入了 Fiber Scheduler 接口，允许在 I/O 阻塞时自动切换 Fiber，这与 Java 虚拟线程的设计理念趋同：</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-comment"># Ruby 3.0+ 的非阻塞 Fiber</span><br><span class="hljs-title class_">Fiber</span>.set_scheduler(<span class="hljs-title class_">MyScheduler</span>.new)<br><br><span class="hljs-title class_">Fiber</span>.schedule <span class="hljs-keyword">do</span><br>  <span class="hljs-comment"># I/O 操作会自动让出</span><br>  data = socket.read  <span class="hljs-comment"># 调度器接管，切换到其他 Fiber</span><br>  process(data)<br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>
<p><strong>与 Java 虚拟线程的关键差异</strong>：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Ruby Fiber</th>
<th>Java 虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>让出方式</strong></td>
<td>显式 <code>Fiber.yield</code>（传统）或 I/O 自动让出（3.0+）</td>
<td>I/O 阻塞时自动让出</td>
</tr>
<tr>
<td><strong>调度器</strong></td>
<td>可插拔，用户可自定义</td>
<td>JVM 内置，基于 ForkJoinPool</td>
</tr>
<tr>
<td><strong>与线程关系</strong></td>
<td>Fiber 运行在单个线程内</td>
<td>虚拟线程可在不同载体线程间迁移</td>
</tr>
<tr>
<td><strong>并行能力</strong></td>
<td>单线程内无真正并行</td>
<td>可利用多核并行</td>
</tr>
</tbody>
</table>
<h4 id="javascript-async-await：单线程事件循环">JavaScript async/await：单线程事件循环</h4>
<p>JavaScript 的异步模型基于单线程事件循环，async/await 是 Promise 的语法糖：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fetchData</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;开始请求&quot;</span>);<br>  <span class="hljs-keyword">const</span> response = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);  <span class="hljs-comment">// 让出控制权，等待 Promise 完成</span><br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;请求完成&quot;</span>);<br>  <span class="hljs-keyword">return</span> response.<span class="hljs-title function_">json</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;JavaScript 事件循环&quot;
        CS[&quot;Call Stack&lt;br/&gt;调用栈&quot;]
        WA[&quot;Web APIs&lt;br/&gt;（定时器、网络等）&quot;]
        TQ[&quot;Task Queue&lt;br/&gt;宏任务队列&quot;]
        MQ[&quot;Microtask Queue&lt;br/&gt;微任务队列&quot;]
        EL[&quot;Event Loop&quot;]
        
        CS --&gt;|&quot;异步调用&quot;| WA
        WA --&gt;|&quot;回调入队&quot;| TQ
        CS --&gt;|&quot;Promise.then&quot;| MQ
        
        EL --&gt;|&quot;1. 清空微任务&quot;| MQ
        EL --&gt;|&quot;2. 取一个宏任务&quot;| TQ
        MQ --&gt;|&quot;执行&quot;| CS
        TQ --&gt;|&quot;执行&quot;| CS
    end</code></pre>
<p><strong>async/await 的&quot;传染性&quot;问题</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 调用 async 函数的函数也必须是 async，或者处理 Promise</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getUser</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchUser</span>();<br>&#125;<br><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">getProfile</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> user = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getUser</span>();  <span class="hljs-comment">// 必须 await</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetchProfile</span>(user.<span class="hljs-property">id</span>);<br>&#125;<br><br><span class="hljs-comment">// 一直传染到调用链顶端</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> profile = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getProfile</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>与 Java 虚拟线程的关键差异</strong>：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>JavaScript async/await</th>
<th>Java 虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线程模型</strong></td>
<td>单线程事件循环</td>
<td>多线程，可利用多核</td>
</tr>
<tr>
<td><strong>语法标记</strong></td>
<td>需要 async/await 关键字</td>
<td>无需特殊语法</td>
</tr>
<tr>
<td><strong>函数签名</strong></td>
<td>async 函数返回 Promise</td>
<td>普通方法，无签名变化</td>
</tr>
<tr>
<td><strong>传染性</strong></td>
<td>高，async 向上传播</td>
<td>无，同步代码直接运行</td>
</tr>
<tr>
<td><strong>调用栈</strong></td>
<td>异步边界处断开</td>
<td>完整保留</td>
</tr>
<tr>
<td><strong>调试体验</strong></td>
<td>需要特殊工具支持</td>
<td>与普通线程一致</td>
</tr>
</tbody>
</table>
<h4 id="设计取舍的深层分析">设计取舍的深层分析</h4>
<p>Java 虚拟线程的设计体现了以下核心取舍：</p>
<p><strong>1. 兼容性优先于激进创新</strong></p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph &quot;Go 的选择&quot;
        G1[&quot;全新语言&quot;] --&gt; G2[&quot;全新并发模型&quot;]
        G2 --&gt; G3[&quot;channel + goroutine&quot;]
        G3 --&gt; G4[&quot;无历史包袱&quot;]
    end
    
    subgraph &quot;Java 的选择&quot;
        J1[&quot;30年历史&quot;] --&gt; J2[&quot;海量现有代码&quot;]
        J2 --&gt; J3[&quot;保持 Thread API&quot;]
        J3 --&gt; J4[&quot;渐进式迁移&quot;]
    end
    
    style G4 fill:#fff9c4
    style J4 fill:#c8e6c9</code></pre>
<p>Java 选择保持 <code>java.lang.Thread</code> 的完整语义，意味着：</p>
<ul>
<li>现有代码无需修改即可在虚拟线程上运行</li>
<li>保留了 ThreadLocal、线程中断、线程状态等所有 API</li>
<li>代价是无法像 Go 那样完全重新设计线程模型</li>
</ul>
<p><strong>2. 隐式让出 vs 显式让出</strong></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
<th>采用者</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>显式让出</strong></td>
<td>控制精确，行为可预测</td>
<td>需要修改代码，易遗漏</td>
<td>Ruby Fiber、Kotlin Coroutines</td>
</tr>
<tr>
<td><strong>隐式让出</strong></td>
<td>无需修改代码，透明</td>
<td>依赖运行时识别阻塞点</td>
<td>Java 虚拟线程、Go（部分）</td>
</tr>
</tbody>
</table>
<p>Java 选择隐式让出，JDK 内部改造了所有阻塞 API（Socket、InputStream、Lock 等），使其在虚拟线程上自动让出。这带来了极大的便利性，但也引入了 Pinning 问题——当阻塞发生在 synchronized 块内或 native 方法中时，无法让出。</p>
<p><strong>3. 调用栈完整性</strong></p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;JavaScript async 调用栈&quot;
        JS1[&quot;main()&quot;]
        JS2[&quot;fetchData()&quot;]
        JS3[&quot;--- await 边界 ---&quot;]
        JS4[&quot;processResponse()&quot;]
        
        JS1 --&gt; JS2
        JS2 -.-&gt;|&quot;栈断开&quot;| JS3
        JS3 -.-&gt; JS4
        
        style JS3 fill:#ffcdd2
    end
    
    subgraph &quot;Java 虚拟线程调用栈&quot;
        JV1[&quot;main()&quot;]
        JV2[&quot;fetchData()&quot;]
        JV3[&quot;socket.read()&quot;]
        JV4[&quot;processResponse()&quot;]
        
        JV1 --&gt; JV2
        JV2 --&gt; JV3
        JV3 --&gt; JV4
        
        style JV3 fill:#c8e6c9
    end</code></pre>
<p>Java 虚拟线程保留完整的调用栈信息，这对于调试和问题定位至关重要。当虚拟线程被挂起时，其栈帧被保存到堆内存；恢复时，栈帧被重新加载。这与 JavaScript 的 async/await 形成鲜明对比——后者在 await 边界处调用栈会断开。</p>
<h4 id="各方案适用场景总结">各方案适用场景总结</h4>
<pre><code class="hljs mermaid">quadrantChart
    title 并发方案选择矩阵
    x-axis 低生态兼容需求 --&gt; 高生态兼容需求
    y-axis 低并发规模 --&gt; 高并发规模
    quadrant-1 Java 虚拟线程最佳
    quadrant-2 Go goroutine 最佳
    quadrant-3 传统线程池足够
    quadrant-4 需要权衡迁移成本
    &quot;新 Go 项目&quot;: [0.2, 0.9]
    &quot;Java 微服务&quot;: [0.85, 0.85]
    &quot;Node.js 服务&quot;: [0.3, 0.7]
    &quot;遗留 Java 系统&quot;: [0.95, 0.6]
    &quot;Ruby Web 应用&quot;: [0.4, 0.5]
    &quot;批处理任务&quot;: [0.7, 0.2]</code></pre>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>新建高并发 Java 服务</strong></td>
<td>虚拟线程</td>
<td>简单、高效、与现有库兼容</td>
</tr>
<tr>
<td><strong>新建高并发服务（语言不限）</strong></td>
<td>Go goroutine</td>
<td>成熟、高性能、生态完善</td>
</tr>
<tr>
<td><strong>现有 Java 系统升级</strong></td>
<td>虚拟线程</td>
<td>迁移成本最低</td>
</tr>
<tr>
<td><strong>前端/Node.js 服务</strong></td>
<td>async/await</td>
<td>语言原生支持，生态成熟</td>
</tr>
<tr>
<td><strong>需要精细控制的场景</strong></td>
<td>Kotlin Coroutines</td>
<td>显式控制，结构化并发</td>
</tr>
</tbody>
</table>
<h2 id="虚拟线程与锁的交互-jdk-21">虚拟线程与锁的交互（JDK 21+）</h2>
<p>Java 21 正式引入了虚拟线程（Virtual Threads，JEP 444），这对锁的使用带来了新的考量。虚拟线程的核心优势在于阻塞操作时可以自动让出载体线程（Carrier Thread），但 <strong>synchronized 和某些 native 方法会导致&quot;钉住&quot;（Pinning）问题</strong>。</p>
<h3 id="pinning-问题">Pinning 问题</h3>
<p><strong>定义</strong>：根据 JEP 444，Pinning（钉住）是指虚拟线程被固定到载体线程上，无法在阻塞时让出的情况。</p>
<p><strong>Pinning 发生的两种场景</strong>（依据 JEP 444）：</p>
<ol>
<li><strong>synchronized 块或方法内的阻塞操作</strong>：当虚拟线程在 synchronized 块内执行阻塞操作时，它会被钉住</li>
<li><strong>native 方法执行期间</strong>：当虚拟线程执行 native 方法（JNI 调用）时，它会被钉住</li>
</ol>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;Pinning 的两种场景&quot;
        direction TB
        
        subgraph &quot;场景1：synchronized 块&quot;
            S1[&quot;进入 synchronized 块&quot;]
            S2[&quot;执行阻塞操作&lt;br/&gt;（如 I/O、sleep）&quot;]
            S3[&quot;虚拟线程被钉住&lt;br/&gt;载体线程被阻塞&quot;]
            
            S1 --&gt; S2 --&gt; S3
            style S3 fill:#ffcdd2
        end
        
        subgraph &quot;场景2：native 方法&quot;
            N1[&quot;调用 native 方法&lt;br/&gt;（JNI）&quot;]
            N2[&quot;执行 native 代码&quot;]
            N3[&quot;虚拟线程被钉住&lt;br/&gt;载体线程被占用&quot;]
            
            N1 --&gt; N2 --&gt; N3
            style N3 fill:#ffcdd2
        end
    end</code></pre>
<p>当虚拟线程在 synchronized 块内执行阻塞操作时，它会被&quot;钉住&quot;到载体线程上，无法让出：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant VT as 虚拟线程
    participant CT as 载体线程
    participant LOCK as synchronized 锁
    participant IO as 阻塞 IO
    
    VT-&gt;&gt;CT: 挂载到载体线程
    VT-&gt;&gt;LOCK: 进入 synchronized 块
    Note over VT,CT: 虚拟线程被&quot;钉住&quot;
    VT-&gt;&gt;IO: 执行阻塞 IO
    Note over CT: 载体线程被阻塞！&lt;br/&gt;无法执行其他虚拟线程
    IO--&gt;&gt;VT: IO 完成
    VT-&gt;&gt;LOCK: 退出 synchronized 块
    Note over VT,CT: 解除钉住</code></pre>
<h3 id="synchronized-vs-reentrantlock-在虚拟线程中的表现">synchronized vs ReentrantLock 在虚拟线程中的表现</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>虚拟线程阻塞时</strong></td>
<td>钉住载体线程</td>
<td>可以让出载体线程</td>
</tr>
<tr>
<td><strong>原因</strong></td>
<td>JVM 内置锁，与虚拟线程调度器集成不完善</td>
<td>基于 <code>LockSupport.park()</code>，已适配虚拟线程</td>
</tr>
<tr>
<td><strong>JDK 21+ 建议</strong></td>
<td>避免在 synchronized 块内执行阻塞操作</td>
<td>推荐用于虚拟线程场景</td>
</tr>
</tbody>
</table>
<h3 id="最佳实践">最佳实践</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不推荐：synchronized 块内的阻塞操作会钉住载体线程</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">badMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 危险：阻塞操作会钉住虚拟线程</span><br>    socket.read();  <span class="hljs-comment">// 载体线程被阻塞</span><br>&#125;<br><br><span class="hljs-comment">// 推荐：使用 ReentrantLock</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">goodMethod</span><span class="hljs-params">()</span> &#123;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        socket.read();  <span class="hljs-comment">// 虚拟线程可以让出载体线程</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="诊断-pinning-问题">诊断 Pinning 问题</h3>
<p>可以使用以下 JVM 参数诊断 Pinning：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打印 Pinning 事件</span><br>-Djdk.tracePinnedThreads=full<br><br><span class="hljs-comment"># 或使用 JFR 事件</span><br>-XX:StartFlightRecording:filename=recording.jfr<br></code></pre></td></tr></table></figure>
<p><strong>注意</strong>：虚拟线程的详细使用指南请参考 <a href="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/">Java 线程池笔记</a> 中的虚拟线程章节。</p>
<h2 id="虚拟线程对中间件和框架的影响">虚拟线程对中间件和框架的影响</h2>
<p>虚拟线程的引入不仅影响锁的使用方式，还对整个 Java 生态系统产生深远影响。Servlet 容器、Spring 框架、数据库连接池、HTTP 客户端等中间件都需要适配或重新评估其设计。</p>
<h3 id="servlet-容器的变革">Servlet 容器的变革</h3>
<h4 id="传统线程模型的局限">传统线程模型的局限</h4>
<p>传统 Servlet 容器（Tomcat、Jetty、Undertow）采用&quot;一请求一线程&quot;模型：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;传统 Servlet 线程模型&quot;
        REQ[&quot;HTTP 请求&quot;]
        TP[&quot;线程池&lt;br/&gt;（200-500 线程）&quot;]
        T1[&quot;线程 1&quot;]
        T2[&quot;线程 2&quot;]
        TN[&quot;线程 N&quot;]
        S1[&quot;Servlet 处理&quot;]
        S2[&quot;Servlet 处理&quot;]
        SN[&quot;Servlet 处理&quot;]
        
        REQ --&gt; TP
        TP --&gt; T1 --&gt; S1
        TP --&gt; T2 --&gt; S2
        TP --&gt; TN --&gt; SN
        
        style TP fill:#ffcdd2
    end
    
    subgraph &quot;资源消耗&quot;
        MEM[&quot;内存：N × 1MB 栈空间&quot;]
        CTX[&quot;上下文切换开销&quot;]
        LIMIT[&quot;并发上限：线程池大小&quot;]
        
        style MEM fill:#ffcdd2
        style CTX fill:#ffcdd2
        style LIMIT fill:#ffcdd2
    end</code></pre>
<p>线程池大小直接限制了并发处理能力。当所有线程都在等待 I/O（数据库查询、RPC 调用）时，新请求只能排队等待。</p>
<h4 id="虚拟线程模型">虚拟线程模型</h4>
<p>Tomcat 10.1+、Jetty 12+、Undertow 2.3+ 已支持虚拟线程：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;虚拟线程 Servlet 模型&quot;
        REQ[&quot;HTTP 请求&quot;]
        VTE[&quot;虚拟线程执行器&quot;]
        VT1[&quot;虚拟线程 1&quot;]
        VT2[&quot;虚拟线程 2&quot;]
        VTN[&quot;虚拟线程 N&lt;br/&gt;（可达数十万）&quot;]
        CT[&quot;载体线程池&lt;br/&gt;（CPU 核心数）&quot;]
        
        REQ --&gt; VTE
        VTE --&gt; VT1
        VTE --&gt; VT2
        VTE --&gt; VTN
        VT1 -.-&gt;|&quot;挂载/卸载&quot;| CT
        VT2 -.-&gt;|&quot;挂载/卸载&quot;| CT
        VTN -.-&gt;|&quot;挂载/卸载&quot;| CT
        
        style VTE fill:#c8e6c9
        style CT fill:#c8e6c9
    end</code></pre>
<p><strong>Tomcat 配置示例</strong>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- server.xml --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8080&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;HTTP/1.1&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用虚拟线程执行器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Executor</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;virtualThreadExecutor&quot;</span> </span><br><span class="hljs-tag">              <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.core.VirtualThreadExecutor&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Connector</span>&gt;</span><br></code></pre></td></tr></table></figure>
<p><strong>Spring Boot 3.2+ 配置</strong>：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># application.yml</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">threads:</span><br>    <span class="hljs-attr">virtual:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 启用虚拟线程</span><br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 或通过代码配置</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VirtualThreadConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> TomcatProtocolHandlerCustomizer&lt;?&gt; protocolHandlerVirtualThreadExecutorCustomizer() &#123;<br>        <span class="hljs-keyword">return</span> protocolHandler -&gt; &#123;<br>            protocolHandler.setExecutor(Executors.newVirtualThreadPerTaskExecutor());<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="性能对比">性能对比</h4>
<table>
<thead>
<tr>
<th>指标</th>
<th>传统线程池（500线程）</th>
<th>虚拟线程</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>最大并发连接</strong></td>
<td>~500</td>
<td>数十万</td>
</tr>
<tr>
<td><strong>内存占用（仅线程栈）</strong></td>
<td>~500MB</td>
<td>~几十MB</td>
</tr>
<tr>
<td><strong>I/O 等待时资源利用</strong></td>
<td>线程被阻塞，资源浪费</td>
<td>自动让出，资源复用</td>
</tr>
<tr>
<td><strong>配置复杂度</strong></td>
<td>需要精细调优</td>
<td>大幅简化</td>
</tr>
</tbody>
</table>
<h3 id="spring-framework-的适配">Spring Framework 的适配</h3>
<h4 id="spring-mvc">Spring MVC</h4>
<p>Spring MVC 6.1+ 与虚拟线程配合良好：</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph &quot;传统模式&quot;
        R1[&quot;请求&quot;] --&gt; C1[&quot;Controller&quot;]
        C1 --&gt; S1[&quot;Service&quot;]
        S1 --&gt; D1[&quot;DAO&quot;]
        D1 --&gt;|&quot;阻塞等待&quot;| DB1[&quot;数据库&quot;]
        
        style D1 fill:#ffcdd2
    end
    
    subgraph &quot;虚拟线程模式&quot;
        R2[&quot;请求&quot;] --&gt; C2[&quot;Controller&quot;]
        C2 --&gt; S2[&quot;Service&quot;]
        S2 --&gt; D2[&quot;DAO&quot;]
        D2 --&gt;|&quot;自动让出&quot;| DB2[&quot;数据库&quot;]
        
        style D2 fill:#c8e6c9
    end</code></pre>
<p><strong>关键变化</strong>：</p>
<ol>
<li><strong>简化异步编程</strong>：不再需要 <code>@Async</code> 和 <code>CompletableFuture</code> 来避免阻塞</li>
<li><strong>保持同步代码风格</strong>：Controller 方法可以直接返回结果，无需返回 <code>Mono</code> 或 <code>Flux</code></li>
<li><strong>完整调用栈</strong>：异常堆栈信息完整，便于调试</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 传统异步方式（复杂）</span><br><span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> CompletableFuture&lt;User&gt; <span class="hljs-title function_">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> CompletableFuture.supplyAsync(() -&gt; userService.findById(id));<br>&#125;<br><br><span class="hljs-comment">// 虚拟线程方式（简单，同样高效）</span><br><span class="hljs-meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> userService.findById(id);  <span class="hljs-comment">// 阻塞但不占用平台线程</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="spring-webflux-的定位变化">Spring WebFlux 的定位变化</h4>
<p>Spring WebFlux 是响应式编程模型，与虚拟线程的关系需要重新审视：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;选择决策&quot;
        Q1&#123;&quot;应用类型？&quot;&#125;
        Q2&#123;&quot;需要背压控制？&quot;&#125;
        Q3&#123;&quot;团队熟悉度？&quot;&#125;
        
        Q1 --&gt;|&quot;I/O 密集型&quot;| Q2
        Q1 --&gt;|&quot;CPU 密集型&quot;| PT[&quot;平台线程&quot;]
        
        Q2 --&gt;|&quot;是&quot;| WF[&quot;WebFlux&quot;]
        Q2 --&gt;|&quot;否&quot;| Q3
        
        Q3 --&gt;|&quot;熟悉响应式&quot;| WF
        Q3 --&gt;|&quot;偏好同步代码&quot;| VT[&quot;虚拟线程 + MVC&quot;]
        
        style VT fill:#c8e6c9
        style WF fill:#fff9c4
        style PT fill:#e1bee7
    end</code></pre>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
<th>理由</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>新建 I/O 密集型服务</strong></td>
<td>虚拟线程 + Spring MVC</td>
<td>代码简单，性能优秀</td>
</tr>
<tr>
<td><strong>需要流式处理/背压</strong></td>
<td>Spring WebFlux</td>
<td>响应式流原生支持</td>
</tr>
<tr>
<td><strong>现有 WebFlux 项目</strong></td>
<td>继续使用 WebFlux</td>
<td>迁移成本高，收益有限</td>
</tr>
<tr>
<td><strong>混合场景</strong></td>
<td>两者结合</td>
<td>WebFlux 处理流，MVC 处理普通请求</td>
</tr>
</tbody>
</table>
<p><strong>Brian Goetz 的观点</strong>：虚拟线程不是要取代响应式编程，而是为那些不需要响应式编程复杂性的场景提供更简单的选择。</p>
<h3 id="数据库访问层的影响">数据库访问层的影响</h3>
<h4 id="jdbc-驱动">JDBC 驱动</h4>
<p>大多数 JDBC 驱动使用阻塞 I/O，在虚拟线程上可以正常工作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在虚拟线程中执行</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> dataSource.getConnection();<br>     <span class="hljs-type">PreparedStatement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> conn.prepareStatement(<span class="hljs-string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>)) &#123;<br>    stmt.setLong(<span class="hljs-number">1</span>, userId);<br>    <span class="hljs-keyword">try</span> (<span class="hljs-type">ResultSet</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> stmt.executeQuery()) &#123;  <span class="hljs-comment">// 阻塞但自动让出</span><br>        <span class="hljs-comment">// 处理结果</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>潜在问题</strong>：</p>
<ol>
<li><strong>驱动内部的 synchronized</strong>：某些 JDBC 驱动内部使用 synchronized 块，可能导致 Pinning</li>
<li><strong>连接验证</strong>：连接池的连接验证逻辑可能包含阻塞操作</li>
</ol>
<p><strong>主流驱动适配状态</strong>：</p>
<table>
<thead>
<tr>
<th>驱动</th>
<th>虚拟线程兼容性</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>MySQL Connector/J 8.1+</td>
<td>良好</td>
<td>已优化减少 Pinning</td>
</tr>
<tr>
<td>PostgreSQL JDBC 42.6+</td>
<td>良好</td>
<td>支持虚拟线程</td>
</tr>
<tr>
<td>Oracle JDBC 23c+</td>
<td>良好</td>
<td>官方支持</td>
</tr>
<tr>
<td>H2</td>
<td>需评估</td>
<td>部分场景有 Pinning</td>
</tr>
</tbody>
</table>
<h4 id="连接池重新评估">连接池重新评估</h4>
<p>虚拟线程场景下，连接池配置需要重新考量：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;传统场景&quot;
        TP1[&quot;线程池：500&quot;]
        CP1[&quot;连接池：50&quot;]
        RATIO1[&quot;比例 10:1&quot;]
        
        TP1 --&gt; CP1
        CP1 --&gt; RATIO1
    end
    
    subgraph &quot;虚拟线程场景&quot;
        VT[&quot;虚拟线程：100,000&quot;]
        CP2[&quot;连接池：???&quot;]
        BOTTLENECK[&quot;连接池成为瓶颈&quot;]
        
        VT --&gt; CP2
        CP2 --&gt; BOTTLENECK
        
        style BOTTLENECK fill:#ffcdd2
    end</code></pre>
<p><strong>HikariCP 配置建议</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HikariConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HikariConfig</span>();<br><span class="hljs-comment">// 虚拟线程场景下，可能需要增加连接数</span><br>config.setMaximumPoolSize(<span class="hljs-number">100</span>);  <span class="hljs-comment">// 根据数据库承载能力调整</span><br><span class="hljs-comment">// 减少连接获取超时，快速失败</span><br>config.setConnectionTimeout(<span class="hljs-number">5000</span>);<br><span class="hljs-comment">// 启用连接泄漏检测</span><br>config.setLeakDetectionThreshold(<span class="hljs-number">30000</span>);<br></code></pre></td></tr></table></figure>
<p><strong>关键洞察</strong>：虚拟线程解决了线程资源瓶颈，但数据库连接、外部服务连接等资源仍然是有限的。需要通过信号量或其他机制限制并发访问这些稀缺资源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 Semaphore 限制数据库并发访问</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">dbSemaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">100</span>);<br><br><span class="hljs-keyword">public</span> User <span class="hljs-title function_">findUser</span><span class="hljs-params">(Long id)</span> &#123;<br>    dbSemaphore.acquire();  <span class="hljs-comment">// 虚拟线程在此等待时会自动让出</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.queryForObject(<span class="hljs-string">&quot;SELECT * FROM users WHERE id = ?&quot;</span>, <br>                                           userRowMapper, id);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        dbSemaphore.release();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="http-客户端的适配">HTTP 客户端的适配</h3>
<h4 id="java-httpclient">Java HttpClient</h4>
<p>JDK 11 引入的 <code>java.net.http.HttpClient</code> 已完全适配虚拟线程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">HttpClient</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> HttpClient.newHttpClient();<br><br><span class="hljs-comment">// 同步调用，在虚拟线程上自动让出</span><br>HttpResponse&lt;String&gt; response = client.send(<br>    HttpRequest.newBuilder()<br>        .uri(URI.create(<span class="hljs-string">&quot;https://api.example.com/data&quot;</span>))<br>        .build(),<br>    HttpResponse.BodyHandlers.ofString()<br>);<br></code></pre></td></tr></table></figure>
<h4 id="第三方客户端">第三方客户端</h4>
<table>
<thead>
<tr>
<th>客户端</th>
<th>虚拟线程兼容性</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Apache HttpClient 5.x</td>
<td>良好</td>
<td>已适配</td>
</tr>
<tr>
<td>OkHttp 4.x+</td>
<td>需评估</td>
<td>内部有 synchronized</td>
</tr>
<tr>
<td>RestTemplate</td>
<td>良好</td>
<td>底层使用适配的客户端即可</td>
</tr>
<tr>
<td>WebClient</td>
<td>良好</td>
<td>响应式，与虚拟线程互补</td>
</tr>
</tbody>
</table>
<h3 id="消息中间件客户端">消息中间件客户端</h3>
<h4 id="kafka-client">Kafka Client</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Kafka 消费者在虚拟线程中</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newVirtualThreadPerTaskExecutor()) &#123;<br>    executor.submit(() -&gt; &#123;<br>        <span class="hljs-keyword">while</span> (running) &#123;<br>            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="hljs-number">100</span>));<br>            <span class="hljs-keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;<br>                processRecord(record);  <span class="hljs-comment">// 每条消息可以在独立虚拟线程处理</span><br>            &#125;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>注意事项</strong>：</p>
<ul>
<li>Kafka 客户端内部有 synchronized 块，可能导致 Pinning</li>
<li>建议关注 Kafka 客户端的更新版本</li>
</ul>
<h4 id="rocketmq-rabbitmq">RocketMQ / RabbitMQ</h4>
<p>类似的考量适用于其他消息中间件客户端。建议：</p>
<ol>
<li>使用最新版本的客户端</li>
<li>通过 <code>-Djdk.tracePinnedThreads=full</code> 诊断 Pinning 问题</li>
<li>必要时使用 ReentrantLock 替换 synchronized</li>
</ol>
<h3 id="threadlocal-的重新审视">ThreadLocal 的重新审视</h3>
<p>虚拟线程场景下，ThreadLocal 的使用需要特别注意：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;传统场景&quot;
        PT[&quot;500 平台线程&quot;]
        TL1[&quot;ThreadLocal 实例&quot;]
        MEM1[&quot;内存：500 × 对象大小&quot;]
        
        PT --&gt; TL1 --&gt; MEM1
    end
    
    subgraph &quot;虚拟线程场景&quot;
        VT[&quot;100,000 虚拟线程&quot;]
        TL2[&quot;ThreadLocal 实例&quot;]
        MEM2[&quot;内存：100,000 × 对象大小&quot;]
        
        VT --&gt; TL2 --&gt; MEM2
        
        style MEM2 fill:#ffcdd2
    end</code></pre>
<p><strong>问题</strong>：</p>
<ol>
<li><strong>内存放大</strong>：虚拟线程数量可能是平台线程的 1000 倍，ThreadLocal 内存占用同比放大</li>
<li><strong>生命周期</strong>：虚拟线程通常是短生命周期的，ThreadLocal 的清理时机需要注意</li>
</ol>
<p><strong>替代方案</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 不推荐：在虚拟线程中使用 ThreadLocal 存储大对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;ExpensiveObject&gt; cache = <br>    ThreadLocal.withInitial(ExpensiveObject::<span class="hljs-keyword">new</span>);<br><br><span class="hljs-comment">// 推荐：使用 Scoped Values（JEP 446，JDK 21-23 预览特性）</span><br><span class="hljs-comment">// 注意：ScopedValue 在 JDK 21、22、23 中均为预览特性，需要 --enable-preview</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ScopedValue&lt;RequestContext&gt; CONTEXT = ScopedValue.newInstance();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleRequest</span><span class="hljs-params">(RequestContext ctx)</span> &#123;<br>    ScopedValue.where(CONTEXT, ctx).run(() -&gt; &#123;<br>        <span class="hljs-comment">// 在此作用域内可以访问 CONTEXT.get()</span><br>        <span class="hljs-comment">// ScopedValue 是不可变的，比 ThreadLocal 更适合虚拟线程</span><br>        processRequest();<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="迁移策略与最佳实践">迁移策略与最佳实践</h3>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;迁移阶段&quot;
        P1[&quot;阶段1：评估&quot;]
        P2[&quot;阶段2：试点&quot;]
        P3[&quot;阶段3：推广&quot;]
        P4[&quot;阶段4：优化&quot;]
        
        P1 --&gt; P2 --&gt; P3 --&gt; P4
    end
    
    subgraph &quot;阶段1：评估&quot;
        E1[&quot;识别 I/O 密集型服务&quot;]
        E2[&quot;检查依赖库兼容性&quot;]
        E3[&quot;评估 Pinning 风险&quot;]
    end
    
    subgraph &quot;阶段2：试点&quot;
        T1[&quot;选择非关键服务&quot;]
        T2[&quot;启用虚拟线程&quot;]
        T3[&quot;监控性能指标&quot;]
        T4[&quot;诊断 Pinning&quot;]
    end
    
    subgraph &quot;阶段3：推广&quot;
        R1[&quot;更新依赖版本&quot;]
        R2[&quot;替换 synchronized&quot;]
        R3[&quot;调整连接池配置&quot;]
    end
    
    subgraph &quot;阶段4：优化&quot;
        O1[&quot;减少 ThreadLocal 使用&quot;]
        O2[&quot;优化资源限制策略&quot;]
        O3[&quot;持续监控&quot;]
    end
    
    P1 --&gt; E1
    P2 --&gt; T1
    P3 --&gt; R1
    P4 --&gt; O1</code></pre>
<p><strong>迁移检查清单</strong>：</p>
<ol>
<li><strong>JDK 版本</strong>：升级到 JDK 21+</li>
<li><strong>框架版本</strong>：
<ul>
<li>Spring Boot 3.2+</li>
<li>Tomcat 10.1+ / Jetty 12+ / Undertow 2.3+</li>
</ul>
</li>
<li><strong>依赖库检查</strong>：
<ul>
<li>JDBC 驱动版本</li>
<li>HTTP 客户端版本</li>
<li>消息中间件客户端版本</li>
</ul>
</li>
<li><strong>代码审查</strong>：
<ul>
<li>识别 synchronized 块内的阻塞操作</li>
<li>审查 ThreadLocal 使用</li>
<li>检查 native 方法调用</li>
</ul>
</li>
<li><strong>配置调整</strong>：
<ul>
<li>连接池大小</li>
<li>超时设置</li>
<li>资源限制策略</li>
</ul>
</li>
<li><strong>监控指标</strong>：
<ul>
<li>虚拟线程数量</li>
<li>Pinning 事件</li>
<li>载体线程利用率</li>
</ul>
</li>
</ol>
<h2 id="结构化并发-structured-concurrency">结构化并发（Structured Concurrency）</h2>
<p>结构化并发的完整内容已独立成文，详见 <a href="https://magicliang.github.io/2026/02/07/Java-%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91">Java 结构化并发</a>。</p>
<p>结构化并发是 Java 并发编程的重要演进方向，与虚拟线程紧密配合，旨在解决传统并发编程中的线程泄漏、错误处理困难等问题。其核心原则是将并发任务的生命周期与代码的词法作用域绑定，通过 <code>StructuredTaskScope</code> API 实现自动的错误传播和取消传播。</p>
<p>关于 JVM 内存模型（JMM）的详细定义、八种内存操作、happens-before 规则、对象内存布局与指针压缩等内容，请参阅<a href="/2026/02/07/JVM-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">《JVM 的内存模型与线程》</a>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="Java 并发编程笔记"><img class="cover" src="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-12</div><div class="info-item-2">Java 并发编程笔记</div></div><div class="info-2"><div class="info-item-1"> juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 什么是管程 管程（Monitor）是一种并发编程的抽象数据结构，由 C.A.R. Hoare 和 Per Brinch Hansen 在 1970 年代提出。它比&quot;锁&quot;的概念更大——锁只是管程的一部分。 管程的完整定义： 1234567891011121314151617181920212223242526272829303132┌─────────────────────────────────────────────────────────────────────┐│                        管程（Monitor）                               │├──────────────────────────...</div></div></div></a><a class="pagination-related" href="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" title="无锁队列"><img class="cover" src="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">无锁队列</div></div><div class="info-2"><div class="info-item-1">Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。 * * &lt;p&gt;原理说明： * - 仅允许一个线程调用 &#123;@code offer()&#125;，一个线程调用 &#123;@code poll()&#125;。 * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。 * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系： *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。 * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad）， *   ...</div></div></div></a><a class="pagination-related" href="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/" title="Java 线程池笔记"><img class="cover" src="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-24</div><div class="info-item-2">Java 线程池笔记</div></div><div class="info-2"><div class="info-item-1">从执行器到线程池（from executor interface to thread pool implementation）  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia “池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。 在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括： 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection Pool...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-137.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-76.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-151.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">卡表和 RSet 问题定义：为什么需要跨区域引用记录 JVM 垃圾收集器的核心工作之一是确定 live set——哪些对象仍然存活、不可回收。确定 live set 的标准做法是从 GC Roots（栈帧中的局部变量、静态字段等）出发，沿引用链遍历所有可达对象。 问题在于：当堆被划分为多个区域（代、Region）并且只回收其中一部分时，如何高效地找到从&quot;不回收区域&quot;指向&quot;回收区域&quot;的引用？ 以 Young GC 为例：只回收新生代，但老年代中可能持有指向新生代对象的引用。如果不处理这些跨代引用，就会错误地回收仍被老年代引用的新生代对象。最朴素的做法是扫描整个老年代来找出这些引用——但老年代通常远大于新生代，这样做的代价过高，违背了分代收集&quot;只回收一部分堆&quot;的初衷。 卡表（Card Table）和 RSet（Remembered Set）正是为解决这个问题而设计的辅助数据结构。二者的关系并非互相替代，而是层次不同、协作互补：卡表是底层的脏标记机制，RSet 是建立在卡表之上的更高层索引结构。 核心概念速览 在深入细节之前，...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.1.</span> <span class="toc-text">什么是线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">1.2.</span> <span class="toc-text">Java 内存模型基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.2.1.</span> <span class="toc-text">为什么需要内存模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jmm-%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">JMM 的抽象模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.3.</span> <span class="toc-text">线程安全的三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8E%9F%E5%AD%90%E6%80%A7-atomicity"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">1. 原子性（Atomicity）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8F%AF%E8%A7%81%E6%80%A7-visibility"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">2. 可见性（Visibility）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%9C%89%E5%BA%8F%E6%80%A7-ordering"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">3. 有序性（Ordering）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#happens-before-%E8%A7%84%E5%88%99"><span class="toc-number">1.2.4.</span> <span class="toc-text">happens-before 规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jmm-%E5%AE%9A%E4%B9%89%E7%9A%84-happens-before-%E8%A7%84%E5%88%99"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">JMM 定义的 happens-before 规则</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.5.</span> <span class="toc-text">volatile 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">volatile 的语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E7%9A%84%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">volatile 的内存屏障</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.2.6.</span> <span class="toc-text">深入理解内存屏障</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9F"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">为什么需要内存屏障？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">1.2.6.2.</span> <span class="toc-text">内存屏障的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jvm-%E5%A6%82%E4%BD%95%E6%98%A0%E5%B0%84%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.2.6.3.</span> <span class="toc-text">JVM 如何映射内存屏障</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.2.6.4.</span> <span class="toc-text">volatile 的底层实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C-vs-gc-%E5%B1%8F%E9%9A%9C%EF%BC%9A%E5%90%8D%E5%AD%97%E7%9B%B8%E5%90%8C-%E6%9C%AC%E8%B4%A8%E4%B8%8D%E5%90%8C"><span class="toc-number">1.2.7.</span> <span class="toc-text">内存屏障 vs GC 屏障：名字相同，本质不同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#g1-%E7%9A%84%E5%86%99%E5%B1%8F%E9%9A%9C-write-barrier"><span class="toc-number">1.2.7.1.</span> <span class="toc-text">G1 的写屏障（Write Barrier）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#zgc-%E7%9A%84%E8%AF%BB%E5%B1%8F%E9%9A%9C-load-barrier"><span class="toc-number">1.2.7.2.</span> <span class="toc-text">ZGC 的读屏障（Load Barrier）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mesi-%E5%8D%8F%E8%AE%AE%EF%BC%9A%E7%BC%93%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E7%9A%84%E5%9F%BA%E7%9F%B3"><span class="toc-number">1.2.8.</span> <span class="toc-text">MESI 协议：缓存一致性的基石</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mesi-%E7%9A%84%E5%9B%9B%E7%A7%8D%E7%8A%B6%E6%80%81"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">MESI 的四种状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mesi-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">MESI 的工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mesi-%E4%B8%8E-jmm-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">MESI 与 JMM 的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E7%BC%93%E5%AD%98-cache-line-locking"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">“锁缓存”（Cache Line Locking）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86-mesi-%E8%BF%98%E9%9C%80%E8%A6%81%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C%EF%BC%9F"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">为什么有了 MESI 还需要内存屏障？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E4%B8%8E%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C"><span class="toc-number">1.2.9.</span> <span class="toc-text">synchronized 与内存屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.10.</span> <span class="toc-text">小结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile-%E7%9A%84%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">volatile 的正确使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E4%B8%8E-volatile-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">1.2.11.</span> <span class="toc-text">synchronized 与 volatile 的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E-%E4%B8%80%E8%87%B4%E6%80%A7-%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">1.2.12.</span> <span class="toc-text">关于&quot;一致性&quot;的说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final-%E5%AD%97%E6%AE%B5%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.13.</span> <span class="toc-text">final 字段的内存语义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#final-%E5%AD%97%E6%AE%B5%E7%9A%84%E5%86%99%E5%85%A5%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.13.1.</span> <span class="toc-text">final 字段的写入语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-%E5%AD%97%E6%AE%B5%E7%9A%84%E8%AF%BB%E5%8F%96%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.13.2.</span> <span class="toc-text">final 字段的读取语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8-final-%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.2.13.3.</span> <span class="toc-text">正确使用 final 的示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-%E8%AF%AD%E4%B9%89%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.2.13.4.</span> <span class="toc-text">final 语义的限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#final-vs-volatile-vs-synchronized"><span class="toc-number">1.2.13.5.</span> <span class="toc-text">final vs volatile vs synchronized</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">1.2.14.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">线程安全的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98-immutable"><span class="toc-number">1.3.1.</span> <span class="toc-text">不可变（Immutable）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-absolute-thread-safety"><span class="toc-number">1.3.2.</span> <span class="toc-text">绝对线程安全（Absolute Thread Safety）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-relative-thread-safety"><span class="toc-number">1.3.3.</span> <span class="toc-text">相对线程安全（Relative Thread Safety）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%BC%E5%AE%B9-thread-compatible"><span class="toc-number">1.3.4.</span> <span class="toc-text">线程兼容（Thread Compatible）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AF%B9%E7%AB%8B-thread-hostile"><span class="toc-number">1.3.5.</span> <span class="toc-text">线程对立（Thread Hostile）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.4.</span> <span class="toc-text">线程安全的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5-mutual-exclusion-synchronization"><span class="toc-number">1.4.1.</span> <span class="toc-text">互斥同步（Mutual Exclusion &amp; Synchronization)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">为什么需要可中断锁？使用场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.4.1.1.1.</span> <span class="toc-text">典型使用场景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81-vs-%E4%B8%8D%E5%8F%AF%E4%B8%AD%E6%96%AD%E9%94%81"><span class="toc-number">1.4.1.1.2.</span> <span class="toc-text">可中断锁 vs 不可中断锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#synchronized-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%AD%E6%96%AD%EF%BC%9F"><span class="toc-number">1.4.1.1.3.</span> <span class="toc-text">synchronized 为什么不支持中断？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E7%9A%84%E5%85%AC%E5%B9%B3%E6%80%A7%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90"><span class="toc-number">1.4.2.</span> <span class="toc-text">synchronized 的公平性深入分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-synchronized-%E6%98%AF%E9%9D%9E%E5%85%AC%E5%B9%B3%E7%9A%84"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">为什么 synchronized 是非公平的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#objectmonitor-%E7%9A%84-entrylist-%E7%AB%9E%E4%BA%89%E6%9C%BA%E5%88%B6"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">ObjectMonitor 的 EntryList 竞争机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E4%B8%8E-reentrantlock-%E5%85%AC%E5%B9%B3%E6%80%A7%E5%AF%B9%E6%AF%94"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">synchronized 与 ReentrantLock 公平性对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8A%BF"><span class="toc-number">1.4.2.4.</span> <span class="toc-text">非公平锁的性能优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5-non-blocking-synchronization"><span class="toc-number">1.4.3.</span> <span class="toc-text">非阻塞同步（Non-Blocking Synchronization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.4.</span> <span class="toc-text">无同步方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A3%E7%A0%81-reentrant-code"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">可重入代码（Reentrant Code）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8-thread-local-storage"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">线程本地存储（Thread Local Storage）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">对象头</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#klass-pointer-%E4%B8%8E%E7%B1%BB%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.</span> <span class="toc-text">Klass Pointer 与类元数据的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mark-word-%E4%B8%8E-monitor-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.</span> <span class="toc-text">Mark Word 与 Monitor 的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#monitor-%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.</span> <span class="toc-text">Monitor 与操作系统同步原语的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E8%AF%AD-primitive-%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">什么是原语（Primitive）？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E4%BC%98%E5%8C%96%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E6%80%81%E9%94%81-vs-%E5%86%85%E6%A0%B8%E6%80%81%E9%94%81"><span class="toc-number">3.1.</span> <span class="toc-text">锁优化的设计哲学：用户态锁 vs 内核态锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%A0%87%E5%BF%97%E6%80%A7%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">锁升级的标志性事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E9%94%81%E5%AF%B9-mark-word-%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">3.1.2.</span> <span class="toc-text">三种锁对 Mark Word 的处理策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E9%94%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.1.3.</span> <span class="toc-text">三种锁的数据结构对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#objectmonitor-%E7%9A%84%E4%B8%89%E4%B8%AA%E9%98%9F%E5%88%97%EF%BC%9Acxq-entrylist-waitset-%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">ObjectMonitor 的三个队列：cxq、EntryList、WaitSet 详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E7%9A%84%E9%9D%9E%E5%85%AC%E5%B9%B3%E6%80%A7%EF%BC%9A%E5%AE%8C%E6%95%B4%E6%9C%BA%E5%88%B6%E5%88%86%E6%9E%90"><span class="toc-number">3.1.3.2.</span> <span class="toc-text">synchronized 的非公平性：完整机制分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E5%85%A8%E6%99%AF%E5%9B%BE%EF%BC%9A%E4%BB%8E%E6%97%A0%E9%94%81%E5%88%B0%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%AE%8C%E6%95%B4%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.4.</span> <span class="toc-text">锁升级全景图：从无锁到重量级锁的完整状态转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4-lock-elimination"><span class="toc-number">3.2.</span> <span class="toc-text">锁消除（Lock Elimination）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E6%B6%88%E9%99%A4%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">什么是锁消除？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">锁消除的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4%E7%9A%84%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.3.</span> <span class="toc-text">锁消除的典型场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reentrantlock-%E8%83%BD%E8%A2%AB%E6%B6%88%E9%99%A4%E5%90%97%EF%BC%9F"><span class="toc-number">3.2.4.</span> <span class="toc-text">ReentrantLock 能被消除吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E9%94%81%E6%B6%88%E9%99%A4%E6%98%AF%E5%90%A6%E7%94%9F%E6%95%88%EF%BC%9F"><span class="toc-number">3.2.5.</span> <span class="toc-text">如何验证锁消除是否生效？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96-lock-coarsening"><span class="toc-number">3.3.</span> <span class="toc-text">锁粗化（Lock Coarsening）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%B2%97%E5%8C%96%EF%BC%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text">什么是锁粗化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96%E7%9A%84%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.2.</span> <span class="toc-text">锁粗化的典型场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-number">3.3.3.</span> <span class="toc-text">锁粗化的权衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96-vs-%E9%94%81%E7%BB%86%E5%8C%96"><span class="toc-number">3.3.4.</span> <span class="toc-text">锁粗化 vs 锁细化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E9%94%81%E7%B2%97%E5%8C%96%EF%BC%9F"><span class="toc-number">3.3.5.</span> <span class="toc-text">如何控制锁粗化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80-lock-inflation"><span class="toc-number">3.4.</span> <span class="toc-text">锁膨胀（Lock Inflation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A%E9%94%81%E7%8A%B6%E6%80%81%E4%B8%8E%E7%AD%89%E5%BE%85%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text">概述：锁状态与等待机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81-biased-lock"><span class="toc-number">3.4.2.</span> <span class="toc-text">偏向锁（Biased Lock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E4%B8%80%E4%B8%AA-%E5%86%99%E5%9C%A8-mark-word-%E9%87%8C%E7%9A%84-volatile-threadid"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">偏向锁的本质：一个&quot;写在 Mark Word 里的 volatile threadId&quot;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashcode-%E4%B8%8E%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E4%BA%92%E6%96%A5"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">hashCode 与偏向锁的互斥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-lightweight-lock"><span class="toc-number">3.4.3.</span> <span class="toc-text">轻量级锁（Lightweight Lock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-vs-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9A%E5%88%B0%E5%BA%95-%E8%BD%BB-%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">轻量级锁 vs 重量级锁：到底&quot;轻&quot;在哪里？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-record-%E4%B8%8D%E6%98%AF%E9%94%81%E6%9C%AC%E8%BA%AB-mark-word-%E6%89%8D%E6%98%AF"><span class="toc-number">3.4.4.</span> <span class="toc-text">Lock Record 不是锁本身，Mark Word 才是</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objectmonitor-%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.4.5.</span> <span class="toc-text">ObjectMonitor 的创建时机与生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%B8%A7%E4%B8%8E-lock-record-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.6.</span> <span class="toc-text">线程栈帧与 Lock Record 的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-record-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E7%94%9F%E8%80%81%E7%97%85%E6%AD%BB"><span class="toc-number">3.4.7.</span> <span class="toc-text">Lock Record 的生命周期（生老病死）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E6%B2%A1%E6%9C%89-waitset-%E5%92%8C-entrylist-%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.4.8.</span> <span class="toc-text">轻量级锁没有 WaitSet 和 EntryList 的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%B8%8E%E9%98%BB%E5%A1%9E%EF%BC%9A%E9%94%81%E7%AD%89%E5%BE%85%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.9.</span> <span class="toc-text">自旋与阻塞：锁等待机制的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">3.4.9.1.</span> <span class="toc-text">自旋优化的必要性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.9.2.</span> <span class="toc-text">自旋锁的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E6%AC%A1%E6%95%B0%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">3.4.9.3.</span> <span class="toc-text">自旋次数的控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.4.9.4.</span> <span class="toc-text">自旋锁的适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80%E7%9A%84%E5%BF%85%E7%84%B6%E6%80%A7%EF%BC%9A%E8%87%AA%E6%97%8B%E5%A4%B1%E8%B4%A5%E6%98%AF%E5%B8%B8%E6%80%81%E8%80%8C%E9%9D%9E%E4%BE%8B%E5%A4%96"><span class="toc-number">3.4.9.5.</span> <span class="toc-text">锁膨胀的必然性：自旋失败是常态而非例外</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-%E7%AB%9E%E4%BA%89-%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E7%AB%9E%E4%BA%89%E7%A8%8B%E5%BA%A6%EF%BC%9F"><span class="toc-number">3.4.10.</span> <span class="toc-text">什么是&quot;竞争&quot;？如何判定竞争程度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%AB%9E%E4%BA%89%E7%9A%84%E8%AF%A6%E7%BB%86%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">3.4.11.</span> <span class="toc-text">锁竞争的详细场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%AB%9E%E4%BA%89%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.11.1.</span> <span class="toc-text">轻量级锁竞争失败的处理策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%AB%9E%E4%BA%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9C%BA%E6%99%AF%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.4.11.2.</span> <span class="toc-text">偏向锁竞争：多线程场景详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E4%B8%8E%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80"><span class="toc-number">3.4.11.3.</span> <span class="toc-text">批量重偏向与批量撤销</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.12.</span> <span class="toc-text">锁升级流程总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9-safepoint-%EF%BC%9A%E4%BB%8E%E9%94%81%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD%E5%88%B0-jvm-%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">安全点（Safepoint）：从锁问题诊断到 JVM 底层机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AD%90%EF%BC%9A%E9%94%81%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-number">3.5.1.</span> <span class="toc-text">引子：锁问题诊断与日志分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E4%B8%8E%E5%AE%89%E5%85%A8%E7%82%B9%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.5.2.</span> <span class="toc-text">日志与安全点的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9Ajvm-%E7%9A%84-%E7%BA%A2%E7%BB%BF%E7%81%AF"><span class="toc-number">3.5.3.</span> <span class="toc-text">安全点的本质：JVM 的&quot;红绿灯&quot;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%BF%AB%E7%85%A7"><span class="toc-number">3.5.4.</span> <span class="toc-text">安全点的本质：线程状态的一致性快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">3.5.5.</span> <span class="toc-text">安全点在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.6.</span> <span class="toc-text">安全点的工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E5%AE%89%E5%85%A8%E7%82%B9%E7%9A%84-vm-%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.7.</span> <span class="toc-text">需要安全点的 VM 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9-vs-%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number">3.5.8.</span> <span class="toc-text">安全点 vs 安全区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-handshake%EF%BC%9A%E6%9B%B4%E7%BB%86%E7%B2%92%E5%BA%A6%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8D%8F%E8%B0%83"><span class="toc-number">3.5.9.</span> <span class="toc-text">Thread Handshake：更细粒度的线程协调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.5.10.</span> <span class="toc-text">安全点与锁的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9B%B8%E5%85%B3%E7%9A%84-jvm-%E6%97%A5%E5%BF%97%E8%AF%8A%E6%96%AD"><span class="toc-number">3.5.11.</span> <span class="toc-text">锁相关的 JVM 日志诊断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E9%94%81%E4%BC%98%E5%8C%96%E7%9A%84%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E5%AF%B9%E6%AF%94"><span class="toc-number">3.5.12.</span> <span class="toc-text">各种锁优化的可观测性对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-aqs-%E7%9C%8B%E9%94%81%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">从 AQS 看锁的抽象模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3%E4%B8%8E%E6%AC%A1%E7%BA%A7%E8%81%8C%E8%B4%A3"><span class="toc-number">3.6.1.</span> <span class="toc-text">锁的核心职责与次级职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E5%A6%82%E4%BD%95%E5%85%B7%E8%B1%A1%E5%8C%96%E8%BF%99%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.6.2.</span> <span class="toc-text">AQS 如何具象化这个抽象模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">3.6.3.</span> <span class="toc-text">synchronized 的内存引用关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reentrantlock-%E7%9A%84%E5%86%85%E5%AD%98%E5%BC%95%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">3.6.4.</span> <span class="toc-text">ReentrantLock 的内存引用关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.6.5.</span> <span class="toc-text">两种锁机制的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#gc-%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8%EF%BC%9F"><span class="toc-number">3.6.6.</span> <span class="toc-text">GC 如何处理循环引用？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">3.6.7.</span> <span class="toc-text">这个抽象模型的意义</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aqs-%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">3.7.</span> <span class="toc-text">AQS 深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-aqs-%E4%B8%8D%E4%BD%BF%E7%94%A8-os-%E5%BA%95%E5%B1%82%E7%9A%84-mutex-conditionvariable"><span class="toc-number">3.7.1.</span> <span class="toc-text">为什么 AQS 不使用 OS 底层的 mutex&#x2F;conditionVariable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#os-%E5%8E%9F%E8%AF%AD%E7%9A%84%E5%BC%80%E9%94%80%E5%88%86%E6%9E%90"><span class="toc-number">3.7.1.1.</span> <span class="toc-text">OS 原语的开销分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aqs-%E7%9A%84%E8%AE%BE%E8%AE%A1%E7%AD%96%E7%95%A5"><span class="toc-number">3.7.1.2.</span> <span class="toc-text">AQS 的设计策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized-%E4%B8%8E-aqs-%E8%BF%9B%E5%85%A5%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E6%97%B6%E6%9C%BA%E5%AF%B9%E6%AF%94"><span class="toc-number">3.7.1.3.</span> <span class="toc-text">synchronized 与 AQS 进入内核态的时机对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">3.7.1.4.</span> <span class="toc-text">性能对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-aqs-%E7%9A%84%E8%87%AA%E6%97%8B%E6%98%AF-%E7%9F%AD%E6%9A%82-%E7%9A%84"><span class="toc-number">3.7.1.5.</span> <span class="toc-text">为什么 AQS 的自旋是&quot;短暂&quot;的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#locksupport-park-%E4%B8%8E-os-%E5%8E%9F%E8%AF%AD%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.7.1.6.</span> <span class="toc-text">LockSupport.park() 与 OS 原语的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state%EF%BC%9A%E5%90%8C%E6%AD%A5%E7%8A%B6%E6%80%81%E7%9A%84%E7%BB%9F%E4%B8%80%E6%8A%BD%E8%B1%A1"><span class="toc-number">3.7.2.</span> <span class="toc-text">state：同步状态的统一抽象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#state-%E5%9C%A8%E4%B8%8D%E5%90%8C%E5%90%8C%E6%AD%A5%E5%99%A8%E4%B8%AD%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="toc-number">3.7.2.1.</span> <span class="toc-text">state 在不同同步器中的语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reentrantreadwritelock-%E7%9A%84-state-%E4%BD%8D%E5%88%86%E5%89%B2"><span class="toc-number">3.7.2.2.</span> <span class="toc-text">ReentrantReadWriteLock 的 state 位分割</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#state-%E5%9C%A8%E4%BA%92%E6%96%A5%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%B7%AE%E5%BC%82"><span class="toc-number">3.7.3.</span> <span class="toc-text">state 在互斥模式与共享模式的本质差异</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E6%A8%A1%E5%BC%8F-vs-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F%E7%9A%84-state-%E8%AF%AD%E4%B9%89"><span class="toc-number">3.7.3.1.</span> <span class="toc-text">互斥模式 vs 共享模式的 state 语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reentrantlock-%E4%B8%8E-semaphore-%E7%9A%84-state-%E4%BD%BF%E7%94%A8%E5%AF%B9%E6%AF%94"><span class="toc-number">3.7.3.2.</span> <span class="toc-text">ReentrantLock 与 Semaphore 的 state 使用对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%98%AF%E7%81%B5%E6%B4%BB%E7%9A%84"><span class="toc-number">3.7.3.3.</span> <span class="toc-text">为什么这种设计是灵活的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aqs-%E4%B8%8D%E5%8F%AA%E6%98%AF-reentrantlock-%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">3.7.3.4.</span> <span class="toc-text">AQS 不只是 ReentrantLock 的实现方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryacquireshared-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%8E%E5%94%A4%E9%86%92%E4%BC%A0%E6%92%AD"><span class="toc-number">3.7.3.5.</span> <span class="toc-text">tryAcquireShared 返回值与唤醒传播</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E7%9A%84%E4%B8%A4%E7%A7%8D%E4%BD%BF%E7%94%A8%E6%80%9D%E8%B7%AF%EF%BC%9A%E7%9B%B4%E6%8E%A5%E7%BB%A7%E6%89%BF-vs-%E5%8C%85%E8%A3%85%E7%BB%84%E5%90%88"><span class="toc-number">3.7.4.</span> <span class="toc-text">AQS 的两种使用思路：直接继承 vs 包装组合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%B8%80%EF%BC%9A%E7%9B%B4%E6%8E%A5%E7%BB%A7%E6%89%BF-aqs-%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="toc-number">3.7.4.1.</span> <span class="toc-text">思路一：直接继承 AQS 实现自定义同步器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF%E4%BA%8C%EF%BC%9A%E5%8C%85%E8%A3%85%E7%8E%B0%E6%9C%89-aqs-%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="toc-number">3.7.4.2.</span> <span class="toc-text">思路二：包装现有 AQS 同步器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%80%9D%E8%B7%AF%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.7.4.3.</span> <span class="toc-text">两种思路的对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8F%90%E5%88%B0%E7%9A%84%E5%90%8C%E6%AD%A5%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90"><span class="toc-number">3.7.4.4.</span> <span class="toc-text">文章中提到的同步器的使用思路分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%80%9D%E8%B7%AF%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">3.7.4.5.</span> <span class="toc-text">两种思路的优缺点深度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E7%BB%A7%E6%89%BF-aqs-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.7.4.5.1.</span> <span class="toc-text">直接继承 AQS 的优缺点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%8E%B0%E6%9C%89%E5%90%8C%E6%AD%A5%E5%99%A8%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.7.4.5.2.</span> <span class="toc-text">包装现有同步器的优缺点</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.7.4.6.</span> <span class="toc-text">最佳实践建议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clh-%E9%98%9F%E5%88%97%EF%BC%9A%E7%AD%89%E5%BE%85%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F"><span class="toc-number">3.7.5.</span> <span class="toc-text">CLH 队列：等待线程的组织方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#node-%E8%8A%82%E7%82%B9%E7%BB%93%E6%9E%84"><span class="toc-number">3.7.5.1.</span> <span class="toc-text">Node 节点结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#waitstatus-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.7.5.2.</span> <span class="toc-text">waitStatus 状态转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84"><span class="toc-number">3.7.5.3.</span> <span class="toc-text">同步队列结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E6%98%AF%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8-%E8%80%8C%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97%E6%98%AF%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%9F"><span class="toc-number">3.7.5.4.</span> <span class="toc-text">为什么同步队列是双向链表，而条件队列是单向链表？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E9%94%81%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B"><span class="toc-number">3.7.6.</span> <span class="toc-text">获取锁的核心流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#acquirequeued%EF%BC%9A%E5%9C%A8%E9%98%9F%E5%88%97%E4%B8%AD%E8%87%AA%E6%97%8B%E7%AD%89%E5%BE%85"><span class="toc-number">3.7.6.1.</span> <span class="toc-text">acquireQueued：在队列中自旋等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shouldparkafterfailedacquire%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E9%98%BB%E5%A1%9E"><span class="toc-number">3.7.6.2.</span> <span class="toc-text">shouldParkAfterFailedAcquire：判断是否需要阻塞</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B"><span class="toc-number">3.7.7.</span> <span class="toc-text">释放锁的核心流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97%EF%BC%9Acondition-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.7.8.</span> <span class="toc-text">条件队列：Condition 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E4%B8%8E%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.7.8.1.</span> <span class="toc-text">同步队列与条件队列的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#await-%E5%92%8C-signal-%E7%9A%84%E5%AE%8C%E6%95%B4%E6%B5%81%E7%A8%8B"><span class="toc-number">3.7.8.2.</span> <span class="toc-text">await 和 signal 的完整流程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">3.7.9.</span> <span class="toc-text">公平锁与非公平锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E8%AF%A6%E7%BB%86%E6%9C%BA%E5%88%B6%EF%BC%9A%E5%94%A4%E9%86%92-head-%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.7.9.1.</span> <span class="toc-text">非公平锁的详细机制：唤醒 head 的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.7.10.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aqs-%E6%BA%90%E7%A0%81%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">3.8.</span> <span class="toc-text">AQS 源码深度分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E7%9A%84%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">3.8.1.</span> <span class="toc-text">AQS 的五层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E9%98%9F%E5%88%97%E4%B8%8E%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97"><span class="toc-number">3.8.2.</span> <span class="toc-text">同步队列与条件队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-%E8%8A%82%E7%82%B9%E7%9A%84%E8%AF%A6%E7%BB%86%E7%BB%93%E6%9E%84"><span class="toc-number">3.8.3.</span> <span class="toc-text">Node 节点的详细结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.8.4.</span> <span class="toc-text">独占模式源码详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#addwaiter%EF%BC%9A%E5%85%A5%E9%98%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">3.8.4.1.</span> <span class="toc-text">addWaiter：入队操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#enq%EF%BC%9A%E5%AE%8C%E6%95%B4%E5%85%A5%E9%98%9F"><span class="toc-number">3.8.4.2.</span> <span class="toc-text">enq：完整入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#acquirequeued%EF%BC%9A%E5%9C%A8%E9%98%9F%E5%88%97%E4%B8%AD%E8%87%AA%E6%97%8B%E7%AD%89%E5%BE%85"><span class="toc-number">3.8.4.3.</span> <span class="toc-text">acquireQueued：在队列中自旋等待</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shouldparkafterfailedacquire%EF%BC%9A%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E9%9C%80%E8%A6%81%E9%98%BB%E5%A1%9E"><span class="toc-number">3.8.4.4.</span> <span class="toc-text">shouldParkAfterFailedAcquire：判断是否需要阻塞</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cancelacquire%EF%BC%9A%E5%8F%96%E6%B6%88%E8%8E%B7%E5%8F%96%E9%94%81"><span class="toc-number">3.8.4.5.</span> <span class="toc-text">cancelAcquire：取消获取锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%B5%81%E7%A8%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">3.8.5.</span> <span class="toc-text">公平锁与非公平锁流程对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E4%B8%8E%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.8.6.</span> <span class="toc-text">独占与共享模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#condition-%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.8.7.</span> <span class="toc-text">Condition 条件队列详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#conditionobject-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.8.7.1.</span> <span class="toc-text">ConditionObject 的结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E7%AD%89%E5%BE%85%E7%9A%84%E4%B8%89%E7%A7%8D%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.8.7.2.</span> <span class="toc-text">条件等待的三种形式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#countdownlatch-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.8.8.</span> <span class="toc-text">CountDownLatch 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#await-%E7%9A%84%E5%85%A5%E9%98%9F%E8%BF%87%E7%A8%8B"><span class="toc-number">3.8.8.1.</span> <span class="toc-text">await 的入队过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#countdown-%E7%9A%84%E9%87%8A%E6%94%BE%E8%BF%87%E7%A8%8B"><span class="toc-number">3.8.8.2.</span> <span class="toc-text">countDown 的释放过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cyclicbarrier-%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.8.9.</span> <span class="toc-text">CyclicBarrier 详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#cyclicbarrier-%E5%92%8C-countdownlatch-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.8.9.1.</span> <span class="toc-text">CyclicBarrier 和 CountDownLatch 的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cyclicbarrier-%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.8.9.2.</span> <span class="toc-text">CyclicBarrier 状态转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#semaphore-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">3.8.10.</span> <span class="toc-text">Semaphore 源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.8.10.1.</span> <span class="toc-text">官方示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">3.8.10.2.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90%EF%BC%9A%E5%9B%9B%E5%A4%A7-acquire-%E6%96%B9%E6%B3%95"><span class="toc-number">3.8.10.3.</span> <span class="toc-text">获取资源：四大 acquire 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryacquireshared-%E7%9A%84%E5%85%AC%E5%B9%B3%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.8.10.4.</span> <span class="toc-text">tryAcquireShared 的公平与非公平实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">3.8.10.5.</span> <span class="toc-text">释放资源</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#locksupport%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD"><span class="toc-number">3.9.</span> <span class="toc-text">LockSupport：线程阻塞的基础设施</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E4%B8%8E-locksupport-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.9.1.</span> <span class="toc-text">AQS 与 LockSupport 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#api-%E6%A6%82%E8%A7%88%EF%BC%9Apark-unpark-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">3.9.2.</span> <span class="toc-text">API 概览：park&#x2F;unpark 的设计哲学</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#park-%E4%B8%8E-sleep-wait-%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.9.3.</span> <span class="toc-text">park 与 sleep&#x2F;wait 的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#api-%E7%AD%BE%E5%90%8D%E5%AF%B9%E6%AF%94"><span class="toc-number">3.9.3.1.</span> <span class="toc-text">API 签名对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90"><span class="toc-number">3.9.3.2.</span> <span class="toc-text">核心差异分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%EF%BC%9Apark-%E4%B8%8E-sleep-%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">3.9.4.</span> <span class="toc-text">中断处理：park 与 sleep 的差异</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-thread-interrupted-%EF%BC%9A%E6%B8%85%E9%99%A4%E8%BF%98%E6%98%AF%E6%81%A2%E5%A4%8D%EF%BC%9F"><span class="toc-number">3.9.4.1.</span> <span class="toc-text">深入理解 Thread.interrupted()：清除还是恢复？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#permit-%E6%9C%BA%E5%88%B6%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.9.4.2.</span> <span class="toc-text">permit 机制解决的问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%EF%BC%9A%E4%BB%8E-java-%E5%88%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">3.9.5.</span> <span class="toc-text">底层实现：从 Java 到操作系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">3.9.6.</span> <span class="toc-text">使用场景的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9Apark-%E4%B8%8E-sleep-%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%B7%AE%E5%BC%82"><span class="toc-number">3.9.7.</span> <span class="toc-text">小结：park 与 sleep 的本质差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-java-%E7%BA%BF%E7%A8%8B-api-%E5%88%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%87%AA%E6%84%BF-vs-%E5%BC%BA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%9F%E4%B8%80%E8%A7%86%E8%A7%92"><span class="toc-number">3.9.8.</span> <span class="toc-text">从 Java 线程 API 到操作系统：自愿 vs 强制操作的统一视角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#permit-%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%BA%8C%E5%85%83%E8%AE%B8%E5%8F%AF%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.9.9.</span> <span class="toc-text">permit 机制：二元许可的设计与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-dijkstra-%E7%9A%84-p-v-%E4%BF%A1%E5%8F%B7%E9%87%8F%E8%AF%B4%E8%B5%B7"><span class="toc-number">3.9.9.1.</span> <span class="toc-text">从 Dijkstra 的 P&#x2F;V 信号量说起</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#permit-%E4%B8%8E-aqs-state-%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">3.9.9.2.</span> <span class="toc-text">permit 与 AQS state 的本质区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocker-%E5%8F%82%E6%95%B0%EF%BC%9A%E8%AF%8A%E6%96%AD%E4%B8%8E%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7"><span class="toc-number">3.9.10.</span> <span class="toc-text">blocker 参数：诊断与可观测性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#blocker-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.9.10.1.</span> <span class="toc-text">blocker 的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#blocker-%E7%9A%84%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7"><span class="toc-number">3.9.10.2.</span> <span class="toc-text">blocker 的关键特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-jstack-%E4%B8%AD%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">3.9.10.3.</span> <span class="toc-text">在 jstack 中的体现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#blocker-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.9.10.4.</span> <span class="toc-text">blocker 的生命周期</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%84%B1%E7%A6%BB-aqs-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-park-unpark-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%8D%8F%E8%B0%83"><span class="toc-number">3.9.11.</span> <span class="toc-text">脱离 AQS 直接使用 park&#x2F;unpark 实现线程协调</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%EF%BC%9A%E5%9F%BA%E4%BA%8E-cas-park-unpark-%E7%9A%84%E7%AE%80%E6%98%93%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">3.9.11.1.</span> <span class="toc-text">从零构建：基于 CAS + park&#x2F;unpark 的简易互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#locksupport-%E5%AE%9E%E6%88%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.9.11.2.</span> <span class="toc-text">LockSupport 实战示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hotspot-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9Aparker-%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-permit-%E8%AF%AD%E4%B9%89"><span class="toc-number">3.9.11.3.</span> <span class="toc-text">HotSpot 源码解析：Parker 类如何实现 permit 语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92-spurious-wakeup-%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E6%A3%80%E6%9F%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.9.11.4.</span> <span class="toc-text">虚假唤醒（Spurious Wakeup）：为什么必须在循环中检查条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E7%AD%89%E5%BE%85%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9Areentrantlock-trylock-timeout-unit-%E5%8E%9F%E7%90%86"><span class="toc-number">3.9.11.5.</span> <span class="toc-text">超时等待的实现：ReentrantLock.tryLock(timeout, unit) 原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%8C%BA%E5%88%86%EF%BC%9Ablocker-%E4%B8%8E%E6%9C%AC%E6%96%87%E5%85%B6%E4%BB%96-%E8%AE%B0%E5%BD%95%E5%AF%B9%E8%B1%A1-%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">3.9.12.</span> <span class="toc-text">重要区分：blocker 与本文其他&quot;记录对象&quot;的本质区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocker-%E6%9D%A5%E8%87%AA%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">3.9.13.</span> <span class="toc-text">blocker 来自哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#condition-await-%E4%B8%8E-signal-%E7%9A%84%E5%AE%8C%E6%95%B4%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">3.9.14.</span> <span class="toc-text">Condition.await() 与 signal() 的完整时序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E4%B8%AD-park-unpark-%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA%E4%B8%8E%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="toc-number">3.9.15.</span> <span class="toc-text">AQS 中 park&#x2F;unpark 的调用时机与状态变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-this-%E4%BD%9C%E4%B8%BA-blocker-%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.9.16.</span> <span class="toc-text">选择 this 作为 blocker 的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E4%B8%8E-park-%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">3.9.17.</span> <span class="toc-text">synchronized 与 park 底层机制的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocker-%E5%9C%A8%E9%94%81%E7%AB%9E%E4%BA%89%E4%B8%AD%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">3.9.18.</span> <span class="toc-text">blocker 在锁竞争中的切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocker-%E4%B8%8E-monitor-%E7%9A%84%E5%AF%B9%E4%BD%8D%E5%85%B3%E7%B3%BB"><span class="toc-number">3.9.19.</span> <span class="toc-text">blocker 与 Monitor 的对位关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%EF%BC%9A%E9%80%9A%E8%BF%87-jstack-%E8%A7%82%E5%AF%9F-blocker"><span class="toc-number">3.9.20.</span> <span class="toc-text">实战：通过 jstack 观察 blocker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9Ablocker-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">3.9.21.</span> <span class="toc-text">小结：blocker 的设计哲学</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-aqs-%E7%9A%84%E5%90%8C%E6%AD%A5%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.10.</span> <span class="toc-text">基于 AQS 的同步器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#reentrantlock%EF%BC%9A%E5%8F%AF%E9%87%8D%E5%85%A5%E7%8B%AC%E5%8D%A0%E9%94%81"><span class="toc-number">3.10.1.</span> <span class="toc-text">ReentrantLock：可重入独占锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84"><span class="toc-number">3.10.1.1.</span> <span class="toc-text">核心结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#state-%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="toc-number">3.10.1.2.</span> <span class="toc-text">state 的语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#reentrantlock-vs-synchronized"><span class="toc-number">3.10.1.3.</span> <span class="toc-text">ReentrantLock vs synchronized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#condition-%E6%8E%A5%E5%8F%A3%EF%BC%9A%E6%98%BE%E5%BC%8F%E9%94%81%E7%9A%84%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">3.10.1.4.</span> <span class="toc-text">Condition 接口：显式锁的条件变量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#condition-%E6%8E%A5%E5%8F%A3%E6%96%B9%E6%B3%95"><span class="toc-number">3.10.1.4.1.</span> <span class="toc-text">Condition 接口方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#condition-vs-object-monitor"><span class="toc-number">3.10.1.4.2.</span> <span class="toc-text">Condition vs Object Monitor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">3.10.1.4.3.</span> <span class="toc-text">使用示例：生产者-消费者</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reentrantreadwritelock%EF%BC%9A%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">3.10.2.</span> <span class="toc-text">ReentrantReadWriteLock：读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84"><span class="toc-number">3.10.2.1.</span> <span class="toc-text">核心结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E8%8E%B7%E5%8F%96%E8%A7%84%E5%88%99"><span class="toc-number">3.10.2.2.</span> <span class="toc-text">读写锁的获取规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E9%99%8D%E7%BA%A7"><span class="toc-number">3.10.2.3.</span> <span class="toc-text">锁降级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stampedlock%EF%BC%9Ajava-8-%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">3.10.3.</span> <span class="toc-text">StampedLock：Java 8 的高性能读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%AE%BE%E8%AE%A1%E7%90%86%E5%BF%B5"><span class="toc-number">3.10.3.1.</span> <span class="toc-text">核心设计理念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.10.3.2.</span> <span class="toc-text">三种访问模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%86%99%E9%94%81-write-lock"><span class="toc-number">3.10.3.2.1.</span> <span class="toc-text">1. 写锁（Write Lock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%82%B2%E8%A7%82%E8%AF%BB%E9%94%81-pessimistic-read-lock"><span class="toc-number">3.10.3.2.2.</span> <span class="toc-text">2. 悲观读锁（Pessimistic Read Lock）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B9%90%E8%A7%82%E8%AF%BB-optimistic-read"><span class="toc-number">3.10.3.2.3.</span> <span class="toc-text">3. 乐观读（Optimistic Read）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#validate-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.10.3.3.</span> <span class="toc-text">validate() 工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">3.10.3.4.</span> <span class="toc-text">锁转换方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#stampedlock-vs-reentrantreadwritelock"><span class="toc-number">3.10.3.5.</span> <span class="toc-text">StampedLock vs ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">3.10.3.6.</span> <span class="toc-text">使用注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%85%A5%E5%AF%BC%E8%87%B4%E7%9A%84%E6%AD%BB%E9%94%81"><span class="toc-number">3.10.3.6.1.</span> <span class="toc-text">1. 不可重入导致的死锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%B8%AD%E6%96%AD%E5%AF%BC%E8%87%B4-cpu-%E9%A3%99%E5%8D%87"><span class="toc-number">3.10.3.6.2.</span> <span class="toc-text">2. 中断导致 CPU 飙升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B9%90%E8%A7%82%E8%AF%BB%E5%BF%85%E9%A1%BB%E9%AA%8C%E8%AF%81"><span class="toc-number">3.10.3.6.3.</span> <span class="toc-text">3. 乐观读必须验证</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.10.3.7.</span> <span class="toc-text">适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#semaphore%EF%BC%9A%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">3.10.4.</span> <span class="toc-text">Semaphore：信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.10.4.1.</span> <span class="toc-text">核心实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#state-%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="toc-number">3.10.4.2.</span> <span class="toc-text">state 的语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.10.4.3.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#countdownlatch%EF%BC%9A%E5%80%92%E8%AE%A1%E6%97%B6%E9%97%A8%E9%97%A9"><span class="toc-number">3.10.5.</span> <span class="toc-text">CountDownLatch：倒计时门闩</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.10.5.1.</span> <span class="toc-text">核心实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">3.10.5.2.</span> <span class="toc-text">工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.10.5.3.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cyclicbarrier%EF%BC%9A%E5%BE%AA%E7%8E%AF%E6%A0%85%E6%A0%8F"><span class="toc-number">3.10.6.</span> <span class="toc-text">CyclicBarrier：循环栅栏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%BB%93%E6%9E%84"><span class="toc-number">3.10.6.1.</span> <span class="toc-text">核心结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cyclicbarrier-vs-countdownlatch"><span class="toc-number">3.10.6.2.</span> <span class="toc-text">CyclicBarrier vs CountDownLatch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%99%A8%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">3.10.7.</span> <span class="toc-text">同步器对比总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%90%8C%E6%AD%A5%E5%99%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.10.8.</span> <span class="toc-text">自定义同步器示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E6%B4%BB%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">3.11.</span> <span class="toc-text">锁的活性问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81-deadlock"><span class="toc-number">3.11.1.</span> <span class="toc-text">死锁（Deadlock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E5%9B%9B%E4%B8%AA%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.11.1.1.</span> <span class="toc-text">死锁的四个必要条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E6%AD%BB%E9%94%81%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.11.1.2.</span> <span class="toc-text">经典死锁示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E9%A2%84%E9%98%B2%E7%AD%96%E7%95%A5"><span class="toc-number">3.11.1.3.</span> <span class="toc-text">死锁的预防策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E7%9A%84%E6%A3%80%E6%B5%8B"><span class="toc-number">3.11.1.4.</span> <span class="toc-text">死锁的检测</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E9%94%81-livelock"><span class="toc-number">3.11.2.</span> <span class="toc-text">活锁（Livelock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E9%94%81%E7%A4%BA%E4%BE%8B%EF%BC%9A%E8%BF%87%E4%BA%8E%E7%A4%BC%E8%B2%8C%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="toc-number">3.11.2.1.</span> <span class="toc-text">活锁示例：过于礼貌的线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BB%E9%94%81%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.11.2.2.</span> <span class="toc-text">活锁的解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF-starvation"><span class="toc-number">3.11.3.</span> <span class="toc-text">饥饿（Starvation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.11.3.1.</span> <span class="toc-text">饥饿示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A5%A5%E9%A5%BF%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">3.11.3.2.</span> <span class="toc-text">饥饿的解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%B4%BB%E6%80%A7%E9%97%AE%E9%A2%98%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.11.4.</span> <span class="toc-text">三种活性问题的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.11.5.</span> <span class="toc-text">小结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">java.util.concurrent.atomic 包体系</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">原子类的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">4.1.1.</span> <span class="toc-text">基本类型原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">4.1.2.</span> <span class="toc-text">引用类型原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%9F%E5%AD%90%E7%B1%BB"><span class="toc-number">4.1.3.</span> <span class="toc-text">数组原子类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E6%AE%B5%E6%9B%B4%E6%96%B0%E5%99%A8"><span class="toc-number">4.1.4.</span> <span class="toc-text">字段更新器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aba-%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.2.</span> <span class="toc-text">ABA 问题与解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-aba-%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.1.</span> <span class="toc-text">什么是 ABA 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aba-%E9%97%AE%E9%A2%98%E7%9A%84%E5%AE%9E%E9%99%85%E5%BD%B1%E5%93%8D"><span class="toc-number">4.2.2.</span> <span class="toc-text">ABA 问题的实际影响</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomicstampedreference%EF%BC%9A%E7%89%88%E6%9C%AC%E5%8F%B7%E6%96%B9%E6%A1%88"><span class="toc-number">4.2.3.</span> <span class="toc-text">AtomicStampedReference：版本号方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#atomicmarkablereference%EF%BC%9A%E6%A0%87%E8%AE%B0%E4%BD%8D%E6%96%B9%E6%A1%88"><span class="toc-number">4.2.4.</span> <span class="toc-text">AtomicMarkableReference：标记位方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%A1%88%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">4.2.5.</span> <span class="toc-text">两种方案的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#longadder%EF%BC%9A%E9%AB%98%E5%B9%B6%E5%8F%91%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="toc-number">4.3.</span> <span class="toc-text">LongAdder：高并发累加器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#atomiclong-%E7%9A%84%E6%80%A7%E8%83%BD%E7%93%B6%E9%A2%88"><span class="toc-number">4.3.1.</span> <span class="toc-text">AtomicLong 的性能瓶颈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#longadder-%E7%9A%84%E5%88%86%E6%AE%B5%E7%B4%AF%E5%8A%A0%E7%AD%96%E7%95%A5"><span class="toc-number">4.3.2.</span> <span class="toc-text">LongAdder 的分段累加策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#longadder-%E7%9A%84%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">4.3.3.</span> <span class="toc-text">LongAdder 的内部结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#longadder-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.3.4.</span> <span class="toc-text">LongAdder 的工作流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">4.3.5.</span> <span class="toc-text">性能对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#longadder-vs-atomiclong%EF%BC%9A%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9"><span class="toc-number">4.3.6.</span> <span class="toc-text">LongAdder vs AtomicLong：如何选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#longaccumulator%EF%BC%9A%E9%80%9A%E7%94%A8%E7%B4%AF%E5%8A%A0%E5%99%A8"><span class="toc-number">4.3.7.</span> <span class="toc-text">LongAccumulator：通用累加器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-9-%E7%9A%84-varhandle"><span class="toc-number">4.4.</span> <span class="toc-text">Java 9+ 的 VarHandle</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#varhandle-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">4.4.1.</span> <span class="toc-text">VarHandle 的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#varhandle-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.4.2.</span> <span class="toc-text">VarHandle 的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#varhandle-%E7%9A%84%E5%86%85%E5%AD%98%E8%AE%BF%E9%97%AE%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.4.3.</span> <span class="toc-text">VarHandle 的内存访问模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">并发数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%80%BB%E8%A7%88"><span class="toc-number">5.1.</span> <span class="toc-text">并发数据结构总览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-aqs-%E7%9A%84%E9%98%BB%E5%A1%9E%E5%AE%B9%E5%99%A8"><span class="toc-number">5.2.</span> <span class="toc-text">基于 AQS 的阻塞容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#blockingqueue-%E6%8E%A5%E5%8F%A3%E4%BD%93%E7%B3%BB"><span class="toc-number">5.2.1.</span> <span class="toc-text">BlockingQueue 接口体系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#arrayblockingqueue-vs-linkedblockingqueue"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">ArrayBlockingQueue vs LinkedBlockingQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronousqueue%EF%BC%9A%E9%9B%B6%E5%AE%B9%E9%87%8F%E9%98%9F%E5%88%97"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">SynchronousQueue：零容量队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delayqueue%EF%BC%9A%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">DelayQueue：延迟队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blockingdeque-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.2.2.</span> <span class="toc-text">BlockingDeque 接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-cas-%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%AE%B9%E5%99%A8"><span class="toc-number">5.3.</span> <span class="toc-text">基于 CAS 的非阻塞容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrenthashmap"><span class="toc-number">5.3.1.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrentskiplistmap-concurrentskiplistset"><span class="toc-number">5.3.2.</span> <span class="toc-text">ConcurrentSkipListMap &#x2F; ConcurrentSkipListSet</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#concurrenthashmap-%E7%9A%84-size-%E4%B8%8E-mappingcount"><span class="toc-number">5.3.2.1.</span> <span class="toc-text">ConcurrentHashMap 的 size() 与 mappingCount()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrentskiplistmap-set"><span class="toc-number">5.3.3.</span> <span class="toc-text">ConcurrentSkipListMap&#x2F;Set</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%B3%E8%A1%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">跳表结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrentlinkedqueue-concurrentlinkeddeque"><span class="toc-number">5.3.4.</span> <span class="toc-text">ConcurrentLinkedQueue &#x2F; ConcurrentLinkedDeque</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E-copy-on-write-%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">5.4.</span> <span class="toc-text">基于 Copy-On-Write 的容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#copyonwritearraylist"><span class="toc-number">5.4.1.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#copyonwritearrayset"><span class="toc-number">5.4.2.</span> <span class="toc-text">CopyOnWriteArraySet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%99%A8"><span class="toc-number">5.5.</span> <span class="toc-text">同步器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#phaser%EF%BC%9A%E5%A4%9A%E9%98%B6%E6%AE%B5%E5%B1%8F%E9%9A%9C"><span class="toc-number">5.5.1.</span> <span class="toc-text">Phaser：多阶段屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exchanger%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%95%B0%E6%8D%AE%E4%BA%A4%E6%8D%A2"><span class="toc-number">5.5.2.</span> <span class="toc-text">Exchanger：线程间数据交换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork-join-%E6%A1%86%E6%9E%B6"><span class="toc-number">5.6.</span> <span class="toc-text">Fork&#x2F;Join 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95"><span class="toc-number">5.6.1.</span> <span class="toc-text">工作窃取算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#forkjoinpool"><span class="toc-number">5.6.2.</span> <span class="toc-text">ForkJoinPool</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#recursiveaction-vs-recursivetask"><span class="toc-number">5.6.3.</span> <span class="toc-text">RecursiveAction vs RecursiveTask</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#countedcompleter"><span class="toc-number">5.6.4.</span> <span class="toc-text">CountedCompleter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%B7%A5%E5%85%B7"><span class="toc-number">5.7.</span> <span class="toc-text">异步编程工具</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#completablefuture"><span class="toc-number">5.7.1.</span> <span class="toc-text">CompletableFuture</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">5.7.1.1.</span> <span class="toc-text">创建方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C"><span class="toc-number">5.7.1.2.</span> <span class="toc-text">转换操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E8%B4%B9%E6%93%8D%E4%BD%9C"><span class="toc-number">5.7.1.3.</span> <span class="toc-text">消费操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%93%8D%E4%BD%9C"><span class="toc-number">5.7.1.4.</span> <span class="toc-text">组合操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">5.7.1.5.</span> <span class="toc-text">异常处理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#futuretask"><span class="toc-number">5.7.2.</span> <span class="toc-text">FutureTask</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile-%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D"><span class="toc-number">5.8.</span> <span class="toc-text">volatile 的可见性影响</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E5%88%86%E7%B1%BB%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-number">5.9.</span> <span class="toc-text">锁的分类与选择</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#java-%E4%B8%BB%E6%B5%81%E9%94%81%E6%A6%82%E8%A7%88"><span class="toc-number">5.9.1.</span> <span class="toc-text">Java 主流锁概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81"><span class="toc-number">5.9.2.</span> <span class="toc-text">乐观锁与悲观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E9%9D%9E%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">5.9.3.</span> <span class="toc-text">自旋锁与非自旋锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">5.9.4.</span> <span class="toc-text">锁升级的思路</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96%E8%A7%82%E5%AF%9F"><span class="toc-number">5.10.</span> <span class="toc-text">线程状态的可视化观察</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E5%AF%BC%E8%87%B4%E7%9A%84-blocked-%E7%8A%B6%E6%80%81"><span class="toc-number">5.10.1.</span> <span class="toc-text">synchronized 导致的 BLOCKED 状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#locksupport-park-%E5%AF%BC%E8%87%B4%E7%9A%84-waiting-%E7%8A%B6%E6%80%81"><span class="toc-number">5.10.2.</span> <span class="toc-text">LockSupport.park() 导致的 WAITING 状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%BC%94%E5%8C%96%EF%BC%9A%E4%BB%8E%E7%BB%BF%E8%89%B2%E7%BA%BF%E7%A8%8B%E5%88%B0%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B"><span class="toc-number">5.11.</span> <span class="toc-text">Java 线程模型的演化：从绿色线程到虚拟线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94"><span class="toc-number">5.11.1.</span> <span class="toc-text">三种线程模型对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E5%8C%96%E5%8E%86%E7%A8%8B%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.11.2.</span> <span class="toc-text">演化历程详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%9A%E7%BB%BF%E8%89%B2%E7%BA%BF%E7%A8%8B-jdk-1-0-jdk-1-2"><span class="toc-number">5.11.2.1.</span> <span class="toc-text">第一阶段：绿色线程（JDK 1.0 ~ JDK 1.2）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%EF%BC%9A%E5%8E%9F%E7%94%9F%E7%BA%BF%E7%A8%8B-jdk-1-3-jdk-20"><span class="toc-number">5.11.2.2.</span> <span class="toc-text">第二阶段：原生线程（JDK 1.3 ~ JDK 20）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E9%98%B6%E6%AE%B5%EF%BC%9A%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B-jdk-21"><span class="toc-number">5.11.2.3.</span> <span class="toc-text">第三阶段：虚拟线程（JDK 21+）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%9E%8B%E7%9A%84%E7%BB%BC%E5%90%88%E5%AF%B9%E6%AF%94"><span class="toc-number">5.11.3.</span> <span class="toc-text">三种模型的综合对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm-%E7%9A%84%E8%AE%BE%E8%AE%A1%E8%80%83%E9%87%8F"><span class="toc-number">5.11.4.</span> <span class="toc-text">JVM 的设计考量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">5.11.5.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E5%9C%A8%E5%BD%93%E4%BB%8A%E6%97%B6%E4%BB%A3%E6%9B%B4%E5%85%B7%E4%BC%98%E5%8A%BF"><span class="toc-number">5.11.6.</span> <span class="toc-text">为什么虚拟线程在当今时代更具优势</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD%E7%89%B9%E5%BE%81%E7%9A%84%E6%A0%B9%E6%9C%AC%E8%BD%AC%E5%8F%98"><span class="toc-number">5.11.6.1.</span> <span class="toc-text">工作负载特征的根本转变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E8%A7%84%E6%A8%A1%E7%9A%84%E6%95%B0%E9%87%8F%E7%BA%A7%E8%B7%83%E5%8D%87"><span class="toc-number">5.11.6.2.</span> <span class="toc-text">并发规模的数量级跃升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%9D%83%E8%A1%A1%EF%BC%9A%E9%98%BB%E5%A1%9E-vs-%E5%BC%82%E6%AD%A5"><span class="toc-number">5.11.6.3.</span> <span class="toc-text">编程模型的权衡：阻塞 vs 异步</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%90%8C%E5%9C%BA%E6%99%AF%E4%B8%8B%E7%9A%84%E9%80%82%E7%94%A8%E6%80%A7%E5%88%86%E6%9E%90"><span class="toc-number">5.11.6.4.</span> <span class="toc-text">不同场景下的适用性分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%B4%9E%E5%AF%9F"><span class="toc-number">5.11.6.5.</span> <span class="toc-text">关键洞察</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i-o-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%E4%B8%8E%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.11.6.6.</span> <span class="toc-text">I&#x2F;O 多路复用与虚拟线程的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E5%B9%B6%E5%8F%91%E6%96%B9%E6%A1%88%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">5.11.7.</span> <span class="toc-text">虚拟线程与其他语言并发方案的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E8%BE%A8%E6%9E%90"><span class="toc-number">5.11.7.1.</span> <span class="toc-text">核心概念辨析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#go-goroutine%EF%BC%9Am-n-%E8%B0%83%E5%BA%A6%E7%9A%84%E5%85%88%E9%A9%B1"><span class="toc-number">5.11.7.2.</span> <span class="toc-text">Go Goroutine：M:N 调度的先驱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ruby-fiber%EF%BC%9A%E6%98%BE%E5%BC%8F%E5%8D%8F%E4%BD%9C%E7%9A%84%E5%8D%8A%E5%8D%8F%E7%A8%8B"><span class="toc-number">5.11.7.3.</span> <span class="toc-text">Ruby Fiber：显式协作的半协程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#javascript-async-await%EF%BC%9A%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">5.11.7.4.</span> <span class="toc-text">JavaScript async&#x2F;await：单线程事件循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E5%8F%96%E8%88%8D%E7%9A%84%E6%B7%B1%E5%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">5.11.7.5.</span> <span class="toc-text">设计取舍的深层分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%84%E6%96%B9%E6%A1%88%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E6%80%BB%E7%BB%93"><span class="toc-number">5.11.7.6.</span> <span class="toc-text">各方案适用场景总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%94%81%E7%9A%84%E4%BA%A4%E4%BA%92-jdk-21"><span class="toc-number">5.12.</span> <span class="toc-text">虚拟线程与锁的交互（JDK 21+）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pinning-%E9%97%AE%E9%A2%98"><span class="toc-number">5.12.1.</span> <span class="toc-text">Pinning 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-vs-reentrantlock-%E5%9C%A8%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0"><span class="toc-number">5.12.2.</span> <span class="toc-text">synchronized vs ReentrantLock 在虚拟线程中的表现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.12.3.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%8A%E6%96%AD-pinning-%E9%97%AE%E9%A2%98"><span class="toc-number">5.12.4.</span> <span class="toc-text">诊断 Pinning 问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E5%AF%B9%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%92%8C%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">5.13.</span> <span class="toc-text">虚拟线程对中间件和框架的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#servlet-%E5%AE%B9%E5%99%A8%E7%9A%84%E5%8F%98%E9%9D%A9"><span class="toc-number">5.13.1.</span> <span class="toc-text">Servlet 容器的变革</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%B1%80%E9%99%90"><span class="toc-number">5.13.1.1.</span> <span class="toc-text">传统线程模型的局限</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.13.1.2.</span> <span class="toc-text">虚拟线程模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">5.13.1.3.</span> <span class="toc-text">性能对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spring-framework-%E7%9A%84%E9%80%82%E9%85%8D"><span class="toc-number">5.13.2.</span> <span class="toc-text">Spring Framework 的适配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-mvc"><span class="toc-number">5.13.2.1.</span> <span class="toc-text">Spring MVC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#spring-webflux-%E7%9A%84%E5%AE%9A%E4%BD%8D%E5%8F%98%E5%8C%96"><span class="toc-number">5.13.2.2.</span> <span class="toc-text">Spring WebFlux 的定位变化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BF%E9%97%AE%E5%B1%82%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">5.13.3.</span> <span class="toc-text">数据库访问层的影响</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jdbc-%E9%A9%B1%E5%8A%A8"><span class="toc-number">5.13.3.1.</span> <span class="toc-text">JDBC 驱动</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%B1%A0%E9%87%8D%E6%96%B0%E8%AF%84%E4%BC%B0"><span class="toc-number">5.13.3.2.</span> <span class="toc-text">连接池重新评估</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#http-%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%9A%84%E9%80%82%E9%85%8D"><span class="toc-number">5.13.4.</span> <span class="toc-text">HTTP 客户端的适配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-httpclient"><span class="toc-number">5.13.4.1.</span> <span class="toc-text">Java HttpClient</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E6%96%B9%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.13.4.2.</span> <span class="toc-text">第三方客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">5.13.5.</span> <span class="toc-text">消息中间件客户端</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#kafka-client"><span class="toc-number">5.13.5.1.</span> <span class="toc-text">Kafka Client</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#rocketmq-rabbitmq"><span class="toc-number">5.13.5.2.</span> <span class="toc-text">RocketMQ &#x2F; RabbitMQ</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#threadlocal-%E7%9A%84%E9%87%8D%E6%96%B0%E5%AE%A1%E8%A7%86"><span class="toc-number">5.13.6.</span> <span class="toc-text">ThreadLocal 的重新审视</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%81%E7%A7%BB%E7%AD%96%E7%95%A5%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">5.13.7.</span> <span class="toc-text">迁移策略与最佳实践</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91-structured-concurrency"><span class="toc-number">5.14.</span> <span class="toc-text">结构化并发（Structured Concurrency）</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>