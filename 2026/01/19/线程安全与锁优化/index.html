<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>线程安全与锁优化 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374），在 JDK 18 中相关代码已被移除。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要">
<meta property="og:type" content="article">
<meta property="og:title" content="线程安全与锁优化">
<meta property="og:url" content="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374），在 JDK 18 中相关代码已被移除。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg">
<meta property="article:published_time" content="2026-01-19T11:18:44.000Z">
<meta property="article:modified_time" content="2026-01-24T08:55:10.624Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "线程安全与锁优化",
  "url": "https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/",
  "image": "https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg",
  "datePublished": "2026-01-19T11:18:44.000Z",
  "dateModified": "2026-01-24T08:55:10.624Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '线程安全与锁优化',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">线程安全与锁优化</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">线程安全与锁优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-19T11:18:44.000Z" title="Created 2026-01-19 19:18:44">2026-01-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T08:55:10.624Z" title="Updated 2026-01-24 16:55:10">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">51.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>201mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><blockquote>
<p><strong>版本说明</strong>：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374），在 JDK 18 中相关代码已被移除。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。</p>
</blockquote>
<h1>线程安全</h1>
<h2 id="什么是线程安全">什么是线程安全</h2>
<p>“当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。”</p>
<p>相对的线程安全，可以分成五个等级：</p>
<h2 id="线程安全的分类">线程安全的分类</h2>
<h3 id="不可变-immutable">不可变（Immutable）</h3>
<p>不可变的数据，都是线程安全的。不可变的对象引用，加上所有field都是不可变的。如果有得选，尽量连方法都是final的。</p>
<h3 id="绝对线程安全-absolute-thread-safety">绝对线程安全（Absolute Thread Safety）</h3>
<p>Vector 不是绝对线程安全的。它也会出现并发修改时 Out of Range 的异常（注意，不是 ConcurrentModification 的异常）。</p>
<h3 id="相对线程安全-relative-thread-safety">相对线程安全（Relative Thread Safety）</h3>
<p>需要保证对这个对象的单独操作是线程安全的，在调用的时候不需要加上额外的保障措施。对于特定顺序的连续操作，就需要额外的同步来保证调用的正确性了。<br>
线程对立</p>
<p>Vector 是相对线程安全的。</p>
<h3 id="线程兼容-thread-compatible">线程兼容（Thread Compatible）</h3>
<p>可以通过特殊手段做到线程安全的普通类，绝大部分类都属于线程兼容的。</p>
<h3 id="线程对立-thread-hostile">线程对立（Thread Hostile）</h3>
<p>线程对立，是不管调用端是否采取了同步措施，都无法在多线程环境中使用的代码。常见的线程对立的操作还有 suspend()，resume()， System.setIn()，System.setOut()和System.runFinalizerOnExit()。</p>
<h2 id="线程安全的实现">线程安全的实现</h2>
<h3 id="互斥同步-mutual-exclusion-synchronization">互斥同步（Mutual Exclusion &amp; Synchronization)</h3>
<p>这是最常见（也是我们在考虑并发问题的时候，首先应该考虑的万能解决方案，也是《Java并发编程实践》和《Thinking in Java 》中最推荐的做法。）的保障并发正确性的手段。同步（Synchronization）是指协调多个线程的执行，保证共享数据在同一时刻只被一条（或使用信号量时多条）线程访问。互斥（Mutual Exclusion）是实现同步的一种手段，临界区（Critical Section）、互斥量（Mutex）和信号量都是实现互斥的常见方式。<strong>互斥是因，同步是果；互斥是方法，同步是目的</strong>。这两个概念源自操作系统理论（Dijkstra 1965 年提出信号量时引入），同样出现在 OS 层面。同步的终极目标是将并发的乱序转化为类似无并发时的有序。</p>
<p>在 Java 里面，最基本的互斥手段就是 synchronized 关键字。它经过编译后，会转化为 monitorenter 和 monitorexit 这两个字节码指令（bytecode instructions）。在执行这两个字节码指令之前，需要先将锁对象的引用压入操作数栈，指令会从栈顶获取这个引用来确定加锁/解锁的对象。这个引用不是一个普通对象实例，就是一个 Class 对象（对于 synchronized 静态方法）。</p>
<p>根据虚拟机规范，在执行 monitorenter 指令时，首先尝试获取对象的锁（实际上就是去用线程信息写 markword）。如果这个对象没有被锁定，或者当前线程已经拥有了那个对象的锁，那么把锁的计数器加1。相应地，在执行 monitorexit 时，会对计数器减1，当计数器为0时，锁就被释放了。从某种意义上来讲，这种设计可以在分布式场景下用 Redis 实现。如果获取锁失败了，那么就会进入阻塞状态，直到对象锁被释放为止。虚拟机规范对 monitorenter 和 monitorexit 两条指令的行为描述中，有两点是需要特别注意的。<strong>首先，synchronized同步块对同一条线程来说是可重入的，不会出现自己把自己锁死（阻塞）的情况。其次，同步块在已进入的线程执行完之前，会阻塞后面其他线程的进入</strong>对于映射到操作系统原生进程的实现，不管是阻塞还是唤醒线程，都需要操作系统的调用帮忙，也就会牵涉到用户态转变入核心态的问题（系统控制权从用户空间转入内核空间）。<strong>这种切换需要消耗很多 CPU 时间。这也是为什么它是昂贵的原因，时间是最昂贵的。对于很多简单的getter()、setter（）操作，花在状态切换上的时间，甚至会多过用户代码执行的时间。甚至可以认为，这样的状态切换需要使用很多的汇编指令代码，以至于要使用很多的 cpu 时钟周期</strong>。因此synchronized本身是一种重量级（Heavyweight）操作。JVM（注意，不是Java语言） 本身可能会对重量锁进行优化，使用自旋来避免频繁地切入核心态之中（自旋难道就不浪费CPU 时间了吗？）。</p>
<p>J.U.C包里专门提供了Reentrantlock来实现同步。它同样具有 synchronized 具有的可重入、阻塞其他求锁者的特性。但它还具有三个额外的特点，支持某些场景下的任务调度需求：</p>
<ol>
<li>等待可中断。Lock 接口有实现类可以实现试锁，超时试锁等功能，各种接口都有 interruptibly 版本。这样 synchronized中，其他求锁线程傻等的情况可以避免。</li>
<li>公平锁。公平锁指的是按照求锁顺序来分配锁（求锁也是有顺序的，fifo 天然就是公平的）。默认的锁（synchronized 和 ReentrantLock 的默认构造函数）是非公平的，随机给予锁，这样性能更好。synchronized 本身并不内置公平锁，AQS 的非公平锁通过允许插队（新来的线程可以直接尝试 CAS 获取锁，不用排队），来减少 cpu 时间片花在调度/cpu上下文切换上的开销，来获得更高的吞吐。非公平锁的吞吐会更好，而公平锁可避免线程饥饿。ReentrantLock 默认使用非公平锁。</li>
<li>绑定多个条件。在 synchronized 的时代，多个 condition 就意味着多层 synchronized。</li>
</ol>
<p>synchronized 的性能屡屡被 JVM 的实现者改进，因此还是优先要使用synchronized（《TIJ》、《Java 并发实践》和《深入理解 Java 虚拟机》到此达到了同一结论）。</p>
<h3 id="非阻塞同步-non-blocking-synchronization">非阻塞同步（Non-Blocking Synchronization)</h3>
<p>也就是我们常说的乐观策略。不需要加锁，也就不需要负担线程状态切换的代价。但代价是，如果真的发生了冲突，乐观操作需要付出的代价就是补偿（compensation）。最常见的补偿，应该就是不断重试（又要引入自旋了）。乐观锁的核心基石，实际上是 CAS（CompareAndSet或者 CompareAndSwap），这两个操作必须是原子化操作，这就要求现代的处理器提供这样的指令原语（instruction primitive）。JVM 虚拟机里，专门通过  Unsafe 包来向上层提供这种原语的语义。</p>
<p>CAS操作有一个很讨厌的 ABA 问题。虽然 ABA 问题本身在大部分情况下不会引起问题，但J.U.C还是提供了一个 AtomicStampedReference操作来避免这个问题（所以说，<strong>带版本的原子值才是最安全的</strong>）。在大多数情况下，进入互斥同步，还比用这些鸡肋功能要高效。所有自旋都满足如下规律：低度竞争自旋优于真正的 mutex 互斥锁定，高度竞争自旋会浪费 cpu-低度竞争适合线程活跃等待，高度竞争适合线程阻塞等待。</p>
<h3 id="无同步方案">无同步方案</h3>
<h4 id="可重入代码-reentrant-code">可重入代码（Reentrant Code）</h4>
<p>也叫纯代码（Pure Code）。在它执行的任意时刻中断它，转而去执行另一段代码，再切换上下文回来以后，不会发生任何错误。<strong>所有可重入的代码都是线程安全的，但并非所有线程安全的代码都是可重入的</strong>。</p>
<p>可重入代码的特征：</p>
<ul>
<li><strong>不依赖任何非常量的全局变量或静态变量</strong></li>
<li>不修改自身的代码</li>
<li>不调用不可重入的函数</li>
<li>所有数据都通过参数传递或使用局部变量（栈封闭）</li>
</ul>
<p>这类似于函数式编程里的纯函数，<strong>函数的行为完全由输入参数决定，结果可预测</strong>，不依赖也不修改外部状态。这也是为什么函数式编程在高并发下是安全的，它们天然满足栈封闁的标准。</p>
<h4 id="线程本地存储-thread-local-storage">线程本地存储（Thread Local Storage）</h4>
<p>关于 ThreadLocal 的详细内容，包括：</p>
<ul>
<li>ThreadLocal 的核心设计理念与内部机制</li>
<li>四大核心原则（操作本质、static 变量、线程生命周期、ThreadLocal 生命周期）</li>
<li>弱引用设计与 Stale Entry 自动清理机制</li>
<li>ThreadLocalMap 使用开放地址法的原因</li>
<li>内存泄漏的发生机制与最佳实践</li>
<li>InheritableThreadLocal 与 TransmittableThreadLocal 跨线程传递方案</li>
</ul>
<p>请参阅专题文章：<a href="https://magicliang.github.io/2020/04/01/ThreadLocal-%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">ThreadLocal 的设计模式</a></p>
<h1>对象头</h1>
<p>需要参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/26357186/what-is-in-java-object-header">What is in Java object header?</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_50275872/article/details/124302457">并发编程的艺术（3）：深入理解Synchronized的原理</a></li>
</ol>
<p>在 32 位虚拟机里：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">普通对象<br>|<span class="hljs-string">--------------------------------------------------------------</span>|<br>|<span class="hljs-string">                   Object Header (64 bits)                    </span>|<br>|<span class="hljs-string">------------------------------------</span>|<span class="hljs-string">-------------------------</span>|<br>|<span class="hljs-string"> Mark Word (32 bits)                </span>|<span class="hljs-string"> Klass Word (32 bits)    </span>|<br>|<span class="hljs-string">------------------------------------</span>|<span class="hljs-string">-------------------------</span>|<br>数组对象<br>|<span class="hljs-string">---------------------------------------------------------------------------------</span>|<br>|<span class="hljs-string">                                 Object Header (96 bits)                         </span>|<br>|<span class="hljs-string">--------------------------------</span>|<span class="hljs-string">-----------------------</span>|<span class="hljs-string">------------------------</span>|<br>|<span class="hljs-string"> Mark Word(32bits)              </span>|<span class="hljs-string"> Klass Word(32bits)    </span>|<span class="hljs-string"> array length(32bits)   </span>|<br>|<span class="hljs-string">--------------------------------</span>|<span class="hljs-string">-----------------------</span>|<span class="hljs-string">------------------------</span>|<br>标记字是<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> Mark Word (32 bits)                                   </span>|<span class="hljs-string"> State              </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> hashcode:25 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:0              </span>|<span class="hljs-string"> 01 </span>|<span class="hljs-string"> Normal             </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> thread:23 </span>|<span class="hljs-string"> epoch:2 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1      </span>|<span class="hljs-string"> 01 </span>|<span class="hljs-string"> Biased             </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> ptr_to_lock_record:30(lock_record指针)           </span>|<span class="hljs-string"> 00 </span>|<span class="hljs-string"> Lightweight Locked </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> ptr_to_heavyweight_monitor:30(monitor指针)       </span>|<span class="hljs-string"> 10 </span>|<span class="hljs-string"> Heavyweight Locked </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string">                                                  </span>|<span class="hljs-string"> 11 </span>|<span class="hljs-string"> Marked for GC      </span>|<br>|<span class="hljs-string">-------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>在64位虚拟机里<br>|<span class="hljs-string">--------------------------------------------------------------</span>|<br>|<span class="hljs-string">                     Object Header (128 bits)                 </span>|<br>|<span class="hljs-string">-------------------------------</span>|<span class="hljs-string">------------------------------</span>|<br>|<span class="hljs-string">          Mark Word (64 bits)  </span>|<span class="hljs-string">         Klass Word (64 bits) </span>|<br>|<span class="hljs-string">-------------------------------</span>|<span class="hljs-string">------------------------------</span>|<br>标记字是<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> Mark Word (64 bits)                                              </span>|<span class="hljs-string"> State              </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> unused:25 </span>|<span class="hljs-string"> hashcode:31 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:0 </span>|<span class="hljs-string"> 01  </span>|<span class="hljs-string"> Normal             </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> thread:54 </span>|<span class="hljs-string"> epoch:2 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1     </span>|<span class="hljs-string"> 01  </span>|<span class="hljs-string"> Biased             </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> ptr_to_lock_record:62                                      </span>|<span class="hljs-string"> 00  </span>|<span class="hljs-string"> Lightweight Locked </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string"> ptr_to_heavyweight_monitor:62                              </span>|<span class="hljs-string"> 10  </span>|<span class="hljs-string"> Heavyweight Locked </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br>|<span class="hljs-string">                                                            </span>|<span class="hljs-string"> 11  </span>|<span class="hljs-string"> Marked for GC      </span>|<br>|<span class="hljs-string">------------------------------------------------------------------</span>|<span class="hljs-string">--------------------</span>|<br></code></pre></td></tr></table></figure>
<p><img src="monitor%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="monitor的结构"></p>
<p>我们大致上认为一个对象应该分为 object header 和 object body，然后再把 header 分为 Mark Word 和 Klass Pointer。</p>
<p><strong>为什么叫 Mark Word？</strong></p>
<ul>
<li><strong>Mark</strong> = 标记/标志，因为这个字段用于存储对象的各种<strong>运行时标记信息</strong></li>
<li><strong>Word</strong> = 机器字长（32 位或 64 位），表示它占用一个机器字的空间</li>
<li>存储内容（根据锁状态动态变化）：
<ul>
<li><strong>无锁状态</strong>：对象的 hashCode、GC 分代年龄（age）、锁标志位</li>
<li><strong>偏向锁状态</strong>：偏向线程 ID、epoch、GC 分代年龄、锁标志位</li>
<li><strong>轻量级锁状态</strong>：指向栈中 Lock Record 的指针</li>
<li><strong>重量级锁状态</strong>：指向 Monitor 对象的指针</li>
<li><strong>GC 标记状态</strong>：用于垃圾回收</li>
</ul>
</li>
</ul>
<p><strong>为什么叫 Klass Word（类型字）？</strong></p>
<ul>
<li><strong>Klass</strong> 是 HotSpot 虚拟机中对 Java 类元数据的 C++ 表示（注意不是 Class，而是 Klass，这是 HotSpot 源码中的命名约定）</li>
<li><strong>Word</strong> = 机器字长（32 位或 64 位），表示它占用一个机器字的空间</li>
<li>本质上是一个<strong>指针</strong>，指向方法区中该对象所属类的元数据（Klass 对象）</li>
<li>存储内容：指向方法区中 <code>InstanceKlass</code>（普通对象）或 <code>ArrayKlass</code>（数组对象）的指针</li>
<li>作用：JVM 通过这个指针确定对象是哪个类的实例，从而找到类的方法表、字段布局等信息</li>
</ul>
<blockquote>
<p><strong>术语说明</strong>：在不同的技术文档中，你可能会看到 <strong>Klass Word</strong> 和 <strong>Klass Pointer</strong> 两种叫法，它们指的是同一个东西。<strong>Klass Word</strong> 强调它占用一个机器字的空间（与 Mark Word 对应），<strong>Klass Pointer</strong> 强调它的本质是一个指针。本文统一使用 <strong>Klass Word</strong> 以与对象头结构图保持一致。</p>
</blockquote>
<h3 id="klass-pointer-与类元数据的关系">Klass Pointer 与类元数据的关系</h3>
<p>Klass Pointer 指向的究竟是什么？当 <code>.class</code> 文件被类加载器加载进 JVM 后，字节码中的类型信息会被解析并存储在方法区（JDK 8+ 为 Metaspace）中，形成 HotSpot 内部的 C++ 数据结构——<strong>Klass</strong>。</p>
<p><strong>图：从 .class 文件到对象实例的完整链路</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;编译期&quot;
        JAVA[&quot;Java 源文件&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;MyClass.java&quot;]
        JAVAC[&quot;javac 编译器&quot;]
        CLASS[&quot;字节码文件&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;MyClass.class&lt;br/&gt;（魔数、版本、常量池、&lt;br/&gt;字段表、方法表...）&quot;]
        
        JAVA --&gt; JAVAC --&gt; CLASS
        style JAVA fill:#e8f5e9
        style CLASS fill:#fff9c4
    end
    
    subgraph &quot;运行期 - 类加载&quot;
        CL[&quot;类加载器&lt;br/&gt;ClassLoader&quot;]
        CLASS --&gt; CL
    end
    
    subgraph &quot;方法区 / Metaspace&quot;
        direction TB
        
        subgraph &quot;Klass 层次结构（C++ 对象）&quot;
            KLASS[&quot;Klass（抽象基类）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;所有类元数据的基类&quot;]
            
            IK[&quot;InstanceKlass&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;普通类的元数据&lt;br/&gt;• vtable（虚方法表）&lt;br/&gt;• itable（接口方法表）&lt;br/&gt;• 字段布局信息&lt;br/&gt;• 常量池引用&lt;br/&gt;• 方法字节码&quot;]
            
            AK[&quot;ArrayKlass&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;数组类的元数据&quot;]
            
            OAK[&quot;ObjArrayKlass&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;对象数组&lt;br/&gt;如 String[]&quot;]
            
            TAK[&quot;TypeArrayKlass&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;基本类型数组&lt;br/&gt;如 int[], byte[]&quot;]
            
            KLASS --&gt; IK
            KLASS --&gt; AK
            AK --&gt; OAK
            AK --&gt; TAK
        end
        
        MIRROR[&quot;java.lang.Class 对象&lt;br/&gt;（Mirror 对象）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Java 层面的类对象&lt;br/&gt;MyClass.class&quot;]
        
        IK &lt;--&gt;|&quot;双向引用&quot;| MIRROR
        
        style KLASS fill:#e1f5ff
        style IK fill:#c8e6c9
        style AK fill:#fff9c4
        style OAK fill:#ffecb3
        style TAK fill:#ffecb3
        style MIRROR fill:#f3e5f5
    end
    
    CL --&gt;|&quot;解析字节码&lt;br/&gt;创建 Klass&quot;| IK
    
    subgraph &quot;堆（Heap）&quot;
        direction TB
        
        subgraph &quot;普通对象实例&quot;
            OBJ1[&quot;对象实例 obj1&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Object Header:&lt;br/&gt;┌─────────────────┐&lt;br/&gt;│ Mark Word (8B)  │&lt;br/&gt;├─────────────────┤&lt;br/&gt;│ Klass Ptr (4/8B)│───────&lt;br/&gt;└─────────────────┘&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Instance Data&quot;]
        end
        
        subgraph &quot;数组对象实例&quot;
            ARR[&quot;数组实例 arr&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Object Header:&lt;br/&gt;┌─────────────────┐&lt;br/&gt;│ Mark Word (8B)  │&lt;br/&gt;├─────────────────┤&lt;br/&gt;│ Klass Ptr (4/8B)│───────&lt;br/&gt;├─────────────────┤&lt;br/&gt;│ Array Length(4B)│&lt;br/&gt;└─────────────────┘&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Array Elements&quot;]
        end
        
        style OBJ1 fill:#e1f5ff
        style ARR fill:#fff9c4
    end
    
    OBJ1 --&gt;|&quot;Klass Pointer&quot;| IK
    ARR --&gt;|&quot;Klass Pointer&quot;| OAK
    
    note1[&quot;关键理解：&lt;br/&gt;1. Klass 是 HotSpot 中类元数据的 C++ 表示&lt;br/&gt;2. InstanceKlass 对应普通 Java 类&lt;br/&gt;3. ArrayKlass 对应数组类型&lt;br/&gt;4. 每个对象的 Klass Pointer 指向其类型的 Klass&lt;br/&gt;5. java.lang.Class 是 Klass 在 Java 层的镜像&quot;]
    style note1 fill:#fff9c4</code></pre>
<p><strong>图：Klass Pointer 的指针压缩</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;64 位 JVM - 未压缩&quot;
        OH1[&quot;Object Header&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word: 8 bytes&lt;br/&gt;Klass Ptr: 8 bytes&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;总计: 16 bytes&quot;]
        style OH1 fill:#ffcdd2
    end
    
    subgraph &quot;64 位 JVM - 压缩指针（默认）&quot;
        OH2[&quot;Object Header&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word: 8 bytes&lt;br/&gt;Klass Ptr: 4 bytes&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;总计: 12 bytes&lt;br/&gt;（+ 4 bytes padding = 16）&quot;]
        style OH2 fill:#c8e6c9
    end
    
    OH1 --&gt;|&quot;-XX:+UseCompressedClassPointers&lt;br/&gt;（堆 &lt; 32GB 时默认开启）&quot;| OH2
    
    note[&quot;压缩指针原理：&lt;br/&gt;• 将 64 位指针压缩为 32 位&lt;br/&gt;• 通过左移 3 位还原（8 字节对齐）&lt;br/&gt;• 可寻址 32GB 的 Metaspace&quot;]
    style note fill:#fff9c4</code></pre>
<p><strong>核心概念澄清：</strong></p>
<table>
<thead>
<tr>
<th>概念</th>
<th>层面</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Klass</strong></td>
<td>C++ (HotSpot 内部)</td>
<td>类元数据的抽象基类，是 HotSpot 对 Java 类型系统的内部表示</td>
</tr>
<tr>
<td><strong>InstanceKlass</strong></td>
<td>C++ (HotSpot 内部)</td>
<td>普通 Java 类的元数据，包含 vtable、字段布局、方法字节码等</td>
</tr>
<tr>
<td><strong>ArrayKlass</strong></td>
<td>C++ (HotSpot 内部)</td>
<td>数组类型的元数据，分为 ObjArrayKlass 和 TypeArrayKlass</td>
</tr>
<tr>
<td><strong>java.lang.Class</strong></td>
<td>Java</td>
<td>Klass 在 Java 层的&quot;镜像&quot;对象，通过 <code>MyClass.class</code> 获取</td>
</tr>
<tr>
<td><strong>Klass Pointer</strong></td>
<td>对象头</td>
<td>每个对象实例中指向其 Klass 的指针，占 1 个机器字（可压缩）</td>
</tr>
</tbody>
</table>
<p><strong>为什么叫 Klass 而不是 Class？</strong></p>
<p>这是 HotSpot 源码的命名约定。由于 C++ 中 <code>class</code> 是保留关键字，无法用作类名，因此 HotSpot 开发者使用 <code>Klass</code> 来表示 Java 类的元数据。这个命名也体现了它与 Java 层 <code>java.lang.Class</code> 的区别——<code>Klass</code> 是 VM 内部的 C++ 对象，而 <code>Class</code> 是 Java 层的反射对象。</p>
<p><strong>为什么放在对象头？</strong></p>
<ul>
<li>这两个信息是 JVM 管理对象的<strong>核心元数据</strong>，每个对象都必须携带</li>
<li>Mark Word 支持 synchronized 锁机制和 GC</li>
<li>Klass Word 支持方法调用（虚方法表查找）和类型检查（instanceof）</li>
</ul>
<p><strong>两个 Word 的结构特性差异：</strong></p>
<p>在不同的 JVM 实现中（32 位 vs 64 位），这两个 Word 都是固定的机器字长（32 bits 或 64 bits），但它们的<strong>结构可变性</strong>完全不同：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>大小</th>
<th>结构是否可变</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Mark Word</strong></td>
<td>32/64 bits</td>
<td><strong>可变</strong></td>
<td>根据锁状态动态变化，像 C 语言的 union，同一块内存在不同状态下存储不同含义的数据</td>
</tr>
<tr>
<td><strong>Klass Word</strong></td>
<td>32/64 bits</td>
<td><strong>固定</strong></td>
<td>始终是一个指向方法区类元数据的指针，结构从不改变</td>
</tr>
</tbody>
</table>
<p>这种设计体现了不同的职责：</p>
<ul>
<li><strong>Klass Word 是静态的</strong>：对象的类型在创建后就确定了，永远不会改变，所以 Klass Word 只需要存储一个固定的指针</li>
<li><strong>Mark Word 是动态的</strong>：对象的运行时状态（锁状态、GC 年龄、hashCode 等）会随着程序执行而变化，所以 Mark Word 需要能够&quot;变形&quot;来适应不同的场景</li>
</ul>
<p><strong>锁升级时原始信息去哪了？</strong></p>
<p>Mark Word 的各种状态是<strong>互斥的</strong>，锁升级时原始信息（hashCode、age 等）会被<strong>转移保存</strong>。关于三种锁对 Mark Word 的详细处理策略，请参见下文<a href="#%E4%B8%89%E7%A7%8D%E9%94%81%E5%AF%B9-Mark-Word-%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5">偏向锁章节的&quot;三种锁对 Mark Word 的处理策略&quot;</a>。</p>
<p>这也解释了为什么轻量级锁解锁时必须用 CAS 把 Displaced Mark Word 写回——就是为了<strong>恢复</strong>原始的 Mark Word 信息。如果 CAS 失败，说明锁已膨胀，原始信息已转移到 ObjectMonitor 中。</p>
<p>Mark Word 本身在对象生命周期里面表现得像 union 一样可变，是让研究 synchronized 的人最头痛的。</p>
<p><img src="%E9%94%81%E7%9A%84%E4%B8%89%E9%87%8D%E5%AF%B9%E8%B1%A1%E9%93%BE%E6%8E%A5.png" alt="锁的三重对象链接"></p>
<p>通常我们可以看到 thread 会维护 lock record/monitor record；monitor 会维护两种 set 和 owner（aqs 原理的原型），似乎可以被看成操作系统的 mutext lock 在 jvm 里的句柄；object 本身使用一个 object header。</p>
<h2 id="mark-word-与-monitor-的关系">Mark Word 与 Monitor 的关系</h2>
<p><strong>核心要点：Mark Word 只保存 Monitor 的引用（指针），而不保存 Monitor 的具体信息。</strong></p>
<p>虽然 Mark Word 是一个多变的数据结构（根据锁状态动态变化），但在重量级锁状态下，它会保存指向 Monitor 对象的指针。而真正的锁管理信息——包括 <strong>Owner（当前持有锁的线程）</strong>、<strong>EntryList（阻塞等待锁的线程队列）</strong>、<strong>WaitSet（调用 wait() 后等待的线程集合）</strong>——都存储在 Monitor 这个独立的数据结构中。</p>
<p><strong>Monitor（ObjectMonitor）的核心字段：</strong></p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_header</code></td>
<td>markOop</td>
<td>保存对象原始的 Mark Word（用于锁释放时恢复）</td>
</tr>
<tr>
<td><code>_owner</code></td>
<td>void*</td>
<td>指向当前持有锁的线程</td>
</tr>
<tr>
<td><code>_EntryList</code></td>
<td>ObjectWaiter*</td>
<td>阻塞在 synchronized 入口处的线程链表</td>
</tr>
<tr>
<td><code>_WaitSet</code></td>
<td>ObjectWaiter*</td>
<td>调用 wait() 后进入等待状态的线程集合</td>
</tr>
<tr>
<td><code>_recursions</code></td>
<td>intptr_t</td>
<td>锁的重入次数</td>
</tr>
<tr>
<td><code>_count</code></td>
<td>volatile intptr_t</td>
<td>等待获取锁的线程数</td>
</tr>
</tbody>
</table>
<p><strong>图1：锁对象、Mark Word 与 Monitor 的引用关系</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Java 对象&quot;
        OBJ[Object]
        subgraph &quot;Object Header&quot;
            MW[Mark Word&lt;br/&gt;64 bits]
            KP[Klass Pointer]
        end
        BODY[Object Body&lt;br/&gt;实例数据]
        OBJ --&gt; MW
        OBJ --&gt; KP
        OBJ --&gt; BODY
    end
    
    subgraph &quot;Monitor 对象（ObjectMonitor）&quot;
        MON[ObjectMonitor]
        HEADER[&quot;_header&lt;br/&gt;原始 Mark Word 备份&quot;]
        OWNER[&quot;_owner&lt;br/&gt;当前持锁线程&quot;]
        ENTRY[&quot;_EntryList&lt;br/&gt;阻塞等待队列&quot;]
        WAIT[&quot;_WaitSet&lt;br/&gt;wait() 等待集合&quot;]
        REC[&quot;_recursions&lt;br/&gt;重入次数&quot;]
        MON --&gt; HEADER
        MON --&gt; OWNER
        MON --&gt; ENTRY
        MON --&gt; WAIT
        MON --&gt; REC
    end
    
    subgraph &quot;线程&quot;
        T1[Thread-1&lt;br/&gt;持有锁]
        T2[Thread-2&lt;br/&gt;阻塞等待]
        T3[Thread-3&lt;br/&gt;wait 等待]
    end
    
    MW --&gt;|&quot;重量级锁状态&lt;br/&gt;ptr_to_heavyweight_monitor&quot;| MON
    OWNER --&gt;|指向| T1
    ENTRY --&gt;|包含| T2
    WAIT --&gt;|包含| T3
    
    style MW fill:#e1f5ff
    style MON fill:#fff4e6
    style HEADER fill:#e8f5e9
    style OWNER fill:#ffcdd2
    style ENTRY fill:#fff9c4
    style WAIT fill:#e1bee7</code></pre>
<p><strong>图2：不同锁状态下 Mark Word 的内容变化</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;无锁状态 (01)&quot;
        MW1[&quot;Mark Word&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;unused:25 | hashcode:31 | unused:1 | age:4 | 0 | 01&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;直接存储 hashCode 和 GC 年龄&quot;]
        style MW1 fill:#c8e6c9
    end
    
    subgraph &quot;偏向锁状态 (01)&quot;
        MW2[&quot;Mark Word&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;thread:54 | epoch:2 | unused:1 | age:4 | 1 | 01&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;存储偏向线程 ID，无需 Monitor&quot;]
        style MW2 fill:#fff9c4
    end
    
    subgraph &quot;轻量级锁状态 (00)&quot;
        MW3[&quot;Mark Word&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;ptr_to_lock_record:62 | 00&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;指向线程栈帧中的 Lock Record&lt;br/&gt;原始 Mark Word 保存在 Lock Record 中&quot;]
        LR[&quot;Lock Record&lt;br/&gt;（线程栈帧中）&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word&lt;br/&gt;（原始 Mark Word 备份）&quot;]
        MW3 -.-&gt;|指向| LR
        style MW3 fill:#bbdefb
        style LR fill:#e3f2fd
    end
    
    subgraph &quot;重量级锁状态 (10)&quot;
        MW4[&quot;Mark Word&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;ptr_to_heavyweight_monitor:62 | 10&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;只存储 Monitor 指针！&lt;br/&gt;所有锁信息都在 Monitor 中&quot;]
        MON4[&quot;ObjectMonitor&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;_header: 原始 Mark Word&lt;br/&gt;_owner: 持锁线程&lt;br/&gt;_EntryList: 阻塞队列&lt;br/&gt;_WaitSet: 等待集合&lt;br/&gt;_recursions: 重入次数&quot;]
        MW4 -.-&gt;|指向| MON4
        style MW4 fill:#ffcdd2
        style MON4 fill:#ffebee
    end
    
    MW1 --&gt;|&quot;第一次加锁&lt;br/&gt;（无竞争）&quot;| MW2
    MW2 --&gt;|&quot;出现竞争&lt;br/&gt;撤销偏向&quot;| MW3
    MW3 --&gt;|&quot;竞争激烈&lt;br/&gt;锁膨胀&quot;| MW4</code></pre>
<p><strong>图3：重量级锁下 Monitor 的工作机制</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as Thread-1
    participant OBJ as 锁对象
    participant MW as Mark Word
    participant MON as ObjectMonitor
    participant T2 as Thread-2
    participant T3 as Thread-3
    
    Note over OBJ,MON: 初始状态：无锁
    
    T1-&gt;&gt;OBJ: synchronized(obj)
    OBJ-&gt;&gt;MW: 检查锁状态
    MW-&gt;&gt;MON: 锁膨胀，创建 Monitor
    Note over MW: Mark Word 变为&lt;br/&gt;ptr_to_monitor | 10
    MON-&gt;&gt;MON: _owner = Thread-1
    Note over T1,MON: Thread-1 成功获取锁
    
    T2-&gt;&gt;OBJ: synchronized(obj)
    OBJ-&gt;&gt;MW: 检查锁状态
    MW-&gt;&gt;MON: 获取 Monitor 引用
    MON-&gt;&gt;MON: 检查 _owner != null
    MON-&gt;&gt;MON: Thread-2 加入 _EntryList
    Note over T2: Thread-2 阻塞等待
    
    T1-&gt;&gt;MON: obj.wait()
    MON-&gt;&gt;MON: Thread-1 移入 _WaitSet
    MON-&gt;&gt;MON: _owner = null
    MON-&gt;&gt;MON: 从 _EntryList 唤醒 Thread-2
    MON-&gt;&gt;MON: _owner = Thread-2
    Note over T2,MON: Thread-2 获取锁
    
    T3-&gt;&gt;MON: obj.notify()
    MON-&gt;&gt;MON: 从 _WaitSet 移出 Thread-1
    MON-&gt;&gt;MON: Thread-1 加入 _EntryList
    Note over T1: Thread-1 等待重新竞争锁</code></pre>
<p><strong>图4：锁状态转换与数据存储位置</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;锁状态&quot;
        UNLOCK[无锁&lt;br/&gt;01]
        BIASED[偏向锁&lt;br/&gt;01]
        LIGHT[轻量级锁&lt;br/&gt;00]
        HEAVY[重量级锁&lt;br/&gt;10]
    end
    
    subgraph &quot;原始信息存储位置&quot;
        IN_MW[&quot;在 Mark Word 中&quot;]
        IN_LR[&quot;在 Lock Record 中&lt;br/&gt;（线程栈帧）&quot;]
        IN_MON[&quot;在 Monitor 的&lt;br/&gt;_header 字段中&quot;]
    end
    
    subgraph &quot;锁管理信息&quot;
        NO_LOCK[&quot;无需管理&quot;]
        THREAD_ID[&quot;线程 ID 在 Mark Word&quot;]
        LR_PTR[&quot;Lock Record 指针在 Mark Word&quot;]
        MON_ALL[&quot;Owner/EntryList/WaitSet&lt;br/&gt;全部在 Monitor 中&quot;]
    end
    
    UNLOCK --&gt;|hashCode/age| IN_MW
    UNLOCK --&gt;|锁信息| NO_LOCK
    
    BIASED --&gt;|hashCode/age| IN_MW
    BIASED --&gt;|锁信息| THREAD_ID
    
    LIGHT --&gt;|hashCode/age| IN_LR
    LIGHT --&gt;|锁信息| LR_PTR
    
    HEAVY --&gt;|hashCode/age| IN_MON
    HEAVY --&gt;|锁信息| MON_ALL
    
    UNLOCK --&gt;|首次加锁| BIASED
    BIASED --&gt;|竞争| LIGHT
    LIGHT --&gt;|膨胀| HEAVY
    
    style UNLOCK fill:#c8e6c9
    style BIASED fill:#fff9c4
    style LIGHT fill:#bbdefb
    style HEAVY fill:#ffcdd2
    style IN_MW fill:#e8f5e9
    style IN_LR fill:#e3f2fd
    style IN_MON fill:#ffebee</code></pre>
<p><strong>关键理解：</strong></p>
<ol>
<li>
<p><strong>Mark Word 是&quot;指针容器&quot;而非&quot;数据容器&quot;</strong>：在轻量级锁和重量级锁状态下，Mark Word 不再直接存储 hashCode 等原始信息，而是存储指向其他数据结构的指针。</p>
</li>
<li>
<p><strong>Monitor 是独立的数据结构</strong>：ObjectMonitor 是 JVM 在 C++ 层面实现的对象，它独立于 Java 对象存在。当锁膨胀为重量级锁时，JVM 会创建（或复用）一个 ObjectMonitor 对象，并将其地址写入 Mark Word。</p>
</li>
<li>
<p><strong>原始信息的&quot;流转&quot;</strong>：</p>
<ul>
<li>无锁/偏向锁：原始信息直接在 Mark Word 中</li>
<li>轻量级锁：原始信息被拷贝到线程栈帧的 Lock Record 中</li>
<li>重量级锁：原始信息被保存到 Monitor 的 <code>_header</code> 字段中</li>
</ul>
</li>
<li>
<p><strong>解锁时的恢复</strong>：无论是轻量级锁还是重量级锁，解锁时都需要将原始的 Mark Word 恢复回去。这就是为什么轻量级锁解锁时需要 CAS 操作——它要把 Lock Record 中保存的 Displaced Mark Word 写回对象头。</p>
</li>
</ol>
<h2 id="monitor-与操作系统同步原语的关系">Monitor 与操作系统同步原语的关系</h2>
<h3 id="什么是原语-primitive-？">什么是原语（Primitive）？</h3>
<p>在讨论锁的底层实现之前，我们需要先理解一个核心概念：<strong>原语（Primitive）</strong>。</p>
<p><strong>原语的定义：</strong></p>
<p>原语是指由若干条机器指令组成的、用于完成特定功能的<strong>不可分割的基本操作</strong>。&quot;不可分割&quot;意味着原语的执行过程不会被中断——要么全部执行完成，要么完全不执行，不存在执行到一半的中间状态。</p>
<p><strong>原语的层次结构：</strong></p>
<p>在计算机系统中，原语存在于不同的层次，它们之间有明确的依赖关系：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;应用层&quot;
        JAVA[&quot;Java 同步机制&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;synchronized&lt;br/&gt;ReentrantLock&lt;br/&gt;Semaphore&quot;]
        style JAVA fill:#c8e6c9
    end
    
    subgraph &quot;JVM 层&quot;
        JVM[&quot;JVM 同步原语&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;ObjectMonitor&lt;br/&gt;Parker&lt;br/&gt;Unsafe.park/unpark&quot;]
        style JVM fill:#fff9c4
    end
    
    subgraph &quot;操作系统层&quot;
        OS[&quot;操作系统同步原语&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mutex（互斥量）&lt;br/&gt;Semaphore（信号量）&lt;br/&gt;Condition Variable（条件变量）&lt;br/&gt;Futex（Linux 快速用户态互斥）&quot;]
        style OS fill:#ffcc80
    end
    
    subgraph &quot;硬件/CPU 层&quot;
        CPU[&quot;CPU 指令原语&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;CAS（Compare-And-Swap）&lt;br/&gt;LL/SC（Load-Linked/Store-Conditional）&lt;br/&gt;Memory Barrier（内存屏障）&lt;br/&gt;LOCK 前缀指令（x86）&quot;]
        style CPU fill:#ffcdd2
    end
    
    JAVA --&gt;|&quot;依赖&quot;| JVM
    JVM --&gt;|&quot;依赖&quot;| OS
    OS --&gt;|&quot;依赖&quot;| CPU
    
    note1[&quot;关键理解：&lt;br/&gt;上层原语由下层原语组合实现&lt;br/&gt;最底层是 CPU 提供的原子指令&quot;]
    style note1 fill:#e1f5ff</code></pre>
<p><strong>CPU 指令原语（Instruction Primitives）：</strong></p>
<p>CPU 指令原语是最底层的原子操作，由硬件直接保证其原子性。常见的 CPU 指令原语包括：</p>
<table>
<thead>
<tr>
<th>指令原语</th>
<th>架构</th>
<th>功能</th>
<th>在 Java 中的体现</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CAS（Compare-And-Swap）</strong></td>
<td>x86: <code>CMPXCHG</code><br/>ARM: <code>LDREX/STREX</code></td>
<td>比较并交换：如果内存值等于预期值，则更新为新值</td>
<td><code>Unsafe.compareAndSwapInt()</code><br/><code>AtomicInteger.compareAndSet()</code></td>
</tr>
<tr>
<td><strong>LOCK 前缀</strong></td>
<td>x86</td>
<td>锁定总线或缓存行，确保后续指令的原子性</td>
<td>CAS 指令的底层实现</td>
</tr>
<tr>
<td><strong>Memory Barrier</strong></td>
<td>所有架构</td>
<td>防止指令重排序，确保内存可见性</td>
<td><code>volatile</code> 的底层实现</td>
</tr>
<tr>
<td><strong>XCHG</strong></td>
<td>x86</td>
<td>原子交换两个值</td>
<td>自旋锁的底层实现</td>
</tr>
</tbody>
</table>
<p><strong>操作系统同步原语（OS Synchronization Primitives）：</strong></p>
<p>操作系统基于 CPU 指令原语，提供了更高级的同步机制：</p>
<table>
<thead>
<tr>
<th>OS 原语</th>
<th>功能</th>
<th>特点</th>
<th>对应的 Java 机制</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Mutex（互斥量）</strong></td>
<td>保证同一时刻只有一个线程进入临界区</td>
<td>阻塞式，需要系统调用</td>
<td><code>synchronized</code>（重量级锁）</td>
</tr>
<tr>
<td><strong>Semaphore（信号量）</strong></td>
<td>控制同时访问资源的线程数量</td>
<td>可以允许多个线程同时访问</td>
<td><code>java.util.concurrent.Semaphore</code></td>
</tr>
<tr>
<td><strong>Condition Variable（条件变量）</strong></td>
<td>线程等待特定条件成立</td>
<td>必须与 Mutex 配合使用</td>
<td><code>Object.wait()/notify()</code></td>
</tr>
<tr>
<td><strong>Futex（Fast Userspace Mutex）</strong></td>
<td>Linux 特有的快速互斥量</td>
<td>无竞争时在用户态完成，有竞争时才进入内核</td>
<td>JVM 在 Linux 上的锁实现</td>
</tr>
</tbody>
</table>
<p><strong>指令原语与操作系统原语的关系：</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;CPU 指令原语&quot;
        CAS[&quot;CAS 指令&quot;]
        LOCK[&quot;LOCK 前缀&quot;]
        BARRIER[&quot;Memory Barrier&quot;]
    end
    
    subgraph &quot;操作系统原语&quot;
        MUTEX[&quot;Mutex&quot;]
        FUTEX[&quot;Futex&quot;]
        COND[&quot;Condition Variable&quot;]
    end
    
    CAS --&gt;|&quot;构建&quot;| FUTEX
    CAS --&gt;|&quot;构建&quot;| MUTEX
    LOCK --&gt;|&quot;保证原子性&quot;| CAS
    BARRIER --&gt;|&quot;保证可见性&quot;| MUTEX
    MUTEX --&gt;|&quot;配合使用&quot;| COND
    
    note[&quot;OS 原语 = CPU 原语 + 线程调度 + 等待队列&lt;br/&gt;OS 原语提供了线程阻塞/唤醒的能力&lt;br/&gt;CPU 原语只能自旋等待&quot;]
    style note fill:#fff9c4</code></pre>
<p><strong>为什么需要操作系统原语？</strong></p>
<p>CPU 指令原语（如 CAS）只能实现<strong>自旋等待</strong>——线程不断循环检查条件是否满足。这种方式在等待时间短时效率很高，但如果等待时间长，会浪费大量 CPU 资源。</p>
<p>操作系统原语（如 Mutex）提供了<strong>阻塞等待</strong>的能力——线程可以被挂起，不占用 CPU，等条件满足时再被唤醒。这需要操作系统内核的支持，因为只有内核才能控制线程的调度。</p>
<table>
<thead>
<tr>
<th>等待方式</th>
<th>实现基础</th>
<th>CPU 占用</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>自旋等待</strong></td>
<td>CPU 指令原语（CAS）</td>
<td>高（持续占用 CPU）</td>
<td>等待时间极短（&lt; 几微秒）</td>
</tr>
<tr>
<td><strong>阻塞等待</strong></td>
<td>OS 原语（Mutex）</td>
<td>低（线程挂起）</td>
<td>等待时间较长（&gt; 几微秒）</td>
</tr>
</tbody>
</table>
<p>这也解释了为什么 JVM 的锁优化策略是&quot;先自旋，后阻塞&quot;——先用 CPU 原语尝试快速获取锁，如果失败再退化到 OS 原语进行阻塞等待。</p>
<p><strong>核心问题：ObjectMonitor 是如何实现线程阻塞和唤醒的？</strong></p>
<p>前面我们知道，重量级锁的核心是 ObjectMonitor，它管理着 Owner、EntryList、WaitSet 等数据结构。但 ObjectMonitor 本身只是一个 JVM 层面的 C++ 对象，它<strong>无法直接让线程阻塞或唤醒</strong>——这些操作必须依赖操作系统提供的同步原语。</p>
<p><strong>图1：从 synchronized 到操作系统的完整调用链</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Java 层&quot;
        SYNC[&quot;synchronized(obj)&quot;]
        style SYNC fill:#c8e6c9
    end
    
    subgraph &quot;JVM 层（HotSpot C++）&quot;
        INTERP[&quot;字节码解释器&lt;br/&gt;monitorenter/monitorexit&quot;]
        OBJMON[&quot;ObjectMonitor&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;enter() / exit()&lt;br/&gt;wait() / notify()&quot;]
        PARKER[&quot;Parker&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;park() / unpark()&lt;br/&gt;每个线程一个 Parker 实例&quot;]
        
        INTERP --&gt; OBJMON
        OBJMON --&gt;|&quot;竞争失败&lt;br/&gt;需要阻塞&quot;| PARKER
        
        style INTERP fill:#fff9c4
        style OBJMON fill:#ffcc80
        style PARKER fill:#ffab91
    end
    
    subgraph &quot;操作系统层&quot;
        subgraph &quot;Linux&quot;
            FUTEX[&quot;futex()&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Fast Userspace Mutex&lt;br/&gt;用户态/内核态混合&quot;]
            PTHREAD_L[&quot;pthread_mutex_t&lt;br/&gt;pthread_cond_t&quot;]
            FUTEX --&gt; PTHREAD_L
            style FUTEX fill:#e1bee7
            style PTHREAD_L fill:#ce93d8
        end
        
        subgraph &quot;macOS/BSD&quot;
            PTHREAD_M[&quot;pthread_mutex_t&lt;br/&gt;pthread_cond_t&quot;]
            style PTHREAD_M fill:#ce93d8
        end
        
        subgraph &quot;Windows&quot;
            CRITICAL[&quot;CRITICAL_SECTION&lt;br/&gt;WaitForSingleObject&quot;]
            style CRITICAL fill:#90caf9
        end
    end
    
    PARKER --&gt;|&quot;Linux&quot;| FUTEX
    PARKER --&gt;|&quot;macOS&quot;| PTHREAD_M
    PARKER --&gt;|&quot;Windows&quot;| CRITICAL
    
    note1[&quot;关键洞察：&lt;br/&gt;ObjectMonitor 不直接调用 OS 原语&lt;br/&gt;而是通过 Parker 这个中间层&lt;br/&gt;Parker 封装了跨平台的阻塞/唤醒逻辑&quot;]
    style note1 fill:#e1f5ff</code></pre>
<p><strong>图2：ObjectMonitor 内部的同步机制</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;ObjectMonitor 内部结构&quot;
        direction TB
        
        subgraph &quot;数据字段&quot;
            OWNER[&quot;_owner&lt;br/&gt;当前持锁线程&quot;]
            ENTRY[&quot;_EntryList&lt;br/&gt;阻塞等待队列&quot;]
            WAIT[&quot;_WaitSet&lt;br/&gt;wait() 等待集合&quot;]
            CXQUEUE[&quot;_cxq&lt;br/&gt;竞争队列（新来的线程）&quot;]
            style OWNER fill:#ffcdd2
            style ENTRY fill:#fff9c4
            style WAIT fill:#e1bee7
            style CXQUEUE fill:#b2dfdb
        end
        
        subgraph &quot;同步原语（平台相关）&quot;
            MUTEX[&quot;底层 Mutex&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;保护 ObjectMonitor 自身&lt;br/&gt;的数据结构一致性&quot;]
            EVENT[&quot;Park/Unpark 事件&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;用于线程阻塞/唤醒&quot;]
            style MUTEX fill:#ffcc80
            style EVENT fill:#ffab91
        end
    end
    
    subgraph &quot;线程状态转换&quot;
        T_RUN[&quot;RUNNABLE&lt;br/&gt;运行中&quot;]
        T_BLOCK[&quot;BLOCKED&lt;br/&gt;阻塞等待锁&quot;]
        T_WAIT[&quot;WAITING&lt;br/&gt;wait() 等待&quot;]
        
        T_RUN --&gt;|&quot;获取锁失败&lt;br/&gt;park()&quot;| T_BLOCK
        T_BLOCK --&gt;|&quot;获取锁成功&lt;br/&gt;unpark()&quot;| T_RUN
        T_RUN --&gt;|&quot;调用 wait()&lt;br/&gt;park()&quot;| T_WAIT
        T_WAIT --&gt;|&quot;被 notify()&lt;br/&gt;unpark()&quot;| T_BLOCK
        
        style T_RUN fill:#c8e6c9
        style T_BLOCK fill:#ffcdd2
        style T_WAIT fill:#e1bee7
    end
    
    MUTEX -.-&gt;|&quot;保护&quot;| OWNER
    MUTEX -.-&gt;|&quot;保护&quot;| ENTRY
    MUTEX -.-&gt;|&quot;保护&quot;| WAIT
    EVENT -.-&gt;|&quot;阻塞/唤醒&quot;| T_BLOCK
    EVENT -.-&gt;|&quot;阻塞/唤醒&quot;| T_WAIT</code></pre>
<p><strong>ObjectMonitor 与 OS 原语的对应关系：</strong></p>
<table>
<thead>
<tr>
<th>ObjectMonitor 操作</th>
<th>对应的 OS 原语</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>enter()</code> 获取锁失败</td>
<td><code>pthread_mutex_lock()</code> 或 <code>futex(FUTEX_WAIT)</code></td>
<td>线程阻塞，进入 EntryList</td>
</tr>
<tr>
<td><code>exit()</code> 释放锁</td>
<td><code>pthread_mutex_unlock()</code> 或 <code>futex(FUTEX_WAKE)</code></td>
<td>唤醒 EntryList 中的线程</td>
</tr>
<tr>
<td><code>wait()</code></td>
<td><code>pthread_cond_wait()</code></td>
<td>释放锁，进入 WaitSet，阻塞</td>
</tr>
<tr>
<td><code>notify()</code></td>
<td><code>pthread_cond_signal()</code></td>
<td>从 WaitSet 移动一个线程到 EntryList</td>
</tr>
<tr>
<td><code>notifyAll()</code></td>
<td><code>pthread_cond_broadcast()</code></td>
<td>移动 WaitSet 中所有线程到 EntryList</td>
</tr>
</tbody>
</table>
<p><strong>图3：Linux 上的 Futex 优化机制</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;Futex 的设计理念&quot;
        direction TB
        
        subgraph &quot;无竞争路径（Fast Path）&quot;
            FAST[&quot;用户态 CAS 操作&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;直接修改 futex word&lt;br/&gt;不进入内核&lt;br/&gt;开销：≈ 几十个 CPU 周期&quot;]
            style FAST fill:#c8e6c9
        end
        
        subgraph &quot;有竞争路径（Slow Path）&quot;
            SLOW[&quot;futex() 系统调用&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;进入内核&lt;br/&gt;线程阻塞在内核等待队列&lt;br/&gt;开销：≈ 几千个 CPU 周期&quot;]
            style SLOW fill:#ffcdd2
        end
    end
    
    subgraph &quot;与 JVM 锁的对应&quot;
        LIGHT_LOCK[&quot;轻量级锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;类似 Futex Fast Path&lt;br/&gt;用户态 CAS + 自旋&quot;]
        HEAVY_LOCK[&quot;重量级锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;类似 Futex Slow Path&lt;br/&gt;进入内核阻塞&quot;]
        
        style LIGHT_LOCK fill:#fff9c4
        style HEAVY_LOCK fill:#ffcc80
    end
    
    FAST -.-&gt;|&quot;设计理念相同&quot;| LIGHT_LOCK
    SLOW -.-&gt;|&quot;设计理念相同&quot;| HEAVY_LOCK
    
    note1[&quot;Futex = Fast Userspace Mutex&lt;br/&gt;核心思想：无竞争时在用户态解决&lt;br/&gt;有竞争时才进入内核&lt;br/&gt;这与 JVM 锁优化的思想一致！&quot;]
    style note1 fill:#e1f5ff</code></pre>
<p><strong>图4：完整的锁获取流程（从 Java 到内核）</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Java as Java 代码
    participant JVM as JVM (HotSpot)
    participant Monitor as ObjectMonitor
    participant Parker as Parker
    participant OS as 操作系统内核
    
    Java-&gt;&gt;JVM: synchronized(obj)
    JVM-&gt;&gt;JVM: 检查 Mark Word
    
    alt 偏向锁/轻量级锁成功
        JVM-&gt;&gt;Java: 获取锁成功（用户态完成）
    else 需要重量级锁
        JVM-&gt;&gt;Monitor: 获取 ObjectMonitor
        Monitor-&gt;&gt;Monitor: 尝试 CAS 设置 _owner
        
        alt CAS 成功
            Monitor-&gt;&gt;Java: 获取锁成功
        else CAS 失败（有竞争）
            Monitor-&gt;&gt;Monitor: 自旋尝试
            
            alt 自旋成功
                Monitor-&gt;&gt;Java: 获取锁成功
            else 自旋失败
                Monitor-&gt;&gt;Parker: 调用 park()
                Parker-&gt;&gt;OS: futex(FUTEX_WAIT) / pthread_mutex_lock()
                Note over OS: 线程阻塞在内核
                OS--&gt;&gt;Parker: 被唤醒
                Parker--&gt;&gt;Monitor: park() 返回
                Monitor-&gt;&gt;Monitor: 重新竞争锁
            end
        end
    end</code></pre>
<p><strong>为什么需要 Parker 这个中间层？</strong></p>
<ol>
<li><strong>跨平台抽象</strong>：不同操作系统的阻塞原语不同（Linux 用 futex/pthread，Windows 用 Event），Parker 提供统一接口</li>
<li><strong>性能优化</strong>：Parker 可以实现&quot;先自旋再阻塞&quot;的策略，减少不必要的系统调用</li>
<li><strong>与 LockSupport 对接</strong>：Java 层的 <code>LockSupport.park()/unpark()</code> 最终调用的就是 Parker</li>
</ol>
<p><strong>关键理解：两层 Mutex 的区别</strong></p>
<p>很多人容易混淆的一点是：ObjectMonitor 内部有一个 Mutex，操作系统也有 Mutex，它们是什么关系？</p>
<table>
<thead>
<tr>
<th>层级</th>
<th>Mutex 用途</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>ObjectMonitor 内部 Mutex</strong></td>
<td>保护 ObjectMonitor 自身的数据结构</td>
<td>确保多线程并发修改 <code>_owner</code>、<code>_EntryList</code> 等字段时的一致性</td>
</tr>
<tr>
<td><strong>OS Mutex（通过 Parker）</strong></td>
<td>实现线程的阻塞和唤醒</td>
<td>当线程需要等待时，真正让 CPU 不再调度该线程</td>
</tr>
</tbody>
</table>
<p>简单来说：</p>
<ul>
<li><strong>ObjectMonitor 的 Mutex</strong> 是为了保护&quot;锁的元数据&quot;</li>
<li><strong>OS 的 Mutex/Futex</strong> 是为了实现&quot;线程的阻塞&quot;</li>
</ul>
<p>这就像一个银行：</p>
<ul>
<li>银行内部的保险柜锁（ObjectMonitor Mutex）保护的是&quot;谁在排队、谁在办业务&quot;的记录</li>
<li>银行大门的锁（OS Mutex）决定的是&quot;顾客能不能进来&quot;</li>
</ul>
<p><strong>锁对象复用陷阱：</strong> 由于一个对象在任意时刻只能被一个线程锁定（monitor 只有一个 owner），如果在不同的业务逻辑中复用同一个锁对象，会导致本来毫无关联的代码互相阻塞。例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BadExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <span class="hljs-comment">// 只有一个锁对象</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodA</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123; <span class="hljs-comment">/* 业务逻辑 A */</span> &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">methodB</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123; <span class="hljs-comment">/* 业务逻辑 B，与 A 完全无关 */</span> &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>即使 <code>methodA</code> 和 <code>methodB</code> 的业务逻辑完全独立，它们也会互相阻塞，因为竞争的是同一个对象的 monitor。正确做法是为不相关的临界区使用不同的锁对象。这个问题同样适用于 <code>ReentrantLock</code>——锁的粒度由锁对象/Lock 实例的数量决定，一个锁对象 = 一把锁 = 同一时刻只能一个线程持有。</p>
<h1>锁优化</h1>
<p><img src="synchronized%E5%8E%9F%E7%90%86.jpg" alt="synchronized原理"><br>
<img src="%E9%94%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8F%98%E5%8C%96%E6%B5%81%E7%A8%8B.png" alt="锁对象的变化流程"></p>
<p>所有的锁优化其实是 synchronized 优化。</p>
<h2 id="锁优化的设计哲学：用户态锁-vs-内核态锁">锁优化的设计哲学：用户态锁 vs 内核态锁</h2>
<p><strong>核心思想：锁越轻，离底层 Mutex 机制越远，越能在 Java/JVM 内部的数据结构中解决；涉及的 JVM 外部/底层机制越少，开销就越小。</strong></p>
<p>这个设计思想与 <strong>绿色线程（Green Thread）vs内核线程（Kernel Thread）</strong> 的设计理念高度相似：</p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>绿色线程</th>
<th>内核线程</th>
<th>轻量级锁</th>
<th>重量级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>调度/管理者</strong></td>
<td>用户态运行时（如 JVM、Go runtime）</td>
<td>操作系统内核</td>
<td>JVM（CAS + 自旋）</td>
<td>操作系统（Mutex）</td>
</tr>
<tr>
<td><strong>切换开销</strong></td>
<td>极低（不涉及内核）</td>
<td>高（用户态/内核态切换）</td>
<td>极低（用户态 CAS）</td>
<td>高（系统调用）</td>
</tr>
<tr>
<td><strong>数据结构位置</strong></td>
<td>用户空间</td>
<td>内核空间</td>
<td>Java 栈帧（Lock Record）</td>
<td>内核 Mutex + ObjectMonitor</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>大量轻量级并发</td>
<td>需要真正并行</td>
<td>低竞争同步</td>
<td>高竞争同步</td>
</tr>
</tbody>
</table>
<p><strong>可以说，偏向锁和轻量级锁就是&quot;用户态锁&quot;，而重量级锁是&quot;内核态锁&quot;。</strong></p>
<p><strong>图：锁机制的分层架构——从用户态到内核态的渐进式下沉</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;用户态（User Space）&quot;
        subgraph &quot;纯 Java 对象层&quot;
            BIAS[&quot;偏向锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word 存储线程 ID&lt;br/&gt;后续加锁：仅比较线程 ID&lt;br/&gt;开销：≈ 0&quot;]
            style BIAS fill:#c8e6c9
        end
        
        subgraph &quot;Java 栈 + CAS 层&quot;
            LIGHT[&quot;轻量级锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word → Lock Record&lt;br/&gt;Lock Record 在线程栈帧中&lt;br/&gt;开销：CAS + 自旋&quot;]
            style LIGHT fill:#fff9c4
        end
        
        subgraph &quot;JVM 运行时层&quot;
            MONITOR[&quot;ObjectMonitor&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;JVM C++ 对象&lt;br/&gt;管理 Owner/EntryList/WaitSet&quot;]
            style MONITOR fill:#ffcc80
        end
    end
    
    subgraph &quot;内核态（Kernel Space）&quot;
        MUTEX[&quot;OS Mutex / Futex&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;操作系统同步原语&lt;br/&gt;线程阻塞/唤醒&lt;br/&gt;开销：用户态/内核态切换&quot;]
        style MUTEX fill:#ffcdd2
    end
    
    BIAS --&gt;|&quot;出现竞争&lt;br/&gt;撤销偏向&quot;| LIGHT
    LIGHT --&gt;|&quot;竞争激烈&lt;br/&gt;自旋失败&quot;| MONITOR
    MONITOR --&gt;|&quot;阻塞线程&lt;br/&gt;系统调用&quot;| MUTEX
    
    note1[&quot;越往下，离 Java 越远，离 OS 越近&lt;br/&gt;开销越大，但能处理的竞争越激烈&quot;]
    style note1 fill:#e1f5ff</code></pre>
<h3 id="锁升级的标志性事件">锁升级的标志性事件</h3>
<p>锁的状态转换不是随机发生的，而是由<strong>明确的、可识别的标志性事件</strong>触发。理解这些事件是理解锁优化的关键：</p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;锁状态&quot;
        UNLOCKED[&quot;无锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word 存储：&lt;br/&gt;hashCode + age + 0|01&quot;]
        BIASED[&quot;偏向锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word 存储：&lt;br/&gt;ThreadID + epoch + 1|01&quot;]
        LIGHT[&quot;轻量级锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word 存储：&lt;br/&gt;Lock Record 指针 + 00&quot;]
        HEAVY[&quot;重量级锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word 存储：&lt;br/&gt;Monitor 指针 + 10&quot;]
    end
    
    UNLOCKED --&gt;|&quot;事件①&lt;br/&gt;首次加锁&quot;| BIASED
    BIASED --&gt;|&quot;事件②&lt;br/&gt;第二个线程尝试获取锁&quot;| LIGHT
    LIGHT --&gt;|&quot;事件③&lt;br/&gt;CAS 竞争失败&quot;| HEAVY
    
    style UNLOCKED fill:#e8f5e9
    style BIASED fill:#c8e6c9
    style LIGHT fill:#fff9c4
    style HEAVY fill:#ffcdd2</code></pre>
<p><strong>锁升级的标志性事件详解：</strong></p>
<table>
<thead>
<tr>
<th>事件</th>
<th>触发条件</th>
<th>状态转换</th>
<th>具体表现</th>
<th>为什么触发升级</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>事件①：首次加锁</strong></td>
<td>对象第一次被 <code>synchronized</code></td>
<td>无锁 → 偏向锁</td>
<td>CAS 将当前线程 ID 写入 Mark Word</td>
<td>假设锁总是被同一线程获取</td>
</tr>
<tr>
<td><strong>事件②：第二个线程尝试获取锁</strong></td>
<td>另一个线程尝试获取已偏向的锁</td>
<td>偏向锁 → 轻量级锁</td>
<td>撤销偏向，两个线程都创建 Lock Record，CAS 竞争</td>
<td>偏向假设被打破，需要真正的同步机制</td>
</tr>
<tr>
<td><strong>事件③：CAS 竞争失败</strong></td>
<td>线程 CAS 设置 Lock Record 指针失败</td>
<td>轻量级锁 → 重量级锁</td>
<td>创建 ObjectMonitor，失败线程进入 EntryList 阻塞</td>
<td>CAS 失败意味着存在真正的并发竞争</td>
</tr>
</tbody>
</table>
<p><strong>关键理解：什么是&quot;竞争&quot;？</strong></p>
<p>在锁优化的语境下，&quot;竞争&quot;有精确的定义：</p>
<table>
<thead>
<tr>
<th>竞争类型</th>
<th>定义</th>
<th>锁状态</th>
<th>处理方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无竞争</strong></td>
<td>始终只有一个线程访问锁</td>
<td>偏向锁</td>
<td>仅记录线程 ID，无需同步</td>
</tr>
<tr>
<td><strong>交替访问（无真正竞争）</strong></td>
<td>多个线程访问锁，但不同时</td>
<td>轻量级锁</td>
<td>CAS 总能成功，无需阻塞</td>
</tr>
<tr>
<td><strong>真正竞争</strong></td>
<td>多个线程同时尝试获取锁</td>
<td>重量级锁</td>
<td>CAS 失败，需要阻塞等待</td>
</tr>
</tbody>
</table>
<p><strong>偏向锁 vs 轻量级锁的本质区别：</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>偏向锁</th>
<th>轻量级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>假设场景</strong></td>
<td>锁始终被同一个线程获取</td>
<td>锁被多个线程交替获取，但不同时</td>
</tr>
<tr>
<td><strong>加锁操作</strong></td>
<td>首次 CAS，后续仅比较线程 ID</td>
<td>每次都需要 CAS</td>
</tr>
<tr>
<td><strong>数据结构</strong></td>
<td>仅 Mark Word（存线程 ID）</td>
<td>Mark Word + Lock Record</td>
</tr>
<tr>
<td><strong>升级触发</strong></td>
<td>第二个线程出现</td>
<td>CAS 失败（真正竞争）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>单线程反复进入同步块</td>
<td>多线程交替进入同步块</td>
</tr>
</tbody>
</table>
<p><strong>为什么这种分层设计是高效的？</strong></p>
<p>观察 Mark Word 在不同锁状态下的内容变化，可以发现一个清晰的<strong>局部性原则</strong>：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>数据存储位置</th>
<th>依赖层级</th>
<th>涉及的外部机制</th>
<th>性能开销</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无锁</strong></td>
<td>Mark Word 直接存储 hashCode、age</td>
<td>纯 Java 对象</td>
<td>无</td>
<td>无额外开销</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>Mark Word 存储线程 ID</td>
<td>纯 Java 对象</td>
<td>无（仅首次 CAS）</td>
<td>≈ 0</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>Mark Word → Lock Record（线程栈帧）</td>
<td>Java 栈 + CPU CAS 指令</td>
<td>CPU 原子指令</td>
<td>用户态自旋</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>Mark Word → ObjectMonitor → OS Mutex</td>
<td>操作系统内核</td>
<td>系统调用、内核调度器</td>
<td>用户态/内核态切换</td>
</tr>
</tbody>
</table>
<p><strong>这种设计体现了&quot;能在用户态解决的问题，就不要下沉到内核态&quot;的优化原则：</strong></p>
<ol>
<li>
<p><strong>偏向锁（纯用户态，零开销）</strong>：假设锁总是被同一个线程获取，直接在 Mark Word 中记录线程 ID，后续加锁只需比较线程 ID，连 CAS 都省了。这是最乐观的假设，完全在 Java 对象层面解决，<strong>不涉及任何 JVM 外部机制</strong>。</p>
</li>
<li>
<p><strong>轻量级锁（用户态，低开销）</strong>：当出现竞争时，退而求其次，使用 CAS + 自旋的方式在用户态解决。Lock Record 存储在线程栈帧中，仍然是 Java 层面的数据结构。虽然 CAS 需要 CPU 提供原子指令支持，但<strong>不涉及操作系统调用</strong>，仍在用户态完成。</p>
</li>
<li>
<p><strong>重量级锁（内核态，高开销）</strong>：当竞争激烈、自旋无法快速获取锁时，才不得不&quot;下沉&quot;到操作系统层面，使用 Mutex/Futex 等同步原语。此时 Mark Word 指向 ObjectMonitor，而 ObjectMonitor 内部会调用操作系统的阻塞/唤醒机制，<strong>触发用户态/内核态切换</strong>。</p>
</li>
</ol>
<p><strong>与绿色线程的类比深化：</strong></p>
<table>
<thead>
<tr>
<th>设计理念</th>
<th>绿色线程</th>
<th>轻量级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心思想</strong></td>
<td>用户态调度替代内核态调度</td>
<td>用户态同步替代内核态同步</td>
</tr>
<tr>
<td><strong>实现方式</strong></td>
<td>M:N 模型，多个用户态线程映射到少量内核线程</td>
<td>CAS + 自旋，在用户态完成锁的获取和释放</td>
</tr>
<tr>
<td><strong>优势</strong></td>
<td>避免内核态切换开销，支持大量轻量级并发</td>
<td>避免系统调用开销，支持低竞争场景的高效同步</td>
</tr>
<tr>
<td><strong>局限性</strong></td>
<td>无法利用多核并行（除非有内核线程支撑）</td>
<td>无法处理高竞争场景（必须膨胀为重量级锁）</td>
</tr>
<tr>
<td><strong>典型实现</strong></td>
<td>Go goroutine、Erlang process、Java 虚拟线程</td>
<td>JVM 偏向锁、轻量级锁</td>
</tr>
</tbody>
</table>
<p><strong>但有一个关键区别</strong>：绿色线程可以<strong>完全替代</strong>内核线程（如 Go 的 goroutine 在大多数场景下足够），而轻量级锁<strong>不能完全替代</strong>重量级锁——当竞争激烈时，自旋会浪费大量 CPU，必须膨胀为重量级锁让线程阻塞等待。</p>
<p><strong>为什么锁只能升级不能降级？</strong></p>
<p>这也解释了为什么锁只能升级不能降级：一旦发现竞争激烈到需要重量级锁，说明这个锁的使用场景确实存在高并发竞争，降级回轻量级锁反而会因为频繁的 CAS 失败和自旋浪费更多 CPU 资源。这就像一个服务发现单机处理不了流量后扩容到集群，即使流量下降也不会立即缩容——因为流量模式已经证明了需要更高的处理能力。</p>
<p><strong>总结：锁优化的本质是&quot;就近原则&quot;</strong></p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">问题能在 <span class="hljs-variable">Java</span> 对象层解决 → 偏向锁（<span class="hljs-variable">Mark</span> <span class="hljs-built_in">Word</span> 存线程 <span class="hljs-variable">ID</span>）<br>问题能在 <span class="hljs-variable">Java</span> 栈层解决   → 轻量级锁（<span class="hljs-variable">Lock</span> <span class="hljs-built_in">Record</span> <span class="hljs-operator">+</span> <span class="hljs-variable">CAS</span>）<br>问题必须在 <span class="hljs-variable">OS</span> 层解决     → 重量级锁（<span class="hljs-variable">ObjectMonitor</span> <span class="hljs-operator">+</span> <span class="hljs-variable">Mutex</span>）<br></code></pre></td></tr></table></figure>
<p><strong>离问题发生地越近的解决方案，开销越小。</strong> 这与计算机体系结构中的&quot;局部性原理&quot;一脉相承：CPU 缓存比内存快，内存比磁盘快，本地调用比远程调用快——同样，用户态同步比内核态同步快。</p>
<h3 id="三种锁对-mark-word-的处理策略">三种锁对 Mark Word 的处理策略</h3>
<p>理解三种锁的本质差异，关键在于理解它们如何处理 Mark Word 中的原始信息（hashCode、GC age 等）：</p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>Mark Word 处理方式</th>
<th>原始信息存储位置</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>偏向锁</strong></td>
<td>原地复用 Mark Word，用 threadId 替换 hashCode 字段</td>
<td>无需备份（但 hashCode 与偏向锁互斥）</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>Mark Word 被替换为指向 Lock Record 的指针</td>
<td>Lock Record 的 Displaced Mark Word 字段</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>Mark Word 被替换为指向 ObjectMonitor 的指针</td>
<td>ObjectMonitor 的 <code>_header</code> 字段</td>
</tr>
</tbody>
</table>
<p>这个设计体现了一个核心权衡：</p>
<ul>
<li><strong>偏向锁</strong>是&quot;原地操作&quot;，不需要额外的数据结构来保存原始 Mark Word，因此最轻量。代价是 hashCode 和 threadId 互斥，调用 <code>hashCode()</code> 会导致偏向锁失效。</li>
<li><strong>轻量级锁和重量级锁</strong>都是&quot;指针替换&quot;，需要将原始 Mark Word 转移到别处保存（Lock Record 或 ObjectMonitor），解锁时再恢复。这也解释了为什么轻量级锁解锁时必须用 CAS 把 Displaced Mark Word 写回——就是为了恢复原始信息。</li>
</ul>
<h3 id="三种锁的数据结构对比">三种锁的数据结构对比</h3>
<p>理解三种锁的本质差异，关键在于理解它们各自的数据结构：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;偏向锁：最轻量，无额外数据结构&quot;
        direction TB
        
        OBJ_BIAS[&quot;锁对象 obj&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word:&lt;br/&gt;threadId | epoch | age | 1 | 01&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;直接在 Mark Word 中&lt;br/&gt;记录偏向线程 ID&quot;]
        
        THREAD_BIAS[&quot;偏向线程&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;无需任何额外数据结构&lt;br/&gt;只需检查 Mark Word 中的&lt;br/&gt;threadId 是否是自己&quot;]
        
        OBJ_BIAS -.-&gt;|&quot;threadId 记录在&lt;br/&gt;Mark Word 中&quot;| THREAD_BIAS
        
        style OBJ_BIAS fill:#e8f5e9
        style THREAD_BIAS fill:#e8f5e9
    end</code></pre>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;轻量级锁：一个 Lock Record，无等待队列&quot;
        direction TB
        
        OBJ_LIGHT[&quot;锁对象 obj&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word:&lt;br/&gt;ptr_to_lock_record | 00&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;指向持锁线程栈上的&lt;br/&gt;Lock Record&quot;]
        
        LR_LIGHT[&quot;Lock Record（栈上）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word&lt;br/&gt;（原始 Mark Word 备份）&lt;br/&gt;owner → obj&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;无 WaitSet&lt;br/&gt;无 EntryList&lt;br/&gt;无 Mutex&quot;]
        
        THREAD_LIGHT[&quot;持锁线程&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Lock Record 在其栈帧中&quot;]
        
        OTHER_LIGHT[&quot;竞争线程&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;CAS 自旋重试&lt;br/&gt;不阻塞、不排队&quot;]
        
        OBJ_LIGHT --&gt;|&quot;Mark Word 指向&quot;| LR_LIGHT
        LR_LIGHT --&gt;|&quot;在栈帧中&quot;| THREAD_LIGHT
        OTHER_LIGHT -.-&gt;|&quot;CAS 失败后自旋&quot;| OBJ_LIGHT
        
        style OBJ_LIGHT fill:#e1f5ff
        style LR_LIGHT fill:#e1f5ff
        style THREAD_LIGHT fill:#c8e6c9
        style OTHER_LIGHT fill:#fff9c4
    end</code></pre>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;重量级锁：完整的 Monitor 结构&quot;
        direction TB
        
        OBJ_HEAVY[&quot;锁对象 obj&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word:&lt;br/&gt;ptr_to_monitor | 10&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;指向 ObjectMonitor&quot;]
        
        MONITOR[&quot;ObjectMonitor（C++ 堆）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;_header: 原始 Mark Word&lt;br/&gt;_owner: → 持锁线程&lt;br/&gt;_recursions: 重入计数&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;_cxq: 竞争队列&lt;br/&gt;_EntryList: 阻塞等待队列&lt;br/&gt;_WaitSet: wait() 等待队列&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;底层同步原语 ⬇️&quot;]
        
        MUTEX[&quot;pthread_mutex_t&lt;br/&gt;（OS 互斥量）&quot;]
        
        COND[&quot;pthread_cond_t&lt;br/&gt;（条件变量）&quot;]
        
        OWNER[&quot;持锁线程&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;_owner 指向它&quot;]
        
        WAITING[&quot;等待线程们&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;在 _EntryList 中阻塞&lt;br/&gt;或在 _WaitSet 中等待&quot;]
        
        OBJ_HEAVY --&gt;|&quot;Mark Word 指向&quot;| MONITOR
        MONITOR --&gt;|&quot;_owner&quot;| OWNER
        MONITOR --&gt;|&quot;_EntryList / _WaitSet&quot;| WAITING
        MONITOR --&gt;|&quot;封装&quot;| MUTEX
        MONITOR --&gt;|&quot;封装&quot;| COND
        MUTEX --&gt;|&quot;系统调用&quot;| KERNEL[&quot;内核态&quot;]
        
        style OBJ_HEAVY fill:#ffcdd2
        style MONITOR fill:#ffcdd2
        style MUTEX fill:#ffcdd2
        style COND fill:#ffcdd2
        style OWNER fill:#c8e6c9
        style WAITING fill:#fff9c4
        style KERNEL fill:#ffcdd2
    end</code></pre>
<p><strong>三种锁的本质区别总结：</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>偏向锁</th>
<th>轻量级锁</th>
<th>重量级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Mark Word 内容</strong></td>
<td>偏向线程 ID</td>
<td>指向 Lock Record 的指针</td>
<td>指向 ObjectMonitor 的指针</td>
</tr>
<tr>
<td><strong>额外数据结构</strong></td>
<td>无</td>
<td>Lock Record（栈上，1个）</td>
<td>ObjectMonitor（C++ 堆，含多个队列）</td>
</tr>
<tr>
<td><strong>持锁线程记录</strong></td>
<td>Mark Word 中的 threadId</td>
<td>Mark Word 指向的 Lock Record 所在栈帧</td>
<td>Monitor 的 _owner 字段</td>
</tr>
<tr>
<td><strong>等待队列</strong></td>
<td>无</td>
<td>无（自旋重试）</td>
<td>有（_EntryList、_WaitSet、_cxq）</td>
</tr>
<tr>
<td><strong>底层同步原语</strong></td>
<td>无</td>
<td>CAS 指令</td>
<td>OS Mutex + Condition Variable</td>
</tr>
<tr>
<td><strong>竞争失败处理</strong></td>
<td>撤销偏向，升级</td>
<td>CAS 自旋，超时则膨胀</td>
<td>阻塞，进入等待队列</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>单线程反复获取同一把锁</td>
<td>多线程交替获取锁，竞争不激烈</td>
<td>多线程激烈竞争</td>
</tr>
</tbody>
</table>
<p><strong>关键理解：</strong></p>
<ol>
<li>
<p><strong>偏向锁</strong>：最轻量，直接在 Mark Word 中记录偏向线程 ID，无任何额外数据结构。相当于&quot;这把锁归你了，以后你来就直接进&quot;。</p>
</li>
<li>
<p><strong>轻量级锁</strong>：Mark Word 指向持锁线程栈上的 Lock Record。Lock Record 只保存原始 Mark Word 的备份，<strong>不包含任何等待队列</strong>。竞争失败的线程只能 CAS 自旋重试，不会被阻塞。</p>
</li>
<li>
<p><strong>重量级锁</strong>：Mark Word 指向 ObjectMonitor，Monitor 是一个完整的同步结构，包含：</p>
<ul>
<li><code>_owner</code>：指向持锁线程</li>
<li><code>_EntryList</code>：阻塞等待获取锁的线程队列</li>
<li><code>_WaitSet</code>：调用 <code>wait()</code> 后等待被 <code>notify()</code> 的线程队列</li>
<li><code>_cxq</code>：竞争队列（新来的竞争者先进这里）</li>
<li>底层封装了 OS 的 Mutex 和 Condition Variable</li>
</ul>
</li>
</ol>
<p><strong>为什么轻量级锁不需要等待队列？</strong></p>
<p>因为轻量级锁的设计假设是&quot;竞争很少发生&quot;。在这种假设下，竞争失败的线程通过短暂的 CAS 自旋就能获取到锁，不需要排队等待。一旦自旋超过阈值（说明竞争激烈），就膨胀为重量级锁，此时才需要等待队列来管理大量等待的线程。</p>
<h3 id="锁升级全景图：从无锁到重量级锁的完整状态转换">锁升级全景图：从无锁到重量级锁的完整状态转换</h3>
<p>下图展示了 synchronized 锁的完整生命周期，包括所有可能的状态转换路径：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph 锁状态转换图
        direction TB
        
        START((&quot;对象创建&quot;)) --&gt; Unlocked
        
        subgraph Unlocked[&quot;无锁状态&quot;]
            U1[&quot;Mark Word: hashCode | age | 0 | 01&quot;]
            U2[&quot;无线程持有锁&quot;]
        end
        
        subgraph Biased[&quot;偏向锁状态&quot;]
            B1[&quot;Mark Word: threadId | epoch | age | 1 | 01&quot;]
            B2[&quot;偏向第一个获取锁的线程&quot;]
        end
        
        subgraph Lightweight[&quot;轻量级锁状态&quot;]
            L1[&quot;Mark Word: Lock Record 指针 | 00&quot;]
            L2[&quot;指向持锁线程栈上的 Lock Record&quot;]
        end
        
        subgraph Heavyweight[&quot;重量级锁状态&quot;]
            H1[&quot;Mark Word: ObjectMonitor 指针 | 10&quot;]
            H2[&quot;指向 C++ 堆上的 Monitor 对象&quot;]
        end
        
        Unlocked --&gt;|&quot;首次加锁&lt;br/&gt;(偏向锁启用时)&quot;| Biased
        Unlocked --&gt;|&quot;首次加锁&lt;br/&gt;(偏向锁禁用时)&quot;| Lightweight
        
        Biased --&gt;|&quot;同一线程重入&lt;br/&gt;(无需任何操作)&quot;| Biased
        Biased --&gt;|&quot;其他线程竞争&lt;br/&gt;(偏向锁撤销)&quot;| Lightweight
        Biased --&gt;|&quot;调用 hashCode()&lt;br/&gt;(偏向锁撤销)&quot;| Unlocked
        
        Lightweight --&gt;|&quot;同一线程重入&lt;br/&gt;(Lock Record 计数)&quot;| Lightweight
        Lightweight --&gt;|&quot;CAS 自旋失败&lt;br/&gt;(锁膨胀)&quot;| Heavyweight
        Lightweight --&gt;|&quot;解锁成功&lt;br/&gt;(CAS 恢复 Mark Word)&quot;| Unlocked
        
        Heavyweight --&gt;|&quot;线程竞争&lt;br/&gt;(进入 EntryList)&quot;| Heavyweight
        Heavyweight --&gt;|&quot;解锁&lt;br/&gt;(可能降级 JDK 15+)&quot;| Unlocked
    end
    
    style Unlocked fill:#e8f5e9
    style Biased fill:#fff3e0
    style Lightweight fill:#e3f2fd
    style Heavyweight fill:#ffebee</code></pre>
<p><strong>锁升级的触发条件与详细流程：</strong></p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;锁升级决策流程&quot;
        START[&quot;线程尝试获取锁&quot;]
        
        CHECK_BIAS&#123;&quot;偏向锁&lt;br/&gt;是否启用?&quot;&#125;
        
        subgraph &quot;偏向锁路径&quot;
            BIAS_CHECK&#123;&quot;Mark Word&lt;br/&gt;threadId == 当前线程?&quot;&#125;
            BIAS_CAS[&quot;CAS 写入 threadId&quot;]
            BIAS_SUCCESS[&quot;偏向锁获取成功&lt;br/&gt;━━━━━━━━━━━━━━&lt;br/&gt;后续重入零开销&quot;]
            BIAS_REVOKE[&quot;偏向锁撤销&lt;br/&gt;━━━━━━━━━━━━━━&lt;br/&gt;需要 STW 安全点&quot;]
        end
        
        subgraph &quot;轻量级锁路径&quot;
            LW_RECORD[&quot;创建 Lock Record&lt;br/&gt;复制 Mark Word&quot;]
            LW_CAS[&quot;CAS: Mark Word&lt;br/&gt;→ Lock Record 指针&quot;]
            LW_SUCCESS[&quot;轻量级锁获取成功&quot;]
            LW_SPIN[&quot;CAS 自旋重试&quot;]
            LW_SPIN_CHECK&#123;&quot;自旋次数&lt;br/&gt;超过阈值?&quot;&#125;
        end
        
        subgraph &quot;重量级锁路径&quot;
            HW_INFLATE[&quot;锁膨胀&lt;br/&gt;━━━━━━━━━━━━━━&lt;br/&gt;创建 ObjectMonitor&quot;]
            HW_ENTER[&quot;进入 Monitor&lt;br/&gt;━━━━━━━━━━━━━━&lt;br/&gt;可能阻塞&quot;]
            HW_SUCCESS[&quot;重量级锁获取成功&quot;]
        end
        
        START --&gt; CHECK_BIAS
        
        CHECK_BIAS --&gt;|&quot;是&quot;| BIAS_CHECK
        CHECK_BIAS --&gt;|&quot;否&quot;| LW_RECORD
        
        BIAS_CHECK --&gt;|&quot;是&quot;| BIAS_SUCCESS
        BIAS_CHECK --&gt;|&quot;否（其他线程）&quot;| BIAS_REVOKE
        BIAS_CHECK --&gt;|&quot;否（无偏向）&quot;| BIAS_CAS
        
        BIAS_CAS --&gt;|&quot;成功&quot;| BIAS_SUCCESS
        BIAS_CAS --&gt;|&quot;失败&quot;| BIAS_REVOKE
        
        BIAS_REVOKE --&gt; LW_RECORD
        
        LW_RECORD --&gt; LW_CAS
        LW_CAS --&gt;|&quot;成功&quot;| LW_SUCCESS
        LW_CAS --&gt;|&quot;失败&quot;| LW_SPIN
        
        LW_SPIN --&gt; LW_SPIN_CHECK
        LW_SPIN_CHECK --&gt;|&quot;否&quot;| LW_CAS
        LW_SPIN_CHECK --&gt;|&quot;是&quot;| HW_INFLATE
        
        HW_INFLATE --&gt; HW_ENTER
        HW_ENTER --&gt; HW_SUCCESS
    end
    
    style BIAS_SUCCESS fill:#c8e6c9
    style LW_SUCCESS fill:#c8e6c9
    style HW_SUCCESS fill:#c8e6c9
    style BIAS_REVOKE fill:#ffcdd2
    style HW_INFLATE fill:#ffcdd2</code></pre>
<p><strong>锁状态与 Mark Word 的对应关系：</strong></p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>Mark Word 布局（64位）</th>
<th>标志位</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无锁</strong></td>
<td><code>[unused:25][hashCode:31][unused:1][age:4][biased:1][lock:2]</code></td>
<td><code>0 01</code></td>
<td>存储对象 hashCode</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td><code>[threadId:54][epoch:2][unused:1][age:4][biased:1][lock:2]</code></td>
<td><code>1 01</code></td>
<td>存储偏向线程 ID</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td><code>[Lock Record 指针:62][lock:2]</code></td>
<td><code>00</code></td>
<td>指向栈上 Lock Record</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td><code>[ObjectMonitor 指针:62][lock:2]</code></td>
<td><code>10</code></td>
<td>指向堆上 Monitor</td>
</tr>
<tr>
<td><strong>GC 标记</strong></td>
<td><code>[转发指针或其他 GC 信息:62][lock:2]</code></td>
<td><code>11</code></td>
<td>GC 期间使用</td>
</tr>
</tbody>
</table>
<p><strong>锁升级的不可逆性与例外：</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;传统模型（JDK 14 及之前）&quot;
        A1[无锁] --&gt; B1[偏向锁]
        B1 --&gt; C1[轻量级锁]
        C1 --&gt; D1[重量级锁]
        D1 -.-&gt;|&quot;不可降级&quot;| D1
    end
    
    subgraph &quot;现代模型（JDK 15+）&quot;
        A2[无锁] --&gt; C2[轻量级锁]
        C2 --&gt; D2[重量级锁]
        D2 -.-&gt;|&quot;可降级&quot;| C2
        
        note1[&quot;偏向锁默认禁用&lt;br/&gt;-XX:+UseBiasedLocking 可启用&quot;]
        note2[&quot;重量级锁可降级&lt;br/&gt;当竞争消失时&quot;]
    end
    
    style D1 fill:#ffcdd2
    style D2 fill:#fff9c4</code></pre>
<p><strong>各锁状态的性能特征对比：</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>偏向锁</th>
<th>轻量级锁</th>
<th>重量级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>获取开销</strong></td>
<td>几乎为零（仅比较 threadId）</td>
<td>一次 CAS 操作</td>
<td>可能涉及系统调用</td>
</tr>
<tr>
<td><strong>释放开销</strong></td>
<td>无（不修改 Mark Word）</td>
<td>一次 CAS 操作</td>
<td>Monitor 操作</td>
</tr>
<tr>
<td><strong>竞争处理</strong></td>
<td>撤销偏向（需 STW）</td>
<td>CAS 自旋</td>
<td>阻塞等待</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>单线程反复获取同一锁</td>
<td>多线程交替获取，竞争不激烈</td>
<td>多线程激烈竞争</td>
</tr>
<tr>
<td><strong>JDK 15+ 默认</strong></td>
<td>禁用</td>
<td>启用</td>
<td>启用</td>
</tr>
</tbody>
</table>
<p><strong>为什么 JDK 15 默认禁用偏向锁？</strong></p>
<ol>
<li><strong>撤销成本高</strong>：偏向锁撤销需要在安全点（STW）进行，影响应用延迟</li>
<li><strong>现代应用特征变化</strong>：容器化、微服务架构下，单线程反复获取同一锁的场景减少</li>
<li><strong>轻量级锁足够高效</strong>：现代 CPU 的 CAS 操作已经非常快</li>
<li><strong>简化 JVM 实现</strong>：移除偏向锁可以简化锁的实现和调试</li>
</ol>
<h2 id="锁消除-lock-elimination">锁消除（Lock Elimination）</h2>
<h3 id="什么是锁消除？">什么是锁消除？</h3>
<p>锁消除是 JIT 编译器的一项优化技术：如果 JVM 通过**逃逸分析（Escape Analysis）**发现某个锁对象不可能被其他线程访问，那么这个锁就是&quot;多余的&quot;，可以被安全地消除。</p>
<p><strong>逃逸分析的核心问题：对象会不会&quot;逃逸&quot;出当前作用域？</strong></p>
<table>
<thead>
<tr>
<th>逃逸类型</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>不逃逸</strong></td>
<td>对象只在方法内部使用，不会被外部引用</td>
<td>方法内的局部变量</td>
</tr>
<tr>
<td><strong>方法逃逸</strong></td>
<td>对象被作为参数传递或作为返回值</td>
<td><code>return new Object()</code></td>
</tr>
<tr>
<td><strong>线程逃逸</strong></td>
<td>对象可能被其他线程访问</td>
<td>赋值给静态变量、实例变量</td>
</tr>
</tbody>
</table>
<p><strong>只有&quot;不逃逸&quot;的对象上的锁才能被消除。</strong></p>
<h3 id="锁消除的工作原理">锁消除的工作原理</h3>
<p><strong>图1：锁消除的决策流程</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;JIT 编译时的逃逸分析&quot;
        CODE[&quot;synchronized (lockObj) &#123;&lt;br/&gt;    // 临界区代码&lt;br/&gt;&#125;&quot;]
        
        ANALYZE[&quot;逃逸分析&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;分析 lockObj 的引用链&lt;br/&gt;判断是否可能被其他线程访问&quot;]
        
        ESCAPE&#123;&quot;lockObj 是否逃逸?&quot;&#125;
        
        ELIMINATE[&quot;锁消除&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;移除 monitorenter/monitorexit&lt;br/&gt;直接执行临界区代码&quot;]
        
        KEEP[&quot;保留锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;正常执行同步逻辑&quot;]
        
        CODE --&gt; ANALYZE
        ANALYZE --&gt; ESCAPE
        ESCAPE --&gt;|&quot;不逃逸&quot;| ELIMINATE
        ESCAPE --&gt;|&quot;可能逃逸&quot;| KEEP
        
        style ELIMINATE fill:#c8e6c9
        style KEEP fill:#fff9c4
    end</code></pre>
<h3 id="锁消除的典型场景">锁消除的典型场景</h3>
<p><strong>场景1：StringBuffer/StringBuilder 的同步</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-comment">// StringBuffer 是线程安全的，内部方法都有 synchronized</span><br>    <span class="hljs-type">StringBuffer</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuffer</span>();<br>    sb.append(s1);  <span class="hljs-comment">// synchronized</span><br>    sb.append(s2);  <span class="hljs-comment">// synchronized</span><br>    sb.append(s3);  <span class="hljs-comment">// synchronized</span><br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，<code>StringBuffer sb</code> 是一个局部变量，不会逃逸出 <code>concatString</code> 方法，更不可能被其他线程访问。因此，JIT 编译器可以安全地消除 <code>append()</code> 方法内部的同步操作。</p>
<p><strong>优化后的等效代码：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">concatString</span><span class="hljs-params">(String s1, String s2, String s3)</span> &#123;<br>    <span class="hljs-comment">// 锁被消除，等效于使用 StringBuilder</span><br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    sb.append(s1);<br>    sb.append(s2);<br>    sb.append(s3);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>场景2：方法内部的同步块</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomething</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <span class="hljs-comment">// 局部变量，不逃逸</span><br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        <span class="hljs-comment">// 临界区代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>由于 <code>lock</code> 对象是方法内部创建的局部变量，每次方法调用都会创建新的对象，不可能被其他线程访问，因此这个同步块可以被完全消除。</p>
<h3 id="reentrantlock-能被消除吗？">ReentrantLock 能被消除吗？</h3>
<p>根据 <a target="_blank" rel="noopener" href="http://www.cs.cmu.edu/~aldrich/papers/scp-camera.pdf">CMU 的研究论文</a>，<strong>ReentrantLock 也可以被锁消除优化</strong>。JIT 编译器的逃逸分析不仅适用于 <code>synchronized</code>，也适用于 <code>java.util.concurrent</code> 包中的锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWithLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <span class="hljs-comment">// 局部变量</span><br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 临界区代码</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果 <code>lock</code> 对象不逃逸，JIT 编译器可以消除 <code>lock()</code> 和 <code>unlock()</code> 的调用。</p>
<p><strong>但需要注意：</strong></p>
<table>
<thead>
<tr>
<th>锁类型</th>
<th>消除难度</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>synchronized</strong></td>
<td>较容易</td>
<td>JVM 内置支持，字节码层面可识别</td>
</tr>
<tr>
<td><strong>ReentrantLock</strong></td>
<td>较难</td>
<td>需要识别 <code>lock()</code>/<code>unlock()</code> 的调用模式</td>
</tr>
<tr>
<td><strong>分布式锁</strong></td>
<td>不可能</td>
<td>涉及外部系统，无法通过逃逸分析判断</td>
</tr>
</tbody>
</table>
<h3 id="如何验证锁消除是否生效？">如何验证锁消除是否生效？</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启逃逸分析（JDK 6u23+ 默认开启）</span><br>-XX:+DoEscapeAnalysis<br><br><span class="hljs-comment"># 开启锁消除（默认开启）</span><br>-XX:+EliminateLocks<br><br><span class="hljs-comment"># 打印逃逸分析结果</span><br>-XX:+PrintEscapeAnalysis<br><br><span class="hljs-comment"># 打印锁消除信息</span><br>-XX:+PrintEliminateLocks<br></code></pre></td></tr></table></figure>
<h2 id="锁粗化-lock-coarsening">锁粗化（Lock Coarsening）</h2>
<h3 id="什么是锁粗化？">什么是锁粗化？</h3>
<p>锁粗化是 JIT 编译器的另一项优化技术：如果 JVM 检测到<strong>一系列连续的加锁/解锁操作都是针对同一个锁对象</strong>，那么可以将这些操作合并为一次更大范围的加锁/解锁，从而减少锁操作的开销。</p>
<p><strong>图1：锁粗化的优化过程</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;优化前：频繁加锁/解锁&quot;
        BEFORE[&quot;synchronized (lock) &#123; op1(); &#125;&lt;br/&gt;synchronized (lock) &#123; op2(); &#125;&lt;br/&gt;synchronized (lock) &#123; op3(); &#125;&quot;]
        
        COST1[&quot;开销分析&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 3 次 monitorenter&lt;br/&gt;• 3 次 monitorexit&lt;br/&gt;• 3 次 CAS 操作&lt;br/&gt;• 可能的锁膨胀&quot;]
        
        BEFORE --&gt; COST1
        style COST1 fill:#ffcdd2
    end
    
    subgraph &quot;优化后：一次大锁&quot;
        AFTER[&quot;synchronized (lock) &#123;&lt;br/&gt;    op1();&lt;br/&gt;    op2();&lt;br/&gt;    op3();&lt;br/&gt;&#125;&quot;]
        
        COST2[&quot;开销分析&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 1 次 monitorenter&lt;br/&gt;• 1 次 monitorexit&lt;br/&gt;• 1 次 CAS 操作&lt;br/&gt;• 锁持有时间略长&quot;]
        
        AFTER --&gt; COST2
        style COST2 fill:#c8e6c9
    end
    
    BEFORE --&gt;|&quot;JIT 锁粗化&quot;| AFTER</code></pre>
<h3 id="锁粗化的典型场景">锁粗化的典型场景</h3>
<p><strong>场景1：循环内的同步</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 优化前：每次循环都加锁/解锁</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>        list.add(i);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 优化后：整个循环只加锁一次</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>        list.add(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>场景2：连续的同步方法调用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 优化前：每个方法调用都有独立的同步</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>    sb.append(<span class="hljs-string">&quot;Hello&quot;</span>);   <span class="hljs-comment">// synchronized</span><br>    sb.append(<span class="hljs-string">&quot; &quot;</span>);       <span class="hljs-comment">// synchronized</span><br>    sb.append(<span class="hljs-string">&quot;World&quot;</span>);   <span class="hljs-comment">// synchronized</span><br>    sb.append(<span class="hljs-string">&quot;!&quot;</span>);       <span class="hljs-comment">// synchronized</span><br>&#125;<br><br><span class="hljs-comment">// 优化后：合并为一次同步</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">synchronized</span> (sb) &#123;<br>        sb.append(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        sb.append(<span class="hljs-string">&quot; &quot;</span>);<br>        sb.append(<span class="hljs-string">&quot;World&quot;</span>);<br>        sb.append(<span class="hljs-string">&quot;!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="锁粗化的权衡">锁粗化的权衡</h3>
<p><strong>图2：锁粗化的利弊分析</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;锁粗化的收益&quot;
        BENEFIT1[&quot;减少锁操作次数&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;N 次加锁/解锁 → 1 次&lt;br/&gt;减少 CAS 开销&quot;]
        BENEFIT2[&quot;减少锁状态转换&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;避免频繁的偏向锁撤销&lt;br/&gt;避免轻量级锁膨胀&quot;]
        BENEFIT3[&quot;提高缓存命中率&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;减少 Mark Word 的修改&lt;br/&gt;减少缓存行失效&quot;]
        
        style BENEFIT1 fill:#c8e6c9
        style BENEFIT2 fill:#c8e6c9
        style BENEFIT3 fill:#c8e6c9
    end
    
    subgraph &quot;锁粗化的代价&quot;
        COST1[&quot;锁持有时间变长&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;其他线程等待时间增加&lt;br/&gt;可能降低并发度&quot;]
        COST2[&quot;临界区变大&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;包含了原本不需要同步的代码&lt;br/&gt;可能引入不必要的串行化&quot;]
        
        style COST1 fill:#ffcdd2
        style COST2 fill:#ffcdd2
    end</code></pre>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否适合锁粗化</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>连续的短临界区</strong></td>
<td>适合</td>
<td>锁操作开销 &gt; 临界区执行时间</td>
</tr>
<tr>
<td><strong>循环内的同步</strong></td>
<td>适合</td>
<td>避免大量重复的加锁/解锁</td>
</tr>
<tr>
<td><strong>包含 I/O 操作的临界区</strong></td>
<td>不适合</td>
<td>锁持有时间过长，严重影响并发</td>
</tr>
<tr>
<td><strong>高并发竞争场景</strong></td>
<td>不适合</td>
<td>锁粗化会加剧竞争</td>
</tr>
</tbody>
</table>
<h3 id="锁粗化-vs-锁细化">锁粗化 vs 锁细化</h3>
<p>锁粗化和锁细化（Lock Splitting/Striping）是两个相反的优化方向：</p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;锁粗化&quot;
        COARSE[&quot;多个小锁 → 一个大锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;减少锁操作开销&lt;br/&gt;适合低竞争场景&quot;]
        style COARSE fill:#e1f5ff
    end
    
    subgraph &quot;锁细化&quot;
        FINE[&quot;一个大锁 → 多个小锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;减少锁竞争&lt;br/&gt;适合高并发场景&quot;]
        style FINE fill:#fff9c4
    end
    
    COARSE &lt;--&gt;|&quot;相反的优化方向&quot;| FINE</code></pre>
<p><strong>JVM 自动进行锁粗化，但锁细化需要程序员手动设计。</strong> 典型的锁细化例子包括：</p>
<ul>
<li><code>ConcurrentHashMap</code> 的分段锁（JDK 7）/ CAS + synchronized（JDK 8+）</li>
<li><code>LongAdder</code> 的分散热点</li>
<li>读写锁分离（<code>ReentrantReadWriteLock</code>）</li>
</ul>
<h3 id="如何控制锁粗化？">如何控制锁粗化？</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启锁粗化（默认开启）</span><br>-XX:+EliminateNestedLocks<br><br><span class="hljs-comment"># 关闭锁粗化（用于调试）</span><br>-XX:-EliminateNestedLocks<br></code></pre></td></tr></table></figure>
<p><strong>最佳实践：</strong></p>
<ol>
<li><strong>信任 JVM 的优化</strong>：在大多数情况下，JVM 的锁粗化决策是合理的</li>
<li><strong>避免过度优化</strong>：不要为了&quot;帮助&quot; JVM 而手动粗化锁，这可能适得其反</li>
<li><strong>关注热点代码</strong>：只有被 JIT 编译的热点代码才会进行锁粗化优化</li>
<li><strong>监控锁竞争</strong>：使用 <code>jstack</code>、<code>async-profiler</code> 等工具监控锁竞争情况，判断是否需要手动调整锁粒度</li>
</ol>
<h2 id="锁状态升级-lock-state-escalation">锁状态升级（Lock State Escalation）</h2>
<p>本章节完整介绍 synchronized 锁的状态升级机制，包括：偏向锁、轻量级锁、重量级锁的实现原理，以及自旋与阻塞的等待机制优化。这是理解 JVM 锁优化的核心内容。</p>
<h3 id="概述：锁状态与等待机制">概述：锁状态与等待机制</h3>
<p>在深入讨论之前，我们需要先澄清两个常被混淆的概念：</p>
<p><strong>&quot;自旋锁&quot;这个术语在不同语境下有不同含义：</strong></p>
<ol>
<li>
<p><strong>狭义的自旋锁（Spinlock）</strong>：一种独立的锁实现，如 Linux 内核中的 <code>spinlock_t</code>，它完全基于自旋实现，不涉及线程阻塞。这种锁通常用于内核态或中断上下文中，因为这些场景不能进行线程调度。</p>
</li>
<li>
<p><strong>锁的自旋优化（Spin Optimization）</strong>：在传统阻塞锁的基础上，增加一个自旋阶段。线程获取锁失败后，先自旋一段时间，如果还获取不到再阻塞。这是 JVM 中 synchronized 和 ReentrantLock 采用的策略。</p>
</li>
</ol>
<p><strong>本文讨论的是第二种含义——锁的自旋优化。</strong></p>
<p><strong>关键理解：自旋是等待机制的优化，不是锁实现的优化</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;锁的分类维度&quot;
        direction TB
        
        subgraph &quot;按锁实现分类&quot;
            IMPL[&quot;锁实现&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;偏向锁 / 轻量级锁 / 重量级锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;决定：如何记录锁的持有者&lt;br/&gt;如何管理锁的状态&quot;]
            style IMPL fill:#e1f5ff
        end
        
        subgraph &quot;按等待机制分类&quot;
            WAIT[&quot;等待机制&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;自旋等待 / 阻塞等待&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;决定：获取锁失败后&lt;br/&gt;线程如何等待&quot;]
            style WAIT fill:#fff9c4
        end
    end
    
    note1[&quot;这两个维度是正交的！&lt;br/&gt;偏向锁/轻量级锁/重量级锁 描述的是「锁的实现」&lt;br/&gt;自旋/阻塞 描述的是「等待机制」&lt;br/&gt;不要混为一谈&quot;]
    style note1 fill:#ffcdd2</code></pre>
<p><strong>英文文献中的术语：</strong></p>
<p>在学术文献和专业书籍中，这两个概念有明确的区分：</p>
<table>
<thead>
<tr>
<th>英文术语</th>
<th>中文</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Lock Implementation</strong></td>
<td>锁实现</td>
<td>偏向锁、轻量级锁、重量级锁属于这个范畴</td>
</tr>
<tr>
<td><strong>Spinning / Spin-waiting</strong></td>
<td>自旋等待</td>
<td>获取锁失败后，线程忙循环等待</td>
</tr>
<tr>
<td><strong>Blocking / Block-waiting</strong></td>
<td>阻塞等待</td>
<td>获取锁失败后，线程被挂起</td>
</tr>
<tr>
<td><strong>Spin-then-block</strong></td>
<td>先自旋后阻塞</td>
<td>JVM 采用的混合策略</td>
</tr>
</tbody>
</table>
<p>《The Art of Multiprocessor Programming》（多处理器编程的艺术）一书中明确指出：</p>
<blockquote>
<p>“Spinning is a technique where a thread repeatedly checks a condition instead of blocking. It is orthogonal to the lock implementation itself.”</p>
<p>（自旋是一种线程反复检查条件而不是阻塞的技术。它与锁的实现本身是正交的。）</p>
</blockquote>
<p><strong>为什么这个区分很重要？</strong></p>
<p>因为：</p>
<ul>
<li><strong>偏向锁、轻量级锁、重量级锁</strong>回答的是&quot;锁的状态如何记录、锁的持有者如何追踪&quot;</li>
<li><strong>自旋、阻塞</strong>回答的是&quot;获取锁失败后，线程如何等待&quot;</li>
</ul>
<p>这两个问题是独立的。例如：</p>
<ul>
<li>轻量级锁获取失败后，可以选择自旋等待，也可以直接膨胀为重量级锁然后阻塞</li>
<li>重量级锁获取失败后，JVM 也会先自旋一段时间，再进入阻塞</li>
</ul>
<p><strong>锁状态升级的完整路径：</strong></p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">无锁 → 偏向锁 → 轻量级锁 → 重量级锁<br></code></pre></td></tr></table></figure>
<p>接下来，我们将按照这个升级路径，逐一介绍每种锁状态的实现原理。</p>
<h3 id="偏向锁-biased-lock">偏向锁（Biased Lock）</h3>
<p>偏向锁是 JDK 1.6 中引入的一项锁优化。它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。如果说轻量级锁在无竞争的情况下使用 CAS 操作去消除同步使用的互斥量，偏向锁就是在无竞争的情况下，把整个同步过程都消除掉，连 CAS 都不做了。</p>
<h4 id="偏向锁的本质：一个-写在-mark-word-里的-volatile-threadid">偏向锁的本质：一个&quot;写在 Mark Word 里的 volatile threadId&quot;</h4>
<p>理解偏向锁最直观的方式是将它类比为一个 <strong>volatile 全局变量</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 偏向锁的概念模型（伪代码）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BiasedLockSimulation</span> &#123;<br>    <span class="hljs-comment">// 这个 volatile 变量就像 Mark Word 中的 threadId 字段</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> <span class="hljs-variable">biasedThreadId</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">currentThreadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-keyword">if</span> (biasedThreadId == currentThreadId) &#123;<br>            <span class="hljs-comment">// 已偏向当前线程，直接进入临界区</span><br>            <span class="hljs-comment">// 这就是偏向锁&quot;零开销&quot;的来源</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (biasedThreadId == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 首次加锁，CAS 设置偏向线程</span><br>            <span class="hljs-keyword">if</span> (CAS(biasedThreadId, <span class="hljs-number">0</span>, currentThreadId)) &#123;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 偏向成功</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 偏向失败，升级到轻量级锁...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>偏向锁与 volatile 变量的相似性：</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>volatile threadId 变量</th>
<th>偏向锁的 Mark Word</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>存储位置</strong></td>
<td>堆中的对象字段</td>
<td>对象头的 Mark Word</td>
</tr>
<tr>
<td><strong>可见性保证</strong></td>
<td>volatile 语义</td>
<td>Mark Word 的原子读写</td>
</tr>
<tr>
<td><strong>写入方式</strong></td>
<td>直接赋值</td>
<td>CAS（仅首次）</td>
</tr>
<tr>
<td><strong>读取开销</strong></td>
<td>一次内存读取</td>
<td>一次内存读取 + 比较</td>
</tr>
<tr>
<td><strong>空间占用</strong></td>
<td>8 字节（long）</td>
<td>复用 Mark Word 的 54 位</td>
</tr>
</tbody>
</table>
<p><strong>关键区别：偏向锁复用了 Mark Word 的空间</strong></p>
<p>偏向锁的精妙之处在于：它没有额外分配一个字段来存储 threadId，而是<strong>复用了 Mark Word 中原本存储 hashCode 的空间</strong>。这就是为什么偏向锁与 hashCode 互斥——它们在 Mark Word 中占用相同的位。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">无锁状态的 Mark Word（64位）：<br>|<span class="hljs-string"> unused:25 </span>|<span class="hljs-string"> hashcode:31 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:0 </span>|<span class="hljs-string"> 01 </span>|<br><br>偏向锁状态的 Mark Word（64位）：<br>|<span class="hljs-string"> thread:54 </span>|<span class="hljs-string"> epoch:2 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1 </span>|<span class="hljs-string"> 01 </span>|<br></code></pre></td></tr></table></figure>
<p>这种设计的权衡是：</p>
<ul>
<li><strong>优点</strong>：零额外空间开销，偏向锁检查只需读取 Mark Word 并比较 threadId</li>
<li><strong>缺点</strong>：hashCode 和 threadId 互斥，调用 <code>hashCode()</code> 会导致偏向锁失效</li>
</ul>
<p><strong>age 与 epoch 的本质区别</strong></p>
<p>观察上述 Mark Word 结构，可以发现两个容易混淆的字段：<code>age</code>（4 bits）和 <code>epoch</code>（2 bits）。它们虽然都存储在 Mark Word 中，但属于完全不同的子系统，服务于不同的目的：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>位数</th>
<th>所属子系统</th>
<th>作用</th>
<th>变化时机</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>age</strong></td>
<td>4 bits</td>
<td>GC 子系统</td>
<td>记录对象的分代年龄</td>
<td>每次 Minor GC 存活后 +1，达到阈值（默认 15）后晋升到老年代</td>
</tr>
<tr>
<td><strong>epoch</strong></td>
<td>2 bits</td>
<td>锁子系统</td>
<td>偏向锁的&quot;批次戳&quot;，用于批量重偏向</td>
<td>当某个类的偏向锁撤销次数超过阈值时，该类的 epoch +1</td>
</tr>
</tbody>
</table>
<p><strong>age 的语义</strong>：这是 GC 的概念。新生代对象每经历一次 Minor GC 且存活，age 就加 1。当 age 达到 <code>-XX:MaxTenuringThreshold</code>（默认 15，正好是 4 bits 能表示的最大值）时，对象会被晋升到老年代。age 与锁机制无关，它在所有锁状态下都保持不变（除非被 GC 更新）。</p>
<p><strong>epoch 的语义</strong>：这是偏向锁特有的概念。每个类（Klass）维护一个 epoch 值，每个偏向锁对象的 Mark Word 中也存储一个 epoch 值。当 JVM 检测到某个类的偏向锁被频繁撤销（超过 <code>BiasedLockingBulkRebiasThreshold</code>，默认 20 次），会触发<strong>批量重偏向（Bulk Rebias）</strong>：类的 epoch 值加 1，使得所有该类对象的旧偏向锁&quot;过期&quot;。后续线程获取这些对象的锁时，发现对象的 epoch 与类的 epoch 不匹配，可以直接重偏向到当前线程，而无需执行昂贵的偏向锁撤销操作。</p>
<p>简言之：<strong>age 是对象在 GC 中的&quot;年龄&quot;，epoch 是偏向锁的&quot;版本号&quot;</strong>。两者在 Mark Word 中共存，但互不干扰。</p>
<p>偏向锁的偏，是偏心的。这个锁会偏向于第一个获得它的线程，如果接下来的执行过程中，该锁没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步。从这点来看，<strong>偏向锁导致同步消除了，等同于锁消除了。但锁消除并不等同于偏向锁，可能有 JIT 自己去掉同步代码的优化</strong>。</p>
<p>当对象在第一次被线程锁定的时候，虚拟机会把标志位设置为&quot;01&quot;（<strong>至此标志位已经被用尽了</strong>）。同时使用 CAS 模式（<strong>因为此时还不能保证没有竞争</strong>）试图把线程 ID 写入 Mark Word 中（<strong>此处就真的写入线程号了</strong>）。如果 CAS 成功，那么以后再进入同步块，都不需要执行任何同步操作。</p>
<p>如果这个时候发生锁竞争，则会发生撤销偏向（Revoke Bias），对象会短暂回到未锁定状态，然后进入轻量级锁的竞争阶段。注意：偏向锁撤销后是先升级到轻量级锁，而不是直接膨胀为重量级锁。只有在轻量级锁竞争失败（CAS 自旋超过阈值）时，才会进一步膨胀为重量级锁。偏向锁是默认打开的，很多推荐的 JVM 配置都关掉它，因为多线程竞争很激烈的情况下，偏向锁的假定往往会失效（轻量级锁实际上也会失效）。所以可以用 <code>-XX:-UseBiasedLocking</code> 来关闭偏向锁。</p>
<h4 id="hashcode-与偏向锁的互斥">hashCode 与偏向锁的互斥</h4>
<p>偏向锁有一个容易被忽略但非常重要的限制：<strong>偏向锁与 identity hashCode 是互斥的</strong>。</p>
<p>观察 64 位 JVM 下偏向锁的 Mark Word 结构：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> thread:54 </span>|<span class="hljs-string"> epoch:2 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:1 </span>|<span class="hljs-string"> 01 </span>|<br></code></pre></td></tr></table></figure>
<p>可以发现：偏向锁的 Mark Word 中没有 hashCode 的存储位置。54 位被线程 ID 占用，剩余的位用于 epoch、age 和标志位。而无锁状态下的 Mark Word 结构是：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string"> unused:25 </span>|<span class="hljs-string"> hashcode:31 </span>|<span class="hljs-string"> unused:1 </span>|<span class="hljs-string"> age:4 </span>|<span class="hljs-string"> biased_lock:0 </span>|<span class="hljs-string"> 01 </span>|<br></code></pre></td></tr></table></figure>
<p>hashCode 占用了 31 位。由于 Mark Word 空间有限，threadId 和 hashCode 无法同时存储，这导致了以下行为：</p>
<ol>
<li><strong>对象从未调用过 <code>hashCode()</code></strong>：可以正常进入偏向锁状态，Mark Word 存储线程 ID</li>
<li><strong>对象已经调用过 <code>hashCode()</code></strong>：hashCode 已经占用了 Mark Word 的相应位，无法再存储 threadId，因此直接跳过偏向锁，进入轻量级锁</li>
<li><strong>对象已经处于偏向锁状态时调用 <code>hashCode()</code></strong>：偏向锁会被立即撤销。如果当前线程持有该偏向锁，则升级为轻量级锁（hashCode 存入 Lock Record 的 Displaced Mark Word）；如果存在其他线程竞争，则膨胀为重量级锁（hashCode 存入 ObjectMonitor 的 <code>_header</code> 字段）</li>
</ol>
<p>这里需要区分两种 hashCode：</p>
<ul>
<li><strong>identity hashCode</strong>：由 <code>Object.hashCode()</code> 或 <code>System.identityHashCode()</code> 返回，基于对象地址计算，需要存储在 Mark Word 中</li>
<li><strong>重写的 hashCode</strong>：如 <code>String.hashCode()</code>，基于对象内容计算，不需要存储在 Mark Word 中，不影响偏向锁</li>
</ul>
<p><strong>实践建议：</strong> 如果一个对象主要用作锁，应避免对其调用 <code>hashCode()</code> 或将其放入 <code>HashMap</code>/<code>HashSet</code>，否则偏向锁优化将失效。</p>
<h3 id="轻量级锁-lightweight-lock">轻量级锁（Lightweight Lock）</h3>
<p>轻量级锁本身是 JDK 1.6 以后才加入的新型锁机制，它名字中的&quot;轻量级&quot;是相对于使用操作系统互斥量来实现的传统锁而言的（<strong>Mutex 等于重量锁，在不同的场景下又称 Mutex Lock、fat lock。可以认为 OS 的系统调用提供了并发机制-线程，就会必然提供互斥量机制。</strong>）。它不是用来代替重量级锁的，用意是在多线程竞争不激烈的情况下，减少重量级锁的使用，来减少性能消耗。</p>
<h4 id="轻量级锁-vs-重量级锁：到底-轻-在哪里？">轻量级锁 vs 重量级锁：到底&quot;轻&quot;在哪里？</h4>
<p>要理解轻量级锁为什么&quot;轻&quot;，首先需要理解重量级锁为什么&quot;重&quot;。</p>
<p><strong>重量级锁的实现机制：</strong></p>
<p>当 synchronized 升级为重量级锁时，JVM 会为锁对象关联一个 <strong>ObjectMonitor</strong> 对象（也称为 Monitor 或管程）。这个 Monitor 对象是 HotSpot 在 C++ 层面实现的，它内部封装了操作系统的 <strong>Mutex（互斥量）</strong> 和 <strong>Condition Variable（条件变量）</strong>。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;重量级锁的完整结构&quot;
        direction TB
        
        subgraph &quot;堆（Heap）&quot;
            OBJ[&quot;锁对象&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word: ptr_to_monitor | 10&lt;br/&gt;Klass Pointer&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Instance Data&quot;]
            style OBJ fill:#e1f5ff
        end
        
        subgraph &quot;C++ 堆 / Native Memory&quot;
            MONITOR[&quot;ObjectMonitor（C++ 对象）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;_header: 原始 Mark Word 备份&lt;br/&gt;_owner: 持锁线程指针&lt;br/&gt;_recursions: 重入计数&lt;br/&gt;_EntryList: 阻塞等待队列&lt;br/&gt;_WaitSet: wait() 等待队列&lt;br/&gt;_cxq: 竞争队列&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;底层同步原语 ⬇️&quot;]
            
            MUTEX[&quot;pthread_mutex_t&lt;br/&gt;（OS 互斥量）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;需要系统调用&lt;br/&gt;futex / mutex_lock&quot;]
            
            COND[&quot;pthread_cond_t&lt;br/&gt;（条件变量）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;用于 wait/notify&quot;]
            
            MONITOR --&gt; MUTEX
            MONITOR --&gt; COND
            
            style MONITOR fill:#ffcdd2
            style MUTEX fill:#ffcdd2
            style COND fill:#ffcdd2
        end
        
        subgraph &quot;操作系统内核&quot;
            KERNEL[&quot;内核态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;线程调度&lt;br/&gt;上下文切换&lt;br/&gt;futex 系统调用&quot;]
            style KERNEL fill:#ffcdd2
        end
        
        OBJ --&gt;|&quot;Mark Word 指向&quot;| MONITOR
        MUTEX --&gt;|&quot;系统调用&quot;| KERNEL
    end
    
    note1[&quot;重量级锁的开销：&lt;br/&gt;1. 需要分配 ObjectMonitor 对象&lt;br/&gt;2. 竞争失败时线程被阻塞（park）&lt;br/&gt;3. 阻塞/唤醒需要系统调用&lt;br/&gt;4. 用户态 ↔ 内核态切换开销大&lt;br/&gt;5. 线程上下文切换成本高&quot;]
    style note1 fill:#ffcdd2</code></pre>
<p><strong>轻量级锁的实现机制：</strong></p>
<p>轻量级锁完全不使用 ObjectMonitor，而是利用线程栈帧中的 <strong>Lock Record</strong> 和 <strong>CAS 操作</strong> 来实现同步。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;轻量级锁的完整结构&quot;
        direction TB
        
        subgraph &quot;线程栈（用户态内存）&quot;
            LR[&quot;Lock Record&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word&lt;br/&gt;owner → 锁对象&quot;]
            style LR fill:#c8e6c9
        end
        
        subgraph &quot;堆（Heap）&quot;
            OBJ2[&quot;锁对象&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word: ptr_to_LR | 00&lt;br/&gt;Klass Pointer&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Instance Data&quot;]
            style OBJ2 fill:#e1f5ff
        end
        
        subgraph &quot;CPU 指令&quot;
            CAS[&quot;CAS 指令&lt;br/&gt;（cmpxchg）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;原子操作&lt;br/&gt;无需系统调用&lt;br/&gt;纯用户态执行&quot;]
            style CAS fill:#c8e6c9
        end
        
        LR &lt;--&gt;|&quot;互相指向&quot;| OBJ2
        LR --&gt;|&quot;加锁/解锁&quot;| CAS
    end
    
    note2[&quot;轻量级锁的优势：&lt;br/&gt;1. Lock Record 在栈上，无需额外分配&lt;br/&gt;2. 只用 CAS 操作，无系统调用&lt;br/&gt;3. 始终在用户态执行&lt;br/&gt;4. 无线程阻塞，无上下文切换&lt;br/&gt;5. CPU 缓存友好&quot;]
    style note2 fill:#c8e6c9</code></pre>
<p><strong>核心对比：轻量级锁的&quot;轻&quot;体现在哪里</strong></p>
<table>
<thead>
<tr>
<th>对比维度</th>
<th>轻量级锁</th>
<th>重量级锁</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>锁状态存储</strong></td>
<td>栈上的 Lock Record（自动管理）</td>
<td>堆外的 ObjectMonitor（需要分配/回收）</td>
</tr>
<tr>
<td><strong>加锁操作</strong></td>
<td>一次 CAS 指令（~10-20 CPU cycles）</td>
<td>可能涉及系统调用（~1000+ CPU cycles）</td>
</tr>
<tr>
<td><strong>竞争失败时</strong></td>
<td>自旋重试（仍在用户态）</td>
<td>线程阻塞（park，进入内核态）</td>
</tr>
<tr>
<td><strong>解锁操作</strong></td>
<td>一次 CAS 指令</td>
<td>可能需要唤醒等待线程（unpark）</td>
</tr>
<tr>
<td><strong>内存开销</strong></td>
<td>无额外开销（Lock Record 随栈帧销毁）</td>
<td>ObjectMonitor 对象（约 200+ bytes）</td>
</tr>
<tr>
<td><strong>上下文切换</strong></td>
<td>无</td>
<td>有（阻塞/唤醒时）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>无竞争或轻度竞争</td>
<td>高竞争场景</td>
</tr>
</tbody>
</table>
<p><strong>使用 Lock Record 而非 Monitor 的原因</strong></p>
<ol>
<li><strong>避免内存分配</strong>：Lock Record 在线程栈帧中，随方法调用自动创建和销毁，无需 GC 管理</li>
<li><strong>避免系统调用</strong>：CAS 是 CPU 指令，不需要进入内核态</li>
<li><strong>避免线程阻塞</strong>：轻量级锁失败时可以自旋重试，不会立即阻塞线程</li>
<li><strong>缓存友好</strong>：栈内存通常在 CPU 缓存中，访问速度快</li>
</ol>
<h3 id="lock-record-不是锁本身-mark-word-才是">Lock Record 不是锁本身，Mark Word 才是</h3>
<p>这里有一个容易混淆的概念需要澄清：<strong>Lock Record 本身并不是锁，它只是锁状态的&quot;证据&quot;</strong>。</p>
<p>很多人会疑惑：Lock Record 存储在线程私有的栈帧中，其他线程根本访问不到，它怎么能起到锁的作用呢？这与 ObjectMonitor 不同——Monitor 在堆上（虽然是 C++ 堆），所有线程都可以访问它、竞争它。</p>
<p>实际上，<strong>真正的锁不是 Lock Record，而是锁对象的 Mark Word</strong>。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;锁的本质：Mark Word 是全局可见的&quot;
        direction TB
        
        subgraph &quot;线程 A 的栈（私有）&quot;
            LR_A[&quot;Lock Record A&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word&lt;br/&gt;owner → obj&quot;]
            style LR_A fill:#c8e6c9
        end
        
        subgraph &quot;线程 B 的栈（私有）&quot;
            LR_B[&quot;Lock Record B&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word&lt;br/&gt;owner → obj&quot;]
            style LR_B fill:#fff9c4
        end
        
        subgraph &quot;堆（全局共享）&quot;
            OBJ[&quot;锁对象 obj&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word: ptr_to_LR_A | 00&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;所有线程都能读取这个 Mark Word！&quot;]
            style OBJ fill:#e1f5ff
        end
        
        LR_A --&gt;|&quot;owner 指向&quot;| OBJ
        LR_B --&gt;|&quot;owner 指向&quot;| OBJ
        OBJ --&gt;|&quot;Mark Word 指向&lt;br/&gt;（这就是锁的证明）&quot;| LR_A
    end
    
    note1[&quot;关键理解：&lt;br/&gt;1. Lock Record 是私有的，但 Mark Word 是共享的&lt;br/&gt;2. 线程通过 CAS 竞争的是 Mark Word，不是 Lock Record&lt;br/&gt;3. Mark Word 指向谁的 Lock Record，谁就持有锁&lt;br/&gt;4. 其他线程通过读取 Mark Word 就能知道锁被谁持有&quot;]
    style note1 fill:#fff9c4</code></pre>
<p><strong>轻量级锁的工作原理可以这样理解：</strong></p>
<ol>
<li><strong>锁对象的 Mark Word 是全局共享的</strong>：所有线程都可以读取堆上对象的 Mark Word</li>
<li><strong>CAS 竞争的是 Mark Word</strong>：线程通过 CAS 尝试将 Mark Word 从&quot;无锁状态&quot;修改为&quot;指向自己 Lock Record 的指针&quot;</li>
<li><strong>Mark Word 指向谁，谁就是锁的持有者</strong>：其他线程读取 Mark Word，发现它指向某个 Lock Record，就知道锁已被占用</li>
<li><strong>Lock Record 只是&quot;持锁证明&quot;的存储位置</strong>：它保存了原始 Mark Word 的备份，用于解锁时恢复</li>
</ol>
<p><strong>类比理解：</strong></p>
<p>可以把这个机制类比为&quot;停车位&quot;：</p>
<table>
<thead>
<tr>
<th>概念</th>
<th>类比</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>锁对象的 Mark Word</strong></td>
<td>停车位上的&quot;占用标识牌&quot;</td>
</tr>
<tr>
<td><strong>Lock Record</strong></td>
<td>车主的&quot;停车凭证&quot;（存在车主口袋里）</td>
</tr>
<tr>
<td><strong>CAS 操作</strong></td>
<td>原子地在标识牌上写下自己的车牌号</td>
</tr>
<tr>
<td><strong>竞争失败</strong></td>
<td>发现标识牌上已经有别人的车牌号</td>
</tr>
</tbody>
</table>
<p>停车凭证（Lock Record）确实是私有的，但停车位的标识牌（Mark Word）是所有人都能看到的。其他车主通过看标识牌就知道这个位置被谁占了，而不需要去翻别人的口袋。</p>
<p><strong>Lock Record vs ObjectMonitor 的本质区别：</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Lock Record（轻量级锁）</th>
<th>ObjectMonitor（重量级锁）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>锁状态存储</strong></td>
<td>Mark Word 存储指向 Lock Record 的指针</td>
<td>Mark Word 存储指向 Monitor 的指针</td>
</tr>
<tr>
<td><strong>竞争机制</strong></td>
<td>CAS 自旋（用户态）</td>
<td>Mutex 阻塞（内核态）</td>
</tr>
<tr>
<td><strong>等待队列</strong></td>
<td>无（自旋重试）</td>
<td>有（_EntryList、_WaitSet）</td>
</tr>
<tr>
<td><strong>线程阻塞</strong></td>
<td>不阻塞（自旋消耗 CPU）</td>
<td>阻塞（释放 CPU）</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>竞争少、持锁时间短</td>
<td>竞争多、持锁时间长</td>
</tr>
</tbody>
</table>
<p><strong>轻量级锁不需要全局可见 Monitor 的原因</strong></p>
<p>因为轻量级锁的设计假设是：<strong>锁竞争很少发生</strong>。在这种假设下：</p>
<ol>
<li><strong>不需要等待队列</strong>：竞争失败的线程直接自旋重试，不需要排队</li>
<li><strong>不需要阻塞/唤醒机制</strong>：没有线程会被挂起，也就不需要 Mutex 和 Condition Variable</li>
<li><strong>Mark Word 足以表达锁状态</strong>：只需要知道&quot;锁被谁持有&quot;，不需要复杂的等待/通知语义</li>
</ol>
<p>一旦竞争变得激烈（自旋超过阈值），轻量级锁就会膨胀为重量级锁，此时才需要 ObjectMonitor 来管理等待队列和线程阻塞。</p>
<h3 id="objectmonitor-的创建时机与生命周期">ObjectMonitor 的创建时机与生命周期</h3>
<p>当 synchronized 需要使用重量级锁时，ObjectMonitor 并非凭空 new 出来，而是<strong>按需延迟创建（Lazy Allocation）</strong>。</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Thread as 线程
    participant OBJ as 锁对象
    participant MW as Mark Word
    participant Pool as Monitor 池
    participant Monitor as ObjectMonitor
    
    Note over Thread,Monitor: 场景：轻量级锁竞争失败，需要膨胀
    
    Thread-&gt;&gt;MW: CAS 失败，检测到竞争
    Thread-&gt;&gt;Thread: 决定膨胀为重量级锁
    
    alt Monitor 池中有空闲 Monitor
        Thread-&gt;&gt;Pool: 从池中获取 Monitor
        Pool--&gt;&gt;Thread: 返回空闲 Monitor
    else Monitor 池为空
        Thread-&gt;&gt;Monitor: new ObjectMonitor()
        Note over Monitor: 在 C++ 堆上分配&lt;br/&gt;初始化 mutex/cond
    end
    
    Thread-&gt;&gt;Monitor: 设置 _header = 原始 Mark Word
    Thread-&gt;&gt;Monitor: 设置 _owner = 当前线程
    Thread-&gt;&gt;MW: CAS 更新为 ptr_to_monitor | 10
    
    Note over Thread,Monitor: 锁膨胀完成
    
    Note over Thread,Monitor: 后续：锁释放时
    Thread-&gt;&gt;Monitor: 释放锁
    Monitor-&gt;&gt;Pool: 归还到 Monitor 池（可能）
    Note over Pool: 或者直接销毁&lt;br/&gt;取决于 JVM 实现</code></pre>
<p><strong>ObjectMonitor 的生命周期：</strong></p>
<ol>
<li><strong>创建时机</strong>：只有当轻量级锁竞争失败，需要膨胀为重量级锁时，才会创建或获取 ObjectMonitor</li>
<li><strong>关联方式</strong>：通过将 Mark Word 替换为指向 ObjectMonitor 的指针（锁标志位为 10）</li>
<li><strong>回收时机</strong>：当锁不再被使用时，ObjectMonitor 可能被回收或放入池中复用</li>
<li><strong>池化复用</strong>：HotSpot 维护了一个 ObjectMonitor 的空闲池，避免频繁分配/销毁</li>
</ol>
<p><strong>Mark Word 与 Monitor 的关系图：</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;Mark Word 的不同状态&quot;
        direction TB
        
        MW1[&quot;无锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;hashCode | age | 0 | 01&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;存储对象自身信息&quot;]
        
        MW2[&quot;偏向锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;threadId | epoch | age | 1 | 01&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;存储偏向线程 ID&quot;]
        
        MW3[&quot;轻量级锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;ptr_to_lock_record | 00&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;指向栈上的 Lock Record&quot;]
        
        MW4[&quot;重量级锁状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;ptr_to_monitor | 10&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;指向 ObjectMonitor&quot;]
        
        MW5[&quot;GC 标记状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;... | 11&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;GC 使用&quot;]
        
        style MW1 fill:#e8f5e9
        style MW2 fill:#fff9c4
        style MW3 fill:#e1f5ff
        style MW4 fill:#ffcdd2
        style MW5 fill:#f5f5f5
    end
    
    subgraph &quot;指向的目标&quot;
        LR[&quot;Lock Record&lt;br/&gt;（栈上）&quot;]
        MON[&quot;ObjectMonitor&lt;br/&gt;（C++ 堆）&quot;]
        
        style LR fill:#e1f5ff
        style MON fill:#ffcdd2
    end
    
    MW3 --&gt;|&quot;指针&quot;| LR
    MW4 --&gt;|&quot;指针&quot;| MON</code></pre>
<p><strong>关键理解：synchronized(obj) 的加锁过程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">synchronized</span> (obj) &#123;<br>    <span class="hljs-comment">// 临界区代码</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码的加锁过程：</p>
<ol>
<li><strong>首先尝试偏向锁</strong>（如果启用）：检查 Mark Word 是否已偏向当前线程</li>
<li><strong>偏向失败，尝试轻量级锁</strong>：在栈帧创建 Lock Record，CAS 替换 Mark Word</li>
<li><strong>轻量级锁失败，膨胀为重量级锁</strong>：
<ul>
<li>创建或获取 ObjectMonitor</li>
<li>将 Mark Word 替换为指向 Monitor 的指针</li>
<li>当前线程成为 Monitor 的 owner</li>
<li>竞争失败的线程进入 Monitor 的等待队列并阻塞</li>
</ul>
</li>
</ol>
<p><strong>小结：轻量级锁与重量级锁的核心差异</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>轻量级锁&quot;轻&quot;在哪里？</strong></td>
<td>不使用 OS 的 Mutex，只用 CAS 指令，无系统调用，无线程阻塞</td>
</tr>
<tr>
<td><strong>为什么用 Lock Record 而不是 Monitor？</strong></td>
<td>Lock Record 在栈上自动管理，无需分配/回收，CAS 操作比 Mutex 快几十倍</td>
</tr>
<tr>
<td><strong>synchronized(obj) 靠 Mark Word 引用 Monitor 吗？</strong></td>
<td>是的，重量级锁状态下 Mark Word 存储的就是指向 ObjectMonitor 的指针</td>
</tr>
<tr>
<td><strong>Monitor 是凭空 new 出来的吗？</strong></td>
<td>是延迟创建的，只有膨胀为重量级锁时才会创建，且可能从池中复用</td>
</tr>
</tbody>
</table>
<p>&quot;Mark Word&quot;被设计成一个非固定的数据结构，以便在极小的空间内存储尽量多的信息。因此，它的内存布局是可变的。要动态地理解对象的数据结构，可以采用 jol 工具：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        Student stu=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>();<br>        System.out.println(<span class="hljs-string">&quot;=====加锁之前======&quot;</span>);<br>        System.out.println(ClassLayout.parseInstance(stu).toPrintable());<br>        <span class="hljs-keyword">synchronized</span> (stu)&#123;<br>            System.out.println(<span class="hljs-string">&quot;=====加锁之后======&quot;</span>);<br>            System.out.println(ClassLayout.parseInstance(stu).toPrintable());<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在代码进入同步块的时候，如果此同步对象没有被锁定（锁标志位为&quot;01&quot;），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储所对象目前的 Mark Word的拷贝（实际上被命名为 Displaced Markd Word）。<strong>也就是说，试图求锁的线程局部栈帧可能是不一样的。</strong></p>
<h3 id="线程栈帧与-lock-record-的结构">线程栈帧与 Lock Record 的结构</h3>
<p>要理解轻量级锁的工作原理，首先需要理解线程栈帧的结构以及 Lock Record 在其中的位置。</p>
<p><strong>线程栈帧（Stack Frame）的基本结构：</strong></p>
<p>每个线程在执行方法时，JVM 会为该方法创建一个栈帧（Stack Frame），栈帧是方法执行的基本单位。栈帧包含以下几个核心部分：</p>
<table>
<thead>
<tr>
<th>组成部分</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>局部变量表（Local Variable Table）</strong></td>
<td>存储方法参数和方法内定义的局部变量</td>
</tr>
<tr>
<td><strong>操作数栈（Operand Stack）</strong></td>
<td>用于执行字节码指令时的临时数据存储</td>
</tr>
<tr>
<td><strong>动态链接（Dynamic Linking）</strong></td>
<td>指向运行时常量池中该方法的引用</td>
</tr>
<tr>
<td><strong>方法返回地址（Return Address）</strong></td>
<td>方法正常退出或异常退出后的返回位置</td>
</tr>
<tr>
<td><strong>Lock Record（锁记录）</strong></td>
<td><strong>仅在进入 synchronized 块时创建</strong>，用于轻量级锁的实现</td>
</tr>
</tbody>
</table>
<p><strong>图：线程栈帧结构与 Lock Record 的位置</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;线程栈（Thread Stack）&quot;
        direction TB
        
        subgraph &quot;栈帧3（当前方法 - synchronized 块内）&quot;
            LVT3[&quot;局部变量表&lt;br/&gt;Local Variable Table&quot;]
            OS3[&quot;操作数栈&lt;br/&gt;Operand Stack&quot;]
            DL3[&quot;动态链接&lt;br/&gt;Dynamic Linking&quot;]
            RA3[&quot;方法返回地址&lt;br/&gt;Return Address&quot;]
            
            subgraph &quot;Lock Record（锁记录）&quot;
                DMW[&quot;Displaced Mark Word&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;对象原始 Mark Word 的备份&lt;br/&gt;（hashCode、age 等信息）&quot;]
                OBJ_REF[&quot;owner 指针&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;指向被锁定的对象&quot;]
            end
            
            style DMW fill:#e8f5e9
            style OBJ_REF fill:#fff9c4
        end
        
        subgraph &quot;栈帧2（调用方法）&quot;
            LVT2[&quot;局部变量表&quot;]
            OS2[&quot;操作数栈&quot;]
            DL2[&quot;动态链接&quot;]
            RA2[&quot;方法返回地址&quot;]
            style LVT2 fill:#f5f5f5
            style OS2 fill:#f5f5f5
            style DL2 fill:#f5f5f5
            style RA2 fill:#f5f5f5
        end
        
        subgraph &quot;栈帧1（main 方法）&quot;
            LVT1[&quot;局部变量表&quot;]
            OS1[&quot;操作数栈&quot;]
            DL1[&quot;动态链接&quot;]
            RA1[&quot;方法返回地址&quot;]
            style LVT1 fill:#f5f5f5
            style OS1 fill:#f5f5f5
            style DL1 fill:#f5f5f5
            style RA1 fill:#f5f5f5
        end
    end
    
    subgraph &quot;堆（Heap）&quot;
        OBJ[&quot;锁对象&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Object Header:&lt;br/&gt;Mark Word | Klass Word&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Object Body&quot;]
        style OBJ fill:#e1f5ff
    end
    
    OBJ_REF --&gt;|&quot;指向&quot;| OBJ
    OBJ --&gt;|&quot;Mark Word 存储&lt;br/&gt;Lock Record 指针&quot;| DMW
    
    note1[&quot;Lock Record 是栈帧的一部分&lt;br/&gt;仅在进入 synchronized 块时动态创建&lt;br/&gt;退出时销毁&quot;]
    style note1 fill:#fff9c4</code></pre>
<p><strong>Lock Record 的内部结构：</strong></p>
<p>Lock Record 是轻量级锁实现的核心数据结构，它包含两个关键字段：</p>
<table>
<thead>
<tr>
<th>字段</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Displaced Mark Word</strong></td>
<td>markOop</td>
<td>对象原始 Mark Word 的备份。当获取轻量级锁时，对象的 Mark Word 会被替换为指向 Lock Record 的指针，原始信息（hashCode、GC age 等）就保存在这里。解锁时需要将其恢复回对象头。</td>
</tr>
<tr>
<td><strong>owner（对象指针）</strong></td>
<td>oop</td>
<td>指向被锁定对象的指针。用于标识这个 Lock Record 锁定的是哪个对象，也用于 GC 时的对象引用追踪。</td>
</tr>
</tbody>
</table>
<p><strong>图：轻量级锁加锁过程中 Lock Record 与对象的交互</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Thread as 线程栈帧
    participant LR as Lock Record
    participant OBJ as 锁对象
    participant MW as Mark Word
    
    Note over Thread,MW: 1. 进入 synchronized 块
    
    Thread-&gt;&gt;LR: 在栈帧中创建 Lock Record
    Thread-&gt;&gt;LR: 初始化 owner 指向锁对象
    
    Note over Thread,MW: 2. 备份原始 Mark Word
    
    OBJ-&gt;&gt;MW: 读取当前 Mark Word
    MW-&gt;&gt;LR: 拷贝到 Displaced Mark Word
    Note over LR: Displaced Mark Word =&lt;br/&gt;hashCode | age | 01
    
    Note over Thread,MW: 3. CAS 尝试获取锁
    
    Thread-&gt;&gt;MW: CAS(原始值, Lock Record 指针)
    
    alt CAS 成功
        MW-&gt;&gt;MW: Mark Word = ptr_to_LR | 00
        Note over Thread,MW: 获取轻量级锁成功！
    else CAS 失败
        alt Mark Word 已指向当前线程的 Lock Record
            Note over Thread,MW: 锁重入，直接进入
        else Mark Word 指向其他线程
            Note over Thread,MW: 竞争失败，锁膨胀为重量级锁
        end
    end</code></pre>
<p><strong>图：Lock Record 在锁重入场景下的表现</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;线程栈（同一线程多次进入 synchronized）&quot;
        direction TB
        
        subgraph &quot;栈帧 - 第三次进入 synchronized&quot;
            LR3[&quot;Lock Record 3&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word: null&lt;br/&gt;owner: → 锁对象&quot;]
            style LR3 fill:#ffcdd2
        end
        
        subgraph &quot;栈帧 - 第二次进入 synchronized&quot;
            LR2[&quot;Lock Record 2&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word: null&lt;br/&gt;owner: → 锁对象&quot;]
            style LR2 fill:#fff9c4
        end
        
        subgraph &quot;栈帧 - 第一次进入 synchronized&quot;
            LR1[&quot;Lock Record 1&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Displaced Mark Word: 原始值&lt;br/&gt;owner: → 锁对象&quot;]
            style LR1 fill:#c8e6c9
        end
    end
    
    subgraph &quot;堆&quot;
        OBJ[&quot;锁对象&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;Mark Word:&lt;br/&gt;ptr_to_LR1 | 00&quot;]
        style OBJ fill:#e1f5ff
    end
    
    LR1 --&gt;|&quot;owner&quot;| OBJ
    LR2 --&gt;|&quot;owner&quot;| OBJ
    LR3 --&gt;|&quot;owner&quot;| OBJ
    OBJ --&gt;|&quot;Mark Word 指向&quot;| LR1
    
    note1[&quot;锁重入时：&lt;br/&gt;1. 每次进入都创建新的 Lock Record&lt;br/&gt;2. 只有第一个 LR 保存原始 Mark Word&lt;br/&gt;3. 后续 LR 的 Displaced Mark Word 为 null&lt;br/&gt;4. 解锁时按栈顺序逐个弹出 LR&lt;br/&gt;5. 遇到非 null 的 Displaced Mark Word 时恢复&quot;]
    style note1 fill:#fff9c4</code></pre>
<p><strong>Lock Record 放在栈帧中的原因</strong></p>
<ol>
<li><strong>生命周期自动管理</strong>：栈帧随方法调用创建、随方法返回销毁，Lock Record 也随之自动管理，无需额外的内存分配和回收</li>
<li><strong>线程私有</strong>：每个线程有自己的栈，Lock Record 天然是线程私有的，无需同步</li>
<li><strong>支持锁重入</strong>：每次进入 synchronized 块都会创建新的 Lock Record，通过栈的 LIFO 特性天然支持锁重入的计数和恢复</li>
<li><strong>快速访问</strong>：栈帧在 CPU 缓存中的命中率高，访问速度快</li>
</ol>
<h3 id="lock-record-的生命周期-生老病死">Lock Record 的生命周期（生老病死）</h3>
<p>理解 Lock Record 的完整生命周期，是理解轻量级锁机制的关键：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Thread as 线程
    participant Stack as 线程栈帧
    participant LR as Lock Record
    participant OBJ as 锁对象
    participant MW as Mark Word
    
    Note over Thread,MW: 1. 创建（Birth）：进入 synchronized 块
    
    Thread-&gt;&gt;Stack: 在当前栈帧中分配空间
    Stack-&gt;&gt;LR: 创建 Lock Record
    LR-&gt;&gt;LR: 初始化 owner 指向锁对象
    
    Note over Thread,MW: 2. 备份（Backup）：保存原始 Mark Word
    
    Thread-&gt;&gt;MW: 读取当前 Mark Word
    MW-&gt;&gt;LR: 拷贝到 Displaced Mark Word
    
    Note over Thread,MW: 3. 竞争（Compete）：CAS 尝试获取锁
    
    Thread-&gt;&gt;MW: CAS(原始值, LR指针|00)
    
    alt CAS 成功
        MW-&gt;&gt;MW: 更新为 ptr_to_LR | 00
        Note over LR: Lock Record 生效&lt;br/&gt;线程持有锁
    else CAS 失败（竞争）
        Note over LR: Lock Record 仍存在于栈帧&lt;br/&gt;但未能成为&quot;有效&quot;的锁记录
        Thread-&gt;&gt;Thread: 自旋重试或触发锁膨胀
    end
    
    Note over Thread,MW: 4. 释放（Release）：退出 synchronized 块
    
    Thread-&gt;&gt;MW: CAS(LR指针|00, 原始Mark Word)
    
    alt CAS 成功
        MW-&gt;&gt;MW: 恢复原始 Mark Word
        Note over LR: 正常解锁
    else CAS 失败（锁已膨胀）
        Note over LR: 按重量级锁方式释放
    end
    
    Note over Thread,MW: 5. 销毁（Death）：栈帧弹出
    
    Stack-&gt;&gt;LR: 随栈帧销毁而自动回收
    Note over LR: Lock Record 生命周期结束</code></pre>
<p><strong>Lock Record 生命周期的关键问题解答：</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>每个线程都有 Lock Record 吗？</strong></td>
<td>只有尝试获取锁的线程才会创建 Lock Record。每次进入 synchronized 块时创建，退出时销毁。</td>
</tr>
<tr>
<td><strong>竞争失败的线程还有 Lock Record 吗？</strong></td>
<td><strong>有</strong>。竞争失败的线程的 Lock Record 仍然存在于其栈帧中，只是它的 Displaced Mark Word 没有被&quot;采用&quot;——锁对象的 Mark Word 没有指向它。</td>
</tr>
<tr>
<td><strong>Lock Record 什么时候销毁？</strong></td>
<td>当线程退出 synchronized 块时，栈帧弹出，Lock Record 随之自动销毁。这是栈内存的天然特性。</td>
</tr>
<tr>
<td><strong>锁膨胀后 Lock Record 怎么办？</strong></td>
<td>锁膨胀后，Lock Record 仍然存在，但解锁时需要按重量级锁的方式处理（唤醒等待线程等）。Lock Record 中的 Displaced Mark Word 会被转移到 ObjectMonitor 的 <code>_header</code> 字段。</td>
</tr>
</tbody>
</table>
<h3 id="轻量级锁没有-waitset-和-entrylist-的原因">轻量级锁没有 WaitSet 和 EntryList 的原因</h3>
<p>重量级锁的 ObjectMonitor 有 <code>_EntryList</code>（阻塞等待队列）和 <code>_WaitSet</code>（wait 等待队列），但轻量级锁的 Lock Record 完全没有这些结构。这是因为<strong>轻量级锁的设计假设是&quot;竞争很少发生&quot;，因此不需要管理等待线程</strong>。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;轻量级锁的设计假设&quot;
        ASSUME[&quot;假设：锁竞争很少发生&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 大多数情况下，锁是无竞争的&lt;br/&gt;• 即使有竞争，也是短暂的&lt;br/&gt;• 竞争失败的线程自旋几次就能获取锁&quot;]
        style ASSUME fill:#c8e6c9
    end
    
    subgraph &quot;因此不需要&quot;
        NO_ENTRY[&quot;不需要 EntryList&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;竞争失败的线程不阻塞&lt;br/&gt;而是自旋重试&quot;]
        NO_WAIT[&quot;不需要 WaitSet&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;轻量级锁不支持 wait/notify&lt;br/&gt;调用 wait() 会触发锁膨胀&quot;]
        NO_COND[&quot;不需要 Condition&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;条件等待需要阻塞线程&lt;br/&gt;这与轻量级锁的设计冲突&quot;]
        
        style NO_ENTRY fill:#fff9c4
        style NO_WAIT fill:#fff9c4
        style NO_COND fill:#fff9c4
    end
    
    ASSUME --&gt; NO_ENTRY
    ASSUME --&gt; NO_WAIT
    ASSUME --&gt; NO_COND
    
    subgraph &quot;一旦假设被打破&quot;
        INFLATE[&quot;立即膨胀为重量级锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• CAS 自旋超过阈值&lt;br/&gt;• 调用 wait()/notify()&lt;br/&gt;• 竞争过于激烈&quot;]
        style INFLATE fill:#ffcdd2
    end
    
    NO_ENTRY --&gt;|&quot;假设失效&quot;| INFLATE
    NO_WAIT --&gt;|&quot;假设失效&quot;| INFLATE
    NO_COND --&gt;|&quot;假设失效&quot;| INFLATE</code></pre>
<p><strong>轻量级锁 vs 重量级锁的数据结构对比：</strong></p>
<table>
<thead>
<tr>
<th>数据结构</th>
<th>轻量级锁（Lock Record）</th>
<th>重量级锁（ObjectMonitor）</th>
<th>为什么轻量级锁不需要</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Displaced Mark Word</strong></td>
<td>有</td>
<td>有（<code>_header</code> 字段）</td>
<td>都需要备份原始 Mark Word</td>
</tr>
<tr>
<td><strong>owner 指针</strong></td>
<td>有</td>
<td>有（<code>_owner</code> 字段）</td>
<td>都需要记录持锁线程</td>
</tr>
<tr>
<td><strong>重入计数</strong></td>
<td>有（多个 Lock Record）</td>
<td>有（<code>_recursions</code> 字段）</td>
<td>都需要支持锁重入</td>
</tr>
<tr>
<td><strong>EntryList</strong></td>
<td>无</td>
<td>有</td>
<td>轻量级锁不阻塞线程，自旋重试</td>
</tr>
<tr>
<td><strong>WaitSet</strong></td>
<td>无</td>
<td>有</td>
<td>轻量级锁不支持 wait/notify</td>
</tr>
<tr>
<td><strong>cxq（竞争队列）</strong></td>
<td>无</td>
<td>有</td>
<td>轻量级锁不排队，直接自旋</td>
</tr>
<tr>
<td><strong>Mutex/Condition</strong></td>
<td>无</td>
<td>有</td>
<td>轻量级锁不使用 OS 同步原语</td>
</tr>
</tbody>
</table>
<h3 id="自旋与阻塞：锁等待机制的优化">自旋与阻塞：锁等待机制的优化</h3>
<p>在理解了偏向锁和轻量级锁的实现原理后，我们需要深入讨论一个关键问题：当线程获取锁失败时，应该如何等待？</p>
<h4 id="自旋优化的必要性">自旋优化的必要性</h4>
<p>一个已经拥有 CPU 执行时间的线程，在求锁的时候，如果直接被阻塞（进入内核态等待），会带来显著的性能开销：</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>开销</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>用户态/内核态切换</strong></td>
<td>≈ 1000+ CPU 周期</td>
<td>需要保存/恢复寄存器、切换特权级别</td>
</tr>
<tr>
<td><strong>线程上下文切换</strong></td>
<td>≈ 5000+ CPU 周期</td>
<td>需要保存/恢复线程状态、刷新 TLB</td>
</tr>
<tr>
<td><strong>CAS 操作</strong></td>
<td>≈ 10-100 CPU 周期</td>
<td>仅需原子指令，无需内核介入</td>
</tr>
</tbody>
</table>
<p>如果锁的持有时间很短（如简单的 getter/setter），线程阻塞后很快就会被唤醒，那么<strong>阻塞和唤醒的开销可能远超过实际执行临界区代码的开销</strong>。这就是自旋锁存在的意义：<strong>用 CPU 空转换取避免线程切换的开销</strong>。</p>
<h4 id="自旋锁的实现原理">自旋锁的实现原理</h4>
<p>自旋锁的核心思想是：当线程获取锁失败时，不立即阻塞，而是执行一个<strong>忙循环（busy waiting）</strong>，不断尝试获取锁。</p>
<p><strong>图：自旋锁 vs 阻塞锁的执行流程对比</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;阻塞锁（传统方式）&quot;
        direction TB
        B1[&quot;线程尝试获取锁&quot;]
        B2&#123;&quot;获取成功?&quot;&#125;
        B3[&quot;进入临界区执行&quot;]
        B4[&quot;释放锁&quot;]
        B5[&quot;阻塞线程&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;1. 保存线程上下文&lt;br/&gt;2. 用户态→内核态&lt;br/&gt;3. 加入等待队列&lt;br/&gt;4. 调度其他线程&quot;]
        B6[&quot;被唤醒&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;1. 内核态→用户态&lt;br/&gt;2. 恢复线程上下文&lt;br/&gt;3. 重新调度&quot;]
        
        B1 --&gt; B2
        B2 --&gt;|是| B3
        B2 --&gt;|否| B5
        B5 --&gt;|锁释放| B6
        B6 --&gt; B1
        B3 --&gt; B4
        
        style B5 fill:#ffcdd2
        style B6 fill:#ffcdd2
    end
    
    subgraph &quot;自旋锁&quot;
        direction TB
        S1[&quot;线程尝试获取锁&quot;]
        S2&#123;&quot;获取成功?&quot;&#125;
        S3[&quot;进入临界区执行&quot;]
        S4[&quot;释放锁&quot;]
        S5[&quot;自旋等待&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;while (!tryLock()) &#123;&lt;br/&gt;    // 空循环&lt;br/&gt;    // 或执行 PAUSE 指令&lt;br/&gt;&#125;&quot;]
        
        S1 --&gt; S2
        S2 --&gt;|是| S3
        S2 --&gt;|否| S5
        S5 --&gt;|继续尝试| S2
        S3 --&gt; S4
        
        style S5 fill:#fff9c4
    end</code></pre>
<p><strong>忙循环是怎么实现的？</strong></p>
<p>在 HotSpot JVM 中，自旋锁的实现并不是简单的 <code>while(true)</code> 空循环。实际的实现涉及以下几个层面：</p>
<ol>
<li><strong>字节码层面</strong>：<code>monitorenter</code> 指令在获取锁失败时，会进入 JVM 运行时的自旋逻辑</li>
<li><strong>JVM 运行时层面</strong>：在 <code>ObjectMonitor::enter()</code> 方法中实现自旋逻辑</li>
<li><strong>CPU 指令层面</strong>：使用 <code>PAUSE</code> 指令（x86）或类似指令来优化自旋</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// HotSpot 中自旋锁的简化伪代码</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectMonitor::enter</span><span class="hljs-params">(TRAPS)</span> </span>&#123;<br>    <span class="hljs-comment">// 快速路径：尝试 CAS 获取锁</span><br>    <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">cmpxchg</span>(Self, &amp;_owner, <span class="hljs-literal">NULL</span>) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 获取成功</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 自旋尝试</span><br>    <span class="hljs-type">int</span> spinCount = Knob_SpinLimit; <span class="hljs-comment">// 自旋次数限制</span><br>    <span class="hljs-keyword">while</span> (spinCount-- &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (_owner == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">cmpxchg</span>(Self, &amp;_owner, <span class="hljs-literal">NULL</span>) == <span class="hljs-literal">NULL</span>) &#123;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 自旋期间获取成功</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">SpinPause</span>(); <span class="hljs-comment">// 执行 PAUSE 指令，降低 CPU 功耗和总线竞争</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 自旋失败，进入阻塞</span><br>    <span class="hljs-built_in">EnterI</span>(THREAD);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong><code>PAUSE</code> 指令的作用：</strong></p>
<table>
<thead>
<tr>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>降低 CPU 功耗</strong></td>
<td>告诉 CPU 当前处于自旋等待状态，可以降低时钟频率</td>
</tr>
<tr>
<td><strong>减少总线竞争</strong></td>
<td>避免频繁的缓存行失效（cache line invalidation）</td>
</tr>
<tr>
<td><strong>提高超线程效率</strong></td>
<td>让出执行资源给同一物理核心上的其他超线程</td>
</tr>
<tr>
<td><strong>避免流水线惩罚</strong></td>
<td>防止 CPU 错误预测分支导致的流水线刷新</td>
</tr>
</tbody>
</table>
<h4 id="自旋次数的控制">自旋次数的控制</h4>
<p><strong>固定自旋（JDK 6 之前）：</strong></p>
<p>循环的次数通常不会很多，默认是 10 次。这个次数可以通过 <code>-XX:PreBlockSpin</code> 参数调整。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 设置自旋次数为 20</span><br>java -XX:PreBlockSpin=20 MyApplication<br></code></pre></td></tr></table></figure>
<p><strong>自适应自旋（Adaptive Spinning，JDK 6+）：</strong></p>
<p>固定自旋次数的问题在于：不同的锁、不同的场景，最优的自旋次数是不同的。JDK 6 引入了<strong>自适应自旋锁</strong>，让 JVM 根据运行时统计信息动态调整自旋次数：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;自适应自旋的决策逻辑&quot;
        direction TB
        
        HISTORY[&quot;历史统计信息&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 上次自旋是否成功&lt;br/&gt;• 锁的持有者状态&lt;br/&gt;• 自旋成功率&quot;]
        
        DECIDE&#123;&quot;决策&quot;&#125;
        
        INCREASE[&quot;增加自旋次数&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;上次自旋成功获取锁&lt;br/&gt;说明锁竞争不激烈&lt;br/&gt;值得多自旋几次&quot;]
        
        DECREASE[&quot;减少自旋次数&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;上次自旋失败&lt;br/&gt;说明锁竞争激烈&lt;br/&gt;自旋浪费 CPU&quot;]
        
        SKIP[&quot;跳过自旋&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;自旋从未成功过&lt;br/&gt;直接阻塞更高效&quot;]
        
        HISTORY --&gt; DECIDE
        DECIDE --&gt;|&quot;自旋成功率高&quot;| INCREASE
        DECIDE --&gt;|&quot;自旋成功率低&quot;| DECREASE
        DECIDE --&gt;|&quot;自旋从未成功&quot;| SKIP
        
        style INCREASE fill:#c8e6c9
        style DECREASE fill:#fff9c4
        style SKIP fill:#ffcdd2
    end</code></pre>
<p>自适应自旋的核心思想是：<strong>让 JVM 自己学习最优的自旋策略</strong>。如果对于某个锁，自旋经常能成功获取，那么下次就多自旋几次；如果自旋很少成功，那么下次就少自旋甚至直接阻塞。</p>
<h4 id="自旋锁的适用场景">自旋锁的适用场景</h4>
<p><strong>图：自旋锁 vs 阻塞锁的性能对比</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;锁持有时间短 + 竞争不激烈&quot;
        SHORT[&quot;临界区执行时间 &lt; 线程切换时间&quot;]
        SPIN_WIN[&quot;自旋锁胜出&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;自旋几次就能获取锁&lt;br/&gt;避免了线程切换开销&quot;]
        SHORT --&gt; SPIN_WIN
        style SPIN_WIN fill:#c8e6c9
    end
    
    subgraph &quot;锁持有时间长 + 竞争激烈&quot;
        LONG[&quot;临界区执行时间 &gt; 线程切换时间&quot;]
        BLOCK_WIN[&quot;阻塞锁胜出&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;自旋浪费大量 CPU&lt;br/&gt;不如让出 CPU 给其他线程&quot;]
        LONG --&gt; BLOCK_WIN
        style BLOCK_WIN fill:#c8e6c9
    end</code></pre>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐策略</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CAS 操作</strong>（如 <code>AtomicInteger.incrementAndGet()</code>）</td>
<td>自旋</td>
<td>操作极快（几个 CPU 周期），自旋几乎总能成功</td>
</tr>
<tr>
<td><strong>简单 getter/setter</strong></td>
<td>自旋</td>
<td>临界区代码很短，锁持有时间极短</td>
</tr>
<tr>
<td><strong>数据库操作、网络 I/O</strong></td>
<td>阻塞</td>
<td>操作耗时长，自旋会浪费大量 CPU</td>
</tr>
<tr>
<td><strong>高并发竞争</strong></td>
<td>阻塞</td>
<td>多个线程同时自旋会导致 CPU 资源浪费</td>
</tr>
</tbody>
</table>
<p><strong>自旋锁的本质权衡：</strong></p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">自旋锁的收益 <span class="hljs-operator">=</span> 避免的线程切换开销<br>自旋锁的成本 <span class="hljs-operator">=</span> 自旋期间浪费的 CPU 时间<br><br>当 收益 &gt; 成本 时，自旋锁是划算的<br>当 收益 &lt; 成本 时，阻塞锁更高效<br></code></pre></td></tr></table></figure>
<p>这也是为什么 JVM 会结合使用自旋和阻塞：<strong>先自旋一定次数，如果还获取不到锁，再阻塞</strong>。这种策略在大多数场景下都能取得较好的平衡。</p>
<h4 id="锁膨胀的必然性：自旋失败是常态而非例外">锁膨胀的必然性：自旋失败是常态而非例外</h4>
<p>理解了自旋的本质权衡后，一个重要的推论是：<strong>在存在真实竞争的场景下，从轻量级锁膨胀到重量级锁几乎是必然的</strong>。</p>
<p>考虑以下推理链条：</p>
<ol>
<li>
<p><strong>synchronized 的语义是无限等待</strong>：与 <code>tryLock(timeout)</code> 不同，<code>synchronized</code> 没有超时机制。一旦线程尝试进入同步块，它必须获取锁才能继续，否则就一直等待。</p>
</li>
<li>
<p><strong>自旋次数是有限的</strong>：无论是固定自旋（默认约 10 次）还是自适应自旋，自旋次数都有上限。假设自旋循环执行 10-20 次，每次循环消耗约 100-200 个 CPU 周期，整个自旋过程大约持续 1-4 微秒。</p>
</li>
<li>
<p><strong>同步块执行时间通常远超自旋时间</strong>：即使是一个简单的同步块，只要包含任何有意义的业务逻辑（如一次 HashMap 操作、一次日志记录），其执行时间通常在微秒到毫秒级别。</p>
</li>
<li>
<p><strong>结论</strong>：如果线程 A 持有轻量级锁正在执行同步块，线程 B 尝试获取锁并开始自旋。只要同步块的执行时间超过自旋等待时间（这在绝大多数情况下都成立），线程 B 的自旋必然失败，锁必然膨胀为重量级锁。</p>
</li>
</ol>
<p><strong>图：自旋失败的时间竞赛</strong></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">时间轴 →<br>线程 A: |<span class="hljs-string">-------- 持有锁执行同步块（10-1000+ 微秒）--------</span>|<span class="hljs-string">释放锁</span>|<br>线程 B:      |<span class="hljs-string">自旋（1-4 微秒）</span>|<span class="hljs-string">膨胀</span>|<span class="hljs-string">阻塞等待.............</span>|<span class="hljs-string">被唤醒</span>|<br>                              ↑<br>                    自旋时间 <span class="hljs-variable">&lt;&lt; 同步块执行时间</span><br><span class="hljs-variable">                    膨胀是必然结果</span><br></code></pre></td></tr></table></figure>
<p><strong>这个分析的实践意义：</strong></p>
<ol>
<li>
<p><strong>不要对轻量级锁抱有不切实际的期望</strong>：轻量级锁的真正价值在于处理&quot;交替访问&quot;（线程 A 释放锁后，线程 B 才来获取）的场景，而非&quot;同时竞争&quot;的场景。</p>
</li>
<li>
<p><strong>自旋的作用是&quot;延迟膨胀&quot;而非&quot;避免膨胀&quot;</strong>：自旋给了持锁线程一个短暂的窗口期来释放锁。如果持锁线程恰好在这个窗口期内释放锁，就避免了膨胀；否则膨胀不可避免。</p>
</li>
<li>
<p><strong>自旋可以看作轻量级的&quot;等待队列&quot;</strong>：在重量级锁中，等待线程被放入 <code>_EntryList</code> 队列并阻塞。而在轻量级锁阶段，自旋循环实际上起到了类似的&quot;等待&quot;作用——只不过是忙等待而非阻塞等待。自旋失败后，线程才真正进入 ObjectMonitor 的等待队列。</p>
</li>
<li>
<p><strong>synchronized 的&quot;无限等待&quot;语义决定了最终必须有阻塞机制</strong>：既然 synchronized 承诺&quot;一定能获取锁&quot;，那么在自旋失败后，唯一的选择就是阻塞等待。这就是为什么锁升级的终点必然是重量级锁——只有重量级锁才有完整的阻塞/唤醒机制。</p>
</li>
</ol>
<h3 id="什么是-竞争-？如何判定竞争程度？">什么是&quot;竞争&quot;？如何判定竞争程度？</h3>
<p>在锁优化的语境下，&quot;竞争&quot;有精确的技术定义：</p>
<p><strong>竞争的判定标准：</strong></p>
<table>
<thead>
<tr>
<th>竞争程度</th>
<th>判定条件</th>
<th>锁状态</th>
<th>线程行为</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无竞争</strong></td>
<td>始终只有一个线程访问锁</td>
<td>偏向锁</td>
<td>仅比较 threadId，零开销</td>
</tr>
<tr>
<td><strong>轻度竞争</strong></td>
<td>多个线程交替访问锁，但不同时</td>
<td>轻量级锁</td>
<td>CAS 总能成功，无需等待</td>
</tr>
<tr>
<td><strong>中度竞争</strong></td>
<td>多个线程同时尝试获取锁，但持锁时间短</td>
<td>轻量级锁 + 自旋</td>
<td>CAS 偶尔失败，自旋几次后成功</td>
</tr>
<tr>
<td><strong>重度竞争</strong></td>
<td>多个线程同时竞争，持锁时间长</td>
<td>重量级锁</td>
<td>CAS 频繁失败，自旋超时，线程阻塞</td>
</tr>
</tbody>
</table>
<p><strong>轻量级锁如何判定&quot;竞争发生&quot;？</strong></p>
<p>轻量级锁通过 <strong>CAS 操作的成功与否</strong> 来判定竞争：</p>
<pre><code class="hljs mermaid">graph TB
    START[&quot;线程尝试获取轻量级锁&quot;]
    CAS[&quot;CAS 将 Mark Word 替换为 Lock Record 指针&quot;]
    
    SUCCESS&#123;&quot;CAS 成功?&quot;&#125;
    
    LOCK_OK[&quot;获取锁成功&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;无竞争或竞争已结束&quot;]
    
    CHECK_REENTRY&#123;&quot;Mark Word 指向&lt;br/&gt;当前线程的 Lock Record?&quot;&#125;
    
    REENTRY[&quot;锁重入&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;创建新的 Lock Record&lt;br/&gt;Displaced Mark Word = null&quot;]
    
    SPIN[&quot;自旋重试&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;说明存在竞争&lt;br/&gt;但可能是短暂的&quot;]
    
    SPIN_CHECK&#123;&quot;自旋次数&lt;br/&gt;超过阈值?&quot;&#125;
    
    INFLATE[&quot;锁膨胀&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;竞争激烈&lt;br/&gt;升级为重量级锁&quot;]
    
    START --&gt; CAS
    CAS --&gt; SUCCESS
    SUCCESS --&gt;|是| LOCK_OK
    SUCCESS --&gt;|否| CHECK_REENTRY
    CHECK_REENTRY --&gt;|是| REENTRY
    CHECK_REENTRY --&gt;|否| SPIN
    SPIN --&gt; SPIN_CHECK
    SPIN_CHECK --&gt;|否| CAS
    SPIN_CHECK --&gt;|是| INFLATE
    
    style LOCK_OK fill:#c8e6c9
    style REENTRY fill:#c8e6c9
    style SPIN fill:#fff9c4
    style INFLATE fill:#ffcdd2</code></pre>
<p><strong>关键理解：轻量级锁的&quot;竞争&quot;触发锁膨胀</strong></p>
<p>轻量级锁的设计哲学是：<strong>一旦检测到真正的竞争（CAS 失败且不是锁重入），就认为轻量级锁的假设被打破，应该膨胀为重量级锁。</strong></p>
<p>这与偏向锁的区别在于：</p>
<ul>
<li><strong>偏向锁</strong>：第二个线程出现就撤销偏向，升级到轻量级锁</li>
<li><strong>轻量级锁</strong>：CAS 失败后先自旋重试，自旋超过阈值才膨胀为重量级锁</li>
</ul>
<p>自旋的存在是为了应对&quot;短暂竞争&quot;的场景——如果持锁线程很快就释放锁，等待线程自旋几次就能获取锁，比阻塞后再唤醒更高效。</p>
<p>然后虚拟机试图使用 CAS 操作尝试将对象的Mark Word 更新为指向 Lock Record 的指针（<strong>注意是整个Mark Word</strong>）。如果更新成功了，那么线程就拥有了该对象的锁，并且 Mark Word 的**锁标志位（Markword的最后两位）**转变为“00”。如果这个更新失败了，虚拟机首先会检查对象的 Mark Word是否指向当前线程的栈帧，如果是就说明当前线程已经拥有了这个对象的锁，可以直接进入同步块继续执行，否则说明这个锁对象已经被其他线程抢占了。如果有两条以上的线程争用同一个锁，那轻量级锁就不再有效，要膨胀为重量级锁，锁标志的状态值变为“10”，Mark Word也就变成指向重量级锁的指针（<strong>也就是说，不再指向 Lock Record</strong>）。</p>
<p>轻量级锁的解锁过程，也必须借助 CAS 操作，把 Displaced Mark Word 的值写到 Mark Word 上。如果替换完成，同步结束。如果替换失败，证明有其他线程尝试获取过该锁，说明在持有轻量级锁期间发生了锁膨胀。此时需要按重量级锁的方式释放锁并唤醒被挂起的线程。这确实是一个&quot;不对称&quot;的操作——加锁时使用轻量级锁，但解锁时需要按重量级锁处理。这种设计是合理的：锁膨胀发生在持锁期间，持锁线程在解锁时必须负责处理膨胀后的状态。</p>
<p><img src="https://ws1.sinaimg.cn/large/66dd581fly1flsf4024taj20h40a5q5u.jpg" alt=""></p>
<p><img src="https://ws1.sinaimg.cn/large/66dd581fly1flsf43kk1vj20d40abtb2.jpg" alt=""></p>
<p>轻量级锁在发生竞争时，依然会出现锁膨胀，而且还加上了CAS的开销，反而比直接使用重量级锁更慢。使用偏向锁只能根据一种经验假定，“绝大部分锁，在同步周期内是不存在竞争的”。</p>
<p>从这个过程我们可以看出来，mark word里并不是存了线程号，而是直接把mark word指向了目标线程的栈帧，轻量级锁和重量级锁的差别就在于底层是不是会触发 Mutex。</p>
<h3 id="锁竞争的详细场景分析">锁竞争的详细场景分析</h3>
<p>前面我们介绍了偏向锁、轻量级锁、重量级锁的基本原理，本节将通过详细的场景分析来说明<strong>当多个线程同时竞争锁时，具体会发生什么</strong>。</p>
<h4 id="轻量级锁竞争失败的处理策略">轻量级锁竞争失败的处理策略</h4>
<p>当线程尝试获取轻量级锁时 CAS 失败，JVM 会<strong>先自旋重试，自旋失败后才膨胀为重量级锁</strong>。</p>
<pre><code class="hljs mermaid">graph TB
    START[&quot;线程 B 尝试获取轻量级锁&quot;]
    CAS1[&quot;CAS 尝试将 Mark Word&lt;br/&gt;替换为自己的 Lock Record 指针&quot;]
    
    CAS1_RESULT&#123;&quot;CAS 成功?&quot;&#125;
    
    SUCCESS[&quot;获取锁成功&lt;br/&gt;进入临界区&quot;]
    
    CHECK_REENTRY&#123;&quot;Mark Word 指向&lt;br/&gt;当前线程的 Lock Record?&quot;&#125;
    
    REENTRY[&quot;锁重入&lt;br/&gt;创建新 Lock Record&lt;br/&gt;Displaced Mark Word = null&quot;]
    
    SPIN[&quot;自旋重试&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;在用户态循环执行 CAS&lt;br/&gt;期望持锁线程很快释放锁&quot;]
    
    SPIN_COUNT&#123;&quot;自旋次数&lt;br/&gt;超过阈值?&lt;br/&gt;（自适应调整）&quot;&#125;
    
    INFLATE[&quot;锁膨胀&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;1. 创建/获取 ObjectMonitor&lt;br/&gt;2. 将 Mark Word 替换为 Monitor 指针&lt;br/&gt;3. 线程进入 Monitor 的等待队列&lt;br/&gt;4. 线程被阻塞（park）&quot;]
    
    START --&gt; CAS1
    CAS1 --&gt; CAS1_RESULT
    CAS1_RESULT --&gt;|是| SUCCESS
    CAS1_RESULT --&gt;|否| CHECK_REENTRY
    CHECK_REENTRY --&gt;|是| REENTRY
    CHECK_REENTRY --&gt;|否| SPIN
    SPIN --&gt; SPIN_COUNT
    SPIN_COUNT --&gt;|否，继续自旋| CAS1
    SPIN_COUNT --&gt;|是，自旋超时| INFLATE
    
    style SUCCESS fill:#c8e6c9
    style REENTRY fill:#c8e6c9
    style SPIN fill:#fff9c4
    style INFLATE fill:#ffcdd2</code></pre>
<p><strong>关键理解：轻量级锁的自旋发生在哪里？</strong></p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>锁状态</th>
<th>自旋行为</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>CAS 首次失败</strong></td>
<td>仍是轻量级锁</td>
<td>开始自旋</td>
<td>Mark Word 仍指向其他线程的 Lock Record，锁标志位仍是 <code>00</code></td>
</tr>
<tr>
<td><strong>自旋期间</strong></td>
<td>仍是轻量级锁</td>
<td>持续 CAS 重试</td>
<td>期望持锁线程释放锁，Mark Word 恢复为无锁状态</td>
</tr>
<tr>
<td><strong>自旋成功</strong></td>
<td>轻量级锁</td>
<td>停止自旋</td>
<td>CAS 成功，获取轻量级锁</td>
</tr>
<tr>
<td><strong>自旋超时</strong></td>
<td>膨胀为重量级锁</td>
<td>停止自旋</td>
<td>创建 Monitor，线程进入阻塞状态</td>
</tr>
</tbody>
</table>
<p><strong>HotSpot 中的实现细节：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 简化的轻量级锁获取逻辑（ObjectSynchronizer::slow_enter）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectSynchronizer::slow_enter</span><span class="hljs-params">(Handle obj, BasicLock* lock, TRAPS)</span> </span>&#123;<br>    markOop mark = obj-&gt;<span class="hljs-built_in">mark</span>();<br>    <br>    <span class="hljs-comment">// 检查是否是无锁状态</span><br>    <span class="hljs-keyword">if</span> (mark-&gt;<span class="hljs-built_in">is_neutral</span>()) &#123;<br>        <span class="hljs-comment">// 尝试 CAS 获取轻量级锁</span><br>        lock-&gt;<span class="hljs-built_in">set_displaced_header</span>(mark);<br>        <span class="hljs-keyword">if</span> (mark == <span class="hljs-built_in">obj</span>()-&gt;<span class="hljs-built_in">cas_set_mark</span>((markOop)lock, mark)) &#123;<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 获取成功</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 检查是否是锁重入</span><br>    <span class="hljs-keyword">if</span> (mark-&gt;<span class="hljs-built_in">has_locker</span>() &amp;&amp; <br>        THREAD-&gt;<span class="hljs-built_in">is_lock_owned</span>((address)mark-&gt;<span class="hljs-built_in">locker</span>())) &#123;<br>        lock-&gt;<span class="hljs-built_in">set_displaced_header</span>(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 锁重入</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// CAS 失败，需要自旋或膨胀</span><br>    <span class="hljs-comment">// 注意：这里会先尝试自旋</span><br>    ObjectSynchronizer::<span class="hljs-built_in">inflate</span>(THREAD, <span class="hljs-built_in">obj</span>())-&gt;<span class="hljs-built_in">enter</span>(THREAD);<br>&#125;<br><br><span class="hljs-comment">// inflate 方法会创建 Monitor，enter 方法会先自旋再阻塞</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectMonitor::enter</span><span class="hljs-params">(TRAPS)</span> </span>&#123;<br>    <span class="hljs-comment">// 快速路径：尝试 CAS 获取</span><br>    <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">cmpxchg</span>(Self, &amp;_owner, <span class="hljs-literal">NULL</span>) == <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 自旋尝试（在膨胀后仍会自旋！）</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">TrySpin</span>(Self) &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 自旋成功</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 自旋失败，进入阻塞</span><br>    <span class="hljs-built_in">EnterI</span>(THREAD);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>重要澄清：自旋发生在两个阶段</strong></p>
<ol>
<li><strong>轻量级锁阶段的自旋</strong>：CAS 失败后，在膨胀之前，会先进行一定次数的自旋重试</li>
<li><strong>重量级锁阶段的自旋</strong>：即使膨胀为重量级锁，在真正阻塞之前，<code>ObjectMonitor::enter()</code> 也会先自旋</li>
</ol>
<p>这意味着：<strong>线程从 CAS 失败到真正阻塞，中间会经历两轮自旋机会</strong>。</p>
<h4 id="偏向锁竞争：多线程场景详解">偏向锁竞争：多线程场景详解</h4>
<p>偏向锁的竞争场景比轻量级锁更复杂，因为涉及到<strong>偏向锁撤销</strong>这个需要安全点的操作。</p>
<p><strong>场景1：原偏向线程仍在同步块内，其他线程尝试获取锁</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 A（原偏向线程）
    participant OBJ as 锁对象
    participant T2 as 线程 B（竞争线程）
    participant VM as VM Thread
    
    Note over T1,OBJ: 初始状态：对象偏向线程 A
    
    T1-&gt;&gt;OBJ: 持有偏向锁，正在执行同步块
    Note over OBJ: Mark Word: threadId=A | 1 | 01
    
    T2-&gt;&gt;OBJ: 尝试获取锁
    T2-&gt;&gt;T2: 检查 Mark Word，发现偏向其他线程
    T2-&gt;&gt;VM: 请求撤销偏向锁
    
    Note over VM: 等待安全点（STW）
    VM-&gt;&gt;VM: 所有线程到达安全点
    
    VM-&gt;&gt;T1: 检查线程 A 的栈帧
    Note over VM: 发现线程 A 仍持有锁&lt;br/&gt;（栈帧中有对应的 Lock Record）
    
    VM-&gt;&gt;OBJ: 撤销偏向，升级为轻量级锁
    Note over OBJ: Mark Word: ptr_to_LR_A | 00&lt;br/&gt;（指向线程 A 的 Lock Record）
    
    VM-&gt;&gt;VM: 恢复所有线程
    
    T2-&gt;&gt;OBJ: 继续尝试获取轻量级锁
    T2-&gt;&gt;T2: CAS 失败（锁被 A 持有）
    T2-&gt;&gt;T2: 自旋等待...
    
    T1-&gt;&gt;OBJ: 释放锁（CAS 恢复 Mark Word）
    T2-&gt;&gt;OBJ: CAS 成功，获取轻量级锁</code></pre>
<p><strong>场景2：原偏向线程已退出同步块，其他线程尝试获取锁</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 A（原偏向线程）
    participant OBJ as 锁对象
    participant T2 as 线程 B（竞争线程）
    participant VM as VM Thread
    
    Note over T1,OBJ: 初始状态：对象偏向线程 A，但 A 已退出同步块
    
    Note over OBJ: Mark Word: threadId=A | 1 | 01&lt;br/&gt;（仍偏向 A，但 A 不在同步块内）
    
    T2-&gt;&gt;OBJ: 尝试获取锁
    T2-&gt;&gt;T2: 检查 Mark Word，发现偏向其他线程
    T2-&gt;&gt;VM: 请求撤销偏向锁
    
    Note over VM: 等待安全点（STW）
    VM-&gt;&gt;VM: 所有线程到达安全点
    
    VM-&gt;&gt;T1: 检查线程 A 的栈帧
    Note over VM: 发现线程 A 未持有锁&lt;br/&gt;（栈帧中没有对应的 Lock Record）
    
    alt 重偏向（Rebias）
        VM-&gt;&gt;OBJ: 将偏向锁重偏向到线程 B
        Note over OBJ: Mark Word: threadId=B | 1 | 01
        VM-&gt;&gt;VM: 恢复所有线程
        T2-&gt;&gt;T2: 获取偏向锁成功
    else 撤销偏向
        VM-&gt;&gt;OBJ: 撤销偏向，恢复为无锁状态
        Note over OBJ: Mark Word: hashCode | age | 0 | 01
        VM-&gt;&gt;VM: 恢复所有线程
        T2-&gt;&gt;OBJ: CAS 获取轻量级锁
        Note over OBJ: Mark Word: ptr_to_LR_B | 00
    end</code></pre>
<p><strong>场景3：多个线程同时竞争偏向锁</strong></p>
<p>这是最复杂的场景：假设对象偏向线程 A，此时线程 B、C、D 同时尝试获取锁。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;初始状态&quot;
        OBJ1[&quot;锁对象&lt;br/&gt;Mark Word: threadId=A | 1 | 01&lt;br/&gt;（偏向线程 A）&quot;]
        style OBJ1 fill:#fff9c4
    end
    
    subgraph &quot;多线程同时竞争&quot;
        T_A[&quot;线程 A&lt;br/&gt;（原偏向线程）&lt;br/&gt;可能在同步块内&lt;br/&gt;也可能已退出&quot;]
        T_B[&quot;线程 B&lt;br/&gt;尝试获取锁&quot;]
        T_C[&quot;线程 C&lt;br/&gt;尝试获取锁&quot;]
        T_D[&quot;线程 D&lt;br/&gt;尝试获取锁&quot;]
        
        style T_A fill:#c8e6c9
        style T_B fill:#e1f5ff
        style T_C fill:#e1f5ff
        style T_D fill:#e1f5ff
    end
    
    subgraph &quot;处理流程&quot;
        REVOKE[&quot;1. 触发偏向锁撤销&lt;br/&gt;（只会触发一次，由第一个检测到竞争的线程触发）&quot;]
        STW[&quot;2. 等待安全点（STW）&lt;br/&gt;所有线程暂停&quot;]
        CHECK[&quot;3. VM Thread 检查线程 A 的状态&quot;]
        
        UPGRADE[&quot;4. 升级为轻量级锁&lt;br/&gt;（如果 A 仍持有锁）&lt;br/&gt;或恢复为无锁状态&lt;br/&gt;（如果 A 已释放锁）&quot;]
        
        RESUME[&quot;5. 恢复所有线程&quot;]
        
        COMPETE[&quot;6. B、C、D 同时竞争轻量级锁&lt;br/&gt;只有一个能 CAS 成功&lt;br/&gt;其他线程自旋等待&quot;]
        
        INFLATE[&quot;7. 如果竞争激烈&lt;br/&gt;膨胀为重量级锁&lt;br/&gt;失败的线程进入等待队列&quot;]
        
        style REVOKE fill:#fff9c4
        style STW fill:#ffcdd2
        style COMPETE fill:#e1f5ff
        style INFLATE fill:#ffcdd2
    end
    
    OBJ1 --&gt; REVOKE
    T_B --&gt; REVOKE
    T_C --&gt; REVOKE
    T_D --&gt; REVOKE
    REVOKE --&gt; STW
    STW --&gt; CHECK
    CHECK --&gt; UPGRADE
    UPGRADE --&gt; RESUME
    RESUME --&gt; COMPETE
    COMPETE --&gt; INFLATE</code></pre>
<p><strong>多线程竞争的关键点：</strong></p>
<table>
<thead>
<tr>
<th>问题</th>
<th>答案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>谁触发偏向锁撤销？</strong></td>
<td>第一个检测到竞争的线程。其他线程会等待撤销完成。</td>
</tr>
<tr>
<td><strong>撤销期间其他线程在做什么？</strong></td>
<td>等待安全点。所有线程都会在安全点暂停。</td>
</tr>
<tr>
<td><strong>撤销后谁能获得锁？</strong></td>
<td>取决于原偏向线程的状态。如果原线程仍持有锁，它会继续持有（升级为轻量级锁）；如果原线程已释放，则竞争线程通过 CAS 竞争。</td>
</tr>
<tr>
<td><strong>多个竞争线程如何排序？</strong></td>
<td>轻量级锁阶段没有排序，谁 CAS 成功谁获得锁。膨胀为重量级锁后，由 Monitor 的等待队列管理。</td>
</tr>
</tbody>
</table>
<h4 id="批量重偏向与批量撤销">批量重偏向与批量撤销</h4>
<p>当一个类的对象频繁发生偏向锁撤销时，JVM 会采取更激进的策略：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;批量操作的触发条件&quot;
        SINGLE[&quot;单次撤销&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;某个对象的偏向锁被撤销&lt;br/&gt;计数器 +1&quot;]
        
        THRESHOLD1&#123;&quot;撤销次数 ≥ 20?&lt;br/&gt;（BiasedLockingBulkRebiasThreshold）&quot;&#125;
        
        BULK_REBIAS[&quot;批量重偏向&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;该类的 epoch +1&lt;br/&gt;后续该类的对象可以重偏向&lt;br/&gt;到新的线程&quot;]
        
        THRESHOLD2&#123;&quot;撤销次数 ≥ 40?&lt;br/&gt;（BiasedLockingBulkRevokeThreshold）&quot;&#125;
        
        BULK_REVOKE[&quot;批量撤销&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;禁用该类的偏向锁&lt;br/&gt;该类的所有对象直接使用轻量级锁&quot;]
        
        SINGLE --&gt; THRESHOLD1
        THRESHOLD1 --&gt;|否| SINGLE
        THRESHOLD1 --&gt;|是| BULK_REBIAS
        BULK_REBIAS --&gt; THRESHOLD2
        THRESHOLD2 --&gt;|否| SINGLE
        THRESHOLD2 --&gt;|是| BULK_REVOKE
        
        style SINGLE fill:#c8e6c9
        style BULK_REBIAS fill:#fff9c4
        style BULK_REVOKE fill:#ffcdd2
    end</code></pre>
<p><strong>epoch 机制详解：</strong></p>
<p>每个类都有一个 <code>epoch</code> 值，每个偏向锁对象的 Mark Word 中也存储了一个 <code>epoch</code> 值。当发生批量重偏向时：</p>
<ol>
<li>类的 <code>epoch</code> 值 +1</li>
<li>当线程尝试获取偏向锁时，会比较对象的 <code>epoch</code> 和类的 <code>epoch</code></li>
<li>如果不相等，说明对象的偏向锁已&quot;过期&quot;，可以直接重偏向到当前线程，无需撤销</li>
</ol>
<p>这个机制避免了频繁的偏向锁撤销开销。</p>
<h3 id="锁升级流程总结">锁升级流程总结</h3>
<p>综合以上所有内容，我们可以总结出 synchronized 锁的完整升级流程：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">无锁 → 偏向锁 → 轻量级锁 → 重量级锁<br></code></pre></td></tr></table></figure>
<p><strong>锁升级的触发条件：</strong></p>
<table>
<thead>
<tr>
<th>当前状态</th>
<th>升级条件</th>
<th>目标状态</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>无锁</strong></td>
<td>第一个线程获取锁</td>
<td>偏向锁</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>第二个线程尝试获取锁（竞争）</td>
<td>轻量级锁</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>调用 <code>hashCode()</code></td>
<td>轻量级锁或重量级锁</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>CAS 自旋超过阈值</td>
<td>重量级锁</td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>调用 <code>wait()</code>/<code>notify()</code></td>
<td>重量级锁</td>
</tr>
</tbody>
</table>
<p><strong>关键理解：</strong></p>
<ol>
<li><strong>锁只能升级，不能降级</strong>：一旦升级为重量级锁，即使竞争消失，也不会降级回轻量级锁或偏向锁</li>
<li><strong>偏向锁撤销需要安全点</strong>：偏向锁的撤销是一个 STW 操作，需要等待所有线程到达安全点</li>
<li><strong>轻量级锁膨胀是即时的</strong>：轻量级锁膨胀为重量级锁不需要等待安全点，可以立即进行</li>
</ol>
<h2 id="安全点-safepoint-：从锁问题诊断到-jvm-底层机制">安全点（Safepoint）：从锁问题诊断到 JVM 底层机制</h2>
<h3 id="引子：锁问题诊断与日志分析">引子：锁问题诊断与日志分析</h3>
<p>在前面的章节中，我们深入探讨了 synchronized 的锁升级机制：偏向锁、轻量级锁、重量级锁。理论知识只是第一步——<strong>当生产系统出现锁相关的性能问题时，诊断和定位的主要手段是查看日志</strong>。</p>
<p>但这里有一个关键的认知：<strong>锁的运行时行为，大部分是&quot;静默&quot;的</strong>。</p>
<table>
<thead>
<tr>
<th>锁操作</th>
<th>是否有日志</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁获取/释放</td>
<td>无</td>
<td>仅比较 threadId，零开销操作</td>
</tr>
<tr>
<td>轻量级锁 CAS</td>
<td>无</td>
<td>用户态原子指令，不涉及 JVM 状态切换</td>
</tr>
<tr>
<td>重量级锁获取/释放</td>
<td>无</td>
<td>虽然涉及 Monitor，但记录日志开销太大</td>
</tr>
<tr>
<td><strong>偏向锁撤销</strong></td>
<td>有</td>
<td>必须触发安全点，这是一个&quot;重&quot;操作</td>
</tr>
<tr>
<td><strong>锁膨胀</strong></td>
<td>有限</td>
<td>可通过 <code>-Xlog:monitorinflation</code> 观察</td>
</tr>
</tbody>
</table>
<p>从中可以观察到一个规律：<strong>只有那些需要&quot;暂停世界&quot;的锁操作，才会留下日志痕迹</strong>。</p>
<p>偏向锁撤销需要暂停世界并出现在日志中的原因，与 JVM 的一个底层机制密切相关——<strong>安全点（Safepoint）</strong>。</p>
<h3 id="日志与安全点的关系">日志与安全点的关系</h3>
<p>从一个具体的日志条目开始分析：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[0.452s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Entering</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span>: <span class="hljs-selector-tag">RevokeBias</span><br><span class="hljs-selector-attr">[0.453s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Leaving</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span><br><span class="hljs-selector-attr">[0.453s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Total</span> <span class="hljs-selector-tag">time</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">which</span> <span class="hljs-selector-tag">application</span> <span class="hljs-selector-tag">threads</span> <span class="hljs-selector-tag">were</span> <span class="hljs-selector-tag">stopped</span>: <span class="hljs-number">0.0008350</span> <span class="hljs-selector-tag">seconds</span><br></code></pre></td></tr></table></figure>
<p>这条日志告诉我们：</p>
<ol>
<li>JVM 进入了一个安全点区域</li>
<li>触发安全点的原因是 <code>RevokeBias</code>（撤销偏向锁）</li>
<li>所有应用线程被暂停了 0.8 毫秒</li>
</ol>
<p><strong>关键洞察：偏向锁撤销之所以有日志，是因为它必须触发安全点。安全点是 JVM 的&quot;全局暂停&quot;机制，任何触发安全点的操作都会被记录。</strong></p>
<p>讨论锁的日志诊断必须先理解安全点，两者的关系如下：</p>
<pre><code class="hljs mermaid">graph LR
    LOCK[&quot;锁问题诊断&quot;]
    LOG[&quot;查看日志&quot;]
    SP[&quot;理解安全点&quot;]
    ROOT[&quot;定位根因&quot;]
    
    LOCK --&gt;|&quot;第一步&quot;| LOG
    LOG --&gt;|&quot;发现 RevokeBias&quot;| SP
    SP --&gt;|&quot;理解机制&quot;| ROOT
    
    style LOCK fill:#e1f5ff
    style LOG fill:#fff9c4
    style SP fill:#ffcdd2
    style ROOT fill:#c8e6c9</code></pre>
<p>下面深入分析安全点的工作原理。</p>
<h3 id="安全点的本质：jvm-的-红绿灯">安全点的本质：JVM 的&quot;红绿灯&quot;</h3>
<p><strong>安全点是什么？</strong></p>
<p>想象一个十字路口：当交通灯变红时，所有车辆都必须停下来，让行人（或其他方向的车辆）安全通过。安全点就是 JVM 的&quot;红绿灯&quot;——当 JVM 需要执行某些全局操作时，它会&quot;亮红灯&quot;，让所有应用线程暂停。</p>
<p><strong>安全点的必要性</strong></p>
<p>GC 需要遍历堆中的所有对象，标记哪些是存活的、哪些是垃圾。但<strong>应用线程还在不断地修改对象引用</strong>——创建新对象、修改字段、调用方法。如果 GC 在遍历的同时，应用线程修改了对象引用，GC 看到的就是一个&quot;不一致&quot;的堆状态，可能会错误地回收存活对象，或者遗漏垃圾对象。</p>
<p>这就像你在数一群不断移动的羊——你数到第 50 只的时候，第 30 只可能已经跑到第 60 只的位置了。</p>
<p><strong>解决方案有两种思路：</strong></p>
<ol>
<li>
<p><strong>并发标记 + 写屏障</strong>：让 GC 和应用线程并发执行，通过写屏障（Write Barrier）记录引用的变化。这是 G1、ZGC、Shenandoah 等现代 GC 的做法，但实现复杂，且某些阶段仍需要 STW。</p>
</li>
<li>
<p><strong>Stop-The-World（STW）</strong>：让所有应用线程暂停，GC 独占 CPU 完成工作。这是最简单、最可靠的方式，但会造成应用停顿。</p>
</li>
</ol>
<p><strong>安全点就是实现 STW 的机制。</strong> 但这里有一个关键的洞察：</p>
<blockquote>
<p><strong>STW 依赖安全点实现，但安全点不只是为 GC 服务。</strong></p>
</blockquote>
<p>安全点是一个<strong>通用的线程协调机制</strong>，GC 只是它最常见的使用者之一。</p>
<h3 id="安全点的本质：线程状态的一致性快照">安全点的本质：线程状态的一致性快照</h3>
<p><strong>安全点的定义：</strong> 程序执行过程中的一个特定位置，在这个位置上，线程的状态是<strong>完全可描述的</strong>——所有的寄存器、栈帧、局部变量、锁状态都处于一个&quot;干净&quot;的状态，JVM 可以安全地检查和修改它们。</p>
<p>换句话说，安全点是线程的一个&quot;可拍照&quot;时刻。在这个时刻：</p>
<ul>
<li>所有 GC Roots（栈上的对象引用）都是可枚举的</li>
<li>所有锁的持有状态都是明确的</li>
<li>所有 JIT 编译的代码都可以被安全地去优化</li>
</ul>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;安全点的本质&quot;
        direction TB
        
        RUNNING[&quot;线程正在执行&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;寄存器、栈帧状态不断变化&lt;br/&gt;对象引用可能在寄存器中&lt;br/&gt;JVM 无法安全地检查线程状态&quot;]
        
        SAFEPOINT[&quot;到达安全点&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;所有对象引用都在已知位置&lt;br/&gt;（栈帧、OopMap 描述的位置）&lt;br/&gt;线程状态完全可描述&quot;]
        
        BLOCKED[&quot;线程阻塞在安全点&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;等待 VM 操作完成&lt;br/&gt;状态被&quot;冻结&quot;&quot;]
        
        RUNNING --&gt;|&quot;执行到安全点位置&quot;| SAFEPOINT
        SAFEPOINT --&gt;|&quot;响应 VM 请求&quot;| BLOCKED
        BLOCKED --&gt;|&quot;VM 操作完成&quot;| RUNNING
        
        style RUNNING fill:#fff9c4
        style SAFEPOINT fill:#c8e6c9
        style BLOCKED fill:#ffcdd2
    end</code></pre>
<h3 id="安全点在哪里？">安全点在哪里？</h3>
<p>JVM 不会在每条字节码指令后都插入安全点检查——那样开销太大。安全点只会出现在以下位置：</p>
<table>
<thead>
<tr>
<th>安全点位置</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>方法调用/返回</strong></td>
<td>方法边界是自然的状态一致点</td>
</tr>
<tr>
<td><strong>循环的回边（back edge）</strong></td>
<td>防止长时间运行的循环阻塞安全点（见下文详解）</td>
</tr>
<tr>
<td><strong>异常抛出点</strong></td>
<td>异常处理需要完整的栈状态</td>
</tr>
<tr>
<td><strong>JNI 调用返回</strong></td>
<td>从 native 代码返回时需要同步状态</td>
</tr>
<tr>
<td><strong>线程阻塞点</strong></td>
<td><code>Object.wait()</code>、<code>Thread.sleep()</code>、锁等待等</td>
</tr>
</tbody>
</table>
<p><strong>什么是循环的回边（Back Edge）？</strong></p>
<p>在控制流图（Control Flow Graph）中，<strong>回边</strong>是指从循环体末尾跳回到循环头部的边。简单来说，就是循环每次迭代结束、准备开始下一次迭代时的那个&quot;跳转点&quot;。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">┌─────────────────────────────────────────────────────────────┐<br>│  for (int i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;                              │<br>│      <span class="hljs-built_in">doSomething</span>();                                          │<br>│  &#125;  <span class="hljs-comment">// ← 这里就是回边：i++ 之后跳回到 i &lt; n 的判断           │</span><br>│      ↑                                                       │<br>│      └── 回边（Back Edge）：从循环末尾跳回循环头部            │<br>└─────────────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<p>JVM 在回边处插入安全点检查的原因是：<strong>如果一个循环执行时间很长，而循环内部没有方法调用，那么线程可能长时间无法到达安全点</strong>。在回边处插入检查，可以确保每次循环迭代都有机会响应安全点请求。</p>
<p>但这里有一个重要的例外——<strong>可数循环（Counted Loop）</strong>：</p>
<p><strong>关键问题：可数循环（Counted Loop）的陷阱</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个循环可能导致安全点延迟！</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1_000_000_000</span>; i++) &#123;<br>    sum += array[i];  <span class="hljs-comment">// 没有方法调用，没有安全点</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>JIT 编译器会将这种&quot;可数循环&quot;（循环次数在编译时可确定）优化为不包含安全点检查的紧凑代码。这意味着如果 GC 请求 STW，必须等待这个循环执行完毕。这就是著名的 <strong>“Time To Safepoint”（TTSP）问题</strong>。</p>
<h3 id="安全点的工作机制">安全点的工作机制</h3>
<pre><code class="hljs mermaid">sequenceDiagram
    participant VMThread as VM Thread
    participant Polling as Polling Page
    participant T1 as App Thread 1
    participant T2 as App Thread 2
    participant T3 as App Thread 3
    
    Note over VMThread: 需要执行 VM 操作&lt;br/&gt;（如 GC、偏向锁撤销）
    
    VMThread-&gt;&gt;Polling: 1. 设置 Polling Page 为不可读
    Note over Polling: 内存保护位变更
    
    par 并行检测
        T1-&gt;&gt;Polling: 2a. 读取 Polling Page
        Polling--&gt;&gt;T1: SIGSEGV 信号
        T1-&gt;&gt;T1: 进入安全点，阻塞
        
        T2-&gt;&gt;Polling: 2b. 读取 Polling Page
        Polling--&gt;&gt;T2: SIGSEGV 信号
        T2-&gt;&gt;T2: 进入安全点，阻塞
        
        T3-&gt;&gt;Polling: 2c. 读取 Polling Page
        Polling--&gt;&gt;T3: SIGSEGV 信号
        T3-&gt;&gt;T3: 进入安全点，阻塞
    end
    
    Note over VMThread: 3. 所有线程已到达安全点&lt;br/&gt;STW 开始
    
    VMThread-&gt;&gt;VMThread: 4. 执行 VM 操作&lt;br/&gt;（GC / 偏向锁撤销 / 去优化...）
    
    VMThread-&gt;&gt;Polling: 5. 恢复 Polling Page 为可读
    
    par 并行恢复
        T1-&gt;&gt;T1: 6a. 离开安全点，继续执行
        T2-&gt;&gt;T2: 6b. 离开安全点，继续执行
        T3-&gt;&gt;T3: 6c. 离开安全点，继续执行
    end
    
    Note over VMThread: STW 结束</code></pre>
<p><strong>Polling Page 机制详解：</strong></p>
<p>HotSpot 使用一种巧妙的&quot;陷阱&quot;机制来实现安全点检查：</p>
<ol>
<li><strong>正常状态</strong>：Polling Page 是一个可读的内存页，线程周期性地读取它（在安全点位置插入读取指令）</li>
<li><strong>请求 STW</strong>：VM Thread 将 Polling Page 设置为不可读（通过 <code>mprotect</code> 系统调用）</li>
<li><strong>触发信号</strong>：当应用线程读取不可读的内存页时，会触发 <code>SIGSEGV</code>（段错误）信号</li>
<li><strong>信号处理</strong>：JVM 的信号处理器捕获这个信号，让线程进入安全点并阻塞</li>
<li><strong>恢复执行</strong>：VM 操作完成后，恢复 Polling Page 为可读，唤醒所有线程</li>
</ol>
<p>这种设计的精妙之处在于：<strong>正常情况下，安全点检查只是一次内存读取，开销极小</strong>（通常在 L1 缓存命中）。只有在需要 STW 时，才会触发信号处理的开销。</p>
<h3 id="需要安全点的-vm-操作">需要安全点的 VM 操作</h3>
<p>GC 是最常见的安全点使用者，但远不是唯一的。以下是 HotSpot 中需要安全点的主要操作：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;需要 Safepoint 的 VM 操作&quot;
        direction TB
        
        subgraph &quot;GC 相关&quot;
            GC1[&quot;Young GC&quot;]
            GC2[&quot;Full GC&quot;]
            GC3[&quot;并发 GC 的 STW 阶段&lt;br/&gt;（初始标记、最终标记等）&quot;]
        end
        
        subgraph &quot;锁相关&quot;
            LOCK1[&quot;RevokeBias&lt;br/&gt;撤销单个对象的偏向锁&quot;]
            LOCK2[&quot;BulkRevokeBias&lt;br/&gt;批量撤销偏向锁&quot;]
            LOCK3[&quot;EnableBiasedLocking&lt;br/&gt;启用偏向锁（JVM 启动后延迟）&quot;]
        end
        
        subgraph &quot;代码相关&quot;
            CODE1[&quot;Deoptimize&lt;br/&gt;JIT 代码去优化&quot;]
            CODE2[&quot;IC_Stub_Invalidate&lt;br/&gt;内联缓存失效&quot;]
            CODE3[&quot;CodeCache_Flush&lt;br/&gt;代码缓存清理&quot;]
        end
        
        subgraph &quot;类相关&quot;
            CLASS1[&quot;ClassRedefinition&lt;br/&gt;热替换（JVMTI）&quot;]
            CLASS2[&quot;ClassUnloading&lt;br/&gt;类卸载&quot;]
        end
        
        subgraph &quot;诊断相关&quot;
            DIAG1[&quot;ThreadDump&lt;br/&gt;线程转储（jstack）&quot;]
            DIAG2[&quot;HeapDump&lt;br/&gt;堆转储&quot;]
            DIAG3[&quot;PrintThreads&lt;br/&gt;打印线程信息&quot;]
        end
        
        style GC1 fill:#ffcdd2
        style GC2 fill:#ffcdd2
        style GC3 fill:#ffcdd2
        style LOCK1 fill:#fff9c4
        style LOCK2 fill:#fff9c4
        style LOCK3 fill:#fff9c4
        style CODE1 fill:#c8e6c9
        style CODE2 fill:#c8e6c9
        style CODE3 fill:#c8e6c9
        style CLASS1 fill:#e1f5ff
        style CLASS2 fill:#e1f5ff
        style DIAG1 fill:#e1bee7
        style DIAG2 fill:#e1bee7
        style DIAG3 fill:#e1bee7
    end</code></pre>
<table>
<thead>
<tr>
<th>操作类别</th>
<th>典型操作</th>
<th>为什么需要安全点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>GC</strong></td>
<td>Young GC、Full GC、并发 GC 的 STW 阶段</td>
<td>需要枚举所有 GC Roots，确保堆状态一致</td>
</tr>
<tr>
<td><strong>偏向锁</strong></td>
<td>RevokeBias、BulkRevokeBias</td>
<td>需要修改对象头，遍历线程栈查找 Lock Record</td>
</tr>
<tr>
<td><strong>代码去优化</strong></td>
<td>Deoptimize</td>
<td>需要将 JIT 编译的栈帧转换为解释器栈帧</td>
</tr>
<tr>
<td><strong>类重定义</strong></td>
<td>ClassRedefinition（热替换）</td>
<td>需要更新所有引用该类的代码和对象</td>
</tr>
<tr>
<td><strong>诊断</strong></td>
<td>ThreadDump、HeapDump</td>
<td>需要获取所有线程的一致状态快照</td>
</tr>
</tbody>
</table>
<h3 id="安全点-vs-安全区域">安全点 vs 安全区域</h3>
<p>除了安全点，还有一个相关概念——<strong>安全区域（Safe Region）</strong>。</p>
<p>如果一个线程正在 <code>Thread.sleep()</code> 或等待 I/O，它不会执行代码，也就不会到达安全点。此时 VM Thread 不需要等待它，因为存在<strong>安全区域</strong>机制：当线程进入阻塞状态时，它会标记自己处于&quot;安全区域&quot;。在安全区域内，线程不会修改任何对象引用，因此 GC 可以安全地进行。</p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;安全点 vs 安全区域&quot;
        SP[&quot;安全点（Safepoint）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;代码中的特定位置&lt;br/&gt;线程主动检查并响应&lt;br/&gt;适用于正在执行的线程&quot;]
        
        SR[&quot;安全区域（Safe Region）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;一段代码区间&lt;br/&gt;线程进入时标记，离开时检查&lt;br/&gt;适用于阻塞的线程&quot;]
        
        SP ---|&quot;互补关系&quot;| SR
        
        style SP fill:#c8e6c9
        style SR fill:#e1f5ff
    end</code></pre>
<h3 id="thread-handshake：更细粒度的线程协调">Thread Handshake：更细粒度的线程协调</h3>
<p>传统的安全点是<strong>全局的</strong>——要么所有线程都停，要么都不停。但有些操作只需要停止特定的线程，全局 STW 就显得过于&quot;重&quot;了。</p>
<p><strong>JEP 312: Thread-Local Handshakes</strong>（JDK 10 引入）解决了这个问题：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;全局 Safepoint vs Thread Handshake&quot;
        direction LR
        
        subgraph &quot;全局 Safepoint&quot;
            GS_VM[&quot;VM Thread&quot;]
            GS_T1[&quot;Thread 1 (暂停)&quot;]
            GS_T2[&quot;Thread 2 (暂停)&quot;]
            GS_T3[&quot;Thread 3 (暂停)&quot;]
            GS_T4[&quot;Thread 4 (暂停)&quot;]
            
            GS_VM --&gt;|&quot;停止所有线程&quot;| GS_T1
            GS_VM --&gt;|&quot;停止所有线程&quot;| GS_T2
            GS_VM --&gt;|&quot;停止所有线程&quot;| GS_T3
            GS_VM --&gt;|&quot;停止所有线程&quot;| GS_T4
            
            style GS_T1 fill:#ffcdd2
            style GS_T2 fill:#ffcdd2
            style GS_T3 fill:#ffcdd2
            style GS_T4 fill:#ffcdd2
        end
        
        subgraph &quot;Thread Handshake&quot;
            TH_VM[&quot;VM Thread&quot;]
            TH_T1[&quot;Thread 1 (暂停)&quot;]
            TH_T2[&quot;Thread 2 (运行)&quot;]
            TH_T3[&quot;Thread 3 (运行)&quot;]
            TH_T4[&quot;Thread 4 (运行)&quot;]
            
            TH_VM --&gt;|&quot;只停止目标线程&quot;| TH_T1
            
            style TH_T1 fill:#ffcdd2
            style TH_T2 fill:#c8e6c9
            style TH_T3 fill:#c8e6c9
            style TH_T4 fill:#c8e6c9
        end
    end</code></pre>
<p>Thread Handshake 允许 VM 对单个线程执行操作，而不影响其他线程。这对于以下场景特别有用：</p>
<ul>
<li>单个线程的栈遍历</li>
<li>单个对象的偏向锁撤销（JDK 15+ 的改进）</li>
<li>线程局部的去优化</li>
</ul>
<h3 id="安全点与锁的关系">安全点与锁的关系</h3>
<p><strong>STW 与安全点的关系：</strong> STW 的本质就是让所有应用线程到达安全点并阻塞。</p>
<p><strong>安全点的适用范围：</strong> 安全点是一个通用的线程协调机制，GC 只是最常见的使用者。偏向锁撤销、代码去优化、类重定义、线程转储等都需要安全点。</p>
<p><strong>偏向锁撤销需要安全点的原因：</strong></p>
<ol>
<li>修改对象头（Mark Word）</li>
<li>遍历偏向线程的栈帧，查找 Lock Record</li>
<li>确保没有线程正在使用这个锁</li>
</ol>
<p>这些操作必须在目标线程&quot;静止&quot;的状态下进行，否则会出现竞态条件。</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;偏向锁撤销为什么需要安全点&quot;
        direction TB
        
        OBJ[&quot;锁对象&lt;br/&gt;Mark Word: threadId | 1 | 01&lt;br/&gt;（偏向线程 A）&quot;]
        
        TA[&quot;线程 A（偏向线程）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;可能正在执行 synchronized 块&lt;br/&gt;栈帧中可能有 Lock Record&quot;]
        
        TB[&quot;线程 B（竞争者）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;尝试获取锁&lt;br/&gt;触发偏向锁撤销&quot;]
        
        VM[&quot;VM Thread&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;执行 RevokeBias 操作&quot;]
        
        TB --&gt;|&quot;1. 发现锁被偏向&quot;| OBJ
        TB --&gt;|&quot;2. 请求撤销偏向&quot;| VM
        VM --&gt;|&quot;3. 触发安全点&quot;| TA
        TA --&gt;|&quot;4. 到达安全点，阻塞&quot;| TA
        VM --&gt;|&quot;5. 遍历线程 A 的栈帧&quot;| TA
        VM --&gt;|&quot;6. 修改 Mark Word&quot;| OBJ
        
        style OBJ fill:#fff9c4
        style TA fill:#ffcdd2
        style TB fill:#e1f5ff
        style VM fill:#c8e6c9
    end</code></pre>
<p>这也解释了为什么偏向锁在 JDK 15 被废弃——每次偏向锁撤销都需要全局安全点，在高并发场景下，频繁的安全点会严重影响性能。</p>
<p>偏向锁在 JVM 内部的实现实在太复杂了，<a target="_blank" rel="noopener" href="https://blog.csdn.net/guanshengg/article/details/126435955">从 Java 15 开始要逐步 deprecated</a>。偏向锁的废弃历程如下：</p>
<table>
<thead>
<tr>
<th>JDK 版本</th>
<th>偏向锁状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>JDK 6 ~ JDK 14</strong></td>
<td>默认开启</td>
<td>需要 <code>-XX:-UseBiasedLocking</code> 显式关闭</td>
</tr>
<tr>
<td><strong>JDK 15</strong></td>
<td>默认关闭</td>
<td>JEP 374 将其标记为废弃，需要 <code>-XX:+UseBiasedLocking</code> 显式开启</td>
</tr>
<tr>
<td><strong>JDK 18+</strong></td>
<td>已移除</td>
<td>相关代码已从 HotSpot 中删除，启动参数无效</td>
</tr>
</tbody>
</table>
<p>废弃偏向锁的主要原因：</p>
<ol>
<li><strong>实现复杂度高</strong>：偏向锁的撤销（revocation）需要在安全点（safepoint）进行，涉及复杂的栈遍历和对象头修改</li>
<li><strong>维护成本大</strong>：偏向锁的代码与 HotSpot 的其他子系统（如 GC、栈遍历）深度耦合，增加了代码维护难度</li>
<li><strong>收益递减</strong>：现代应用中，无竞争的同步场景越来越少，偏向锁的优化收益不再显著</li>
<li><strong>替代方案成熟</strong>：轻量级锁的 CAS 操作在现代 CPU 上已经足够高效</li>
</ol>
<p>在日常的 JVM 调优中，很多团队为了避免偏向锁撤销带来的性能抖动，也会主动关闭偏向锁。</p>
<h3 id="锁相关的-jvm-日志诊断">锁相关的 JVM 日志诊断</h3>
<p>锁的状态切换（尤其是偏向锁撤销和锁膨胀）会触发 <strong>Safepoint</strong>（安全点），导致所有应用线程暂停。通过 JVM 日志可以诊断这些问题。</p>
<p><strong>JDK 8 及之前版本的日志参数：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打印安全点统计信息</span><br>-XX:+PrintSafepointStatistics -XX:PrintSafepointStatisticsCount=1<br><br><span class="hljs-comment"># 追踪偏向锁行为（仅限 debug 版本或开启诊断选项）</span><br>-XX:+UnlockDiagnosticVMOptions -XX:+TraceBiasedLocking<br></code></pre></td></tr></table></figure>
<p><strong>JDK 9+ 的 Unified Logging（统一日志）：</strong></p>
<p>JDK 9 引入了 <a target="_blank" rel="noopener" href="https://openjdk.org/jeps/158">JEP 158: Unified JVM Logging</a>，所有 JVM 日志统一使用 <code>-Xlog</code> 语法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 打印安全点日志（info 级别）</span><br>-Xlog:safepoint=info<br><br><span class="hljs-comment"># 打印安全点详细日志（debug 级别，包含更多细节）</span><br>-Xlog:safepoint=debug<br><br><span class="hljs-comment"># 同时输出到文件，带时间戳和线程 ID</span><br>-Xlog:safepoint=debug:file=safepoint.log:<span class="hljs-keyword">time</span>,tid,level,tags<br></code></pre></td></tr></table></figure>
<p><strong>典型的安全点日志输出示例：</strong></p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[0.452s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Application</span> <span class="hljs-selector-tag">time</span>: <span class="hljs-number">0.1950250</span> <span class="hljs-selector-tag">seconds</span><br><span class="hljs-selector-attr">[0.452s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Entering</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span>: <span class="hljs-selector-tag">RevokeBias</span><br><span class="hljs-selector-attr">[0.453s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Leaving</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span><br><span class="hljs-selector-attr">[0.453s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Total</span> <span class="hljs-selector-tag">time</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">which</span> <span class="hljs-selector-tag">application</span> <span class="hljs-selector-tag">threads</span> <span class="hljs-selector-tag">were</span> <span class="hljs-selector-tag">stopped</span>: <span class="hljs-number">0.0008350</span> <span class="hljs-selector-tag">seconds</span><br></code></pre></td></tr></table></figure>
<p><strong>常见的锁相关 Safepoint 操作（vmop）：</strong></p>
<table>
<thead>
<tr>
<th>Safepoint 操作</th>
<th>含义</th>
<th>触发场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RevokeBias</strong></td>
<td>撤销单个对象的偏向锁</td>
<td>偏向锁对象被其他线程访问</td>
</tr>
<tr>
<td><strong>BulkRevokeBias</strong></td>
<td>批量撤销某个类的所有对象的偏向锁</td>
<td>某个类的对象频繁发生偏向锁撤销，触发批量撤销阈值</td>
</tr>
<tr>
<td><strong>EnableBiasedLocking</strong></td>
<td>启用偏向锁</td>
<td>JVM 启动后延迟启用偏向锁（默认延迟 4 秒）</td>
</tr>
<tr>
<td><strong>Deoptimize</strong></td>
<td>去优化</td>
<td>JIT 编译的代码需要回退到解释执行</td>
</tr>
<tr>
<td><strong>G1IncCollectionPause</strong></td>
<td>G1 增量收集暂停</td>
<td>G1 GC 的 Young GC</td>
</tr>
<tr>
<td><strong>CGC_Operation</strong></td>
<td>并发 GC 操作</td>
<td>CMS/G1 的并发标记等阶段</td>
</tr>
</tbody>
</table>
<p><strong>诊断偏向锁性能问题的实战示例：</strong></p>
<p>如果你在日志中看到大量短暂但频繁的 <code>RevokeBias</code> 安全点：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-attr">[8501.234s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Entering</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span>: <span class="hljs-selector-tag">RevokeBias</span><br><span class="hljs-selector-attr">[8501.234s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Leaving</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span><br><span class="hljs-selector-attr">[8501.234s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Total</span> <span class="hljs-selector-tag">time</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">which</span> <span class="hljs-selector-tag">application</span> <span class="hljs-selector-tag">threads</span> <span class="hljs-selector-tag">were</span> <span class="hljs-selector-tag">stopped</span>: <span class="hljs-number">0.0001420</span> <span class="hljs-selector-tag">seconds</span><br><span class="hljs-selector-attr">[8501.278s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Entering</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span>: <span class="hljs-selector-tag">RevokeBias</span><br><span class="hljs-selector-attr">[8501.278s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Leaving</span> <span class="hljs-selector-tag">safepoint</span> <span class="hljs-selector-tag">region</span><br><span class="hljs-selector-attr">[8501.278s]</span><span class="hljs-selector-attr">[info]</span><span class="hljs-selector-attr">[safepoint]</span> <span class="hljs-selector-tag">Total</span> <span class="hljs-selector-tag">time</span> <span class="hljs-selector-tag">for</span> <span class="hljs-selector-tag">which</span> <span class="hljs-selector-tag">application</span> <span class="hljs-selector-tag">threads</span> <span class="hljs-selector-tag">were</span> <span class="hljs-selector-tag">stopped</span>: <span class="hljs-number">0.0001380</span> <span class="hljs-selector-tag">seconds</span><br></code></pre></td></tr></table></figure>
<p>虽然每次暂停时间很短（约 0.1ms），但如果每秒发生数百次，累积的停顿时间就会显著影响应用的吞吐量和延迟。此时应考虑：</p>
<ol>
<li><strong>关闭偏向锁</strong>：<code>-XX:-UseBiasedLocking</code>（JDK 15+ 默认已关闭）</li>
<li><strong>分析锁竞争</strong>：使用 <code>jstack</code> 或 JFR（Java Flight Recorder）分析哪些锁存在竞争</li>
<li><strong>优化代码</strong>：减少锁的粒度或使用无锁数据结构</li>
</ol>
<p><strong>JDK 17+ 的注意事项：</strong></p>
<p>由于偏向锁在 JDK 15 被废弃、JDK 18 被移除，在 JDK 17+ 中你将不再看到 <code>RevokeBias</code> 和 <code>BulkRevokeBias</code> 相关的安全点日志。取而代之的是更多的轻量级锁 CAS 操作，这些操作不需要安全点，因此不会出现在安全点日志中。</p>
<h3 id="各种锁优化的可观测性对比">各种锁优化的可观测性对比</h3>
<p>除了偏向锁，其他锁优化<strong>大部分没有直接的运行时日志</strong>，因为它们要么发生在编译期，要么是纯用户态操作。</p>
<table>
<thead>
<tr>
<th>锁优化类型</th>
<th>是否有 JVM 日志</th>
<th>原因</th>
<th>观测方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>偏向锁</strong></td>
<td>有（间接）</td>
<td>偏向锁撤销<strong>必须在安全点进行</strong>，需要暂停所有线程修改对象头</td>
<td>Safepoint 日志：<code>RevokeBias</code>、<code>BulkRevokeBias</code></td>
</tr>
<tr>
<td><strong>轻量级锁</strong></td>
<td>无</td>
<td>纯 CAS 操作，用户态原子指令，不涉及 JVM 状态切换</td>
<td><code>jstack</code> 查看线程状态；JFR 记录锁竞争事件</td>
</tr>
<tr>
<td><strong>重量级锁</strong></td>
<td>有限</td>
<td>Monitor 膨胀/收缩可记录，但锁的获取/释放本身无日志</td>
<td><code>-Xlog:monitorinflation=debug</code>（JDK 11+）；<code>jstack</code> 查看 <code>BLOCKED</code> 状态</td>
</tr>
<tr>
<td><strong>锁消除</strong></td>
<td>无（运行时）</td>
<td>JIT 编译时优化，发生在编译阶段而非运行时</td>
<td><code>-XX:+PrintEliminateLocks</code>（需 debug 版本）；JIT 编译日志</td>
</tr>
<tr>
<td><strong>锁粗化</strong></td>
<td>无（运行时）</td>
<td>同上，JIT 编译时优化</td>
<td>JIT 编译日志</td>
</tr>
</tbody>
</table>
<p><strong>重量级锁的 Monitor 膨胀日志（JDK 11+）：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 观察 Monitor 的膨胀和收缩</span><br>-Xlog:monitorinflation=debug<br></code></pre></td></tr></table></figure>
<p>输出示例：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[0.234s][<span class="hljs-built_in">debug</span>][monitorinflation] inflate(has_locker): <span class="hljs-attribute">object</span>=0x00000007bfe00000, <span class="hljs-attribute">mark</span>=0x00007f8a1c0008c0, <span class="hljs-attribute">type</span>=java.lang.Object<br>[0.567s][<span class="hljs-built_in">debug</span>][monitorinflation] deflate_idle_monitors: deflated 1 monitors <span class="hljs-keyword">in</span> 0.0001234 secs<br></code></pre></td></tr></table></figure>
<p><strong>使用 jstack 观察锁竞争：</strong></p>
<p>当线程因为重量级锁而阻塞时，<code>jstack</code> 会显示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-string">&quot;Thread-1&quot;</span> #<span class="hljs-number">12</span> prio=<span class="hljs-number">5</span> os_prio=<span class="hljs-number">0</span> tid=<span class="hljs-number">0</span>x00007f8a1c0008c0 nid=<span class="hljs-number">0</span>x1234 waiting <span class="hljs-keyword">for</span> monitor entry <span class="hljs-selector-attr">[0x00007f8a1c000000]</span><br>   java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.State</span>: BLOCKED (on <span class="hljs-selector-tag">object</span> monitor)<br>        at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyClass</span><span class="hljs-selector-class">.syncMethod</span>(MyClass<span class="hljs-selector-class">.java</span>:<span class="hljs-number">42</span>)<br>        - waiting to lock &lt;<span class="hljs-number">0</span>x00000007bfe00000&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.lang</span>.Object)<br>        at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyClass</span><span class="hljs-selector-class">.run</span>(MyClass<span class="hljs-selector-class">.java</span>:<span class="hljs-number">30</span>)<br><br><span class="hljs-string">&quot;Thread-0&quot;</span> #<span class="hljs-number">11</span> prio=<span class="hljs-number">5</span> os_prio=<span class="hljs-number">0</span> tid=<span class="hljs-number">0</span>x00007f8a1c0007b0 nid=<span class="hljs-number">0</span>x1233 runnable <span class="hljs-selector-attr">[0x00007f8a1bfff000]</span><br>   java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.State</span>: RUNNABLE<br>        at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyClass</span><span class="hljs-selector-class">.syncMethod</span>(MyClass<span class="hljs-selector-class">.java</span>:<span class="hljs-number">45</span>)<br>        - locked &lt;<span class="hljs-number">0</span>x00000007bfe00000&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.lang</span>.Object)<br></code></pre></td></tr></table></figure>
<p>关键信息：</p>
<ul>
<li><code>waiting for monitor entry</code>：线程正在等待获取 Monitor</li>
<li><code>BLOCKED (on object monitor)</code>：线程状态为阻塞</li>
<li><code>waiting to lock &lt;0x...&gt;</code>：等待锁定的对象地址</li>
<li><code>locked &lt;0x...&gt;</code>：已持有锁的对象地址</li>
</ul>
<p><strong>使用 JFR 记录锁竞争事件：</strong></p>
<p>Java Flight Recorder 可以记录详细的锁竞争信息：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动 JFR 记录</span><br>java -XX:StartFlightRecording=filename=recording.jfr,settings=profile ...<br><br><span class="hljs-comment"># 或使用 jcmd 动态开启</span><br>jcmd &lt;pid&gt; JFR.start filename=recording.jfr settings=profile<br></code></pre></td></tr></table></figure>
<p>JFR 可以记录的锁相关事件：</p>
<ul>
<li><code>jdk.JavaMonitorEnter</code>：进入 synchronized 块</li>
<li><code>jdk.JavaMonitorWait</code>：调用 <code>Object.wait()</code></li>
<li><code>jdk.JavaMonitorInflate</code>：Monitor 膨胀事件</li>
<li><code>jdk.ThreadPark</code>：<code>LockSupport.park()</code> 事件（AQS 相关）</li>
</ul>
<p><strong>小结：大部分锁操作没有日志的原因</strong></p>
<p>这是一个<strong>性能与可观测性的权衡</strong>：</p>
<ol>
<li><strong>轻量级锁</strong>的设计目标就是&quot;零开销&quot;，如果每次 CAS 都记录日志，性能损耗会远超锁本身的开销</li>
<li><strong>锁消除和锁粗化</strong>发生在 JIT 编译期，编译完成后就是普通的代码执行，没有&quot;锁&quot;的概念了</li>
<li><strong>偏向锁撤销</strong>之所以有日志，是因为它<strong>必须触发安全点</strong>，这本身就是一个&quot;重&quot;操作，记录日志的边际成本很低</li>
</ol>
<p>因此，在生产环境中诊断锁问题，通常需要结合多种工具：</p>
<ul>
<li><strong>Safepoint 日志</strong>：诊断偏向锁撤销问题</li>
<li><strong>jstack</strong>：快速查看当前的锁竞争状态</li>
<li><strong>JFR</strong>：长期记录和分析锁竞争模式</li>
<li><strong>Async-profiler</strong>：采样分析锁等待时间</li>
</ul>
<p>无锁和轻量级锁的差别是：</p>
<ul>
<li>无锁是自旋修改同步资源：无锁的特点就是修改操作在循环内进行，线程会不断的尝试修改共享资源。如果没有冲突就修改成功并退出，否则就会继续循环尝试。如果有多个线程修改同一个值，必定会有一个线程能修改成功，而其他修改失败的线程会不断重试直到修改成功。上面我们介绍的CAS原理及应用即是无锁的实现。无锁无法全面代替有锁，但无锁在某些场合下的性能是非常高的。</li>
<li>轻量级锁是自旋抢锁而不是阻塞抢锁：是指当锁是偏向锁的时候，被另外的线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，从而提高性能。</li>
</ul>
<p>如果硬要对比：</p>
<ul>
<li><strong>无锁</strong>更像是直接使用 <code>AtomicInteger.compareAndSet()</code> 进行乐观更新，失败就重试，不涉及任何锁的概念</li>
<li><strong>轻量级锁</strong>更像是 AQS 中 <code>tryAcquire()</code> 的非阻塞尝试部分——通过 CAS 竞争锁，失败后自旋重试，但不会立即阻塞线程</li>
</ul>
<p>两者的本质区别在于：无锁是对<strong>数据</strong>的 CAS 操作（修改共享变量本身），而轻量级锁是对<strong>锁状态</strong>的 CAS 操作（竞争 Mark Word 的所有权）。</p>
<h2 id="从-aqs-看锁的抽象模型">从 AQS 看锁的抽象模型</h2>
<p>在深入 <code>LockSupport</code> 之前，有必要先建立一个关于锁的抽象模型。这个模型将帮助我们理解：无论是 <code>synchronized</code> 的 ObjectMonitor，还是 <code>ReentrantLock</code> 的 AQS，它们本质上都在管理相同的核心信息。</p>
<h3 id="锁的核心职责与次级职责">锁的核心职责与次级职责</h3>
<p>任何锁机制都需要回答以下问题：</p>
<table>
<thead>
<tr>
<th>职责类型</th>
<th>核心问题</th>
<th>必要性</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>核心职责</strong></td>
<td>谁拥有锁？（owner）</td>
<td>必须——这是锁存在的根本意义</td>
</tr>
<tr>
<td><strong>次级职责</strong></td>
<td>谁在等待锁？（entry queue）</td>
<td>可选——可以用自旋代替队列</td>
</tr>
<tr>
<td><strong>次级职责</strong></td>
<td>谁在等待条件？（wait set）</td>
<td>可选——只有支持条件变量时才需要</td>
</tr>
<tr>
<td><strong>次级职责</strong></td>
<td>锁被重入了多少次？（recursion count）</td>
<td>可选——只有可重入锁才需要</td>
</tr>
</tbody>
</table>
<p><strong>核心职责是不可或缺的</strong>：无论锁的实现多么简化，&quot;谁拥有锁&quot;这个信息必须存在。偏向锁把 threadId 写入 Mark Word，轻量级锁通过 Lock Record 指针隐含 owner，重量级锁在 ObjectMonitor 的 <code>_owner</code> 字段显式记录——形式不同，但本质相同。</p>
<p><strong>次级职责可以有不同的实现策略</strong>：</p>
<ul>
<li><strong>自旋实现</strong>：不显式维护等待队列，让竞争线程在 for 循环中反复尝试 CAS。这是轻量级锁的策略。</li>
<li><strong>队列实现</strong>：显式维护等待线程的队列，竞争失败的线程入队并阻塞。这是重量级锁和 AQS 的策略。</li>
</ul>
<h3 id="aqs-如何具象化这个抽象模型">AQS 如何具象化这个抽象模型</h3>
<p><code>AbstractQueuedSynchronizer</code>（AQS）是 Doug Lea 设计的同步器框架，它将上述抽象模型具象化为具体的数据结构：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;AQS 的核心数据结构&quot;
        direction TB
        
        STATE[&quot;state: int&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;锁状态的统一抽象&lt;br/&gt;• 0 = 未锁定&lt;br/&gt;• 1 = 已锁定&lt;br/&gt;• &gt;1 = 重入次数&quot;]
        
        OWNER[&quot;exclusiveOwnerThread: Thread&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;核心职责：谁拥有锁&lt;br/&gt;显式记录持锁线程&quot;]
        
        SYNC_QUEUE[&quot;同步队列（CLH 变体）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;次级职责：谁在等待锁&lt;br/&gt;head ↔ Node ↔ Node ↔ tail&lt;br/&gt;每个 Node 封装一个等待线程&quot;]
        
        COND_QUEUE[&quot;条件队列（ConditionObject）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;次级职责：谁在等待条件&lt;br/&gt;firstWaiter → Node → Node&lt;br/&gt;每个 Condition 一个队列&quot;]
        
        STATE --&gt; OWNER
        OWNER --&gt; SYNC_QUEUE
        SYNC_QUEUE --&gt; COND_QUEUE
        
        style STATE fill:#e1f5ff
        style OWNER fill:#c8e6c9
        style SYNC_QUEUE fill:#fff9c4
        style COND_QUEUE fill:#ffecb3
    end</code></pre>
<p><strong>AQS 与 ObjectMonitor 的对位关系：</strong></p>
<table>
<thead>
<tr>
<th>抽象概念</th>
<th>AQS 实现</th>
<th>ObjectMonitor 实现</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>谁拥有锁</strong></td>
<td><code>exclusiveOwnerThread</code></td>
<td><code>_owner</code></td>
</tr>
<tr>
<td><strong>锁状态/重入计数</strong></td>
<td><code>state</code></td>
<td><code>_recursions</code></td>
</tr>
<tr>
<td><strong>等待获取锁的线程</strong></td>
<td>同步队列（CLH 变体）</td>
<td><code>_EntryList</code> + <code>_cxq</code></td>
</tr>
<tr>
<td><strong>等待条件的线程</strong></td>
<td><code>ConditionObject</code> 的条件队列</td>
<td><code>_WaitSet</code></td>
</tr>
<tr>
<td><strong>线程阻塞原语</strong></td>
<td><code>LockSupport.park()</code></td>
<td><code>pthread_cond_wait()</code></td>
</tr>
</tbody>
</table>
<p><strong>锁对象 → 同步器 → 线程的三层引用关系：</strong></p>
<p>无论是 <code>synchronized</code> 还是 <code>ReentrantLock</code>，最终都形成这样的引用链：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nix">锁对象（Object <span class="hljs-symbol">/</span> ReentrantLock）<br>    ↓<br>同步器实现（ObjectMonitor <span class="hljs-symbol">/</span> AQS.Sync）<br>    ↓ 包含<br>等待队列（_EntryList <span class="hljs-symbol">/</span> CLH Queue）<br>    ↓ 封装<br>线程引用（Thread）<br></code></pre></td></tr></table></figure>
<p>这个三层结构是锁机制的本质。不同的锁实现只是在各层使用了不同的数据结构和算法，但信息的本质是相同的。</p>
<h3 id="为什么需要理解这个抽象模型？">为什么需要理解这个抽象模型？</h3>
<p>理解这个模型有助于：</p>
<ol>
<li><strong>理解锁升级的本质</strong>：从偏向锁到重量级锁，本质上是&quot;次级职责&quot;的实现方式从&quot;无&quot;到&quot;自旋&quot;再到&quot;队列&quot;的演进。</li>
<li><strong>理解 LockSupport 的定位</strong>：<code>park()</code>/<code>unpark()</code> 是实现&quot;队列等待&quot;的底层原语，它让线程能够阻塞和唤醒，但不负责管理队列本身。</li>
<li><strong>理解 blocker 参数的意义</strong>：blocker 是为了在诊断时能够追溯&quot;这个线程在等待哪个同步器&quot;，它是三层引用关系的可观测性体现。</li>
</ol>
<h2 id="locksupport：线程阻塞的基础设施">LockSupport：线程阻塞的基础设施</h2>
<p>有了上述抽象模型的铺垫，我们现在可以深入理解 <code>LockSupport</code>。它是 JDK 提供的线程阻塞原语，是 AQS 等高级同步器的基础设施。</p>
<h3 id="blocker-参数的本质">blocker 参数的本质</h3>
<p>前面的章节多次提到 <code>LockSupport.park(Object blocker)</code> 中的 blocker 参数，但很多开发者对它的理解仍然模糊。</p>
<p><strong>blocker 是一个纯粹用于诊断目的的标记对象</strong>，它告诉 JVM 和诊断工具&quot;这个线程为什么被阻塞了&quot;。</p>
<p><strong>blocker 是一个纯粹用于诊断目的的标记对象</strong>，它告诉 JVM 和诊断工具&quot;这个线程为什么被阻塞了&quot;。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread 类中的字段</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The argument supplied to the current call to</span><br><span class="hljs-comment">     * java.util.concurrent.locks.LockSupport.park.</span><br><span class="hljs-comment">     * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker</span><br><span class="hljs-comment">     * Accessed using java.util.concurrent.locks.LockSupport.getBlocker</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">volatile</span> Object parkBlocker;<br>    <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键理解：</p>
<ul>
<li><strong>blocker 不参与任何锁的获取/释放逻辑</strong>——它纯粹是一个&quot;标签&quot;</li>
<li><strong>blocker 不影响 park/unpark 的行为</strong>——即使传 null，park 也能正常工作</li>
<li><strong>blocker 的唯一作用是可观测性</strong>——让 <code>jstack</code>、JFR 等工具能显示线程在等待什么</li>
</ul>
<h3 id="park-与-unpark-的参数不对称性">park 与 unpark 的参数不对称性</h3>
<p><code>LockSupport</code> 的 API 设计存在一个容易被忽视的不对称性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span>;    <span class="hljs-comment">// 阻塞当前线程，blocker 仅用于诊断</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span>;   <span class="hljs-comment">// 唤醒指定线程</span><br></code></pre></td></tr></table></figure>
<p><strong>关键观察：</strong></p>
<ul>
<li><code>park()</code> 的参数是 <strong>blocker</strong>（诊断标记），不是线程——它总是阻塞<strong>调用它的当前线程</strong></li>
<li><code>unpark()</code> 的参数是 <strong>Thread</strong>（目标线程）——它唤醒<strong>指定的那个线程</strong></li>
</ul>
<p>这种不对称性反映了线程阻塞与唤醒的本质差异：</p>
<ul>
<li><strong>阻塞是自愿行为</strong>：线程只能阻塞自己，不能强制阻塞别人</li>
<li><strong>唤醒是外部行为</strong>：线程需要被别人唤醒，所以必须指定目标</li>
</ul>
<h3 id="park-与-sleep-的深层对比">park 与 sleep 的深层对比</h3>
<p>从 API 形态上看，<code>LockSupport.park()</code> 与 <code>Thread.sleep()</code> 存在显著的相似性：两者都是使当前线程进入阻塞状态的静态方法，都不需要持有任何锁，都可以响应中断。然而，它们在语义设计上存在本质差异。</p>
<h4 id="api-签名对比">API 签名对比</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Thread 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sleep</span><span class="hljs-params">(Duration duration)</span> <span class="hljs-keyword">throws</span> InterruptedException;  <span class="hljs-comment">// JDK 19+</span><br><br><span class="hljs-comment">// LockSupport 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">()</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanos)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkNanos</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> nanos)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(<span class="hljs-type">long</span> deadline)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parkUntil</span><span class="hljs-params">(Object blocker, <span class="hljs-type">long</span> deadline)</span>;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span>;<br></code></pre></td></tr></table></figure>
<h4 id="核心差异分析">核心差异分析</h4>
<table>
<thead>
<tr>
<th>维度</th>
<th><code>Thread.sleep()</code></th>
<th><code>LockSupport.park()</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>唤醒机制</strong></td>
<td>仅时间到期或中断</td>
<td><code>unpark()</code>、中断、虚假唤醒、时间到期</td>
</tr>
<tr>
<td><strong>配对方法</strong></td>
<td>无</td>
<td><code>unpark(Thread)</code></td>
</tr>
<tr>
<td><strong>permit 机制</strong></td>
<td>无</td>
<td>有（二元许可）</td>
</tr>
<tr>
<td><strong>唤醒顺序</strong></td>
<td>不适用</td>
<td><code>unpark()</code> 可先于 <code>park()</code> 调用</td>
</tr>
<tr>
<td><strong>中断响应</strong></td>
<td>抛出 <code>InterruptedException</code>，清除中断状态</td>
<td>静默返回，保留中断状态</td>
</tr>
<tr>
<td><strong>线程状态</strong></td>
<td><code>TIMED_WAITING</code></td>
<td><code>WAITING</code> 或 <code>TIMED_WAITING</code></td>
</tr>
<tr>
<td><strong>设计目的</strong></td>
<td>简单的定时等待</td>
<td>构建同步器的底层原语</td>
</tr>
</tbody>
</table>
<p><strong><code>sleep()</code> 没有对应 <code>unsleep()</code> 方法的原因</strong></p>
<p>这触及了两者设计哲学的核心差异。<code>sleep()</code> 的语义是&quot;休眠指定时长&quot;，其唤醒条件在调用时就已完全确定——时间到期。这是一个<strong>自包含的操作</strong>，不需要外部协作。如果需要提前唤醒，使用 <code>interrupt()</code> 即可，这与 <code>sleep()</code> 的&quot;可中断休眠&quot;语义一致。</p>
<p>相比之下，<code>park()</code> 的语义是&quot;等待许可&quot;，其唤醒条件依赖于外部线程的协作——调用 <code>unpark()</code>。这是一个<strong>协作式操作</strong>，必须有配对的唤醒机制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sleep 的语义：自包含的定时等待</span><br>Thread.sleep(<span class="hljs-number">1000</span>);  <span class="hljs-comment">// 语义完整：休眠 1 秒</span><br><br><span class="hljs-comment">// park 的语义：等待外部许可</span><br>LockSupport.park();  <span class="hljs-comment">// 语义不完整：谁来唤醒我？</span><br><span class="hljs-comment">// 必须有另一个线程执行：</span><br>LockSupport.unpark(parkedThread);  <span class="hljs-comment">// 配对的唤醒操作</span><br></code></pre></td></tr></table></figure>
<h4 id="中断处理的差异">中断处理的差异</h4>
<p>两者对中断的处理方式体现了不同的设计取向：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// sleep：中断即异常，必须显式处理</span><br><span class="hljs-keyword">try</span> &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// 中断状态已被清除</span><br>    <span class="hljs-comment">// 必须决定如何处理：重新中断、退出、忽略...</span><br>    Thread.currentThread().interrupt();  <span class="hljs-comment">// 恢复中断状态</span><br>&#125;<br><br><span class="hljs-comment">// park：中断即返回，由调用者检查</span><br>LockSupport.park();<br><span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;  <span class="hljs-comment">// 检查并清除中断状态</span><br>    <span class="hljs-comment">// 处理中断</span><br>&#125;<br><span class="hljs-comment">// 或者保留中断状态，让上层处理</span><br></code></pre></td></tr></table></figure>
<p><code>park()</code> 的这种设计使其更适合作为同步器的构建块。AQS 中的 <code>acquireQueued()</code> 方法正是利用了这一特性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS.acquireQueued 的简化逻辑</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (tryAcquire(arg)) &#123;<br>            <span class="hljs-keyword">return</span> interrupted;  <span class="hljs-comment">// 返回是否被中断过</span><br>        &#125;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> (Thread.interrupted())<br>            interrupted = <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 记录中断，但继续尝试获取锁</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="permit-机制：解决-sleep-无法解决的问题">permit 机制：解决 sleep 无法解决的问题</h4>
<p><code>park()</code>/<code>unpark()</code> 的 permit 机制解决了一个 <code>sleep()</code> 无法处理的经典问题：<strong>唤醒信号的时序问题</strong>。</p>
<p>考虑以下场景：线程 A 需要等待线程 B 完成某项工作后再继续。</p>
<p><strong>使用 sleep 的错误尝试：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br><span class="hljs-keyword">while</span> (!workDone) &#123;<br>    Thread.sleep(<span class="hljs-number">100</span>);  <span class="hljs-comment">// 轮询等待，浪费 CPU</span><br>&#125;<br><br><span class="hljs-comment">// 线程 B</span><br>doWork();<br>workDone = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 无法主动唤醒 A，只能等 A 的下一次轮询</span><br></code></pre></td></tr></table></figure>
<p><strong>使用 wait/notify 的经典问题：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-keyword">while</span> (!workDone) &#123;<br>        lock.wait();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线程 B</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    doWork();<br>    workDone = <span class="hljs-literal">true</span>;<br>    lock.notify();<br>&#125;<br><br><span class="hljs-comment">// 问题：如果 B 先执行完，notify 信号丢失，A 将永远等待</span><br></code></pre></td></tr></table></figure>
<p><strong>使用 park/unpark 的解决方案：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A</span><br><span class="hljs-keyword">while</span> (!workDone) &#123;<br>    LockSupport.park();<br>&#125;<br><br><span class="hljs-comment">// 线程 B</span><br>doWork();<br>workDone = <span class="hljs-literal">true</span>;<br>LockSupport.unpark(threadA);<br><br><span class="hljs-comment">// 即使 B 先执行 unpark，permit 会被保存</span><br><span class="hljs-comment">// A 随后调用 park 时立即返回，不会阻塞</span><br></code></pre></td></tr></table></figure>
<h4 id="底层实现的统一性">底层实现的统一性</h4>
<p>尽管 API 语义不同，<code>sleep()</code> 和 <code>park()</code> 在 HotSpot JVM 中的底层实现存在共性。两者最终都会调用操作系统的线程阻塞原语：</p>
<ul>
<li><strong>POSIX 系统</strong>：<code>pthread_cond_wait()</code> / <code>pthread_cond_timedwait()</code></li>
<li><strong>Windows</strong>：<code>WaitForSingleObject()</code> / <code>WaitForMultipleObjects()</code></li>
</ul>
<p>关键差异在于唤醒条件的管理：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// HotSpot 中 Parker 的核心结构（简化）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parker</span> : <span class="hljs-keyword">public</span> os::PlatformParker &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> _counter;  <span class="hljs-comment">// permit 计数器（0 或 1）</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">park</span><span class="hljs-params">(<span class="hljs-type">bool</span> isAbsolute, jlong time)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">()</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// park 的核心逻辑</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parker::park</span><span class="hljs-params">(<span class="hljs-type">bool</span> isAbsolute, jlong time)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">xchg</span>(&amp;_counter, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 有 permit，立即返回</span><br>    <span class="hljs-comment">// ... 进入条件等待 ...</span><br>&#125;<br><br><span class="hljs-comment">// unpark 的核心逻辑</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parker::unpark</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> s = Atomic::<span class="hljs-built_in">xchg</span>(&amp;_counter, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 设置 permit</span><br>    <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 唤醒等待的线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>sleep()</code> 则没有这个 permit 机制，它直接进入定时等待，唯一的提前唤醒途径是中断。</p>
<h4 id="使用场景的选择">使用场景的选择</h4>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐使用</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>简单的定时延迟</td>
<td><code>Thread.sleep()</code></td>
<td>语义清晰，无需配对操作</td>
</tr>
<tr>
<td>限流、节流</td>
<td><code>Thread.sleep()</code></td>
<td>固定时间间隔，无需外部唤醒</td>
</tr>
<tr>
<td>线程间协调</td>
<td><code>LockSupport.park()/unpark()</code></td>
<td>精确的一对一唤醒</td>
</tr>
<tr>
<td>构建同步器</td>
<td><code>LockSupport.park()/unpark()</code></td>
<td>permit 机制避免信号丢失</td>
</tr>
<tr>
<td>等待条件变量</td>
<td><code>Condition.await()</code></td>
<td>高层抽象，内部使用 park</td>
</tr>
<tr>
<td>等待对象监视器</td>
<td><code>Object.wait()</code></td>
<td>与 synchronized 配合使用</td>
</tr>
</tbody>
</table>
<h4 id="小结">小结</h4>
<p><code>park()</code> 与 <code>sleep()</code> 的关系可以这样理解：<code>sleep()</code> 是一个<strong>自给自足的定时等待</strong>，而 <code>park()</code> 是一个<strong>需要外部配合的协作等待</strong>。<code>sleep()</code> 没有 <code>unsleep()</code> 方法，正如 <code>park()</code> 必须有 <code>unpark()</code> 方法一样，这不是 API 设计的疏漏，而是两者语义本质差异的必然体现。</p>
<p>从同步原语的角度看，<code>park()</code>/<code>unpark()</code> 提供了比 <code>sleep()</code> 更底层、更灵活的线程阻塞机制，它是 <code>java.util.concurrent</code> 包中各种同步器的基石。而 <code>sleep()</code> 则保持了其简单直接的定位：当你只需要让线程暂停一段时间时，它仍然是最佳选择。</p>
<h4 id="从-java-线程-api-到操作系统：自愿-vs-强制操作的统一视角">从 Java 线程 API 到操作系统：自愿 vs 强制操作的统一视角</h4>
<p><code>park</code>/<code>unpark</code> 的参数不对称性并非孤例，而是反映了并发编程中一个更深层的设计原则：<strong>自愿操作作用于当前线程，强制操作必须指定目标线程</strong>。</p>
<p><strong>Java 线程 API 的参数模式：</strong></p>
<table>
<thead>
<tr>
<th>操作类型</th>
<th>方法签名</th>
<th>作用目标</th>
<th>设计原因</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>自愿阻塞</strong></td>
<td><code>Thread.sleep(long millis)</code></td>
<td>当前线程</td>
<td>线程主动让出 CPU，无需指定自己</td>
</tr>
<tr>
<td><strong>自愿阻塞</strong></td>
<td><code>Object.wait()</code></td>
<td>当前线程</td>
<td>线程主动进入等待，释放锁</td>
</tr>
<tr>
<td><strong>自愿阻塞</strong></td>
<td><code>LockSupport.park(Object blocker)</code></td>
<td>当前线程</td>
<td>blocker 仅用于诊断</td>
</tr>
<tr>
<td><strong>强制唤醒</strong></td>
<td><code>Object.notify()/notifyAll()</code></td>
<td>等待队列中的线程</td>
<td>由 Monitor 管理目标选择</td>
</tr>
<tr>
<td><strong>强制唤醒</strong></td>
<td><code>LockSupport.unpark(Thread t)</code></td>
<td>指定线程</td>
<td>必须明确唤醒谁</td>
</tr>
<tr>
<td><strong>强制中断</strong></td>
<td><code>thread.interrupt()</code></td>
<td>指定线程</td>
<td>必须明确中断谁</td>
</tr>
<tr>
<td><strong>强制终止</strong></td>
<td><code>thread.stop()</code> (已废弃)</td>
<td>指定线程</td>
<td>必须明确终止谁</td>
</tr>
<tr>
<td><strong>强制挂起</strong></td>
<td><code>thread.suspend()</code> (已废弃)</td>
<td>指定线程</td>
<td>必须明确挂起谁</td>
</tr>
</tbody>
</table>
<p><strong>操作系统层面的对应关系：</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;自愿操作（作用于当前进程/线程）&quot;
        SLEEP[&quot;sleep()&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;主动让出 CPU&lt;br/&gt;进入 SLEEPING 状态&quot;]
        WAIT[&quot;wait()/park()&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;主动等待条件&lt;br/&gt;进入 WAITING 状态&quot;]
        YIELD[&quot;yield()&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;主动让出时间片&lt;br/&gt;仍为 RUNNABLE&quot;]
        EXIT[&quot;exit()&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;主动终止自己&quot;]
        
        style SLEEP fill:#c8e6c9
        style WAIT fill:#c8e6c9
        style YIELD fill:#c8e6c9
        style EXIT fill:#c8e6c9
    end
    
    subgraph &quot;强制操作（必须指定目标）&quot;
        KILL[&quot;kill(pid, signal)&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;向指定进程发信号&lt;br/&gt;必须知道 PID&quot;]
        SIGNAL[&quot;pthread_kill(tid, sig)&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;向指定线程发信号&lt;br/&gt;必须知道 TID&quot;]
        CANCEL[&quot;pthread_cancel(tid)&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;请求取消指定线程&lt;br/&gt;必须知道 TID&quot;]
        UNPARK[&quot;unpark(thread)&lt;br/&gt;━━━━━━━━━━━━&lt;br/&gt;唤醒指定线程&lt;br/&gt;必须持有引用&quot;]
        
        style KILL fill:#ffcdd2
        style SIGNAL fill:#ffcdd2
        style CANCEL fill:#ffcdd2
        style UNPARK fill:#ffcdd2
    end</code></pre>
<p><strong>为什么会有这种设计？</strong></p>
<ol>
<li>
<p><strong>安全性考量</strong>：如果允许线程 A 强制阻塞线程 B，可能导致死锁或资源泄漏。线程 B 可能正持有锁、正在执行关键操作，强制阻塞它会破坏系统一致性。</p>
</li>
<li>
<p><strong>协作式 vs 抢占式</strong>：</p>
<ul>
<li><strong>阻塞是协作式的</strong>：线程在安全点主动放弃执行权</li>
<li><strong>唤醒/中断是抢占式的</strong>：外部力量介入改变线程状态</li>
</ul>
</li>
<li>
<p><strong>信息不对称</strong>：</p>
<ul>
<li>当前线程知道自己的状态，可以安全地阻塞自己</li>
<li>外部线程不知道目标线程的内部状态，只能发送&quot;请求&quot;（如中断），由目标线程决定如何响应</li>
</ul>
</li>
<li>
<p><strong>POSIX 信号模型的影响</strong>：Unix/Linux 的信号机制（<code>kill(pid, signal)</code>）就是&quot;向指定目标发送异步通知&quot;的典范，Java 的 <code>interrupt()</code> 和 <code>unpark()</code> 继承了这一思想。</p>
</li>
</ol>
<p><strong><code>stop()</code>/<code>suspend()</code> 被废弃的教训：</strong></p>
<p>Java 早期提供的 <code>Thread.stop()</code> 和 <code>Thread.suspend()</code> 正是&quot;强制阻塞/终止其他线程&quot;的尝试，但它们被证明是危险的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 危险！stop() 会立即终止线程，可能导致：</span><br><span class="hljs-comment">// 1. 锁未释放 → 死锁</span><br><span class="hljs-comment">// 2. 数据结构更新到一半 → 不一致状态</span><br><span class="hljs-comment">// 3. 资源未清理 → 泄漏</span><br>thread.stop();  <span class="hljs-comment">// @Deprecated since JDK 1.2</span><br><br><span class="hljs-comment">// 危险！suspend() 会冻结线程但不释放锁</span><br><span class="hljs-comment">// 如果被挂起的线程持有锁，其他线程将永远等待</span><br>thread.suspend();  <span class="hljs-comment">// @Deprecated since JDK 1.2</span><br></code></pre></td></tr></table></figure>
<p>这些 API 的废弃证明了：<strong>强制改变其他线程的执行状态是危险的</strong>。正确的做法是：</p>
<ul>
<li>使用 <code>interrupt()</code> 发送中断请求，由目标线程自己决定如何响应</li>
<li>使用 <code>volatile</code> 标志位进行协作式停止</li>
<li>使用 <code>park()</code>/<code>unpark()</code> 进行精确的线程协调</li>
</ul>
<h4 id="permit-机制：从信号量到-park-unpark-的演进">permit 机制：从信号量到 park/unpark 的演进</h4>
<p><code>park</code>/<code>unpark</code> 的核心是一个<strong>二元许可（permit）机制</strong>。理解这个机制需要追溯到并发编程的历史。</p>
<p><strong>从 Dijkstra 的 P/V 信号量说起</strong></p>
<p>1965 年，Dijkstra 提出了信号量（Semaphore）概念，使用两个原子操作：</p>
<ul>
<li><strong>P 操作（Proberen，荷兰语&quot;测试&quot;）</strong>：如果信号量 &gt; 0，则减 1 并继续；否则阻塞</li>
<li><strong>V 操作（Verhogen，荷兰语&quot;增加&quot;）</strong>：信号量加 1，唤醒一个等待者</li>
</ul>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">Semaphore</span>(n)：初始值为 n 的计数器<br><span class="hljs-selector-tag">P</span>(S)：while (S &lt;= <span class="hljs-number">0</span>) wait; S--<br><span class="hljs-built_in">V</span>(S)：S++; <span class="hljs-built_in">wakeup_one</span>()<br></code></pre></td></tr></table></figure>
<p><strong>park/unpark 是&quot;退化的二元信号量&quot;</strong></p>
<p><code>LockSupport</code> 的 permit 机制可以理解为<strong>计数上限为 1 的信号量</strong>：</p>
<table>
<thead>
<tr>
<th>信号量概念</th>
<th>park/unpark 对应</th>
<th>关键差异</th>
</tr>
</thead>
<tbody>
<tr>
<td>P 操作</td>
<td><code>park()</code></td>
<td>消耗 permit，若无则阻塞</td>
</tr>
<tr>
<td>V 操作</td>
<td><code>unpark()</code></td>
<td>发放 permit，但<strong>最多累积 1 个</strong></td>
</tr>
<tr>
<td>计数器</td>
<td>permit（0 或 1）</td>
<td>不是任意整数，只有两个状态</td>
</tr>
</tbody>
</table>
<p><strong>为什么 permit 最多只能累积 1 个？</strong></p>
<p>这是一个关键的设计决策。考虑以下场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果 permit 可以累积多个...</span><br>unpark(thread);  <span class="hljs-comment">// permit = 1</span><br>unpark(thread);  <span class="hljs-comment">// permit = 2（假设可以累积）</span><br>unpark(thread);  <span class="hljs-comment">// permit = 3</span><br><br><span class="hljs-comment">// 那么线程可以连续 park 三次而不阻塞</span><br>park();  <span class="hljs-comment">// permit = 2，立即返回</span><br>park();  <span class="hljs-comment">// permit = 1，立即返回</span><br>park();  <span class="hljs-comment">// permit = 0，立即返回</span><br>park();  <span class="hljs-comment">// 才会阻塞</span><br></code></pre></td></tr></table></figure>
<p>这会导致<strong>唤醒信号的语义混乱</strong>：一次 <code>unpark</code> 本意是&quot;唤醒一次&quot;，但如果可以累积，就变成了&quot;预支多次唤醒&quot;。<code>park</code>/<code>unpark</code> 的设计目标是<strong>精确的一对一唤醒</strong>，而非通用的计数信号量。</p>
<p><strong>permit 机制解决的核心问题：竞态条件下的唤醒丢失</strong></p>
<p>传统的 <code>wait()</code>/<code>notify()</code> 存在一个经典问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 A（等待方）</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-keyword">while</span> (!condition) &#123;<br>        lock.wait();  <span class="hljs-comment">// 必须在 synchronized 块内</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 线程 B（唤醒方）</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    condition = <span class="hljs-literal">true</span>;<br>    lock.notify();  <span class="hljs-comment">// 必须在 synchronized 块内</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果线程 B 在线程 A 调用 <code>wait()</code> <strong>之前</strong>就调用了 <code>notify()</code>，这个唤醒信号就<strong>丢失</strong>了。线程 A 随后调用 <code>wait()</code> 会永远阻塞。</p>
<p><code>park</code>/<code>unpark</code> 的 permit 机制优雅地解决了这个问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 线程 B 先执行</span><br>LockSupport.unpark(threadA);  <span class="hljs-comment">// permit = 1（即使 A 还没 park）</span><br><br><span class="hljs-comment">// 线程 A 后执行</span><br>LockSupport.park();           <span class="hljs-comment">// permit = 0，立即返回，不阻塞！</span><br></code></pre></td></tr></table></figure>
<p><strong>permit 的状态机：</strong></p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; NoPermit: 初始状态
    
    NoPermit: 无许可状态
    HasPermit: 有许可状态 (permit最多为1)
    Blocked: 阻塞状态 (线程进入dormant状态)
    
    NoPermit --&gt; HasPermit: unpark()
    NoPermit --&gt; Blocked: park()
    
    HasPermit --&gt; NoPermit: park()(立即返回)
    HasPermit --&gt; HasPermit: unpark()(幂等不累积)
    
    Blocked --&gt; NoPermit: unpark()(唤醒)
    Blocked --&gt; NoPermit: interrupt()(中断唤醒)
    Blocked --&gt; NoPermit: 虚假唤醒</code></pre>
<p><strong>为什么 JVM 使用 “dormant” 而非 “sleeping”？</strong></p>
<p>JVM 规范中使用 <strong>dormant</strong>（休眠/蛰伏）而非 <strong>sleeping</strong>（睡眠）来描述 <code>park()</code> 后的线程状态，这是一个精确的术语选择：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>含义</th>
<th>对应 API</th>
<th>唤醒方式</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Sleeping</strong></td>
<td>定时休眠，时间到自动醒来</td>
<td><code>Thread.sleep(millis)</code></td>
<td>时间到期、中断</td>
</tr>
<tr>
<td><strong>Dormant</strong></td>
<td>无限期蛰伏，必须被外部唤醒</td>
<td><code>LockSupport.park()</code></td>
<td><code>unpark()</code>、中断、虚假唤醒</td>
</tr>
</tbody>
</table>
<p><code>dormant</code> 强调的是：</p>
<ol>
<li><strong>无自主唤醒能力</strong>：线程不会因为时间流逝而自动醒来</li>
<li><strong>依赖外部干预</strong>：必须有其他线程调用 <code>unpark()</code> 或发送中断</li>
<li><strong>生物学隐喻</strong>：如同冬眠的动物，需要外部刺激才能苏醒</li>
</ol>
<p><strong>permit 使用不当的风险：无条件 park 的陷阱</strong></p>
<p>虽然 permit 机制解决了唤醒丢失问题，但使用不当仍会导致问题。考虑以下错误示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：无条件循环 park</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    LockSupport.park();<br>    doSomeWork();  <span class="hljs-comment">// 被唤醒后执行某些工作</span><br>    <span class="hljs-comment">// 然后无条件地再次 park</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个模式的问题在于 <strong>permit 的一次性消耗特性</strong>：</p>
<ol>
<li><strong>第一次循环</strong>：假设 <code>unpark()</code> 先于 <code>park()</code> 调用，permit 被设置为 1</li>
<li><strong><code>park()</code> 调用</strong>：发现 permit = 1，立即返回并将 permit 置为 0</li>
<li><strong>执行 <code>doSomeWork()</code></strong>：正常执行</li>
<li><strong>第二次循环</strong>：再次调用 <code>park()</code>，此时 permit = 0，线程真正阻塞</li>
<li><strong>问题</strong>：如果没有新的 <code>unpark()</code> 调用，线程将永远阻塞</li>
</ol>
<p>这不是活锁（活锁是线程一直运行但无法取得进展），而是<strong>意外阻塞</strong>——线程在不应该阻塞的时候被阻塞了。问题的根源是：<strong>permit 最多只能累积 1 个，一次 <code>unpark()</code> 只能抵消一次 <code>park()</code></strong>。</p>
<p><strong>正确的使用模式必须包含条件检查：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!condition) &#123;           <span class="hljs-comment">// 1. 检查条件</span><br>    LockSupport.park(blocker); <span class="hljs-comment">// 2. 条件不满足才 park</span><br>    <span class="hljs-comment">// 3. 被唤醒后回到循环开头重新检查条件</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个模式的关键在于：</p>
<ul>
<li><strong>条件检查在循环开头</strong>：即使因为虚假唤醒或 permit 提前消耗而从 <code>park()</code> 返回，也会重新检查条件</li>
<li><strong>条件满足时退出循环</strong>：不会无谓地再次 <code>park()</code></li>
<li><strong>条件不满足时才 <code>park()</code></strong>：确保每次 <code>park()</code> 都是有意义的等待</li>
</ul>
<p><strong>AQS 如何利用 permit 机制？</strong></p>
<p>AQS 在 <code>acquireQueued()</code> 方法中展示了 permit 的正确使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>        <span class="hljs-comment">// 1. 先尝试获取锁（条件检查）</span><br>        <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>            setHead(node);<br>            p.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> interrupted;<br>        &#125;<br>        <span class="hljs-comment">// 2. 获取失败才考虑 park</span><br>        <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>            parkAndCheckInterrupt())  <span class="hljs-comment">// 这里调用 park</span><br>            interrupted = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 3. 被唤醒后回到循环开头重新尝试获取锁</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>AQS 的设计确保了：</p>
<ul>
<li><strong>不会丢失唤醒</strong>：即使 <code>unpark</code> 先于 <code>park</code>，permit 会保证 <code>park</code> 立即返回</li>
<li><strong>不会无限阻塞</strong>：每次唤醒后都会重新检查获取锁的条件</li>
<li><strong>不会活锁</strong>：通过 <code>shouldParkAfterFailedAcquire</code> 确保只有在确实需要等待时才 park</li>
</ul>
<h4 id="脱离-aqs-直接使用-park-unpark-实现线程协调">脱离 AQS 直接使用 park/unpark 实现线程协调</h4>
<p>如果不依赖 AQS，仅使用 <code>park</code>/<code>unpark</code> 原语实现简单的线程阻塞与唤醒，需要解决一个核心问题：<strong>唤醒方如何获得被阻塞线程的引用？</strong></p>
<p><strong>基本模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 共享的线程引用——唤醒方需要知道要唤醒谁</span><br><span class="hljs-keyword">volatile</span> Thread waitingThread;<br><br><span class="hljs-comment">// 等待方（线程 A）</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">waiter</span><span class="hljs-params">()</span> &#123;<br>    waitingThread = Thread.currentThread();  <span class="hljs-comment">// 1. 发布自己的引用</span><br>    <span class="hljs-keyword">while</span> (!condition) &#123;                      <span class="hljs-comment">// 2. 检查条件</span><br>        LockSupport.park(<span class="hljs-built_in">this</span>);               <span class="hljs-comment">// 3. 阻塞（blocker 可选）</span><br>    &#125;<br>    waitingThread = <span class="hljs-literal">null</span>;                     <span class="hljs-comment">// 4. 清理引用</span><br>&#125;<br><br><span class="hljs-comment">// 唤醒方（线程 B）</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">signaler</span><span class="hljs-params">()</span> &#123;<br>    condition = <span class="hljs-literal">true</span>;                         <span class="hljs-comment">// 1. 设置条件</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> waitingThread;                 <span class="hljs-comment">// 2. 获取等待线程引用</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>        LockSupport.unpark(t);                <span class="hljs-comment">// 3. 唤醒指定线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="从零构建：基于-cas-park-unpark-的简易互斥锁">从零构建：基于 CAS + park/unpark 的简易互斥锁</h4>
<p>下面展示如何仅使用 <code>Unsafe.compareAndSwapInt</code>（CAS）和 <code>LockSupport.park/unpark</code> 构建一个可工作的互斥锁，不依赖 AQS 的队列机制。</p>
<p><strong>设计目标：</strong></p>
<ul>
<li>互斥性：同一时刻只有一个线程持有锁</li>
<li>可重入性：同一线程可以多次获取锁</li>
<li>阻塞等待：获取失败的线程阻塞而非忙等</li>
</ul>
<p><strong>Version 1：最简单的自旋锁（无 park）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> Thread owner;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-comment">// 自旋直到获取成功</span><br>        <span class="hljs-keyword">while</span> (!state.compareAndSet(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            <span class="hljs-comment">// 忙等待，消耗 CPU</span><br>        &#125;<br>        owner = current;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        owner = <span class="hljs-literal">null</span>;<br>        state.set(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>问题</strong>：纯自旋在高竞争下会浪费大量 CPU 时间。</p>
<p><strong>Version 2：自旋 + park 的混合锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpinParkLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNLOCKED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">LOCKED</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(UNLOCKED);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread owner;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread waiter;  <span class="hljs-comment">// 简化：只支持一个等待者</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <br>        <span class="hljs-comment">// 阶段1：快速路径——尝试直接 CAS 获取</span><br>        <span class="hljs-keyword">if</span> (state.compareAndSet(UNLOCKED, LOCKED)) &#123;<br>            owner = current;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 阶段2：自旋若干次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span> (state.compareAndSet(UNLOCKED, LOCKED)) &#123;<br>                owner = current;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            Thread.onSpinWait();  <span class="hljs-comment">// JDK 9+ 的自旋提示</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// 阶段3：自旋失败，准备阻塞</span><br>        waiter = current;  <span class="hljs-comment">// 发布自己的引用，让 unlock 知道要唤醒谁</span><br>        <br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 再次尝试获取（可能在我们设置 waiter 时锁已释放）</span><br>            <span class="hljs-keyword">if</span> (state.compareAndSet(UNLOCKED, LOCKED)) &#123;<br>                owner = current;<br>                waiter = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 获取失败，阻塞等待</span><br>            LockSupport.park(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-comment">// 被唤醒后回到循环开头重新尝试</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        owner = <span class="hljs-literal">null</span>;<br>        state.set(UNLOCKED);<br>        <br>        <span class="hljs-comment">// 唤醒等待者</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> waiter;<br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>) &#123;<br>            LockSupport.unpark(w);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Version 3：支持可重入的完整实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantSpinParkLock</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">UNLOCKED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(UNLOCKED);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread owner;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread waiter;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SPIN_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <br>        <span class="hljs-comment">// 可重入检查：如果当前线程已持有锁，直接增加计数</span><br>        <span class="hljs-keyword">if</span> (owner == current) &#123;<br>            state.incrementAndGet();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 快速路径</span><br>        <span class="hljs-keyword">if</span> (state.compareAndSet(UNLOCKED, <span class="hljs-number">1</span>)) &#123;<br>            owner = current;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 自旋阶段</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; SPIN_COUNT; i++) &#123;<br>            <span class="hljs-keyword">if</span> (state.compareAndSet(UNLOCKED, <span class="hljs-number">1</span>)) &#123;<br>                owner = current;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            Thread.onSpinWait();<br>        &#125;<br>        <br>        <span class="hljs-comment">// 阻塞阶段</span><br>        waiter = current;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">if</span> (state.compareAndSet(UNLOCKED, <span class="hljs-number">1</span>)) &#123;<br>                owner = current;<br>                waiter = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            LockSupport.park(<span class="hljs-built_in">this</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (owner != Thread.currentThread()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        &#125;<br>        <br>        <span class="hljs-type">int</span> <span class="hljs-variable">newState</span> <span class="hljs-operator">=</span> state.decrementAndGet();<br>        <span class="hljs-keyword">if</span> (newState == <span class="hljs-number">0</span>) &#123;<br>            owner = <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> waiter;<br>            <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>) &#123;<br>                LockSupport.unpark(w);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldByCurrentThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> owner == Thread.currentThread();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>时序图：两个线程竞争锁</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 1
    participant Lock as SpinParkLock
    participant T2 as 线程 2
    
    Note over T1: 获取锁
    T1-&gt;&gt;Lock: CAS(0→1) 成功
    T1-&gt;&gt;Lock: owner = T1
    
    Note over T2: 尝试获取锁
    T2-&gt;&gt;Lock: CAS(0→1) 失败
    T2-&gt;&gt;Lock: 自旋 64 次...
    T2-&gt;&gt;Lock: 仍然失败
    T2-&gt;&gt;Lock: waiter = T2
    T2-&gt;&gt;Lock: CAS(0→1) 再次失败
    T2-&gt;&gt;T2: park(lock)&lt;br/&gt;阻塞
    
    Note over T1: 释放锁
    T1-&gt;&gt;Lock: owner = null
    T1-&gt;&gt;Lock: state = 0
    T1-&gt;&gt;Lock: 读取 waiter = T2
    T1-&gt;&gt;T2: unpark(T2)
    
    Note over T2: 被唤醒
    T2-&gt;&gt;Lock: CAS(0→1) 成功
    T2-&gt;&gt;Lock: owner = T2
    T2-&gt;&gt;Lock: waiter = null</code></pre>
<p><strong>这个简易锁的局限性：</strong></p>
<table>
<thead>
<tr>
<th>局限</th>
<th>原因</th>
<th>AQS 的解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>只支持一个等待者</strong></td>
<td><code>waiter</code> 是单个引用</td>
<td>CLH 队列支持任意数量的等待者</td>
</tr>
<tr>
<td><strong>不保证公平性</strong></td>
<td>新来的线程可能抢先获取锁</td>
<td>公平模式下按队列顺序唤醒</td>
</tr>
<tr>
<td><strong>无超时支持</strong></td>
<td><code>park()</code> 无限等待</td>
<td><code>parkNanos()</code> 支持超时</td>
</tr>
<tr>
<td><strong>无中断响应</strong></td>
<td>被中断后继续尝试获取</td>
<td><code>lockInterruptibly()</code> 响应中断</td>
</tr>
<tr>
<td><strong>无条件变量</strong></td>
<td>不支持 <code>await()</code>/<code>signal()</code></td>
<td><code>ConditionObject</code> 提供完整支持</td>
</tr>
</tbody>
</table>
<p><strong>为什么需要 volatile？</strong></p>
<p>在上述实现中，<code>owner</code> 和 <code>waiter</code> 都声明为 <code>volatile</code>，原因如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">volatile</span> Thread owner;   <span class="hljs-comment">// 必须 volatile</span><br><span class="hljs-keyword">volatile</span> Thread waiter;  <span class="hljs-comment">// 必须 volatile</span><br></code></pre></td></tr></table></figure>
<ol>
<li>
<p><strong><code>owner</code> 的可见性</strong>：<code>unlock()</code> 中设置 <code>owner = null</code> 必须对其他线程立即可见，否则可重入检查 <code>owner == current</code> 可能读到过期值。</p>
</li>
<li>
<p><strong><code>waiter</code> 的可见性</strong>：<code>lock()</code> 中设置 <code>waiter = current</code> 必须对 <code>unlock()</code> 线程可见，否则 <code>unlock()</code> 可能读到 <code>null</code> 而不唤醒等待者。</p>
</li>
<li>
<p><strong>与 CAS 的配合</strong>：虽然 <code>AtomicInteger.compareAndSet</code> 本身有内存屏障效果，但 <code>owner</code> 和 <code>waiter</code> 的读写发生在 CAS 之外，需要 <code>volatile</code> 保证顺序。</p>
</li>
</ol>
<p><strong>不使用 volatile 的替代方案：</strong></p>
<p>如果想避免 <code>volatile</code>，可以将所有状态打包到一个原子变量中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PackedLock</span> &#123;<br>    <span class="hljs-comment">// 高 32 位：owner 线程的 hashCode（简化标识）</span><br>    <span class="hljs-comment">// 低 32 位：重入计数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br>    <br>    <span class="hljs-comment">// 但 waiter 仍然需要单独存储...</span><br>    <span class="hljs-comment">// 这就是为什么 AQS 使用 Node 队列的原因</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>结论</strong>：直接使用 <code>park</code>/<code>unpark</code> 构建锁是可行的，但一旦需要支持多等待者、公平性、超时、中断等特性，复杂度会急剧上升。AQS 的价值在于提供了一个经过充分测试的、功能完备的框架，让开发者只需实现 <code>tryAcquire</code>/<code>tryRelease</code> 即可获得完整的锁语义。</p>
<p><strong>必须处理的边界情况：</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>问题</th>
<th>解决方案</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>unpark 先于 park</strong></td>
<td>线程 B 在线程 A 调用 park 前就调用了 unpark</td>
<td><code>unpark</code> 会设置一个&quot;许可&quot;，后续的 <code>park</code> 会立即返回而不阻塞</td>
</tr>
</tbody>
</table>
<h4 id="locksupport-实战示例">LockSupport 实战示例</h4>
<p>以下示例展示 <code>LockSupport</code> 的核心特性，帮助理解 permit 机制的实际行为。</p>
<p><strong>示例 1：park/unpark 与 wait/notify 的对比</strong></p>
<p>使用 <code>wait/notify</code> 实现线程协调需要 <code>synchronized</code> 块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// wait/notify 方式：必须在 synchronized 块内</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNotifyExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (WaitNotifyExample.class) &#123;<br>                System.out.println(<span class="hljs-string">&quot;Worker: 准备等待&quot;</span>);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    WaitNotifyExample.class.wait();  <span class="hljs-comment">// 必须持有监视器锁</span><br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;Worker: 被唤醒，继续执行&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <br>        worker.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);  <span class="hljs-comment">// 确保 worker 先进入 wait</span><br>        <br>        <span class="hljs-keyword">synchronized</span> (WaitNotifyExample.class) &#123;<br>            WaitNotifyExample.class.notify();  <span class="hljs-comment">// 必须持有监视器锁</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>使用 <code>LockSupport</code> 则无需 <code>synchronized</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// park/unpark 方式：无需 synchronized</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockSupportExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Thread workerThread;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        workerThread = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Worker: 准备阻塞&quot;</span>);<br>            LockSupport.park();  <span class="hljs-comment">// 无需持有任何锁</span><br>            System.out.println(<span class="hljs-string">&quot;Worker: 被唤醒，继续执行&quot;</span>);<br>        &#125;);<br>        <br>        workerThread.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <br>        LockSupport.unpark(workerThread);  <span class="hljs-comment">// 精确唤醒指定线程</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键区别</strong>：</p>
<ul>
<li><code>wait()</code> 必须在 <code>synchronized</code> 块内调用，否则抛出 <code>IllegalMonitorStateException</code></li>
<li><code>park()</code> 可以在任何地方调用，无需持有任何锁</li>
<li><code>notify()</code> 随机唤醒一个等待线程，<code>unpark(thread)</code> 精确唤醒指定线程</li>
</ul>
<p><strong>示例 2：unpark 可以先于 park 调用</strong></p>
<p>这是 permit 机制最重要的特性——解决了 <code>wait/notify</code> 的时序问题：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UnparkBeforePark</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <br>        <span class="hljs-comment">// 先 unpark（发放许可）</span><br>        LockSupport.unpark(current);<br>        System.out.println(<span class="hljs-string">&quot;已发放许可&quot;</span>);<br>        <br>        <span class="hljs-comment">// 后 park（消费许可）——立即返回，不阻塞</span><br>        LockSupport.park();<br>        System.out.println(<span class="hljs-string">&quot;park 立即返回，未阻塞&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// 已发放许可</span><br><span class="hljs-comment">// park 立即返回，未阻塞</span><br></code></pre></td></tr></table></figure>
<p>这个特性在生产者-消费者模型中非常有用：生产者可能先于消费者准备好，此时 <code>unpark</code> 发放的许可会被保留，消费者随后调用 <code>park</code> 时立即返回。</p>
<p><strong>示例 3：permit 不可累积（二元信号量语义）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PermitNotAccumulate</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <br>        <span class="hljs-comment">// 连续三次 unpark</span><br>        LockSupport.unpark(current);<br>        LockSupport.unpark(current);<br>        LockSupport.unpark(current);<br>        <span class="hljs-comment">// permit 仍然只有 1 个，不会累积到 3</span><br>        <br>        System.out.println(<span class="hljs-string">&quot;a&quot;</span>);<br>        LockSupport.park();   <span class="hljs-comment">// 消费唯一的 permit，立即返回</span><br>        System.out.println(<span class="hljs-string">&quot;b&quot;</span>);<br>        LockSupport.park();   <span class="hljs-comment">// 没有 permit 了，永久阻塞！</span><br>        System.out.println(<span class="hljs-string">&quot;c&quot;</span>);  <span class="hljs-comment">// 永远不会执行</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// a</span><br><span class="hljs-comment">// b</span><br><span class="hljs-comment">// （程序阻塞，不会打印 c）</span><br></code></pre></td></tr></table></figure>
<p><strong>这就是为什么 permit 最多只能累积 1 个</strong>：<code>LockSupport</code> 设计为精确的一对一唤醒机制，而非通用的计数信号量。</p>
<p><strong>示例 4：park 响应中断但不抛出 InterruptedException</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ParkInterruptBehavior</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Worker: 准备 park&quot;</span>);<br>            LockSupport.park();<br>            <span class="hljs-comment">// park 被中断后返回，但不抛出异常</span><br>            System.out.println(<span class="hljs-string">&quot;Worker: park 返回，中断状态 = &quot;</span> <br>                + Thread.currentThread().isInterrupted());<br>        &#125;);<br>        <br>        worker.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <br>        worker.interrupt();  <span class="hljs-comment">// 中断 worker 线程</span><br>        worker.join();<br>        System.out.println(<span class="hljs-string">&quot;Main: 结束&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Worker: 准备 park</span><br><span class="hljs-comment">// Worker: park 返回，中断状态 = true</span><br><span class="hljs-comment">// Main: 结束</span><br></code></pre></td></tr></table></figure>
<p><strong>关键行为</strong>：</p>
<ul>
<li><code>park()</code> 会响应中断——被中断后立即返回</li>
<li>但 <code>park()</code> <strong>不会抛出 <code>InterruptedException</code></strong></li>
<li>中断状态被<strong>保留</strong>（<code>isInterrupted()</code> 返回 <code>true</code>）</li>
<li>这与 <code>wait()</code>、<code>sleep()</code> 不同，后者会抛出异常并<strong>清除</strong>中断状态</li>
</ul>
<p><strong>这就是为什么 AQS 中的 <code>parkAndCheckInterrupt()</code> 要检查中断状态：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS 中的实现</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();  <span class="hljs-comment">// 检查并清除中断状态</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>示例 5：blocker 参数的诊断价值</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlockerDiagnostics</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">BLOCKER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MyCustomBlocker&quot;</span>;<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            LockSupport.park(BLOCKER);  <span class="hljs-comment">// 传入 blocker 对象</span><br>        &#125;, <span class="hljs-string">&quot;WorkerThread&quot;</span>);<br>        <br>        worker.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        <br>        <span class="hljs-comment">// 获取 blocker 信息（用于诊断）</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">blocker</span> <span class="hljs-operator">=</span> LockSupport.getBlocker(worker);<br>        System.out.println(<span class="hljs-string">&quot;Worker 的 blocker: &quot;</span> + blocker);<br>        <br>        LockSupport.unpark(worker);<br>        worker.join();<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 输出：</span><br><span class="hljs-comment">// Worker 的 blocker: MyCustomBlocker</span><br></code></pre></td></tr></table></figure>
<p>在 <code>jstack</code> 输出中，blocker 信息会显示为：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-string">&quot;WorkerThread&quot;</span> #12 <span class="hljs-attribute">prio</span>=5 <span class="hljs-attribute">os_prio</span>=0 <span class="hljs-attribute">tid</span>=0x... <span class="hljs-attribute">nid</span>=0x... waiting on condition<br>   java.lang.Thread.State: WAITING (parking)<br>        at sun.misc.Unsafe.park(Native Method)<br>        - parking <span class="hljs-keyword">to</span> wait <span class="hljs-keyword">for</span>  &lt;0x<span class="hljs-built_in">..</span>.&gt; (a MyCustomBlocker)<br></code></pre></td></tr></table></figure>
<p>| <strong>虚假唤醒</strong> | park 可能在没有 unpark 的情况下返回 | 必须在循环中检查条件：<code>while (!condition) park()</code> |</p>
<h4 id="hotspot-源码解析：parker-类如何实现-permit-语义">HotSpot 源码解析：Parker 类如何实现 permit 语义</h4>
<p><code>LockSupport.park()</code> 和 <code>unpark()</code> 最终调用的是 <code>Unsafe.park()</code> 和 <code>Unsafe.unpark()</code>，而这两个 native 方法在 HotSpot 中由 <code>Parker</code> 类实现。理解 <code>Parker</code> 的实现是理解 permit 机制的关键。</p>
<p><strong>Parker 类的核心结构（Linux 平台）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// hotspot/src/os/posix/os_posix.hpp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PlatformParker</span> : <span class="hljs-keyword">public</span> CHeapObj&lt;mtInternal&gt; &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">pthread_mutex_t</span> _mutex[<span class="hljs-number">1</span>];    <span class="hljs-comment">// POSIX 互斥量</span><br>    <span class="hljs-type">pthread_cond_t</span>  _cond[<span class="hljs-number">1</span>];     <span class="hljs-comment">// POSIX 条件变量</span><br>    <span class="hljs-comment">// ...</span><br>&#125;;<br><br><span class="hljs-comment">// hotspot/src/share/runtime/park.hpp</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Parker</span> : <span class="hljs-keyword">public</span> os::PlatformParker &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> _counter;  <span class="hljs-comment">// 核心：permit 计数器（0 或 1）</span><br>    <span class="hljs-comment">// ...</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">park</span><span class="hljs-params">(<span class="hljs-type">bool</span> isAbsolute, jlong time)</span></span>;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">unpark</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">// ...</span><br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>关键字段 <code>_counter</code> 的语义：</strong></p>
<ul>
<li><code>_counter == 0</code>：没有可用的 permit，<code>park()</code> 将阻塞</li>
<li><code>_counter == 1</code>：有一个可用的 permit，<code>park()</code> 将立即返回并消费它</li>
</ul>
<p><strong><code>Parker::park()</code> 的核心实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parker::park</span><span class="hljs-params">(<span class="hljs-type">bool</span> isAbsolute, jlong time)</span> </span>&#123;<br>    <span class="hljs-comment">// 快速路径：尝试原子地消费 permit</span><br>    <span class="hljs-comment">// 如果 _counter &gt; 0，将其设为 0 并立即返回</span><br>    <span class="hljs-keyword">if</span> (Atomic::<span class="hljs-built_in">xchg</span>(<span class="hljs-number">0</span>, &amp;_counter) &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>    <br>    <span class="hljs-comment">// 慢速路径：需要阻塞等待</span><br>    Thread* thread = Thread::<span class="hljs-built_in">current</span>();<br>    <br>    <span class="hljs-comment">// 获取互斥锁</span><br>    <span class="hljs-type">int</span> status = <span class="hljs-built_in">pthread_mutex_lock</span>(_mutex);<br>    <br>    <span class="hljs-comment">// 双重检查：在持有锁的情况下再次检查 _counter</span><br>    <span class="hljs-comment">// 这是为了处理在获取锁之前 unpark 被调用的情况</span><br>    <span class="hljs-keyword">if</span> (_counter &gt; <span class="hljs-number">0</span>) &#123;<br>        _counter = <span class="hljs-number">0</span>;<br>        status = <span class="hljs-built_in">pthread_mutex_unlock</span>(_mutex);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 真正的阻塞等待</span><br>    <span class="hljs-keyword">if</span> (time == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 无限等待</span><br>        status = <span class="hljs-built_in">pthread_cond_wait</span>(_cond, _mutex);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 带超时的等待</span><br>        status = <span class="hljs-built_in">pthread_cond_timedwait</span>(_cond, _mutex, &amp;absTime);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 被唤醒后，消费 permit 并释放锁</span><br>    _counter = <span class="hljs-number">0</span>;<br>    status = <span class="hljs-built_in">pthread_mutex_unlock</span>(_mutex);<br>    <br>    <span class="hljs-comment">// 内存屏障，确保可见性</span><br>    OrderAccess::<span class="hljs-built_in">fence</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong><code>Parker::unpark()</code> 的核心实现：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Parker::unpark</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> status = <span class="hljs-built_in">pthread_mutex_lock</span>(_mutex);<br>    <br>    <span class="hljs-type">int</span> s = _counter;<br>    _counter = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 发放 permit（无论之前是 0 还是 1）</span><br>    <br>    <span class="hljs-comment">// 只有当之前没有 permit 时才需要唤醒</span><br>    <span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 唤醒在 pthread_cond_wait 上阻塞的线程</span><br>        status = <span class="hljs-built_in">pthread_cond_signal</span>(_cond);<br>    &#125;<br>    <br>    status = <span class="hljs-built_in">pthread_mutex_unlock</span>(_mutex);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>permit 语义的实现要点：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as 线程 A (parker)
    participant Counter as _counter
    participant T2 as 线程 B (unparker)
    
    Note over Counter: 初始值 = 0
    
    alt 场景1：park 先于 unpark
        T1-&gt;&gt;Counter: Atomic::xchg(0, &amp;_counter)
        Note over Counter: 返回 0，需要阻塞
        T1-&gt;&gt;T1: pthread_cond_wait() 阻塞
        T2-&gt;&gt;Counter: _counter = 1
        T2-&gt;&gt;T1: pthread_cond_signal()
        T1-&gt;&gt;Counter: _counter = 0（消费 permit）
        Note over T1: park() 返回
    end
    
    alt 场景2：unpark 先于 park
        T2-&gt;&gt;Counter: _counter = 1
        Note over Counter: permit 已发放
        T1-&gt;&gt;Counter: Atomic::xchg(0, &amp;_counter)
        Note over Counter: 返回 1，立即消费
        Note over T1: park() 立即返回，不阻塞
    end
    
    alt 场景3：多次 unpark
        T2-&gt;&gt;Counter: _counter = 1
        T2-&gt;&gt;Counter: _counter = 1（幂等，仍为 1）
        T2-&gt;&gt;Counter: _counter = 1（幂等，仍为 1）
        T1-&gt;&gt;Counter: Atomic::xchg(0, &amp;_counter)
        Note over Counter: 返回 1，消费唯一的 permit
        T1-&gt;&gt;Counter: Atomic::xchg(0, &amp;_counter)
        Note over Counter: 返回 0，需要阻塞
        Note over T1: 第二次 park() 阻塞
    end</code></pre>
<p><strong>为什么使用 <code>Atomic::xchg</code> 而非简单的读取？</strong></p>
<p><code>Atomic::xchg(0, &amp;_counter)</code> 是一个原子交换操作，它同时完成两件事：</p>
<ol>
<li>读取 <code>_counter</code> 的当前值</li>
<li>将 <code>_counter</code> 设置为 0</li>
</ol>
<p>这个操作具有完整的内存屏障语义，确保：</p>
<ul>
<li>如果 permit 可用（<code>_counter == 1</code>），立即消费它并返回</li>
<li>如果 permit 不可用（<code>_counter == 0</code>），进入慢速路径</li>
</ul>
<p>使用原子操作而非普通读取是为了避免竞态条件：如果先读取再设置，可能在读取和设置之间被其他线程的 <code>unpark</code> 打断。</p>
<h4 id="虚假唤醒-spurious-wakeup-：为什么必须在循环中检查条件">虚假唤醒（Spurious Wakeup）：为什么必须在循环中检查条件</h4>
<p><code>park()</code> 可能在以下情况下返回，即使没有对应的 <code>unpark()</code> 调用：</p>
<ol>
<li><strong>POSIX 条件变量的虚假唤醒</strong>：<code>pthread_cond_wait()</code> 规范允许虚假唤醒</li>
<li><strong>中断</strong>：线程被 <code>interrupt()</code> 中断</li>
<li><strong>超时</strong>：使用 <code>parkNanos()</code> 或 <code>parkUntil()</code> 时超时返回</li>
</ol>
<p><strong>虚假唤醒的根本原因：</strong></p>
<p>POSIX 标准明确指出，<code>pthread_cond_wait()</code> 可能在没有对应 <code>pthread_cond_signal()</code> 的情况下返回。这是一个有意的设计决策，允许实现在某些情况下（如信号处理、多处理器同步）更高效地工作。</p>
<p><strong>错误的使用方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 错误示例：不检查条件，假设 park 返回意味着条件满足</span><br>LockSupport.park();<br><span class="hljs-comment">// 直接执行后续逻辑，可能条件并未满足！</span><br>doSomething();<br></code></pre></td></tr></table></figure>
<p><strong>正确的使用方式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 正确示例：在循环中检查条件</span><br><span class="hljs-keyword">while</span> (!conditionSatisfied()) &#123;<br>    LockSupport.park(blocker);<br>    <span class="hljs-comment">// 被唤醒后回到循环开头，重新检查条件</span><br>    <span class="hljs-comment">// 如果是虚假唤醒，条件不满足，继续 park</span><br>    <span class="hljs-comment">// 如果是真正的唤醒，条件满足，退出循环</span><br>&#125;<br>doSomething();<br></code></pre></td></tr></table></figure>
<p><strong>AQS 中的正确模式：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.acquireQueued()</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;  <span class="hljs-comment">// 无限循环</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>        <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;  <span class="hljs-comment">// 检查条件</span><br>            setHead(node);<br>            p.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> interrupted;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>            parkAndCheckInterrupt())  <span class="hljs-comment">// park 在循环内</span><br>            interrupted = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 被唤醒后回到循环开头，重新检查条件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>虚假唤醒与 permit 机制的关系：</strong></p>
<table>
<thead>
<tr>
<th>唤醒类型</th>
<th>permit 状态</th>
<th>条件检查结果</th>
<th>行为</th>
</tr>
</thead>
<tbody>
<tr>
<td>正常唤醒（unpark）</td>
<td>被消费</td>
<td>条件满足</td>
<td>退出循环，继续执行</td>
</tr>
<tr>
<td>虚假唤醒</td>
<td>未变化（仍为 0）</td>
<td>条件不满足</td>
<td>继续循环，再次 park</td>
</tr>
<tr>
<td>中断唤醒</td>
<td>未变化（仍为 0）</td>
<td>条件不满足</td>
<td>根据策略处理中断</td>
</tr>
</tbody>
</table>
<p><strong>关键理解</strong>：permit 机制解决的是&quot;唤醒丢失&quot;问题（unpark 先于 park），而循环检查解决的是&quot;虚假唤醒&quot;问题。两者相辅相成，缺一不可。</p>
<h4 id="超时等待的实现：reentrantlock-trylock-timeout-unit-原理">超时等待的实现：ReentrantLock.tryLock(timeout, unit) 原理</h4>
<p><code>tryLock(long timeout, TimeUnit unit)</code> 是 <code>ReentrantLock</code> 提供的带超时的锁获取方法，它基于 <code>LockSupport.parkNanos()</code> 实现。理解其实现原理有助于掌握超时等待的正确模式。</p>
<p><strong>tryLock 超时版本的使用场景：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSomethingWithTimeout</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">acquired</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 尝试在 5 秒内获取锁</span><br>        acquired = lock.tryLock(<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (acquired) &#123;<br>            <span class="hljs-comment">// 成功获取锁，执行临界区代码</span><br>            doCriticalWork();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 超时未获取到锁，执行降级逻辑</span><br>            handleTimeout();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt();<br>        handleInterruption();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (acquired) &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>AQS 中 tryAcquireNanos 的核心实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <br>    <span class="hljs-comment">// 先尝试快速获取，成功则直接返回</span><br>    <span class="hljs-keyword">return</span> tryAcquire(arg) ||<br>           doAcquireNanos(arg, nanosTimeout);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">doAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 计算截止时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>    <br>    <span class="hljs-comment">// 创建节点并加入队列</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                p.next = <span class="hljs-literal">null</span>;<br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 成功获取锁</span><br>            &#125;<br>            <br>            <span class="hljs-comment">// 计算剩余等待时间</span><br>            nanosTimeout = deadline - System.nanoTime();<br>            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 超时，获取失败</span><br>            <br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                nanosTimeout &gt; spinForTimeoutThreshold)<br>                <span class="hljs-comment">// 使用 parkNanos 进行带超时的阻塞</span><br>                LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br>            <br>            <span class="hljs-comment">// 检查中断</span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>超时等待的时序图：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T as 线程
    participant AQS as AQS
    participant LS as LockSupport
    participant OS as 操作系统
    
    Note over T: tryLock(5, SECONDS)
    
    T-&gt;&gt;AQS: tryAcquireNanos(1, 5_000_000_000L)
    AQS-&gt;&gt;AQS: tryAcquire(1)
    Note over AQS: 快速路径失败
    
    AQS-&gt;&gt;AQS: doAcquireNanos()
    Note over AQS: deadline = now + 5s
    
    AQS-&gt;&gt;AQS: addWaiter(EXCLUSIVE)
    
    loop 自旋 + 超时检查
        AQS-&gt;&gt;AQS: tryAcquire(1)
        Note over AQS: 获取失败
        
        AQS-&gt;&gt;AQS: 计算 nanosTimeout
        
        alt nanosTimeout &lt;= 0
            Note over AQS: 超时！
            AQS--&gt;&gt;T: return false
        else nanosTimeout &gt; spinThreshold
            AQS-&gt;&gt;LS: parkNanos(this, nanosTimeout)
            LS-&gt;&gt;OS: pthread_cond_timedwait()
            Note over T: 阻塞等待&lt;br/&gt;最多 nanosTimeout 纳秒
            
            alt 被 unpark 唤醒
                OS--&gt;&gt;LS: 返回
                LS--&gt;&gt;AQS: 返回
                Note over AQS: 继续循环尝试获取
            else 超时返回
                OS--&gt;&gt;LS: 超时返回
                LS--&gt;&gt;AQS: 返回
                Note over AQS: 检查剩余时间
            end
        else nanosTimeout &lt;= spinThreshold
            Note over AQS: 剩余时间太短&lt;br/&gt;自旋而非 park
        end
    end</code></pre>
<p><strong>spinForTimeoutThreshold 的设计意图：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AQS 中的常量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">spinForTimeoutThreshold</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000L</span>;  <span class="hljs-comment">// 1 微秒</span><br></code></pre></td></tr></table></figure>
<p>当剩余等待时间小于 1 微秒时，AQS 选择自旋而非调用 <code>parkNanos()</code>。原因是：</p>
<ol>
<li><strong>系统调用开销</strong>：<code>parkNanos()</code> 最终会调用操作系统的 <code>pthread_cond_timedwait()</code>，这是一个系统调用，开销约为几微秒</li>
<li><strong>精度问题</strong>：操作系统的定时器精度有限，极短的超时可能不准确</li>
<li><strong>性能权衡</strong>：对于极短的等待，自旋的 CPU 开销小于系统调用的开销</li>
</ol>
<p><strong>Condition.awaitNanos() 的类似实现：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConditionObject.awaitNanos()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanosTimeout;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>) &#123;<br>            <span class="hljs-comment">// 超时，自己转移到同步队列</span><br>            transferAfterCancelledWait(node);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nanosTimeout &gt;= spinForTimeoutThreshold)<br>            LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanosTimeout);<br>        <br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        nanosTimeout = deadline - System.nanoTime();<br>    &#125;<br>    <br>    <span class="hljs-comment">// 重新获取锁...</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <br>    <span class="hljs-comment">// 返回剩余时间（可能为负，表示超时）</span><br>    <span class="hljs-keyword">return</span> deadline - System.nanoTime();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>超时等待的返回值语义：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>返回值类型</th>
<th>成功</th>
<th>超时</th>
<th>中断</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tryLock(timeout, unit)</code></td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>抛出 <code>InterruptedException</code></td>
</tr>
<tr>
<td><code>awaitNanos(nanos)</code></td>
<td><code>long</code></td>
<td>剩余时间 &gt; 0</td>
<td>剩余时间 ≤ 0</td>
<td>抛出 <code>InterruptedException</code></td>
</tr>
<tr>
<td><code>await(time, unit)</code></td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>抛出 <code>InterruptedException</code></td>
</tr>
<tr>
<td><code>awaitUntil(deadline)</code></td>
<td><code>boolean</code></td>
<td><code>true</code></td>
<td><code>false</code></td>
<td>抛出 <code>InterruptedException</code></td>
</tr>
</tbody>
</table>
<p>| <strong>引用发布时机</strong> | 线程 A 发布引用后、park 前，线程 B 就调用了 unpark | 同上，许可机制保证不会丢失唤醒 |<br>
| <strong>多个等待者</strong> | 多个线程都在等待同一个条件 | 需要使用队列管理等待线程，这正是 AQS 所做的事情 |</p>
<p><strong>为什么 AQS 不直接暴露这些细节？</strong></p>
<p>AQS 封装了上述所有复杂性：</p>
<ol>
<li><strong>CLH 队列</strong>：管理多个等待线程的引用</li>
<li><strong>Node 节点</strong>：每个节点持有等待线程的引用（<code>Node.thread</code>）</li>
<li><strong>状态机</strong>：通过 <code>waitStatus</code> 管理节点状态，确保正确的唤醒顺序</li>
<li><strong>自旋 + park</strong>：在 park 前先自旋尝试，减少不必要的阻塞</li>
</ol>
<p>直接使用 <code>park</code>/<code>unpark</code> 虽然可行，但一旦涉及多线程竞争、公平性、可重入等需求，手工管理的复杂度会急剧上升。AQS 的价值正在于此。</p>
<h3 id="重要区分：blocker-与本文其他-记录对象-的本质区别">重要区分：blocker 与本文其他&quot;记录对象&quot;的本质区别</h3>
<p>在本文中，我们讨论了多种&quot;记录对象&quot;：锁对象、Lock Record、ObjectMonitor 等。<strong>blocker 与它们有本质的不同</strong>，这一点必须强调：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;参与锁逻辑的记录对象&quot;
        direction TB
        
        LR[&quot;Lock Record&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 存储 Displaced Mark Word&lt;br/&gt;• owner 指向锁对象&lt;br/&gt;• Mark Word 指向它表示持锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;删除它 = 锁逻辑崩溃&quot;]
        
        MON[&quot;ObjectMonitor&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• _owner 记录持锁线程&lt;br/&gt;• _EntryList 管理等待队列&lt;br/&gt;• _WaitSet 管理 wait 队列&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;删除它 = 锁逻辑崩溃&quot;]
        
        AQS_STATE[&quot;AQS.state&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 记录锁的持有状态&lt;br/&gt;• 0 = 无锁，&gt;0 = 已锁定&lt;br/&gt;• CAS 修改它 = 获取/释放锁&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;删除它 = 锁逻辑崩溃&quot;]
        
        style LR fill:#ffcdd2
        style MON fill:#ffcdd2
        style AQS_STATE fill:#ffcdd2
    end
    
    subgraph &quot;纯诊断用途的标记&quot;
        direction TB
        
        BLOCKER[&quot;Thread.parkBlocker&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 仅用于 jstack/JFR 显示&lt;br/&gt;• 不参与任何锁逻辑&lt;br/&gt;• 传 null 也能正常 park&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;删除它 = 锁照常工作&lt;br/&gt;   只是诊断信息丢失&quot;]
        
        style BLOCKER fill:#c8e6c9
    end</code></pre>
<p><strong>对比表：blocker vs 其他记录对象</strong></p>
<table>
<thead>
<tr>
<th>维度</th>
<th>Lock Record / Monitor / AQS.state</th>
<th>Thread.parkBlocker</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>是否参与锁逻辑</strong></td>
<td>是，核心组成部分</td>
<td>否，完全不参与</td>
</tr>
<tr>
<td><strong>删除后果</strong></td>
<td>锁机制崩溃</td>
<td>锁照常工作，仅丢失诊断信息</td>
</tr>
<tr>
<td><strong>记录的信息</strong></td>
<td>持锁线程、等待队列、锁状态</td>
<td>“线程在等待什么”（纯标签）</td>
</tr>
<tr>
<td><strong>谁读取它</strong></td>
<td>JVM 锁实现代码</td>
<td>jstack、JFR 等诊断工具</td>
</tr>
<tr>
<td><strong>设置时机</strong></td>
<td>获取锁时</td>
<td>park() 前设置，unpark() 后清除</td>
</tr>
<tr>
<td><strong>生命周期</strong></td>
<td>与锁的持有周期一致</td>
<td>仅在线程阻塞期间有效</td>
</tr>
</tbody>
</table>
<p><strong>一句话总结：blocker 是&quot;旁观者&quot;，不是&quot;参与者&quot;。</strong> 它就像一个便利贴，贴在线程上告诉诊断工具&quot;我在等什么&quot;，但撕掉这个便利贴，线程该怎么等还是怎么等。</p>
<h3 id="blocker-来自哪里？">blocker 来自哪里？</h3>
<p>blocker 的来源取决于调用 <code>LockSupport.park()</code> 的上下文。在 AQS 体系中，主要有两种来源：</p>
<p><strong>1. 在 Sync Queue（同步队列）中等待锁时：blocker = AQS 实例本身</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// this = AQS 子类实例（如 ReentrantLock.Sync）</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时 <code>this</code> 就是 <code>ReentrantLock</code> 内部的 <code>Sync</code> 对象（继承自 AQS）。</p>
<p><strong>2. 在 Condition Queue（条件队列）中等待条件时：blocker = ConditionObject 实例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.ConditionObject.java</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// this = ConditionObject 实例</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>此时 <code>this</code> 是 <code>ConditionObject</code>，它是 AQS 的内部类。</p>
<h3 id="condition-await-与-signal-的完整时序图">Condition.await() 与 signal() 的完整时序图</h3>
<p><code>Condition</code> 的 <code>await()</code> 和 <code>signal()</code> 是基于 <code>LockSupport.park()</code> 和 <code>unpark()</code> 实现的。理解它们的交互时序是掌握条件变量的关键。</p>
<p><strong>完整时序图：await() 与 signal() 的协作</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant TA as 线程 A（等待者）
    participant Lock as ReentrantLock
    participant Sync as AQS.Sync
    participant Cond as ConditionObject
    participant CQ as 条件队列
    participant SQ as 同步队列
    participant TB as 线程 B（唤醒者）
    
    Note over TA,TB: 阶段1：线程 A 调用 await()
    
    TA-&gt;&gt;Lock: lock.lock()
    Lock-&gt;&gt;Sync: acquire(1)
    Note over Sync: 线程 A 获取锁成功
    
    TA-&gt;&gt;Cond: condition.await()
    Cond-&gt;&gt;Cond: addConditionWaiter()
    Note over Cond: 创建 Node(CONDITION)
    Cond-&gt;&gt;CQ: 加入条件队列尾部
    
    Cond-&gt;&gt;Sync: fullyRelease(node)
    Note over Sync: 完全释放锁&lt;br/&gt;savedState = state&lt;br/&gt;state = 0
    
    Note over TA: 进入等待循环
    
    loop while (!isOnSyncQueue(node))
        TA-&gt;&gt;TA: LockSupport.park(this)
        Note over TA: blocker = ConditionObject&lt;br/&gt;线程 A 阻塞在条件队列
    end
    
    Note over TA,TB: 阶段2：线程 B 调用 signal()
    
    TB-&gt;&gt;Lock: lock.lock()
    Lock-&gt;&gt;Sync: acquire(1)
    Note over Sync: 线程 B 获取锁成功
    
    TB-&gt;&gt;Cond: condition.signal()
    Cond-&gt;&gt;CQ: 取出 firstWaiter
    Cond-&gt;&gt;Cond: transferForSignal(node)
    
    Note over Cond: 1. CAS: waitStatus&lt;br/&gt;   CONDITION → 0
    Cond-&gt;&gt;SQ: enq(node)
    Note over SQ: 节点转移到同步队列
    
    Note over Cond: 2. 设置前驱节点&lt;br/&gt;   waitStatus = SIGNAL
    
    Cond-&gt;&gt;TA: LockSupport.unpark(node.thread)
    Note over TA: 线程 A 被唤醒
    
    TB-&gt;&gt;Lock: lock.unlock()
    Lock-&gt;&gt;Sync: release(1)
    Note over Sync: 线程 B 释放锁
    
    Note over TA,TB: 阶段3：线程 A 重新竞争锁
    
    Note over TA: park() 返回&lt;br/&gt;isOnSyncQueue = true&lt;br/&gt;退出等待循环
    
    TA-&gt;&gt;Sync: acquireQueued(node, savedState)
    
    loop 自旋获取锁
        TA-&gt;&gt;Sync: tryAcquire(savedState)
        alt 获取成功
            Note over TA: 恢复之前的锁状态
        else 获取失败
            TA-&gt;&gt;TA: LockSupport.park(this)
            Note over TA: blocker = Sync&lt;br/&gt;在同步队列中等待
        end
    end
    
    Note over TA: await() 返回&lt;br/&gt;线程 A 继续执行</code></pre>
<p><strong>关键状态转换：节点在两个队列间的迁移</strong></p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; HoldLock: lock.lock() 成功
    
    HoldLock: 持有锁
    HoldLock: await() 返回后继续执行临界区代码
    
    ConditionWait: 条件队列等待
    ConditionWait: Node.waitStatus = CONDITION (-2)
    ConditionWait: blocker = ConditionObject
    ConditionWait: 锁已释放
    
    SyncWait: 同步队列等待
    SyncWait: Node.waitStatus = 0 → SIGNAL
    SyncWait: blocker = Sync
    SyncWait: 等待重新获取锁
    
    HoldLock --&gt; ConditionWait: await() 调用
    ConditionWait --&gt; SyncWait: signal() 调用
    SyncWait --&gt; HoldLock: 获取锁成功
    HoldLock --&gt; [*]: lock.unlock()</code></pre>
<p><strong>blocker 的切换过程详解：</strong></p>
<table>
<thead>
<tr>
<th>阶段</th>
<th>线程状态</th>
<th>所在队列</th>
<th>blocker 值</th>
<th>park 调用位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>获取锁成功</td>
<td>RUNNABLE</td>
<td>无</td>
<td>null</td>
<td>-</td>
</tr>
<tr>
<td>await() 阻塞</td>
<td>WAITING</td>
<td>条件队列</td>
<td>ConditionObject</td>
<td><code>ConditionObject.await()</code></td>
</tr>
<tr>
<td>signal() 唤醒</td>
<td>RUNNABLE</td>
<td>同步队列</td>
<td>null（短暂）</td>
<td>-</td>
</tr>
<tr>
<td>竞争锁失败</td>
<td>WAITING</td>
<td>同步队列</td>
<td>Sync</td>
<td><code>AQS.acquireQueued()</code></td>
</tr>
<tr>
<td>获取锁成功</td>
<td>RUNNABLE</td>
<td>无</td>
<td>null</td>
<td>-</td>
</tr>
</tbody>
</table>
<p><strong>await() 的核心代码路径：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.ConditionObject</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <br>    <span class="hljs-comment">// 1. 创建节点，加入条件队列</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <br>    <span class="hljs-comment">// 2. 完全释放锁，保存之前的状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 3. 等待被转移到同步队列</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// blocker = ConditionObject</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 4. 重新获取锁（此时已在同步队列中）</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <br>    <span class="hljs-comment">// 5. 清理和中断处理</span><br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>)<br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>signal() 的核心代码路径：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.ConditionObject</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>        doSignal(first);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 从条件队列移除</span><br>        <span class="hljs-keyword">if</span> ((firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>            lastWaiter = <span class="hljs-literal">null</span>;<br>        first.nextWaiter = <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;  <span class="hljs-comment">// 转移到同步队列</span><br>             (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>&#125;<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// CAS 修改状态：CONDITION → 0</span><br>    <span class="hljs-keyword">if</span> (!node.compareAndSetWaitStatus(Node.CONDITION, <span class="hljs-number">0</span>))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <br>    <span class="hljs-comment">// 加入同步队列</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>    <br>    <span class="hljs-comment">// 设置前驱为 SIGNAL，或直接唤醒</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !p.compareAndSetWaitStatus(ws, Node.SIGNAL))<br>        LockSupport.unpark(node.thread);<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="aqs-中-park-unpark-的调用时机与状态变化">AQS 中 park/unpark 的调用时机与状态变化</h3>
<p>理解 AQS 何时调用 <code>park()</code> 和 <code>unpark()</code> 是理解 blocker 的关键。下面我们通过图解来说明 AQS 内部的调用时机、方法参数以及调用后的状态变化。</p>
<p><strong>图1：ReentrantLock.lock() 的 park 调用时机</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T as 线程B
    participant RL as ReentrantLock
    participant AQS as AQS_Sync
    participant LS as LockSupport
    participant TB as ThreadB
    
    Note over T,TB: 假设线程A已持有锁,线程B尝试获取
    
    T-&gt;&gt;RL: lock()
    RL-&gt;&gt;AQS: acquire(1)
    AQS-&gt;&gt;AQS: tryAcquire(1)
    Note over AQS: 返回false,锁被A持有
    
    AQS-&gt;&gt;AQS: addWaiter(Node.EXCLUSIVE)
    Note over AQS: 创建Node,加入同步队列
    
    AQS-&gt;&gt;AQS: acquireQueued(node, 1)
    
    rect rgb(255, 245, 238)
        Note over AQS: 自旋尝试阶段
        AQS-&gt;&gt;AQS: tryAcquire(1)
        Note over AQS: 返回false
        AQS-&gt;&gt;AQS: shouldParkAfterFailedAcquire()
        Note over AQS: 返回true,前驱节点状态正确
        
        AQS-&gt;&gt;AQS: parkAndCheckInterrupt()
        Note over AQS: 准备阻塞线程
        
        AQS-&gt;&gt;LS: park(this)
        Note over LS: blocker=AQS实例即ReentrantLock$Sync
        
        LS-&gt;&gt;TB: setBlocker(blocker)
        Note over TB: parkBlocker=Sync
        
        LS-&gt;&gt;TB: Unsafe.park()
        Note over TB: 线程B阻塞,jstack可见parking to wait for
    end</code></pre>
<p><strong>图2：ReentrantLock.unlock() 的 unpark 调用时机</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant TA as 线程 A（持锁者）
    participant RL as ReentrantLock
    participant AQS as AQS (Sync)
    participant LS as LockSupport
    participant TB as Thread B（等待者）
    
    Note over TA,TB: 线程 A 释放锁，唤醒等待的线程 B
    
    TA-&gt;&gt;RL: unlock()
    RL-&gt;&gt;AQS: release(1)
    AQS-&gt;&gt;AQS: tryRelease(1)
    Note over AQS: state: 1 → 0&lt;br/&gt;exclusiveOwnerThread: A → null
    
    AQS-&gt;&gt;AQS: unparkSuccessor(head)
    Note over AQS: 找到队列中第一个等待的节点
    
    AQS-&gt;&gt;LS: unpark(thread B)
    Note over LS: 参数是线程对象，不是 blocker
    
    LS-&gt;&gt;TB: Unsafe.unpark(thread B)
    Note over TB: 线程 B 被唤醒
    
    Note over TB: park() 返回
    TB-&gt;&gt;TB: setBlocker(null)
    Note over TB: parkBlocker = null&lt;br/&gt;（自动清除）
    
    TB-&gt;&gt;AQS: 继续 acquireQueued 循环
    AQS-&gt;&gt;AQS: tryAcquire(1)
    Note over AQS: 返回 true（锁已释放）&lt;br/&gt;state: 0 → 1&lt;br/&gt;exclusiveOwnerThread: null → B
    
    Note over TB: 线程 B 获取锁成功</code></pre>
<p><strong>图3：AQS 状态变化与 park/unpark 的关系</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;AQS 内部状态&quot;
        STATE[&quot;state 字段&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;0 = 无锁&lt;br/&gt;1 = 已锁定（非重入）&lt;br/&gt;n = 重入 n 次&quot;]
        
        OWNER[&quot;exclusiveOwnerThread&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;null = 无持有者&lt;br/&gt;Thread = 持锁线程&quot;]
        
        QUEUE[&quot;同步队列（简化）&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;head → Node1 → Node2 → ...&lt;br/&gt;每个 Node 包含：&lt;br/&gt;• thread: 等待的线程&lt;br/&gt;• waitStatus: 节点状态&quot;]
        
        style STATE fill:#e1f5ff
        style OWNER fill:#e1f5ff
        style QUEUE fill:#fff9c4
    end
    
    subgraph &quot;park 调用时机&quot;
        PARK_WHEN[&quot;何时调用 park？&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;1. tryAcquire() 返回 false&lt;br/&gt;2. 前驱节点状态正确&lt;br/&gt;3. 调用 parkAndCheckInterrupt()&quot;]
        
        PARK_PARAMS[&quot;park 参数&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;LockSupport.park(this)&lt;br/&gt;• this = AQS 子类实例&lt;br/&gt;• 如 ReentrantLock$Sync&quot;]
        
        PARK_EFFECT[&quot;park 后状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 线程阻塞&lt;br/&gt;• parkBlocker = this&lt;br/&gt;• state 不变&lt;br/&gt;• 队列不变&quot;]
        
        style PARK_WHEN fill:#ffcdd2
        style PARK_PARAMS fill:#ffcdd2
        style PARK_EFFECT fill:#ffcdd2
    end
    
    subgraph &quot;unpark 调用时机&quot;
        UNPARK_WHEN[&quot;何时调用 unpark？&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;1. tryRelease() 返回 true&lt;br/&gt;2. 队列中有等待节点&lt;br/&gt;3. 调用 unparkSuccessor()&quot;]
        
        UNPARK_PARAMS[&quot;unpark 参数&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;LockSupport.unpark(thread)&lt;br/&gt;• thread = 等待线程&lt;br/&gt;• 注意：不是 blocker！&quot;]
        
        UNPARK_EFFECT[&quot;unpark 后状态&lt;br/&gt;━━━━━━━━━━━━━━━━━━━━&lt;br/&gt;• 线程被唤醒&lt;br/&gt;• parkBlocker = null&lt;br/&gt;• 线程继续竞争锁&quot;]
        
        style UNPARK_WHEN fill:#c8e6c9
        style UNPARK_PARAMS fill:#c8e6c9
        style UNPARK_EFFECT fill:#c8e6c9
    end
    
    STATE --&gt; PARK_WHEN
    OWNER --&gt; PARK_WHEN
    QUEUE --&gt; UNPARK_WHEN
    PARK_WHEN --&gt; PARK_PARAMS
    PARK_PARAMS --&gt; PARK_EFFECT
    UNPARK_WHEN --&gt; UNPARK_PARAMS
    UNPARK_PARAMS --&gt; UNPARK_EFFECT</code></pre>
<p><strong>关键代码路径（简化）：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ===== 获取锁路径 =====</span><br><br><span class="hljs-comment">// 1. ReentrantLock.lock()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.acquire(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 2. AQS.acquire()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;                    <span class="hljs-comment">// 尝试获取锁</span><br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))  <span class="hljs-comment">// 失败则入队等待</span><br>        selfInterrupt();<br>&#125;<br><br><span class="hljs-comment">// 3. AQS.acquireQueued() - 核心循环</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>        <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;    <span class="hljs-comment">// 前驱是 head 且获取成功</span><br>            setHead(node);<br>            <span class="hljs-keyword">return</span> interrupted;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>            parkAndCheckInterrupt())            <span class="hljs-comment">// ← 这里调用 park</span><br>            interrupted = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 4. AQS.parkAndCheckInterrupt() - park 调用点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);  <span class="hljs-comment">// blocker = this (AQS 子类实例)</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br><br><span class="hljs-comment">// ===== 释放锁路径 =====</span><br><br><span class="hljs-comment">// 1. ReentrantLock.unlock()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 2. AQS.release()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;                     <span class="hljs-comment">// 尝试释放锁</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);                 <span class="hljs-comment">// ← 这里调用 unpark</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 3. AQS.unparkSuccessor() - unpark 调用点</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;                        <span class="hljs-comment">// 找到后继节点</span><br>    <span class="hljs-comment">// ... 省略边界处理 ...</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        LockSupport.unpark(s.thread);          <span class="hljs-comment">// 参数是线程，不是 blocker</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>park 与 unpark 参数对比：</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>参数</th>
<th>参数含义</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LockSupport.park(Object blocker)</code></td>
<td>blocker</td>
<td>诊断标记，告诉工具&quot;线程在等什么&quot;</td>
<td><code>park(this)</code> → blocker = Sync</td>
</tr>
<tr>
<td><code>LockSupport.unpark(Thread thread)</code></td>
<td>thread</td>
<td>要唤醒的线程对象</td>
<td><code>unpark(node.thread)</code></td>
</tr>
</tbody>
</table>
<p><strong>注意：unpark 的参数是线程对象，不是 blocker！</strong> 这是因为 unpark 的目的是唤醒特定线程，而 blocker 只是诊断信息，唤醒时不需要。</p>
<p><strong>3. 其他场景的 blocker</strong></p>
<table>
<thead>
<tr>
<th>场景</th>
<th>blocker 是什么</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ReentrantLock.lock()</code></td>
<td><code>ReentrantLock$Sync</code></td>
<td>等待获取锁</td>
</tr>
<tr>
<td><code>Condition.await()</code></td>
<td><code>ConditionObject</code></td>
<td>等待条件满足</td>
</tr>
<tr>
<td><code>Semaphore.acquire()</code></td>
<td><code>Semaphore$Sync</code></td>
<td>等待许可</td>
</tr>
<tr>
<td><code>CountDownLatch.await()</code></td>
<td><code>CountDownLatch$Sync</code></td>
<td>等待计数归零</td>
</tr>
<tr>
<td><code>FutureTask.get()</code></td>
<td><code>FutureTask</code> 自身</td>
<td>等待任务完成</td>
</tr>
<tr>
<td><code>SynchronousQueue.take()</code></td>
<td><code>SynchronousQueue$TransferStack</code> 或 <code>TransferQueue</code></td>
<td>等待配对</td>
</tr>
</tbody>
</table>
<h3 id="选择-this-作为-blocker-的原因">选择 this 作为 blocker 的原因</h3>
<p>设计者选择 <code>this</code>（即当前的同步器对象）作为 blocker，有几个重要原因：</p>
<p><strong>1. 语义清晰</strong>：blocker 应该回答&quot;线程在等待什么&quot;，而 AQS 子类正是&quot;锁&quot;的抽象。当你看到 <code>parking to wait for &lt;0x000000076ab12345&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</code> 时，立刻就知道线程在等待一个非公平锁。</p>
<p><strong>2. 便于死锁检测</strong>：通过 blocker 可以构建&quot;线程 → 锁 → 持有者线程&quot;的等待链，这是死锁检测的基础。</p>
<p><strong>3. 与 synchronized 对称</strong>：synchronized 的重量级锁会将 <code>ObjectMonitor</code> 记录到线程的 <code>_current_pending_monitor</code> 字段，AQS 用 <code>parkBlocker</code> 实现了相同的功能。</p>
<h3 id="synchronized-与-park-底层机制的差异">synchronized 与 park 底层机制的差异</h3>
<p>synchronized 的重量级锁<strong>不使用</strong> <code>LockSupport.park()</code> 来阻塞线程。synchronized 和 AQS 在底层使用了完全不同的线程阻塞机制。</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>synchronized（重量级锁）</th>
<th>AQS（ReentrantLock 等）</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>阻塞机制</strong></td>
<td>OS 原生的 Mutex/Condition</td>
<td><code>LockSupport.park()/unpark()</code></td>
</tr>
<tr>
<td><strong>实现层次</strong></td>
<td>JVM C++ 层（<code>ObjectMonitor</code>）</td>
<td>Java 层 + <code>Unsafe.park()</code></td>
</tr>
<tr>
<td><strong>线程状态</strong></td>
<td><code>BLOCKED</code></td>
<td><code>WAITING</code> 或 <code>TIMED_WAITING</code></td>
</tr>
<tr>
<td><strong>可中断性</strong></td>
<td>不可中断（<code>monitorenter</code> 不响应中断）</td>
<td>可中断（<code>lockInterruptibly()</code>）</td>
</tr>
<tr>
<td><strong>诊断信息</strong></td>
<td><code>_current_pending_monitor</code>（C++ 层）</td>
<td><code>Thread.parkBlocker</code>（Java 层）</td>
</tr>
</tbody>
</table>
<p><strong>这种设计差异的原因：</strong></p>
<ol>
<li>
<p><strong>历史原因</strong>：synchronized 是 Java 1.0 就存在的语言特性，其实现深度嵌入 JVM 内部。当时 Java 还没有 <code>LockSupport</code>（JDK 1.5 才引入），只能依赖 OS 原生的同步原语。</p>
</li>
<li>
<p><strong>语义差异</strong>：synchronized 的 <code>monitorenter</code> 指令被设计为<strong>不可中断</strong>的阻塞操作。而 <code>LockSupport.park()</code> 天然支持中断，这使得 AQS 可以实现 <code>lockInterruptibly()</code> 等可中断的锁获取方式。</p>
</li>
<li>
<p><strong>性能优化空间</strong>：synchronized 的实现在 JVM 内部，可以做偏向锁、轻量级锁等深度优化。AQS 在 Java 层实现，虽然灵活性更高，但无法享受这些 JVM 级别的优化。</p>
</li>
</ol>
<p><strong>ObjectMonitor 的阻塞实现（简化）：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// HotSpot ObjectMonitor::enter() 中的阻塞逻辑</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectMonitor::enter</span><span class="hljs-params">(TRAPS)</span> </span>&#123;<br>    <span class="hljs-comment">// ... 自旋尝试 ...</span><br>    <br>    <span class="hljs-comment">// 自旋失败，准备阻塞</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-built_in">EnterI</span>(THREAD);  <span class="hljs-comment">// 进入等待队列并阻塞</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">ObjectMonitor::EnterI</span><span class="hljs-params">(TRAPS)</span> </span>&#123;<br>    <span class="hljs-comment">// 将当前线程加入 _EntryList</span><br>    <span class="hljs-comment">// ...</span><br>    <br>    <span class="hljs-comment">// 使用 OS 原生的 park 机制阻塞线程</span><br>    <span class="hljs-comment">// 注意：这里调用的是 os::PlatformEvent::park()</span><br>    <span class="hljs-comment">// 而不是 LockSupport.park()</span><br>    Self-&gt;_ParkEvent-&gt;<span class="hljs-built_in">park</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键区别：</strong> <code>os::PlatformEvent::park()</code> 是 JVM 内部的 C++ 实现，直接调用操作系统的 <code>pthread_cond_wait()</code>（Linux）或 <code>WaitForSingleObject()</code>（Windows）。而 <code>LockSupport.park()</code> 虽然最终也会调用类似的系统调用，但它是通过 <code>Unsafe.park()</code> 暴露给 Java 层的，并且额外支持了 <code>blocker</code> 参数和中断响应。</p>
<h3 id="blocker-在锁竞争中的切换">blocker 在锁竞争中的切换</h3>
<p>以 <code>ReentrantLock</code> + <code>Condition</code> 场景为例，追踪 blocker 的变化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br><span class="hljs-comment">// 线程 A</span><br>lock.lock();          <span class="hljs-comment">// 假设获取成功，不需要 park</span><br>condition.await();    <span class="hljs-comment">// 释放锁，进入条件队列，park</span><br><span class="hljs-comment">// ... 被 signal 唤醒后 ...</span><br><span class="hljs-comment">// 重新竞争锁，可能需要 park</span><br>lock.unlock();<br></code></pre></td></tr></table></figure>
<p><strong>blocker 的切换过程：</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant ThreadA as 线程 A
    participant Sync as ReentrantLock.Sync
    participant Cond as ConditionObject
    participant PB as Thread.parkBlocker

    Note over ThreadA: 初始状态
    ThreadA-&gt;&gt;PB: parkBlocker = null
    
    Note over ThreadA: lock.lock() 成功
    ThreadA-&gt;&gt;PB: parkBlocker = null（无需 park）
    
    Note over ThreadA: condition.await() 开始
    ThreadA-&gt;&gt;Cond: 进入条件队列
    ThreadA-&gt;&gt;PB: setBlocker(ConditionObject)
    Note over PB: parkBlocker = ConditionObject
    ThreadA-&gt;&gt;ThreadA: park() 阻塞
    
    Note over ThreadA: 被 signal() 唤醒
    ThreadA-&gt;&gt;PB: setBlocker(null)
    Note over PB: parkBlocker = null
    ThreadA-&gt;&gt;Sync: 转移到同步队列，竞争锁
    
    Note over ThreadA: 竞争锁失败，需要 park
    ThreadA-&gt;&gt;PB: setBlocker(Sync)
    Note over PB: parkBlocker = Sync
    ThreadA-&gt;&gt;ThreadA: park() 阻塞
    
    Note over ThreadA: 获取锁成功
    ThreadA-&gt;&gt;PB: setBlocker(null)
    Note over PB: parkBlocker = null</code></pre>
<p><strong>关键观察：</strong></p>
<ol>
<li><strong>blocker 在 park 前设置，在 unpark 后清除</strong>：这是 <code>LockSupport.park(Object blocker)</code> 的标准模式</li>
<li><strong>blocker 会随着线程在不同队列间移动而切换</strong>：
<ul>
<li>在同步队列等待锁时：blocker = Sync</li>
<li>在条件队列等待条件时：blocker = ConditionObject</li>
</ul>
</li>
<li><strong>blocker 只在线程被阻塞时有意义</strong>：一旦线程被唤醒，blocker 立即被清除为 null</li>
</ol>
<p><strong>代码层面的切换逻辑：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// LockSupport.park 的实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">park</span><span class="hljs-params">(Object blocker)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    setBlocker(t, blocker);  <span class="hljs-comment">// 1. park 前设置 blocker</span><br>    U.park(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);       <span class="hljs-comment">// 2. 真正阻塞</span><br>    setBlocker(t, <span class="hljs-literal">null</span>);     <span class="hljs-comment">// 3. 唤醒后清除 blocker</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个&quot;设置 → 阻塞 → 清除&quot;的三段式是理解 blocker 生命周期的关键。</p>
<h3 id="blocker-与-monitor-的对位关系">blocker 与 Monitor 的对位关系</h3>
<p>blocker 和 Monitor 在功能上是对位的，但实现层次不同。以下是精确的对比：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>synchronized (Monitor)</th>
<th>AQS (blocker)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>存储位置</strong></td>
<td><code>Thread._current_pending_monitor</code>（C++ 层）</td>
<td><code>Thread.parkBlocker</code>（Java 层）</td>
</tr>
<tr>
<td><strong>记录的对象</strong></td>
<td><code>ObjectMonitor*</code>（C++ 对象）</td>
<td>AQS 子类实例（Java 对象）</td>
</tr>
<tr>
<td><strong>设置时机</strong></td>
<td>进入 <code>_EntryList</code> 或 <code>_WaitSet</code> 时</td>
<td>调用 <code>LockSupport.park()</code> 前</td>
</tr>
<tr>
<td><strong>清除时机</strong></td>
<td>离开等待队列时</td>
<td><code>park()</code> 返回后立即清除</td>
</tr>
<tr>
<td><strong>用途</strong></td>
<td>死锁检测、jstack 输出</td>
<td>死锁检测、jstack 输出</td>
</tr>
<tr>
<td><strong>是否参与锁逻辑</strong></td>
<td>否（纯诊断）</td>
<td>否（纯诊断）</td>
</tr>
</tbody>
</table>
<p><strong>它们的对位关系体现在：</strong></p>
<ol>
<li><strong>功能对位</strong>：都是为了回答&quot;这个线程在等待哪个锁&quot;</li>
<li><strong>诊断对位</strong>：<code>jstack</code> 对两者的输出格式类似：<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// synchronized</span><br>- waiting to lock &lt;<span class="hljs-number">0</span>x000000076ab12345&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.lang</span>.Object)<br><br><span class="hljs-comment">// AQS</span><br>- parking to wait <span class="hljs-keyword">for</span> &lt;<span class="hljs-number">0</span>x000000076ab67890&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span>)<br></code></pre></td></tr></table></figure>
</li>
<li><strong>设计意图对位</strong>：都是为了在不影响锁性能的前提下，提供可观测性</li>
</ol>
<p><strong>但它们也有本质区别：</strong></p>
<ol>
<li><strong>层次不同</strong>：<code>_current_pending_monitor</code> 在 JVM 的 C++ 层，<code>parkBlocker</code> 在 Java 层</li>
<li><strong>生命周期不同</strong>：<code>_current_pending_monitor</code> 的生命周期由 JVM 管理，<code>parkBlocker</code> 由 <code>LockSupport</code> 显式管理</li>
<li><strong>灵活性不同</strong>：<code>parkBlocker</code> 可以是任意对象，而 <code>_current_pending_monitor</code> 只能是 <code>ObjectMonitor</code></li>
</ol>
<p><strong>图：Monitor 与 blocker 的对位关系</strong></p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;synchronized 的诊断信息流&quot;
        direction LR
        T1_SYNC[&quot;Thread（C++ JavaThread）&quot;]
        MON[&quot;ObjectMonitor&quot;]
        JSTACK1[&quot;jstack 输出&quot;]
        
        T1_SYNC --&gt;|&quot;_current_pending_monitor&quot;| MON
        MON --&gt;|&quot;读取&quot;| JSTACK1
    end
    
    subgraph &quot;AQS 的诊断信息流&quot;
        direction LR
        T1_AQS[&quot;Thread（Java Thread）&quot;]
        BLOCKER[&quot;AQS 子类实例&quot;]
        JSTACK2[&quot;jstack 输出&quot;]
        
        T1_AQS --&gt;|&quot;parkBlocker&quot;| BLOCKER
        BLOCKER --&gt;|&quot;读取&quot;| JSTACK2
    end
    
    JSTACK1 -.-&gt;|&quot;功能等价&quot;| JSTACK2</code></pre>
<h3 id="实战：通过-jstack-观察-blocker">实战：通过 jstack 观察 blocker</h3>
<p>以下是一个实际的 jstack 输出，展示 blocker 如何帮助诊断问题：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-string">&quot;Thread-1&quot;</span> #<span class="hljs-number">12</span> prio=<span class="hljs-number">5</span> os_prio=<span class="hljs-number">0</span> tid=<span class="hljs-number">0</span>x00007f8a1c0008c0 nid=<span class="hljs-number">0</span>x1234 waiting on condition <span class="hljs-selector-attr">[0x00007f8a1c000000]</span><br>   java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.State</span>: WAITING (parking)<br>        at sun<span class="hljs-selector-class">.misc</span><span class="hljs-selector-class">.Unsafe</span><span class="hljs-selector-class">.park</span>(Native Method)<br>        - parking to wait <span class="hljs-keyword">for</span>  &lt;<span class="hljs-number">0</span>x000000076ab67890&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.LockSupport</span><span class="hljs-selector-class">.park</span>(LockSupport<span class="hljs-selector-class">.java</span>:<span class="hljs-number">175</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.parkAndCheckInterrupt</span>(AbstractQueuedSynchronizer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">836</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquireQueued</span>(AbstractQueuedSynchronizer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">870</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquire</span>(AbstractQueuedSynchronizer<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1199</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span><span class="hljs-selector-class">.lock</span>(ReentrantLock<span class="hljs-selector-class">.java</span>:<span class="hljs-number">209</span>)<br>        at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.ReentrantLock</span><span class="hljs-selector-class">.lock</span>(ReentrantLock<span class="hljs-selector-class">.java</span>:<span class="hljs-number">285</span>)<br>        at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyService</span><span class="hljs-selector-class">.doSomething</span>(MyService<span class="hljs-selector-class">.java</span>:<span class="hljs-number">42</span>)<br></code></pre></td></tr></table></figure>
<p>从这个输出中，我们可以读出：</p>
<ol>
<li><strong>线程状态</strong>：<code>WAITING (parking)</code> — 线程被 <code>LockSupport.park()</code> 阻塞</li>
<li><strong>blocker 对象</strong>：<code>&lt;0x000000076ab67890&gt; (a java.util.concurrent.locks.ReentrantLock$NonfairSync)</code> — 线程在等待一个非公平锁</li>
<li><strong>调用栈</strong>：从 <code>MyService.doSomething</code> 到 <code>ReentrantLock.lock</code> 的完整路径</li>
</ol>
<p>如果同时有另一个线程持有这个锁：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-string">&quot;Thread-0&quot;</span> #<span class="hljs-number">11</span> prio=<span class="hljs-number">5</span> os_prio=<span class="hljs-number">0</span> tid=<span class="hljs-number">0</span>x00007f8a1c0007b0 nid=<span class="hljs-number">0</span>x1233 runnable <span class="hljs-selector-attr">[0x00007f8a1bfff000]</span><br>   java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span><span class="hljs-selector-class">.State</span>: RUNNABLE<br>        at com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.MyService</span><span class="hljs-selector-class">.doSomethingElse</span>(MyService<span class="hljs-selector-class">.java</span>:<span class="hljs-number">55</span>)<br>        - locked &lt;<span class="hljs-number">0</span>x000000076ab67890&gt; (<span class="hljs-selector-tag">a</span> java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span>)<br></code></pre></td></tr></table></figure>
<p>通过对比两个线程的 blocker 地址（<code>0x000000076ab67890</code>），我们可以确定 Thread-1 在等待 Thread-0 持有的锁。这就是 blocker 的诊断价值。</p>
<h3 id="小结：blocker-的设计哲学">小结：blocker 的设计哲学</h3>
<p><code>LockSupport.park(Object blocker)</code> 的 blocker 参数体现了一个重要的设计哲学：<strong>在不影响核心功能的前提下，提供最大化的可观测性</strong>。</p>
<ol>
<li><strong>零性能开销</strong>：blocker 只是一个引用赋值，不涉及任何同步操作</li>
<li><strong>完全可选</strong>：即使传 null，park 也能正常工作</li>
<li><strong>诊断友好</strong>：让 jstack、JFR 等工具能够准确报告线程的等待原因</li>
<li><strong>与 synchronized 对称</strong>：在 Java 层实现了与 JVM 层 <code>_current_pending_monitor</code> 相同的功能</li>
</ol>
<p>这种设计思想值得我们在自己的代码中借鉴：<strong>核心逻辑保持简洁，诊断信息作为可选的&quot;旁路&quot;提供</strong>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3%EF%BC%9AForkJoinPool/" title="线程池详解：ForkJoinPool"><img class="cover" src="/2026/01/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3%EF%BC%9AForkJoinPool/java-thread-x-forkjoin-%E5%8F%AA%E5%8F%91%E7%94%9F%E5%9C%A8%E5%90%8C%E5%B1%82%E4%B9%8B%E9%97%B4.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-04</div><div class="info-item-2">线程池详解：ForkJoinPool</div></div><div class="info-2"><div class="info-item-1"> 前言：分治并行的诞生 ForkJoinPool 不是为了通用&quot;并行&quot;而设计，而是专门为分治并行（Divide-and-Conquer Parallelism）这一特定模式量身定制。分治算法（如快速排序、归并排序、树遍历）具有独特的执行模式：  任务天然形成树状结构 父任务派生子任务后需要等待结果 子任务之间通常无依赖关系 计算密集，无I/O阻塞  理解分治算法的执行特性，是理解 ForkJoinPool 设计的关键。传统线程池在处理这类任务时遇到根本性挑战，ForkJoinPool 正是为解决这些挑战而诞生。 1. 核心数据结构：ForkJoinPool的基石 1.1 ForkJoinPool：去中心化的调度器 数据结构定义 1234567891011121314151617181920212223public class ForkJoinPool extends AbstractExecutorService &#123;    // 64位控制状态：编码活跃线程数、空闲线程数、任务计数    volatile long ctl;        // 工作...</div></div></div></a><a class="pagination-related" href="/2026/01/18/%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E7%9A%84%E5%8E%86%E5%8F%B2/" title="异步进化的历史"><img class="cover" src="/2026/01/18/%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E7%9A%84%E5%8E%86%E5%8F%B2/CompletableFuture%E6%89%A7%E8%A1%8C%E6%A0%91.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">异步进化的历史</div></div><div class="info-2"><div class="info-item-1">本文一部分来自于qwen，一部分来自于以下文章：  《CompletableFuture原理与实践-外卖商家端API的异步化》  Java 演进本质 graph LR     A[Java 5 Future] --&gt;|阻塞痛点| B[Guava ListenableFuture]     B --&gt;|回调地狱| C[CompletableFuture]     C --&gt;|流处理需求| D[RxJava]     D --&gt;|Spring整合| E[Reactor]          A --&gt;|范式转变| F[命令式-&gt;声明式]     B --&gt;|抽象提升| G[事件驱动-&gt;数据流]     C --&gt;|能力增强| H[组合-&gt;背压]     D &amp; E --&gt;|统一理念| I[异步即数据流]  控制流：阻塞等待 → 回调响应 → 声明式组合 → 响应式流 错误处理：分散try-catch → 回调onFailure → 链式exceptionally → 流式onError 组合能力：无 → 有限tr...</div></div></div></a><a class="pagination-related" href="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/" title="Java 并发编程笔记"><img class="cover" src="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-12</div><div class="info-item-2">Java 并发编程笔记</div></div><div class="info-2"><div class="info-item-1"> juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 MESA 模型 JAVA 采用 MESA 模型：  互斥（Mutual Exclusion）：通过锁机制保证同一时刻只有一个线程能进入管程内部执行。 同步（Synchronization）：利用条件变量（Condition Variable）实现线程间的等待与唤醒。 Signal and Continue：   当线程发出通知（signal/notify）时，它继续持有锁并运行，而被唤醒的线程仅仅是进入就绪队列，并不立即抢占 CPU。   必须使用 while 循环：   由于线程被唤醒后不一定立即执行，当它重新获得锁时，环境条件可能已发生变化，因此必须在一个 while 循环中重新检查等待条件（while (condition) { wait(); }）。  为什么用 se...</div></div></div></a><a class="pagination-related" href="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" title="无锁队列"><img class="cover" src="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">无锁队列</div></div><div class="info-2"><div class="info-item-1">Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。 * * &lt;p&gt;原理说明： * - 仅允许一个线程调用 &#123;@code offer()&#125;，一个线程调用 &#123;@code poll()&#125;。 * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。 * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系： *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。 * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad）， *   ...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-126.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a><a class="pagination-related" href="/2017/11/03/JVM-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="JVM 的内存模型与线程"><img class="cover" src="/img/wall-paper-176.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-03</div><div class="info-item-2">JVM 的内存模型与线程</div></div><div class="info-2"><div class="info-item-1">1.性能何处寻   计算机的CPU比起其他所有的设备，都快得多，所以怎样尽量复用 CPU 的时间片，是压榨计算机性能的目标。多核和并发，使得阿姆达尔定律大显神威，超越摩尔定律成为提升系统性能的金科玉律 - 现在单核计算能力已经无法垂直提升，要水平提升核数来提升整体性能。 2.缓存一致性问题（Cache Coherence）   软件缓存，不过是硬件缓存的模仿，真正的缓存，早已存在于计算机的多级存储体系结构中。JVM 里，我们可以认为每个处理器都会在主内存（Main Memory）之外有高速缓存作为工作内存（Working memory）。除此之外，处理器和 JVM 都可能出现指令重排（Instruction Reorder）的的情况。工作内存是线程 Save 和 Load 的主要场所，主内存则是他们沟通的场所。 3.JVM 的对象信息   Java Object 除了基本的内存轮廓以外，还有：  Mark Word（对象的 Hash Code 的缓存值、GC标志、GC年龄、同步锁等信息）。 Klass Point（指向对象元数据信息的指针，指向 .class  的指针吗？不是，是...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">线程安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">1.1.</span> <span class="toc-text">什么是线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">线程安全的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98-immutable"><span class="toc-number">1.2.1.</span> <span class="toc-text">不可变（Immutable）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9D%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-absolute-thread-safety"><span class="toc-number">1.2.2.</span> <span class="toc-text">绝对线程安全（Absolute Thread Safety）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%AF%B9%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8-relative-thread-safety"><span class="toc-number">1.2.3.</span> <span class="toc-text">相对线程安全（Relative Thread Safety）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%85%BC%E5%AE%B9-thread-compatible"><span class="toc-number">1.2.4.</span> <span class="toc-text">线程兼容（Thread Compatible）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AF%B9%E7%AB%8B-thread-hostile"><span class="toc-number">1.2.5.</span> <span class="toc-text">线程对立（Thread Hostile）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.3.</span> <span class="toc-text">线程安全的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E5%90%8C%E6%AD%A5-mutual-exclusion-synchronization"><span class="toc-number">1.3.1.</span> <span class="toc-text">互斥同步（Mutual Exclusion &amp; Synchronization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%9E%E9%98%BB%E5%A1%9E%E5%90%8C%E6%AD%A5-non-blocking-synchronization"><span class="toc-number">1.3.2.</span> <span class="toc-text">非阻塞同步（Non-Blocking Synchronization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E5%90%8C%E6%AD%A5%E6%96%B9%E6%A1%88"><span class="toc-number">1.3.3.</span> <span class="toc-text">无同步方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E4%BB%A3%E7%A0%81-reentrant-code"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">可重入代码（Reentrant Code）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8-thread-local-storage"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">线程本地存储（Thread Local Storage）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">对象头</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#klass-pointer-%E4%B8%8E%E7%B1%BB%E5%85%83%E6%95%B0%E6%8D%AE%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.1.</span> <span class="toc-text">Klass Pointer 与类元数据的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mark-word-%E4%B8%8E-monitor-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.2.</span> <span class="toc-text">Mark Word 与 Monitor 的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#monitor-%E4%B8%8E%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%8C%E6%AD%A5%E5%8E%9F%E8%AF%AD%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.</span> <span class="toc-text">Monitor 与操作系统同步原语的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E8%AF%AD-primitive-%EF%BC%9F"><span class="toc-number">2.3.1.</span> <span class="toc-text">什么是原语（Primitive）？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">锁优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E4%BC%98%E5%8C%96%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6%EF%BC%9A%E7%94%A8%E6%88%B7%E6%80%81%E9%94%81-vs-%E5%86%85%E6%A0%B8%E6%80%81%E9%94%81"><span class="toc-number">3.1.</span> <span class="toc-text">锁优化的设计哲学：用户态锁 vs 内核态锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%A0%87%E5%BF%97%E6%80%A7%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.1.1.</span> <span class="toc-text">锁升级的标志性事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E9%94%81%E5%AF%B9-mark-word-%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">3.1.2.</span> <span class="toc-text">三种锁对 Mark Word 的处理策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E9%94%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.1.3.</span> <span class="toc-text">三种锁的数据结构对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E5%85%A8%E6%99%AF%E5%9B%BE%EF%BC%9A%E4%BB%8E%E6%97%A0%E9%94%81%E5%88%B0%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%E7%9A%84%E5%AE%8C%E6%95%B4%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">3.1.4.</span> <span class="toc-text">锁升级全景图：从无锁到重量级锁的完整状态转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4-lock-elimination"><span class="toc-number">3.2.</span> <span class="toc-text">锁消除（Lock Elimination）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E6%B6%88%E9%99%A4%EF%BC%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">什么是锁消除？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">锁消除的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E6%B6%88%E9%99%A4%E7%9A%84%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF"><span class="toc-number">3.2.3.</span> <span class="toc-text">锁消除的典型场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#reentrantlock-%E8%83%BD%E8%A2%AB%E6%B6%88%E9%99%A4%E5%90%97%EF%BC%9F"><span class="toc-number">3.2.4.</span> <span class="toc-text">ReentrantLock 能被消除吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E9%AA%8C%E8%AF%81%E9%94%81%E6%B6%88%E9%99%A4%E6%98%AF%E5%90%A6%E7%94%9F%E6%95%88%EF%BC%9F"><span class="toc-number">3.2.5.</span> <span class="toc-text">如何验证锁消除是否生效？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96-lock-coarsening"><span class="toc-number">3.3.</span> <span class="toc-text">锁粗化（Lock Coarsening）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%94%81%E7%B2%97%E5%8C%96%EF%BC%9F"><span class="toc-number">3.3.1.</span> <span class="toc-text">什么是锁粗化？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96%E7%9A%84%E5%85%B8%E5%9E%8B%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.2.</span> <span class="toc-text">锁粗化的典型场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96%E7%9A%84%E6%9D%83%E8%A1%A1"><span class="toc-number">3.3.3.</span> <span class="toc-text">锁粗化的权衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%B2%97%E5%8C%96-vs-%E9%94%81%E7%BB%86%E5%8C%96"><span class="toc-number">3.3.4.</span> <span class="toc-text">锁粗化 vs 锁细化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%E9%94%81%E7%B2%97%E5%8C%96%EF%BC%9F"><span class="toc-number">3.3.5.</span> <span class="toc-text">如何控制锁粗化？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%81%E7%8A%B6%E6%80%81%E5%8D%87%E7%BA%A7-lock-state-escalation"><span class="toc-number">3.4.</span> <span class="toc-text">锁状态升级（Lock State Escalation）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0%EF%BC%9A%E9%94%81%E7%8A%B6%E6%80%81%E4%B8%8E%E7%AD%89%E5%BE%85%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.1.</span> <span class="toc-text">概述：锁状态与等待机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81-biased-lock"><span class="toc-number">3.4.2.</span> <span class="toc-text">偏向锁（Biased Lock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E4%B8%80%E4%B8%AA-%E5%86%99%E5%9C%A8-mark-word-%E9%87%8C%E7%9A%84-volatile-threadid"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">偏向锁的本质：一个&quot;写在 Mark Word 里的 volatile threadId&quot;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hashcode-%E4%B8%8E%E5%81%8F%E5%90%91%E9%94%81%E7%9A%84%E4%BA%92%E6%96%A5"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">hashCode 与偏向锁的互斥</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-lightweight-lock"><span class="toc-number">3.4.3.</span> <span class="toc-text">轻量级锁（Lightweight Lock）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-vs-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81%EF%BC%9A%E5%88%B0%E5%BA%95-%E8%BD%BB-%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">轻量级锁 vs 重量级锁：到底&quot;轻&quot;在哪里？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-record-%E4%B8%8D%E6%98%AF%E9%94%81%E6%9C%AC%E8%BA%AB-mark-word-%E6%89%8D%E6%98%AF"><span class="toc-number">3.4.4.</span> <span class="toc-text">Lock Record 不是锁本身，Mark Word 才是</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#objectmonitor-%E7%9A%84%E5%88%9B%E5%BB%BA%E6%97%B6%E6%9C%BA%E4%B8%8E%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.4.5.</span> <span class="toc-text">ObjectMonitor 的创建时机与生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A0%88%E5%B8%A7%E4%B8%8E-lock-record-%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.6.</span> <span class="toc-text">线程栈帧与 Lock Record 的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-record-%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-%E7%94%9F%E8%80%81%E7%97%85%E6%AD%BB"><span class="toc-number">3.4.7.</span> <span class="toc-text">Lock Record 的生命周期（生老病死）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E6%B2%A1%E6%9C%89-waitset-%E5%92%8C-entrylist-%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.4.8.</span> <span class="toc-text">轻量级锁没有 WaitSet 和 EntryList 的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%B8%8E%E9%98%BB%E5%A1%9E%EF%BC%9A%E9%94%81%E7%AD%89%E5%BE%85%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E5%8C%96"><span class="toc-number">3.4.9.</span> <span class="toc-text">自旋与阻塞：锁等待机制的优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">3.4.9.1.</span> <span class="toc-text">自旋优化的必要性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.9.2.</span> <span class="toc-text">自旋锁的实现原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E6%AC%A1%E6%95%B0%E7%9A%84%E6%8E%A7%E5%88%B6"><span class="toc-number">3.4.9.3.</span> <span class="toc-text">自旋次数的控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.4.9.4.</span> <span class="toc-text">自旋锁的适用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%94%81%E8%86%A8%E8%83%80%E7%9A%84%E5%BF%85%E7%84%B6%E6%80%A7%EF%BC%9A%E8%87%AA%E6%97%8B%E5%A4%B1%E8%B4%A5%E6%98%AF%E5%B8%B8%E6%80%81%E8%80%8C%E9%9D%9E%E4%BE%8B%E5%A4%96"><span class="toc-number">3.4.9.5.</span> <span class="toc-text">锁膨胀的必然性：自旋失败是常态而非例外</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-%E7%AB%9E%E4%BA%89-%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%A4%E5%AE%9A%E7%AB%9E%E4%BA%89%E7%A8%8B%E5%BA%A6%EF%BC%9F"><span class="toc-number">3.4.10.</span> <span class="toc-text">什么是&quot;竞争&quot;？如何判定竞争程度？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%AB%9E%E4%BA%89%E7%9A%84%E8%AF%A6%E7%BB%86%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90"><span class="toc-number">3.4.11.</span> <span class="toc-text">锁竞争的详细场景分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E7%AB%9E%E4%BA%89%E5%A4%B1%E8%B4%A5%E7%9A%84%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.11.1.</span> <span class="toc-text">轻量级锁竞争失败的处理策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E7%AB%9E%E4%BA%89%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9C%BA%E6%99%AF%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.4.11.2.</span> <span class="toc-text">偏向锁竞争：多线程场景详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91%E4%B8%8E%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80"><span class="toc-number">3.4.11.3.</span> <span class="toc-text">批量重偏向与批量撤销</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.12.</span> <span class="toc-text">锁升级流程总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9-safepoint-%EF%BC%9A%E4%BB%8E%E9%94%81%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD%E5%88%B0-jvm-%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.</span> <span class="toc-text">安全点（Safepoint）：从锁问题诊断到 JVM 底层机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AD%90%EF%BC%9A%E9%94%81%E9%97%AE%E9%A2%98%E8%AF%8A%E6%96%AD%E4%B8%8E%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90"><span class="toc-number">3.5.1.</span> <span class="toc-text">引子：锁问题诊断与日志分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E4%B8%8E%E5%AE%89%E5%85%A8%E7%82%B9%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.5.2.</span> <span class="toc-text">日志与安全点的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9Ajvm-%E7%9A%84-%E7%BA%A2%E7%BB%BF%E7%81%AF"><span class="toc-number">3.5.3.</span> <span class="toc-text">安全点的本质：JVM 的&quot;红绿灯&quot;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E7%9A%84%E6%9C%AC%E8%B4%A8%EF%BC%9A%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E5%BF%AB%E7%85%A7"><span class="toc-number">3.5.4.</span> <span class="toc-text">安全点的本质：线程状态的一致性快照</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">3.5.5.</span> <span class="toc-text">安全点在哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">3.5.6.</span> <span class="toc-text">安全点的工作机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E8%A6%81%E5%AE%89%E5%85%A8%E7%82%B9%E7%9A%84-vm-%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.7.</span> <span class="toc-text">需要安全点的 VM 操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9-vs-%E5%AE%89%E5%85%A8%E5%8C%BA%E5%9F%9F"><span class="toc-number">3.5.8.</span> <span class="toc-text">安全点 vs 安全区域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-handshake%EF%BC%9A%E6%9B%B4%E7%BB%86%E7%B2%92%E5%BA%A6%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%8D%8F%E8%B0%83"><span class="toc-number">3.5.9.</span> <span class="toc-text">Thread Handshake：更细粒度的线程协调</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E7%82%B9%E4%B8%8E%E9%94%81%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.5.10.</span> <span class="toc-text">安全点与锁的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9B%B8%E5%85%B3%E7%9A%84-jvm-%E6%97%A5%E5%BF%97%E8%AF%8A%E6%96%AD"><span class="toc-number">3.5.11.</span> <span class="toc-text">锁相关的 JVM 日志诊断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E7%A7%8D%E9%94%81%E4%BC%98%E5%8C%96%E7%9A%84%E5%8F%AF%E8%A7%82%E6%B5%8B%E6%80%A7%E5%AF%B9%E6%AF%94"><span class="toc-number">3.5.12.</span> <span class="toc-text">各种锁优化的可观测性对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-aqs-%E7%9C%8B%E9%94%81%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.6.</span> <span class="toc-text">从 AQS 看锁的抽象模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81%E7%9A%84%E6%A0%B8%E5%BF%83%E8%81%8C%E8%B4%A3%E4%B8%8E%E6%AC%A1%E7%BA%A7%E8%81%8C%E8%B4%A3"><span class="toc-number">3.6.1.</span> <span class="toc-text">锁的核心职责与次级职责</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E5%A6%82%E4%BD%95%E5%85%B7%E8%B1%A1%E5%8C%96%E8%BF%99%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.6.2.</span> <span class="toc-text">AQS 如何具象化这个抽象模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E7%90%86%E8%A7%A3%E8%BF%99%E4%B8%AA%E6%8A%BD%E8%B1%A1%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">3.6.3.</span> <span class="toc-text">为什么需要理解这个抽象模型？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#locksupport%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E7%9A%84%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD"><span class="toc-number">3.7.</span> <span class="toc-text">LockSupport：线程阻塞的基础设施</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#blocker-%E5%8F%82%E6%95%B0%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.7.1.</span> <span class="toc-text">blocker 参数的本质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#park-%E4%B8%8E-unpark-%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E5%AF%B9%E7%A7%B0%E6%80%A7"><span class="toc-number">3.7.2.</span> <span class="toc-text">park 与 unpark 的参数不对称性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#park-%E4%B8%8E-sleep-%E7%9A%84%E6%B7%B1%E5%B1%82%E5%AF%B9%E6%AF%94"><span class="toc-number">3.7.3.</span> <span class="toc-text">park 与 sleep 的深层对比</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#api-%E7%AD%BE%E5%90%8D%E5%AF%B9%E6%AF%94"><span class="toc-number">3.7.3.1.</span> <span class="toc-text">API 签名对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90"><span class="toc-number">3.7.3.2.</span> <span class="toc-text">核心差异分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">3.7.3.3.</span> <span class="toc-text">中断处理的差异</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#permit-%E6%9C%BA%E5%88%B6%EF%BC%9A%E8%A7%A3%E5%86%B3-sleep-%E6%97%A0%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">3.7.3.4.</span> <span class="toc-text">permit 机制：解决 sleep 无法解决的问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%BB%9F%E4%B8%80%E6%80%A7"><span class="toc-number">3.7.3.5.</span> <span class="toc-text">底层实现的统一性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">3.7.3.6.</span> <span class="toc-text">使用场景的选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">3.7.3.7.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E-java-%E7%BA%BF%E7%A8%8B-api-%E5%88%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%EF%BC%9A%E8%87%AA%E6%84%BF-vs-%E5%BC%BA%E5%88%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E7%BB%9F%E4%B8%80%E8%A7%86%E8%A7%92"><span class="toc-number">3.7.3.8.</span> <span class="toc-text">从 Java 线程 API 到操作系统：自愿 vs 强制操作的统一视角</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#permit-%E6%9C%BA%E5%88%B6%EF%BC%9A%E4%BB%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%88%B0-park-unpark-%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">3.7.3.9.</span> <span class="toc-text">permit 机制：从信号量到 park&#x2F;unpark 的演进</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%84%B1%E7%A6%BB-aqs-%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8-park-unpark-%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E5%8D%8F%E8%B0%83"><span class="toc-number">3.7.3.10.</span> <span class="toc-text">脱离 AQS 直接使用 park&#x2F;unpark 实现线程协调</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E9%9B%B6%E6%9E%84%E5%BB%BA%EF%BC%9A%E5%9F%BA%E4%BA%8E-cas-park-unpark-%E7%9A%84%E7%AE%80%E6%98%93%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-number">3.7.3.11.</span> <span class="toc-text">从零构建：基于 CAS + park&#x2F;unpark 的简易互斥锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#locksupport-%E5%AE%9E%E6%88%98%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.7.3.12.</span> <span class="toc-text">LockSupport 实战示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hotspot-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%9Aparker-%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0-permit-%E8%AF%AD%E4%B9%89"><span class="toc-number">3.7.3.13.</span> <span class="toc-text">HotSpot 源码解析：Parker 类如何实现 permit 语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92-spurious-wakeup-%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E6%A3%80%E6%9F%A5%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.7.3.14.</span> <span class="toc-text">虚假唤醒（Spurious Wakeup）：为什么必须在循环中检查条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E7%AD%89%E5%BE%85%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%9Areentrantlock-trylock-timeout-unit-%E5%8E%9F%E7%90%86"><span class="toc-number">3.7.3.15.</span> <span class="toc-text">超时等待的实现：ReentrantLock.tryLock(timeout, unit) 原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%A6%81%E5%8C%BA%E5%88%86%EF%BC%9Ablocker-%E4%B8%8E%E6%9C%AC%E6%96%87%E5%85%B6%E4%BB%96-%E8%AE%B0%E5%BD%95%E5%AF%B9%E8%B1%A1-%E7%9A%84%E6%9C%AC%E8%B4%A8%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.4.</span> <span class="toc-text">重要区分：blocker 与本文其他&quot;记录对象&quot;的本质区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocker-%E6%9D%A5%E8%87%AA%E5%93%AA%E9%87%8C%EF%BC%9F"><span class="toc-number">3.7.5.</span> <span class="toc-text">blocker 来自哪里？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#condition-await-%E4%B8%8E-signal-%E7%9A%84%E5%AE%8C%E6%95%B4%E6%97%B6%E5%BA%8F%E5%9B%BE"><span class="toc-number">3.7.6.</span> <span class="toc-text">Condition.await() 与 signal() 的完整时序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E4%B8%AD-park-unpark-%E7%9A%84%E8%B0%83%E7%94%A8%E6%97%B6%E6%9C%BA%E4%B8%8E%E7%8A%B6%E6%80%81%E5%8F%98%E5%8C%96"><span class="toc-number">3.7.7.</span> <span class="toc-text">AQS 中 park&#x2F;unpark 的调用时机与状态变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-this-%E4%BD%9C%E4%B8%BA-blocker-%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.7.8.</span> <span class="toc-text">选择 this 作为 blocker 的原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized-%E4%B8%8E-park-%E5%BA%95%E5%B1%82%E6%9C%BA%E5%88%B6%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">3.7.9.</span> <span class="toc-text">synchronized 与 park 底层机制的差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocker-%E5%9C%A8%E9%94%81%E7%AB%9E%E4%BA%89%E4%B8%AD%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-number">3.7.10.</span> <span class="toc-text">blocker 在锁竞争中的切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocker-%E4%B8%8E-monitor-%E7%9A%84%E5%AF%B9%E4%BD%8D%E5%85%B3%E7%B3%BB"><span class="toc-number">3.7.11.</span> <span class="toc-text">blocker 与 Monitor 的对位关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%88%98%EF%BC%9A%E9%80%9A%E8%BF%87-jstack-%E8%A7%82%E5%AF%9F-blocker"><span class="toc-number">3.7.12.</span> <span class="toc-text">实战：通过 jstack 观察 blocker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93%EF%BC%9Ablocker-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">3.7.13.</span> <span class="toc-text">小结：blocker 的设计哲学</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>