<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 并发编程笔记 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 MESA 模型 JAVA 采用 MESA 模型：  互斥（Mutual Exclusion">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 并发编程笔记">
<meta property="og:url" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 MESA 模型 JAVA 采用 MESA 模型：  互斥（Mutual Exclusion">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png">
<meta property="article:published_time" content="2026-01-12T14:28:12.000Z">
<meta property="article:modified_time" content="2026-01-24T15:31:59.565Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 并发编程笔记",
  "url": "https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
  "image": "https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png",
  "datePublished": "2026-01-12T14:28:12.000Z",
  "dateModified": "2026-01-24T15:31:59.565Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 并发编程笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 并发编程笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java 并发编程笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-12T14:28:12.000Z" title="Created 2026-01-12 22:28:12">2026-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T15:31:59.565Z" title="Updated 2026-01-24 23:31:59">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">8.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>30mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><img src="juc.png" alt="juc.png"><br>
<a href="juc.xmind">juc.xmind</a></p>
<h1>写在前面的话</h1>
<p>并发编程最早的实践都在操作系统里。</p>
<h2 id="管程">管程</h2>
<p>理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。</p>
<h2 id="mesa-模型">MESA 模型</h2>
<p>JAVA 采用 MESA 模型：</p>
<ul>
<li>互斥（Mutual Exclusion）：通过锁机制保证同一时刻只有一个线程能进入管程内部执行。</li>
<li>同步（Synchronization）：利用条件变量（Condition Variable）实现线程间的等待与唤醒。</li>
<li>Signal and Continue：</li>
</ul>
<blockquote>
<p>当线程发出通知（signal/notify）时，它继续持有锁并运行，而被唤醒的线程仅仅是进入就绪队列，并不立即抢占 CPU。</p>
</blockquote>
<ul>
<li>必须使用 while 循环：</li>
</ul>
<blockquote>
<p>由于线程被唤醒后不一定立即执行，当它重新获得锁时，环境条件可能已发生变化，因此必须在一个 while 循环中重新检查等待条件（while<br>
(condition) { wait(); }）。</p>
</blockquote>
<h3 id="为什么用-set-而不用-queue">为什么用 set 而不用 queue</h3>
<ol>
<li>Queue 暗示 FIFO（先进先出）：</li>
</ol>
<ul>
<li>如果我们叫它 EntryQueue，开发者会本能地认为：先来的线程一定先拿到锁。</li>
<li>但实际上，Java 的 synchronized 是非公平锁（Non-fair Lock）。</li>
</ul>
<ol start="2">
<li>实际上更像“一堆人”而不是“一队人”：</li>
</ol>
<ul>
<li>在 JVM 的具体实现策略中，当锁被释放时，并不保证 EntrySet 中排在最前面的线程一定能抢到锁（可能被刚来的线程抢走，或者被随机唤醒）。</li>
<li>对于 WaitSet，notify() 唤醒的线程也不一定是先 wait() 的那个线程（取决于具体 JVM 实现）。</li>
<li>所以，用 Set（集合） 这个词能更准确地表达“这里有一群线程在等，但谁先出去不一定”的语义。</li>
</ul>
<p>总结：叫 Set 是为了告诉你，不要依赖它们的唤醒顺序。</p>
<h3 id="模型映射">模型映射</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Mesa 模型</th>
<th style="text-align:left">Mesa 语义</th>
<th style="text-align:left"><code>synchronized</code></th>
<th style="text-align:left"><code>ReentrantLock</code></th>
<th style="text-align:left">Java State</th>
<th style="text-align:left">超时</th>
<th style="text-align:left">JVisualVM</th>
<th style="text-align:left">底层机制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Entry Set</strong><br>(锁竞争)</td>
<td style="text-align:left">等待获取锁</td>
<td style="text-align:left">Monitor Entry List</td>
<td style="text-align:left">AQS Sync Queue</td>
<td style="text-align:left"><code>BLOCKED</code><br><code>WAITING (parking)</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left">Monitor<br>Park</td>
<td style="text-align:left">ObjectMonitor<br>LockSupport.park()</td>
</tr>
<tr>
<td style="text-align:left"><strong>Wait Set</strong><br>(条件等待)</td>
<td style="text-align:left">等待条件满足</td>
<td style="text-align:left">Monitor Wait Set</td>
<td style="text-align:left">AQS Condition Queue</td>
<td style="text-align:left"><code>WAITING</code><br><code>TIMED_WAITING</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left">Wait<br>Park</td>
<td style="text-align:left">ObjectMonitor<br>LockSupport.park()</td>
</tr>
<tr>
<td style="text-align:left"><strong>Owner</strong><br>(持有者)</td>
<td style="text-align:left">持有锁的线程</td>
<td style="text-align:left">Monitor Owner</td>
<td style="text-align:left">exclusiveOwnerThread</td>
<td style="text-align:left"><code>RUNNABLE</code></td>
<td style="text-align:left">-</td>
<td style="text-align:left">Running</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<h4 id="1-mesa-模型的-signal-and-continue-语义">1. Mesa 模型的 “Signal and Continue” 语义</h4>
<ul>
<li><code>notify()</code> / <code>signal()</code> 后，通知者<strong>继续持有锁</strong></li>
<li>被唤醒的线程从 Wait Set 移入 Entry Set，必须<strong>重新竞争锁</strong></li>
<li>唤醒路径：
<ul>
<li><code>synchronized</code>: Wait Set → Entry Set (<code>BLOCKED</code>) → Owner</li>
<li><code>ReentrantLock</code>: Condition Queue → Sync Queue (<code>WAITING</code>) → Owner</li>
</ul>
</li>
</ul>
<h4 id="2-entry-set-锁竞争-❌-永远不会有-timed-waiting">2. Entry Set（锁竞争）❌ 永远不会有 TIMED_WAITING</h4>
<ul>
<li><code>synchronized</code> 不支持超时</li>
<li><code>ReentrantLock.lock()</code> 不支持超时</li>
<li><code>tryLock(timeout)</code> 不进队列，在当前线程自旋</li>
</ul>
<h4 id="3-wait-set-条件等待-✅-支持-timed-waiting">3. Wait Set（条件等待）✅ 支持 TIMED_WAITING</h4>
<ul>
<li><code>wait(timeout)</code> / <code>await(timeout, unit)</code> 支持超时</li>
<li>设计哲学：条件等待是主动等待业务条件，需要&quot;等不到就放弃&quot;的语义</li>
</ul>
<h4 id="4-jvisualvm-分类逻辑">4. JVisualVM 分类逻辑</h4>
<ul>
<li><strong>Monitor</strong>: <code>synchronized</code> 的 <code>BLOCKED</code> 状态</li>
<li><strong>Park</strong>: <code>LockSupport.park()</code> 导致的 <code>WAITING</code> 状态</li>
<li><strong>Wait</strong>: <code>Object.wait()</code> 导致的 <code>WAITING</code> 状态</li>
</ul>
<h4 id="5-线程状态与-os-调度">5. 线程状态与 OS 调度</h4>
<ul>
<li><strong>RUNNABLE</strong> = OS Ready + OS Running（JVM 无法区分）</li>
<li><strong>BLOCKED</strong> / <strong>WAITING</strong>: 线程在 JVM 队列中，未持有 CPU</li>
<li>Ready Queue 是 OS 层面的，JVM 不可见</li>
</ul>
<h1>Java 线程状态</h1>
<p><img src="java-thread-state.png" alt="java-thread-state.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MesaMonitorExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionSatisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// === 等待者线程 (Thread-A) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWait</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// [阶段 1]：尝试进入 synchronized 块</span><br>        <span class="hljs-comment">// 状态详情：</span><br>        <span class="hljs-comment">// 1. Monitor 锁：未持有（正在 Entry Set 排队竞争）</span><br>        <span class="hljs-comment">// 2. CPU：未持有（被 OS 挂起）</span><br>        <span class="hljs-comment">// 3. Mesa Set：处于 Entry Set (入口队列/锁池)</span><br>        <span class="hljs-comment">// 4. 线程状态：BLOCKED</span><br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// ============================================================</span><br>            <span class="hljs-comment">// [微观状态间隙 - 从抢到锁到执行第一行代码]</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 1. 【Lock Acquired】：</span><br>            <span class="hljs-comment">//    Monitor 锁竞争成功。线程从 Entry Set 移出，成为 Owner。</span><br>            <span class="hljs-comment">//    Java 线程状态：BLOCKED -&gt; RUNNABLE。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 2. 【OS Scheduling (Ready)】：</span><br>            <span class="hljs-comment">//    虽然 Java 认为你是 RUNNABLE，但在 OS 看来，你只是进入了</span><br>            <span class="hljs-comment">//    &quot;CPU 就绪队列&quot; (Ready Queue)，正在等待分配时间片。JVM 本身并不理解 OS 的这个队列，所以 RUNNABLE 包含了“可以运行”和“正在运行”两种状态。</span><br>            <span class="hljs-comment">//    此时：持有锁 | 未持有 CPU | 状态：RUNNABLE (Ready)。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 3. 【Context Switch (Running)】：</span><br>            <span class="hljs-comment">//    OS 调度器选中了本线程，加载寄存器，PC 指针指向下一行指令。</span><br>            <span class="hljs-comment">//    此时：持有锁 | 持有 CPU | 状态：RUNNABLE (Running)。</span><br>            <span class="hljs-comment">// ============================================================</span><br>            <br>            <span class="hljs-comment">// [阶段 2]：真正执行代码</span><br>            <span class="hljs-comment">// 状态详情：持有锁 | 持有 CPU | Owner (持有者) | RUNNABLE (Running)</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Acquired lock, checking condition...&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (!conditionSatisfied) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Condition false, calling wait()...&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// [阶段 3：主动入冷宫 - 调用 wait()]</span><br>                    <span class="hljs-comment">// 状态详情（执行瞬间）：</span><br>                    <span class="hljs-comment">// 1. Monitor 锁：原子性释放</span><br>                    <span class="hljs-comment">// 2. CPU：主动放弃</span><br>                    <span class="hljs-comment">// 3. Mesa Set：从 Owner 移入 Wait Set (第一重队列)</span><br>                    <span class="hljs-comment">// 4. 线程状态：RUNNABLE -&gt; WAITING</span><br>                    <span class="hljs-comment">// 注意：此时线程完全“睡死”，必须等待 notify 救援</span><br>                    lock.wait(); <br>                    <br>                    <span class="hljs-comment">// ============================================================</span><br>                    <span class="hljs-comment">// [阶段 4：漫长的回归之路 - 穿越“两重队列”]</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 1. 【被 notify 唤醒时】：</span><br>                    <span class="hljs-comment">//    Thread-A 从 Wait Set 移出，直接被扔进 Entry Set (第二重队列)。</span><br>                    <span class="hljs-comment">//    因为锁还在通知者手里！</span><br>                    <span class="hljs-comment">//    此时状态：WAITING -&gt; BLOCKED。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 2. 【等待锁释放】：</span><br>                    <span class="hljs-comment">//    在 Entry Set 中排队，直到通知者离开 synchronized。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 3. 【竞争锁 &amp; OS 调度】：</span><br>                    <span class="hljs-comment">//    抢到锁 -&gt; BLOCKED 变 RUNNABLE (Ready) -&gt; 获得 CPU (Running)。</span><br>                    <span class="hljs-comment">// ============================================================</span><br><br>                    <span class="hljs-comment">// [阶段 5：重回舞台]</span><br>                    <span class="hljs-comment">// 此时 Thread-A 已经成功拿回了锁和 CPU</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Woke up, re-acquired lock.&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Condition met, doing work.&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// [阶段 6]：离开 synchronized 块</span><br>        <span class="hljs-comment">// 状态详情：释放锁 | 持有 CPU | 离开 Owner 变为 Outside | RUNNABLE</span><br>    &#125;<br><br>    <span class="hljs-comment">// === 通知者线程 (Thread-B) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doNotify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// [阶段 7]：获取锁</span><br>            <span class="hljs-comment">// 状态详情：持有锁 | 持有 CPU | Owner | RUNNABLE</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Acquired lock, changing condition...&quot;</span>);<br>            conditionSatisfied = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// [阶段 8：只管唤醒，不管开门]</span><br>            <span class="hljs-comment">// 状态详情（关键点）：</span><br>            <span class="hljs-comment">// 1. Monitor 锁：仍然持有！(Signal and Continue)</span><br>            <span class="hljs-comment">// 2. Mesa Set：Owner（Thread-B 还在舞台上）</span><br>            <span class="hljs-comment">// 3. 对 Thread-A 的影响：将 A 从 Wait Set 移入 Entry Set (BLOCKED)</span><br>            lock.notify(); <br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Notified, but STILL holding lock.&quot;</span>);<br>            <br>            <span class="hljs-comment">// 模拟 Thread-B 继续占用锁，此时 Thread-A 只能在 Entry Set 阻塞</span><br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>        &#125; <br>        <span class="hljs-comment">// [阶段 9：真正放手]</span><br>        <span class="hljs-comment">// 离开 synchronized 块，释放 Monitor 锁。</span><br>        <span class="hljs-comment">// 此时 Entry Set 里的 Thread-A 才有机会去抢锁，完成它的“回归之路”。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockExample</span> &#123;<br>    <span class="hljs-comment">// 显式锁（替代 synchronized）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 显式条件变量（替代 Object monitor methods）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionSatisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// === 等待者线程 (Thread-A) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAwait</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// [阶段 1]：尝试获取锁</span><br>        <span class="hljs-comment">// 状态详情：</span><br>        <span class="hljs-comment">// 1. AQS State：尝试 CAS 修改 state。</span><br>        <span class="hljs-comment">// 2. AQS Queue：如果失败，进入 AQS Sync Queue (同步队列) 排队。</span><br>        <span class="hljs-comment">// 3. 线程状态：BLOCKED (Parked)。</span><br>        lock.lock(); <br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ============================================================</span><br>            <span class="hljs-comment">// [微观状态间隙 - AQS 版]</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 1. 【Lock Acquired】：</span><br>            <span class="hljs-comment">//    CAS 成功，或被前驱节点唤醒。</span><br>            <span class="hljs-comment">//    线程从 AQS Sync Queue 移出 (Head 节点后继)。</span><br>            <span class="hljs-comment">//    State：BLOCKED -&gt; RUNNABLE。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 2. 【OS Scheduling】：</span><br>            <span class="hljs-comment">//    进入 OS Ready Queue，等待 CPU。JVM 本身并不理解 OS 的这个队列，所以 RUNNABLE 包含了“可以运行”和“正在运行”两种状态。</span><br>            <span class="hljs-comment">//    此时：持有 ReentrantLock | 未持有 CPU。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 3. 【Running】：</span><br>            <span class="hljs-comment">//    获得 CPU 时间片，开始执行下一行。</span><br>            <span class="hljs-comment">// ============================================================</span><br><br>            <span class="hljs-comment">// [阶段 2]：真正执行代码</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Acquired lock, checking condition...&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (!conditionSatisfied) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Condition false, calling await()...&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// [阶段 3：主动入冷宫 - 调用 await()]</span><br>                    <span class="hljs-comment">// 状态详情（执行瞬间）：</span><br>                    <span class="hljs-comment">// 1. Lock 释放：彻底释放锁（fullyRelease），无论重入多少次。</span><br>                    <span class="hljs-comment">// 2. Mesa 位置：</span><br>                    <span class="hljs-comment">//    a. 构造一个 Node，加入 Condition Queue (条件队列)。</span><br>                    <span class="hljs-comment">//    b. 线程被挂起 (LockSupport.park)。</span><br>                    <span class="hljs-comment">// 3. 线程状态：RUNNABLE -&gt; WAITING。</span><br>                    condition.await(); <br>                    <br>                    <span class="hljs-comment">// ============================================================</span><br>                    <span class="hljs-comment">// [阶段 4：AQS 内部的漫长回归之路]</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 1. 【Signal 发生时】：</span><br>                    <span class="hljs-comment">//    Thread-A 的 Node 从 Condition Queue 被“踢”到了 AQS Sync Queue 尾部。</span><br>                    <span class="hljs-comment">//    注意：此时它仅仅是换了个队排，锁还在 Signal 线程手里！</span><br>                    <span class="hljs-comment">//    状态：WAITING -&gt; BLOCKED (等待获取锁)。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 2. 【等待锁释放】：</span><br>                    <span class="hljs-comment">//    在 AQS Sync Queue 中自旋或挂起，直到轮到自己。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 3. 【抢锁成功】：</span><br>                    <span class="hljs-comment">//    acquireQueued 返回，从 await() 方法内部返回。</span><br>                    <span class="hljs-comment">// ============================================================</span><br><br>                    <span class="hljs-comment">// [阶段 5：重回舞台]</span><br>                    <span class="hljs-comment">// 此时 Thread-A 处于 AQS Sync Queue 的 Head 位置并拿到了锁</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Woke up, re-acquired lock.&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Condition met, doing work.&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// [阶段 6]：释放锁</span><br>            <span class="hljs-comment">// 必须在 finally 中释放！</span><br>            <span class="hljs-comment">// 动作：修改 AQS state，唤醒 AQS Sync Queue 中的下一个节点 (Successor)。</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// === 通知者线程 (Thread-B) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">()</span> &#123;<br>        lock.lock(); <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// [阶段 7]：持有锁执行业务</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Acquired lock, changing condition...&quot;</span>);<br>            conditionSatisfied = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// [阶段 8：只管迁移，不管开门]</span><br>            <span class="hljs-comment">// 关键点：signal() 仅仅是将节点从 Condition Queue 转移到 AQS Sync Queue。</span><br>            <span class="hljs-comment">// Thread-B **仍然持有锁**！</span><br>            <span class="hljs-comment">// Thread-A 此时在 AQS Sync Queue 尾部排队，状态从 WAITING 变为了 BLOCKED。</span><br>            condition.signal(); <br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Signaled, but STILL holding lock.&quot;</span>);<br>            <br>            <span class="hljs-comment">// 模拟业务耗时</span><br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// [阶段 9：真正放手]</span><br>            <span class="hljs-comment">// 释放锁 (state = 0)。</span><br>            <span class="hljs-comment">// 此时 AQS Sync Queue 里的 Thread-A (如果排在前面的话) 被 unpark 唤醒，</span><br>            <span class="hljs-comment">// 从而完成 await() 的返回。</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Releasing lock...&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="线程状态列举">线程状态列举</h2>
<h3 id="new">NEW</h3>
<p>没有启动过的线程。</p>
<h3 id="runnable">RUNNABLE</h3>
<ol>
<li>正在执行的线程。</li>
<li>可以被执行但没有拿到处理器资源。</li>
</ol>
<h3 id="blocked">BLOCKED</h3>
<p>blocked 其实是 blocked waiting。</p>
<ol>
<li>等待 monitor，进入 synchronized method/block</li>
<li>或者等 wait()/await()以后再次进入 synchronized method/block。解除 wait 以后以后不是直接 runnable，而是进入 blocked，如果 notify 后通知线程立刻离开同步块，则几乎不可能用程序观察到从 blocked 进入 runnable。如果通知者在 notify() 之后赖着不走（比如执行了一个耗时操作），或者同时有 100 个线程在竞争这把锁：
<ul>
<li>那个被唤醒的线程会长时间停留在 BLOCKED 状态，直到它抢到锁为止。可以通过 jstack 或者 Thread.getState() 清晰地观察到它处于 BLOCKED 状态。</li>
</ul>
</li>
</ol>
<h3 id="waiting">WAITING</h3>
<p>在调用这三种不计时方法以后，线程进入 waiting 态：</p>
<ul>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.park 我们经常在文档里看到的 thread lies dormant 就是被这个方法处理过的结果</li>
</ul>
<p>waiting 意味着一个线程在等待另一个线程做出某种 action。wait 在等其他对象 notify 和 notifyAll，join 在等其他线程终结。</p>
<p>如：<br>
<code>java.util.concurrent.LinkedBlockingQueue.take -&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await -&gt; java.util.concurrent.locks.LockSupport.park</code></p>
<p>Reentrantlock 的 lock 接口的栈帧则是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sun<span class="hljs-selector-class">.misc</span><span class="hljs-selector-class">.Unsafe</span><span class="hljs-selector-class">.park</span> 行: 不可用 <span class="hljs-selector-attr">[本地方法]</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.LockSupport</span><span class="hljs-selector-class">.park</span> 行: <span class="hljs-number">175</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.parkAndCheckInterrupt</span> 行: <span class="hljs-number">836</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquireQueued</span> 行: <span class="hljs-number">870</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquire</span> 行: <span class="hljs-number">1199</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span><span class="hljs-selector-class">.lock</span> 行: <span class="hljs-number">209</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.ReentrantLock</span><span class="hljs-selector-class">.lock</span> 行: <span class="hljs-number">285</span> <br></code></pre></td></tr></table></figure>
<p>jstack 总会告诉我们 waiting 的位置，比如等待某个 Condition 的 await 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;t1 before lock&quot;</span>);<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 此时 t1 是 Runnable</span><br>            queue.put(<span class="hljs-number">1</span>); <span class="hljs-comment">// 此时刺激主线程开始读 t2</span><br>            System.out.println(<span class="hljs-string">&quot;t1 begin to sleep&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1 prepare to release lock&quot;</span>);<br>        lock.unlock();<br>        System.out.println(<span class="hljs-string">&quot;t1 release lock&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t2 before lock&quot;</span>);<br>        <span class="hljs-comment">// 此时 t2 可能被 t1 阻塞，进入 waiting 状态</span><br>        lock.lock();<br>        System.out.println(<span class="hljs-string">&quot;t2 prepare to release lock&quot;</span>);<br>        lock.unlock();<br>        System.out.println(<span class="hljs-string">&quot;t2 release lock&quot;</span>);<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>    t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>    t1.start();<br>    t2.start();<br>    <span class="hljs-comment">// 此时主线程在等待一个信号来刺激自己往下走</span><br>    queue.take();<br>    <span class="hljs-comment">// 往下走的目的就是校验 t2 的状态</span><br>    <span class="hljs-keyword">while</span> (t2.isAlive()) &#123;<br>        System.out.println(t2.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对这个程序进行 thread dump，可以看出 ReentrantLock 就是依赖于 park 导致的 waiting：</p>
<p><img src="parking%E5%8D%B3waiting.png" alt="parking即waiting.png"><br>
<img src="sleeping%E5%8D%B3timed-waiting.png" alt="sleeping即timed-waiting.png"></p>
<p>如果使用 synchronized，则会显示 object monitor：</p>
<p><img src="object-monitor.png" alt="object-monitor.png"></p>
<p>所以 waiting 可能是在条件变量上等待，也可能是在 synchronizer 本身上等待，不可一概而论。</p>
<p>按照 jvisualvm 的分类方法，线程还可以分为：</p>
<ul>
<li>等待</li>
<li>驻留（park）</li>
<li>监视（monitor）</li>
</ul>
<h3 id="timed-waiting">TIMED_WAITING</h3>
<p>调用了计时方法，等待时间结束后才或者被其他唤醒方法唤醒结束等待。</p>
<ul>
<li>Thread.sleep</li>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUntil</li>
</ul>
<p>如：</p>
<p><code>java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take -&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos -&gt; java.util.concurrent.locks.LockSupport.parkNanos -&gt; sun.misc.Unsafe.park</code></p>
<p>除了 sleep 以外，jstack 总会告诉我们 time_waiting 的位置，比如等待某个 Condition 的 await 操作。</p>
<h3 id="terminated">TERMINATED</h3>
<p>终结的线程，执行已经结束了。</p>
<p>中断退出也是一种结束。</p>
<h3 id="几种线程状态的对比">几种线程状态的对比</h3>
<ol>
<li>blocked：线程想要获取锁进入临界区之前，会求锁，求不到锁会进入 entry_set，然后放弃 cpu。高并发时 blocked 会增多。</li>
<li>工作线程池开始伸缩，扩容的时候：jvm.thread.waiting.count 的数量会变少。过程是，core 线程先满，然后队列再满，这时候等待从队列里获取任务，waiting 在 take 动作上的线程已经降为0了，然后开始产生非core线程，线程数才开始增长。</li>
<li>工作吞吐变多，而调用下游的工作线程在阻塞的时候，jvm.thread.time_waiting.count 会变多，因为 rpc 框架自带超时，而这些超时是会让工作线程进行计时等待的。</li>
<li>流量变大的时候，2 和 3 可能同时发生。</li>
</ol>
<h2 id="线程间方法的设计哲学">线程间方法的设计哲学</h2>
<ol>
<li>通常：
<ol>
<li>静态方法 = “我要操作当前线程”（self-operation）。static 相当于 per thread，一个好记的例子是通常 ThreadLocal 设置为 static 的，这样每个线程可以分到一个它的实例，而不是每个线程在每个对象里分到它的实例。</li>
<li>实例方法 = “我要操作指定线程”（cross-thread operation）。</li>
</ol>
</li>
<li>这背后的逻辑是：
<ol>
<li>每个线程操作自己是比较安全的，static 可以默认在不指定对象的情况下操作自己。</li>
<li>而跨线程操作其他线程是比较危险的，因为其他线程的生死如果不是自然发展和结束的，很可能导致锁不释放，条件变量不正确设置，通知没有正确发出。这也就意味着系统可能死锁。
<ol>
<li>主动控制线程何时开始是安全的。</li>
<li>主动控制进程何时结束是危险的，因为你不能替他释放资源-这是禁止使用 stop、spend api 这类操作的全部理由。</li>
</ol>
</li>
<li>可以跨线程操作的是比较温和的操作：
<ol>
<li>start()：可以让程序员开启线程周期。</li>
<li>interrupt()：可以设置一个标志位，算是轻微的主动写入别的线程状态的一种低侵入的 api。</li>
<li>join(): 观测另一个对象的状态，通过内部自旋 wait 来等待另一个线程死亡。</li>
</ol>
</li>
<li>其他 static 方法：
<ol>
<li>yield()：主动让出 CPU，让同优先级线程有机会运行。是对调度器的&quot;建议&quot;，不保证效果。和 interrupt 的温和写入，但不必然强制操作形成对比。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="特别的切换方法">特别的切换方法</h2>
<h3 id="locksupport-park">LockSupport.park</h3>
<p>也就是线程挂起。</p>
<p>condition 的 await 底层调用的是 LockSupport.park。这个方法的参数是一个用作 monitor 的对象，会被设置到 Object 的特定 Offset 上。</p>
<p>park 只能带来 waiting。所以 sync 和 conditionObject 其实都让 thread waiting ，只不过代表 thread 的 node 处在的队列不一样而已-线程 node 在 sync queue 和 condition queue 都是 waiting。</p>
<h3 id="wait">wait</h3>
<p>这个方法是对 object 用的。</p>
<p>从 wait 中醒来会有伪唤醒的 case，所以醒来的时候一定要先检查唤醒条件是否已经得到满足。原理见<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/271521213">《为什么条件锁会产生虚假唤醒现象（spurious wakeup）？》</a></p>
<h3 id="join">join</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待此线程终止，最多等待 millis 毫秒。超时值为 0 表示永久等待。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 设计巧妙之处（三个关键角色的分离）：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 当 th1 调用 th2.join() 时：</span><br><span class="hljs-comment"> * 1. 锁对象：th2（Thread 对象）</span><br><span class="hljs-comment"> * 2. 检查对象：th2（通过 isAlive() 检查）</span><br><span class="hljs-comment"> * 3. 等待线程：th1（调用 wait() 的线程）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 执行流程：</span><br><span class="hljs-comment"> * - th1 获取 th2 对象的 Monitor 锁</span><br><span class="hljs-comment"> * - th1 检查 th2.isAlive()</span><br><span class="hljs-comment"> * - th1 在 th2 对象上调用 wait()，释放锁并挂起</span><br><span class="hljs-comment"> * - th2 执行完毕时，JVM 自动调用 th2.notifyAll()</span><br><span class="hljs-comment"> * - th1 被唤醒，重新检查 th2.isAlive()（协作式逻辑）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * Thread 对象的特殊性：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 1. 普通对象（Object、String 等）：</span><br><span class="hljs-comment"> *    - 没有内置状态可以自动触发 notify()</span><br><span class="hljs-comment"> *    - wait/notify 完全由程序员手动控制</span><br><span class="hljs-comment"> *    - 适合作为条件变量</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 2. Thread 对象（特殊对象）：</span><br><span class="hljs-comment"> *    - 有内置状态：线程生命周期（NEW → RUNNABLE → TERMINATED）</span><br><span class="hljs-comment"> *    - 状态变化触发通知：线程终止时，JVM 自动调用 notifyAll()</span><br><span class="hljs-comment"> *    - 不适合作为条件变量：会出现程序设计之外的 notifyAll()</span><br><span class="hljs-comment"> *    - Javadoc 警告：&quot;不建议在 Thread 实例上使用 wait/notify/notifyAll&quot;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 为什么 JVM 要自动 notifyAll()？</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * - 设计目的：专门为 join() 而设计</span><br><span class="hljs-comment"> * - 常见需求：等待线程结束是非常常见的并发模式</span><br><span class="hljs-comment"> * - 简化编程：无需手动管理通知逻辑</span><br><span class="hljs-comment"> * - 设计哲学：Thread 对象代表执行流，生命周期结束是重要事件</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 协作式编程体现：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * - OS 调度（抢占式）：JVM/OS 决定何时给 th1 CPU 时间片</span><br><span class="hljs-comment"> * - 业务逻辑（协作式）：th1 主动检查 isAlive()，决定是否继续等待</span><br><span class="hljs-comment"> * - while 循环的意义：不是&quot;被唤醒就执行&quot;，而是&quot;醒来后检查条件&quot;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  millis 等待的毫秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException 如果 millis 为负数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException 如果当前线程被中断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 记录开始时间，用于计算已等待时长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 无超时版本：永久等待直到线程结束</span><br>        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 协作式编程的核心：while 循环主动检查条件</span><br>            <span class="hljs-comment">// - isAlive() 检查的是 this（th2）的状态</span><br>            <span class="hljs-comment">// - wait(0) 挂起的是调用线程（th1）</span><br>            <span class="hljs-comment">// - 使用 while 而非 if，防止伪唤醒（spurious wakeup）</span><br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-comment">// 调用线程（th1）在 this（th2）对象上等待</span><br>                <span class="hljs-comment">// 等价于：th2.wait(0)</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 释放 th2 对象的 Monitor 锁，th1 进入 WAITING 状态</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 可能的唤醒原因：</span><br>                <span class="hljs-comment">// 1. th2 结束，JVM 自动调用 th2.notifyAll()（Thread 对象的特殊性）</span><br>                <span class="hljs-comment">// 2. 伪唤醒（spurious wakeup）</span><br>                wait(<span class="hljs-number">0</span>);<br>                <br>                <span class="hljs-comment">// 被唤醒后，重新检查 isAlive()（协作式逻辑）</span><br>                <span class="hljs-comment">// 如果是伪唤醒且 th2 还活着，继续 wait</span><br>                <span class="hljs-comment">// 如果 th2 已死，退出循环</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 带超时版本：等待指定时间或线程结束</span><br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-comment">// 计算剩余等待时间</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis - now;<br>                <br>                <span class="hljs-comment">// 超时检查：如果已经等待了足够长的时间，退出循环</span><br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 调用线程（th1）在 this（th2）对象上等待 delay 毫秒</span><br>                <span class="hljs-comment">// 等价于：th2.wait(delay)</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 可能的唤醒原因：</span><br>                <span class="hljs-comment">// 1. th2 结束，JVM 自动调用 th2.notifyAll()</span><br>                <span class="hljs-comment">// 2. 超时时间到</span><br>                <span class="hljs-comment">// 3. 伪唤醒</span><br>                wait(delay);<br>                <br>                <span class="hljs-comment">// 更新已等待时长</span><br>                now = System.currentTimeMillis() - base;<br>                <br>                <span class="hljs-comment">// 循环继续，重新检查 isAlive() 和剩余时间（协作式逻辑）</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 退出方法时，释放 th2 对象的 Monitor 锁</span><br>        <span class="hljs-comment">// th1 继续执行后续代码</span><br>    &#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>线程的 join 相当于当前线程在另一个会死亡的线程对象上等待，在 while 循环里无限  wait，在超时或者该线程死亡的时候从 wait 里解脱出来。</li>
<li>每个 thread 对象的内置状态变成死亡的时候，JVM 会主动调用这个对象的 notifyAll，这和任意条件对象的 wait 和 notifyAll 由程序员自己控制是不一样的。</li>
</ol>
<h1>JMM</h1>
<h2 id="volatile">Volatile</h2>
<p>根据 JMM（Java Memory Model）规范，volatile 关键字提供两个核心保证：</p>
<ol>
<li>
<p><strong>可见性（Visibility）</strong>：对 volatile 变量的写操作对后续的读操作立即可见。当一个线程修改了 volatile 变量的值，新值会立即被刷新到主内存，其他线程读取时会从主内存中获取最新值。</p>
</li>
<li>
<p><strong>有序性（Ordering）</strong>：volatile 写-读建立 happens-before 关系，通过内存屏障禁止特定的指令重排序：</p>
<ul>
<li>volatile 写之前的操作不会被重排序到 volatile 写之后</li>
<li>volatile 读之后的操作不会被重排序到 volatile 读之前</li>
<li>volatile 写 happens-before 后续的 volatile 读</li>
</ul>
</li>
</ol>
<p>需要注意的是，volatile 不保证原子性。对于复合操作（如 <code>i++</code>），仍然需要使用 synchronized 或原子类来保证线程安全。</p>
<p>volatile 的语义本质上是通过内存屏障（Memory Barrier）实现的 happens-before 语义，而非简单的&quot;刷新缓存&quot;模型。理解这一点对于正确使用 volatile 至关重要。</p>
<p><img src="volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="volatile的可见性影响.png"></p>
<h1>JUC</h1>
<p><img src="juc-class-diagram.png" alt="juc-class-diagram.png"></p>
<h2 id="总体设计原则">总体设计原则</h2>
<ul>
<li>有状态管理的核心组件：
<ul>
<li>FutureTask：任务执行状态</li>
<li>ThreadPoolExecutor：线程池生命周期状态</li>
<li>Worker：工作线程锁状态</li>
<li>BlockingQueue：任务队列状态</li>
<li>Thread：操作系统线程状态</li>
</ul>
</li>
<li>Doug Lea 特别热衷于使用顺序状态来表达初始、中间态和终态，往往使用 &lt;= 中间态当作初始态，&gt;= 中间态当作完成态（包括 normal 和 exceptional）。“用最少的状态变量，表达最精确的状态转换。”
<ul>
<li>原子变量优先于锁</li>
<li>状态编码（Packing）</li>
<li>无锁算法（Lock-Free）</li>
<li>状态转换的精确性</li>
</ul>
</li>
<li>有一些变量内存不安全，强依赖于 happen-before relation 的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14432400/why-outcome-object-in-futuretask-is-non-volatile">巧妙实现</a>，也需要参考<a href="##Volatile">Volatile</a>。</li>
<li>Doug Lea 不喜欢写大括号。</li>
<li>对于所有的计时等待而言，0 意味着无限等待。</li>
<li>链表的特性：
<ul>
<li>在初始时，链表总是先初始化 head，cas 成功，然后用 head 赋值给 tail，使其最初相等，但读值的时候顺序是反过来的-利用了 volatile 的内存屏障的特性。</li>
<li>只要有一个 cas 操作成功，包裹住剩下的 volatile 写都不需要再做 cas。所以通常对 AQS 自身的全局状态的 cas 是和链表自身状态的 link/unlink 操作是分开的。</li>
<li>所有要被 cas 的链表元素/aqs state，在局部代码运行前，要被先用局部变量存储起来，写在 block 的最开始。这样做可以提高复用性，减少多次对 volatile 变量的求值，避免对缓存机制的扰乱，也保证了变量的线程封闭性。在全局也有一些 global state。</li>
</ul>
</li>
<li>有副作用的方法，副作用包括修改全局变量、park、unpark、修改中断位，返回值通常是主要操作的成败。有时候用 int 代表多种返回值。</li>
</ul>
<h2 id="unsafe-的应用">Unsafe 的应用</h2>
<p>JUC 强依赖于 Unsafe，它提供了硬件级别的 CAS 原子操作。在 X86 上，这个 CAS 操作依赖于 cmpxchg 指令，会锁定总线。所以仍然会产生一些硬件锁。</p>
<p>通常 Unsafe 的使用模式是<code>compareAndSwapXXX</code>，一个典型的函数是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object obj, <span class="hljs-type">long</span> offset, Object expect, Object update)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>obj是我们要操作的目标对象</li>
<li>offset表示了目标对象中，对应的属性的内存偏移量</li>
<li>expect是进行比较的原值</li>
<li>update是拟写入的新值</li>
</ul>
<h3 id="获取-field">获取 field</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; k = FutureTask.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">stateField</span> <span class="hljs-operator">=</span> k.getDeclaredField(<span class="hljs-string">&quot;state&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>进而获取 field 的偏移：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">objectFieldOffset</span><span class="hljs-params">(Field field)</span>;<br></code></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">tailOffset = unsafe.objectFieldOffset<br>            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;tail&quot;</span>));<br></code></pre></td></tr></table></figure>
<p>然后就可以做类似的 cas 操作了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetTail</span><span class="hljs-params">(Node expect, Node update)</span> &#123;<br>     <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(<span class="hljs-built_in">this</span>, tailOffset, expect, update);<br> &#125;<br></code></pre></td></tr></table></figure>
<p>很多 AtomicXXX 原子类，底层都依赖于 Unsafe 的 CAS offset、old value、new value操作。</p>
<h3 id="increaseandget-与-getandincrease">increaseAndGet 与 getAndIncrease</h3>
<p>incrementAndGet() 是由 getAndAddInt(obj, offset, 1) + 1 实现的，而 getAndIncrement() 直接就是 getAndAddInt(…, 1) 的返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// OpenJDK 8</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object obj, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = getIntVolatile(obj, offset);<br>    <span class="hljs-comment">// 整个“比较+更新”操作封装在 compareAndSwapInt() 中，在 JNI 里是借助于一个 CPU 指令（cmpxchg）完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。   </span><br>    &#125; <span class="hljs-keyword">while</span> (!compareAndSwapInt(obj, offset, v, v + delta));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>CAS 有三大问题：</p>
<blockquote>
<ul>
<li>ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
<ul>
<li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li>
<li>实现细节：AtomicStampedReference 内部使用一个不可变的 Pair 对象来封装引用和版本号（stamp）。每次 compareAndSet 成功时，都会创建一个新的 Pair 对象。Pair 本身的比较是引用比较（==），这意味着即使两个 Pair 包含相同的引用和 stamp 值，只要不是同一个对象实例，比较就会失败。这种设计确保了版本号机制的正确性。</li>
</ul>
</li>
<li>循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。自旋（spin-wait）在低竞争场景下非常高效，因为避免了线程阻塞/唤醒的上下文切换开销。只有在高竞争或长时间无法成功时，自旋才成为问题。现代 JVM（如 HotSpot）在 Atomic* 类中仍使用简单自旋，因为其设计目标是短临界区、低延迟。更复杂的结构（如 ConcurrentLinkedQueue）会采用退避策略（backoff） 或结合 Thread.yield()，但 AtomicInteger 本身不这么做。</li>
<li>只能保证一个共享变量的原子操作（实际上是单个内存地址）。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
<ul>
<li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="自旋锁">自旋锁</h3>
<blockquote>
<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
</blockquote>
<p><img src="%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E9%9D%9E%E8%87%AA%E6%97%8B%E9%94%81.png" alt="自旋锁与非自旋锁"></p>
<blockquote>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK<br>
6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
</blockquote>
<p>在自旋锁中另有三种常见的锁形式：TicketLock、<a target="_blank" rel="noopener" href="https://coderbee.net/index.php/concurrent/20131115/577">CLHlock和MCSlock</a>。这是很多 Lock Free 数据结构的基础。但 CLH 改成双端队列和引入 Park 以后，也可以实现 blocking lock。</p>
<p><strong>关于 AQS 中的 CLH 队列变体</strong>：需要特别说明的是，AQS（AbstractQueuedSynchronizer）使用的是 CLH 队列的变体，而非标准的 CLH 队列：</p>
<ul>
<li><strong>标准 CLH 队列</strong>：每个节点在前驱节点的 locked 字段上自旋等待，是一种纯自旋锁实现</li>
<li><strong>AQS 变体</strong>：使用显式的 prev 和 next 双向指针，并结合 <code>LockSupport.park/unpark</code> 实现真正的阻塞而非自旋。这种设计使得 AQS 既保留了 CLH 队列的 FIFO 公平性，又避免了自旋带来的 CPU 资源浪费</li>
</ul>
<p><img src="%E5%9B%9B%E7%A7%8D%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%80%9D%E8%B7%AF.png" alt="四种锁升级的思路"></p>
<p><strong>synchronized 锁升级流程概览</strong>：</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph &quot;锁状态演进&quot;
        A[无锁&lt;br/&gt;001] --&gt;|首次加锁| B[偏向锁&lt;br/&gt;101]
        B --&gt;|第二个线程竞争| C[轻量级锁&lt;br/&gt;00]
        C --&gt;|自旋失败/竞争激烈| D[重量级锁&lt;br/&gt;10]
    end
    
    subgraph &quot;特点对比&quot;
        B1[&quot;偏向锁&lt;br/&gt;• 无竞争场景&lt;br/&gt;• 只记录线程ID&lt;br/&gt;• 无同步开销&quot;]
        C1[&quot;轻量级锁&lt;br/&gt;• 短暂竞争&lt;br/&gt;• CAS + 自旋&lt;br/&gt;• 避免阻塞&quot;]
        D1[&quot;重量级锁&lt;br/&gt;• 激烈竞争&lt;br/&gt;• OS 互斥量&lt;br/&gt;• 线程阻塞&quot;]
    end
    
    B -.-&gt; B1
    C -.-&gt; C1
    D -.-&gt; D1
    
    style A fill:#e8f5e9
    style B fill:#fff3e0
    style C fill:#e3f2fd
    style D fill:#ffebee</code></pre>
<blockquote>
<p><strong>注意</strong>：JDK 15 起，偏向锁默认禁用（JEP 374），锁升级从无锁直接到轻量级锁。</p>
</blockquote>
<p>具体的解释先统一存储在<a href="https://magicliang.github.io/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">《线程安全与锁优化》</a>。</p>
<h2 id="函数式接口">函数式接口</h2>
<h3 id="区别-runnable-和-callable">区别 Runnable 和 Callable</h3>
<p>Runnable 本身是不抛出异常的，但 Callable  本身耗时比较长，而且还会抛出异常（这个设计会最终导致我们进行函数式编程的时候，有时候我们需要在 Runnable 内部处理异常，有时候我们要在 Callable 外处理异常）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="synchronized-的状态">synchronized 的状态</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sync1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 制造一个内外部死锁，让 t1 内部锁死在这里</span><br>        <span class="hljs-keyword">synchronized</span> (sync1) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">20L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;I am going to die，current state：&quot;</span> + Thread.currentThread().getState() );<br>        &#125;<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;TTTTTT1&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (sync1) &#123;<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">2000L</span>);<br>        System.out.println(<span class="hljs-string">&quot;t1 state1：&quot;</span> + t1.getState());<br>        <span class="hljs-comment">// waiting for jmx client to attach on it</span><br>        Thread.sleep(<span class="hljs-number">30000L</span>);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;unsyncrhonized&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;t1 state2：&quot;</span> + t1.getState());<br>    Thread.sleep(<span class="hljs-number">500000L</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="jvisualvm%E8%A7%82%E5%AF%9F%E5%88%B0monitored%E6%80%81.png" alt="jvisualvm观察到monitored态"><br>
<img src="jmc%E5%BE%97%E5%88%B0blocked%E6%80%81.png" alt="jmc得到blocked态"></p>
<p>JVisualVM 会专门把 block 当做 monitorered 态。</p>
<h2 id="locksupport">LockSupport</h2>
<p>这个类型是为了提供阻塞元语，这样可以创造以锁为代表的 synchronization classes。</p>
<p>使用一个 park，如果有 permit，则立刻返回，否则阻塞；使用一个 unpark 会让 permit available。permit 最多有一个，这点和 semaphore 不一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sync1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 在这一步以后，线程进入 waiting 的 state</span><br>        <span class="hljs-comment">// park 和 unpark 只能内外部调用，不能在一个线程内对称调用，而且 park 的参数是 sync，unpark 的参数是线程</span><br>        LockSupport.park(sync1);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">20L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">// RUNNABLE</span><br>        System.out.println(<span class="hljs-string">&quot;I am going to die，current state：&quot;</span> + Thread.currentThread().getState() );<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;TTTTTT1&quot;</span>);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">2000L</span>);<br>    <span class="hljs-comment">//  t1 state1：WAITING</span><br>    System.out.println(<span class="hljs-string">&quot;t1 state1：&quot;</span> + t1.getState());<br>    <span class="hljs-comment">// waiting for jmx client to attach on it</span><br>    Thread.sleep(<span class="hljs-number">30000L</span>);<br>    <span class="hljs-comment">// 这个unpark并不会立刻让 t1 进入runnable</span><br>    LockSupport.unpark(t1);<br>    System.out.println(<span class="hljs-string">&quot;unpark&quot;</span>);<br>    <span class="hljs-comment">// t1 state1：WAITING/TIMED_WAITING/RUNNABLE/TERMINATED </span><br>    System.out.println(<span class="hljs-string">&quot;t1 state2：&quot;</span> + t1.getState());<br>    Thread.sleep(<span class="hljs-number">500000L</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="JVisualVM%E7%9A%84%E9%A9%BB%E7%95%99%E7%8A%B6%E6%80%81.png" alt="JVisualVM的驻留状态"><br>
<img src="JMC%E7%9C%8Bwaiting%E7%8A%B6%E6%80%81.jpeg" alt="JMC看waiting状态"></p>
<p>注意，只有 jvisualvm会有“驻留”这个状态，jmc和jconsole都是直接进入标准的 waiting 状态。目前使用基于aqs 的lock 和 await 语义都会导致waiting，这会和 Object waiting 产生混淆。JVisualVM 似乎能够把 object waiting 和 park 驻留导致的 waiting 专门区别开来。</p>
<h2 id="内存一致性效应-memory-consistency-effects">内存一致性效应（Memory consistency effects）</h2>
<p>哪一种 action happen-before 哪一种action？</p>
<p>通常是 action prior to some release opertion happen-before action following acquire operation。</p>
<p>比如 Semaphore 的 memory consistency effect：Actions in a thread prior to calling a “release” method such as release() happen-before actions following a successful “acquire” method such as acquire() in another thread.</p>
<h2 id="主流锁">主流锁</h2>
<p><img src="Java%E7%9A%84%E4%B8%BB%E6%B5%81%E9%94%81.png" alt="Java的主流锁"></p>
<h3 id="悲观锁与乐观锁">悲观锁与乐观锁</h3>
<p><img src="%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81.png" alt="乐观锁与悲观锁"></p>
<ul>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">《一行一行源码分析清楚AbstractQueuedSynchronizer》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016058789">《Java多线程》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">《从ReentrantLock的实现看AQS的原理及应用》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">《不可不说的Java&quot;锁&quot;事》</a></li>
<li><a target="_blank" rel="noopener" href="http://itmyhome.com/java-api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#nested_class_summary">《官方文档的中文翻译》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《Java线程池实现原理及其在美团业务中的实践》</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" title="无锁队列"><img class="cover" src="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">无锁队列</div></div><div class="info-2"><div class="info-item-1">Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。 * * &lt;p&gt;原理说明： * - 仅允许一个线程调用 &#123;@code offer()&#125;，一个线程调用 &#123;@code poll()&#125;。 * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。 * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系： *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。 * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad）， *   ...</div></div></div></a><a class="pagination-related" href="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/" title="Java 线程池笔记"><img class="cover" src="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-24</div><div class="info-item-2">Java 线程池笔记</div></div><div class="info-2"><div class="info-item-1">从执行器到线程池  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia “池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。 在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括： 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池(Object Pooling)：循...</div></div></div></a><a class="pagination-related" href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-19</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1"> 版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374），在 JDK 18 中相关代码已被移除。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级。但在深入讨论线程安全的分类之前，我们需要先理解 Java 内存模型——它是理解线程安全问题的理论基础。 Java 内存模型基础 Java 内存模型（Java Memory Model，JMM）是 Java 语言规范的一部分，定义了多线程程序中共享变量的访问规则。理解 JMM 是理解线程安全问题的基础。 为什么需要内存模型？ 现代计算机系统中，CPU 与主内存之间存在巨大的速度差异。为了弥补这一差距，硬件层面引入了多级缓存（L1、L...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-56.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a><a class="pagination-related" href="/2017/11/03/JVM-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="JVM 的内存模型与线程"><img class="cover" src="/img/wall-paper-158.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-03</div><div class="info-item-2">JVM 的内存模型与线程</div></div><div class="info-2"><div class="info-item-1">1.性能何处寻   计算机的CPU比起其他所有的设备，都快得多，所以怎样尽量复用 CPU 的时间片，是压榨计算机性能的目标。多核和并发，使得阿姆达尔定律大显神威，超越摩尔定律成为提升系统性能的金科玉律 - 现在单核计算能力已经无法垂直提升，要水平提升核数来提升整体性能。 2.缓存一致性问题（Cache Coherence）   软件缓存，不过是硬件缓存的模仿，真正的缓存，早已存在于计算机的多级存储体系结构中。JVM 里，我们可以认为每个处理器都会在主内存（Main Memory）之外有高速缓存作为工作内存（Working memory）。除此之外，处理器和 JVM 都可能出现指令重排（Instruction Reorder）的的情况。工作内存是线程 Save 和 Load 的主要场所，主内存则是他们沟通的场所。 3.JVM 的对象信息   Java Object 除了基本的内存轮廓以外，还有：  Mark Word（对象的 Hash Code 的缓存值、GC标志、GC年龄、同步锁等信息）。 Klass Point（指向对象元数据信息的指针，指向 .class  的指针吗？不是，是...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-85.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">上下文 卡表和 RSet（Remember Set），是 JVM 为了解决分代收集时，live set 扫描需要穿梭到不同的代的时候的效率问题。 使用缓存表来提高查询效率，是化顺序查找为部分随机查找的一种常用的设计思路。 例如，在传统的计算机体系结构中，当我们把内存分成页以后，会有一个页表，页表又会有一个快表，作为一个中间缓存项，来帮助我们查找我们需要使用的页表项（table entry）。 JVM 在进行垃圾收集的时候，有一项非常重要的工作就是确定这一次垃圾收集的对象到底有多少个，即确定 live set 的范围。 对于新生代垃圾收集器而言，这个问题又有其特殊之处。根据 JVM 的弱分代收集假设（weak generational hypothesis）的存在，每次垃圾收集的时候，新生代的扫描范围可能很大，但新生代的 live set 不应该太大。card table/Remember Set 的设计目的，就是尽量减少无用的垃圾扫描范围，使用类似操作系统或者数据库的脏页表的形式，来做类似快表的查询。 卡表（card table）  卡表是 CMS 的解决方案。 卡表通常在 JV...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">写在前面的话</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">管程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mesa-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">MESA 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-set-%E8%80%8C%E4%B8%8D%E7%94%A8-queue"><span class="toc-number">1.2.1.</span> <span class="toc-text">为什么用 set 而不用 queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">模型映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mesa-%E6%A8%A1%E5%9E%8B%E7%9A%84-signal-and-continue-%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. Mesa 模型的 “Signal and Continue” 语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-entry-set-%E9%94%81%E7%AB%9E%E4%BA%89-%E2%9D%8C-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E6%9C%89-timed-waiting"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. Entry Set（锁竞争）❌ 永远不会有 TIMED_WAITING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-wait-set-%E6%9D%A1%E4%BB%B6%E7%AD%89%E5%BE%85-%E2%9C%85-%E6%94%AF%E6%8C%81-timed-waiting"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. Wait Set（条件等待）✅ 支持 TIMED_WAITING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-jvisualvm-%E5%88%86%E7%B1%BB%E9%80%BB%E8%BE%91"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4. JVisualVM 分类逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E-os-%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">5. 线程状态与 OS 调度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Java 线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%97%E4%B8%BE"><span class="toc-number">2.1.</span> <span class="toc-text">线程状态列举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">2.1.1.</span> <span class="toc-text">NEW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runnable"><span class="toc-number">2.1.2.</span> <span class="toc-text">RUNNABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocked"><span class="toc-number">2.1.3.</span> <span class="toc-text">BLOCKED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waiting"><span class="toc-number">2.1.4.</span> <span class="toc-text">WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timed-waiting"><span class="toc-number">2.1.5.</span> <span class="toc-text">TIMED_WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#terminated"><span class="toc-number">2.1.6.</span> <span class="toc-text">TERMINATED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.7.</span> <span class="toc-text">几种线程状态的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">2.2.</span> <span class="toc-text">线程间方法的设计哲学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E7%9A%84%E5%88%87%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">特别的切换方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#locksupport-park"><span class="toc-number">2.3.1.</span> <span class="toc-text">LockSupport.park</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-number">2.3.2.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">2.3.3.</span> <span class="toc-text">join</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">3.1.</span> <span class="toc-text">Volatile</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.1.</span> <span class="toc-text">总体设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">Unsafe 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-field"><span class="toc-number">4.2.1.</span> <span class="toc-text">获取 field</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#increaseandget-%E4%B8%8E-getandincrease"><span class="toc-number">4.2.2.</span> <span class="toc-text">increaseAndGet 与 getAndIncrease</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">4.2.3.</span> <span class="toc-text">自旋锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.</span> <span class="toc-text">函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-runnable-%E5%92%8C-callable"><span class="toc-number">4.3.1.</span> <span class="toc-text">区别 Runnable 和 Callable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.4.</span> <span class="toc-text">synchronized 的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#locksupport"><span class="toc-number">4.5.</span> <span class="toc-text">LockSupport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%95%88%E5%BA%94-memory-consistency-effects"><span class="toc-number">4.6.</span> <span class="toc-text">内存一致性效应（Memory consistency effects）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E9%94%81"><span class="toc-number">4.7.</span> <span class="toc-text">主流锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">4.7.1.</span> <span class="toc-text">悲观锁与乐观锁</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>