<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 并发编程笔记 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 MESA 模型 JAVA 采用 MESA 模型：  互斥（Mutual Exclusion">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 并发编程笔记">
<meta property="og:url" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 MESA 模型 JAVA 采用 MESA 模型：  互斥（Mutual Exclusion">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png">
<meta property="article:published_time" content="2026-01-12T14:28:12.000Z">
<meta property="article:modified_time" content="2026-01-24T14:14:55.027Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 并发编程笔记",
  "url": "https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
  "image": "https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png",
  "datePublished": "2026-01-12T14:28:12.000Z",
  "dateModified": "2026-01-24T14:14:55.027Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 并发编程笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 并发编程笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java 并发编程笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-12T14:28:12.000Z" title="Created 2026-01-12 22:28:12">2026-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T14:14:55.027Z" title="Updated 2026-01-24 22:14:55">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">32.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>128mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><img src="juc.png" alt="juc.png"><br>
<a href="juc.xmind">juc.xmind</a></p>
<h1>写在前面的话</h1>
<p>并发编程最早的实践都在操作系统里。</p>
<h2 id="管程">管程</h2>
<p>理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。</p>
<h2 id="mesa-模型">MESA 模型</h2>
<p>JAVA 采用 MESA 模型：</p>
<ul>
<li>互斥（Mutual Exclusion）：通过锁机制保证同一时刻只有一个线程能进入管程内部执行。</li>
<li>同步（Synchronization）：利用条件变量（Condition Variable）实现线程间的等待与唤醒。</li>
<li>Signal and Continue：</li>
</ul>
<blockquote>
<p>当线程发出通知（signal/notify）时，它继续持有锁并运行，而被唤醒的线程仅仅是进入就绪队列，并不立即抢占 CPU。</p>
</blockquote>
<ul>
<li>必须使用 while 循环：</li>
</ul>
<blockquote>
<p>由于线程被唤醒后不一定立即执行，当它重新获得锁时，环境条件可能已发生变化，因此必须在一个 while 循环中重新检查等待条件（while<br>
(condition) { wait(); }）。</p>
</blockquote>
<h3 id="为什么用-set-而不用-queue">为什么用 set 而不用 queue</h3>
<ol>
<li>Queue 暗示 FIFO（先进先出）：</li>
</ol>
<ul>
<li>如果我们叫它 EntryQueue，开发者会本能地认为：先来的线程一定先拿到锁。</li>
<li>但实际上，Java 的 synchronized 是非公平锁（Non-fair Lock）。</li>
</ul>
<ol start="2">
<li>实际上更像“一堆人”而不是“一队人”：</li>
</ol>
<ul>
<li>在 JVM 的具体实现策略中，当锁被释放时，并不保证 EntrySet 中排在最前面的线程一定能抢到锁（可能被刚来的线程抢走，或者被随机唤醒）。</li>
<li>对于 WaitSet，notify() 唤醒的线程也不一定是先 wait() 的那个线程（取决于具体 JVM 实现）。</li>
<li>所以，用 Set（集合） 这个词能更准确地表达“这里有一群线程在等，但谁先出去不一定”的语义。</li>
</ul>
<p>总结：叫 Set 是为了告诉你，不要依赖它们的唤醒顺序。</p>
<h3 id="模型映射">模型映射</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Mesa 模型</th>
<th style="text-align:left">Mesa 语义</th>
<th style="text-align:left"><code>synchronized</code></th>
<th style="text-align:left"><code>ReentrantLock</code></th>
<th style="text-align:left">Java State</th>
<th style="text-align:left">超时</th>
<th style="text-align:left">JVisualVM</th>
<th style="text-align:left">底层机制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Entry Set</strong><br>(锁竞争)</td>
<td style="text-align:left">等待获取锁</td>
<td style="text-align:left">Monitor Entry List</td>
<td style="text-align:left">AQS Sync Queue</td>
<td style="text-align:left"><code>BLOCKED</code><br><code>WAITING (parking)</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left">Monitor<br>Park</td>
<td style="text-align:left">ObjectMonitor<br>LockSupport.park()</td>
</tr>
<tr>
<td style="text-align:left"><strong>Wait Set</strong><br>(条件等待)</td>
<td style="text-align:left">等待条件满足</td>
<td style="text-align:left">Monitor Wait Set</td>
<td style="text-align:left">AQS Condition Queue</td>
<td style="text-align:left"><code>WAITING</code><br><code>TIMED_WAITING</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left">Wait<br>Park</td>
<td style="text-align:left">ObjectMonitor<br>LockSupport.park()</td>
</tr>
<tr>
<td style="text-align:left"><strong>Owner</strong><br>(持有者)</td>
<td style="text-align:left">持有锁的线程</td>
<td style="text-align:left">Monitor Owner</td>
<td style="text-align:left">exclusiveOwnerThread</td>
<td style="text-align:left"><code>RUNNABLE</code></td>
<td style="text-align:left">-</td>
<td style="text-align:left">Running</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<h4 id="1-mesa-模型的-signal-and-continue-语义">1. Mesa 模型的 “Signal and Continue” 语义</h4>
<ul>
<li><code>notify()</code> / <code>signal()</code> 后，通知者<strong>继续持有锁</strong></li>
<li>被唤醒的线程从 Wait Set 移入 Entry Set，必须<strong>重新竞争锁</strong></li>
<li>唤醒路径：
<ul>
<li><code>synchronized</code>: Wait Set → Entry Set (<code>BLOCKED</code>) → Owner</li>
<li><code>ReentrantLock</code>: Condition Queue → Sync Queue (<code>WAITING</code>) → Owner</li>
</ul>
</li>
</ul>
<h4 id="2-entry-set-锁竞争-❌-永远不会有-timed-waiting">2. Entry Set（锁竞争）❌ 永远不会有 TIMED_WAITING</h4>
<ul>
<li><code>synchronized</code> 不支持超时</li>
<li><code>ReentrantLock.lock()</code> 不支持超时</li>
<li><code>tryLock(timeout)</code> 不进队列，在当前线程自旋</li>
</ul>
<h4 id="3-wait-set-条件等待-✅-支持-timed-waiting">3. Wait Set（条件等待）✅ 支持 TIMED_WAITING</h4>
<ul>
<li><code>wait(timeout)</code> / <code>await(timeout, unit)</code> 支持超时</li>
<li>设计哲学：条件等待是主动等待业务条件，需要&quot;等不到就放弃&quot;的语义</li>
</ul>
<h4 id="4-jvisualvm-分类逻辑">4. JVisualVM 分类逻辑</h4>
<ul>
<li><strong>Monitor</strong>: <code>synchronized</code> 的 <code>BLOCKED</code> 状态</li>
<li><strong>Park</strong>: <code>LockSupport.park()</code> 导致的 <code>WAITING</code> 状态</li>
<li><strong>Wait</strong>: <code>Object.wait()</code> 导致的 <code>WAITING</code> 状态</li>
</ul>
<h4 id="5-线程状态与-os-调度">5. 线程状态与 OS 调度</h4>
<ul>
<li><strong>RUNNABLE</strong> = OS Ready + OS Running（JVM 无法区分）</li>
<li><strong>BLOCKED</strong> / <strong>WAITING</strong>: 线程在 JVM 队列中，未持有 CPU</li>
<li>Ready Queue 是 OS 层面的，JVM 不可见</li>
</ul>
<h1>Java 线程状态</h1>
<p><img src="java-thread-state.png" alt="java-thread-state.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MesaMonitorExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionSatisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// === 等待者线程 (Thread-A) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWait</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// [阶段 1]：尝试进入 synchronized 块</span><br>        <span class="hljs-comment">// 状态详情：</span><br>        <span class="hljs-comment">// 1. Monitor 锁：未持有（正在 Entry Set 排队竞争）</span><br>        <span class="hljs-comment">// 2. CPU：未持有（被 OS 挂起）</span><br>        <span class="hljs-comment">// 3. Mesa Set：处于 Entry Set (入口队列/锁池)</span><br>        <span class="hljs-comment">// 4. 线程状态：BLOCKED</span><br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// ============================================================</span><br>            <span class="hljs-comment">// [微观状态间隙 - 从抢到锁到执行第一行代码]</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 1. 【Lock Acquired】：</span><br>            <span class="hljs-comment">//    Monitor 锁竞争成功。线程从 Entry Set 移出，成为 Owner。</span><br>            <span class="hljs-comment">//    Java 线程状态：BLOCKED -&gt; RUNNABLE。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 2. 【OS Scheduling (Ready)】：</span><br>            <span class="hljs-comment">//    虽然 Java 认为你是 RUNNABLE，但在 OS 看来，你只是进入了</span><br>            <span class="hljs-comment">//    &quot;CPU 就绪队列&quot; (Ready Queue)，正在等待分配时间片。JVM 本身并不理解 OS 的这个队列，所以 RUNNABLE 包含了“可以运行”和“正在运行”两种状态。</span><br>            <span class="hljs-comment">//    此时：持有锁 | 未持有 CPU | 状态：RUNNABLE (Ready)。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 3. 【Context Switch (Running)】：</span><br>            <span class="hljs-comment">//    OS 调度器选中了本线程，加载寄存器，PC 指针指向下一行指令。</span><br>            <span class="hljs-comment">//    此时：持有锁 | 持有 CPU | 状态：RUNNABLE (Running)。</span><br>            <span class="hljs-comment">// ============================================================</span><br>            <br>            <span class="hljs-comment">// [阶段 2]：真正执行代码</span><br>            <span class="hljs-comment">// 状态详情：持有锁 | 持有 CPU | Owner (持有者) | RUNNABLE (Running)</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Acquired lock, checking condition...&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (!conditionSatisfied) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Condition false, calling wait()...&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// [阶段 3：主动入冷宫 - 调用 wait()]</span><br>                    <span class="hljs-comment">// 状态详情（执行瞬间）：</span><br>                    <span class="hljs-comment">// 1. Monitor 锁：原子性释放</span><br>                    <span class="hljs-comment">// 2. CPU：主动放弃</span><br>                    <span class="hljs-comment">// 3. Mesa Set：从 Owner 移入 Wait Set (第一重队列)</span><br>                    <span class="hljs-comment">// 4. 线程状态：RUNNABLE -&gt; WAITING</span><br>                    <span class="hljs-comment">// 注意：此时线程完全“睡死”，必须等待 notify 救援</span><br>                    lock.wait(); <br>                    <br>                    <span class="hljs-comment">// ============================================================</span><br>                    <span class="hljs-comment">// [阶段 4：漫长的回归之路 - 穿越“两重队列”]</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 1. 【被 notify 唤醒时】：</span><br>                    <span class="hljs-comment">//    Thread-A 从 Wait Set 移出，直接被扔进 Entry Set (第二重队列)。</span><br>                    <span class="hljs-comment">//    因为锁还在通知者手里！</span><br>                    <span class="hljs-comment">//    此时状态：WAITING -&gt; BLOCKED。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 2. 【等待锁释放】：</span><br>                    <span class="hljs-comment">//    在 Entry Set 中排队，直到通知者离开 synchronized。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 3. 【竞争锁 &amp; OS 调度】：</span><br>                    <span class="hljs-comment">//    抢到锁 -&gt; BLOCKED 变 RUNNABLE (Ready) -&gt; 获得 CPU (Running)。</span><br>                    <span class="hljs-comment">// ============================================================</span><br><br>                    <span class="hljs-comment">// [阶段 5：重回舞台]</span><br>                    <span class="hljs-comment">// 此时 Thread-A 已经成功拿回了锁和 CPU</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Woke up, re-acquired lock.&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Condition met, doing work.&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// [阶段 6]：离开 synchronized 块</span><br>        <span class="hljs-comment">// 状态详情：释放锁 | 持有 CPU | 离开 Owner 变为 Outside | RUNNABLE</span><br>    &#125;<br><br>    <span class="hljs-comment">// === 通知者线程 (Thread-B) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doNotify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// [阶段 7]：获取锁</span><br>            <span class="hljs-comment">// 状态详情：持有锁 | 持有 CPU | Owner | RUNNABLE</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Acquired lock, changing condition...&quot;</span>);<br>            conditionSatisfied = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// [阶段 8：只管唤醒，不管开门]</span><br>            <span class="hljs-comment">// 状态详情（关键点）：</span><br>            <span class="hljs-comment">// 1. Monitor 锁：仍然持有！(Signal and Continue)</span><br>            <span class="hljs-comment">// 2. Mesa Set：Owner（Thread-B 还在舞台上）</span><br>            <span class="hljs-comment">// 3. 对 Thread-A 的影响：将 A 从 Wait Set 移入 Entry Set (BLOCKED)</span><br>            lock.notify(); <br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Notified, but STILL holding lock.&quot;</span>);<br>            <br>            <span class="hljs-comment">// 模拟 Thread-B 继续占用锁，此时 Thread-A 只能在 Entry Set 阻塞</span><br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>        &#125; <br>        <span class="hljs-comment">// [阶段 9：真正放手]</span><br>        <span class="hljs-comment">// 离开 synchronized 块，释放 Monitor 锁。</span><br>        <span class="hljs-comment">// 此时 Entry Set 里的 Thread-A 才有机会去抢锁，完成它的“回归之路”。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockExample</span> &#123;<br>    <span class="hljs-comment">// 显式锁（替代 synchronized）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 显式条件变量（替代 Object monitor methods）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionSatisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// === 等待者线程 (Thread-A) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAwait</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// [阶段 1]：尝试获取锁</span><br>        <span class="hljs-comment">// 状态详情：</span><br>        <span class="hljs-comment">// 1. AQS State：尝试 CAS 修改 state。</span><br>        <span class="hljs-comment">// 2. AQS Queue：如果失败，进入 AQS Sync Queue (同步队列) 排队。</span><br>        <span class="hljs-comment">// 3. 线程状态：BLOCKED (Parked)。</span><br>        lock.lock(); <br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ============================================================</span><br>            <span class="hljs-comment">// [微观状态间隙 - AQS 版]</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 1. 【Lock Acquired】：</span><br>            <span class="hljs-comment">//    CAS 成功，或被前驱节点唤醒。</span><br>            <span class="hljs-comment">//    线程从 AQS Sync Queue 移出 (Head 节点后继)。</span><br>            <span class="hljs-comment">//    State：BLOCKED -&gt; RUNNABLE。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 2. 【OS Scheduling】：</span><br>            <span class="hljs-comment">//    进入 OS Ready Queue，等待 CPU。JVM 本身并不理解 OS 的这个队列，所以 RUNNABLE 包含了“可以运行”和“正在运行”两种状态。</span><br>            <span class="hljs-comment">//    此时：持有 ReentrantLock | 未持有 CPU。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 3. 【Running】：</span><br>            <span class="hljs-comment">//    获得 CPU 时间片，开始执行下一行。</span><br>            <span class="hljs-comment">// ============================================================</span><br><br>            <span class="hljs-comment">// [阶段 2]：真正执行代码</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Acquired lock, checking condition...&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (!conditionSatisfied) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Condition false, calling await()...&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// [阶段 3：主动入冷宫 - 调用 await()]</span><br>                    <span class="hljs-comment">// 状态详情（执行瞬间）：</span><br>                    <span class="hljs-comment">// 1. Lock 释放：彻底释放锁（fullyRelease），无论重入多少次。</span><br>                    <span class="hljs-comment">// 2. Mesa 位置：</span><br>                    <span class="hljs-comment">//    a. 构造一个 Node，加入 Condition Queue (条件队列)。</span><br>                    <span class="hljs-comment">//    b. 线程被挂起 (LockSupport.park)。</span><br>                    <span class="hljs-comment">// 3. 线程状态：RUNNABLE -&gt; WAITING。</span><br>                    condition.await(); <br>                    <br>                    <span class="hljs-comment">// ============================================================</span><br>                    <span class="hljs-comment">// [阶段 4：AQS 内部的漫长回归之路]</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 1. 【Signal 发生时】：</span><br>                    <span class="hljs-comment">//    Thread-A 的 Node 从 Condition Queue 被“踢”到了 AQS Sync Queue 尾部。</span><br>                    <span class="hljs-comment">//    注意：此时它仅仅是换了个队排，锁还在 Signal 线程手里！</span><br>                    <span class="hljs-comment">//    状态：WAITING -&gt; BLOCKED (等待获取锁)。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 2. 【等待锁释放】：</span><br>                    <span class="hljs-comment">//    在 AQS Sync Queue 中自旋或挂起，直到轮到自己。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 3. 【抢锁成功】：</span><br>                    <span class="hljs-comment">//    acquireQueued 返回，从 await() 方法内部返回。</span><br>                    <span class="hljs-comment">// ============================================================</span><br><br>                    <span class="hljs-comment">// [阶段 5：重回舞台]</span><br>                    <span class="hljs-comment">// 此时 Thread-A 处于 AQS Sync Queue 的 Head 位置并拿到了锁</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Woke up, re-acquired lock.&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Condition met, doing work.&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// [阶段 6]：释放锁</span><br>            <span class="hljs-comment">// 必须在 finally 中释放！</span><br>            <span class="hljs-comment">// 动作：修改 AQS state，唤醒 AQS Sync Queue 中的下一个节点 (Successor)。</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// === 通知者线程 (Thread-B) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">()</span> &#123;<br>        lock.lock(); <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// [阶段 7]：持有锁执行业务</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Acquired lock, changing condition...&quot;</span>);<br>            conditionSatisfied = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// [阶段 8：只管迁移，不管开门]</span><br>            <span class="hljs-comment">// 关键点：signal() 仅仅是将节点从 Condition Queue 转移到 AQS Sync Queue。</span><br>            <span class="hljs-comment">// Thread-B **仍然持有锁**！</span><br>            <span class="hljs-comment">// Thread-A 此时在 AQS Sync Queue 尾部排队，状态从 WAITING 变为了 BLOCKED。</span><br>            condition.signal(); <br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Signaled, but STILL holding lock.&quot;</span>);<br>            <br>            <span class="hljs-comment">// 模拟业务耗时</span><br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// [阶段 9：真正放手]</span><br>            <span class="hljs-comment">// 释放锁 (state = 0)。</span><br>            <span class="hljs-comment">// 此时 AQS Sync Queue 里的 Thread-A (如果排在前面的话) 被 unpark 唤醒，</span><br>            <span class="hljs-comment">// 从而完成 await() 的返回。</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Releasing lock...&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="线程状态列举">线程状态列举</h2>
<h3 id="new">NEW</h3>
<p>没有启动过的线程。</p>
<h3 id="runnable">RUNNABLE</h3>
<ol>
<li>正在执行的线程。</li>
<li>可以被执行但没有拿到处理器资源。</li>
</ol>
<h3 id="blocked">BLOCKED</h3>
<p>blocked 其实是 blocked waiting。</p>
<ol>
<li>等待 monitor，进入 synchronized method/block</li>
<li>或者等 wait()/await()以后再次进入 synchronized method/block。解除 wait 以后以后不是直接 runnable，而是进入 blocked，如果 notify 后通知线程立刻离开同步块，则几乎不可能用程序观察到从 blocked 进入 runnable。如果通知者在 notify() 之后赖着不走（比如执行了一个耗时操作），或者同时有 100 个线程在竞争这把锁：
<ul>
<li>那个被唤醒的线程会长时间停留在 BLOCKED 状态，直到它抢到锁为止。可以通过 jstack 或者 Thread.getState() 清晰地观察到它处于 BLOCKED 状态。</li>
</ul>
</li>
</ol>
<h3 id="waiting">WAITING</h3>
<p>在调用这三种不计时方法以后，线程进入 waiting 态：</p>
<ul>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.park 我们经常在文档里看到的 thread lies dormant 就是被这个方法处理过的结果</li>
</ul>
<p>waiting 意味着一个线程在等待另一个线程做出某种 action。wait 在等其他对象 notify 和 notifyAll，join 在等其他线程终结。</p>
<p>如：<br>
<code>java.util.concurrent.LinkedBlockingQueue.take -&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await -&gt; java.util.concurrent.locks.LockSupport.park</code></p>
<p>Reentrantlock 的 lock 接口的栈帧则是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sun<span class="hljs-selector-class">.misc</span><span class="hljs-selector-class">.Unsafe</span><span class="hljs-selector-class">.park</span> 行: 不可用 <span class="hljs-selector-attr">[本地方法]</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.LockSupport</span><span class="hljs-selector-class">.park</span> 行: <span class="hljs-number">175</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.parkAndCheckInterrupt</span> 行: <span class="hljs-number">836</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquireQueued</span> 行: <span class="hljs-number">870</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquire</span> 行: <span class="hljs-number">1199</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span><span class="hljs-selector-class">.lock</span> 行: <span class="hljs-number">209</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.ReentrantLock</span><span class="hljs-selector-class">.lock</span> 行: <span class="hljs-number">285</span> <br></code></pre></td></tr></table></figure>
<p>jstack 总会告诉我们 waiting 的位置，比如等待某个 Condition 的 await 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;t1 before lock&quot;</span>);<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 此时 t1 是 Runnable</span><br>            queue.put(<span class="hljs-number">1</span>); <span class="hljs-comment">// 此时刺激主线程开始读 t2</span><br>            System.out.println(<span class="hljs-string">&quot;t1 begin to sleep&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1 prepare to release lock&quot;</span>);<br>        lock.unlock();<br>        System.out.println(<span class="hljs-string">&quot;t1 release lock&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t2 before lock&quot;</span>);<br>        <span class="hljs-comment">// 此时 t2 可能被 t1 阻塞，进入 waiting 状态</span><br>        lock.lock();<br>        System.out.println(<span class="hljs-string">&quot;t2 prepare to release lock&quot;</span>);<br>        lock.unlock();<br>        System.out.println(<span class="hljs-string">&quot;t2 release lock&quot;</span>);<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>    t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>    t1.start();<br>    t2.start();<br>    <span class="hljs-comment">// 此时主线程在等待一个信号来刺激自己往下走</span><br>    queue.take();<br>    <span class="hljs-comment">// 往下走的目的就是校验 t2 的状态</span><br>    <span class="hljs-keyword">while</span> (t2.isAlive()) &#123;<br>        System.out.println(t2.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对这个程序进行 thread dump，可以看出 ReentrantLock 就是依赖于 park 导致的 waiting：</p>
<p><img src="parking%E5%8D%B3waiting.png" alt="parking即waiting.png"><br>
<img src="sleeping%E5%8D%B3timed-waiting.png" alt="sleeping即timed-waiting.png"></p>
<p>如果使用 synchronized，则会显示 object monitor：</p>
<p><img src="object-monitor.png" alt="object-monitor.png"></p>
<p>所以 waiting 可能是在条件变量上等待，也可能是在 synchronizer 本身上等待，不可一概而论。</p>
<p>按照 jvisualvm 的分类方法，线程还可以分为：</p>
<ul>
<li>等待</li>
<li>驻留（park）</li>
<li>监视（monitor）</li>
</ul>
<h3 id="timed-waiting">TIMED_WAITING</h3>
<p>调用了计时方法，等待时间结束后才或者被其他唤醒方法唤醒结束等待。</p>
<ul>
<li>Thread.sleep</li>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUntil</li>
</ul>
<p>如：</p>
<p><code>java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take -&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos -&gt; java.util.concurrent.locks.LockSupport.parkNanos -&gt; sun.misc.Unsafe.park</code></p>
<p>除了 sleep 以外，jstack 总会告诉我们 time_waiting 的位置，比如等待某个 Condition 的 await 操作。</p>
<h3 id="terminated">TERMINATED</h3>
<p>终结的线程，执行已经结束了。</p>
<p>中断退出也是一种结束。</p>
<h3 id="几种线程状态的对比">几种线程状态的对比</h3>
<ol>
<li>blocked：线程想要获取锁进入临界区之前，会求锁，求不到锁会进入 entry_set，然后放弃 cpu。高并发时 blocked 会增多。</li>
<li>工作线程池开始伸缩，扩容的时候：jvm.thread.waiting.count 的数量会变少。过程是，core 线程先满，然后队列再满，这时候等待从队列里获取任务，waiting 在 take 动作上的线程已经降为0了，然后开始产生非core线程，线程数才开始增长。</li>
<li>工作吞吐变多，而调用下游的工作线程在阻塞的时候，jvm.thread.time_waiting.count 会变多，因为 rpc 框架自带超时，而这些超时是会让工作线程进行计时等待的。</li>
<li>流量变大的时候，2 和 3 可能同时发生。</li>
</ol>
<h2 id="线程间方法的设计哲学">线程间方法的设计哲学</h2>
<ol>
<li>通常：
<ol>
<li>静态方法 = “我要操作当前线程”（self-operation）。static 相当于 per thread，一个好记的例子是通常 ThreadLocal 设置为 static 的，这样每个线程可以分到一个它的实例，而不是每个线程在每个对象里分到它的实例。</li>
<li>实例方法 = “我要操作指定线程”（cross-thread operation）。</li>
</ol>
</li>
<li>这背后的逻辑是：
<ol>
<li>每个线程操作自己是比较安全的，static 可以默认在不指定对象的情况下操作自己。</li>
<li>而跨线程操作其他线程是比较危险的，因为其他线程的生死如果不是自然发展和结束的，很可能导致锁不释放，条件变量不正确设置，通知没有正确发出。这也就意味着系统可能死锁。
<ol>
<li>主动控制线程何时开始是安全的。</li>
<li>主动控制进程何时结束是危险的，因为你不能替他释放资源-这是禁止使用 stop、spend api 这类操作的全部理由。</li>
</ol>
</li>
<li>可以跨线程操作的是比较温和的操作：
<ol>
<li>start()：可以让程序员开启线程周期。</li>
<li>interrupt()：可以设置一个标志位，算是轻微的主动写入别的线程状态的一种低侵入的 api。</li>
<li>join(): 观测另一个对象的状态，通过内部自旋 wait 来等待另一个线程死亡。</li>
</ol>
</li>
<li>其他 static 方法：
<ol>
<li>yield()：主动让出 CPU，让同优先级线程有机会运行。是对调度器的&quot;建议&quot;，不保证效果。和 interrupt 的温和写入，但不必然强制操作形成对比。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="特别的切换方法">特别的切换方法</h2>
<h3 id="locksupport-park">LockSupport.park</h3>
<p>也就是线程挂起。</p>
<p>condition 的 await 底层调用的是 LockSupport.park。这个方法的参数是一个用作 monitor 的对象，会被设置到 Object 的特定 Offset 上。</p>
<p>park 只能带来 waiting。所以 sync 和 conditionObject 其实都让 thread waiting ，只不过代表 thread 的 node 处在的队列不一样而已-线程 node 在 sync queue 和 condition queue 都是 waiting。</p>
<h3 id="wait">wait</h3>
<p>这个方法是对 object 用的。</p>
<p>从 wait 中醒来会有伪唤醒的 case，所以醒来的时候一定要先检查唤醒条件是否已经得到满足。原理见<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/271521213">《为什么条件锁会产生虚假唤醒现象（spurious wakeup）？》</a></p>
<h3 id="join">join</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待此线程终止，最多等待 millis 毫秒。超时值为 0 表示永久等待。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 设计巧妙之处（三个关键角色的分离）：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 当 th1 调用 th2.join() 时：</span><br><span class="hljs-comment"> * 1. 锁对象：th2（Thread 对象）</span><br><span class="hljs-comment"> * 2. 检查对象：th2（通过 isAlive() 检查）</span><br><span class="hljs-comment"> * 3. 等待线程：th1（调用 wait() 的线程）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 执行流程：</span><br><span class="hljs-comment"> * - th1 获取 th2 对象的 Monitor 锁</span><br><span class="hljs-comment"> * - th1 检查 th2.isAlive()</span><br><span class="hljs-comment"> * - th1 在 th2 对象上调用 wait()，释放锁并挂起</span><br><span class="hljs-comment"> * - th2 执行完毕时，JVM 自动调用 th2.notifyAll()</span><br><span class="hljs-comment"> * - th1 被唤醒，重新检查 th2.isAlive()（协作式逻辑）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * Thread 对象的特殊性：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 1. 普通对象（Object、String 等）：</span><br><span class="hljs-comment"> *    - 没有内置状态可以自动触发 notify()</span><br><span class="hljs-comment"> *    - wait/notify 完全由程序员手动控制</span><br><span class="hljs-comment"> *    - 适合作为条件变量</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 2. Thread 对象（特殊对象）：</span><br><span class="hljs-comment"> *    - 有内置状态：线程生命周期（NEW → RUNNABLE → TERMINATED）</span><br><span class="hljs-comment"> *    - 状态变化触发通知：线程终止时，JVM 自动调用 notifyAll()</span><br><span class="hljs-comment"> *    - 不适合作为条件变量：会出现程序设计之外的 notifyAll()</span><br><span class="hljs-comment"> *    - Javadoc 警告：&quot;不建议在 Thread 实例上使用 wait/notify/notifyAll&quot;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 为什么 JVM 要自动 notifyAll()？</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * - 设计目的：专门为 join() 而设计</span><br><span class="hljs-comment"> * - 常见需求：等待线程结束是非常常见的并发模式</span><br><span class="hljs-comment"> * - 简化编程：无需手动管理通知逻辑</span><br><span class="hljs-comment"> * - 设计哲学：Thread 对象代表执行流，生命周期结束是重要事件</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 协作式编程体现：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * - OS 调度（抢占式）：JVM/OS 决定何时给 th1 CPU 时间片</span><br><span class="hljs-comment"> * - 业务逻辑（协作式）：th1 主动检查 isAlive()，决定是否继续等待</span><br><span class="hljs-comment"> * - while 循环的意义：不是&quot;被唤醒就执行&quot;，而是&quot;醒来后检查条件&quot;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  millis 等待的毫秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException 如果 millis 为负数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException 如果当前线程被中断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 记录开始时间，用于计算已等待时长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 无超时版本：永久等待直到线程结束</span><br>        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 协作式编程的核心：while 循环主动检查条件</span><br>            <span class="hljs-comment">// - isAlive() 检查的是 this（th2）的状态</span><br>            <span class="hljs-comment">// - wait(0) 挂起的是调用线程（th1）</span><br>            <span class="hljs-comment">// - 使用 while 而非 if，防止伪唤醒（spurious wakeup）</span><br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-comment">// 调用线程（th1）在 this（th2）对象上等待</span><br>                <span class="hljs-comment">// 等价于：th2.wait(0)</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 释放 th2 对象的 Monitor 锁，th1 进入 WAITING 状态</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 可能的唤醒原因：</span><br>                <span class="hljs-comment">// 1. th2 结束，JVM 自动调用 th2.notifyAll()（Thread 对象的特殊性）</span><br>                <span class="hljs-comment">// 2. 伪唤醒（spurious wakeup）</span><br>                wait(<span class="hljs-number">0</span>);<br>                <br>                <span class="hljs-comment">// 被唤醒后，重新检查 isAlive()（协作式逻辑）</span><br>                <span class="hljs-comment">// 如果是伪唤醒且 th2 还活着，继续 wait</span><br>                <span class="hljs-comment">// 如果 th2 已死，退出循环</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 带超时版本：等待指定时间或线程结束</span><br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-comment">// 计算剩余等待时间</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis - now;<br>                <br>                <span class="hljs-comment">// 超时检查：如果已经等待了足够长的时间，退出循环</span><br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 调用线程（th1）在 this（th2）对象上等待 delay 毫秒</span><br>                <span class="hljs-comment">// 等价于：th2.wait(delay)</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 可能的唤醒原因：</span><br>                <span class="hljs-comment">// 1. th2 结束，JVM 自动调用 th2.notifyAll()</span><br>                <span class="hljs-comment">// 2. 超时时间到</span><br>                <span class="hljs-comment">// 3. 伪唤醒</span><br>                wait(delay);<br>                <br>                <span class="hljs-comment">// 更新已等待时长</span><br>                now = System.currentTimeMillis() - base;<br>                <br>                <span class="hljs-comment">// 循环继续，重新检查 isAlive() 和剩余时间（协作式逻辑）</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 退出方法时，释放 th2 对象的 Monitor 锁</span><br>        <span class="hljs-comment">// th1 继续执行后续代码</span><br>    &#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>线程的 join 相当于当前线程在另一个会死亡的线程对象上等待，在 while 循环里无限  wait，在超时或者该线程死亡的时候从 wait 里解脱出来。</li>
<li>每个 thread 对象的内置状态变成死亡的时候，JVM 会主动调用这个对象的 notifyAll，这和任意条件对象的 wait 和 notifyAll 由程序员自己控制是不一样的。</li>
</ol>
<h1>JMM</h1>
<h2 id="volatile">Volatile</h2>
<p>根据 JMM（Java Memory Model）规范，volatile 关键字提供两个核心保证：</p>
<ol>
<li>
<p><strong>可见性（Visibility）</strong>：对 volatile 变量的写操作对后续的读操作立即可见。当一个线程修改了 volatile 变量的值，新值会立即被刷新到主内存，其他线程读取时会从主内存中获取最新值。</p>
</li>
<li>
<p><strong>有序性（Ordering）</strong>：volatile 写-读建立 happens-before 关系，通过内存屏障禁止特定的指令重排序：</p>
<ul>
<li>volatile 写之前的操作不会被重排序到 volatile 写之后</li>
<li>volatile 读之后的操作不会被重排序到 volatile 读之前</li>
<li>volatile 写 happens-before 后续的 volatile 读</li>
</ul>
</li>
</ol>
<p>需要注意的是，volatile 不保证原子性。对于复合操作（如 <code>i++</code>），仍然需要使用 synchronized 或原子类来保证线程安全。</p>
<p>volatile 的语义本质上是通过内存屏障（Memory Barrier）实现的 happens-before 语义，而非简单的&quot;刷新缓存&quot;模型。理解这一点对于正确使用 volatile 至关重要。</p>
<p><img src="volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="volatile的可见性影响.png"></p>
<h1>JUC</h1>
<p><img src="juc-class-diagram.png" alt="juc-class-diagram.png"></p>
<h2 id="总体设计原则">总体设计原则</h2>
<ul>
<li>有状态管理的核心组件：
<ul>
<li>FutureTask：任务执行状态</li>
<li>ThreadPoolExecutor：线程池生命周期状态</li>
<li>Worker：工作线程锁状态</li>
<li>BlockingQueue：任务队列状态</li>
<li>Thread：操作系统线程状态</li>
</ul>
</li>
<li>Doug Lea 特别热衷于使用顺序状态来表达初始、中间态和终态，往往使用 &lt;= 中间态当作初始态，&gt;= 中间态当作完成态（包括 normal 和 exceptional）。“用最少的状态变量，表达最精确的状态转换。”
<ul>
<li>原子变量优先于锁</li>
<li>状态编码（Packing）</li>
<li>无锁算法（Lock-Free）</li>
<li>状态转换的精确性</li>
</ul>
</li>
<li>有一些变量内存不安全，强依赖于 happen-before relation 的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14432400/why-outcome-object-in-futuretask-is-non-volatile">巧妙实现</a>，也需要参考<a href="##Volatile">Volatile</a>。</li>
<li>Doug Lea 不喜欢写大括号。</li>
<li>对于所有的计时等待而言，0 意味着无限等待。</li>
<li>链表的特性：
<ul>
<li>在初始时，链表总是先初始化 head，cas 成功，然后用 head 赋值给 tail，使其最初相等，但读值的时候顺序是反过来的-利用了 volatile 的内存屏障的特性。</li>
<li>只要有一个 cas 操作成功，包裹住剩下的 volatile 写都不需要再做 cas。所以通常对 AQS 自身的全局状态的 cas 是和链表自身状态的 link/unlink 操作是分开的。</li>
<li>所有要被 cas 的链表元素/aqs state，在局部代码运行前，要被先用局部变量存储起来，写在 block 的最开始。这样做可以提高复用性，减少多次对 volatile 变量的求值，避免对缓存机制的扰乱，也保证了变量的线程封闭性。在全局也有一些 global state。</li>
</ul>
</li>
<li>有副作用的方法，副作用包括修改全局变量、park、unpark、修改中断位，返回值通常是主要操作的成败。有时候用 int 代表多种返回值。</li>
</ul>
<h2 id="unsafe-的应用">Unsafe 的应用</h2>
<p>JUC 强依赖于 Unsafe，它提供了硬件级别的 CAS 原子操作。在 X86 上，这个 CAS 操作依赖于 cmpxchg 指令，会锁定总线。所以仍然会产生一些硬件锁。</p>
<p>通常 Unsafe 的使用模式是<code>compareAndSwapXXX</code>，一个典型的函数是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object obj, <span class="hljs-type">long</span> offset, Object expect, Object update)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>obj是我们要操作的目标对象</li>
<li>offset表示了目标对象中，对应的属性的内存偏移量</li>
<li>expect是进行比较的原值</li>
<li>update是拟写入的新值</li>
</ul>
<h3 id="获取-field">获取 field</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; k = FutureTask.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">stateField</span> <span class="hljs-operator">=</span> k.getDeclaredField(<span class="hljs-string">&quot;state&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>进而获取 field 的偏移：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">objectFieldOffset</span><span class="hljs-params">(Field field)</span>;<br></code></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">tailOffset = unsafe.objectFieldOffset<br>            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;tail&quot;</span>));<br></code></pre></td></tr></table></figure>
<p>然后就可以做类似的 cas 操作了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetTail</span><span class="hljs-params">(Node expect, Node update)</span> &#123;<br>     <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(<span class="hljs-built_in">this</span>, tailOffset, expect, update);<br> &#125;<br></code></pre></td></tr></table></figure>
<p>很多 AtomicXXX 原子类，底层都依赖于 Unsafe 的 CAS offset、old value、new value操作。</p>
<h3 id="increaseandget-与-getandincrease">increaseAndGet 与 getAndIncrease</h3>
<p>incrementAndGet() 是由 getAndAddInt(obj, offset, 1) + 1 实现的，而 getAndIncrement() 直接就是 getAndAddInt(…, 1) 的返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// OpenJDK 8</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object obj, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = getIntVolatile(obj, offset);<br>    <span class="hljs-comment">// 整个“比较+更新”操作封装在 compareAndSwapInt() 中，在 JNI 里是借助于一个 CPU 指令（cmpxchg）完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。   </span><br>    &#125; <span class="hljs-keyword">while</span> (!compareAndSwapInt(obj, offset, v, v + delta));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>CAS 有三大问题：</p>
<blockquote>
<ul>
<li>ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
<ul>
<li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li>
<li>实现细节：AtomicStampedReference 内部使用一个不可变的 Pair 对象来封装引用和版本号（stamp）。每次 compareAndSet 成功时，都会创建一个新的 Pair 对象。Pair 本身的比较是引用比较（==），这意味着即使两个 Pair 包含相同的引用和 stamp 值，只要不是同一个对象实例，比较就会失败。这种设计确保了版本号机制的正确性。</li>
</ul>
</li>
<li>循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。自旋（spin-wait）在低竞争场景下非常高效，因为避免了线程阻塞/唤醒的上下文切换开销。只有在高竞争或长时间无法成功时，自旋才成为问题。现代 JVM（如 HotSpot）在 Atomic* 类中仍使用简单自旋，因为其设计目标是短临界区、低延迟。更复杂的结构（如 ConcurrentLinkedQueue）会采用退避策略（backoff） 或结合 Thread.yield()，但 AtomicInteger 本身不这么做。</li>
<li>只能保证一个共享变量的原子操作（实际上是单个内存地址）。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
<ul>
<li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="自旋锁">自旋锁</h3>
<blockquote>
<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
</blockquote>
<p><img src="%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E9%9D%9E%E8%87%AA%E6%97%8B%E9%94%81.png" alt="自旋锁与非自旋锁"></p>
<blockquote>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK<br>
6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
</blockquote>
<p>在自旋锁中另有三种常见的锁形式：TicketLock、<a target="_blank" rel="noopener" href="https://coderbee.net/index.php/concurrent/20131115/577">CLHlock和MCSlock</a>。这是很多 Lock Free 数据结构的基础。但 CLH 改成双端队列和引入 Park 以后，也可以实现 blocking lock。</p>
<p><strong>关于 AQS 中的 CLH 队列变体</strong>：需要特别说明的是，AQS（AbstractQueuedSynchronizer）使用的是 CLH 队列的变体，而非标准的 CLH 队列：</p>
<ul>
<li><strong>标准 CLH 队列</strong>：每个节点在前驱节点的 locked 字段上自旋等待，是一种纯自旋锁实现</li>
<li><strong>AQS 变体</strong>：使用显式的 prev 和 next 双向指针，并结合 <code>LockSupport.park/unpark</code> 实现真正的阻塞而非自旋。这种设计使得 AQS 既保留了 CLH 队列的 FIFO 公平性，又避免了自旋带来的 CPU 资源浪费</li>
</ul>
<p><img src="%E5%9B%9B%E7%A7%8D%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%80%9D%E8%B7%AF.png" alt="四种锁升级的思路"></p>
<p><strong>synchronized 锁升级流程概览</strong>：</p>
<pre><code class="hljs mermaid">flowchart LR
    subgraph &quot;锁状态演进&quot;
        A[无锁&lt;br/&gt;001] --&gt;|首次加锁| B[偏向锁&lt;br/&gt;101]
        B --&gt;|第二个线程竞争| C[轻量级锁&lt;br/&gt;00]
        C --&gt;|自旋失败/竞争激烈| D[重量级锁&lt;br/&gt;10]
    end
    
    subgraph &quot;特点对比&quot;
        B1[&quot;偏向锁&lt;br/&gt;• 无竞争场景&lt;br/&gt;• 只记录线程ID&lt;br/&gt;• 无同步开销&quot;]
        C1[&quot;轻量级锁&lt;br/&gt;• 短暂竞争&lt;br/&gt;• CAS + 自旋&lt;br/&gt;• 避免阻塞&quot;]
        D1[&quot;重量级锁&lt;br/&gt;• 激烈竞争&lt;br/&gt;• OS 互斥量&lt;br/&gt;• 线程阻塞&quot;]
    end
    
    B -.-&gt; B1
    C -.-&gt; C1
    D -.-&gt; D1
    
    style A fill:#e8f5e9
    style B fill:#fff3e0
    style C fill:#e3f2fd
    style D fill:#ffebee</code></pre>
<blockquote>
<p><strong>注意</strong>：JDK 15 起，偏向锁默认禁用（JEP 374），锁升级从无锁直接到轻量级锁。</p>
</blockquote>
<p>具体的解释先统一存储在<a href="https://magicliang.github.io/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">《线程安全与锁优化》</a>。</p>
<h2 id="函数式接口">函数式接口</h2>
<h3 id="区别-runnable-和-callable">区别 Runnable 和 Callable</h3>
<p>Runnable 本身是不抛出异常的，但 Callable  本身耗时比较长，而且还会抛出异常（这个设计会最终导致我们进行函数式编程的时候，有时候我们需要在 Runnable 内部处理异常，有时候我们要在 Callable 外处理异常）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="synchronized-的状态">synchronized 的状态</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sync1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 制造一个内外部死锁，让 t1 内部锁死在这里</span><br>        <span class="hljs-keyword">synchronized</span> (sync1) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">20L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;I am going to die，current state：&quot;</span> + Thread.currentThread().getState() );<br>        &#125;<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;TTTTTT1&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (sync1) &#123;<br>        t1.start();<br>        Thread.sleep(<span class="hljs-number">2000L</span>);<br>        System.out.println(<span class="hljs-string">&quot;t1 state1：&quot;</span> + t1.getState());<br>        <span class="hljs-comment">// waiting for jmx client to attach on it</span><br>        Thread.sleep(<span class="hljs-number">30000L</span>);<br>    &#125;<br>    System.out.println(<span class="hljs-string">&quot;unsyncrhonized&quot;</span>);<br>    System.out.println(<span class="hljs-string">&quot;t1 state2：&quot;</span> + t1.getState());<br>    Thread.sleep(<span class="hljs-number">500000L</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="jvisualvm%E8%A7%82%E5%AF%9F%E5%88%B0monitored%E6%80%81.png" alt="jvisualvm观察到monitored态"><br>
<img src="jmc%E5%BE%97%E5%88%B0blocked%E6%80%81.png" alt="jmc得到blocked态"></p>
<p>JVisualVM 会专门把 block 当做 monitorered 态。</p>
<h2 id="locksupport">LockSupport</h2>
<p>这个类型是为了提供阻塞元语，这样可以创造以锁为代表的 synchronization classes。</p>
<p>使用一个 park，如果有 permit，则立刻返回，否则阻塞；使用一个 unpark 会让 permit available。permit 最多有一个，这点和 semaphore 不一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sync1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 在这一步以后，线程进入 waiting 的 state</span><br>        <span class="hljs-comment">// park 和 unpark 只能内外部调用，不能在一个线程内对称调用，而且 park 的参数是 sync，unpark 的参数是线程</span><br>        LockSupport.park(sync1);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">20L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">// RUNNABLE</span><br>        System.out.println(<span class="hljs-string">&quot;I am going to die，current state：&quot;</span> + Thread.currentThread().getState() );<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;TTTTTT1&quot;</span>);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">2000L</span>);<br>    <span class="hljs-comment">//  t1 state1：WAITING</span><br>    System.out.println(<span class="hljs-string">&quot;t1 state1：&quot;</span> + t1.getState());<br>    <span class="hljs-comment">// waiting for jmx client to attach on it</span><br>    Thread.sleep(<span class="hljs-number">30000L</span>);<br>    <span class="hljs-comment">// 这个unpark并不会立刻让 t1 进入runnable</span><br>    LockSupport.unpark(t1);<br>    System.out.println(<span class="hljs-string">&quot;unpark&quot;</span>);<br>    <span class="hljs-comment">// t1 state1：WAITING/TIMED_WAITING/RUNNABLE/TERMINATED </span><br>    System.out.println(<span class="hljs-string">&quot;t1 state2：&quot;</span> + t1.getState());<br>    Thread.sleep(<span class="hljs-number">500000L</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="JVisualVM%E7%9A%84%E9%A9%BB%E7%95%99%E7%8A%B6%E6%80%81.png" alt="JVisualVM的驻留状态"><br>
<img src="JMC%E7%9C%8Bwaiting%E7%8A%B6%E6%80%81.jpeg" alt="JMC看waiting状态"></p>
<p>注意，只有 jvisualvm会有“驻留”这个状态，jmc和jconsole都是直接进入标准的 waiting 状态。目前使用基于aqs 的lock 和 await 语义都会导致waiting，这会和 Object waiting 产生混淆。JVisualVM 似乎能够把 object waiting 和 park 驻留导致的 waiting 专门区别开来。</p>
<h2 id="内存一致性效应-memory-consistency-effects">内存一致性效应（Memory consistency effects）</h2>
<p>哪一种 action happen-before 哪一种action？</p>
<p>通常是 action prior to some release opertion happen-before action following acquire operation。</p>
<p>比如 Semaphore 的 memory consistency effect：Actions in a thread prior to calling a “release” method such as release() happen-before actions following a successful “acquire” method such as acquire() in another thread.</p>
<h2 id="主流锁">主流锁</h2>
<p><img src="Java%E7%9A%84%E4%B8%BB%E6%B5%81%E9%94%81.png" alt="Java的主流锁"></p>
<h3 id="悲观锁与乐观锁">悲观锁与乐观锁</h3>
<p><img src="%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81.png" alt="乐观锁与悲观锁"></p>
<ul>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<h2 id="aqs-abstractqueuedsynchronizer">AQS（AbstractQueuedSynchronizer）</h2>
<p>JUC 有个 locks 包，所有的锁和基于锁的并发基础设施都在这个包里隐藏。这些数据结构被称为同步器，而同步器本身是为了并发安全而存在的（相应地应该也存在原子化的解决方案、隔离的解决方案，我们改天再探讨）。AQS 是为了实现同步器而设计的<strong>框架</strong>，作为 <strong>basis</strong> of a synchronizer（同步器的依据），它提供了 queuing and blocking mechanic。</p>
<blockquote>
<p>AQS虽然被定义为抽象类，但事实上它并不包含任何抽象方法。这是因为AQS是被设计来支持多种用途的，如果定义抽象方法，则子类在继承时必须要覆写所有的抽象方法，这显然是不合理的。所以AQS将一些需要子类覆写的方法都设计成protect方法，将其默认实现为抛出UnsupportedOperationException异常。如果子类使用到这些方法，但是没有覆写，则会抛出异常；如果子类没有使用到这些方法，则不需要做任何操作。</p>
</blockquote>
<p>全部使用 protected 方法也是抽象类的设计方法之一。</p>
<p>AQS 并不是最初的基类，它能够被 Thread Own 这个特性，来自于 AbstractOwnableSynchronizer。它对 Own 的表达方式在于保存一个线程句柄-exclusiveOwnerThread。和锁（Monitor）的markword里保留一个对象头的设计思路是很相似的。</p>
<p>AQS 提供两种模式：</p>
<ul>
<li>独占 exclusive（这是<strong>缺省模式</strong>）：当以独占模式获取时，尝试通过其他线程获取不能成功。<code>When acquired in exclusive mode, attempted acquires by other threads cannot succeed.</code></li>
<li>共享 share：共享模式通常会成功，但实际上不一定。<code>Shared mode acquires by multiple threads may (but need not) succeed.</code>这和其他提供共享锁机制的软件实现（如 MySQL）还是不一样的。当共享模式获取成功时，下一个等待线程（如果存在）也必须确定它是否也可以获取-<strong>也就是说阻塞是决定后的结果</strong>。 <code>when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as well.</code></li>
</ul>
<p><strong>重要</strong>：<strong>在不同模式下等待的线程共享相同的FIFO队列</strong>（互斥和共享模式都需要addWaiter）。实现子类只支持这些模式之一，但是两者都可以在ReadWriteLock中发挥作用（所以同一个 FIFO 队列是实现读写锁混合的基石） 。仅支持独占或仅共享模式的子类不需要定义支持未使用模式的方法。</p>
<p>在四大 try 方法中，tryAcquire()，tryRelease()，tryReleaseShared() 都返回 boolean，只有 tryAcquireShared() 返回数字。</p>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">《一行一行源码分析清楚AbstractQueuedSynchronizer》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016058789">《Java多线程》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">《从ReentrantLock的实现看AQS的原理及应用》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">《不可不说的Java“锁”事》</a></li>
<li><a target="_blank" rel="noopener" href="http://itmyhome.com/java-api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#nested_class_summary">《官方文档的中文翻译》</a></li>
</ol>
<h3 id="treiber-stack-原理简介">Treiber Stack 原理简介</h3>
<p>在深入 AQS 之前，有必要了解一个重要的无锁数据结构——<strong>Treiber Stack</strong>。它是理解 AQS 中 CAS 操作和链表指针更新的基础。</p>
<p><strong>Treiber Stack</strong> 是 R. Kent Treiber 在 1986 年提出的一种无锁并发栈，使用 CAS 操作实现线程安全的 push 和 pop：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Treiber Stack - 无锁并发栈的经典实现</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 核心思想：</span><br><span class="hljs-comment"> * 1. 使用 AtomicReference 保存栈顶指针</span><br><span class="hljs-comment"> * 2. push/pop 操作通过 CAS 原子更新栈顶</span><br><span class="hljs-comment"> * 3. CAS 失败则重试（自旋），直到成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TreiberStack</span>&lt;E&gt; &#123;<br>    <span class="hljs-comment">// 栈顶指针，使用原子引用保证可见性和原子更新</span><br>    <span class="hljs-keyword">private</span> AtomicReference&lt;Node&lt;E&gt;&gt; top = <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicReference</span>&lt;&gt;();<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 入栈操作 - 将新元素压入栈顶</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * 时间复杂度：O(1) 平均，最坏情况下因竞争可能重试多次</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(E item)</span> &#123;<br>        Node&lt;E&gt; newHead = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>&lt;&gt;(item);  <span class="hljs-comment">// 创建新节点</span><br>        Node&lt;E&gt; oldHead;<br>        <span class="hljs-keyword">do</span> &#123;<br>            oldHead = top.get();             <span class="hljs-comment">// 读取当前栈顶</span><br>            newHead.next = oldHead;          <span class="hljs-comment">// 新节点指向旧栈顶</span><br>        &#125; <span class="hljs-keyword">while</span> (!top.compareAndSet(oldHead, newHead));  <span class="hljs-comment">// CAS 更新栈顶</span><br>        <span class="hljs-comment">// CAS 失败说明有其他线程修改了栈顶，需要重试</span><br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出栈操作 - 弹出栈顶元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> E <span class="hljs-title function_">pop</span><span class="hljs-params">()</span> &#123;<br>        Node&lt;E&gt; oldHead;<br>        Node&lt;E&gt; newHead;<br>        <span class="hljs-keyword">do</span> &#123;<br>            oldHead = top.get();             <span class="hljs-comment">// 读取当前栈顶</span><br>            <span class="hljs-keyword">if</span> (oldHead == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;                 <span class="hljs-comment">// 栈空</span><br>            &#125;<br>            newHead = oldHead.next;          <span class="hljs-comment">// 新栈顶为原栈顶的下一个</span><br>        &#125; <span class="hljs-keyword">while</span> (!top.compareAndSet(oldHead, newHead));  <span class="hljs-comment">// CAS 更新栈顶</span><br>        <span class="hljs-keyword">return</span> oldHead.item;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;E&gt; &#123;<br>        <span class="hljs-keyword">final</span> E item;<br>        Node&lt;E&gt; next;<br>        Node(E item) &#123; <span class="hljs-built_in">this</span>.item = item; &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>Treiber Stack 与 AQS 的关联</strong>：</p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;Treiber Stack&quot;
        A[单向链表] --&gt; B[CAS 更新头指针]
        B --&gt; C[失败重试]
    end
    
    subgraph &quot;AQS CLH Queue&quot;
        D[双向链表] --&gt; E[CAS 更新 tail/head]
        E --&gt; F[失败重试 + park]
    end
    
    A -.-&gt;|演进| D
    B -.-&gt;|相同思想| E
    C -.-&gt;|增强为| F</code></pre>
<table>
<thead>
<tr>
<th>特性</th>
<th>Treiber Stack</th>
<th>AQS CLH Queue</th>
</tr>
</thead>
<tbody>
<tr>
<td>链表类型</td>
<td>单向链表</td>
<td>双向链表</td>
</tr>
<tr>
<td>指针更新</td>
<td>CAS 更新 top</td>
<td>CAS 更新 head/tail</td>
</tr>
<tr>
<td>失败处理</td>
<td>纯自旋重试</td>
<td>自旋 + park 阻塞</td>
</tr>
<tr>
<td>遍历方向</td>
<td>只能从头到尾</td>
<td>可双向遍历</td>
</tr>
<tr>
<td>应用场景</td>
<td>简单的无锁栈</td>
<td>复杂的同步器框架</td>
</tr>
</tbody>
</table>
<p><strong>关键区别</strong>：</p>
<ul>
<li>AQS 使用<strong>双向链表</strong>是因为需要从尾部向前遍历来修正 <code>prev</code> 指针（在 <code>cancelAcquire</code> 中）</li>
<li>AQS 的 <code>next</code> 指针更新使用 CAS（类似 Treiber Stack），但 <code>prev</code> 指针可以容忍短暂不一致</li>
<li>AQS 在 CAS 失败后不是纯自旋，而是结合 <code>LockSupport.park()</code> 实现阻塞等待</li>
</ul>
<h3 id="aqs-的设计原则">AQS 的设计原则</h3>
<ul>
<li>Node 代表线程。atomic int state 代表锁状态（初始值为0），也就是并发理论里经常提到的临界资源本身，FIFO queue （分为 sync queue 和 wait queue ）是它的同步逻辑的基石（bias）。</li>
<li>依赖状态、队列和 CAS 操作来完成对同步机制的实现。
<ul>
<li>如果要涉及到出入队，操作的顺序大致上是：cas node wait status、sync queue 节点之间的enq 和 deque、管理 aqs 的状态（tryAcquir/tryRelease）。</li>
<li>AQS 自身的状态代表着锁的状态，这些状态都是 transient volatile 的，重点关注锁是被<strong>acquired 还是 released</strong> 。<strong>锁操作的实质就是对状态的维护</strong>。这其中又大量使用 CAS 操作，<strong>CAS操作是最轻量的并发处理动作</strong>。cas 会把操作分隔出两个部分：cas 以前做拥有权限的 if 比对，cas以后做其他成员-如在 AQS 里，主要是 exclusiveOwnerThread 的设值操作，这样就形成了原子性。
<ul>
<li><strong>CAS操作保证了同一个时刻，只有一个线程能修改成功</strong>，从而保证了线程安全，CAS操作基本是由Unsafe工具类的compareAndSwapXXX来实现的；CAS采用的是乐观锁的思想，<strong>因此常常伴随着自旋</strong>，如果发现当前无法成功地执行CAS，则不断重试，直到成功为止，自旋的的表现形式通常是一个<strong>死循环for(;;)</strong>。if 条件写得非常复杂，不易于拆解，而且有些 if 的约束是隐藏在内部的 cas 和自旋里的。有非常多的带有 side-effect 的 action，最终返回一个 boolean，可以被连续地 &amp;&amp; 在一个大括号里。大括号里把某个值设置为 true，意味着把最后一个 action 的返回值带出去。
<ul>
<li>加锁主要比对 state</li>
<li>解锁主要比对 owner thread</li>
<li>通过监控 API 可以查看：是否持有锁、是否有 contend、waitQueue的内容、syncQueue的内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Node 组成的链表代表了所有与锁相关的线程，我们有 sync queue 和 wait queue。
<ul>
<li>在 sync queue 里，头节点代表了拥有锁的线程，而链表的其他部分意味着阻塞队列（所以头指针可以是一个蓝色的node，而阻塞队列是一系列绿色的链表节点）
<ul>
<li>。队列遵循 FIFO 的原则（入队顺序为加锁顺序，从尾部入队），因此能够实现公平锁。
<ul>
<li>原始的<code>acquire</code>要求在队列里的 node，必须 predecessor 为 head 才能<code>tryAcquire</code>，这就实现了先进先出。</li>
<li><strong>公平锁意味着在<code>tryAcquire</code>实现的时候，要看看有没有 queued predecessor（表现为<code>hasQueuedPredeccesor()</code>（而不是<code>predecessor()</code>）方法返回 false，即这个节点）才能够 cas state，进而获取锁</strong>）。</li>
<li><strong>能够实现非公平锁是能够实现公平锁的基础</strong>。非公平锁在 tryAcquireLock 的 casState 之前，没有多余的 hasQueuedPredeccesor() 检查，所以公平锁是非公平锁画蛇添足的结果，非公平锁在 acquire 前面还套了一个很强的短路操作，在入队以前就猛抢，即很多人常说的插队。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Node 的 waitStatus 代表着线程-<strong>锁的等待状态（而不是锁的获取状态）</strong> ，如线程是否取消争抢线程的锁。AQS 内部大量使用 compareAndSetWaitStatus 来变更每个 node 和它的 predecessor 的状态
<ul>
<li>后节点是否在 sync queue 里 acquireQueued 里阻塞，要看前驱节点 ws。是否在 wait queue 里，要看本节点 ws。</li>
<li>通常是由后节点来更新前节点的 ws，自身的 ws 也会在某些情况下被自己的线程更新：
<ul>
<li>每一个 node 在 sync queue 和 wait queue 之间互换是要求在 0 和 CONDITION 之间互换的，在由本线程对本节点使用的。</li>
<li>每一个 node 被取消（主要是 acquireQueued 里发现了 failed）的时候会变成 CANCELLED，不管是自身求锁的时候发现被取消，还是被后继节点取消，或者被 signal 的流程取消。</li>
<li>每一个 node 会因为 next 的入队变成 SIGNAL。</li>
</ul>
</li>
</ul>
</li>
<li>Node 本身也有 next 和 prev，通常对 prev 的重新赋值可以直接用 =，但对 next 的赋值需要做 cas。有时候 set next 还需要考虑 next 自己的 ws。</li>
<li>线程自身还有 state，如 new、runnable 等。</li>
<li>所有的“同步属性”，都是某个类内部的非公开内部帮助类（如 ReentrantLock 内部的 abstract static class Sync）。</li>
<li>aqs 不实现任何 synchronization interface，其他同步器或者具体锁真正需要做的是**使用<code>acquireInterruptibly</code>等方法。**就锁的获取操作而言，子类必须重写<code>tryAcquire</code>方法。</li>
<li>各种 Sync 的标准格式应该是<code>Subclasses should be defined as non-public internal helper classes（非公共内部助手类） that are used to implement the synchronization properties of their enclosing class（封闭类）</code>。</li>
<li>序列化模式：此类的序列化仅存储底层原子整数维持状态，因此反序列化对象具有空线程队列（实现方法是，让链表的各种节点都被设置成<code>transient</code> 的）。 需要可序列化的典型子类将定义一个<code>readObject</code>方法，可以将其恢复为<code>readObject</code>时的已知初始状态。所有的状态都是 atomic 的，这些状态可以被序列化（有一些特定的成员变量被刻意设计成 transient的，如ownerThread），但 queue  通常不能直接被序列化，需要序列化器实现<code>readObject</code>方法才行。</li>
</ul>
<h4 id="简要记忆">简要记忆</h4>
<ol>
<li>互斥：改双入尾，放双出头</li>
<li>共享：初始设态，非0入尾，扣减出队，解放总是全解放。</li>
</ol>
<h3 id="aqs的五层结构">AQS的五层结构</h3>
<p><img src="AQS%E7%9A%84%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="AQS的五层结构"></p>
<blockquote>
<p>上图中有颜色的为Method，无颜色的为Attribution。</p>
<p>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</p>
<p>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</p>
</blockquote>
<h3 id="clh-queue">CLH queue</h3>
<p>CLH 是一种 lock queue，normally used for spinlocks，but here used for blocking synchronizers。</p>
<p>这个 ADT 的 basic tatic 是<code>holding some of the control information about a thread in the predecessor of its node</code>。即本节点是否需要被 SIGNAL（parked - signaled- unparked），是由前一个节点决定的。</p>
<p>A “status” field in each node keeps track of whether a thread should block.</p>
<p>一个 node 是不是需要 block 需要由 status field 决定。实际上一个 field 的 status 为 SIGNAL 必然导致它的 successor parked（形成 blocked）。</p>
<p>A node is signalled when its predecessor releases.</p>
<p>release 里会附带一个 unparked successor 操作，而第一个 acquire 的入队会让出队自动进入一个 for-loop，不断 tryAcquire。</p>
<p>The status field does NOT control whether threads are granted locks etc though.</p>
<p>线程求锁就是它成为队头，队头的 thread 本身为 null。真正 hold thread 的地方只剩下 exclusiveOwnerThread。</p>
<p>入队是作尾，出队是作头。被唤醒不一定得到锁-如果不是公平锁的话。</p>
<p>The “prev” links (not used in original CLH locks), are mainly needed to handle cancellation. If a node is cancelled, its successor is (normally) relinked to a non-cancelled predecessor.</p>
<p>prev 让这个链表变成双向的，主要是为了让 cancelled 的node 的 next 找到新的 predecessor。</p>
<p>next 的用意是为了让 a predecessor signals the next node to wake up by traversing next link to determine which thread it is. next 是可能有争议的，CLH 的算法的用意是在一个节点的 successor 看起来是 null 的时候，对 tail 进行回溯检查-见 unparkSuccessor 里面寻找 null 的方法，这是基于 tail 是 atomically updated 的假定。</p>
<p>CLH 的 head 最初就是 dummy 的，node 被设置为 head 的时候也会变成 dummy 的。</p>
<p>Threads waiting on Conditions use the same nodes, but use an additional link. Conditions only need to link nodes in simple (non-concurrent) linked queues because they are only accessed when exclusively held.  Upon await, a node is inserted into a condition queue.  Upon signal, the node is transferred to the main queue.  A special value of status field is used to mark which queue a node is on.</p>
<p>condition 有一个单独的 condition queue，和 main queue 使用同一批节点，但使用 additional link。</p>
<p><img src="CLH%E5%8F%98%E4%BD%93%E9%98%9F%E5%88%97.png" alt="CLH变体队列"></p>
<h3 id="互斥框架的标准伪代码">互斥框架的标准伪代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 所以 tryAcquire 可以用非阻塞实现阻塞，tryAcquire 是一切 aqs 操作的灵魂</span><br><span class="hljs-comment">// 1. 试获取（改 state 和ownerThread）2. 入队</span><br>Acquire:<br>    <span class="hljs-comment">// 自旋带来阻塞，没有 sleep，这里就没有引入 clh 的 block</span><br>    <span class="hljs-keyword">while</span> (!tryAcquire(arg)) &#123;<br>     enqueue thread <span class="hljs-keyword">if</span> it is not already queued;<br>        possibly block current thread;<span class="hljs-comment">// 可以 block 也可以不 block，要看入队以后第二次 tryAcquire 的结果，以及 predecessor 的 waitStatus</span><br>    &#125;<br><br>Release:<br><span class="hljs-comment">// 1.试释放（改 state 和ownerThread）2. 尝试唤醒 successor，不需要出队，因为作为头部就已经算是出队了</span><br> <span class="hljs-keyword">if</span> (tryRelease(arg))<br>        <span class="hljs-comment">// 尝试唤醒，这里的伪代码实际上漏掉了实现中存在的 unpark</span><br>        unblock the first queued thread;<br><br><span class="hljs-comment">// 锁的调用模式：</span><br>somelock.lock()<br><br><span class="hljs-comment">// 有的 lock 会有 sync.lock() 的设计（如 ReentrantLock 的 UnfairSync），通过这一层再 delegate 到 acquire，lock 里面会有一个短路的 tryAcquire 操作。这足以证明 tryAcquire 不一定和 CLH 机制有关</span><br>sync.acquire(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<h3 id="node-的实现">Node 的实现</h3>
<p><img src="Node%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="Node的结构"></p>
<p>构造器，一个是需要 waitStatus，一个需要 nextWaiter，但都需要 Thread。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Link to the successor node that the current node/thread</span><br><span class="hljs-comment"> * unparks upon release. Assigned during enqueuing, adjusted</span><br><span class="hljs-comment"> * when bypassing cancelled predecessors, and nulled out (for</span><br><span class="hljs-comment"> * sake of GC) when dequeued.  The enq operation does not</span><br><span class="hljs-comment"> * assign next field of a predecessor until after attachment,</span><br><span class="hljs-comment"> * so seeing a null next field does not necessarily mean that</span><br><span class="hljs-comment"> * node is at end of queue. However, if a next field appears</span><br><span class="hljs-comment"> * to be null, we can scan prev&#x27;s from the tail to</span><br><span class="hljs-comment"> * double-check.  The next field of cancelled nodes is set to</span><br><span class="hljs-comment"> * point to the node itself instead of null, to make life</span><br><span class="hljs-comment"> * easier for isOnSyncQueue.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> Node next;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Link to predecessor node that current node/thread relies on</span><br><span class="hljs-comment"> * for checking waitStatus. Assigned during enqueuing, and nulled</span><br><span class="hljs-comment"> * out (for sake of GC) only upon dequeuing.  Also, upon</span><br><span class="hljs-comment"> * cancellation of a predecessor, we short-circuit while</span><br><span class="hljs-comment"> * finding a non-cancelled one, which will always exist</span><br><span class="hljs-comment"> * because the head node is never cancelled: A node becomes</span><br><span class="hljs-comment"> * head only as a result of successful acquire. A</span><br><span class="hljs-comment"> * cancelled thread never succeeds in acquiring, and a thread only</span><br><span class="hljs-comment"> * cancels itself, not any other node.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> Node prev;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Link to the successor node that the current node/thread</span><br><span class="hljs-comment"> * unparks upon release. Assigned during enqueuing, adjusted</span><br><span class="hljs-comment"> * when bypassing cancelled predecessors, and nulled out (for</span><br><span class="hljs-comment"> * sake of GC) when dequeued.  The enq operation does not</span><br><span class="hljs-comment"> * assign next field of a predecessor until after attachment,</span><br><span class="hljs-comment"> * so seeing a null next field does not necessarily mean that</span><br><span class="hljs-comment"> * node is at end of queue. However, if a next field appears</span><br><span class="hljs-comment"> * to be null, we can scan prev&#x27;s from the tail to</span><br><span class="hljs-comment"> * double-check.  The next field of cancelled nodes is set to</span><br><span class="hljs-comment"> * point to the node itself instead of null, to make life</span><br><span class="hljs-comment"> * easier for isOnSyncQueue.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> Node next;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Marker to indicate a node is waiting in shared mode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Marker to indicate a node is waiting in exclusive mode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br>&#125;<br><span class="hljs-comment">// SHARED 和 EXCLUSIVE 其实是用来指向 nextWaiter 的，这里隐含一个假设，非互斥获锁的前提下不需要使用条件变量，缺省情况下 EXCLUSIVE 才是 null</span><br>Node(Thread thread, Node mode) &#123;     <span class="hljs-comment">// Used by addWaiter</span><br>    <span class="hljs-built_in">this</span>.nextWaiter = mode;<br>    <span class="hljs-built_in">this</span>.thread = thread;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="锁">锁</h3>
<h4 id="加锁">加锁</h4>
<p>求锁的过程里，得到锁的线程会被记录在 aqs 的成员里，而得不到锁的线程会把 aqs 作为 blocker 记在自己的对象里。</p>
<h5 id="clh-主框架">CLH 主框架</h5>
<p><strong>AQS acquire 整体流程图</strong>：</p>
<pre><code class="hljs mermaid">flowchart TD
    A[acquire 开始] --&gt; B&#123;tryAcquire?&#125;
    
    B --&gt;|成功| Z[获取锁成功&lt;br/&gt;直接返回]
    B --&gt;|失败| C[addWaiter&lt;br/&gt;创建节点并入队]
    
    C --&gt; D[acquireQueued&lt;br/&gt;自旋获取锁]
    
    subgraph &quot;acquireQueued 循环&quot;
        D --&gt; E&#123;前驱是 head?&#125;
        E --&gt;|是| F&#123;tryAcquire?&#125;
        F --&gt;|成功| G[setHead&lt;br/&gt;出队成功]
        F --&gt;|失败| H[shouldParkAfterFailedAcquire&lt;br/&gt;设置前驱 SIGNAL]
        E --&gt;|否| H
        H --&gt; I&#123;需要 park?&#125;
        I --&gt;|是| J[parkAndCheckInterrupt&lt;br/&gt;阻塞等待]
        I --&gt;|否| D
        J --&gt;|被唤醒| K&#123;被中断?&#125;
        K --&gt;|是| L[记录中断状态]
        K --&gt;|否| D
        L --&gt; D
    end
    
    G --&gt; M&#123;曾被中断?&#125;
    M --&gt;|是| N[selfInterrupt&lt;br/&gt;重设中断标志]
    M --&gt;|否| Z
    N --&gt; Z
    
    style Z fill:#90EE90
    style J fill:#FFB6C1</code></pre>
<p><strong>关键方法职责</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>职责</th>
<th>返回值含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>tryAcquire</code></td>
<td>尝试获取锁（CAS state）</td>
<td>true=成功，false=失败</td>
</tr>
<tr>
<td><code>addWaiter</code></td>
<td>创建节点并加入队尾</td>
<td>新创建的节点</td>
</tr>
<tr>
<td><code>acquireQueued</code></td>
<td>自旋+阻塞获取锁</td>
<td>true=曾被中断，false=未被中断</td>
</tr>
<tr>
<td><code>shouldParkAfterFailedAcquire</code></td>
<td>判断是否需要阻塞</td>
<td>true=需要 park</td>
</tr>
<tr>
<td><code>parkAndCheckInterrupt</code></td>
<td>阻塞并检查中断</td>
<td>true=被中断唤醒</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 走完第一步走第二步，第一步求锁成功改状态和线程-这是被包裹在一个原子操作里的，如果不成功走到第二步，让 acquire 这个操作入队，用 node 来管理线程。</span><br><span class="hljs-comment">     * 这一步就实现了通过 cas 把前条件和后操作分隔开来，acquireQueued 本身是阻塞的，出来才会需要做 selfInterrupt 的重置</span><br><span class="hljs-comment">     * Node.EXCLUSIVE 是一个 null，而 Share 是一个平凡的 empty Node 单例，所以先实现出来的 condition queue（而不是 CLH queue）是 exclusive 的</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;<br>     <span class="hljs-comment">// 这个 selfInterrupt 是唤醒以后使用的。入队是在 addWaiter 做的，自旋-唤醒-检查能否 tryAcquire 出队 - 继续 park 是在 acquireQueued 里做的</span><br>     selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>acquire 最复杂，aqs 自己实现了，最好不要覆写，所以一般设计 sync 都是从外部和 tryAcquire 入手（重点：tryAcquire 是非 CLH queue 的部分，只是对 state 和 ownerThread 的原子操作，易于覆写。而 CLH 队列的出队入队是 AQS 自身的标准套路，不需要覆写，覆写会造成破坏）。在 AQS 里，tryAcquire 默认的实现是空。</p>
<p>阻塞主要靠的是 tryAcquire(1) 以后的入队操作。</p>
<h6 id="tryacquire">tryAcquire</h6>
<p>tryAcquire 通常是交给具体的lock实现的：cas 本身的 state，修改 ownerThread 是在这一层做的。甲骨文推荐的一个特别简单的实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == arg;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 这两步无锁放在一起，也算原子了，因为只有一个线程的 cas能走进来，不考虑线程中断的问题</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, arg)) &#123;<br>        setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个实现过于简单，以至于忽略了一个简单的问题，那就是，为什么这里没有累加呢？因为累加就要加上一个判定 volatile currentOwnerThread 是否等于 currentThread 的问题。所以问题又变成为什么没有对 currentOwnerThread 的检查呢？所以 ReentrantLock 的实现里是会针对互斥 owner 提出判断分支的。</p>
<h6 id="addwaiter">addWaiter</h6>
<p>这是一个 aqs 自身的成员方法，会生成一个节点，加入到自身的队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 每一个node 天然出现的时候，自己的 next 都是 mode 参数本身，tail 的next 是 mode</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// 最快入队的方法是在把新节点的 pred 设置成队尾，所以 FIFO 的 I 指的是对 tail 的追加</span><br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-comment">// 如果存在队尾-此时这不是一个空链表，否则必定走入一个 enq</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 先设置 node 的 prev，在并发入队时，会有多个 node 的 prev 设置为 pred</span><br>        node.prev = pred;<br>        <span class="hljs-comment">// 这一步的实现，是把当前 aqs 的 tail 节点设置为新的 node，之前的 tail 的 prev 本身是不变的</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            <span class="hljs-comment">// 然后把老 tail 的 next 设置为本 node，只有成功通过 cas 的 node 能够得到 pred 的next，其他节点还维持错误的 prev</span><br>            pred.next = node;<br>            <span class="hljs-comment">// 然后就可以从快路线返回了，此处返回的是 node 本身</span><br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 进入这里的 node 的 prev 还是错的，在这一步返回的 node 是 alreadyLinked 了的，注意，这个方法返回的不是node本身，而是它的前驱</span><br>    enq(node);<br>    <span class="hljs-comment">// 然后就算入队成功，可以返回了</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在外面虽然有一个 enqued 的操作，但实质上对 tail 的修改-也就是入队，是被收敛到 enq(node) 这个方法调用里的，这一个 addWaiter 方法里完成了全部的入队操作。</p>
<h6 id="enq">enq</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node to insert</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> node&#x27;s predecessor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-comment">// 无限循环，直到能够返回一个 t 为止，enq 的存在是为了实现一个多线程 for 循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 因为 tail 为空 head 必为空，所以此处用局部变量来节省性能，使用链表的基本法则之一是，在一轮操作里会被修改的变量，要被提前存起来</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-comment">// 在 for 循环里，只会进入这一步一次</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-comment">// 设计一个空的队头，然后把本 aqs 的 head 设置为 tail。注意，这个链表的第二个节点可能是抢不到锁的，但执行 enq 的时候，实际上前一个节点已经把锁释放了，所以此处可能遇到一个无头队列，如果无头，则初始化 tail 和 head</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                <span class="hljs-comment">// 这里隐藏一个设定，就是 head 和 tail 只要有一个为空，就全部为空。上一个 cas已经卡住其他操作，这里的操作就不用 cas，直接 set 即可</span><br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这一段代码就是外部代码的一部分，只不过移到一个 for loop 里来，这一段是无 sleep 和无 park 的自旋 + 一个初始化链表的操作</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>            <span class="hljs-comment">// 如果 cas 失败，则下一轮的 node.prev 会被覆写</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="acquirequeued">acquireQueued</h6>
<p>这个方法提供了一个内部的自旋和 park 和从 unpark 中醒来的全部流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Acquires in exclusive uninterruptible mode for thread already in</span><br><span class="hljs-comment">     * queue. Used by condition wait methods as well as acquire.</span><br><span class="hljs-comment">     * 我们可以先姑且认为，这个方法是一个极度特殊版本的 acquire。</span><br><span class="hljs-comment">     * 是在互斥且不可中断模式下（与之相对地是 doAcquireShared，本方法也可以被叫做 doAcquireExclusive）</span><br><span class="hljs-comment">     * share 和 interruptibly 是两个维度</span><br><span class="hljs-comment">     * 每一个节点进入queue的顺序是这样的：</span><br><span class="hljs-comment">     * 1. 先看看自己是不是 head 后的第一个node（此处不分公平锁还是不公平锁）或者尝试获取锁（此处可能是为了预防并发，这意味着 pred 可能是被污染的），如果是的话，带着 interrupted 返回</span><br><span class="hljs-comment">     * 2. 检查 pred 的状态 ws：</span><br><span class="hljs-comment">     *    2.1  ws 此时是 SIGNAL，意味着上次已经设值过了，此节点需要做的就是 park，等待进入下一循环，如果下次循环还是求不到锁，前节点的 SIGNAL不变，总是能够不断地被 park，unpark。在此直接返回</span><br><span class="hljs-comment">     *    2.2 如果 ws 此时是 CANCELLED，寻找一个新的 pred（做 pred 收窄），但不去碰新 pred 的状态</span><br><span class="hljs-comment">     *    2.3 尝试把它设置为 SIGNAL</span><br><span class="hljs-comment">     *    2.4  2.2 和 2.3 会直接导致 false 退出，然后进入下一轮的求锁循环，下一轮循环开始时，pred 的节点终究会是 SIGNAL，然后就可以 park 了</span><br><span class="hljs-comment">     * 所以 CLH queue 本质上是1 入队，2 获锁，3 检查 pred，park等唤醒 唤醒检查 interrputed 或者设置 pred 但不park，4 再进入 for 循环尝试2获锁（还没有 release），一旦获取锁就带着 interrupted 离开自旋的一种结构</span><br><span class="hljs-comment">     * 所有的 bloking queue 的轮询等待，都在这里通过 for loop park 来实现</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arg the acquire argument 这个参数主要是递归调用 tryAcquire 时用的</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if interrupted while waiting</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-comment">// 一开始会预设失败</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 一开始会预设未被中断</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 阻塞由两部分组成，一部分是这里的 for 循环，一部分是下面的检查 park</span><br>            <span class="hljs-comment">// 每次进入第一部分都先尝试获锁</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-comment">// node 在循环里是不会变的，每个循环里都只取 node 的前置</span><br>                <span class="hljs-comment">// 注意，阻塞队列不包含 head 节点，head 一般指的是占有锁的线程，head 后面的才称为阻塞队列。这个方法在需要 npe 检查的时候会代替成员指针拿出来用</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-comment">// 如果它的前驱为 head-就是获取锁的当前线程（前驱为 head，意味着本 node 前面已经没有节点了，也就意味着这是出队方法），则尝试获取锁-acquireQueued 外部是由 tryAcquire 开头的，自己也是由 tryAcquire 结尾</span><br>                <span class="hljs-comment">// 历史上第一个 head 其实是一个空 node（根据懒加载原理），如果本 node 后入队发现自己是阻塞队列的第一个节点，则还要再尝试 tryAcquire 一下</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    <span class="hljs-comment">// 如果获锁成功，则把本节点设置为头，头就是这样被替代的，头就意味着出队的线程。            </span><br>                    setHead(node);<br>                    <span class="hljs-comment">// 此时本 node（也就是 head）不一定是 tail，因为在这个 for 循环里，可能有其它线程 link 过本 node 了</span><br>                    <span class="hljs-comment">// 但 p 本身是“前一个 head”，新老交替的结果就是把 p 和 node 做一个 unlink</span><br>                    <span class="hljs-comment">// 这两步把 head 做了一个出队</span><br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// interrupted 为true 或者 false 都可能退出这个队列，这一步是一定会跑到的，而 interrupted 可能被上一轮循环的尾部给修改了</span><br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-comment">// 如果在上面一步没有返回，则没有产生收窄出队的效应。在这一步就会产生判定是不是要 park 以及实际 park 操作了</span><br>                <span class="hljs-comment">// 第一个条件检查状态机，看看是不是 shouldPark</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) <br>                    <span class="hljs-comment">// 第二个条件用 park 来实现阻塞，这个 park 就是 waiting queue 的实质了</span><br>                    &amp;&amp; parkAndCheckInterrupt())<br>                    <span class="hljs-comment">// 理论上被中断唤醒以后会进入这里，重新设计中断位（因为底层清了，这里有些多此一举），否则也可能 interrupted 为 false 退出这里</span><br>                    <span class="hljs-comment">// 这一步是可能被跑到，但大部分时候跑不到的</span><br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                <span class="hljs-comment">// 注意，这里是在 for循环之外的一个兜底措施，上面的 for循环本身只有求到锁以后的 return 退出方法，这里是为了预防异常，在求锁过程中遇到异常，要直接清掉这个节点，这意味着这个 node 在 acquire 操作下无法进入正常的状态</span><br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的复杂之处在于，理解 pred/next 的复杂性，和 waitStatus 对 AQS 工作流程的间接影响。</p>
<p><img src="acquireQueued%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="acquireQueued的实现"></p>
<h6 id="sethead">setHead</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets head of queue to be node, thus dequeuing. Called only by</span><br><span class="hljs-comment"> * acquire methods.  Also nulls out unused fields for sake of GC</span><br><span class="hljs-comment"> * and to suppress unnecessary signals and traversals.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHead</span><span class="hljs-params">(Node node)</span> &#123;<br>    head = node;<br>    <span class="hljs-comment">// 在这里只从 node 视角进行操作，node.prev.next 的 unlink 操作留给外部的 node.prev 自己做</span><br>    <span class="hljs-comment">// 获取锁以后，算是出了 waiting-set 了，本 node 只是给 aqs 管理队列用，所以解除了对 thread 的引用，防止 thread 不能被回收</span><br>    <span class="hljs-comment">// 这个 node hold thread 和 status 都不算让 thread hold lock，node as head 算是让 thread 加了锁</span><br>    node.thread = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// head 不应该有 prev 的，因为这不是循环链表</span><br>    node.prev = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的关注点是：node 是dummy 的，要清空自身状态。</p>
<h6 id="shouldparkafterfailedacquire">shouldParkAfterFailedAcquire</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Checks and updates status for a node that failed to acquire.</span><br><span class="hljs-comment"> * Returns true if thread should block. This is the main signal</span><br><span class="hljs-comment"> * control in all acquire loops.  Requires that pred == node.prev.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pred node&#x27;s predecessor holding status</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if thread should block</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-comment">// 这个状态机很有意思，这意味着我们的每一个 node 的实际状态是应该由前一个node（即 pred）来决定的</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-comment">// 前一个节点的 SIGNAL 状态，意味着后一个线程的 unpark。</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * This node has already set status asking a release</span><br><span class="hljs-comment">         * to signal it, so it can safely park.</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-comment">// 被 signal 以后反而会触发 park。这里的 signal 指的是 asking a release to signal it，通过 park 来等 unpark 来进入下一个循环的入口</span><br>         <span class="hljs-comment">// 通常我们要进入队列就是要 park 的。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 这里的大于零此时专指 CANCELLED，以后 cancelled 类的状态都必须大于零（反过来也一样）</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">         * indicate retry.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 链表自动做一个小的收窄，所有的 cancelled 线程要排出本链表，这里是自动把本 node 的prev跳了一下，为什么不会有并发问题安全问题还是不太容易看明白</span><br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 缩进玩</span><br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 这里引入了一个对状态机的隐式推导，可读性不太好。作者断言，此处要么是 0，要么是 PROPAGATE。CONDITION 也就是 -2 不会进入这个方法，因为 CONDITION 在另一个队伍里</span><br><span class="hljs-comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">         * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">         * 此时我们需要一个 signal，但还不需要 park</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-comment">// 否则尝试将 pred 的status 置为 SIGNAL，这样下一轮循环的时候，就可以进入 park，然后等 unpark了</span><br>         <span class="hljs-comment">// 也就意味着，这个 CLH 里的队列的每个 node 都天然需要自己的前驱是 SIGNAL 才正常。最初入队的 thread addWaiter 的时候会初始化一个 dummy head，然后进入这里，把这个 head 设置为 Node.SIGNAL。然后下一轮循环进到这里来，会从上面的 return true 那里出去。等于每一个节点是由它的后继节点的 acquiredQueued() 的第一次 for loop 设置为 SIGNAL 的。</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-comment">// 本次检查先不park，不 park 则外部可能就直接进入下一轮循环，尝试抢锁，失败再看要不要 park</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个配置告诉我们几个已知事实：每个节点的 waitStatus 状态，在主流程里是由后面的排队的 next 的入队来触发变化的。</p>
<p><strong>AQS Node waitStatus 状态转换图</strong>：</p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; 初始化_0: new Node()
    
    初始化_0 --&gt; SIGNAL_负1: 后继节点入队&lt;br/&gt;shouldParkAfterFailedAcquire
    初始化_0 --&gt; CANCELLED_1: 获取锁异常/超时&lt;br/&gt;cancelAcquire
    初始化_0 --&gt; CONDITION_负2: 加入条件队列&lt;br/&gt;addConditionWaiter
    
    SIGNAL_负1 --&gt; 初始化_0: 成功唤醒后继&lt;br/&gt;unparkSuccessor
    SIGNAL_负1 --&gt; CANCELLED_1: 获取锁异常/超时
    
    CONDITION_负2 --&gt; 初始化_0: signal 转移到同步队列&lt;br/&gt;transferForSignal
    CONDITION_负2 --&gt; CANCELLED_1: 等待被中断&lt;br/&gt;transferAfterCancelledWait
    
    CANCELLED_1 --&gt; [*]: 节点被移除&lt;br/&gt;GC回收
    
    note right of 初始化_0
        waitStatus = 0
        新创建的节点默认状态
    end note
    
    note right of SIGNAL_负1
        waitStatus = -1
        表示后继节点需要被唤醒
    end note
    
    note right of CONDITION_负2
        waitStatus = -2
        节点在条件队列中等待
    end note
    
    note right of CANCELLED_1
        waitStatus = 1
        节点已取消，唯一的正数状态
    end note</code></pre>
<table>
<thead>
<tr>
<th>waitStatus 值</th>
<th>常量名</th>
<th>含义</th>
<th>触发场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>-</td>
<td>初始状态</td>
<td>新节点创建时</td>
</tr>
<tr>
<td>-1</td>
<td>SIGNAL</td>
<td>后继节点需要被唤醒</td>
<td>后继节点入队时设置前驱为 SIGNAL</td>
</tr>
<tr>
<td>-2</td>
<td>CONDITION</td>
<td>节点在条件队列中</td>
<td>await() 时创建条件节点</td>
</tr>
<tr>
<td>-3</td>
<td>PROPAGATE</td>
<td>共享模式下传播唤醒</td>
<td>releaseShared 时设置</td>
</tr>
<tr>
<td>1</td>
<td>CANCELLED</td>
<td>节点已取消</td>
<td>超时、中断、异常时</td>
</tr>
</tbody>
</table>
<p><img src="shouldParkAfterFailedAcquire.png" alt="shouldParkAfterFailedAcquire"></p>
<h6 id="parkandcheckinterrupt">parkAndCheckInterrupt</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 入队和每次 for 循环被唤醒抢不到锁，然后又需要 park，就会进入本方法 park 一次</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里需要关注的是this 作为 blocker 参数。</p>
<h6 id="cancelacquire">cancelAcquire</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Cancels an ongoing attempt to acquire.</span><br><span class="hljs-comment"> * 1. 设置本节点内部状态：status 和 thread</span><br><span class="hljs-comment"> * 2. 把本节点的前后节点做好 unsplice，意味着对出队做好准备</span><br><span class="hljs-comment"> * 3. 把本节点从 aqs 的视图里去掉，这里使用了一个二分法：区分是队尾和不是队尾</span><br><span class="hljs-comment"> * 4. 在这个方法里面我们有一个很重要的认知迭代：signal、cancel 和各式各样的 acquire 是存在 race condition 的，对于 ws、queue的头和尾都是需要 cas的。</span><br><span class="hljs-comment"> * 5. 尽量先找 pred，动力从 pred 来</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// Ignore if node doesn&#x27;t exist</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 清空本 node</span><br>    node.thread = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// Skip cancelled predecessors。因为 enq 效应存在，node.prev 不会为 null</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;<br>    <span class="hljs-comment">// 在这里也在做一个 prev 的覆盖，只管本废弃节点的 prev 即可，这里可能会存在一个并发问题，如果 pred 的 prev 本身同时也在修改，则 node.prev 会跟着这个 prev 修改变动。这种“越过”操作的本质是废弃不当的 prev，至于 pred.prev 是不是正常，那另当别论</span><br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)<br>        node.prev = pred = pred.prev;<br><br>    <span class="hljs-comment">// predNext is the apparent node to unsplice. CASes below will</span><br>    <span class="hljs-comment">// fail if not, in which case, we lost race vs another cancel</span><br>    <span class="hljs-comment">// or signal, so no further action is necessary.</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;<br><br>    <span class="hljs-comment">// Can use unconditional write instead of CAS here.</span><br>    <span class="hljs-comment">// After this atomic step, other Nodes can skip past us.</span><br>    <span class="hljs-comment">// Before, we are free of interference from other threads.</span><br>    node.waitStatus = Node.CANCELLED;<br><br>    <span class="hljs-comment">// 在这里只做一个逻辑二分，只解决是不是队尾的问题，不区分队中和队头，如果是队尾则不用管 node next</span><br>    <span class="hljs-comment">// If we are the tail, remove ourselves.</span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<br>        <span class="hljs-comment">// 尾节点不需要 next，直接清空，因为中间节点实际上都是 cancelled 的节点</span><br>        compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果要处理 next，也有两种思路：把 pred 的next link 和 本 node 的 next 连起来，或者直接unpark node 的 next，总之本 node 的 next 得到了很好的处理</span><br>        <span class="hljs-comment">// If successor needs signal, try to set pred&#x27;s next-link</span><br>        <span class="hljs-comment">// so it will get one. Otherwise wake it up to propagate.</span><br>        <span class="hljs-type">int</span> ws;<br>        <br>        <span class="hljs-comment">// pred 的节点自身是 SIGNAL 和 cas 成 SIGNAL 是等效的，这是 Doug Lea 的习惯</span><br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;<br>            ((ws = pred.waitStatus) == Node.SIGNAL ||<br>             (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;<br>            pred.thread != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;<br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// prev 是不怕有并发安全问题的，但 next 一定要使用 compareAndSetNext，也就是说 prev 寻址出错不要紧，但 next 寻址出错要紧，这是容易被忽略的</span><br>                compareAndSetNext(pred, predNext, next);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 不属于上面的情况，即 pread 是头或者 pred 的状态不为 signal（即使在 cas 设置过后）或者 pred 的线程为空，则对 succesor 进行 unpark 操作，所以 succesor unpark 不是常态</span><br>            unparkSuccessor(node);<br>        &#125;<br>        <span class="hljs-comment">// 清除完 prev，最后再清除 next，即本方法主要是对 next 负责，不对 pred 负责</span><br>        node.next = node; <span class="hljs-comment">// help GC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>队尾和不是队尾的流程太复杂了，要仔细看。</p>
<p><strong>cancelAcquire 完整流程图</strong>：</p>
<pre><code class="hljs mermaid">flowchart TD
    A[cancelAcquire 开始] --&gt; B&#123;node == null?&#125;
    B --&gt;|是| Z[直接返回]
    B --&gt;|否| C[node.thread = null&lt;br/&gt;清空线程引用]
    
    C --&gt; D[跳过已取消的前驱节点&lt;br/&gt;while pred.waitStatus &gt; 0]
    D --&gt; E[记录 predNext = pred.next]
    E --&gt; F[node.waitStatus = CANCELLED]
    
    F --&gt; G&#123;node == tail?&#125;
    
    G --&gt;|是 - 当前是尾节点| H[CAS 设置 tail = pred]
    H --&gt;|成功| I[CAS 设置 pred.next = null]
    H --&gt;|失败| Z
    I --&gt; Z
    
    G --&gt;|否 - 当前不是尾节点| J&#123;pred != head&lt;br/&gt;AND pred 状态有效&lt;br/&gt;AND pred.thread != null?&#125;
    
    J --&gt;|是 - 中间节点| K[获取 node.next]
    K --&gt; L&#123;next != null&lt;br/&gt;AND next.waitStatus &lt;= 0?&#125;
    L --&gt;|是| M[CAS 设置 pred.next = next&lt;br/&gt;跳过当前节点]
    L --&gt;|否| N[unparkSuccessor node&lt;br/&gt;唤醒后继]
    
    J --&gt;|否 - head 的后继| N
    
    M --&gt; O[node.next = node&lt;br/&gt;help GC]
    N --&gt; O
    O --&gt; Z
    
    style F fill:#FFB6C1
    style Z fill:#90EE90</code></pre>
<p><strong>三种场景对比</strong>：</p>
<table>
<thead>
<tr>
<th>场景</th>
<th>条件</th>
<th>处理方式</th>
<th>目的</th>
</tr>
</thead>
<tbody>
<tr>
<td>尾节点</td>
<td>node == tail</td>
<td>CAS 更新 tail，清空 pred.next</td>
<td>直接移除尾节点</td>
</tr>
<tr>
<td>中间节点</td>
<td>pred != head &amp;&amp; pred 有效</td>
<td>CAS 连接 pred.next → node.next</td>
<td>跳过当前节点</td>
</tr>
<tr>
<td>head 后继</td>
<td>pred == head 或 pred 无效</td>
<td>unparkSuccessor(node)</td>
<td>唤醒后继让其重新竞争</td>
</tr>
</tbody>
</table>
<p><img src="cancelledAcquire-%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%98%AF%E5%B0%BE%E8%8A%82%E7%82%B9.png" alt="cancelledAcquire-当前节点是尾节点"><br>
<img src="cancellAcquire-%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%98%AFhead%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9.png" alt="cancellAcquire-当前节点是head的后继节点"><br>
<img src="cancellAcquire-%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%98%AF%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.png" alt="cancellAcquire-当前节点是中间节点"></p>
<h5 id="公平锁与非公平锁">公平锁与非公平锁</h5>
<p><img src="%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%B5%81%E7%A8%8B1.png" alt="非公平锁流程1"><br>
<img src="%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%B5%81%E7%A8%8B2.png" alt="非公平锁流程2"></p>
<p><strong>非公平锁 vs 公平锁流程对比</strong>：</p>
<pre><code class="hljs mermaid">flowchart TD
    subgraph &quot;非公平锁 NonfairSync&quot;
        A1[lock 调用] --&gt; B1&#123;CAS state 0→1&lt;br/&gt;第一次抢劫&#125;
        B1 --&gt;|成功| C1[直接获取锁&lt;br/&gt;插队成功!]
        B1 --&gt;|失败| D1[acquire 1]
        D1 --&gt; E1[nonfairTryAcquire]
        E1 --&gt; F1&#123;state == 0?&#125;
        F1 --&gt;|是| G1&#123;CAS state 0→1&lt;br/&gt;第二次抢劫&#125;
        G1 --&gt;|成功| C1
        G1 --&gt;|失败| H1[入队等待]
        F1 --&gt;|否| I1&#123;是重入?&#125;
        I1 --&gt;|是| J1[state++]
        I1 --&gt;|否| H1
    end
    
    subgraph &quot;公平锁 FairSync&quot;
        A2[lock 调用] --&gt; D2[acquire 1]
        D2 --&gt; E2[tryAcquire]
        E2 --&gt; F2&#123;state == 0?&#125;
        F2 --&gt;|是| K2&#123;hasQueuedPredecessors?&lt;br/&gt;有人排队吗?&#125;
        K2 --&gt;|有| H2[入队等待]
        K2 --&gt;|没有| G2&#123;CAS state 0→1&#125;
        G2 --&gt;|成功| C2[获取锁]
        G2 --&gt;|失败| H2
        F2 --&gt;|否| I2&#123;是重入?&#125;
        I2 --&gt;|是| J2[state++]
        I2 --&gt;|否| H2
    end
    
    style C1 fill:#90EE90
    style C2 fill:#90EE90
    style H1 fill:#FFB6C1
    style H2 fill:#FFB6C1</code></pre>
<p>核心特征：贪婪，不放过任何插队机会。</p>
<ol>
<li>入口阶段（第一轮抢劫）</li>
</ol>
<ul>
<li>动作：线程调用 lock()。</li>
<li>行为：二话不说，直接尝试 CAS(0, 1)。
<ul>
<li>成功：运气爆棚，锁正好空闲，直接拿锁走人（插队成功）。</li>
<li>失败：锁被人占了，准备走正规流程 acquire(1)。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>尝试获取阶段（第二轮抢劫）</li>
</ol>
<ul>
<li>动作：进入 acquire() -&gt; tryAcquire() -&gt; nonfairTryAcquire()。</li>
<li>行为：在入队前，不死心地再看一眼锁的状态。
<ul>
<li>如果发现 state == 0（锁刚才瞬间释放了）：不管有没有人排队，直接再次尝试 CAS。
<ul>
<li>成功：又一次插队成功，拿锁走人。</li>
<li>失败：这次是真的没机会了。</li>
</ul>
</li>
<li>如果发现是自己持有的锁（重入）：计数器 state + 1，成功。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>入队与阻塞阶段（认命排队）</li>
</ol>
<ul>
<li>动作：调用 addWaiter(Node.EXCLUSIVE)。</li>
<li>行为：将自己封装成 Node 节点，追加到 AQS 等待队列（CLH 队列）的尾部。</li>
<li>阻塞：进入 acquireQueued() 自旋循环。
<ul>
<li>检查前驱节点是不是 Head？</li>
<li>是 Head -&gt; 再试一次 tryAcquire（注意：这里调用的还是非公平的 tryAcquire，万一此时又有新强盗来抢，可能会输）。</li>
<li>不是 Head 或抢失败 -&gt; 调用 LockSupport.park() 挂起自己，进入 WAITING 状态，等待被唤醒。</li>
</ul>
</li>
</ul>
<p>ReentrantLock 的 sync 的 lock 方法是抽象的，对公平锁和非公平锁来讲都是一个壳方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.lock();<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">// state == 0 此时此刻没有线程持有锁</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span><br>        <span class="hljs-comment">// 看看有没有前置的排队节点，这是 cas 前条件。这也是公平的</span><br>        <span class="hljs-comment">// 这个嵌套条件判断没有和外面的条件判断放在一起，算是一个可读性更好的表达。在这里我们要注意，很多场合会同时出现 pred 和 prev，把这两个词分开就不会出现 prev.prev 的读写问题了</span><br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>            <span class="hljs-comment">// 如果没有线程在等待，那就用CAS尝试一下（注意这里有一个并发处理问题），成功了就获取到锁了</span><br>            <span class="hljs-comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span><br>            <span class="hljs-comment">// 因为刚刚还没人的，我判断过了</span><br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            <span class="hljs-comment">// 这是 cas 后操作</span><br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>      <span class="hljs-comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span><br>    <span class="hljs-comment">// 这里不存在并发问题</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-comment">// 这里告诉我们，子类也可能传入错误的 acquire，这里要做防御性编程。这里允许等于0，这就要求 release 的时候要注意 release 操作的对称性</span><br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果到这里，说明前面的 if 和 else if 都没有返回 true，说明没有获取到锁，直接返回 false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意 FairSync 和 NoneFairSync 的区别一部分在 tryAcquire，acquire 的标准实现在 AQS 里是不需要实现的。</p>
<h6 id="关于公平锁：那些-反直觉-的地方">关于公平锁：那些“反直觉”的地方</h6>
<ul>
<li>反直觉一：非公平锁在绝大多数时候其实是“公平”的。
<ul>
<li>很多人以为非公平锁是“所有线程一拥而上随机抢”。</li>
<li>真相：非公平锁依然基于 AQS 的 FIFO（先进先出）队列。只有当一个新线程刚来请求锁，且恰好锁刚被释放的那个瞬间，它才有机会插队。如果没抢到，它依然要乖乖排队，且一旦入队，就必须按顺序等待，不能再插队了。</li>
</ul>
</li>
<li>反直觉二：公平锁可能会导致“全员受损”。
<ul>
<li>为了维护公平（严格按顺序唤醒），必须频繁地挂起和唤醒线程。这会导致大量的上下文切换（Context Switch），其开销可能比执行临界区代码本身还要大，导致整体系统吞吐量剧烈下降。</li>
</ul>
</li>
<li>反直觉三：绝对的时间公平是不存在的。
<ul>
<li>JVM 无法保证线程调度是绝对公平的。即使是公平锁，也只是保证“获取锁的顺序与入队顺序一致”，而无法保证“先请求的线程一定先入队”（因为入队动作本身也有并发竞争）。</li>
</ul>
</li>
</ul>
<h6 id="为什么非公平锁不需要复杂的非线性实现？">为什么非公平锁不需要复杂的非线性实现？</h6>
<p>因为只要允许“插队”，破坏了“先来后到”的规则，它在定义上就是“非公平”的了。保留底层的 <strong>FIFO 队列是为了保证兜底，防止大量线程饥饿（Starvation）</strong>，确保最终大家都能拿到锁，只是刚来的幸运儿能少排队而已。</p>
<h6 id="为什么非公平锁是缺省实现-且效率更高？">为什么非公平锁是缺省实现，且效率更高？</h6>
<p>核心原因在于：<strong>恢复一个被挂起的线程是非常慢的</strong>。</p>
<p>想象一个场景：</p>
<ol>
<li>线程 A 释放了锁。</li>
<li>AQS 决定唤醒队列头部的线程 B。</li>
<li>时间差（关键点）：从 A 释放锁，到 B 真正被 CPU 调度并运行，这中间有一段毫秒级的延迟（涉及到内核态/用户态切换、CPU 缓存重新加载等）。</li>
<li>在这段“空档期”，锁是空闲的！5</li>
<li>此时线程 C 刚好请求锁。</li>
</ol>
<ul>
<li>如果是公平锁：C 必须排队。CPU 空转，等待 B 醒来。</li>
<li>如果是非公平锁：C 发现锁没人在用，直接拿走执行。如果 C 执行得很快（比如只是 i++），它可能在 B 彻底醒来之前就已经执行完并释放锁了。</li>
</ul>
<p>结果：</p>
<ul>
<li>B 醒来后依然拿到了锁（或者稍微多等了一下）。</li>
<li>C 更是“白嫖”了一次执行机会。</li>
<li>整体吞吐量：在相同时间内，非公平锁多处理了一个 C 的请求。</li>
</ul>
<h6 id="关于公平锁-非公平锁的经典面试题">关于公平锁/非公平锁的经典面试题</h6>
<ol>
<li>ReentrantLock 和 synchronized 默认是公平还是非公平？
<ul>
<li>答：都是非公平。synchronized 偏向锁/轻量级锁/重量级锁的升级过程本身就是带有竞争和插队的，重量级锁底层 ObjectMonitor 的 EntryList 竞争也不保证顺序。</li>
</ul>
</li>
<li>什么情况下应该强制使用公平锁？
<ul>
<li>答：当持有锁的时间相对较长，或者业务上强烈要求“先来后到”的顺序（例如按顺序打印、按顺序处理请求），且不在乎吞吐量下降时。</li>
</ul>
</li>
<li>非公平锁会导致“线程饥饿”吗？如何解决？
<ul>
<li>答：理论上会，如果不断有新线程插队，队列里的线程可能一直等。但在 AQS 设计中，一旦插队失败进入队列，就只能排队，所以长期来看不会完全饿死，只是等待时间变数大。如果必须避免，请用公平锁。</li>
</ul>
</li>
<li>AQS 中 hasQueuedPredecessors() 的作用是什么？
<ul>
<li>答：这是公平锁判断“是否需要排队”的核心逻辑。如果队列不为空且头节点的后继不是当前线程，说明有人在排队，当前线程必须放弃 CAS，去排队。</li>
</ul>
</li>
<li>简述 ReentrantLock 非公平锁的加锁流程。</li>
</ol>
<ul>
<li>答：
<ul>
<li>CAS 尝试将 state 从 0 改为 1。成功则获锁。</li>
<li>失败则调用 acquire。</li>
<li>再次尝试非公平获取（tryAcquire），如果 state 为 0 直接 CAS，不看队列。</li>
<li>还失败，则封装成 Node 进入 AQS 队列排队挂起。</li>
</ul>
</li>
</ul>
<h4 id="解锁">解锁</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这一段代码是 ReentrantLock 里的，解锁也是一个抽象方法，跨公平锁和非公平锁</span><br><span class="hljs-comment"> * Attempts to release this lock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;If the current thread is the holder of this lock then the hold</span><br><span class="hljs-comment"> * count is decremented.  If the hold count is now zero then the lock</span><br><span class="hljs-comment"> * is released.  If the current thread is not the holder of this</span><br><span class="hljs-comment"> * lock then &#123;<span class="hljs-doctag">@link</span> IllegalMonitorStateException&#125; is thrown.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if the current thread does not hold this lock</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>解锁也依赖于壳方法。</p>
<h5 id="release">release</h5>
<p>release 也分双重，需要复写的只有 tryRelease，管理状态用这个方法不管公平不公平，统一 tryRelease + unparkSuccessor head</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span><br><span class="hljs-comment"> * more threads if &#123;<span class="hljs-doctag">@link</span> #tryRelease&#125; returns true.</span><br><span class="hljs-comment"> * This method can be used to implement method &#123;<span class="hljs-doctag">@link</span> Lock#unlock&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arg the release argument.  This value is conveyed to</span><br><span class="hljs-comment"> *        &#123;<span class="hljs-doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span><br><span class="hljs-comment"> *        can represent anything you like.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the value returned from &#123;<span class="hljs-doctag">@link</span> #tryRelease&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 这里的 tryRelease 的返回结果是是否完全释放的意思</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 这里的 != 0 就是 SIGNAl 的意思</span><br>        <span class="hljs-comment">// 只要/只有完全释放了 state 才唤醒 h 的继任者</span><br>        <span class="hljs-comment">// ws &gt; 0，h 取消了；ws &lt; 0，要么是 PROPAGATE，要么是 SIGNAL，从语义上来讲后继节点就是一个阻塞态。换言之，如果head是初始节点，则不需要 unpark 后继</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="tryrelease">tryRelease</h6>
<p>tryRelease 的返回值是值得关注的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-comment">// 减少可重入次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-comment">// 当前线程不是持有锁的线程，抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">// free 的意思是完全释放锁，不管 true/false，state 总是会被扣减掉的</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只有完全释放锁，才算 free，进入只执行一次的 post-free 流程。</p>
<h6 id="unparksuccessor">unparkSuccessor</h6>
<p>这个方法在 release 或者某个 node cancelled 的时候会被调用这个方法的难度在于，如何决定 successor。那些 timeout 的就不要了有时候 unparkSuccessor 的对象是 head，有时候是任意节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">     * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 把本 node 设置为非状态机的初始态</span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Thread to unpark is held in successor, which is normally</span><br><span class="hljs-comment">     * just the next node.  But if cancelled or apparently null,</span><br><span class="hljs-comment">     * traverse backwards from tail to find the actual</span><br><span class="hljs-comment">     * non-cancelled successor.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 从尾部开始遍历，直到要 unpark 的节点是尾部的第一个 waitStatus 为负数的 node</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-comment">// 找到即唤醒它</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// node 里持有 thread 的用意就是让外围的 lockSupport 来引用和 unpark</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="独占与共享">独占与共享</h4>
<p><img src="%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F.png" alt="独占模式与共享模式"></p>
<h3 id="条件">条件</h3>
<p>从 Doug Lea 的原始设计思路来讲，一个 Condition 是要引出一组多线程共用的 wait-set。它和锁的抽象实现了arbitrary lock 和 condition implementaion 的正交组合。</p>
<p>Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods. 在原始的 Java 锁机制里面，synchronized 被叫作 synchronized methods，而 condition 被叫作 monitor methods。</p>
<p>条件有很多种叫法，可以叫作 condition queue，也可以叫作 condition variable。一个线程的使用语序总是先 wait，然后再由外部 notify，又内外协同来实现对执行上下文的切换。</p>
<p>这种状态必须被锁保护，否则就会触发  IllegateMonitorStateException。这会导致 ConditionObject 的实现总是一个 lock implementation 的 inner class，相互持有引用。A Condition instance is intrinsically bound to a lock。</p>
<p>有一个 key property 就是，Condition 会  atomically releases the associated lock and suspends the current thread，也就是说 Thread 会从一种 waiting 切换到另一种 waiting。但是锁没了。恰如  Java 语言规范力图描述的那样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// 这个程序的意义告诉我们：如果两个条件变量是互斥的-即不同时为真，则可以实现环形的 wait 和 notify（即相互阻塞），而不会产生死锁</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedBuffer</span> &#123;<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span>  <span class="hljs-operator">=</span> lock.newCondition(); <br>     <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition(); <br>  <br>     <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>     <span class="hljs-type">int</span> putptr, takeptr, count;<br>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object x)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       lock.lock();<br>       <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">while</span> (count == items.length)<br>           notFull.await();<br>         items[putptr] = x;<br>         <span class="hljs-keyword">if</span> (++putptr == items.length) putptr = <span class="hljs-number">0</span>;<br>         ++count;<br>         notEmpty.signal();<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<br>       &#125;<br>     &#125;<br>  <br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       lock.lock();<br>       <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>           notEmpty.await();<br>         <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> items[takeptr];<br>         <span class="hljs-keyword">if</span> (++takeptr == items.length) takeptr = <span class="hljs-number">0</span>;<br>         --count;<br>         notFull.signal();<br>         <span class="hljs-keyword">return</span> x;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<br>       &#125;<br>     &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>理论上来讲，condition 能够提供某些原生 notify 不支持的行为，如：</p>
<ol>
<li>guaranteed ordering for notifications</li>
<li>not requiring a lock to be held when performing notifications</li>
</ol>
<p>往下我们会看到，这些可选的 notification feature 的实现，严重依赖于类似 Reentrantlock 里标准的 isHeldExclusive 的实现。</p>
<p>Condition 对象原生的 monitor 相关方法仍然是可以被使用的，只不过最好不要拿来用，因为它会搞混你对条件队列的理解。</p>
<p>因为 spurious wakeup 的存在，所以 condition 的 waiting 一定要在一个 loop 里面执行。当然，一个狭义的实现也可以不允许 spurious wakeup 的存在，这就会要求不遵循 platform 的默认模式。</p>
<p>条件等待有三种形式：</p>
<ol>
<li>interruptible waiting  会抛出中断异常</li>
<li>non-interruptible waiting 不会抛出中断异常</li>
<li>timed waiting</li>
</ol>
<p>不管采用哪种形式，从 await 中返回过来，这个线程要 guaranteed to hold this lock。</p>
<p>另外，在 Java 的设计里面，凡是抛出 InterruptedException，<a href="#aqs-%E4%B8%8E%E4%B8%AD%E6%96%AD">必定清空 interrupted state</a>。</p>
<h4 id="条件对象">条件对象</h4>
<p>条件对象仍然管理 Node，而且也是用头和尾的形式，不过这次的链表是个单链表。一般的 Lock 是用 Sync 来管理 lock，sync 作为 AQS 自己维护 node，用 ConditionObject 来管理condition，ConditionObject 自己管理 Node。照理来讲一个 lock 可以产生多个 condition object 线程可以通过 await 操作，进入多个队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;<br>    <span class="hljs-comment">// 条件队列的第一个节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br>    <span class="hljs-comment">// 条件队列的最后一个节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97.png" alt="条件队列"></p>
<p>我们可以看到，Node 仍然是AQS 的 node，但它们的 ws 是 Node.CONDITION。</p>
<h5 id="总结">总结</h5>
<p>大部分的换状态，放锁，部分的中断回再换状态回 sync queue，重新获锁，检查中断的流程都是在 await 中完成的；而 signal 中完成的只是主动的 transferForSignal，完成主动的 换状态回 sync queue 操作，和部分的唤醒。</p>
<h5 id="await">await</h5>
<ol>
<li>检查是否需要抛出中断异常。</li>
<li>在调用 await 相关方法的时候，线程先进入 wait queue。此时线程也不在 sync queue里了，因为获取锁才可以 await，获取锁的时候它已经是 sync queue 的 head 了。</li>
<li>调用 fullyRelease 方法，释放锁并把锁释放前的状态取出来。</li>
<li>在 wait queue 的自旋里检查 isOnSyncQueue。如果没有在同步队列里，自己 park，park 的 blocker 是 ConditionObject。每次从 park 中唤醒有两种可能：被 signal 内置的 unpark 唤醒，或者被中断唤醒。线程检查自己是不是被中断唤醒的，如果是被中断唤醒的，则自己 transfer 到 sync queue 里，设置 interrupt mode 然后退出；否则，它是被 signal 唤醒的，此时已经在 sync queue里了。自旋到下一阶段也会退出。</li>
<li>进入 wait queue 会把 ws 置为 condition，而进入 sync queue 则置为 0（等待 next 置为 SIGNAL），然后做好前后节点的 link。</li>
<li>调用 acquireQueued，引出在 sync queue 里的 park （park 的 blocker 是 AQS 自己）和自旋。</li>
<li>从 acquireQueued 返回真则本线程又是从中断中返回的，要确认上一步的 interrupt mode 是不是指示我们抛出异常，如果是则 interrupt mode 不变，否则设置 interrupt mode 为重新设置中断位。</li>
<li>看看本 node 的 next waiter 是不是 null，是的话 unlinkCancelledWaiters。</li>
<li>根据 interrupt mode 来让线程选择一种方式来设置自己的中断位。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock1.newCondition();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; &#123;<br>        lock1.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition.await();<br>            System.out.println(<span class="hljs-string">&quot;i am awaken&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock1.unlock();<br>        &#125;<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;TTTTT1&quot;</span>);<br>    t1.start();<br>    t1.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法值得一看的地方是，如果一个方法是长时间的阻塞的，它是不是对外声明自己要响应中断，如果要响应中断，则中断是无时无刻在发生的，它要怎么在多个地方响应中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 如果开始 await 之前线程已经被中断了，则直接显式地抛出异常。这里有一个 juc 的习惯，只要抛出异常必定清空中断位，反之亦然</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-comment">// 先入 wait queue 队伍</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <span class="hljs-comment">// 然后彻底释放锁，注意，此时其实线程也不在 sync queue里了，代表它的是头节点，所以这里只要清理 aqs 的state就行了，为了预防万一，我们先留存 savedState</span><br>    <span class="hljs-comment">// 这个设计是先冗余入队，然后再释放锁。这个方法表面上看起来没有做 isHeldExclusive 的检查，实际上在 tryRelease 的内部就会有，因为 tryRelease 是可选实现的，甚至 isHeldExclusive 也是可选实现的，所以条件在锁内被持有的设计规范是可以被破坏掉的</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 这里的 syncQueue 就是 CLH queue 里面非头的部分了，在这里就是自己 park，然后自旋</span><br>   <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        <span class="hljs-comment">// 注意，这里的 park 使用的 blocker 是 ConditionObject</span><br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">// 一旦从 unpark 中醒来，要做几件事，首先检查中断，如果中断，则由 await 来做 transfer queue的操作，走 park 内部的 transfer 流程（把 node 的节点置回0，然后 enq node，算是完成了 queue 之间的 transfer），如果走完就会从这里面 break，但如果不发生中断，而产生了 signal，signal 内部也会完成 enq，让 isOnSyncQueue 检测到自动退出而不是 break 退出</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 如果因中断退出，而不是 signal 退出，直接 break，不再校验是否在 SyncQueue</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// enq 完就进入 CLH 的 park了，savedState 保证归还的锁的累积数量仍然不变。当然，此处也不一定会触发 park，如果此时锁被完全 release 的话，可以直接求锁成功</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)       <br>        <span class="hljs-comment">// 这里要理解一个两次中断的事实：acquireQueued 中返回true，也意味着发生了中断，但这种中断必然发生在 signal 之后，如果前面发生过一次 wait 的中断，则此处就不重设中断位，否则此处要设置模式</span><br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 抛出异常或者自置中断位，也就是说，如果发生过基于 park 的中断，内部没有做过中断重设，此处需要做，这和 acquire 内部还要调用一次 selfInterrupt 是异曲同工的。park 和 interrupt 的关系就是这么复杂</span><br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="addconditionwaiter">addConditionWaiter</h6>
<p>这个方法的主要逻辑就是让本线程产生一个代表节点，然后入队：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;<br>    <span class="hljs-comment">// 在需要检查状态时，链表的 cancelled 节点总要被清掉</span><br>    <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    &#125;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="fullyrelease">fullyRelease</h6>
<p>这个方法依赖于 release 的实现，也会返回 savedState。但如果 release 失败太复杂了，作者在这里选择了直接抛出异常，令人意外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (release(savedState)) &#123;<br>            failed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> savedState;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            node.waitStatus = Node.CANCELLED;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="unlinkcancelledwaiters">unlinkCancelledWaiters</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlinkCancelledWaiters</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">trail</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> t.nextWaiter;<br>        <span class="hljs-comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span><br>        <span class="hljs-keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;<br>            t.nextWaiter = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (trail == <span class="hljs-literal">null</span>)<br>                firstWaiter = next;<br>            <span class="hljs-keyword">else</span><br>                trail.nextWaiter = next;<br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>                lastWaiter = trail;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            trail = t;<br>        t = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="isonsyncqueue">isOnSyncQueue</h6>
<p>检查这个 node 是否已经在 sync queue 里了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOnSyncQueue</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>) <span class="hljs-comment">// If has successor, it must be on queue</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * node.prev can be non-null, but not yet on queue because</span><br><span class="hljs-comment">     * the CAS to place it on queue can fail. So we have to</span><br><span class="hljs-comment">     * traverse from tail to make sure it actually made it.  It</span><br><span class="hljs-comment">     * will always be near the tail in calls to this method, and</span><br><span class="hljs-comment">     * unless the CAS failed (which is unlikely), it will be</span><br><span class="hljs-comment">     * there, so we hardly ever traverse much.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> findNodeFromTail(node);<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="isonsyncqueue">isOnSyncQueue</h6>
<p>如果中断，则做 queue transfer，如果不中断则返回 0，这里使用了内部类能够引用外部方法的闭包性质，可以用 enq 方法自动找到尾部。</p>
<p>这个方法的动词使用了现在进行时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// 不发生中断返回 0 最好，如果发生中断则要自己做 enq，而且根据 transfer 的结果告知外部是该抛出异常，还是自己重新设置中断位</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted() ?<br>        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :<br>        <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="transferaftercancelledwait">transferAfterCancelledWait</h6>
<p>这个方法是 await 内部的 transfer 方法之一（另一个在 signal 里）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法是给中断 CancelledWait 用的</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferAfterCancelledWait</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// 如果改变 ws成功，则应该抛出中断异常</span><br>    <span class="hljs-keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>)) &#123;<br>        enq(node);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 上面失败就意味着发生了一个 race condition，如果是 signal 赢了，则实际上不应该抛出异常</span><br><span class="hljs-comment">     * If we lost out to a signal(), then we can&#x27;t proceed</span><br><span class="hljs-comment">     * until it finishes its enq().  Cancelling during an</span><br><span class="hljs-comment">     * incomplete transfer is both rare and transient, so just</span><br><span class="hljs-comment">     * spin.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node))<br>        Thread.<span class="hljs-keyword">yield</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="reportinterruptafterwait">reportInterruptAfterWait</h6>
<p>使用一个常量作为 flag，就完成了从中断-flag-重新还原中断的全流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-type">int</span> interruptMode)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="signal">signal</h5>
<ol>
<li>检查 isHeldExclusively。</li>
<li>选一个非空的 firstWaiter，进行 signal。因为 ConditionObject 本身是跨多线程共享的，所以这会随机选取第一个 node 进行信号唤醒，把它从 CONDITION 置为 0，如果失败则返回 false。与之相对的，signalAll 是用 firstWaiter 开始，按顺序唤醒整个链表。<strong>AQS 的随机性在于不知道链表的顺序是怎样的，但对于 FIFO 的出队是不随机的</strong>。</li>
<li>enq node。</li>
<li>把前驱 cas 设置成 SIGNAL 失败或者前驱节点已经取消，尝试直接 unpark 这个 node。然后就让 await 方法的 isOnSyncQueue 走剩下的流程。</li>
<li>返回操作为 true。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注意看这个方法，只要 isHeldExclusively 不正常，则这个方法会抛出 IllegalMonitorStateException</span><br><span class="hljs-comment"> * Moves the longest-waiting thread, if one exists, from the</span><br><span class="hljs-comment"> * wait queue for this condition to the wait queue for the</span><br><span class="hljs-comment"> * owning lock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="hljs-doctag">@link</span> #isHeldExclusively&#125;</span><br><span class="hljs-comment"> *         returns &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 检查是不是在锁的控制范围内</span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-comment">// 只取非空 first 作为 doSignal 对象</span><br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>        doSignal(first);<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="dosignal">doSignal</h6>
<p>只有 signal 一个非零和非 cancelled 的 node 成功才会从循环中停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * Removes and transfers nodes until hit non-cancelled one or</span><br><span class="hljs-comment">         * null. Split out from signal in part to encourage compilers</span><br><span class="hljs-comment">         * to inline the case of no waiters.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> first (non-null) the first node on condition queue</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 首先用 frist.next 来顶掉 firstwaiter，如果 first.next 为空，则清空本队列</span><br>                <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>                    lastWaiter = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// unlink first 到 next waiter 的联系</span><br>                first.nextWaiter = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 如果 transferForSignal 成功，循环中止，否则必定是 node 被 cancelled 了，这时候要把 firstWaiter 赋值回 first，看看是不是还能找到 non-null 继续循环</span><br>            &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>                     (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>        &#125;<br>```    <br><br>###### transferForSignal<br><br>这个方法的主要目的是为了完成往 sync queue 的转移只要求 cas node 的状态为 <span class="hljs-number">0</span> 和对它进行 enq 只有在极端情况下才会做立即 unpark：AQS 有个设计，在 cancel 一个 node 以后，或者 一个 node 不正常了以后，会立刻 unpark 它的  successor 如果这个 unpark 没有被执行，unlock 的时候还会带有一个 unpark 来刺激 lock。<br><br>```java   <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br>    <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * If cannot change waitStatus, the node has been cancelled.</span><br><span class="hljs-comment">         * 假定，condition queue中的节点一定是 CONDITION，不会再变</span><br><span class="hljs-comment">         * 这是本方法第一次试图 cas 改变一个 node，其实此时如果失败，意味着本节点是 cancelled 的，应该返回 false</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="hljs-comment">         * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="hljs-comment">         * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="hljs-comment">         * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>        <span class="hljs-comment">// 如果前驱节点已取消，本 node 应该直接 unpark；或者前驱节点不能设置为 SIGNAL-此处不需要等到下轮循环再设置了，要把本 node 做一个 unpark，交给 await中的循环处理。</span><br>        <span class="hljs-comment">// 什么情况下 compareAndSetWaitStatus 会失败呢？p 是前驱节点的意思，p 被人动过，这也就意味着此处的 cas已经无意义了</span><br>        <span class="hljs-comment">// 这是第二个地方用 cas 检查 node 的前驱，如果失败，通过 unpark 让 acquiredQueued 来试图收窄链表</span><br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>            <span class="hljs-comment">// 注意，node.thread 已经在await 的循环里 park了，此处的 enq 帮那个循环省略了从中断中 enq 的动作，它会在 await 方法里进入 acquireQueued，再尝试求锁解锁，这种直接唤醒重新入队的方法，被作者称作 resync。</span><br>            LockSupport.unpark(node.thread);<br>        <span class="hljs-comment">// 但如果不 unpark，直接返回，则对于 node.thread 的 unpark 需要等到 unlock 底层的 release</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>关于 signal + unlock 带来的获锁，可以参考这个实验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConditionProcedure</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br><br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>        <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">controlFlag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            System.out.println(<span class="hljs-string">&quot;内线程先求锁&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (!controlFlag.get()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;check input failed, begin to await，准备释放锁&quot;</span>);<br>                        <span class="hljs-comment">// 在这一行里，内线程 fullyRelease 了 lock</span><br>                        condition.await();<br>                        <span class="hljs-comment">// 在这一行里，内线程重新拿回了 lock</span><br>                        System.out.println(<span class="hljs-string">&quot;signaled, begin to check input，重新得回锁&quot;</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>                System.out.println(<span class="hljs-string">&quot;isInterrupted: &quot;</span> + Thread.currentThread().isInterrupted());<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;);<br>        t1.setName(<span class="hljs-string">&quot;test-thread1&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">// 造成一种内线程先拿到锁，但释放后进入 wait queue 的情况</span><br>        Thread.sleep(<span class="hljs-number">1000L</span>);<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 在 idea 里暂时无法使用 prompt input，所以现阶段就用倒数计时来触发锁定</span><br><span class="hljs-comment">//            Scanner command = new Scanner(System.in);</span><br><span class="hljs-comment">//            System.out.println(&quot;Enter command: &quot;);</span><br><span class="hljs-comment">//            boolean running = true;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//            while(running)&#123;</span><br><span class="hljs-comment">//                switch(command.nextLine())&#123;</span><br><span class="hljs-comment">//                    case &quot;signal&quot;:</span><br><span class="hljs-comment">//                        System.out.println(&quot;Machine started!&quot;);</span><br><span class="hljs-comment">//                        running = false;</span><br><span class="hljs-comment">//                        break;</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//            command.close();</span><br><br>            controlFlag.set(<span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">// 这里会让内线程准备求锁</span><br>            System.out.println(<span class="hljs-string">&quot;让内线程准备求锁&quot;</span>);<br>            <span class="hljs-comment">// 要在锁里面执行 signal，其内部针对极端情况会触发 unpark，但那个unpark 只能触发 resync 入队用，如果本线程没有释放锁，则内线程求不到锁，会进入第二次 park</span><br>            condition.signal();<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 在这行彻底执行完的一瞬间，内线程求锁完，才能从 await 中退出，这会导致 unpark，await 内部至少会有一次 unpark 醒来，到时候无人争抢锁的话，会直接重新回到获锁（acquired）状态</span><br>            System.out.println(<span class="hljs-string">&quot;释放本线程的锁，下一瞬间内线程就会求到锁&quot;</span>);<br>            lock.unlock();<br>        &#125;<br><br>        Thread.sleep(<span class="hljs-number">15000L</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="aqs-与中断">AQS 与中断</h3>
<h4 id="两种中断模式">两种中断模式</h4>
<p>在 AQS 内部，把这两种中断模式归类为：</p>
<ul>
<li>REINTERRUPT：Mode meaning to reinterrupt on exit from wait，模式保留中断状态，让上层代码能感知到中断的发生：
<ul>
<li>这样做的好处是：
<ul>
<li>保持中断状态的完整性</li>
<li>允许上层代码检测到中断并作出相应处理</li>
<li>符合Java的中断机制设计理念：中断是一种协作机制，应该传播给调用链</li>
</ul>
</li>
<li>如果不恢复中断状态：
<ul>
<li>上层代码将无法感知到中断发生</li>
<li>可能会影响依赖中断状态的取消操作</li>
<li>违反了线程中断的传播机制</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 等待操作</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// 重新设置中断标志</span><br>    Thread.currentThread().interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>THROW_IE：Mode meaning to throw InterruptedException on exit from wait，通过异常直接通知上层代码中断的发生</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例处理方式</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 等待操作</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// 直接抛出异常</span><br>    <span class="hljs-keyword">throw</span> e;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="检测中断的标准方法">检测中断的标准方法</h4>
<p><strong>在阻塞方法里 catch InterruptedException/ClosedByInterruptException 和非阻塞流程轮询检查线程的中断状态</strong>是响应中断的方法：</p>
<ul>
<li>能检测到中断就是发生过中断</li>
<li>而不能检测到中断可能意味着中断位被重置了，用异常表达了中断-所以捕获了异常就需要重新中断。</li>
</ul>
<h4 id="非锁的计时waiting方法">非锁的计时waiting方法。</h4>
<p>Java 自带的内置长时间停顿方法有以下：</p>
<ul>
<li>Object：wait()、wait(long)、wait(long, int)，被中断的时候会抛出 <strong>InterruptedException</strong>，而且会<strong>清空</strong>中断位</li>
<li>Thread：join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)，被中断的时候会抛出 <strong>InterruptedException</strong>，而且会<strong>清空</strong>中断位</li>
<li>实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等，被中断的时候会抛出 <strong>ClosedByInterruptException</strong>，而且会<strong>设置</strong>中断位</li>
<li>Selector 中的 select 方法，被中断的时候会<strong>立即返回</strong>，而且会<strong>设置</strong>中断位</li>
</ul>
<h4 id="locksupport-park-的行为">LockSupport.park 的行为</h4>
<p>LockSupport.park 会响应中断-<strong>醒来</strong>，但通常会被java类库作者的自旋重新带进下一个 LockSupport.park ，但<strong>不会重置中断状态</strong>（对线程进行中断检查会得到  true，线程被 interrupt()的结果<strong>完全不会被 LockSupport.park 影响</strong>）。</p>
<h4 id="lock-与中断">lock 与中断</h4>
<p>AQS 在设计的时候，会设计普通 lock，lockInterruptibly() 的版本。在条件上，会设计 await 和 awaitUninterruptibly()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.lock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>普通 lock 是不会响应中断的阻塞操作的-对卡在 lock 上的线程进行 interrupt，在线程内部什么都不会发生。</p>
<p>在下面的实验里，我们从主线程，不断地中断另一个线程，另一个线程没有抛出异常，只有求到锁才从中断中返回，而且重置（reset，而不是 clear）了中断位，<strong>仿佛只有最后退出线程的那一刻，线程才被中断了</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个实验的问题是，无法复现求锁的子线程从被中断状态下退出的场景</span><br><span class="hljs-comment"> * 是不是只有从 os 层面干预线程，才能触发这一点？</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException 中断异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLockProcedure</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch1.await();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            System.out.println(<span class="hljs-string">&quot;isInterrupted: &quot;</span> + Thread.currentThread().isInterrupted());<br>        &#125;<br><br>        <span class="hljs-comment">// 用 while 而不是 sleep，这样就不怕 interrupt 被阻塞 api 抛出异常来响应了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            j += i;<br>        &#125;<br>        <span class="hljs-comment">// 返回累加结果，这样不会被死代码优化：704982704</span><br>        System.out.println(j);<br>        <span class="hljs-comment">// 在lock 内部可能检测不到这个中断，需要外部频繁中断为好</span><br>        Thread.currentThread().interrupt();<br><br>        <span class="hljs-comment">// 让系统在这个地方卡住，然后用 debugger 观察本线程的状态</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(String.format(<span class="hljs-string">&quot;from inside Thread.currentThread().getState(): %s, Thread&quot;</span><br>                            + <span class="hljs-string">&quot;.currentThread().isInterrupted(): %s&quot;</span>,<br>                    Thread.currentThread().getState(), Thread.currentThread().isInterrupted()));<br>            System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;test-thread1&quot;</span>);<br>    t1.start();<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>        countDownLatch1.countDown();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 休眠一段时间，让t1开始求锁，然后再解锁</span><br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>        &#125;<br>        <span class="hljs-comment">// 中断一千次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-comment">// 在这里频繁中断，如果t1内部这时候还在 sleep 就会抛出异常，所以t1内部只能循环</span><br>            t1.interrupt();<br>            StackTraceElement[] stackTrace = t1.getStackTrace();<br>            <span class="hljs-comment">// 只输出前两行堆栈信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">stackInfo</span> <span class="hljs-operator">=</span> stackTrace.length &gt;= <span class="hljs-number">2</span><br>                    ? stackTrace[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;\n&quot;</span> + stackTrace[<span class="hljs-number">1</span>]<br>                    : stackTrace.length == <span class="hljs-number">1</span> ? stackTrace[<span class="hljs-number">0</span>].toString() : <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-comment">// 我们不断检验线程状态，会得到结论：lock 内部是基于 park 的，中断不会清除让 lock 退出，中断可能会短暂让线程进入中断状态（只能在锁的外部短暂观察到），但是 lock</span><br>            <span class="hljs-comment">// 的自旋模式会让锁回到未中断状态-只有从锁里出来，才能在本线程内部看到正确的中断状态</span><br>            System.out.println(String.format(<span class="hljs-string">&quot;t1.getState(): %s, t1.isInterrupted(): %s, stackInfo: %s&quot;</span>,<br>                    t1.getState(), t1.isInterrupted(), stackInfo));<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">10000L</span>);<br>        lock.unlock();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="hljs-comment">         *         boolean failed = true;</span><br><span class="hljs-comment">         *         try &#123;</span><br><span class="hljs-comment">         *             boolean interrupted = false;</span><br><span class="hljs-comment">         *             for (;;) &#123;</span><br><span class="hljs-comment">         *                 final Node p = node.predecessor();</span><br><span class="hljs-comment">         *                 if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="hljs-comment">         *                     setHead(node);</span><br><span class="hljs-comment">         *                     p.next = null; // help GC</span><br><span class="hljs-comment">         *                     failed = false;</span><br><span class="hljs-comment">         *                     // 不管是否中断，都从这里 return</span><br><span class="hljs-comment">         *                     return interrupted;</span><br><span class="hljs-comment">         *                 &#125;</span><br><span class="hljs-comment">         *                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="hljs-comment">         *                     parkAndCheckInterrupt())</span><br><span class="hljs-comment">         *                      // 如果中断则跑到这，不然得到锁就保持 interrupted = false，然后从上面 return</span><br><span class="hljs-comment">         *                     interrupted = true;</span><br><span class="hljs-comment">         *             &#125;</span><br><span class="hljs-comment">         *         &#125; finally &#123;</span><br><span class="hljs-comment">         *             if (failed)</span><br><span class="hljs-comment">         *                 cancelAcquire(node);</span><br><span class="hljs-comment">         *         &#125;</span><br><span class="hljs-comment">         *     &#125;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *     public final void acquire(int arg) &#123;</span><br><span class="hljs-comment">         *         if (!tryAcquire(arg) &amp;&amp;</span><br><span class="hljs-comment">         *             acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="hljs-comment">         *             // 如果 acquireQueued 方法返回true，断点到这一行</span><br><span class="hljs-comment">         *             // 如果 while interrupt 循环足够多，是可以从这一步跑出去的</span><br><span class="hljs-comment">         *             selfInterrupt();</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *             // 否则断点到这一行即不做 selfInterrupt</span><br><span class="hljs-comment">         *     &#125;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *    private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="hljs-comment">         *         LockSupport.park(this);</span><br><span class="hljs-comment">         *         // 这是一个清理线程状态的 testMethod()</span><br><span class="hljs-comment">         *         return Thread.interrupted();</span><br><span class="hljs-comment">         *     &#125;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>    t1.join();<br>    Thread.sleep(<span class="hljs-number">10000L</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们不断检验线程状态，会得到结论：lock 内部是基于 park 的，中断不会清除让 lock 退出，中断可能会短暂让线程进入中断状态（只能在锁的外部短暂观察到），但是 lock  的自旋模式会让锁回到未中断状态-只有从锁里出来，才能在本线程内部看到正确的中断状态</p>
<p>这是 park 隐晦地把响应中断的职责外放给使用者的一种设计。如果我们真的关心线程在跑到外部的时候是否还是从中断路径中出现，我们可以使用 lockInterruptibly + 检查异常，或者使用普通 lock + 检查中断位。</p>
<p>从总体来讲，lock 作为一个外部操作是不用抛出中断异常的方式来退出的，从lock 中正常退出往下走是用户可以接受的结果。中断位被隐藏得比较隐晦。</p>
<p>await 操作如果遇到异常，到底退出还是不退出呢？如果像 park 一样退出，则用户必须写类似 aqs 之类的代码才能检查中断位，而且有时候中断的真实目的并不是让一个线程苏醒，而是真的把后续的流程阻断掉（如果不中断掉，因为自旋的存在，线程只会再一次进入 park 的状态），从这个视角来看，抛出异常学 sleep 和 wait更合理。</p>
<h4 id="内部方法">内部方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 最底层的方法</span><br><span class="hljs-comment"> * Tests if some Thread has been interrupted.  The interrupted state</span><br><span class="hljs-comment"> * is reset or not based on the value of ClearInterrupted that is</span><br><span class="hljs-comment"> * passed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterrupted</span><span class="hljs-params">(<span class="hljs-type">boolean</span> ClearInterrupted)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安全方法-纯粹的读方法：不 clear 中断位的检查</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterrupted</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> isInterrupted(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 危险方法-不纯粹的读方法：名为中断，其实是 clear 中断位的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interrupted</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> currentThread().isInterrupted(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Interrupts this thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; Unless the current thread is interrupting itself, which is</span><br><span class="hljs-comment"> * always permitted, the &#123;<span class="hljs-doctag">@link</span> #checkAccess() checkAccess&#125; method</span><br><span class="hljs-comment"> * of this thread is invoked, which may cause a &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * SecurityException&#125; to be thrown.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If this thread is blocked in an invocation of the &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * Object#wait() wait()&#125;, &#123;<span class="hljs-doctag">@link</span> Object#wait(long) wait(long)&#125;, or &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;<span class="hljs-doctag">@link</span> Object&#125;</span><br><span class="hljs-comment"> * class, or of the &#123;<span class="hljs-doctag">@link</span> #join()&#125;, &#123;<span class="hljs-doctag">@link</span> #join(long)&#125;, &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * #join(long, int)&#125;, &#123;<span class="hljs-doctag">@link</span> #sleep(long)&#125;, or &#123;<span class="hljs-doctag">@link</span> #sleep(long, int)&#125;,</span><br><span class="hljs-comment"> * methods of this class, then its interrupt status will be cleared and it</span><br><span class="hljs-comment"> * will receive an &#123;<span class="hljs-doctag">@link</span> InterruptedException&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span><br><span class="hljs-comment"> * then the channel will be closed, the thread&#x27;s interrupt</span><br><span class="hljs-comment"> * status will be set, and the thread will receive a &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * java.nio.channels.ClosedByInterruptException&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If this thread is blocked in a &#123;<span class="hljs-doctag">@link</span> java.nio.channels.Selector&#125;</span><br><span class="hljs-comment"> * then the thread&#x27;s interrupt status will be set and it will return</span><br><span class="hljs-comment"> * immediately from the selection operation, possibly with a non-zero</span><br><span class="hljs-comment"> * value, just as if the selector&#x27;s &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If none of the previous conditions hold then this thread&#x27;s interrupt</span><br><span class="hljs-comment"> * status will be set. &lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  SecurityException</span><br><span class="hljs-comment"> *          if the current thread cannot modify this thread</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@revised</span> 6.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@spec</span> JSR-51</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> != Thread.currentThread())<br>        <span class="hljs-comment">// 只允许中断自己，否则抛出异常</span><br>        checkAccess();<br><br>    <span class="hljs-keyword">synchronized</span> (blockerLock) &#123;<br>        <span class="hljs-type">Interruptible</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> blocker;<br>        <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Just to set the interrupt flag</span><br>            interrupt0();           <br>            <span class="hljs-comment">// 当前线程阻塞或者非阻塞</span><br>            b.interrupt(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    interrupt0();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="countdownlatch">CountDownLatch</h2>
<p><img src="countDownLatch.png" alt="countDownLatch"></p>
<p>CountDownLatch 是一个 one-shot phenomenon，它的 state 是不能被复用的。</p>
<p>这个类的功能底层依赖于自身的 sync 的两个实现：</p>
<ul>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
</ul>
<p>其他都是框架编织的结果。这两个方法告诉我们，try 方法不需要考虑 interruptibly/uninterruptibly。</p>
<p>在大型项目里，测试异步用例的时候经常使用如下模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testScheduleTimeoutShouldNotRunBeforeDelay</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashedWheelTimer</span>();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Timeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> timer.newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            fail(<span class="hljs-string">&quot;This should not have run&quot;</span>);<br>            barrier.countDown();<br>        &#125;<br>    &#125;, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    assertFalse(barrier.await(<span class="hljs-number">3</span>, TimeUnit.SECONDS));<br>    assertFalse(timeout.isExpired(), <span class="hljs-string">&quot;timer should not expire&quot;</span>);<br>    timer.stop();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="初始化">初始化</h3>
<p>自身构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>       <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br>       <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>同步构造器只依赖于 setState：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Sync(<span class="hljs-type">int</span> count) &#123;<br>        <span class="hljs-comment">// 这样就 state == count 了</span><br>        setState(count);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>sync 在共享模式和互斥模式下有很重大的区别，就是 state 在互斥模式下维护的是同一个线程求锁的次数，在共享模式下维护的是共有多少个线程持有这把锁。</p>
<h3 id="await">await</h3>
<p>在 CountDownLatch 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的隐式逻辑是：sync 内部的 state 为0则此方法可以返回，阻塞发生在改为0之前。普通的 acquire 是修改 state 成功返回，阻塞发生在获取修改 state 的权限之前，这里产生了比较大的语义差别。</p>
<h4 id="acquiresharedinterruptibly">acquireSharedInterruptibly</h4>
<p>在 AQS 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Acquires in shared mode, aborting if interrupted.  Implemented</span><br><span class="hljs-comment"> * by first checking interrupt status, then invoking at least once</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #tryAcquireShared&#125;, returning on success.  Otherwise the</span><br><span class="hljs-comment"> * thread is queued, possibly repeatedly blocking and unblocking,</span><br><span class="hljs-comment"> * invoking &#123;<span class="hljs-doctag">@link</span> #tryAcquireShared&#125; until success or the thread</span><br><span class="hljs-comment"> * is interrupted.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arg the acquire argument.</span><br><span class="hljs-comment"> * This value is conveyed to &#123;<span class="hljs-doctag">@link</span> #tryAcquireShared&#125; but is</span><br><span class="hljs-comment"> * otherwise uninterpreted and can represent anything</span><br><span class="hljs-comment"> * you like.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException if the current thread is interrupted</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <br>    <span class="hljs-comment">// 这里小于0意味着 state 还是保持在 sync 的 state 非0的状态，才可以进入 doAcquireSharedInterruptibly 阻塞；否则就是已经被扣减到头了，就直接返回了，这会导致上层的 await 直接返回，这就是很多的事后 await 会直接返回的原理。这种</span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireSharedInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="CountDownLatch%E5%85%A5%E9%98%9F1.png" alt="CountDownLatch入队1"></p>
<p>在互斥类的 acquire 里面，只有 state 不为0（已被其他线程获取锁）会导致入队。在共享类的 acquire 里，只要 state 不为 0，也入队，反复自旋，直到 state 为 0 才导致出队，让 await 降为0。</p>
<p><img src="CountDownLatch%E5%85%A5%E9%98%9F2.png" alt="CountDownLatch入队2"><br>
<img src="CountDownLatch%E5%85%A5%E9%98%9F3.png" alt="CountDownLatch入队3"></p>
<h4 id="tryacquireshared">tryAcquireShared</h4>
<p>在自定义 sync 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-comment">// 在 CountDownLatch 的sync 里 acquires 是无用的，但在其他 sync 里就可以有用</span><br>    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只有当 state == 0 的时候，这个方法才会返回 1，否则返回-1。这和普通的 tryAcquire 返回 boolean 有很大差别。</p>
<p><code>acquireSharedInterruptibly(arg)</code> -&gt; <code>tryAcquireShared(arg) 只做判断</code> -&gt; <code>doAcquireSharedInterruptibly(arg) 产生阻塞</code>，AQS 的框架隐藏在<code>doAcquireSharedInterruptibly</code>里：</p>
<h4 id="doacquiresharedinterruptibly">doAcquireSharedInterruptibly</h4>
<p>这个方法很像 acquireQueued，出队的条件是 state 变为 0，而不是得到了修改 state 的机会</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 共享模式也入队，这里让每个入队的节点都带有同一个 nextWaiter</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 入队也要自旋</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 只有快要出队的节点可以这样做</span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-comment">// tryAcquireShared &gt; 0 意味着此时 aqs 没动过，或者被还原了，此时就可以考虑出队，最终让上层的 await 返回了</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 只要共享状态降为0即可以出队</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// 然后返回，让更上层返回</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-comment">// 这个方法是 interruptibly 的版本，所以遇到中断应该抛出中断异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="setheadandpropagate">setHeadAndPropagate</h4>
<p>这个方法 propagate 是很难理解的，doShare 是它试图 propagate 的东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// Record old head for check below</span><br>    setHead(node);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Try to signal next queued node if:</span><br><span class="hljs-comment">     *   Propagation was indicated by caller,</span><br><span class="hljs-comment">     *     or was recorded (as h.waitStatus either before</span><br><span class="hljs-comment">     *     or after setHead) by a previous operation</span><br><span class="hljs-comment">     *     (note: this uses sign-check of waitStatus because</span><br><span class="hljs-comment">     *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="hljs-comment">     * and</span><br><span class="hljs-comment">     *   The next node is waiting in shared mode,</span><br><span class="hljs-comment">     *     or we don&#x27;t know, because it appears null</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The conservatism in both of these checks may cause</span><br><span class="hljs-comment">     * unnecessary wake-ups, but only when there are multiple</span><br><span class="hljs-comment">     * racing acquires/releases, so most need signals now or soon</span><br><span class="hljs-comment">     * anyway.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-comment">// shared mode 的模式在此处生效产生了一个和普通的 setHead 不同的效应，它会产生一个 doReleaseShared</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())<br>            doReleaseShared();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="doreleaseshared">doReleaseShared</h4>
<p>这个方法特别难，普通 tryRelease 是改动 aqs 的自身状态，但 doReleaseShared 依赖于 tryReleaseShared 的返回结果，只专心处理从 head 开始的 ws 问题，然后对 head 的后继进行 unpark。这个节点会让所有卡在 countDownLatch 的计时条件上的线程都越过门槛本身。因为 tryReleaseShared 已经把 state 扣减为0，此处做的主要是 unpark + 改 ws，doAcquireSharedInterruptibly 那里就会自己直接返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Ensure that a release propagates, even if there are other</span><br><span class="hljs-comment">     * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="hljs-comment">     * way of trying to unparkSuccessor of head if it needs</span><br><span class="hljs-comment">     * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="hljs-comment">     * ensure that upon release, propagation continues.</span><br><span class="hljs-comment">     * Additionally, we must loop in case a new node is added</span><br><span class="hljs-comment">     * while we are doing this. Also, unlike other uses of</span><br><span class="hljs-comment">     * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="hljs-comment">     * fails, if so rechecking.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 1. h == null: 说明阻塞队列为空</span><br>        <span class="hljs-comment">// 2. h == tail: 说明头节点可能是刚刚初始化的头节点，</span><br>        <span class="hljs-comment">// 或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了</span><br>        <span class="hljs-comment">// 所以这两种情况不需要进行唤醒后继节点</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-comment">// head 如果能够被从 SIGNAL 设为 0，则 unpark head 的下一个节点，否则循环 recheck</span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>               <span class="hljs-comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-comment">// head 如果已经是 0，则把它设置为 PROPAGATE</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="countdown">countDown</h3>
<p><img src="CountDownLatch%E9%87%8A%E6%94%BE.png" alt="CountDownLatch释放"></p>
<p><code>countDown()</code> -&gt; releaseShared(1) -&gt; tryRleaseShare(1) -&gt; doReleaseShare();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 每次 countDown 都等于一次共享释放1</span><br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="releaseshared">releaseShared</h4>
<p>这里在完全退出的分支里，再次主动调用了 doReleaseShared</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 如果已经 state 为0，则直接返回；如果扣减不到0，也直接返回；如果扣减到0了，则执行 doReleaseShared</span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="tryreleaseshared">tryReleaseShared</h4>
<p>这个方法的返回值很有意思：true 意味着允许一个 acquire（不管是共享式还是互斥式的）得到一个 permit-是否要进入一个最终退出动作，这个动作只执行一次。否则，返回 false可能含有2个含义，已被扣减完，应该进入退出后状态；或者意味着先扣减得到中间态的 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>      <span class="hljs-comment">// Decrement count; signal when transition to zero</span><br>      <span class="hljs-comment">// 在 try release 系列里，这是唯一一个有自旋的</span><br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>          <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          <span class="hljs-comment">// 这里直接做了减1，而不是减 releases</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>              <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<h2 id="cyclicbarrier">CyclicBarrier</h2>
<p>cyclic 既有周期的意思，也有循环的意思。</p>
<p><img src="cyclicbarrier-1.png" alt="cyclicbarrier-1"><br>
<img src="cyclicbarrier-2.png" alt="cyclicbarrier-2"></p>
<blockquote>
<p>CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS<br>
的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p>
</blockquote>
<p>这个类是一个很简单的交替地使用一个内置了 Lock 和 Condition 来维护一个 barrier waiting count 的实现。</p>
<h3 id="和countdownlatch-的区别">和CountDownLatch 的区别</h3>
<ol>
<li>CyclicBarrier 使用互斥而不是共享机制来实现多线程协同，共享状态是由 party 生成的 count。CyclicBarrier 依托 Condition。</li>
<li>而 CountDownLatch 通过共享而不是互斥来实现多线程协同，共享状态是 AQS 的 state。而 CountDownLatch 有自己的 sync。</li>
<li>CyclicBarrier 只需要每个内线程做完自己的事自动<strong>await</strong>，不需要 signal，到齐了自动就通过；CountDownLatch 让内线程<strong>countDown</strong>。CyclicBarrier 外线程等待这个到齐结果 join 所有内线程； CountDownLatch 对 latch 进行 <strong>await</strong>。</li>
</ol>
<h3 id="作者的官方示例">作者的官方示例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solver</span> &#123;<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N;<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">float</span>[][] data;<br>   <span class="hljs-keyword">final</span> CyclicBarrier barrier;<br><br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>     <span class="hljs-type">int</span> myRow;<br>     Worker(<span class="hljs-type">int</span> row) &#123; myRow = row; &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">while</span> (!done()) &#123;<br>         processRow(myRow);<br><br>         <span class="hljs-keyword">try</span> &#123;<br>           barrier.await();<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>           <span class="hljs-keyword">return</span>;<br>         &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException ex) &#123;<br>           <span class="hljs-keyword">return</span>;<br>         &#125;<br>       &#125;<br>     &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solver</span><span class="hljs-params">(<span class="hljs-type">float</span>[][] matrix)</span> &#123;<br>     data = matrix;<br>     N = matrix.length;<br>     <span class="hljs-type">Runnable</span> <span class="hljs-variable">barrierAction</span> <span class="hljs-operator">=</span><br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; mergeRows(...); &#125;&#125;;<br>     barrier = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(N, barrierAction);<br><br>     List&lt;Thread&gt; threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Thread&gt;(N);<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(i));<br>       threads.add(thread);<br>       thread.start();<br>     &#125;<br><br>     <span class="hljs-comment">// wait until done</span><br>     <span class="hljs-keyword">for</span> (Thread thread : threads)<br>       thread.join();<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>在 Spring 里拿他来做测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pubSubLostConnectionTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>);<br>    channel.subscribe(message -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            latch.await(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">this</span>.channel.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericMessage</span>&lt;&gt;(<span class="hljs-string">&quot;foo&quot;</span>));<br>    latch.await(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    latch.reset();<br>    <span class="hljs-type">BlockingQueueConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> (BlockingQueueConsumer) TestUtils.getPropertyValue(<span class="hljs-built_in">this</span>.channel,<br>            <span class="hljs-string">&quot;container.consumers&quot;</span>, Set.class).iterator().next();<br>    connectionFactory.destroy();<br>    waitForNewConsumer(<span class="hljs-built_in">this</span>.channel, consumer);<br>    <span class="hljs-built_in">this</span>.channel.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericMessage</span>&lt;&gt;(<span class="hljs-string">&quot;bar&quot;</span>));<br>    latch.await(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    <span class="hljs-built_in">this</span>.channel.destroy();<br>    <span class="hljs-built_in">this</span>.pubSubWithEP.destroy();<br>    <span class="hljs-built_in">this</span>.withEP.destroy();<br>    <span class="hljs-built_in">this</span>.pollableWithEP.destroy();<br>    assertThat(TestUtils.getPropertyValue(connectionFactory, <span class="hljs-string">&quot;connectionListener.delegates&quot;</span>, Collection.class)<br>            .size()).isEqualTo(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有些地方还会有工具方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitAtBarrier</span><span class="hljs-params">(String barrierName, Map&lt;String, CyclicBarrier&gt; barriers)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        barriers.get(barrierName).await(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(<span class="hljs-string">&quot;Test didn&#x27;t complete: &quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="成员拆解">成员拆解</h3>
<p>首先，非 generation 的部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/** The lock for guarding barrier entry */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-comment">// 触动开关</span><br><span class="hljs-comment">/** Condition to wait on until tripped */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br><span class="hljs-comment">/** The number of parties */</span><br><span class="hljs-comment">// 这个数字不可扣减</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> parties;<br><br><span class="hljs-comment">/* The command to run when tripped */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable barrierCommand;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个数字可以扣减</span><br><span class="hljs-comment"> * Number of parties still waiting. Counts down from parties to 0</span><br><span class="hljs-comment"> * on each generation.  It is reset to parties on each new</span><br><span class="hljs-comment"> * generation or when broken.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br></code></pre></td></tr></table></figure>
<p>其次，generation 的部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Each use of the barrier is represented as a generation instance.</span><br><span class="hljs-comment">   * The generation changes whenever the barrier is tripped, or</span><br><span class="hljs-comment">   * is reset. There can be many generations associated with threads</span><br><span class="hljs-comment">   * using the barrier - due to the non-deterministic way the lock</span><br><span class="hljs-comment">   * may be allocated to waiting threads - but only one of these</span><br><span class="hljs-comment">   * can be active at a time (the one to which &#123;<span class="hljs-doctag">@code</span> count&#125; applies)</span><br><span class="hljs-comment">   * and all the rest are either broken or tripped.</span><br><span class="hljs-comment">   * There need not be an active generation if there has been a break</span><br><span class="hljs-comment">   * but no subsequent reset.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generation</span> &#123;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">broken</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <br>    <span class="hljs-comment">/** The current generation */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">generation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();<br></code></pre></td></tr></table></figure>
<h3 id="构造器">构造器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a new &#123;<span class="hljs-doctag">@code</span> CyclicBarrier&#125; that will trip when the</span><br><span class="hljs-comment"> * given number of parties (threads) are waiting upon it, and which</span><br><span class="hljs-comment"> * will execute the given barrier action when the barrier is tripped,</span><br><span class="hljs-comment"> * performed by the last thread entering the barrier.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> parties the number of threads that must invoke &#123;<span class="hljs-doctag">@link</span> #await&#125;</span><br><span class="hljs-comment"> *        before the barrier is tripped</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> barrierAction the command to execute when the barrier is</span><br><span class="hljs-comment"> *        tripped, or &#123;<span class="hljs-doctag">@code</span> null&#125; if there is no action</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if &#123;<span class="hljs-doctag">@code</span> parties&#125; is less than 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;<br>    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.parties = parties;<br>    <span class="hljs-built_in">this</span>.count = parties;<br>    <span class="hljs-built_in">this</span>.barrierCommand = barrierAction;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a new &#123;<span class="hljs-doctag">@code</span> CyclicBarrier&#125; that will trip when the</span><br><span class="hljs-comment"> * given number of parties (threads) are waiting upon it, and</span><br><span class="hljs-comment"> * does not perform a predefined action when the barrier is tripped.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> parties the number of threads that must invoke &#123;<span class="hljs-doctag">@link</span> #await&#125;</span><br><span class="hljs-comment"> *        before the barrier is tripped</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if &#123;<span class="hljs-doctag">@code</span> parties&#125; is less than 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties)</span> &#123;<br>    <span class="hljs-built_in">this</span>(parties, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="await">await</h3>
<p>这个方法既会返回，也会抛出异常。</p>
<p>它的返回值是：the arrival index of the current thread, where index getParties() - 1 indicates the first to arrive and zero indicates the last to arrive。也就是说，如果有5个线程在等，await == 4 意味着第一个返回，await == 0 意味着最后一个返回。然后可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里的 await 是支持 happen-before 语义的，在 await 返回的那一刻即返回</span><br><span class="hljs-keyword">if</span> (barrier.await() == <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-comment">// log the completion of this iteration</span><br> &#125;<br></code></pre></td></tr></table></figure>
<p>它有一个核心的方法，这个方法把所有的非计时转化为计时- ConditionObject 内部不是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">return</span> dowait(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>       &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>           <span class="hljs-comment">// 针对有签名但不处理的异常，我们包装为 error</span><br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(toe); <span class="hljs-comment">// cannot happen</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>所以我们有了计时的等待方法总能得到非计时的实现。</p>
<h3 id="dowait">dowait</h3>
<p><strong>CyclicBarrier 状态转换图</strong>：</p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; 初始状态: new CyclicBarrier(n)
    
    初始状态 --&gt; 等待中: 线程调用 await()&lt;br/&gt;count--
    等待中 --&gt; 等待中: 更多线程 await()&lt;br/&gt;count--
    
    等待中 --&gt; 触发: count == 0&lt;br/&gt;最后一个线程到达
    触发 --&gt; 初始状态: nextGeneration()&lt;br/&gt;重置 count，新建 Generation
    
    等待中 --&gt; 破损: 中断/超时/reset
    破损 --&gt; 初始状态: reset() 调用&lt;br/&gt;breakBarrier + nextGeneration
    
    note right of 初始状态
        count = parties
        generation.broken = false
    end note
    
    note right of 触发
        执行 barrierCommand
        signalAll() 唤醒所有等待线程
    end note
    
    note right of 破损
        generation.broken = true
        抛出 BrokenBarrierException
    end note</code></pre>
<p><strong>CyclicBarrier 多线程协作时序图</strong>：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T1 as Thread-1
    participant T2 as Thread-2
    participant T3 as Thread-3
    participant CB as CyclicBarrier(3)
    
    Note over CB: count=3, generation.broken=false
    
    T1-&gt;&gt;CB: await()
    CB--&gt;&gt;T1: count=2, 进入等待
    Note over T1: WAITING on Condition
    
    T2-&gt;&gt;CB: await()
    CB--&gt;&gt;T2: count=1, 进入等待
    Note over T2: WAITING on Condition
    
    T3-&gt;&gt;CB: await()
    Note over CB: count=0, 触发!
    CB-&gt;&gt;CB: 执行 barrierCommand
    CB-&gt;&gt;CB: nextGeneration()
    CB--&gt;&gt;T1: 唤醒, 返回 index=2
    CB--&gt;&gt;T2: 唤醒, 返回 index=1
    CB--&gt;&gt;T3: 返回 index=0
    
    Note over CB: 新一代开始&lt;br/&gt;count=3, 新 Generation</code></pre>
<p>有4种方法可退出：<br>
- last thread arrives<br>
- 中断发生在任意一个等待线程，抛出 InterruptedException（自己被中断）或者 BrokenBarrierException （其他线程被中断）<br>
- 超时发生，抛出 BrokenBarrierException<br>
- 触发了 reset，抛出 BrokenBarrierException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException,<br>               TimeoutException &#123;<br>        <span class="hljs-comment">// 这个内部框架在维护状态的时候，都是使用标准的 lock-check-await 的模式</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 把当前的 generation 取出来</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> generation;<br><br>            <span class="hljs-comment">// 这个方法的前置检查抛出 generation 异常，作为栅栏破坏的响应，而不处理栅栏</span><br>            <span class="hljs-keyword">if</span> (g.broken)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br><br>            <span class="hljs-comment">// 一个线程检查出中断，要把其他线程破坏。所以被中断的线程是中断异常，被破坏的线程是破坏异常。中断线程可以处理栅栏。</span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>                breakBarrier();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125;<br>            <br>            <span class="hljs-comment">// 在进行等待以前对 count 做共享减法，这个共享写的顺序能够体现在 index 里</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> --count;<br>            <br>            <span class="hljs-comment">// index 等于 0 是一个特定的事件，是最后一个线程才会触发的分支，这引出了一种写法，最后返回的分支写在等待的开头</span><br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// tripped</span><br>                <span class="hljs-comment">// 维护一个 ranAction 状态</span><br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">ranAction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> barrierCommand;<br>                    <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>)<br>                        command.run();<br>                    ranAction = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-comment">// 由最后一个线程驱动下一个 generation，理论上下一轮的 await 可以在这个时刻运行了。返回线程可以处理栅栏。</span><br>                    nextGeneration();<br>                    <span class="hljs-comment">// 这里的 return 是唯一的“无害动作”，如果这里插入任何维护状态的代码，下面的 breakBarrier 再破坏状态，可能会导致下一代的 wait 动作被集体破坏</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 如果 ranAction 状态不正常，则还是要破坏栅栏</span><br>                    <span class="hljs-keyword">if</span> (!ranAction)<br>                        breakBarrier();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 非 last 动作，则只有3种方式返回</span><br>            <span class="hljs-comment">// loop until tripped, broken, interrupted, or timed out</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 区分计时和非计时的等待，然后在自旋里工作</span><br>                    <span class="hljs-keyword">if</span> (!timed)<br>                        trip.await();<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)<br>                        <span class="hljs-comment">// an estimate of the nanosTimeout value minus the time spent waiting upon return from this method. A positive value may be used as the argument to a subsequent call to this method to finish waiting out the desired time. A value less than or equal to zero indicates that no time remains.</span><br>                        <span class="hljs-comment">// 这个 nanos 可能成为负数，为我们超时异常提供了依据</span><br>                        nanos = trip.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                    <span class="hljs-comment">// 如果此时本代仍然是同一代，则尝试破坏栅栏（这是为了让同一代里 breakBarrier 式退出 exactly once）</span><br>                    <span class="hljs-keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;<br>                        breakBarrier();<br>                        <span class="hljs-keyword">throw</span> ie;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 如果不需要我们破坏动作，根据标准协议，收到 InterruptedException 我们也要中断线程，作为响应。</span><br>                        <span class="hljs-comment">// 我们要理解一个巨大的差别：在当代的中断我们是要忠实地履行方法签名的行为，抛出异常，不在当代则静默地中断自己</span><br>                        <span class="hljs-comment">// We&#x27;re about to finish waiting even if we had not</span><br>                        <span class="hljs-comment">// been interrupted, so this interrupt is deemed to</span><br>                        <span class="hljs-comment">// &quot;belong&quot; to subsequent execution.</span><br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;<br>                <br>                <span class="hljs-comment">// await 的正常返回带来的后置检查，这里的 g是当前代数</span><br>                <span class="hljs-keyword">if</span> (g.broken)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br>                <br>                <span class="hljs-comment">// 如果代数换了，就返回当前的次序，不管超时了（无意义）。只要�发生过nextGeneration，发生代切换，此处才得到许可可以出去，这又潜在要求 nextGeneration 执行替换一定发生在 signallAll 之前。但 nextGeneration 的实现却是先 signallAll 再替换 nextGeneration 的</span><br>                <span class="hljs-keyword">if</span> (g != generation)<br>                    <span class="hljs-comment">// 在这里编译器居然能保证 return 总是不漏，怎么做到的呢？</span><br>                    <span class="hljs-keyword">return</span> index;<br>                <br>                <span class="hljs-comment">//  如果排队中出现了超时，此时要处理一下</span><br>                <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                    breakBarrier();<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的等待是由 await 类操作决定的，它的唤醒操作必然来自 signal 类操作，而这两类操作被隐藏在正常退出和异常退出里。</p>
<h3 id="异常退出-breakbarrier">异常退出 breakBarrier</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breakBarrier</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 把当前的代破坏</span><br>       generation.broken = <span class="hljs-literal">true</span>;<br>       <span class="hljs-comment">// 把 count 复原为 parties</span><br>       count = parties;<br>       trip.signalAll();<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>异常退出是设置完状态再 signalAll。</p>
<h3 id="正常退出-nextgeneration">正常退出 nextGeneration</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextGeneration</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// signal completion of last generation</span><br>      trip.signalAll();<br>      <span class="hljs-comment">// set up next generation</span><br>      count = parties;<br>      generation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>异常退出是 signalAll 完再设置完状态。</p>
<h3 id="重置-reset">重置 reset</h3>
<p>等于先破坏栅栏再重置栅栏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Resets the barrier to its initial state.  If any parties are</span><br><span class="hljs-comment"> * currently waiting at the barrier, they will return with a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> BrokenBarrierException&#125;. Note that resets &lt;em&gt;after&lt;/em&gt;</span><br><span class="hljs-comment"> * a breakage has occurred for other reasons can be complicated to</span><br><span class="hljs-comment"> * carry out; threads need to re-synchronize in some other way,</span><br><span class="hljs-comment"> * and choose one to perform the reset.  It may be preferable to</span><br><span class="hljs-comment"> * instead create a new barrier for subsequent use.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 老线程要通过闭包里闭合的局部变量理解 break</span><br>        breakBarrier();   <span class="hljs-comment">// break the current generation</span><br>        <span class="hljs-comment">// 新线程使用隔离的 generation</span><br>        nextGeneration(); <span class="hljs-comment">// start a new generation</span><br>        <span class="hljs-comment">// reset 意味着 count 再次等于 parties</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="统计方法">统计方法</h3>
<h4 id="isbroken">isBroken</h4>
<p>这个方法实现了准确读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBroken</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> generation.broken;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="getnumberwaiting">getNumberWaiting</h4>
<p>这个方法也实现了准确读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the number of parties currently waiting at the barrier.</span><br><span class="hljs-comment"> * This method is primarily useful for debugging and assertions.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the number of parties currently blocked in &#123;<span class="hljs-doctag">@link</span> #await&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumberWaiting</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> parties - count;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="semaphore">Semaphore</h2>
<p><strong>Semaphore 与其他同步工具对比</strong>：</p>
<pre><code class="hljs mermaid">flowchart TB
    subgraph &quot;同步工具对比&quot;
        direction LR
        
        subgraph SEM[&quot;Semaphore&quot;]
            S1[&quot;• state = 可用许可数&lt;br/&gt;• acquire: state--&lt;br/&gt;• release: state++&lt;br/&gt;• 可重复使用&lt;br/&gt;• 不记录 owner&quot;]
        end
        
        subgraph CDL[&quot;CountDownLatch&quot;]
            C1[&quot;• state = 剩余计数&lt;br/&gt;• countDown: state--&lt;br/&gt;• await: 等待 state=0&lt;br/&gt;• 一次性使用&lt;br/&gt;• 不可重置&quot;]
        end
        
        subgraph CB[&quot;CyclicBarrier&quot;]
            B1[&quot;• count = 等待线程数&lt;br/&gt;• await: count--&lt;br/&gt;• 最后线程触发&lt;br/&gt;• 可重复使用&lt;br/&gt;• 可重置&quot;]
        end
    end
    
    style SEM fill:#e3f2fd
    style CDL fill:#fff3e0
    style CB fill:#e8f5e9</code></pre>
<table>
<thead>
<tr>
<th>特性</th>
<th>Semaphore</th>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>state 语义</strong></td>
<td>可用许可数</td>
<td>剩余计数</td>
<td>等待线程数</td>
</tr>
<tr>
<td><strong>增减方向</strong></td>
<td>双向（acquire-/release+）</td>
<td>单向（只减）</td>
<td>单向（只减）</td>
</tr>
<tr>
<td><strong>可重用</strong></td>
<td>✅ 是</td>
<td>❌ 否</td>
<td>✅ 是（自动重置）</td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>资源池限流</td>
<td>等待多任务完成</td>
<td>多线程同步点</td>
</tr>
</tbody>
</table>
<p>Semaphore 使用数字维护一个共享状态池，使用共享加解锁的思路来修改 state。</p>
<blockquote>
<p>创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用<br>
acquire 的时候，执行 state = state - 1，release 的时候执行 state = state +<br>
1，当然，acquire  的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p>
</blockquote>
<p>需要仔细设计的怎么阻塞与唤醒。</p>
<h3 id="官方示例">官方示例</h3>
<p>作者认为这是一个 permit pool。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_AVAILABLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(MAX_AVAILABLE, <span class="hljs-literal">true</span>);<br><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getItem</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     available.acquire();<br>     <span class="hljs-keyword">return</span> getNextAvailableItem();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putItem</span><span class="hljs-params">(Object x)</span> &#123;<br>     <span class="hljs-keyword">if</span> (markAsUnused(x))<br>       available.release();<br>   &#125;<br><br>   <span class="hljs-comment">// Not a particularly efficient data structure; just for demo</span><br>   <span class="hljs-keyword">protected</span> Object[] items = ... whatever kinds of items being managed<br>   <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[MAX_AVAILABLE];<br><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title function_">getNextAvailableItem</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;<br>       <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>          used[i] = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">return</span> items[i];<br>       &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// not reached</span><br>   &#125;<br><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markAsUnused</span><span class="hljs-params">(Object item)</span> &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;<br>       <span class="hljs-keyword">if</span> (item == items[i]) &#123;<br>          <span class="hljs-keyword">if</span> (used[i]) &#123;<br>            used[i] = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例里对称很重要，在 op 以前就要 acquire permit，在 op 成功以后才 release permit。它的 state 恰好不是以互斥的方式 accumulated 的，是以共享的方式 accumulated 的。</p>
<p>mutex = binary semaphore = nonreentrant exclusive lock</p>
<p>这种锁是不计较 owner 的，在死锁恢复场景下尤其有用。比如有个线程 a 拿走了一个 permit 没有还，其他线程可以通过把自己的 permit 归还，来暂时制造流动性。</p>
<p>照理来讲，没有 IllegateMonitorStateException 的约束，多 release 也是有可能的，不一定需要严格按照 acquire 时线程得到的 permit进行归还。所以，CountDownLatch 和 CyclicBarrier 的state 是固定大小的，Semaphore不是。</p>
<h3 id="构造器">构造器</h3>
<p>因为信号量也是不易察觉的“类锁”的方案，所以它也有公平和非公平的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(<span class="hljs-keyword">permits</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不公平抢锁可以减少调度，被称作 barging；公平抢锁可以减少饥饿。</p>
<h3 id="获取资源：四大-acquire-方法">获取资源：四大 acquire 方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>    sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">permits</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    sync.acquireSharedInterruptibly(<span class="hljs-keyword">permits</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">permits</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    sync.acquireShared(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有可中断和不可中断两大类 API，也有无参数和固定参数两大 API，不过 API 命名的习惯没有得到遵循，默认的 Semaphore 的方法是响应中断的。</p>
<h4 id="acquireshared">acquireShared</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法很像 CountDownLatch 的 await，但少了检查中断的一部分。其中 doAcquireShared 和 CountDownLatch 一样都使用的 AQS 的原生实现。</p>
<h4 id="tryacquireshared">tryAcquireShared</h4>
<h5 id="公平">公平</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (hasQueuedPredecessors())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>共享池模式使用 -1 和 1 来控制是否 doAcquireShare，所以这里返回 -1 意味着要入队，返回负数的 remaining 也是需要入队的。如果是正数则可以尝试 cas 一下。</p>
<h5 id="非公平">非公平</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>         <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br> &#125;<br> <br> <span class="hljs-comment">// 在父类里</span><br> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>         <span class="hljs-keyword">for</span> (;;) &#123;<br>             <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>             <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>             <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>                 compareAndSetState(available, remaining))<br>                 <span class="hljs-keyword">return</span> remaining;<br>         &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>公平和非公平的差别只在 hasQueuedPredecessors 的调用结果里。</p>
<h3 id="释放资源">释放资源</h3>
<p>不管用什么方式获取，释放总是用同一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>releaseShared 和 doReleaseShared 仍然共用 AQS 的缺省实现，只有 tryReleaseShared 是使用 sync 实现。</p>
<h4 id="tryreleaseshared">tryReleaseShared</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>        <span class="hljs-comment">// 溢出，当然，我们一般也不会用这么大的数</span><br>        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>获取当前的 state，按照 releases 来做加法。</p>
<h2 id="从执行器到线程池">从执行器到线程池</h2>
<blockquote>
<p>线程池相关内容已抽取为独立文档，请参阅：<a href="2026-01-12-Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0.md">Java 线程池笔记</a></p>
</blockquote>
<p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">《一行一行源码分析清楚AbstractQueuedSynchronizer》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016058789">《Java多线程》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">《从ReentrantLock的实现看AQS的原理及应用》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">《不可不说的Java&quot;锁&quot;事》</a></li>
<li><a target="_blank" rel="noopener" href="http://itmyhome.com/java-api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#nested_class_summary">《官方文档的中文翻译》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《Java线程池实现原理及其在美团业务中的实践》</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" title="无锁队列"><img class="cover" src="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">无锁队列</div></div><div class="info-2"><div class="info-item-1">Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。 * * &lt;p&gt;原理说明： * - 仅允许一个线程调用 &#123;@code offer()&#125;，一个线程调用 &#123;@code poll()&#125;。 * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。 * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系： *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。 * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad）， *   ...</div></div></div></a><a class="pagination-related" href="/2026/01/18/%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E7%9A%84%E5%8E%86%E5%8F%B2/" title="异步进化的历史"><img class="cover" src="/2026/01/18/%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E7%9A%84%E5%8E%86%E5%8F%B2/CompletableFuture%E6%89%A7%E8%A1%8C%E6%A0%91.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">异步进化的历史</div></div><div class="info-2"><div class="info-item-1">本文一部分来自于qwen，一部分来自于以下文章：  《CompletableFuture原理与实践-外卖商家端API的异步化》  Java 演进本质 graph LR     A[Java 5 Future] --&gt;|阻塞痛点| B[Guava ListenableFuture]     B --&gt;|回调地狱| C[CompletableFuture]     C --&gt;|流处理需求| D[RxJava]     D --&gt;|Spring整合| E[Reactor]          A --&gt;|范式转变| F[命令式-&gt;声明式]     B --&gt;|抽象提升| G[事件驱动-&gt;数据流]     C --&gt;|能力增强| H[组合-&gt;背压]     D &amp; E --&gt;|统一理念| I[异步即数据流]  控制流：阻塞等待 → 回调响应 → 声明式组合 → 响应式流 错误处理：分散try-catch → 回调onFailure → 链式exceptionally → 流式onError 组合能力：无 → 有限tr...</div></div></div></a><a class="pagination-related" href="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/" title="Java 线程池笔记"><img class="cover" src="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-24</div><div class="info-item-2">Java 线程池笔记</div></div><div class="info-2"><div class="info-item-1">从执行器到线程池  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia “池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。 在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括： 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池(Object Pooling)：循...</div></div></div></a><a class="pagination-related" href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-19</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1"> 版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374），在 JDK 18 中相关代码已被移除。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级。但在深入讨论线程安全的分类之前，我们需要先理解 Java 内存模型——它是理解线程安全问题的理论基础。 Java 内存模型基础 Java 内存模型（Java Memory Model，JMM）是 Java 语言规范的一部分，定义了多线程程序中共享变量的访问规则。理解 JMM 是理解线程安全问题的基础。 为什么需要内存模型？ 现代计算机系统中，CPU 与主内存之间存在巨大的速度差异。为了弥补这一差距，硬件层面引入了多级缓存（L1、L...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-91.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a><a class="pagination-related" href="/2017/11/03/JVM-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="JVM 的内存模型与线程"><img class="cover" src="/img/wall-paper-83.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-03</div><div class="info-item-2">JVM 的内存模型与线程</div></div><div class="info-2"><div class="info-item-1">1.性能何处寻   计算机的CPU比起其他所有的设备，都快得多，所以怎样尽量复用 CPU 的时间片，是压榨计算机性能的目标。多核和并发，使得阿姆达尔定律大显神威，超越摩尔定律成为提升系统性能的金科玉律 - 现在单核计算能力已经无法垂直提升，要水平提升核数来提升整体性能。 2.缓存一致性问题（Cache Coherence）   软件缓存，不过是硬件缓存的模仿，真正的缓存，早已存在于计算机的多级存储体系结构中。JVM 里，我们可以认为每个处理器都会在主内存（Main Memory）之外有高速缓存作为工作内存（Working memory）。除此之外，处理器和 JVM 都可能出现指令重排（Instruction Reorder）的的情况。工作内存是线程 Save 和 Load 的主要场所，主内存则是他们沟通的场所。 3.JVM 的对象信息   Java Object 除了基本的内存轮廓以外，还有：  Mark Word（对象的 Hash Code 的缓存值、GC标志、GC年龄、同步锁等信息）。 Klass Point（指向对象元数据信息的指针，指向 .class  的指针吗？不是，是...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">写在前面的话</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">管程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mesa-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">MESA 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-set-%E8%80%8C%E4%B8%8D%E7%94%A8-queue"><span class="toc-number">1.2.1.</span> <span class="toc-text">为什么用 set 而不用 queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">模型映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mesa-%E6%A8%A1%E5%9E%8B%E7%9A%84-signal-and-continue-%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. Mesa 模型的 “Signal and Continue” 语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-entry-set-%E9%94%81%E7%AB%9E%E4%BA%89-%E2%9D%8C-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E6%9C%89-timed-waiting"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. Entry Set（锁竞争）❌ 永远不会有 TIMED_WAITING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-wait-set-%E6%9D%A1%E4%BB%B6%E7%AD%89%E5%BE%85-%E2%9C%85-%E6%94%AF%E6%8C%81-timed-waiting"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. Wait Set（条件等待）✅ 支持 TIMED_WAITING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-jvisualvm-%E5%88%86%E7%B1%BB%E9%80%BB%E8%BE%91"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4. JVisualVM 分类逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E-os-%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">5. 线程状态与 OS 调度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Java 线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%97%E4%B8%BE"><span class="toc-number">2.1.</span> <span class="toc-text">线程状态列举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">2.1.1.</span> <span class="toc-text">NEW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runnable"><span class="toc-number">2.1.2.</span> <span class="toc-text">RUNNABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocked"><span class="toc-number">2.1.3.</span> <span class="toc-text">BLOCKED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waiting"><span class="toc-number">2.1.4.</span> <span class="toc-text">WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timed-waiting"><span class="toc-number">2.1.5.</span> <span class="toc-text">TIMED_WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#terminated"><span class="toc-number">2.1.6.</span> <span class="toc-text">TERMINATED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.7.</span> <span class="toc-text">几种线程状态的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">2.2.</span> <span class="toc-text">线程间方法的设计哲学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E7%9A%84%E5%88%87%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">特别的切换方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#locksupport-park"><span class="toc-number">2.3.1.</span> <span class="toc-text">LockSupport.park</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-number">2.3.2.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">2.3.3.</span> <span class="toc-text">join</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">3.1.</span> <span class="toc-text">Volatile</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.1.</span> <span class="toc-text">总体设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">Unsafe 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-field"><span class="toc-number">4.2.1.</span> <span class="toc-text">获取 field</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#increaseandget-%E4%B8%8E-getandincrease"><span class="toc-number">4.2.2.</span> <span class="toc-text">increaseAndGet 与 getAndIncrease</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">4.2.3.</span> <span class="toc-text">自旋锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.</span> <span class="toc-text">函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-runnable-%E5%92%8C-callable"><span class="toc-number">4.3.1.</span> <span class="toc-text">区别 Runnable 和 Callable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.4.</span> <span class="toc-text">synchronized 的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#locksupport"><span class="toc-number">4.5.</span> <span class="toc-text">LockSupport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%95%88%E5%BA%94-memory-consistency-effects"><span class="toc-number">4.6.</span> <span class="toc-text">内存一致性效应（Memory consistency effects）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E9%94%81"><span class="toc-number">4.7.</span> <span class="toc-text">主流锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">4.7.1.</span> <span class="toc-text">悲观锁与乐观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aqs-abstractqueuedsynchronizer"><span class="toc-number">4.8.</span> <span class="toc-text">AQS（AbstractQueuedSynchronizer）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#treiber-stack-%E5%8E%9F%E7%90%86%E7%AE%80%E4%BB%8B"><span class="toc-number">4.8.1.</span> <span class="toc-text">Treiber Stack 原理简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.8.2.</span> <span class="toc-text">AQS 的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BF%86"><span class="toc-number">4.8.2.1.</span> <span class="toc-text">简要记忆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs%E7%9A%84%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">4.8.3.</span> <span class="toc-text">AQS的五层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clh-queue"><span class="toc-number">4.8.4.</span> <span class="toc-text">CLH queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%87%E5%87%86%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">4.8.5.</span> <span class="toc-text">互斥框架的标准伪代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.8.6.</span> <span class="toc-text">Node 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.8.7.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81"><span class="toc-number">4.8.7.1.</span> <span class="toc-text">加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#clh-%E4%B8%BB%E6%A1%86%E6%9E%B6"><span class="toc-number">4.8.7.1.1.</span> <span class="toc-text">CLH 主框架</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#tryacquire"><span class="toc-number">4.8.7.1.1.1.</span> <span class="toc-text">tryAcquire</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#addwaiter"><span class="toc-number">4.8.7.1.1.2.</span> <span class="toc-text">addWaiter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#enq"><span class="toc-number">4.8.7.1.1.3.</span> <span class="toc-text">enq</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#acquirequeued"><span class="toc-number">4.8.7.1.1.4.</span> <span class="toc-text">acquireQueued</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sethead"><span class="toc-number">4.8.7.1.1.5.</span> <span class="toc-text">setHead</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#shouldparkafterfailedacquire"><span class="toc-number">4.8.7.1.1.6.</span> <span class="toc-text">shouldParkAfterFailedAcquire</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#parkandcheckinterrupt"><span class="toc-number">4.8.7.1.1.7.</span> <span class="toc-text">parkAndCheckInterrupt</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#cancelacquire"><span class="toc-number">4.8.7.1.1.8.</span> <span class="toc-text">cancelAcquire</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">4.8.7.1.2.</span> <span class="toc-text">公平锁与非公平锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9A%E9%82%A3%E4%BA%9B-%E5%8F%8D%E7%9B%B4%E8%A7%89-%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">4.8.7.1.2.1.</span> <span class="toc-text">关于公平锁：那些“反直觉”的地方</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%8D%E6%9D%82%E7%9A%84%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.8.7.1.2.2.</span> <span class="toc-text">为什么非公平锁不需要复杂的非线性实现？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%98%AF%E7%BC%BA%E7%9C%81%E5%AE%9E%E7%8E%B0-%E4%B8%94%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%EF%BC%9F"><span class="toc-number">4.8.7.1.2.3.</span> <span class="toc-text">为什么非公平锁是缺省实现，且效率更高？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.8.7.1.2.4.</span> <span class="toc-text">关于公平锁&#x2F;非公平锁的经典面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%94%81"><span class="toc-number">4.8.7.2.</span> <span class="toc-text">解锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#release"><span class="toc-number">4.8.7.2.1.</span> <span class="toc-text">release</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#tryrelease"><span class="toc-number">4.8.7.2.1.1.</span> <span class="toc-text">tryRelease</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#unparksuccessor"><span class="toc-number">4.8.7.2.1.2.</span> <span class="toc-text">unparkSuccessor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E4%B8%8E%E5%85%B1%E4%BA%AB"><span class="toc-number">4.8.7.3.</span> <span class="toc-text">独占与共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.8.8.</span> <span class="toc-text">条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.8.8.1.</span> <span class="toc-text">条件对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.8.8.1.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#await"><span class="toc-number">4.8.8.1.2.</span> <span class="toc-text">await</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#addconditionwaiter"><span class="toc-number">4.8.8.1.2.1.</span> <span class="toc-text">addConditionWaiter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#fullyrelease"><span class="toc-number">4.8.8.1.2.2.</span> <span class="toc-text">fullyRelease</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#unlinkcancelledwaiters"><span class="toc-number">4.8.8.1.2.3.</span> <span class="toc-text">unlinkCancelledWaiters</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#isonsyncqueue"><span class="toc-number">4.8.8.1.2.4.</span> <span class="toc-text">isOnSyncQueue</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#isonsyncqueue"><span class="toc-number">4.8.8.1.2.5.</span> <span class="toc-text">isOnSyncQueue</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#transferaftercancelledwait"><span class="toc-number">4.8.8.1.2.6.</span> <span class="toc-text">transferAfterCancelledWait</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#reportinterruptafterwait"><span class="toc-number">4.8.8.1.2.7.</span> <span class="toc-text">reportInterruptAfterWait</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#signal"><span class="toc-number">4.8.8.1.3.</span> <span class="toc-text">signal</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#dosignal"><span class="toc-number">4.8.8.1.3.1.</span> <span class="toc-text">doSignal</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-number">4.8.9.</span> <span class="toc-text">AQS 与中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E4%B8%AD%E6%96%AD%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.8.9.1.</span> <span class="toc-text">两种中断模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E4%B8%AD%E6%96%AD%E7%9A%84%E6%A0%87%E5%87%86%E6%96%B9%E6%B3%95"><span class="toc-number">4.8.9.2.</span> <span class="toc-text">检测中断的标准方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%94%81%E7%9A%84%E8%AE%A1%E6%97%B6waiting%E6%96%B9%E6%B3%95"><span class="toc-number">4.8.9.3.</span> <span class="toc-text">非锁的计时waiting方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#locksupport-park-%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">4.8.9.4.</span> <span class="toc-text">LockSupport.park 的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-number">4.8.9.5.</span> <span class="toc-text">lock 与中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.8.9.6.</span> <span class="toc-text">内部方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#countdownlatch"><span class="toc-number">4.9.</span> <span class="toc-text">CountDownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.9.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await"><span class="toc-number">4.9.2.</span> <span class="toc-text">await</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#acquiresharedinterruptibly"><span class="toc-number">4.9.2.1.</span> <span class="toc-text">acquireSharedInterruptibly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryacquireshared"><span class="toc-number">4.9.2.2.</span> <span class="toc-text">tryAcquireShared</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doacquiresharedinterruptibly"><span class="toc-number">4.9.2.3.</span> <span class="toc-text">doAcquireSharedInterruptibly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setheadandpropagate"><span class="toc-number">4.9.2.4.</span> <span class="toc-text">setHeadAndPropagate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doreleaseshared"><span class="toc-number">4.9.2.5.</span> <span class="toc-text">doReleaseShared</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#countdown"><span class="toc-number">4.9.3.</span> <span class="toc-text">countDown</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#releaseshared"><span class="toc-number">4.9.3.1.</span> <span class="toc-text">releaseShared</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryreleaseshared"><span class="toc-number">4.9.3.2.</span> <span class="toc-text">tryReleaseShared</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cyclicbarrier"><span class="toc-number">4.10.</span> <span class="toc-text">CyclicBarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8Ccountdownlatch-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.10.1.</span> <span class="toc-text">和CountDownLatch 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E8%80%85%E7%9A%84%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.10.2.</span> <span class="toc-text">作者的官方示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%8B%86%E8%A7%A3"><span class="toc-number">4.10.3.</span> <span class="toc-text">成员拆解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.10.4.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await"><span class="toc-number">4.10.5.</span> <span class="toc-text">await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dowait"><span class="toc-number">4.10.6.</span> <span class="toc-text">dowait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA-breakbarrier"><span class="toc-number">4.10.7.</span> <span class="toc-text">异常退出 breakBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E9%80%80%E5%87%BA-nextgeneration"><span class="toc-number">4.10.8.</span> <span class="toc-text">正常退出 nextGeneration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE-reset"><span class="toc-number">4.10.9.</span> <span class="toc-text">重置 reset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">4.10.10.</span> <span class="toc-text">统计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#isbroken"><span class="toc-number">4.10.10.1.</span> <span class="toc-text">isBroken</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getnumberwaiting"><span class="toc-number">4.10.10.2.</span> <span class="toc-text">getNumberWaiting</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#semaphore"><span class="toc-number">4.11.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.11.1.</span> <span class="toc-text">官方示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.11.2.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90%EF%BC%9A%E5%9B%9B%E5%A4%A7-acquire-%E6%96%B9%E6%B3%95"><span class="toc-number">4.11.3.</span> <span class="toc-text">获取资源：四大 acquire 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#acquireshared"><span class="toc-number">4.11.3.1.</span> <span class="toc-text">acquireShared</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryacquireshared"><span class="toc-number">4.11.3.2.</span> <span class="toc-text">tryAcquireShared</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3"><span class="toc-number">4.11.3.2.1.</span> <span class="toc-text">公平</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3"><span class="toc-number">4.11.3.2.2.</span> <span class="toc-text">非公平</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">4.11.4.</span> <span class="toc-text">释放资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tryreleaseshared"><span class="toc-number">4.11.4.1.</span> <span class="toc-text">tryReleaseShared</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.12.</span> <span class="toc-text">从执行器到线程池</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>