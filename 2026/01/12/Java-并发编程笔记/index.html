<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 并发编程笔记 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 MESA 模型 JAVA 采用 MESA 模型：  互斥（Mutual Exclusion">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 并发编程笔记">
<meta property="og:url" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 MESA 模型 JAVA 采用 MESA 模型：  互斥（Mutual Exclusion">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png">
<meta property="article:published_time" content="2026-01-12T14:28:12.000Z">
<meta property="article:modified_time" content="2026-01-24T07:32:08.682Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 并发编程笔记",
  "url": "https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
  "image": "https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png",
  "datePublished": "2026-01-12T14:28:12.000Z",
  "dateModified": "2026-01-24T07:32:08.682Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 并发编程笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 并发编程笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java 并发编程笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-12T14:28:12.000Z" title="Created 2026-01-12 22:28:12">2026-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-24T07:32:08.682Z" title="Updated 2026-01-24 15:32:08">2026-01-24</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">49.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>200mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><img src="juc.png" alt="juc.png"><br>
<a href="juc.xmind">juc.xmind</a></p>
<h1>写在前面的话</h1>
<p>并发编程最早的实践都在操作系统里。</p>
<h2 id="管程">管程</h2>
<p>理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。</p>
<h2 id="mesa-模型">MESA 模型</h2>
<p>JAVA 采用 MESA 模型：</p>
<ul>
<li>互斥（Mutual Exclusion）：通过锁机制保证同一时刻只有一个线程能进入管程内部执行。</li>
<li>同步（Synchronization）：利用条件变量（Condition Variable）实现线程间的等待与唤醒。</li>
<li>Signal and Continue：</li>
</ul>
<blockquote>
<p>当线程发出通知（signal/notify）时，它继续持有锁并运行，而被唤醒的线程仅仅是进入就绪队列，并不立即抢占 CPU。</p>
</blockquote>
<ul>
<li>必须使用 while 循环：</li>
</ul>
<blockquote>
<p>由于线程被唤醒后不一定立即执行，当它重新获得锁时，环境条件可能已发生变化，因此必须在一个 while 循环中重新检查等待条件（while<br>
(condition) { wait(); }）。</p>
</blockquote>
<h3 id="为什么用-set-而不用-queue">为什么用 set 而不用 queue</h3>
<ol>
<li>Queue 暗示 FIFO（先进先出）：</li>
</ol>
<ul>
<li>如果我们叫它 EntryQueue，开发者会本能地认为：先来的线程一定先拿到锁。</li>
<li>但实际上，Java 的 synchronized 是非公平锁（Non-fair Lock）。</li>
</ul>
<ol start="2">
<li>实际上更像“一堆人”而不是“一队人”：</li>
</ol>
<ul>
<li>在 JVM 的具体实现策略中，当锁被释放时，并不保证 EntrySet 中排在最前面的线程一定能抢到锁（可能被刚来的线程抢走，或者被随机唤醒）。</li>
<li>对于 WaitSet，notify() 唤醒的线程也不一定是先 wait() 的那个线程（取决于具体 JVM 实现）。</li>
<li>所以，用 Set（集合） 这个词能更准确地表达“这里有一群线程在等，但谁先出去不一定”的语义。</li>
</ul>
<p>总结：叫 Set 是为了告诉你，不要依赖它们的唤醒顺序。</p>
<h3 id="模型映射">模型映射</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Mesa 模型</th>
<th style="text-align:left">Mesa 语义</th>
<th style="text-align:left"><code>synchronized</code></th>
<th style="text-align:left"><code>ReentrantLock</code></th>
<th style="text-align:left">Java State</th>
<th style="text-align:left">超时</th>
<th style="text-align:left">JVisualVM</th>
<th style="text-align:left">底层机制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Entry Set</strong><br>(锁竞争)</td>
<td style="text-align:left">等待获取锁</td>
<td style="text-align:left">Monitor Entry List</td>
<td style="text-align:left">AQS Sync Queue</td>
<td style="text-align:left"><code>BLOCKED</code><br><code>WAITING (parking)</code></td>
<td style="text-align:left">❌</td>
<td style="text-align:left">Monitor<br>Park</td>
<td style="text-align:left">ObjectMonitor<br>LockSupport.park()</td>
</tr>
<tr>
<td style="text-align:left"><strong>Wait Set</strong><br>(条件等待)</td>
<td style="text-align:left">等待条件满足</td>
<td style="text-align:left">Monitor Wait Set</td>
<td style="text-align:left">AQS Condition Queue</td>
<td style="text-align:left"><code>WAITING</code><br><code>TIMED_WAITING</code></td>
<td style="text-align:left">✅</td>
<td style="text-align:left">Wait<br>Park</td>
<td style="text-align:left">ObjectMonitor<br>LockSupport.park()</td>
</tr>
<tr>
<td style="text-align:left"><strong>Owner</strong><br>(持有者)</td>
<td style="text-align:left">持有锁的线程</td>
<td style="text-align:left">Monitor Owner</td>
<td style="text-align:left">exclusiveOwnerThread</td>
<td style="text-align:left"><code>RUNNABLE</code></td>
<td style="text-align:left">-</td>
<td style="text-align:left">Running</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<h4 id="1-mesa-模型的-signal-and-continue-语义">1. Mesa 模型的 “Signal and Continue” 语义</h4>
<ul>
<li><code>notify()</code> / <code>signal()</code> 后，通知者<strong>继续持有锁</strong></li>
<li>被唤醒的线程从 Wait Set 移入 Entry Set，必须<strong>重新竞争锁</strong></li>
<li>唤醒路径：
<ul>
<li><code>synchronized</code>: Wait Set → Entry Set (<code>BLOCKED</code>) → Owner</li>
<li><code>ReentrantLock</code>: Condition Queue → Sync Queue (<code>WAITING</code>) → Owner</li>
</ul>
</li>
</ul>
<h4 id="2-entry-set-锁竞争-❌-永远不会有-timed-waiting">2. Entry Set（锁竞争）❌ 永远不会有 TIMED_WAITING</h4>
<ul>
<li><code>synchronized</code> 不支持超时</li>
<li><code>ReentrantLock.lock()</code> 不支持超时</li>
<li><code>tryLock(timeout)</code> 不进队列，在当前线程自旋</li>
</ul>
<h4 id="3-wait-set-条件等待-✅-支持-timed-waiting">3. Wait Set（条件等待）✅ 支持 TIMED_WAITING</h4>
<ul>
<li><code>wait(timeout)</code> / <code>await(timeout, unit)</code> 支持超时</li>
<li>设计哲学：条件等待是主动等待业务条件，需要&quot;等不到就放弃&quot;的语义</li>
</ul>
<h4 id="4-jvisualvm-分类逻辑">4. JVisualVM 分类逻辑</h4>
<ul>
<li><strong>Monitor</strong>: <code>synchronized</code> 的 <code>BLOCKED</code> 状态</li>
<li><strong>Park</strong>: <code>LockSupport.park()</code> 导致的 <code>WAITING</code> 状态</li>
<li><strong>Wait</strong>: <code>Object.wait()</code> 导致的 <code>WAITING</code> 状态</li>
</ul>
<h4 id="5-线程状态与-os-调度">5. 线程状态与 OS 调度</h4>
<ul>
<li><strong>RUNNABLE</strong> = OS Ready + OS Running（JVM 无法区分）</li>
<li><strong>BLOCKED</strong> / <strong>WAITING</strong>: 线程在 JVM 队列中，未持有 CPU</li>
<li>Ready Queue 是 OS 层面的，JVM 不可见</li>
</ul>
<h1>Java 线程状态</h1>
<p><img src="java-thread-state.png" alt="java-thread-state.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MesaMonitorExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionSatisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// === 等待者线程 (Thread-A) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWait</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// [阶段 1]：尝试进入 synchronized 块</span><br>        <span class="hljs-comment">// 状态详情：</span><br>        <span class="hljs-comment">// 1. Monitor 锁：未持有（正在 Entry Set 排队竞争）</span><br>        <span class="hljs-comment">// 2. CPU：未持有（被 OS 挂起）</span><br>        <span class="hljs-comment">// 3. Mesa Set：处于 Entry Set (入口队列/锁池)</span><br>        <span class="hljs-comment">// 4. 线程状态：BLOCKED</span><br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// ============================================================</span><br>            <span class="hljs-comment">// [微观状态间隙 - 从抢到锁到执行第一行代码]</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 1. 【Lock Acquired】：</span><br>            <span class="hljs-comment">//    Monitor 锁竞争成功。线程从 Entry Set 移出，成为 Owner。</span><br>            <span class="hljs-comment">//    Java 线程状态：BLOCKED -&gt; RUNNABLE。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 2. 【OS Scheduling (Ready)】：</span><br>            <span class="hljs-comment">//    虽然 Java 认为你是 RUNNABLE，但在 OS 看来，你只是进入了</span><br>            <span class="hljs-comment">//    &quot;CPU 就绪队列&quot; (Ready Queue)，正在等待分配时间片。JVM 本身并不理解 OS 的这个队列，所以 RUNNABLE 包含了“可以运行”和“正在运行”两种状态。</span><br>            <span class="hljs-comment">//    此时：持有锁 | 未持有 CPU | 状态：RUNNABLE (Ready)。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 3. 【Context Switch (Running)】：</span><br>            <span class="hljs-comment">//    OS 调度器选中了本线程，加载寄存器，PC 指针指向下一行指令。</span><br>            <span class="hljs-comment">//    此时：持有锁 | 持有 CPU | 状态：RUNNABLE (Running)。</span><br>            <span class="hljs-comment">// ============================================================</span><br>            <br>            <span class="hljs-comment">// [阶段 2]：真正执行代码</span><br>            <span class="hljs-comment">// 状态详情：持有锁 | 持有 CPU | Owner (持有者) | RUNNABLE (Running)</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Acquired lock, checking condition...&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (!conditionSatisfied) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Condition false, calling wait()...&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// [阶段 3：主动入冷宫 - 调用 wait()]</span><br>                    <span class="hljs-comment">// 状态详情（执行瞬间）：</span><br>                    <span class="hljs-comment">// 1. Monitor 锁：原子性释放</span><br>                    <span class="hljs-comment">// 2. CPU：主动放弃</span><br>                    <span class="hljs-comment">// 3. Mesa Set：从 Owner 移入 Wait Set (第一重队列)</span><br>                    <span class="hljs-comment">// 4. 线程状态：RUNNABLE -&gt; WAITING</span><br>                    <span class="hljs-comment">// 注意：此时线程完全“睡死”，必须等待 notify 救援</span><br>                    lock.wait(); <br>                    <br>                    <span class="hljs-comment">// ============================================================</span><br>                    <span class="hljs-comment">// [阶段 4：漫长的回归之路 - 穿越“两重队列”]</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 1. 【被 notify 唤醒时】：</span><br>                    <span class="hljs-comment">//    Thread-A 从 Wait Set 移出，直接被扔进 Entry Set (第二重队列)。</span><br>                    <span class="hljs-comment">//    因为锁还在通知者手里！</span><br>                    <span class="hljs-comment">//    此时状态：WAITING -&gt; BLOCKED。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 2. 【等待锁释放】：</span><br>                    <span class="hljs-comment">//    在 Entry Set 中排队，直到通知者离开 synchronized。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 3. 【竞争锁 &amp; OS 调度】：</span><br>                    <span class="hljs-comment">//    抢到锁 -&gt; BLOCKED 变 RUNNABLE (Ready) -&gt; 获得 CPU (Running)。</span><br>                    <span class="hljs-comment">// ============================================================</span><br><br>                    <span class="hljs-comment">// [阶段 5：重回舞台]</span><br>                    <span class="hljs-comment">// 此时 Thread-A 已经成功拿回了锁和 CPU</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Woke up, re-acquired lock.&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Condition met, doing work.&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// [阶段 6]：离开 synchronized 块</span><br>        <span class="hljs-comment">// 状态详情：释放锁 | 持有 CPU | 离开 Owner 变为 Outside | RUNNABLE</span><br>    &#125;<br><br>    <span class="hljs-comment">// === 通知者线程 (Thread-B) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doNotify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// [阶段 7]：获取锁</span><br>            <span class="hljs-comment">// 状态详情：持有锁 | 持有 CPU | Owner | RUNNABLE</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Acquired lock, changing condition...&quot;</span>);<br>            conditionSatisfied = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// [阶段 8：只管唤醒，不管开门]</span><br>            <span class="hljs-comment">// 状态详情（关键点）：</span><br>            <span class="hljs-comment">// 1. Monitor 锁：仍然持有！(Signal and Continue)</span><br>            <span class="hljs-comment">// 2. Mesa Set：Owner（Thread-B 还在舞台上）</span><br>            <span class="hljs-comment">// 3. 对 Thread-A 的影响：将 A 从 Wait Set 移入 Entry Set (BLOCKED)</span><br>            lock.notify(); <br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Notified, but STILL holding lock.&quot;</span>);<br>            <br>            <span class="hljs-comment">// 模拟 Thread-B 继续占用锁，此时 Thread-A 只能在 Entry Set 阻塞</span><br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>        &#125; <br>        <span class="hljs-comment">// [阶段 9：真正放手]</span><br>        <span class="hljs-comment">// 离开 synchronized 块，释放 Monitor 锁。</span><br>        <span class="hljs-comment">// 此时 Entry Set 里的 Thread-A 才有机会去抢锁，完成它的“回归之路”。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockExample</span> &#123;<br>    <span class="hljs-comment">// 显式锁（替代 synchronized）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 显式条件变量（替代 Object monitor methods）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionSatisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// === 等待者线程 (Thread-A) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAwait</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// [阶段 1]：尝试获取锁</span><br>        <span class="hljs-comment">// 状态详情：</span><br>        <span class="hljs-comment">// 1. AQS State：尝试 CAS 修改 state。</span><br>        <span class="hljs-comment">// 2. AQS Queue：如果失败，进入 AQS Sync Queue (同步队列) 排队。</span><br>        <span class="hljs-comment">// 3. 线程状态：BLOCKED (Parked)。</span><br>        lock.lock(); <br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ============================================================</span><br>            <span class="hljs-comment">// [微观状态间隙 - AQS 版]</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 1. 【Lock Acquired】：</span><br>            <span class="hljs-comment">//    CAS 成功，或被前驱节点唤醒。</span><br>            <span class="hljs-comment">//    线程从 AQS Sync Queue 移出 (Head 节点后继)。</span><br>            <span class="hljs-comment">//    State：BLOCKED -&gt; RUNNABLE。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 2. 【OS Scheduling】：</span><br>            <span class="hljs-comment">//    进入 OS Ready Queue，等待 CPU。JVM 本身并不理解 OS 的这个队列，所以 RUNNABLE 包含了“可以运行”和“正在运行”两种状态。</span><br>            <span class="hljs-comment">//    此时：持有 ReentrantLock | 未持有 CPU。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 3. 【Running】：</span><br>            <span class="hljs-comment">//    获得 CPU 时间片，开始执行下一行。</span><br>            <span class="hljs-comment">// ============================================================</span><br><br>            <span class="hljs-comment">// [阶段 2]：真正执行代码</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Acquired lock, checking condition...&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (!conditionSatisfied) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Condition false, calling await()...&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// [阶段 3：主动入冷宫 - 调用 await()]</span><br>                    <span class="hljs-comment">// 状态详情（执行瞬间）：</span><br>                    <span class="hljs-comment">// 1. Lock 释放：彻底释放锁（fullyRelease），无论重入多少次。</span><br>                    <span class="hljs-comment">// 2. Mesa 位置：</span><br>                    <span class="hljs-comment">//    a. 构造一个 Node，加入 Condition Queue (条件队列)。</span><br>                    <span class="hljs-comment">//    b. 线程被挂起 (LockSupport.park)。</span><br>                    <span class="hljs-comment">// 3. 线程状态：RUNNABLE -&gt; WAITING。</span><br>                    condition.await(); <br>                    <br>                    <span class="hljs-comment">// ============================================================</span><br>                    <span class="hljs-comment">// [阶段 4：AQS 内部的漫长回归之路]</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 1. 【Signal 发生时】：</span><br>                    <span class="hljs-comment">//    Thread-A 的 Node 从 Condition Queue 被“踢”到了 AQS Sync Queue 尾部。</span><br>                    <span class="hljs-comment">//    注意：此时它仅仅是换了个队排，锁还在 Signal 线程手里！</span><br>                    <span class="hljs-comment">//    状态：WAITING -&gt; BLOCKED (等待获取锁)。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 2. 【等待锁释放】：</span><br>                    <span class="hljs-comment">//    在 AQS Sync Queue 中自旋或挂起，直到轮到自己。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 3. 【抢锁成功】：</span><br>                    <span class="hljs-comment">//    acquireQueued 返回，从 await() 方法内部返回。</span><br>                    <span class="hljs-comment">// ============================================================</span><br><br>                    <span class="hljs-comment">// [阶段 5：重回舞台]</span><br>                    <span class="hljs-comment">// 此时 Thread-A 处于 AQS Sync Queue 的 Head 位置并拿到了锁</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Woke up, re-acquired lock.&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Condition met, doing work.&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// [阶段 6]：释放锁</span><br>            <span class="hljs-comment">// 必须在 finally 中释放！</span><br>            <span class="hljs-comment">// 动作：修改 AQS state，唤醒 AQS Sync Queue 中的下一个节点 (Successor)。</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// === 通知者线程 (Thread-B) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">()</span> &#123;<br>        lock.lock(); <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// [阶段 7]：持有锁执行业务</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Acquired lock, changing condition...&quot;</span>);<br>            conditionSatisfied = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// [阶段 8：只管迁移，不管开门]</span><br>            <span class="hljs-comment">// 关键点：signal() 仅仅是将节点从 Condition Queue 转移到 AQS Sync Queue。</span><br>            <span class="hljs-comment">// Thread-B **仍然持有锁**！</span><br>            <span class="hljs-comment">// Thread-A 此时在 AQS Sync Queue 尾部排队，状态从 WAITING 变为了 BLOCKED。</span><br>            condition.signal(); <br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Signaled, but STILL holding lock.&quot;</span>);<br>            <br>            <span class="hljs-comment">// 模拟业务耗时</span><br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// [阶段 9：真正放手]</span><br>            <span class="hljs-comment">// 释放锁 (state = 0)。</span><br>            <span class="hljs-comment">// 此时 AQS Sync Queue 里的 Thread-A (如果排在前面的话) 被 unpark 唤醒，</span><br>            <span class="hljs-comment">// 从而完成 await() 的返回。</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Releasing lock...&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="线程状态列举">线程状态列举</h2>
<h3 id="new">NEW</h3>
<p>没有启动过的线程。</p>
<h3 id="runnable">RUNNABLE</h3>
<ol>
<li>正在执行的线程。</li>
<li>可以被执行但没有拿到处理器资源。</li>
</ol>
<h3 id="blocked">BLOCKED</h3>
<p>blocked 其实是 blocked waiting。</p>
<ol>
<li>等待 monitor，进入 synchronized method/block</li>
<li>或者等 wait()/await()以后再次进入 synchronized method/block。解除 wait 以后以后不是直接 runnable，而是进入 blocked，如果 notify 后通知线程立刻离开同步块，则几乎不可能用程序观察到从 blocked 进入 runnable。如果通知者在 notify() 之后赖着不走（比如执行了一个耗时操作），或者同时有 100 个线程在竞争这把锁：
<ul>
<li>那个被唤醒的线程会长时间停留在 BLOCKED 状态，直到它抢到锁为止。可以通过 jstack 或者 Thread.getState() 清晰地观察到它处于 BLOCKED 状态。</li>
</ul>
</li>
</ol>
<h3 id="waiting">WAITING</h3>
<p>在调用这三种不计时方法以后，线程进入 waiting 态：</p>
<ul>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.park 我们经常在文档里看到的 thread lies dormant 就是被这个方法处理过的结果</li>
</ul>
<p>waiting 意味着一个线程在等待另一个线程做出某种 action。wait 在等其他对象 notify 和 notifyAll，join 在等其他线程终结。</p>
<p>如：<br>
<code>java.util.concurrent.LinkedBlockingQueue.take -&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await -&gt; java.util.concurrent.locks.LockSupport.park</code></p>
<p>Reentrantlock 的 lock 接口的栈帧则是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sun<span class="hljs-selector-class">.misc</span><span class="hljs-selector-class">.Unsafe</span><span class="hljs-selector-class">.park</span> 行: 不可用 <span class="hljs-selector-attr">[本地方法]</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.LockSupport</span><span class="hljs-selector-class">.park</span> 行: <span class="hljs-number">175</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.parkAndCheckInterrupt</span> 行: <span class="hljs-number">836</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquireQueued</span> 行: <span class="hljs-number">870</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquire</span> 行: <span class="hljs-number">1199</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span><span class="hljs-selector-class">.lock</span> 行: <span class="hljs-number">209</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.ReentrantLock</span><span class="hljs-selector-class">.lock</span> 行: <span class="hljs-number">285</span> <br></code></pre></td></tr></table></figure>
<p>jstack 总会告诉我们 waiting 的位置，比如等待某个 Condition 的 await 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;t1 before lock&quot;</span>);<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 此时 t1 是 Runnable</span><br>            queue.put(<span class="hljs-number">1</span>); <span class="hljs-comment">// 此时刺激主线程开始读 t2</span><br>            System.out.println(<span class="hljs-string">&quot;t1 begin to sleep&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1 prepare to release lock&quot;</span>);<br>        lock.unlock();<br>        System.out.println(<span class="hljs-string">&quot;t1 release lock&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t2 before lock&quot;</span>);<br>        <span class="hljs-comment">// 此时 t2 可能被 t1 阻塞，进入 waiting 状态</span><br>        lock.lock();<br>        System.out.println(<span class="hljs-string">&quot;t2 prepare to release lock&quot;</span>);<br>        lock.unlock();<br>        System.out.println(<span class="hljs-string">&quot;t2 release lock&quot;</span>);<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>    t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>    t1.start();<br>    t2.start();<br>    <span class="hljs-comment">// 此时主线程在等待一个信号来刺激自己往下走</span><br>    queue.take();<br>    <span class="hljs-comment">// 往下走的目的就是校验 t2 的状态</span><br>    <span class="hljs-keyword">while</span> (t2.isAlive()) &#123;<br>        System.out.println(t2.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对这个程序进行 thread dump，可以看出 ReentrantLock 就是依赖于 park 导致的 waiting：</p>
<p><img src="parking%E5%8D%B3waiting.png" alt="parking即waiting.png"><br>
<img src="sleeping%E5%8D%B3timed-waiting.png" alt="sleeping即timed-waiting.png"></p>
<p>如果使用 synchronized，则会显示 object monitor：</p>
<p><img src="object-monitor.png" alt="object-monitor.png"></p>
<p>所以 waiting 可能是在条件变量上等待，也可能是在 synchronizer 本身上等待，不可一概而论。</p>
<p>按照 jvisualvm 的分类方法，线程还可以分为：</p>
<ul>
<li>等待</li>
<li>驻留（park）</li>
<li>监视（monitor）</li>
</ul>
<h3 id="timed-waiting">TIMED_WAITING</h3>
<p>调用了计时方法，等待时间结束后才或者被其他唤醒方法唤醒结束等待。</p>
<ul>
<li>Thread.sleep</li>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUntil</li>
</ul>
<p>如：</p>
<p><code>java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take -&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos -&gt; java.util.concurrent.locks.LockSupport.parkNanos -&gt; sun.misc.Unsafe.park</code></p>
<p>除了 sleep 以外，jstack 总会告诉我们 time_waiting 的位置，比如等待某个 Condition 的 await 操作。</p>
<h3 id="terminated">TERMINATED</h3>
<p>终结的线程，执行已经结束了。</p>
<p>中断退出也是一种结束。</p>
<h3 id="几种线程状态的对比">几种线程状态的对比</h3>
<ol>
<li>blocked：线程想要获取锁进入临界区之前，会求锁，求不到锁会进入 entry_set，然后放弃 cpu。高并发时 blocked 会增多。</li>
<li>工作线程池开始伸缩，扩容的时候：jvm.thread.waiting.count 的数量会变少。过程是，core 线程先满，然后队列再满，这时候等待从队列里获取任务，waiting 在 take 动作上的线程已经降为0了，然后开始产生非core线程，线程数才开始增长。</li>
<li>工作吞吐变多，而调用下游的工作线程在阻塞的时候，jvm.thread.time_waiting.count 会变多，因为 rpc 框架自带超时，而这些超时是会让工作线程进行计时等待的。</li>
<li>流量变大的时候，2 和 3 可能同时发生。</li>
</ol>
<h2 id="线程间方法的设计哲学">线程间方法的设计哲学</h2>
<ol>
<li>通常：
<ol>
<li>静态方法 = “我要操作当前线程”（self-operation）。static 相当于 per thread，一个好记的例子是通常 ThreadLocal 设置为 static 的，这样每个线程可以分到一个它的实例，而不是每个线程在每个对象里分到它的实例。</li>
<li>实例方法 = “我要操作指定线程”（cross-thread operation）。</li>
</ol>
</li>
<li>这背后的逻辑是：
<ol>
<li>每个线程操作自己是比较安全的，static 可以默认在不指定对象的情况下操作自己。</li>
<li>而跨线程操作其他线程是比较危险的，因为其他线程的生死如果不是自然发展和结束的，很可能导致锁不释放，条件变量不正确设置，通知没有正确发出。这也就意味着系统可能死锁。
<ol>
<li>主动控制线程何时开始是安全的。</li>
<li>主动控制进程何时结束是危险的，因为你不能替他释放资源-这是禁止使用 stop、spend api 这类操作的全部理由。</li>
</ol>
</li>
<li>可以跨线程操作的是比较温和的操作：
<ol>
<li>start()：可以让程序员开启线程周期。</li>
<li>interrupt()：可以设置一个标志位，算是轻微的主动写入别的线程状态的一种低侵入的 api。</li>
<li>join(): 观测另一个对象的状态，通过内部自旋 wait 来等待另一个线程死亡。</li>
</ol>
</li>
<li>其他 static 方法：
<ol>
<li>yield()：主动让出 CPU，让同优先级线程有机会运行。是对调度器的&quot;建议&quot;，不保证效果。和 interrupt 的温和写入，但不必然强制操作形成对比。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="特别的切换方法">特别的切换方法</h2>
<h3 id="locksupport-park">LockSupport.park</h3>
<p>也就是线程挂起。</p>
<p>condition 的 await 底层调用的是 LockSupport.park。这个方法的参数是一个用作 monitor 的对象，会被设置到 Object 的特定 Offset 上。</p>
<p>park 只能带来 waiting。所以 sync 和 conditionObject 其实都让 thread waiting ，只不过代表 thread 的 node 处在的队列不一样而已-线程 node 在 sync queue 和 condition queue 都是 waiting。</p>
<h3 id="wait">wait</h3>
<p>这个方法是对 object 用的。</p>
<p>从 wait 中醒来会有伪唤醒的 case，所以醒来的时候一定要先检查唤醒条件是否已经得到满足。原理见<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/271521213">《为什么条件锁会产生虚假唤醒现象（spurious wakeup）？》</a></p>
<h3 id="join">join</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待此线程终止，最多等待 millis 毫秒。超时值为 0 表示永久等待。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 设计巧妙之处（三个关键角色的分离）：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 当 th1 调用 th2.join() 时：</span><br><span class="hljs-comment"> * 1. 锁对象：th2（Thread 对象）</span><br><span class="hljs-comment"> * 2. 检查对象：th2（通过 isAlive() 检查）</span><br><span class="hljs-comment"> * 3. 等待线程：th1（调用 wait() 的线程）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 执行流程：</span><br><span class="hljs-comment"> * - th1 获取 th2 对象的 Monitor 锁</span><br><span class="hljs-comment"> * - th1 检查 th2.isAlive()</span><br><span class="hljs-comment"> * - th1 在 th2 对象上调用 wait()，释放锁并挂起</span><br><span class="hljs-comment"> * - th2 执行完毕时，JVM 自动调用 th2.notifyAll()</span><br><span class="hljs-comment"> * - th1 被唤醒，重新检查 th2.isAlive()（协作式逻辑）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * Thread 对象的特殊性：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 1. 普通对象（Object、String 等）：</span><br><span class="hljs-comment"> *    - 没有内置状态可以自动触发 notify()</span><br><span class="hljs-comment"> *    - wait/notify 完全由程序员手动控制</span><br><span class="hljs-comment"> *    - 适合作为条件变量</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 2. Thread 对象（特殊对象）：</span><br><span class="hljs-comment"> *    - 有内置状态：线程生命周期（NEW → RUNNABLE → TERMINATED）</span><br><span class="hljs-comment"> *    - 状态变化触发通知：线程终止时，JVM 自动调用 notifyAll()</span><br><span class="hljs-comment"> *    - 不适合作为条件变量：会出现程序设计之外的 notifyAll()</span><br><span class="hljs-comment"> *    - Javadoc 警告：&quot;不建议在 Thread 实例上使用 wait/notify/notifyAll&quot;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 为什么 JVM 要自动 notifyAll()？</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * - 设计目的：专门为 join() 而设计</span><br><span class="hljs-comment"> * - 常见需求：等待线程结束是非常常见的并发模式</span><br><span class="hljs-comment"> * - 简化编程：无需手动管理通知逻辑</span><br><span class="hljs-comment"> * - 设计哲学：Thread 对象代表执行流，生命周期结束是重要事件</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 协作式编程体现：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * - OS 调度（抢占式）：JVM/OS 决定何时给 th1 CPU 时间片</span><br><span class="hljs-comment"> * - 业务逻辑（协作式）：th1 主动检查 isAlive()，决定是否继续等待</span><br><span class="hljs-comment"> * - while 循环的意义：不是&quot;被唤醒就执行&quot;，而是&quot;醒来后检查条件&quot;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  millis 等待的毫秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException 如果 millis 为负数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException 如果当前线程被中断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 记录开始时间，用于计算已等待时长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 无超时版本：永久等待直到线程结束</span><br>        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 协作式编程的核心：while 循环主动检查条件</span><br>            <span class="hljs-comment">// - isAlive() 检查的是 this（th2）的状态</span><br>            <span class="hljs-comment">// - wait(0) 挂起的是调用线程（th1）</span><br>            <span class="hljs-comment">// - 使用 while 而非 if，防止伪唤醒（spurious wakeup）</span><br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-comment">// 调用线程（th1）在 this（th2）对象上等待</span><br>                <span class="hljs-comment">// 等价于：th2.wait(0)</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 释放 th2 对象的 Monitor 锁，th1 进入 WAITING 状态</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 可能的唤醒原因：</span><br>                <span class="hljs-comment">// 1. th2 结束，JVM 自动调用 th2.notifyAll()（Thread 对象的特殊性）</span><br>                <span class="hljs-comment">// 2. 伪唤醒（spurious wakeup）</span><br>                wait(<span class="hljs-number">0</span>);<br>                <br>                <span class="hljs-comment">// 被唤醒后，重新检查 isAlive()（协作式逻辑）</span><br>                <span class="hljs-comment">// 如果是伪唤醒且 th2 还活着，继续 wait</span><br>                <span class="hljs-comment">// 如果 th2 已死，退出循环</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 带超时版本：等待指定时间或线程结束</span><br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-comment">// 计算剩余等待时间</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis - now;<br>                <br>                <span class="hljs-comment">// 超时检查：如果已经等待了足够长的时间，退出循环</span><br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 调用线程（th1）在 this（th2）对象上等待 delay 毫秒</span><br>                <span class="hljs-comment">// 等价于：th2.wait(delay)</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 可能的唤醒原因：</span><br>                <span class="hljs-comment">// 1. th2 结束，JVM 自动调用 th2.notifyAll()</span><br>                <span class="hljs-comment">// 2. 超时时间到</span><br>                <span class="hljs-comment">// 3. 伪唤醒</span><br>                wait(delay);<br>                <br>                <span class="hljs-comment">// 更新已等待时长</span><br>                now = System.currentTimeMillis() - base;<br>                <br>                <span class="hljs-comment">// 循环继续，重新检查 isAlive() 和剩余时间（协作式逻辑）</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 退出方法时，释放 th2 对象的 Monitor 锁</span><br>        <span class="hljs-comment">// th1 继续执行后续代码</span><br>    &#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>线程的 join 相当于当前线程在另一个会死亡的线程对象上等待，在 while 循环里无限  wait，在超时或者该线程死亡的时候从 wait 里解脱出来。</li>
<li>每个 thread 对象的内置状态变成死亡的时候，JVM 会主动调用这个对象的 notifyAll，这和任意条件对象的 wait 和 notifyAll 由程序员自己控制是不一样的。</li>
</ol>
<h1>JMM</h1>
<h2 id="volatile">Volatile</h2>
<p><img src="volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" alt="volatile的可见性影响.png"></p>
<h1>JUC</h1>
<p><img src="juc-class-diagram.png" alt="juc-class-diagram.png"></p>
<h2 id="总体设计原则">总体设计原则</h2>
<ul>
<li>有状态管理的核心组件：
<ul>
<li>FutureTask：任务执行状态</li>
<li>ThreadPoolExecutor：线程池生命周期状态</li>
<li>Worker：工作线程锁状态</li>
<li>BlockingQueue：任务队列状态</li>
<li>Thread：操作系统线程状态</li>
</ul>
</li>
<li>Doug Lea 特别热衷于使用顺序状态来表达初始、中间态和终态，往往使用 &lt;= 中间态当作初始态，&gt;= 中间态当作完成态（包括 normal 和 exceptional）。“用最少的状态变量，表达最精确的状态转换。”
<ul>
<li>原子变量优先于锁</li>
<li>状态编码（Packing）</li>
<li>无锁算法（Lock-Free）</li>
<li>状态转换的精确性</li>
</ul>
</li>
<li>有一些变量内存不安全，强依赖于 happen-before relation 的<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/14432400/why-outcome-object-in-futuretask-is-non-volatile">巧妙实现</a>，也需要参考<a href="##Volatile">Volatile</a>。</li>
<li>Doug Lea 不喜欢写大括号。</li>
<li>对于所有的计时等待而言，0 意味着无限等待。</li>
<li>链表的特性：
<ul>
<li>在初始时，链表总是先初始化 head，cas 成功，然后用 head 赋值给 tail，使其最初相等，但读值的时候顺序是反过来的-利用了 volatile 的内存屏障的特性。</li>
<li>只要有一个 cas 操作成功，包裹住剩下的 volatile 写都不需要再做 cas。所以通常对 AQS 自身的全局状态的 cas 是和链表自身状态的 link/unlink 操作是分开的。</li>
<li>所有要被 cas 的链表元素/aqs state，在局部代码运行前，要被先用局部变量存储起来，写在 block 的最开始。这样做可以提高复用性，减少多次对 volatile 变量的求值，避免对缓存机制的扰乱，也保证了变量的线程封闭性。在全局也有一些 global state。</li>
</ul>
</li>
<li>有副作用的方法，副作用包括修改全局变量、park、unpark、修改中断位，返回值通常是主要操作的成败。有时候用 int 代表多种返回值。</li>
</ul>
<h2 id="unsafe-的应用">Unsafe 的应用</h2>
<p>JUC 强依赖于 Unsafe，它提供了硬件级别的 CAS 原子操作。在 X86 上，这个 CAS 操作依赖于 cmpxchg 指令，会锁定总线。所以仍然会产生一些硬件锁。</p>
<p>通常 Unsafe 的使用模式是<code>compareAndSwapXXX</code>，一个典型的函数是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSwapObject</span><span class="hljs-params">(Object obj, <span class="hljs-type">long</span> offset, Object expect, Object update)</span>;<br></code></pre></td></tr></table></figure>
<ul>
<li>obj是我们要操作的目标对象</li>
<li>offset表示了目标对象中，对应的属性的内存偏移量</li>
<li>expect是进行比较的原值</li>
<li>update是拟写入的新值</li>
</ul>
<h3 id="获取-field">获取 field</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; k = FutureTask.class;<br><span class="hljs-type">Field</span> <span class="hljs-variable">stateField</span> <span class="hljs-operator">=</span> k.getDeclaredField(<span class="hljs-string">&quot;state&quot;</span>);<br></code></pre></td></tr></table></figure>
<p>进而获取 field 的偏移：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">long</span> <span class="hljs-title function_">objectFieldOffset</span><span class="hljs-params">(Field field)</span>;<br></code></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">tailOffset = unsafe.objectFieldOffset<br>            (AbstractQueuedSynchronizer.class.getDeclaredField(<span class="hljs-string">&quot;tail&quot;</span>));<br></code></pre></td></tr></table></figure>
<p>然后就可以做类似的 cas 操作了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetTail</span><span class="hljs-params">(Node expect, Node update)</span> &#123;<br>     <span class="hljs-keyword">return</span> unsafe.compareAndSwapObject(<span class="hljs-built_in">this</span>, tailOffset, expect, update);<br> &#125;<br></code></pre></td></tr></table></figure>
<p>很多 AtomicXXX 原子类，底层都依赖于 Unsafe 的 CAS offset、old value、new value操作。</p>
<h3 id="increaseandget-与-getandincrease">increaseAndGet 与 getAndIncrease</h3>
<p>incrementAndGet() 是由 getAndAddInt(obj, offset, 1) + 1 实现的，而 getAndIncrement() 直接就是 getAndAddInt(…, 1) 的返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// OpenJDK 8</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndAddInt</span><span class="hljs-params">(Object obj, <span class="hljs-type">long</span> offset, <span class="hljs-type">int</span> delta)</span> &#123;<br>    <span class="hljs-type">int</span> v;<br>    <span class="hljs-keyword">do</span> &#123;<br>        v = getIntVolatile(obj, offset);<br>    <span class="hljs-comment">// 整个“比较+更新”操作封装在 compareAndSwapInt() 中，在 JNI 里是借助于一个 CPU 指令（cmpxchg）完成的，属于原子操作，可以保证多个线程都能够看到同一个变量的修改值。   </span><br>    &#125; <span class="hljs-keyword">while</span> (!compareAndSwapInt(obj, offset, v, v + delta));<br>    <span class="hljs-keyword">return</span> v;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>CAS 有三大问题：</p>
<blockquote>
<ul>
<li>ABA问题。CAS需要在操作值的时候检查内存值是否发生变化，没有发生变化才会更新内存值。但是如果内存值原来是A，后来变成了B，然后又变成了A，那么CAS进行检查时会发现值没有发生变化，但是实际上是有变化的。ABA问题的解决思路就是在变量前面添加版本号，每次变量更新的时候都把版本号加一，这样变化过程就从“A－B－A”变成了“1A－2B－3A”。
<ul>
<li>JDK从1.5开始提供了AtomicStampedReference类来解决ABA问题，具体操作封装在compareAndSet()中。compareAndSet()首先检查当前引用和当前标志与预期引用和预期标志是否相等，如果都相等，则以原子方式将引用值和标志的值设置为给定的更新值。</li>
</ul>
</li>
<li>循环时间长开销大。CAS操作如果长时间不成功，会导致其一直自旋，给CPU带来非常大的开销。自旋（spin-wait）在低竞争场景下非常高效，因为避免了线程阻塞/唤醒的上下文切换开销。只有在高竞争或长时间无法成功时，自旋才成为问题。现代 JVM（如 HotSpot）在 Atomic* 类中仍使用简单自旋，因为其设计目标是短临界区、低延迟。更复杂的结构（如 ConcurrentLinkedQueue）会采用退避策略（backoff） 或结合 Thread.yield()，但 AtomicInteger 本身不这么做。</li>
<li>只能保证一个共享变量的原子操作（实际上是单个内存地址）。对一个共享变量执行操作时，CAS能够保证原子操作，但是对多个共享变量操作时，CAS是无法保证操作的原子性的。
<ul>
<li>Java从1.5开始JDK提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="自旋锁">自旋锁</h3>
<blockquote>
<p>阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。</p>
<p>在许多场景中，同步资源的锁定时间很短，为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能会让系统得不偿失。如果物理机器有多个处理器，能够让两个或以上的线程同时并行执行，我们就可以让后面那个请求锁的线程不放弃CPU的执行时间，看看持有锁的线程是否很快就会释放锁。</p>
<p>而为了让当前线程“稍等一下”，我们需让当前线程进行自旋，如果在自旋完成后前面锁定同步资源的线程已经释放了锁，那么当前线程就可以不必阻塞而是直接获取同步资源，从而避免切换线程的开销。这就是自旋锁。</p>
</blockquote>
<p><img src="%E8%87%AA%E6%97%8B%E9%94%81%E4%B8%8E%E9%9D%9E%E8%87%AA%E6%97%8B%E9%94%81.png" alt="自旋锁与非自旋锁"></p>
<blockquote>
<p>自旋锁本身是有缺点的，它不能代替阻塞。自旋等待虽然避免了线程切换的开销，但它要占用处理器时间。如果锁被占用的时间很短，自旋等待的效果就会非常好。反之，如果锁被占用的时间很长，那么自旋的线程只会白浪费处理器资源。所以，自旋等待的时间必须要有一定的限度，如果自旋超过了限定次数（默认是10次，可以使用-XX:PreBlockSpin来更改）没有成功获得锁，就应当挂起线程。</p>
<p>自旋锁在JDK1.4.2中引入，使用-XX:+UseSpinning来开启。JDK<br>
6中变为默认开启，并且引入了自适应的自旋锁（适应性自旋锁）。</p>
<p>自适应意味着自旋的时间（次数）不再固定，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而它将允许自旋等待持续相对更长的时间。如果对于某个锁，自旋很少成功获得过，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</p>
</blockquote>
<p>在自旋锁中另有三种常见的锁形式：TicketLock、<a target="_blank" rel="noopener" href="https://coderbee.net/index.php/concurrent/20131115/577">CLHlock和MCSlock</a>。这是很多 Lock Free 数据结构的基础。但 CLH 改成双端队列和引入 Park 以后，也可以实现 blocking lock。</p>
<p><img src="%E5%9B%9B%E7%A7%8D%E9%94%81%E5%8D%87%E7%BA%A7%E7%9A%84%E6%80%9D%E8%B7%AF.png" alt="四种锁升级的思路"></p>
<p>具体的解释先统一存储在<a href="https://magicliang.github.io/2017/11/10/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">《线程安全与锁优化》</a>。</p>
<h2 id="函数式接口">函数式接口</h2>
<h3 id="区别-runnable-和-callable">区别 Runnable 和 Callable</h3>
<p>Runnable 本身是不抛出异常的，但 Callable  本身耗时比较长，而且还会抛出异常（这个设计会最终导致我们进行函数式编程的时候，有时候我们需要在 Runnable 内部处理异常，有时候我们要在 Callable 外处理异常）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Callable</span>&lt;V&gt; &#123;<br>    V <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="synchronized-的状态">synchronized 的状态</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">sync1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-comment">// 制造一个内外部死锁，让 t1 内部锁死在这里</span><br>、           <span class="hljs-keyword">synchronized</span> (sync1) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">20L</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;I am going to die，current state：&quot;</span> + Thread.currentThread().getState() );<br>            &#125;<br>        &#125;);<br>        t1.setName(<span class="hljs-string">&quot;TTTTTT1&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (sync1) &#123;<br>            t1.start();<br>            Thread.sleep(<span class="hljs-number">2000L</span>);<br>            System.out.println(<span class="hljs-string">&quot;t1 state1：&quot;</span> + t1.getState());<br>            <span class="hljs-comment">// waiting for jmx client to attach on it</span><br>            Thread.sleep(<span class="hljs-number">30000L</span>);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;unsyncrhonized&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;t1 state2：&quot;</span> + t1.getState());<br>        Thread.sleep(<span class="hljs-number">500000L</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p><img src="jvisualvm%E8%A7%82%E5%AF%9F%E5%88%B0monitored%E6%80%81.png" alt="jvisualvm观察到monitored态"><br>
<img src="jmc%E5%BE%97%E5%88%B0blocked%E6%80%81.png" alt="jmc得到blocked态"></p>
<p>JVisualVM 会专门把 block 当做 monitorered 态。</p>
<h2 id="locksupport">LockSupport</h2>
<p>这个类型是为了提供阻塞元语，这样可以创造以锁为代表的 synchronization classes。</p>
<p>使用一个 park，如果有 permit，则立刻返回，否则阻塞；使用一个 unpark 会让 permit available。permit 最多有一个，这点和 semaphore 不一样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">sync1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-comment">// 在这一步以后，线程进入 waiting 的 state</span><br>        <span class="hljs-comment">// park 和 unpark 只能内外部调用，不能在一个线程内对称调用，而且 park 的参数是 sync，unpark 的参数是线程</span><br>        LockSupport.park(sync1);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">20L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-comment">// RUNNABLE</span><br>        System.out.println(<span class="hljs-string">&quot;I am going to die，current state：&quot;</span> + Thread.currentThread().getState() );<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;TTTTTT1&quot;</span>);<br>    t1.start();<br>    Thread.sleep(<span class="hljs-number">2000L</span>);<br>    <span class="hljs-comment">//  t1 state1：WAITING</span><br>    System.out.println(<span class="hljs-string">&quot;t1 state1：&quot;</span> + t1.getState());<br>    <span class="hljs-comment">// waiting for jmx client to attach on it</span><br>    Thread.sleep(<span class="hljs-number">30000L</span>);<br>    <span class="hljs-comment">// 这个unpark并不会立刻让 t1 进入runnable</span><br>    LockSupport.unpark(t1);<br>    System.out.println(<span class="hljs-string">&quot;unpark&quot;</span>);<br>    <span class="hljs-comment">// t1 state1：WAITING/TIMED_WAITING/RUNNABLE/TERMINATED </span><br>    System.out.println(<span class="hljs-string">&quot;t1 state2：&quot;</span> + t1.getState());<br>    Thread.sleep(<span class="hljs-number">500000L</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="JVisualVM%E7%9A%84%E9%A9%BB%E7%95%99%E7%8A%B6%E6%80%81.png" alt="JVisualVM的驻留状态"><br>
<img src="JMC%E7%9C%8Bwaiting%E7%8A%B6%E6%80%81.jpeg" alt="JMC看waiting状态"></p>
<p>注意，只有 jvisualvm会有“驻留”这个状态，jmc和jconsole都是直接进入标准的 waiting 状态。目前使用基于aqs 的lock 和 await 语义都会导致waiting，这会和 Object waiting 产生混淆。JVisualVM 似乎能够把 object waiting 和 park 驻留导致的 waiting 专门区别开来。</p>
<h2 id="内存一致性效应-memory-consistency-effects">内存一致性效应（Memory consistency effects）</h2>
<p>哪一种 action happen-before 哪一种action？</p>
<p>通常是 action prior to some release opertion happen-before action following acquire operation。</p>
<p>比如 Semaphore 的 memory consistency effect：Actions in a thread prior to calling a “release” method such as release() happen-before actions following a successful “acquire” method such as acquire() in another thread.</p>
<h2 id="主流锁">主流锁</h2>
<p><img src="Java%E7%9A%84%E4%B8%BB%E6%B5%81%E9%94%81.png" alt="Java的主流锁"></p>
<h3 id="悲观锁与乐观锁">悲观锁与乐观锁</h3>
<p><img src="%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81.png" alt="乐观锁与悲观锁"></p>
<ul>
<li>悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。</li>
<li>乐观锁适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。</li>
</ul>
<h2 id="aqs-abstractqueuedsynchronizer">AQS（AbstractQueuedSynchronizer）</h2>
<p>JUC 有个 locks 包，所有的锁和基于锁的并发基础设施都在这个包里隐藏。这些数据结构被称为同步器，而同步器本身是为了并发安全而存在的（相应地应该也存在原子化的解决方案、隔离的解决方案，我们改天再探讨）。AQS 是为了实现同步器而设计的<strong>框架</strong>，作为 <strong>basis</strong> of a synchronizer（同步器的依据），它提供了 queuing and blocking mechanic。</p>
<blockquote>
<p>AQS虽然被定义为抽象类，但事实上它并不包含任何抽象方法。这是因为AQS是被设计来支持多种用途的，如果定义抽象方法，则子类在继承时必须要覆写所有的抽象方法，这显然是不合理的。所以AQS将一些需要子类覆写的方法都设计成protect方法，将其默认实现为抛出UnsupportedOperationException异常。如果子类使用到这些方法，但是没有覆写，则会抛出异常；如果子类没有使用到这些方法，则不需要做任何操作。</p>
</blockquote>
<p>全部使用 protected 方法也是抽象类的设计方法之一。</p>
<p>AQS 并不是最初的基类，它能够被 Thread Own 这个特性，来自于 AbstractOwnableSynchronizer。它对 Own 的表达方式在于保存一个线程句柄-exclusiveOwnerThread。和锁（Monitor）的markword里保留一个对象头的设计思路是很相似的。</p>
<p>AQS 提供两种模式：</p>
<ul>
<li>独占 exclusive（这是<strong>缺省模式</strong>）：当以独占模式获取时，尝试通过其他线程获取不能成功。<code>When acquired in exclusive mode, attempted acquires by other threads cannot succeed.</code></li>
<li>共享 share：共享模式通常会成功，但实际上不一定。<code>Shared mode acquires by multiple threads may (but need not) succeed.</code>这和其他提供共享锁机制的软件实现（如 MySQL）还是不一样的。当共享模式获取成功时，下一个等待线程（如果存在）也必须确定它是否也可以获取-<strong>也就是说阻塞是决定后的结果</strong>。 <code>when a shared mode acquire succeeds, the next waiting thread (if one exists) must also determine whether it can acquire as well.</code></li>
</ul>
<p><strong>重要</strong>：<strong>在不同模式下等待的线程共享相同的FIFO队列</strong>（互斥和共享模式都需要addWaiter）。实现子类只支持这些模式之一，但是两者都可以在ReadWriteLock中发挥作用（所以同一个 FIFO 队列是实现读写锁混合的基石） 。仅支持独占或仅共享模式的子类不需要定义支持未使用模式的方法。</p>
<p>在四大 try 方法中，tryAcquire()，tryRelease()，tryReleaseShared() 都返回 boolean，只有 tryAcquireShared() 返回数字。</p>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">《一行一行源码分析清楚AbstractQueuedSynchronizer》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016058789">《Java多线程》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html">《从ReentrantLock的实现看AQS的原理及应用》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2018/11/15/java-lock.html">《不可不说的Java“锁”事》</a></li>
<li><a target="_blank" rel="noopener" href="http://itmyhome.com/java-api/java/util/concurrent/locks/AbstractQueuedSynchronizer.html#nested_class_summary">《官方文档的中文翻译》</a></li>
</ol>
<h3 id="aqs-的设计原则">AQS 的设计原则</h3>
<ul>
<li>Node 代表线程。atomic int state 代表锁状态（初始值为0），也就是并发理论里经常提到的临界资源本身，FIFO queue （分为 sync queue 和 wait queue ）是它的同步逻辑的基石（bias）。</li>
<li>依赖状态、队列和 CAS 操作来完成对同步机制的实现。
<ul>
<li>如果要涉及到出入队，操作的顺序大致上是：cas node wait status、sync queue 节点之间的enq 和 deque、管理 aqs 的状态（tryAcquir/tryRelease）。</li>
<li>AQS 自身的状态代表着锁的状态，这些状态都是 transient volatile 的，重点关注锁是被<strong>acquired 还是 released</strong> 。<strong>锁操作的实质就是对状态的维护</strong>。这其中又大量使用 CAS 操作，<strong>CAS操作是最轻量的并发处理动作</strong>。cas 会把操作分隔出两个部分：cas 以前做拥有权限的 if 比对，cas以后做其他成员-如在 AQS 里，主要是 exclusiveOwnerThread 的设值操作，这样就形成了原子性。
<ul>
<li><strong>CAS操作保证了同一个时刻，只有一个线程能修改成功</strong>，从而保证了线程安全，CAS操作基本是由Unsafe工具类的compareAndSwapXXX来实现的；CAS采用的是乐观锁的思想，<strong>因此常常伴随着自旋</strong>，如果发现当前无法成功地执行CAS，则不断重试，直到成功为止，自旋的的表现形式通常是一个<strong>死循环for(;;)</strong>。if 条件写得非常复杂，不易于拆解，而且有些 if 的约束是隐藏在内部的 cas 和自旋里的。有非常多的带有 side-effect 的 action，最终返回一个 boolean，可以被连续地 &amp;&amp; 在一个大括号里。大括号里把某个值设置为 true，意味着把最后一个 action 的返回值带出去。
<ul>
<li>加锁主要比对 state</li>
<li>解锁主要比对 owner thread</li>
<li>通过监控 API 可以查看：是否持有锁、是否有 contend、waitQueue的内容、syncQueue的内容。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Node 组成的链表代表了所有与锁相关的线程，我们有 sync queue 和 wait queue。
<ul>
<li>在 sync queue 里，头节点代表了拥有锁的线程，而链表的其他部分意味着阻塞队列（所以头指针可以是一个蓝色的node，而阻塞队列是一系列绿色的链表节点）
<ul>
<li>。队列遵循 FIFO 的原则（入队顺序为加锁顺序，从尾部入队），因此能够实现公平锁。
<ul>
<li>原始的<code>acquire</code>要求在队列里的 node，必须 predecessor 为 head 才能<code>tryAcquire</code>，这就实现了先进先出。</li>
<li><strong>公平锁意味着在<code>tryAcquire</code>实现的时候，要看看有没有 queued predecessor（表现为<code>hasQueuedPredeccesor()</code>（而不是<code>predecessor()</code>）方法返回 false，即这个节点）才能够 cas state，进而获取锁</strong>）。</li>
<li><strong>能够实现非公平锁是能够实现公平锁的基础</strong>。非公平锁在 tryAcquireLock 的 casState 之前，没有多余的 hasQueuedPredeccesor() 检查，所以公平锁是非公平锁画蛇添足的结果，非公平锁在 acquire 前面还套了一个很强的短路操作，在入队以前就猛抢，即很多人常说的插队。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Node 的 waitStatus 代表着线程-<strong>锁的等待状态（而不是锁的获取状态）</strong> ，如线程是否取消争抢线程的锁。AQS 内部大量使用 compareAndSetWaitStatus 来变更每个 node 和它的 predecessor 的状态
<ul>
<li>后节点是否在 sync queue 里 acquireQueued 里阻塞，要看前驱节点 ws。是否在 wait queue 里，要看本节点 ws。</li>
<li>通常是由后节点来更新前节点的 ws，自身的 ws 也会在某些情况下被自己的线程更新：
<ul>
<li>每一个 node 在 sync queue 和 wait queue 之间互换是要求在 0 和 CONDITION 之间互换的，在由本线程对本节点使用的。</li>
<li>每一个 node 被取消（主要是 acquireQueued 里发现了 failed）的时候会变成 CANCELLED，不管是自身求锁的时候发现被取消，还是被后继节点取消，或者被 signal 的流程取消。</li>
<li>每一个 node 会因为 next 的入队变成 SIGNAL。</li>
</ul>
</li>
</ul>
</li>
<li>Node 本身也有 next 和 prev，通常对 prev 的重新赋值可以直接用 =，但对 next 的赋值需要做 cas。有时候 set next 还需要考虑 next 自己的 ws。</li>
<li>线程自身还有 state，如 new、runnable 等。</li>
<li>所有的“同步属性”，都是某个类内部的非公开内部帮助类（如 ReentrantLock 内部的 abstract static class Sync）。</li>
<li>aqs 不实现任何 synchronization interface，其他同步器或者具体锁真正需要做的是**使用<code>acquireInterruptibly</code>等方法。**就锁的获取操作而言，子类必须重写<code>tryAcquire</code>方法。</li>
<li>各种 Sync 的标准格式应该是<code>Subclasses should be defined as non-public internal helper classes（非公共内部助手类） that are used to implement the synchronization properties of their enclosing class（封闭类）</code>。</li>
<li>序列化模式：此类的序列化仅存储底层原子整数维持状态，因此反序列化对象具有空线程队列（实现方法是，让链表的各种节点都被设置成<code>transient</code> 的）。 需要可序列化的典型子类将定义一个<code>readObject</code>方法，可以将其恢复为<code>readObject</code>时的已知初始状态。所有的状态都是 atomic 的，这些状态可以被序列化（有一些特定的成员变量被刻意设计成 transient的，如ownerThread），但 queue  通常不能直接被序列化，需要序列化器实现<code>readObject</code>方法才行。</li>
</ul>
<h4 id="简要记忆">简要记忆</h4>
<ol>
<li>互斥：改双入尾，放双出头</li>
<li>共享：初始设态，非0入尾，扣减出队，解放总是全解放。</li>
</ol>
<h3 id="aqs的五层结构">AQS的五层结构</h3>
<p><img src="AQS%E7%9A%84%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84.png" alt="AQS的五层结构"></p>
<blockquote>
<p>上图中有颜色的为Method，无颜色的为Attribution。</p>
<p>总的来说，AQS框架共分为五层，自上而下由浅入深，从AQS对外暴露的API到底层基础数据。</p>
<p>当有自定义同步器接入时，只需重写第一层所需要的部分方法即可，不需要关注底层具体的实现流程。当自定义同步器进行加锁或者解锁操作时，先经过第一层的API进入AQS内部方法，然后经过第二层进行锁的获取，接着对于获取锁失败的流程，进入第三层和第四层的等待队列处理，而这些处理方式均依赖于第五层的基础数据提供层。</p>
</blockquote>
<h3 id="clh-queue">CLH queue</h3>
<p>CLH 是一种 lock queue，normally used for spinlocks，but here used for blocking synchronizers。</p>
<p>这个 ADT 的 basic tatic 是<code>holding some of the control information about a thread in the predecessor of its node</code>。即本节点是否需要被 SIGNAL（parked - signaled- unparked），是由前一个节点决定的。</p>
<p>A “status” field in each node keeps track of whether a thread should block.</p>
<p>一个 node 是不是需要 block 需要由 status field 决定。实际上一个 field 的 status 为 SIGNAL 必然导致它的 successor parked（形成 blocked）。</p>
<p>A node is signalled when its predecessor releases.</p>
<p>release 里会附带一个 unparked successor 操作，而第一个 acquire 的入队会让出队自动进入一个 for-loop，不断 tryAcquire。</p>
<p>The status field does NOT control whether threads are granted locks etc though.</p>
<p>线程求锁就是它成为队头，队头的 thread 本身为 null。真正 hold thread 的地方只剩下 exclusiveOwnerThread。</p>
<p>入队是作尾，出队是作头。被唤醒不一定得到锁-如果不是公平锁的话。</p>
<p>The “prev” links (not used in original CLH locks), are mainly needed to handle cancellation. If a node is cancelled, its successor is (normally) relinked to a non-cancelled predecessor.</p>
<p>prev 让这个链表变成双向的，主要是为了让 cancelled 的node 的 next 找到新的 predecessor。</p>
<p>next 的用意是为了让 a predecessor signals the next node to wake up by traversing next link to determine which thread it is. next 是可能有争议的，CLH 的算法的用意是在一个节点的 successor 看起来是 null 的时候，对 tail 进行回溯检查-见 unparkSuccessor 里面寻找 null 的方法，这是基于 tail 是 atomically updated 的假定。</p>
<p>CLH 的 head 最初就是 dummy 的，node 被设置为 head 的时候也会变成 dummy 的。</p>
<p>Threads waiting on Conditions use the same nodes, but use an additional link. Conditions only need to link nodes in simple (non-concurrent) linked queues because they are only accessed when exclusively held.  Upon await, a node is inserted into a condition queue.  Upon signal, the node is transferred to the main queue.  A special value of status field is used to mark which queue a node is on.</p>
<p>condition 有一个单独的 condition queue，和 main queue 使用同一批节点，但使用 additional link。</p>
<p><img src="CLH%E5%8F%98%E4%BD%93%E9%98%9F%E5%88%97.png" alt="CLH变体队列"></p>
<h3 id="互斥框架的标准伪代码">互斥框架的标准伪代码</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 所以 tryAcquire 可以用非阻塞实现阻塞，tryAcquire 是一切 aqs 操作的灵魂</span><br><span class="hljs-comment">// 1. 试获取（改 state 和ownerThread）2. 入队</span><br>Acquire:<br>    <span class="hljs-comment">// 自旋带来阻塞，没有 sleep，这里就没有引入 clh 的 block</span><br>    <span class="hljs-keyword">while</span> (!tryAcquire(arg)) &#123;<br>     enqueue thread <span class="hljs-keyword">if</span> it is not already queued;<br>        possibly block current thread;<span class="hljs-comment">// 可以 block 也可以不 block，要看入队以后第二次 tryAcquire 的结果，以及 predecessor 的 waitStatus</span><br>    &#125;<br><br>Release:<br><span class="hljs-comment">// 1.试释放（改 state 和ownerThread）2. 尝试唤醒 successor，不需要出队，因为作为头部就已经算是出队了</span><br> <span class="hljs-keyword">if</span> (tryRelease(arg))<br>        <span class="hljs-comment">// 尝试唤醒，这里的伪代码实际上漏掉了实现中存在的 unpark</span><br>        unblock the first queued thread;<br><br><span class="hljs-comment">// 锁的调用模式：</span><br>somelock.lock()<br><br><span class="hljs-comment">// 有的 lock 会有 sync.lock() 的设计（如 ReentrantLock 的 UnfairSync），通过这一层再 delegate 到 acquire，lock 里面会有一个短路的 tryAcquire 操作。这足以证明 tryAcquire 不一定和 CLH 机制有关</span><br>sync.acquire(<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>
<h3 id="node-的实现">Node 的实现</h3>
<p><img src="Node%E7%9A%84%E7%BB%93%E6%9E%84.png" alt="Node的结构"></p>
<p>构造器，一个是需要 waitStatus，一个需要 nextWaiter，但都需要 Thread。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Link to the successor node that the current node/thread</span><br><span class="hljs-comment"> * unparks upon release. Assigned during enqueuing, adjusted</span><br><span class="hljs-comment"> * when bypassing cancelled predecessors, and nulled out (for</span><br><span class="hljs-comment"> * sake of GC) when dequeued.  The enq operation does not</span><br><span class="hljs-comment"> * assign next field of a predecessor until after attachment,</span><br><span class="hljs-comment"> * so seeing a null next field does not necessarily mean that</span><br><span class="hljs-comment"> * node is at end of queue. However, if a next field appears</span><br><span class="hljs-comment"> * to be null, we can scan prev&#x27;s from the tail to</span><br><span class="hljs-comment"> * double-check.  The next field of cancelled nodes is set to</span><br><span class="hljs-comment"> * point to the node itself instead of null, to make life</span><br><span class="hljs-comment"> * easier for isOnSyncQueue.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> Node next;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Link to predecessor node that current node/thread relies on</span><br><span class="hljs-comment"> * for checking waitStatus. Assigned during enqueuing, and nulled</span><br><span class="hljs-comment"> * out (for sake of GC) only upon dequeuing.  Also, upon</span><br><span class="hljs-comment"> * cancellation of a predecessor, we short-circuit while</span><br><span class="hljs-comment"> * finding a non-cancelled one, which will always exist</span><br><span class="hljs-comment"> * because the head node is never cancelled: A node becomes</span><br><span class="hljs-comment"> * head only as a result of successful acquire. A</span><br><span class="hljs-comment"> * cancelled thread never succeeds in acquiring, and a thread only</span><br><span class="hljs-comment"> * cancels itself, not any other node.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> Node prev;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Link to the successor node that the current node/thread</span><br><span class="hljs-comment"> * unparks upon release. Assigned during enqueuing, adjusted</span><br><span class="hljs-comment"> * when bypassing cancelled predecessors, and nulled out (for</span><br><span class="hljs-comment"> * sake of GC) when dequeued.  The enq operation does not</span><br><span class="hljs-comment"> * assign next field of a predecessor until after attachment,</span><br><span class="hljs-comment"> * so seeing a null next field does not necessarily mean that</span><br><span class="hljs-comment"> * node is at end of queue. However, if a next field appears</span><br><span class="hljs-comment"> * to be null, we can scan prev&#x27;s from the tail to</span><br><span class="hljs-comment"> * double-check.  The next field of cancelled nodes is set to</span><br><span class="hljs-comment"> * point to the node itself instead of null, to make life</span><br><span class="hljs-comment"> * easier for isOnSyncQueue.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">volatile</span> Node next;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Marker to indicate a node is waiting in shared mode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">SHARED</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>();<br><br><span class="hljs-comment">/** </span><br><span class="hljs-comment"> * Marker to indicate a node is waiting in exclusive mode</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">EXCLUSIVE</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br>&#125;<br><span class="hljs-comment">// SHARED 和 EXCLUSIVE 其实是用来指向 nextWaiter 的，这里隐含一个假设，非互斥获锁的前提下不需要使用条件变量，缺省情况下 EXCLUSIVE 才是 null</span><br>Node(Thread thread, Node mode) &#123;     <span class="hljs-comment">// Used by addWaiter</span><br>    <span class="hljs-built_in">this</span>.nextWaiter = mode;<br>    <span class="hljs-built_in">this</span>.thread = thread;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="锁">锁</h3>
<h4 id="加锁">加锁</h4>
<p>求锁的过程里，得到锁的线程会被记录在 aqs 的成员里，而得不到锁的线程会把 aqs 作为 blocker 记在自己的对象里。</p>
<h5 id="clh-主框架">CLH 主框架</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 走完第一步走第二步，第一步求锁成功改状态和线程-这是被包裹在一个原子操作里的，如果不成功走到第二步，让 acquire 这个操作入队，用 node 来管理线程。</span><br><span class="hljs-comment">     * 这一步就实现了通过 cas 把前条件和后操作分隔开来，acquireQueued 本身是阻塞的，出来才会需要做 selfInterrupt 的重置</span><br><span class="hljs-comment">     * Node.EXCLUSIVE 是一个 null，而 Share 是一个平凡的 empty Node 单例，所以先实现出来的 condition queue（而不是 CLH queue）是 exclusive 的</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) &#123;<br>     <span class="hljs-comment">// 这个 selfInterrupt 是唤醒以后使用的。入队是在 addWaiter 做的，自旋-唤醒-检查能否 tryAcquire 出队 - 继续 park 是在 acquireQueued 里做的</span><br>     selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>acquire 最复杂，aqs 自己实现了，最好不要覆写，所以一般设计 sync 都是从外部和 tryAcquire 入手（重点：tryAcquire 是非 CLH queue 的部分，只是对 state 和 ownerThread 的原子操作，易于覆写。而 CLH 队列的出队入队是 AQS 自身的标准套路，不需要覆写，覆写会造成破坏）。在 AQS 里，tryAcquire 默认的实现是空。</p>
<p>阻塞主要靠的是 tryAcquire(1) 以后的入队操作。</p>
<h6 id="tryacquire">tryAcquire</h6>
<p>tryAcquire 通常是交给具体的lock实现的：cas 本身的 state，修改 ownerThread 是在这一层做的。甲骨文推荐的一个特别简单的实现是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">assert</span> <span class="hljs-number">1</span> == arg;<br>    <br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 这两步无锁放在一起，也算原子了，因为只有一个线程的 cas能走进来，不考虑线程中断的问题</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, arg)) &#123;<br>        setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个实现过于简单，以至于忽略了一个简单的问题，那就是，为什么这里没有累加呢？因为累加就要加上一个判定 volatile currentOwnerThread 是否等于 currentThread 的问题。所以问题又变成为什么没有对 currentOwnerThread 的检查呢？所以 ReentrantLock 的实现里是会针对互斥 owner 提出判断分支的。</p>
<h6 id="addwaiter">addWaiter</h6>
<p>这是一个 aqs 自身的成员方法，会生成一个节点，加入到自身的队列：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 每一个node 天然出现的时候，自己的 next 都是 mode 参数本身，tail 的next 是 mode</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// 最快入队的方法是在把新节点的 pred 设置成队尾，所以 FIFO 的 I 指的是对 tail 的追加</span><br>    <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-comment">// 如果存在队尾-此时这不是一个空链表，否则必定走入一个 enq</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 先设置 node 的 prev，在并发入队时，会有多个 node 的 prev 设置为 pred</span><br>        node.prev = pred;<br>        <span class="hljs-comment">// 这一步的实现，是把当前 aqs 的 tail 节点设置为新的 node，之前的 tail 的 prev 本身是不变的</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            <span class="hljs-comment">// 然后把老 tail 的 next 设置为本 node，只有成功通过 cas 的 node 能够得到 pred 的next，其他节点还维持错误的 prev</span><br>            pred.next = node;<br>            <span class="hljs-comment">// 然后就可以从快路线返回了，此处返回的是 node 本身</span><br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 进入这里的 node 的 prev 还是错的，在这一步返回的 node 是 alreadyLinked 了的，注意，这个方法返回的不是node本身，而是它的前驱</span><br>    enq(node);<br>    <span class="hljs-comment">// 然后就算入队成功，可以返回了</span><br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在外面虽然有一个 enqued 的操作，但实质上对 tail 的修改-也就是入队，是被收敛到 enq(node) 这个方法调用里的，这一个 addWaiter 方法里完成了全部的入队操作。</p>
<h6 id="enq">enq</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Inserts node into queue, initializing if necessary. See picture above.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node to insert</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> node&#x27;s predecessor</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-comment">// 无限循环，直到能够返回一个 t 为止，enq 的存在是为了实现一个多线程 for 循环</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 因为 tail 为空 head 必为空，所以此处用局部变量来节省性能，使用链表的基本法则之一是，在一轮操作里会被修改的变量，要被提前存起来</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-comment">// 在 for 循环里，只会进入这一步一次</span><br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123; <span class="hljs-comment">// Must initialize</span><br>            <span class="hljs-comment">// 设计一个空的队头，然后把本 aqs 的 head 设置为 tail。注意，这个链表的第二个节点可能是抢不到锁的，但执行 enq 的时候，实际上前一个节点已经把锁释放了，所以此处可能遇到一个无头队列，如果无头，则初始化 tail 和 head</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                <span class="hljs-comment">// 这里隐藏一个设定，就是 head 和 tail 只要有一个为空，就全部为空。上一个 cas已经卡住其他操作，这里的操作就不用 cas，直接 set 即可</span><br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 这一段代码就是外部代码的一部分，只不过移到一个 for loop 里来，这一段是无 sleep 和无 park 的自旋 + 一个初始化链表的操作</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>            <span class="hljs-comment">// 如果 cas 失败，则下一轮的 node.prev 会被覆写</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="acquirequeued">acquireQueued</h6>
<p>这个方法提供了一个内部的自旋和 park 和从 unpark 中醒来的全部流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Acquires in exclusive uninterruptible mode for thread already in</span><br><span class="hljs-comment">     * queue. Used by condition wait methods as well as acquire.</span><br><span class="hljs-comment">     * 我们可以先姑且认为，这个方法是一个极度特殊版本的 acquire。</span><br><span class="hljs-comment">     * 是在互斥且不可中断模式下（与之相对地是 doAcquireShared，本方法也可以被叫做 doAcquireExclusive）</span><br><span class="hljs-comment">     * share 和 interruptibly 是两个维度</span><br><span class="hljs-comment">     * 每一个节点进入queue的顺序是这样的：</span><br><span class="hljs-comment">     * 1. 先看看自己是不是 head 后的第一个node（此处不分公平锁还是不公平锁）或者尝试获取锁（此处可能是为了预防并发，这意味着 pred 可能是被污染的），如果是的话，带着 interrupted 返回</span><br><span class="hljs-comment">     * 2. 检查 pred 的状态 ws：</span><br><span class="hljs-comment">     *    2.1  ws 此时是 SIGNAL，意味着上次已经设值过了，此节点需要做的就是 park，等待进入下一循环，如果下次循环还是求不到锁，前节点的 SIGNAL不变，总是能够不断地被 park，unpark。在此直接返回</span><br><span class="hljs-comment">     *    2.2 如果 ws 此时是 CANCELLED，寻找一个新的 pred（做 pred 收窄），但不去碰新 pred 的状态</span><br><span class="hljs-comment">     *    2.3 尝试把它设置为 SIGNAL</span><br><span class="hljs-comment">     *    2.4  2.2 和 2.3 会直接导致 false 退出，然后进入下一轮的求锁循环，下一轮循环开始时，pred 的节点终究会是 SIGNAL，然后就可以 park 了</span><br><span class="hljs-comment">     * 所以 CLH queue 本质上是1 入队，2 获锁，3 检查 pred，park等唤醒 唤醒检查 interrputed 或者设置 pred 但不park，4 再进入 for 循环尝试2获锁（还没有 release），一旦获取锁就带着 interrupted 离开自旋的一种结构</span><br><span class="hljs-comment">     * 所有的 bloking queue 的轮询等待，都在这里通过 for loop park 来实现</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> arg the acquire argument 这个参数主要是递归调用 tryAcquire 时用的</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if interrupted while waiting</span><br><span class="hljs-comment">     */</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-comment">// 一开始会预设失败</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 一开始会预设未被中断</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 阻塞由两部分组成，一部分是这里的 for 循环，一部分是下面的检查 park</span><br>            <span class="hljs-comment">// 每次进入第一部分都先尝试获锁</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-comment">// node 在循环里是不会变的，每个循环里都只取 node 的前置</span><br>                <span class="hljs-comment">// 注意，阻塞队列不包含 head 节点，head 一般指的是占有锁的线程，head 后面的才称为阻塞队列。这个方法在需要 npe 检查的时候会代替成员指针拿出来用</span><br>                <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>                <span class="hljs-comment">// 如果它的前驱为 head-就是获取锁的当前线程（前驱为 head，意味着本 node 前面已经没有节点了，也就意味着这是出队方法），则尝试获取锁-acquireQueued 外部是由 tryAcquire 开头的，自己也是由 tryAcquire 结尾</span><br>                <span class="hljs-comment">// 历史上第一个 head 其实是一个空 node（根据懒加载原理），如果本 node 后入队发现自己是阻塞队列的第一个节点，则还要再尝试 tryAcquire 一下</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                    <span class="hljs-comment">// 如果获锁成功，则把本节点设置为头，头就是这样被替代的，头就意味着出队的线程。            </span><br>                    setHead(node);<br>                    <span class="hljs-comment">// 此时本 node（也就是 head）不一定是 tail，因为在这个 for 循环里，可能有其它线程 link 过本 node 了</span><br>                    <span class="hljs-comment">// 但 p 本身是“前一个 head”，新老交替的结果就是把 p 和 node 做一个 unlink</span><br>                    <span class="hljs-comment">// 这两步把 head 做了一个出队</span><br>，                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// interrupted 为true 或者 false 都可能退出这个队列，这一步是一定会跑到的，而 interrupted 可能被上一轮循环的尾部给修改了</span><br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-comment">// 如果在上面一步没有返回，则没有产生收窄出队的效应。在这一步就会产生判定是不是要 park 以及实际 park 操作了</span><br>                <span class="hljs-comment">// 第一个条件检查状态机，看看是不是 shouldPark</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) <br>                    <span class="hljs-comment">// 第二个条件用 park 来实现阻塞，这个 park 就是 waiting queue 的实质了</span><br>                    &amp;&amp; parkAndCheckInterrupt())<br>                    <span class="hljs-comment">// 理论上被中断唤醒以后会进入这里，重新设计中断位（因为底层清了，这里有些多此一举），否则也可能 interrupted 为 false 退出这里</span><br>                    <span class="hljs-comment">// 这一步是可能被跑到，但大部分时候跑不到的</span><br>                    interrupted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                <span class="hljs-comment">// 注意，这里是在 for循环之外的一个兜底措施，上面的 for循环本身只有求到锁以后的 return 退出方法，这里是为了预防异常，在求锁过程中遇到异常，要直接清掉这个节点，这意味着这个 node 在 acquire 操作下无法进入正常的状态</span><br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的复杂之处在于，理解 pred/next 的复杂性，和 waitStatus 对 AQS 工作流程的间接影响。</p>
<p><img src="acquireQueued%E7%9A%84%E5%AE%9E%E7%8E%B0.png" alt="acquireQueued的实现"></p>
<h6 id="sethead">setHead</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sets head of queue to be node, thus dequeuing. Called only by</span><br><span class="hljs-comment"> * acquire methods.  Also nulls out unused fields for sake of GC</span><br><span class="hljs-comment"> * and to suppress unnecessary signals and traversals.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHead</span><span class="hljs-params">(Node node)</span> &#123;<br>    head = node;<br>    <span class="hljs-comment">// 在这里只从 node 视角进行操作，node.prev.next 的 unlink 操作留给外部的 node.prev 自己做</span><br>    <span class="hljs-comment">// 获取锁以后，算是出了 waiting-set 了，本 node 只是给 aqs 管理队列用，所以解除了对 thread 的引用，防止 thread 不能被回收</span><br>    <span class="hljs-comment">// 这个 node hold thread 和 status 都不算让 thread hold lock，node as head 算是让 thread 加了锁</span><br>    node.thread = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// head 不应该有 prev 的，因为这不是循环链表</span><br>    node.prev = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的关注点是：node 是dummy 的，要清空自身状态。</p>
<h6 id="shouldparkafterfailedacquire">shouldParkAfterFailedAcquire</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Checks and updates status for a node that failed to acquire.</span><br><span class="hljs-comment"> * Returns true if thread should block. This is the main signal</span><br><span class="hljs-comment"> * control in all acquire loops.  Requires that pred == node.prev.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> pred node&#x27;s predecessor holding status</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if thread should block</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-comment">// 这个状态机很有意思，这意味着我们的每一个 node 的实际状态是应该由前一个node（即 pred）来决定的</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-comment">// 前一个节点的 SIGNAL 状态，意味着后一个线程的 unpark。</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * This node has already set status asking a release</span><br><span class="hljs-comment">         * to signal it, so it can safely park.</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-comment">// 被 signal 以后反而会触发 park。这里的 signal 指的是 asking a release to signal it，通过 park 来等 unpark 来进入下一个循环的入口</span><br>         <span class="hljs-comment">// 通常我们要进入队列就是要 park 的。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 这里的大于零此时专指 CANCELLED，以后 cancelled 类的状态都必须大于零（反过来也一样）</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Predecessor was cancelled. Skip over predecessors and</span><br><span class="hljs-comment">         * indicate retry.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 链表自动做一个小的收窄，所有的 cancelled 线程要排出本链表，这里是自动把本 node 的prev跳了一下，为什么不会有并发问题安全问题还是不太容易看明白</span><br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 缩进玩</span><br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 这里引入了一个对状态机的隐式推导，可读性不太好。作者断言，此处要么是 0，要么是 PROPAGATE。CONDITION 也就是 -2 不会进入这个方法，因为 CONDITION 在另一个队伍里</span><br><span class="hljs-comment">         * waitStatus must be 0 or PROPAGATE.  Indicate that we</span><br><span class="hljs-comment">         * need a signal, but don&#x27;t park yet.  Caller will need to</span><br><span class="hljs-comment">         * retry to make sure it cannot acquire before parking.</span><br><span class="hljs-comment">         * 此时我们需要一个 signal，但还不需要 park</span><br><span class="hljs-comment">         */</span><br>         <span class="hljs-comment">// 否则尝试将 pred 的status 置为 SIGNAL，这样下一轮循环的时候，就可以进入 park，然后等 unpark了</span><br>         <span class="hljs-comment">// 也就意味着，这个 CLH 里的队列的每个 node 都天然需要自己的前驱是 SIGNAL 才正常。最初入队的 thread addWaiter 的时候会初始化一个 dummy head，然后进入这里，把这个 head 设置为 Node.SIGNAL。然后下一轮循环进到这里来，会从上面的 return true 那里出去。等于每一个节点是由它的后继节点的 acquiredQueued() 的第一次 for loop 设置为 SIGNAL 的。</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-comment">// 本次检查先不park，不 park 则外部可能就直接进入下一轮循环，尝试抢锁，失败再看要不要 park</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个配置告诉我们几个已知事实：每个节点的 waitStatus 状态，在主流程里是由后面的排队的 next 的入队来触发变化的。</p>
<p><img src="shouldParkAfterFailedAcquire.png" alt="shouldParkAfterFailedAcquire"></p>
<h6 id="parkandcheckinterrupt">parkAndCheckInterrupt</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 入队和每次 for 循环被唤醒抢不到锁，然后又需要 park，就会进入本方法 park 一次</span><br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这里需要关注的是this 作为 blocker 参数。</p>
<h6 id="cancelacquire">cancelAcquire</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Cancels an ongoing attempt to acquire.</span><br><span class="hljs-comment"> * 1. 设置本节点内部状态：status 和 thread</span><br><span class="hljs-comment"> * 2. 把本节点的前后节点做好 unsplice，意味着对出队做好准备</span><br><span class="hljs-comment"> * 3. 把本节点从 aqs 的视图里去掉，这里使用了一个二分法：区分是队尾和不是队尾</span><br><span class="hljs-comment"> * 4. 在这个方法里面我们有一个很重要的认知迭代：signal、cancel 和各式各样的 acquire 是存在 race condition 的，对于 ws、queue的头和尾都是需要 cas的。</span><br><span class="hljs-comment"> * 5. 尽量先找 pred，动力从 pred 来</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node the node</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// Ignore if node doesn&#x27;t exist</span><br>    <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 清空本 node</span><br>    node.thread = <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-comment">// Skip cancelled predecessors。因为 enq 效应存在，node.prev 不会为 null</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> node.prev;<br>    <span class="hljs-comment">// 在这里也在做一个 prev 的覆盖，只管本废弃节点的 prev 即可，这里可能会存在一个并发问题，如果 pred 的 prev 本身同时也在修改，则 node.prev 会跟着这个 prev 修改变动。这种“越过”操作的本质是废弃不当的 prev，至于 pred.prev 是不是正常，那另当别论</span><br>    <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>)<br>        node.prev = pred = pred.prev;<br><br>    <span class="hljs-comment">// predNext is the apparent node to unsplice. CASes below will</span><br>    <span class="hljs-comment">// fail if not, in which case, we lost race vs another cancel</span><br>    <span class="hljs-comment">// or signal, so no further action is necessary.</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">predNext</span> <span class="hljs-operator">=</span> pred.next;<br><br>    <span class="hljs-comment">// Can use unconditional write instead of CAS here.</span><br>    <span class="hljs-comment">// After this atomic step, other Nodes can skip past us.</span><br>    <span class="hljs-comment">// Before, we are free of interference from other threads.</span><br>    node.waitStatus = Node.CANCELLED;<br><br>    <span class="hljs-comment">// 在这里只做一个逻辑二分，只解决是不是队尾的问题，不区分队中和队头，如果是队尾则不用管 node next</span><br>    <span class="hljs-comment">// If we are the tail, remove ourselves.</span><br>    <span class="hljs-keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;<br>        <span class="hljs-comment">// 尾节点不需要 next，直接清空，因为中间节点实际上都是 cancelled 的节点</span><br>        compareAndSetNext(pred, predNext, <span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果要处理 next，也有两种思路：把 pred 的next link 和 本 node 的 next 连起来，或者直接unpark node 的 next，总之本 node 的 next 得到了很好的处理</span><br>        <span class="hljs-comment">// If successor needs signal, try to set pred&#x27;s next-link</span><br>        <span class="hljs-comment">// so it will get one. Otherwise wake it up to propagate.</span><br>        <span class="hljs-type">int</span> ws;<br>        <br>        <span class="hljs-comment">// pred 的节点自身是 SIGNAL 和 cas 成 SIGNAL 是等效的，这是 Doug Lea 的习惯</span><br>        <span class="hljs-keyword">if</span> (pred != head &amp;&amp;<br>            ((ws = pred.waitStatus) == Node.SIGNAL ||<br>             (ws &lt;= <span class="hljs-number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;<br>            pred.thread != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> node.next;<br>            <span class="hljs-keyword">if</span> (next != <span class="hljs-literal">null</span> &amp;&amp; next.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-comment">// prev 是不怕有并发安全问题的，但 next 一定要使用 compareAndSetNext，也就是说 prev 寻址出错不要紧，但 next 寻址出错要紧，这是容易被忽略的</span><br>                compareAndSetNext(pred, predNext, next);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 不属于上面的情况，即 pread 是头或者 pred 的状态不为 signal（即使在 cas 设置过后）或者 pred 的线程为空，则对 succesor 进行 unpark 操作，所以 succesor unpark 不是常态</span><br>            unparkSuccessor(node);<br>        &#125;<br>        <span class="hljs-comment">// 清除完 prev，最后再清除 next，即本方法主要是对 next 负责，不对 pred 负责</span><br>        node.next = node; <span class="hljs-comment">// help GC</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>队尾和不是队尾的流程太复杂了，要仔细看。</p>
<p><img src="cancelledAcquire-%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%98%AF%E5%B0%BE%E8%8A%82%E7%82%B9.png" alt="cancelledAcquire-当前节点是尾节点"><br>
<img src="cancellAcquire-%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%98%AFhead%E7%9A%84%E5%90%8E%E7%BB%A7%E8%8A%82%E7%82%B9.png" alt="cancellAcquire-当前节点是head的后继节点"><br>
<img src="cancellAcquire-%E5%BD%93%E5%89%8D%E8%8A%82%E7%82%B9%E6%98%AF%E4%B8%AD%E9%97%B4%E8%8A%82%E7%82%B9.png" alt="cancellAcquire-当前节点是中间节点"></p>
<h5 id="公平锁与非公平锁">公平锁与非公平锁</h5>
<p><img src="%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%B5%81%E7%A8%8B1.png" alt="非公平锁流程1"><br>
<img src="%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%B5%81%E7%A8%8B2.png" alt="非公平锁流程2"></p>
<p>核心特征：贪婪，不放过任何插队机会。</p>
<ol>
<li>入口阶段（第一轮抢劫）</li>
</ol>
<ul>
<li>动作：线程调用 lock()。</li>
<li>行为：二话不说，直接尝试 CAS(0, 1)。
<ul>
<li>成功：运气爆棚，锁正好空闲，直接拿锁走人（插队成功）。</li>
<li>失败：锁被人占了，准备走正规流程 acquire(1)。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>尝试获取阶段（第二轮抢劫）</li>
</ol>
<ul>
<li>动作：进入 acquire() -&gt; tryAcquire() -&gt; nonfairTryAcquire()。</li>
<li>行为：在入队前，不死心地再看一眼锁的状态。
<ul>
<li>如果发现 state == 0（锁刚才瞬间释放了）：不管有没有人排队，直接再次尝试 CAS。
<ul>
<li>成功：又一次插队成功，拿锁走人。</li>
<li>失败：这次是真的没机会了。</li>
</ul>
</li>
<li>如果发现是自己持有的锁（重入）：计数器 state + 1，成功。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>入队与阻塞阶段（认命排队）</li>
</ol>
<ul>
<li>动作：调用 addWaiter(Node.EXCLUSIVE)。</li>
<li>行为：将自己封装成 Node 节点，追加到 AQS 等待队列（CLH 队列）的尾部。</li>
<li>阻塞：进入 acquireQueued() 自旋循环。
<ul>
<li>检查前驱节点是不是 Head？</li>
<li>是 Head -&gt; 再试一次 tryAcquire（注意：这里调用的还是非公平的 tryAcquire，万一此时又有新强盗来抢，可能会输）。</li>
<li>不是 Head 或抢失败 -&gt; 调用 LockSupport.park() 挂起自己，进入 WAITING 状态，等待被唤醒。</li>
</ul>
</li>
</ul>
<p>ReentrantLock 的 sync 的 lock 方法是抽象的，对公平锁和非公平锁来讲都是一个壳方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.lock();<br>&#125;<br><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>    <span class="hljs-comment">// state == 0 此时此刻没有线程持有锁</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 虽然此时此刻锁是可以用的，但是这是公平锁，既然是公平，就得讲究先来后到，</span><br>        <span class="hljs-comment">// 看看有没有前置的排队节点，这是 cas 前条件。这也是公平的</span><br>        <span class="hljs-comment">// 这个嵌套条件判断没有和外面的条件判断放在一起，算是一个可读性更好的表达。在这里我们要注意，很多场合会同时出现 pred 和 prev，把这两个词分开就不会出现 prev.prev 的读写问题了</span><br>        <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>            <span class="hljs-comment">// 如果没有线程在等待，那就用CAS尝试一下（注意这里有一个并发处理问题），成功了就获取到锁了</span><br>            <span class="hljs-comment">// 不成功的话，只能说明一个问题，就在刚刚几乎同一时刻有个线程抢先了 =_=</span><br>            <span class="hljs-comment">// 因为刚刚还没人的，我判断过了</span><br>            compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>            <span class="hljs-comment">// 这是 cas 后操作</span><br>            setExclusiveOwnerThread(current);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>      <span class="hljs-comment">// 会进入这个else if分支，说明是重入了，需要操作：state=state+1</span><br>    <span class="hljs-comment">// 这里不存在并发问题</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c + acquires;<br>        <span class="hljs-comment">// 这里告诉我们，子类也可能传入错误的 acquire，这里要做防御性编程。这里允许等于0，这就要求 release 的时候要注意 release 操作的对称性</span><br>        <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>        setState(nextc);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果到这里，说明前面的 if 和 else if 都没有返回 true，说明没有获取到锁，直接返回 false</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>注意 FairSync 和 NoneFairSync 的区别一部分在 tryAcquire，acquire 的标准实现在 AQS 里是不需要实现的。</p>
<h6 id="关于公平锁：那些-反直觉-的地方">关于公平锁：那些“反直觉”的地方</h6>
<ul>
<li>反直觉一：非公平锁在绝大多数时候其实是“公平”的。
<ul>
<li>很多人以为非公平锁是“所有线程一拥而上随机抢”。</li>
<li>真相：非公平锁依然基于 AQS 的 FIFO（先进先出）队列。只有当一个新线程刚来请求锁，且恰好锁刚被释放的那个瞬间，它才有机会插队。如果没抢到，它依然要乖乖排队，且一旦入队，就必须按顺序等待，不能再插队了。</li>
</ul>
</li>
<li>反直觉二：公平锁可能会导致“全员受损”。
<ul>
<li>为了维护公平（严格按顺序唤醒），必须频繁地挂起和唤醒线程。这会导致大量的上下文切换（Context Switch），其开销可能比执行临界区代码本身还要大，导致整体系统吞吐量剧烈下降。</li>
</ul>
</li>
<li>反直觉三：绝对的时间公平是不存在的。
<ul>
<li>JVM 无法保证线程调度是绝对公平的。即使是公平锁，也只是保证“获取锁的顺序与入队顺序一致”，而无法保证“先请求的线程一定先入队”（因为入队动作本身也有并发竞争）。</li>
</ul>
</li>
</ul>
<h6 id="为什么非公平锁不需要复杂的非线性实现？">为什么非公平锁不需要复杂的非线性实现？</h6>
<p>因为只要允许“插队”，破坏了“先来后到”的规则，它在定义上就是“非公平”的了。保留底层的 <strong>FIFO 队列是为了保证兜底，防止大量线程饥饿（Starvation）</strong>，确保最终大家都能拿到锁，只是刚来的幸运儿能少排队而已。</p>
<h6 id="为什么非公平锁是缺省实现-且效率更高？">为什么非公平锁是缺省实现，且效率更高？</h6>
<p>核心原因在于：<strong>恢复一个被挂起的线程是非常慢的</strong>。</p>
<p>想象一个场景：</p>
<ol>
<li>线程 A 释放了锁。</li>
<li>AQS 决定唤醒队列头部的线程 B。</li>
<li>时间差（关键点）：从 A 释放锁，到 B 真正被 CPU 调度并运行，这中间有一段毫秒级的延迟（涉及到内核态/用户态切换、CPU 缓存重新加载等）。</li>
<li>在这段“空档期”，锁是空闲的！5</li>
<li>此时线程 C 刚好请求锁。</li>
</ol>
<ul>
<li>如果是公平锁：C 必须排队。CPU 空转，等待 B 醒来。</li>
<li>如果是非公平锁：C 发现锁没人在用，直接拿走执行。如果 C 执行得很快（比如只是 i++），它可能在 B 彻底醒来之前就已经执行完并释放锁了。</li>
</ul>
<p>结果：</p>
<ul>
<li>B 醒来后依然拿到了锁（或者稍微多等了一下）。</li>
<li>C 更是“白嫖”了一次执行机会。</li>
<li>整体吞吐量：在相同时间内，非公平锁多处理了一个 C 的请求。</li>
</ul>
<h6 id="关于公平锁-非公平锁的经典面试题">关于公平锁/非公平锁的经典面试题</h6>
<ol>
<li>ReentrantLock 和 synchronized 默认是公平还是非公平？
<ul>
<li>答：都是非公平。synchronized 偏向锁/轻量级锁/重量级锁的升级过程本身就是带有竞争和插队的，重量级锁底层 ObjectMonitor 的 EntryList 竞争也不保证顺序。</li>
</ul>
</li>
<li>什么情况下应该强制使用公平锁？
<ul>
<li>答：当持有锁的时间相对较长，或者业务上强烈要求“先来后到”的顺序（例如按顺序打印、按顺序处理请求），且不在乎吞吐量下降时。</li>
</ul>
</li>
<li>非公平锁会导致“线程饥饿”吗？如何解决？
<ul>
<li>答：理论上会，如果不断有新线程插队，队列里的线程可能一直等。但在 AQS 设计中，一旦插队失败进入队列，就只能排队，所以长期来看不会完全饿死，只是等待时间变数大。如果必须避免，请用公平锁。</li>
</ul>
</li>
<li>AQS 中 hasQueuedPredecessors() 的作用是什么？
<ul>
<li>答：这是公平锁判断“是否需要排队”的核心逻辑。如果队列不为空且头节点的后继不是当前线程，说明有人在排队，当前线程必须放弃 CAS，去排队。</li>
</ul>
</li>
<li>简述 ReentrantLock 非公平锁的加锁流程。</li>
</ol>
<ul>
<li>答：
<ul>
<li>CAS 尝试将 state 从 0 改为 1。成功则获锁。</li>
<li>失败则调用 acquire。</li>
<li>再次尝试非公平获取（tryAcquire），如果 state 为 0 直接 CAS，不看队列。</li>
<li>还失败，则封装成 Node 进入 AQS 队列排队挂起。</li>
</ul>
</li>
</ul>
<h4 id="解锁">解锁</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这一段代码是 ReentrantLock 里的，解锁也是一个抽象方法，跨公平锁和非公平锁</span><br><span class="hljs-comment"> * Attempts to release this lock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;If the current thread is the holder of this lock then the hold</span><br><span class="hljs-comment"> * count is decremented.  If the hold count is now zero then the lock</span><br><span class="hljs-comment"> * is released.  If the current thread is not the holder of this</span><br><span class="hljs-comment"> * lock then &#123;<span class="hljs-doctag">@link</span> IllegalMonitorStateException&#125; is thrown.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if the current thread does not hold this lock</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    sync.release(<span class="hljs-number">1</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>解锁也依赖于壳方法。</p>
<h5 id="release">release</h5>
<p>release 也分双重，需要复写的只有 tryRelease，管理状态用这个方法不管公平不公平，统一 tryRelease + unparkSuccessor head</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Releases in exclusive mode.  Implemented by unblocking one or</span><br><span class="hljs-comment"> * more threads if &#123;<span class="hljs-doctag">@link</span> #tryRelease&#125; returns true.</span><br><span class="hljs-comment"> * This method can be used to implement method &#123;<span class="hljs-doctag">@link</span> Lock#unlock&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arg the release argument.  This value is conveyed to</span><br><span class="hljs-comment"> *        &#123;<span class="hljs-doctag">@link</span> #tryRelease&#125; but is otherwise uninterpreted and</span><br><span class="hljs-comment"> *        can represent anything you like.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the value returned from &#123;<span class="hljs-doctag">@link</span> #tryRelease&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 这里的 tryRelease 的返回结果是是否完全释放的意思</span><br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 这里的 != 0 就是 SIGNAl 的意思</span><br>        <span class="hljs-comment">// 只要/只有完全释放了 state 才唤醒 h 的继任者</span><br>        <span class="hljs-comment">// ws &gt; 0，h 取消了；ws &lt; 0，要么是 PROPAGATE，要么是 SIGNAL，从语义上来讲后继节点就是一个阻塞态。换言之，如果head是初始节点，则不需要 unpark 后继</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="tryrelease">tryRelease</h6>
<p>tryRelease 的返回值是值得关注的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-comment">// 减少可重入次数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState() - releases;<br>    <span class="hljs-comment">// 当前线程不是持有锁的线程，抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-comment">// free 的意思是完全释放锁，不管 true/false，state 总是会被扣减掉的</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">free</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 如果持有线程全部释放，将当前独占锁所有线程设置为null，并更新state</span><br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>        free = <span class="hljs-literal">true</span>;<br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>    &#125;<br>    setState(c);<br>    <span class="hljs-keyword">return</span> free;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只有完全释放锁，才算 free，进入只执行一次的 post-free 流程。</p>
<h6 id="unparksuccessor">unparkSuccessor</h6>
<p>这个方法在 release 或者某个 node cancelled 的时候会被调用这个方法的难度在于，如何决定 successor。那些 timeout 的就不要了有时候 unparkSuccessor 的对象是 head，有时候是任意节点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * If status is negative (i.e., possibly needing signal) try</span><br><span class="hljs-comment">     * to clear in anticipation of signalling.  It is OK if this</span><br><span class="hljs-comment">     * fails or if status is changed by waiting thread.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 把本 node 设置为非状态机的初始态</span><br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Thread to unpark is held in successor, which is normally</span><br><span class="hljs-comment">     * just the next node.  But if cancelled or apparently null,</span><br><span class="hljs-comment">     * traverse backwards from tail to find the actual</span><br><span class="hljs-comment">     * non-cancelled successor.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// 从尾部开始遍历，直到要 unpark 的节点是尾部的第一个 waitStatus 为负数的 node</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-comment">// 找到即唤醒它</span><br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        <span class="hljs-comment">// node 里持有 thread 的用意就是让外围的 lockSupport 来引用和 unpark</span><br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="独占与共享">独占与共享</h4>
<p><img src="%E7%8B%AC%E5%8D%A0%E6%A8%A1%E5%BC%8F%E4%B8%8E%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%BC%8F.png" alt="独占模式与共享模式"></p>
<h3 id="条件">条件</h3>
<p>从 Doug Lea 的原始设计思路来讲，一个 Condition 是要引出一组多线程共用的 wait-set。它和锁的抽象实现了arbitrary lock 和 condition implementaion 的正交组合。</p>
<p>Where a Lock replaces the use of synchronized methods and statements, a Condition replaces the use of the Object monitor methods. 在原始的 Java 锁机制里面，synchronized 被叫作 synchronized methods，而 condition 被叫作 monitor methods。</p>
<p>条件有很多种叫法，可以叫作 condition queue，也可以叫作 condition variable。一个线程的使用语序总是先 wait，然后再由外部 notify，又内外协同来实现对执行上下文的切换。</p>
<p>这种状态必须被锁保护，否则就会触发  IllegateMonitorStateException。这会导致 ConditionObject 的实现总是一个 lock implementation 的 inner class，相互持有引用。A Condition instance is intrinsically bound to a lock。</p>
<p>有一个 key property 就是，Condition 会  atomically releases the associated lock and suspends the current thread，也就是说 Thread 会从一种 waiting 切换到另一种 waiting。但是锁没了。恰如  Java 语言规范力图描述的那样。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// 这个程序的意义告诉我们：如果两个条件变量是互斥的-即不同时为真，则可以实现环形的 wait 和 notify（即相互阻塞），而不会产生死锁</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BoundedBuffer</span> &#123;<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notFull</span>  <span class="hljs-operator">=</span> lock.newCondition(); <br>     <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">notEmpty</span> <span class="hljs-operator">=</span> lock.newCondition(); <br>  <br>     <span class="hljs-keyword">final</span> Object[] items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">100</span>];<br>     <span class="hljs-type">int</span> putptr, takeptr, count;<br>  <br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(Object x)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       lock.lock();<br>       <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">while</span> (count == items.length)<br>           notFull.await();<br>         items[putptr] = x;<br>         <span class="hljs-keyword">if</span> (++putptr == items.length) putptr = <span class="hljs-number">0</span>;<br>         ++count;<br>         notEmpty.signal();<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<br>       &#125;<br>     &#125;<br>  <br>     <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">take</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>       lock.lock();<br>       <span class="hljs-keyword">try</span> &#123;<br>         <span class="hljs-keyword">while</span> (count == <span class="hljs-number">0</span>)<br>           notEmpty.await();<br>         <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> items[takeptr];<br>         <span class="hljs-keyword">if</span> (++takeptr == items.length) takeptr = <span class="hljs-number">0</span>;<br>         --count;<br>         notFull.signal();<br>         <span class="hljs-keyword">return</span> x;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>         lock.unlock();<br>       &#125;<br>     &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>理论上来讲，condition 能够提供某些原生 notify 不支持的行为，如：</p>
<ol>
<li>guaranteed ordering for notifications</li>
<li>not requiring a lock to be held when performing notifications</li>
</ol>
<p>往下我们会看到，这些可选的 notification feature 的实现，严重依赖于类似 Reentrantlock 里标准的 isHeldExclusive 的实现。</p>
<p>Condition 对象原生的 monitor 相关方法仍然是可以被使用的，只不过最好不要拿来用，因为它会搞混你对条件队列的理解。</p>
<p>因为 spurious wakeup 的存在，所以 condition 的 waiting 一定要在一个 loop 里面执行。当然，一个狭义的实现也可以不允许 spurious wakeup 的存在，这就会要求不遵循 platform 的默认模式。</p>
<p>条件等待有三种形式：</p>
<ol>
<li>interruptible waiting  会抛出中断异常</li>
<li>non-interruptible waiting 不会抛出中断异常</li>
<li>timed waiting</li>
</ol>
<p>不管采用哪种形式，从 await 中返回过来，这个线程要 guaranteed to hold this lock。</p>
<p>另外，在 Java 的设计里面，凡是抛出 InterruptedException，<a href="#aqs-%E4%B8%8E%E4%B8%AD%E6%96%AD">必定清空 interrupted state</a>。</p>
<h4 id="条件对象">条件对象</h4>
<p>条件对象仍然管理 Node，而且也是用头和尾的形式，不过这次的链表是个单链表。一般的 Lock 是用 Sync 来管理 lock，sync 作为 AQS 自己维护 node，用 ConditionObject 来管理condition，ConditionObject 自己管理 Node。照理来讲一个 lock 可以产生多个 condition object 线程可以通过 await 操作，进入多个队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;<br>    <span class="hljs-comment">// 条件队列的第一个节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node firstWaiter;<br>    <span class="hljs-comment">// 条件队列的最后一个节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> Node lastWaiter;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="%E6%9D%A1%E4%BB%B6%E9%98%9F%E5%88%97.png" alt="条件队列"></p>
<p>我们可以看到，Node 仍然是AQS 的 node，但它们的 ws 是 Node.CONDITION。</p>
<h5 id="总结">总结</h5>
<p>大部分的换状态，放锁，部分的中断回再换状态回 sync queue，重新获锁，检查中断的流程都是在 await 中完成的；而 signal 中完成的只是主动的 transferForSignal，完成主动的 换状态回 sync queue 操作，和部分的唤醒。</p>
<h5 id="await">await</h5>
<ol>
<li>检查是否需要抛出中断异常。</li>
<li>在调用 await 相关方法的时候，线程先进入 wait queue。此时线程也不在 sync queue里了，因为获取锁才可以 await，获取锁的时候它已经是 sync queue 的 head 了。</li>
<li>调用 fullyRelease 方法，释放锁并把锁释放前的状态取出来。</li>
<li>在 wait queue 的自旋里检查 isOnSyncQueue。如果没有在同步队列里，自己 park，park 的 blocker 是 ConditionObject。每次从 park 中唤醒有两种可能：被 signal 内置的 unpark 唤醒，或者被中断唤醒。线程检查自己是不是被中断唤醒的，如果是被中断唤醒的，则自己 transfer 到 sync queue 里，设置 interrupt mode 然后退出；否则，它是被 signal 唤醒的，此时已经在 sync queue里了。自旋到下一阶段也会退出。</li>
<li>进入 wait queue 会把 ws 置为 condition，而进入 sync queue 则置为 0（等待 next 置为 SIGNAL），然后做好前后节点的 link。</li>
<li>调用 acquireQueued，引出在 sync queue 里的 park （park 的 blocker 是 AQS 自己）和自旋。</li>
<li>从 acquireQueued 返回真则本线程又是从中断中返回的，要确认上一步的 interrupt mode 是不是指示我们抛出异常，如果是则 interrupt mode 不变，否则设置 interrupt mode 为重新设置中断位。</li>
<li>看看本 node 的 next waiter 是不是 null，是的话 unlinkCancelledWaiters。</li>
<li>根据 interrupt mode 来让线程选择一种方式来设置自己的中断位。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock1.newCondition();<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt; &#123;<br>        lock1.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            condition.await();<br>            System.out.println(<span class="hljs-string">&quot;i am awaken&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock1.unlock();<br>        &#125;<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;TTTTT1&quot;</span>);<br>    t1.start();<br>    t1.interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法值得一看的地方是，如果一个方法是长时间的阻塞的，它是不是对外声明自己要响应中断，如果要响应中断，则中断是无时无刻在发生的，它要怎么在多个地方响应中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 如果开始 await 之前线程已经被中断了，则直接显式地抛出异常。这里有一个 juc 的习惯，只要抛出异常必定清空中断位，反之亦然</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-comment">// 先入 wait queue 队伍</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();<br>    <span class="hljs-comment">// 然后彻底释放锁，注意，此时其实线程也不在 sync queue里了，代表它的是头节点，所以这里只要清理 aqs 的state就行了，为了预防万一，我们先留存 savedState</span><br>    <span class="hljs-comment">// 这个设计是先冗余入队，然后再释放锁。这个方法表面上看起来没有做 isHeldExclusive 的检查，实际上在 tryRelease 的内部就会有，因为 tryRelease 是可选实现的，甚至 isHeldExclusive 也是可选实现的，所以条件在锁内被持有的设计规范是可以被破坏掉的</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 这里的 syncQueue 就是 CLH queue 里面非头的部分了，在这里就是自己 park，然后自旋</span><br>   <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        <span class="hljs-comment">// 注意，这里的 park 使用的 blocker 是 ConditionObject</span><br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-comment">// 一旦从 unpark 中醒来，要做几件事，首先检查中断，如果中断，则由 await 来做 transfer queue的操作，走 park 内部的 transfer 流程（把 node 的节点置回0，然后 enq node，算是完成了 queue 之间的 transfer），如果走完就会从这里面 break，但如果不发生中断，而产生了 signal，signal 内部也会完成 enq，让 isOnSyncQueue 检测到自动退出而不是 break 退出</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 如果因中断退出，而不是 signal 退出，直接 break，不再校验是否在 SyncQueue</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// enq 完就进入 CLH 的 park了，savedState 保证归还的锁的累积数量仍然不变。当然，此处也不一定会触发 park，如果此时锁被完全 release 的话，可以直接求锁成功</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)       <br>        <span class="hljs-comment">// 这里要理解一个两次中断的事实：acquireQueued 中返回true，也意味着发生了中断，但这种中断必然发生在 signal 之后，如果前面发生过一次 wait 的中断，则此处就不重设中断位，否则此处要设置模式</span><br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-literal">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        <span class="hljs-comment">// 抛出异常或者自置中断位，也就是说，如果发生过基于 park 的中断，内部没有做过中断重设，此处需要做，这和 acquire 内部还要调用一次 selfInterrupt 是异曲同工的。park 和 interrupt 的关系就是这么复杂</span><br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="addconditionwaiter">addConditionWaiter</h6>
<p>这个方法的主要逻辑就是让本线程产生一个代表节点，然后入队：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addConditionWaiter</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> lastWaiter;<br>    <span class="hljs-comment">// 在需要检查状态时，链表的 cancelled 节点总要被清掉</span><br>    <span class="hljs-comment">// If lastWaiter is cancelled, clean out.</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    &#125;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), Node.CONDITION);<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="fullyrelease">fullyRelease</h6>
<p>这个方法依赖于 release 的实现，也会返回 savedState。但如果 release 失败太复杂了，作者在这里选择了直接抛出异常，令人意外：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">fullyRelease</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-keyword">if</span> (release(savedState)) &#123;<br>            failed = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> savedState;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            node.waitStatus = Node.CANCELLED;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="unlinkcancelledwaiters">unlinkCancelledWaiters</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlinkCancelledWaiters</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">trail</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">while</span> (t != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> t.nextWaiter;<br>        <span class="hljs-comment">// 如果节点的状态不是 Node.CONDITION 的话，这个节点就是被取消的</span><br>        <span class="hljs-keyword">if</span> (t.waitStatus != Node.CONDITION) &#123;<br>            t.nextWaiter = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">if</span> (trail == <span class="hljs-literal">null</span>)<br>                firstWaiter = next;<br>            <span class="hljs-keyword">else</span><br>                trail.nextWaiter = next;<br>            <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>                lastWaiter = trail;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>            trail = t;<br>        t = next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="isonsyncqueue">isOnSyncQueue</h6>
<p>检查这个 node 是否已经在 sync queue 里了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOnSyncQueue</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-keyword">if</span> (node.waitStatus == Node.CONDITION || node.prev == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (node.next != <span class="hljs-literal">null</span>) <span class="hljs-comment">// If has successor, it must be on queue</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * node.prev can be non-null, but not yet on queue because</span><br><span class="hljs-comment">     * the CAS to place it on queue can fail. So we have to</span><br><span class="hljs-comment">     * traverse from tail to make sure it actually made it.  It</span><br><span class="hljs-comment">     * will always be near the tail in calls to this method, and</span><br><span class="hljs-comment">     * unless the CAS failed (which is unlikely), it will be</span><br><span class="hljs-comment">     * there, so we hardly ever traverse much.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">return</span> findNodeFromTail(node);<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="isonsyncqueue">isOnSyncQueue</h6>
<p>如果中断，则做 queue transfer，如果不中断则返回 0，这里使用了内部类能够引用外部方法的闭包性质，可以用 enq 方法自动找到尾部。</p>
<p>这个方法的动词使用了现在进行时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">checkInterruptWhileWaiting</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// 不发生中断返回 0 最好，如果发生中断则要自己做 enq，而且根据 transfer 的结果告知外部是该抛出异常，还是自己重新设置中断位</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted() ?<br>        (transferAfterCancelledWait(node) ? THROW_IE : REINTERRUPT) :<br>        <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="transferaftercancelledwait">transferAfterCancelledWait</h6>
<p>这个方法是 await 内部的 transfer 方法之一（另一个在 signal 里）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法是给中断 CancelledWait 用的</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferAfterCancelledWait</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// 如果改变 ws成功，则应该抛出中断异常</span><br>    <span class="hljs-keyword">if</span> (compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>)) &#123;<br>        enq(node);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 上面失败就意味着发生了一个 race condition，如果是 signal 赢了，则实际上不应该抛出异常</span><br><span class="hljs-comment">     * If we lost out to a signal(), then we can&#x27;t proceed</span><br><span class="hljs-comment">     * until it finishes its enq().  Cancelling during an</span><br><span class="hljs-comment">     * incomplete transfer is both rare and transient, so just</span><br><span class="hljs-comment">     * spin.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node))<br>        Thread.<span class="hljs-keyword">yield</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="reportinterruptafterwait">reportInterruptAfterWait</h6>
<p>使用一个常量作为 flag，就完成了从中断-flag-重新还原中断的全流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reportInterruptAfterWait</span><span class="hljs-params">(<span class="hljs-type">int</span> interruptMode)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="signal">signal</h5>
<ol>
<li>检查 isHeldExclusively。</li>
<li>选一个非空的 firstWaiter，进行 signal。因为 ConditionObject 本身是跨多线程共享的，所以这会随机选取第一个 node 进行信号唤醒，把它从 CONDITION 置为 0，如果失败则返回 false。与之相对的，signalAll 是用 firstWaiter 开始，按顺序唤醒整个链表。<strong>AQS 的随机性在于不知道链表的顺序是怎样的，但对于 FIFO 的出队是不随机的</strong>。</li>
<li>enq node。</li>
<li>把前驱 cas 设置成 SIGNAL 失败或者前驱节点已经取消，尝试直接 unpark 这个 node。然后就让 await 方法的 isOnSyncQueue 走剩下的流程。</li>
<li>返回操作为 true。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 注意看这个方法，只要 isHeldExclusively 不正常，则这个方法会抛出 IllegalMonitorStateException</span><br><span class="hljs-comment"> * Moves the longest-waiting thread, if one exists, from the</span><br><span class="hljs-comment"> * wait queue for this condition to the wait queue for the</span><br><span class="hljs-comment"> * owning lock.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalMonitorStateException if &#123;<span class="hljs-doctag">@link</span> #isHeldExclusively&#125;</span><br><span class="hljs-comment"> *         returns &#123;<span class="hljs-doctag">@code</span> false&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 检查是不是在锁的控制范围内</span><br>    <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>    <span class="hljs-comment">// 只取非空 first 作为 doSignal 对象</span><br>    <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>        doSignal(first);<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="dosignal">doSignal</h6>
<p>只有 signal 一个非零和非 cancelled 的 node 成功才会从循环中停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java">        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * </span><br><span class="hljs-comment">         * Removes and transfers nodes until hit non-cancelled one or</span><br><span class="hljs-comment">         * null. Split out from signal in part to encourage compilers</span><br><span class="hljs-comment">         * to inline the case of no waiters.</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> first (non-null) the first node on condition queue</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(Node first)</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-comment">// 首先用 frist.next 来顶掉 firstwaiter，如果 first.next 为空，则清空本队列</span><br>                <span class="hljs-keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="hljs-literal">null</span>)<br>                    lastWaiter = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// unlink first 到 next waiter 的联系</span><br>                first.nextWaiter = <span class="hljs-literal">null</span>;<br>                <span class="hljs-comment">// 如果 transferForSignal 成功，循环中止，否则必定是 node 被 cancelled 了，这时候要把 firstWaiter 赋值回 first，看看是不是还能找到 non-null 继续循环</span><br>            &#125; <span class="hljs-keyword">while</span> (!transferForSignal(first) &amp;&amp;<br>                     (first = firstWaiter) != <span class="hljs-literal">null</span>);<br>        &#125;<br>```    <br><br>###### transferForSignal<br><br>这个方法的主要目的是为了完成往 sync queue 的转移只要求 cas node 的状态为 <span class="hljs-number">0</span> 和对它进行 enq 只有在极端情况下才会做立即 unpark：AQS 有个设计，在 cancel 一个 node 以后，或者 一个 node 不正常了以后，会立刻 unpark 它的  successor 如果这个 unpark 没有被执行，unlock 的时候还会带有一个 unpark 来刺激 lock。<br><br>```java   <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">transferForSignal</span><span class="hljs-params">(Node node)</span> &#123;<br>    <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * If cannot change waitStatus, the node has been cancelled.</span><br><span class="hljs-comment">         * 假定，condition queue中的节点一定是 CONDITION，不会再变</span><br><span class="hljs-comment">         * 这是本方法第一次试图 cas 改变一个 node，其实此时如果失败，意味着本节点是 cancelled 的，应该返回 false</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * Splice onto queue and try to set waitStatus of predecessor to</span><br><span class="hljs-comment">         * indicate that thread is (probably) waiting. If cancelled or</span><br><span class="hljs-comment">         * attempt to set waitStatus fails, wake up to resync (in which</span><br><span class="hljs-comment">         * case the waitStatus can be transiently and harmlessly wrong).</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> enq(node);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> p.waitStatus;<br>        <span class="hljs-comment">// 如果前驱节点已取消，本 node 应该直接 unpark；或者前驱节点不能设置为 SIGNAL-此处不需要等到下轮循环再设置了，要把本 node 做一个 unpark，交给 await中的循环处理。</span><br>        <span class="hljs-comment">// 什么情况下 compareAndSetWaitStatus 会失败呢？p 是前驱节点的意思，p 被人动过，这也就意味着此处的 cas已经无意义了</span><br>        <span class="hljs-comment">// 这是第二个地方用 cas 检查 node 的前驱，如果失败，通过 unpark 让 acquiredQueued 来试图收窄链表</span><br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))<br>            <span class="hljs-comment">// 注意，node.thread 已经在await 的循环里 park了，此处的 enq 帮那个循环省略了从中断中 enq 的动作，它会在 await 方法里进入 acquireQueued，再尝试求锁解锁，这种直接唤醒重新入队的方法，被作者称作 resync。</span><br>            LockSupport.unpark(node.thread);<br>        <span class="hljs-comment">// 但如果不 unpark，直接返回，则对于 node.thread 的 unpark 需要等到 unlock 底层的 release</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>关于 signal + unlock 带来的获锁，可以参考这个实验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">testConditionProcedure</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, IOException &#123;<br><br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>        <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>        <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">controlFlag</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            lock.lock();<br>            System.out.println(<span class="hljs-string">&quot;内线程先求锁&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">while</span> (!controlFlag.get()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;check input failed, begin to await，准备释放锁&quot;</span>);<br>                        <span class="hljs-comment">// 在这一行里，内线程 fullyRelease 了 lock</span><br>                        condition.await();<br>                        <span class="hljs-comment">// 在这一行里，内线程重新拿回了 lock</span><br>                        System.out.println(<span class="hljs-string">&quot;signaled, begin to check input，重新得回锁&quot;</span>);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>                System.out.println(<span class="hljs-string">&quot;isInterrupted: &quot;</span> + Thread.currentThread().isInterrupted());<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                lock.unlock();<br>            &#125;<br>        &#125;);<br>        t1.setName(<span class="hljs-string">&quot;test-thread1&quot;</span>);<br>        t1.start();<br>        <span class="hljs-comment">// 造成一种内线程先拿到锁，但释放后进入 wait queue 的情况</span><br>        Thread.sleep(<span class="hljs-number">1000L</span>);<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 在 idea 里暂时无法使用 prompt input，所以现阶段就用倒数计时来触发锁定</span><br><span class="hljs-comment">//            Scanner command = new Scanner(System.in);</span><br><span class="hljs-comment">//            System.out.println(&quot;Enter command: &quot;);</span><br><span class="hljs-comment">//            boolean running = true;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//            while(running)&#123;</span><br><span class="hljs-comment">//                switch(command.nextLine())&#123;</span><br><span class="hljs-comment">//                    case &quot;signal&quot;:</span><br><span class="hljs-comment">//                        System.out.println(&quot;Machine started!&quot;);</span><br><span class="hljs-comment">//                        running = false;</span><br><span class="hljs-comment">//                        break;</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//            command.close();</span><br><br>            controlFlag.set(<span class="hljs-literal">true</span>);<br>            <span class="hljs-comment">// 这里会让内线程准备求锁</span><br>            System.out.println(<span class="hljs-string">&quot;让内线程准备求锁&quot;</span>);<br>            <span class="hljs-comment">// 要在锁里面执行 signal，其内部针对极端情况会触发 unpark，但那个unpark 只能触发 resync 入队用，如果本线程没有释放锁，则内线程求不到锁，会进入第二次 park</span><br>            condition.signal();<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 在这行彻底执行完的一瞬间，内线程求锁完，才能从 await 中退出，这会导致 unpark，await 内部至少会有一次 unpark 醒来，到时候无人争抢锁的话，会直接重新回到获锁（acquired）状态</span><br>            System.out.println(<span class="hljs-string">&quot;释放本线程的锁，下一瞬间内线程就会求到锁&quot;</span>);<br>            lock.unlock();<br>        &#125;<br><br>        Thread.sleep(<span class="hljs-number">15000L</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h3 id="aqs-与中断">AQS 与中断</h3>
<h4 id="两种中断模式">两种中断模式</h4>
<p>在 AQS 内部，把这两种中断模式归类为：</p>
<ul>
<li>REINTERRUPT：Mode meaning to reinterrupt on exit from wait，模式保留中断状态，让上层代码能感知到中断的发生：
<ul>
<li>这样做的好处是：
<ul>
<li>保持中断状态的完整性</li>
<li>允许上层代码检测到中断并作出相应处理</li>
<li>符合Java的中断机制设计理念：中断是一种协作机制，应该传播给调用链</li>
</ul>
</li>
<li>如果不恢复中断状态：
<ul>
<li>上层代码将无法感知到中断发生</li>
<li>可能会影响依赖中断状态的取消操作</li>
<li>违反了线程中断的传播机制</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 等待操作</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// 重新设置中断标志</span><br>    Thread.currentThread().interrupt();<br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>THROW_IE：Mode meaning to throw InterruptedException on exit from wait，通过异常直接通知上层代码中断的发生</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例处理方式</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 等待操作</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// 直接抛出异常</span><br>    <span class="hljs-keyword">throw</span> e;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="检测中断的标准方法">检测中断的标准方法</h4>
<p><strong>在阻塞方法里 catch InterruptedException/ClosedByInterruptException 和非阻塞流程轮询检查线程的中断状态</strong>是响应中断的方法：</p>
<ul>
<li>能检测到中断就是发生过中断</li>
<li>而不能检测到中断可能意味着中断位被重置了，用异常表达了中断-所以捕获了异常就需要重新中断。</li>
</ul>
<h4 id="非锁的计时waiting方法">非锁的计时waiting方法。</h4>
<p>Java 自带的内置长时间停顿方法有以下：</p>
<ul>
<li>Object：wait()、wait(long)、wait(long, int)，被中断的时候会抛出 <strong>InterruptedException</strong>，而且会<strong>清空</strong>中断位</li>
<li>Thread：join()、join(long)、join(long, int)、sleep(long)、sleep(long, int)，被中断的时候会抛出 <strong>InterruptedException</strong>，而且会<strong>清空</strong>中断位</li>
<li>实现了 InterruptibleChannel 接口的类中的一些 I/O 阻塞操作，如 DatagramChannel 中的 connect 方法和 receive 方法等，被中断的时候会抛出 <strong>ClosedByInterruptException</strong>，而且会<strong>设置</strong>中断位</li>
<li>Selector 中的 select 方法，被中断的时候会<strong>立即返回</strong>，而且会<strong>设置</strong>中断位</li>
</ul>
<h4 id="locksupport-park-的行为">LockSupport.park 的行为</h4>
<p>LockSupport.park 会响应中断-<strong>醒来</strong>，但通常会被java类库作者的自旋重新带进下一个 LockSupport.park ，但<strong>不会重置中断状态</strong>（对线程进行中断检查会得到  true，线程被 interrupt()的结果<strong>完全不会被 LockSupport.park 影响</strong>）。</p>
<h4 id="lock-与中断">lock 与中断</h4>
<p>AQS 在设计的时候，会设计普通 lock，lockInterruptibly() 的版本。在条件上，会设计 await 和 awaitUninterruptibly()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>    sync.lock();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>普通 lock 是不会响应中断的阻塞操作的-对卡在 lock 上的线程进行 interrupt，在线程内部什么都不会发生。</p>
<p>在下面的实验里，我们从主线程，不断地中断另一个线程，另一个线程没有抛出异常，只有求到锁才从中断中返回，而且重置（reset，而不是 clear）了中断位，<strong>仿佛只有最后退出线程的那一刻，线程才被中断了</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个实验的问题是，无法复现求锁的子线程从被中断状态下退出的场景</span><br><span class="hljs-comment"> * 是不是只有从 os 层面干预线程，才能触发这一点？</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException 中断异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLockProcedure</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch1.await();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            System.out.println(<span class="hljs-string">&quot;isInterrupted: &quot;</span> + Thread.currentThread().isInterrupted());<br>        &#125;<br><br>        <span class="hljs-comment">// 用 while 而不是 sleep，这样就不怕 interrupt 被阻塞 api 抛出异常来响应了</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            j += i;<br>        &#125;<br>        <span class="hljs-comment">// 返回累加结果，这样不会被死代码优化：704982704</span><br>        System.out.println(j);<br>        <span class="hljs-comment">// 在lock 内部可能检测不到这个中断，需要外部频繁中断为好</span><br>        Thread.currentThread().interrupt();<br><br>        <span class="hljs-comment">// 让系统在这个地方卡住，然后用 debugger 观察本线程的状态</span><br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(String.format(<span class="hljs-string">&quot;from inside Thread.currentThread().getState(): %s, Thread&quot;</span><br>                            + <span class="hljs-string">&quot;.currentThread().isInterrupted(): %s&quot;</span>,<br>                    Thread.currentThread().getState(), Thread.currentThread().isInterrupted()));<br>            System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;test-thread1&quot;</span>);<br>    t1.start();<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>        countDownLatch1.countDown();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 休眠一段时间，让t1开始求锁，然后再解锁</span><br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>        &#125;<br>        <span class="hljs-comment">// 中断一千次</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>            <span class="hljs-comment">// 在这里频繁中断，如果t1内部这时候还在 sleep 就会抛出异常，所以t1内部只能循环</span><br>            t1.interrupt();<br>            StackTraceElement[] stackTrace = t1.getStackTrace();<br>            <span class="hljs-comment">// 只输出前两行堆栈信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">stackInfo</span> <span class="hljs-operator">=</span> stackTrace.length &gt;= <span class="hljs-number">2</span><br>                    ? stackTrace[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot;\n&quot;</span> + stackTrace[<span class="hljs-number">1</span>]<br>                    : stackTrace.length == <span class="hljs-number">1</span> ? stackTrace[<span class="hljs-number">0</span>].toString() : <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-comment">// 我们不断检验线程状态，会得到结论：lock 内部是基于 park 的，中断不会清除让 lock 退出，中断可能会短暂让线程进入中断状态（只能在锁的外部短暂观察到），但是 lock</span><br>            <span class="hljs-comment">// 的自旋模式会让锁回到未中断状态-只有从锁里出来，才能在本线程内部看到正确的中断状态</span><br>            System.out.println(String.format(<span class="hljs-string">&quot;t1.getState(): %s, t1.isInterrupted(): %s, stackInfo: %s&quot;</span>,<br>                    t1.getState(), t1.isInterrupted(), stackInfo));<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">10000L</span>);<br>        lock.unlock();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="hljs-comment">         *         boolean failed = true;</span><br><span class="hljs-comment">         *         try &#123;</span><br><span class="hljs-comment">         *             boolean interrupted = false;</span><br><span class="hljs-comment">         *             for (;;) &#123;</span><br><span class="hljs-comment">         *                 final Node p = node.predecessor();</span><br><span class="hljs-comment">         *                 if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="hljs-comment">         *                     setHead(node);</span><br><span class="hljs-comment">         *                     p.next = null; // help GC</span><br><span class="hljs-comment">         *                     failed = false;</span><br><span class="hljs-comment">         *                     // 不管是否中断，都从这里 return</span><br><span class="hljs-comment">         *                     return interrupted;</span><br><span class="hljs-comment">         *                 &#125;</span><br><span class="hljs-comment">         *                 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="hljs-comment">         *                     parkAndCheckInterrupt())</span><br><span class="hljs-comment">         *                      // 如果中断则跑到这，不然得到锁就保持 interrupted = false，然后从上面 return</span><br><span class="hljs-comment">         *                     interrupted = true;</span><br><span class="hljs-comment">         *             &#125;</span><br><span class="hljs-comment">         *         &#125; finally &#123;</span><br><span class="hljs-comment">         *             if (failed)</span><br><span class="hljs-comment">         *                 cancelAcquire(node);</span><br><span class="hljs-comment">         *         &#125;</span><br><span class="hljs-comment">         *     &#125;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *     public final void acquire(int arg) &#123;</span><br><span class="hljs-comment">         *         if (!tryAcquire(arg) &amp;&amp;</span><br><span class="hljs-comment">         *             acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="hljs-comment">         *             // 如果 acquireQueued 方法返回true，断点到这一行</span><br><span class="hljs-comment">         *             // 如果 while interrupt 循环足够多，是可以从这一步跑出去的</span><br><span class="hljs-comment">         *             selfInterrupt();</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *             // 否则断点到这一行即不做 selfInterrupt</span><br><span class="hljs-comment">         *     &#125;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *    private final boolean parkAndCheckInterrupt() &#123;</span><br><span class="hljs-comment">         *         LockSupport.park(this);</span><br><span class="hljs-comment">         *         // 这是一个清理线程状态的 testMethod()</span><br><span class="hljs-comment">         *         return Thread.interrupted();</span><br><span class="hljs-comment">         *     &#125;</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         */</span><br>    &#125;<br>    t1.join();<br>    Thread.sleep(<span class="hljs-number">10000L</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们不断检验线程状态，会得到结论：lock 内部是基于 park 的，中断不会清除让 lock 退出，中断可能会短暂让线程进入中断状态（只能在锁的外部短暂观察到），但是 lock  的自旋模式会让锁回到未中断状态-只有从锁里出来，才能在本线程内部看到正确的中断状态</p>
<p>这是 park 隐晦地把响应中断的职责外放给使用者的一种设计。如果我们真的关心线程在跑到外部的时候是否还是从中断路径中出现，我们可以使用 lockInterruptibly + 检查异常，或者使用普通 lock + 检查中断位。</p>
<p>从总体来讲，lock 作为一个外部操作是不用抛出中断异常的方式来退出的，从lock 中正常退出往下走是用户可以接受的结果。中断位被隐藏得比较隐晦。</p>
<p>await 操作如果遇到异常，到底退出还是不退出呢？如果像 park 一样退出，则用户必须写类似 aqs 之类的代码才能检查中断位，而且有时候中断的真实目的并不是让一个线程苏醒，而是真的把后续的流程阻断掉（如果不中断掉，因为自旋的存在，线程只会再一次进入 park 的状态），从这个视角来看，抛出异常学 sleep 和 wait更合理。</p>
<h4 id="内部方法">内部方法</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 最底层的方法</span><br><span class="hljs-comment"> * Tests if some Thread has been interrupted.  The interrupted state</span><br><span class="hljs-comment"> * is reset or not based on the value of ClearInterrupted that is</span><br><span class="hljs-comment"> * passed.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterrupted</span><span class="hljs-params">(<span class="hljs-type">boolean</span> ClearInterrupted)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 安全方法-纯粹的读方法：不 clear 中断位的检查</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isInterrupted</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> isInterrupted(<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 危险方法-不纯粹的读方法：名为中断，其实是 clear 中断位的方法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">interrupted</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> currentThread().isInterrupted(<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Interrupts this thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; Unless the current thread is interrupting itself, which is</span><br><span class="hljs-comment"> * always permitted, the &#123;<span class="hljs-doctag">@link</span> #checkAccess() checkAccess&#125; method</span><br><span class="hljs-comment"> * of this thread is invoked, which may cause a &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * SecurityException&#125; to be thrown.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If this thread is blocked in an invocation of the &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * Object#wait() wait()&#125;, &#123;<span class="hljs-doctag">@link</span> Object#wait(long) wait(long)&#125;, or &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * Object#wait(long, int) wait(long, int)&#125; methods of the &#123;<span class="hljs-doctag">@link</span> Object&#125;</span><br><span class="hljs-comment"> * class, or of the &#123;<span class="hljs-doctag">@link</span> #join()&#125;, &#123;<span class="hljs-doctag">@link</span> #join(long)&#125;, &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * #join(long, int)&#125;, &#123;<span class="hljs-doctag">@link</span> #sleep(long)&#125;, or &#123;<span class="hljs-doctag">@link</span> #sleep(long, int)&#125;,</span><br><span class="hljs-comment"> * methods of this class, then its interrupt status will be cleared and it</span><br><span class="hljs-comment"> * will receive an &#123;<span class="hljs-doctag">@link</span> InterruptedException&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If this thread is blocked in an I/O operation upon an &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * java.nio.channels.InterruptibleChannel InterruptibleChannel&#125;</span><br><span class="hljs-comment"> * then the channel will be closed, the thread&#x27;s interrupt</span><br><span class="hljs-comment"> * status will be set, and the thread will receive a &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * java.nio.channels.ClosedByInterruptException&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If this thread is blocked in a &#123;<span class="hljs-doctag">@link</span> java.nio.channels.Selector&#125;</span><br><span class="hljs-comment"> * then the thread&#x27;s interrupt status will be set and it will return</span><br><span class="hljs-comment"> * immediately from the selection operation, possibly with a non-zero</span><br><span class="hljs-comment"> * value, just as if the selector&#x27;s &#123;<span class="hljs-doctag">@link</span></span><br><span class="hljs-comment"> * java.nio.channels.Selector#wakeup wakeup&#125; method were invoked.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; If none of the previous conditions hold then this thread&#x27;s interrupt</span><br><span class="hljs-comment"> * status will be set. &lt;/p&gt;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span>  SecurityException</span><br><span class="hljs-comment"> *          if the current thread cannot modify this thread</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@revised</span> 6.0</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@spec</span> JSR-51</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span> != Thread.currentThread())<br>        <span class="hljs-comment">// 只允许中断自己，否则抛出异常</span><br>        checkAccess();<br><br>    <span class="hljs-keyword">synchronized</span> (blockerLock) &#123;<br>        <span class="hljs-type">Interruptible</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> blocker;<br>        <span class="hljs-keyword">if</span> (b != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Just to set the interrupt flag</span><br>            interrupt0();           <br>            <span class="hljs-comment">// 当前线程阻塞或者非阻塞</span><br>            b.interrupt(<span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    interrupt0();<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="countdownlatch">CountDownLatch</h2>
<p><img src="countDownLatch.png" alt="countDownLatch"></p>
<p>CountDownLatch 是一个 one-shot phenomenon，它的 state 是不能被复用的。</p>
<p>这个类的功能底层依赖于自身的 sync 的两个实现：</p>
<ul>
<li>tryAcquireShared</li>
<li>tryReleaseShared</li>
</ul>
<p>其他都是框架编织的结果。这两个方法告诉我们，try 方法不需要考虑 interruptibly/uninterruptibly。</p>
<p>在大型项目里，测试异步用例的时候经常使用如下模式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testScheduleTimeoutShouldNotRunBeforeDelay</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashedWheelTimer</span>();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">barrier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Timeout</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> timer.newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>            fail(<span class="hljs-string">&quot;This should not have run&quot;</span>);<br>            barrier.countDown();<br>        &#125;<br>    &#125;, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    assertFalse(barrier.await(<span class="hljs-number">3</span>, TimeUnit.SECONDS));<br>    assertFalse(timeout.isExpired(), <span class="hljs-string">&quot;timer should not expire&quot;</span>);<br>    timer.stop();<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="初始化">初始化</h3>
<p>自身构造器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">CountDownLatch</span><span class="hljs-params">(<span class="hljs-type">int</span> count)</span> &#123;<br>       <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br>       <span class="hljs-built_in">this</span>.sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>(count);<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>同步构造器只依赖于 setState：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">Sync(<span class="hljs-type">int</span> count) &#123;<br>        <span class="hljs-comment">// 这样就 state == count 了</span><br>        setState(count);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>sync 在共享模式和互斥模式下有很重大的区别，就是 state 在互斥模式下维护的是同一个线程求锁的次数，在共享模式下维护的是共有多少个线程持有这把锁。</p>
<h3 id="await">await</h3>
<p>在 CountDownLatch 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的隐式逻辑是：sync 内部的 state 为0则此方法可以返回，阻塞发生在改为0之前。普通的 acquire 是修改 state 成功返回，阻塞发生在获取修改 state 的权限之前，这里产生了比较大的语义差别。</p>
<h4 id="acquiresharedinterruptibly">acquireSharedInterruptibly</h4>
<p>在 AQS 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Acquires in shared mode, aborting if interrupted.  Implemented</span><br><span class="hljs-comment"> * by first checking interrupt status, then invoking at least once</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #tryAcquireShared&#125;, returning on success.  Otherwise the</span><br><span class="hljs-comment"> * thread is queued, possibly repeatedly blocking and unblocking,</span><br><span class="hljs-comment"> * invoking &#123;<span class="hljs-doctag">@link</span> #tryAcquireShared&#125; until success or the thread</span><br><span class="hljs-comment"> * is interrupted.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> arg the acquire argument.</span><br><span class="hljs-comment"> * This value is conveyed to &#123;<span class="hljs-doctag">@link</span> #tryAcquireShared&#125; but is</span><br><span class="hljs-comment"> * otherwise uninterpreted and can represent anything</span><br><span class="hljs-comment"> * you like.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException if the current thread is interrupted</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        <br>    <span class="hljs-comment">// 这里小于0意味着 state 还是保持在 sync 的 state 非0的状态，才可以进入 doAcquireSharedInterruptibly 阻塞；否则就是已经被扣减到头了，就直接返回了，这会导致上层的 await 直接返回，这就是很多的事后 await 会直接返回的原理。这种</span><br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireSharedInterruptibly(arg);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><img src="CountDownLatch%E5%85%A5%E9%98%9F1.png" alt="CountDownLatch入队1"></p>
<p>在互斥类的 acquire 里面，只有 state 不为0（已被其他线程获取锁）会导致入队。在共享类的 acquire 里，只要 state 不为 0，也入队，反复自旋，直到 state 为 0 才导致出队，让 await 降为0。</p>
<p><img src="CountDownLatch%E5%85%A5%E9%98%9F2.png" alt="CountDownLatch入队2"><br>
<img src="CountDownLatch%E5%85%A5%E9%98%9F3.png" alt="CountDownLatch入队3"></p>
<h4 id="tryacquireshared">tryAcquireShared</h4>
<p>在自定义 sync 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-comment">// 在 CountDownLatch 的sync 里 acquires 是无用的，但在其他 sync 里就可以有用</span><br>    <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>只有当 state == 0 的时候，这个方法才会返回 1，否则返回-1。这和普通的 tryAcquire 返回 boolean 有很大差别。</p>
<p><code>acquireSharedInterruptibly(arg)</code> -&gt; <code>tryAcquireShared(arg) 只做判断</code> -&gt; <code>doAcquireSharedInterruptibly(arg) 产生阻塞</code>，AQS 的框架隐藏在<code>doAcquireSharedInterruptibly</code>里：</p>
<h4 id="doacquiresharedinterruptibly">doAcquireSharedInterruptibly</h4>
<p>这个方法很像 acquireQueued，出队的条件是 state 变为 0，而不是得到了修改 state 的机会</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-comment">// 共享模式也入队，这里让每个入队的节点都带有同一个 nextWaiter</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 入队也要自旋</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 只有快要出队的节点可以这样做</span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-comment">// tryAcquireShared &gt; 0 意味着此时 aqs 没动过，或者被还原了，此时就可以考虑出队，最终让上层的 await 返回了</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 只要共享状态降为0即可以出队</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-comment">// 然后返回，让更上层返回</span><br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-comment">// 这个方法是 interruptibly 的版本，所以遇到中断应该抛出中断异常</span><br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="setheadandpropagate">setHeadAndPropagate</h4>
<p>这个方法 propagate 是很难理解的，doShare 是它试图 propagate 的东西：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setHeadAndPropagate</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> propagate)</span> &#123;<br>    <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head; <span class="hljs-comment">// Record old head for check below</span><br>    setHead(node);<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Try to signal next queued node if:</span><br><span class="hljs-comment">     *   Propagation was indicated by caller,</span><br><span class="hljs-comment">     *     or was recorded (as h.waitStatus either before</span><br><span class="hljs-comment">     *     or after setHead) by a previous operation</span><br><span class="hljs-comment">     *     (note: this uses sign-check of waitStatus because</span><br><span class="hljs-comment">     *      PROPAGATE status may transition to SIGNAL.)</span><br><span class="hljs-comment">     * and</span><br><span class="hljs-comment">     *   The next node is waiting in shared mode,</span><br><span class="hljs-comment">     *     or we don&#x27;t know, because it appears null</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * The conservatism in both of these checks may cause</span><br><span class="hljs-comment">     * unnecessary wake-ups, but only when there are multiple</span><br><span class="hljs-comment">     * racing acquires/releases, so most need signals now or soon</span><br><span class="hljs-comment">     * anyway.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">if</span> (propagate &gt; <span class="hljs-number">0</span> || h == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span> ||<br>        (h = head) == <span class="hljs-literal">null</span> || h.waitStatus &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>        <span class="hljs-comment">// shared mode 的模式在此处生效产生了一个和普通的 setHead 不同的效应，它会产生一个 doReleaseShared</span><br>        <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.isShared())<br>            doReleaseShared();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="doreleaseshared">doReleaseShared</h4>
<p>这个方法特别难，普通 tryRelease 是改动 aqs 的自身状态，但 doReleaseShared 依赖于 tryReleaseShared 的返回结果，只专心处理从 head 开始的 ws 问题，然后对 head 的后继进行 unpark。这个节点会让所有卡在 countDownLatch 的计时条件上的线程都越过门槛本身。因为 tryReleaseShared 已经把 state 扣减为0，此处做的主要是 unpark + 改 ws，doAcquireSharedInterruptibly 那里就会自己直接返回。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Ensure that a release propagates, even if there are other</span><br><span class="hljs-comment">     * in-progress acquires/releases.  This proceeds in the usual</span><br><span class="hljs-comment">     * way of trying to unparkSuccessor of head if it needs</span><br><span class="hljs-comment">     * signal. But if it does not, status is set to PROPAGATE to</span><br><span class="hljs-comment">     * ensure that upon release, propagation continues.</span><br><span class="hljs-comment">     * Additionally, we must loop in case a new node is added</span><br><span class="hljs-comment">     * while we are doing this. Also, unlike other uses of</span><br><span class="hljs-comment">     * unparkSuccessor, we need to know if CAS to reset status</span><br><span class="hljs-comment">     * fails, if so rechecking.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-comment">// 1. h == null: 说明阻塞队列为空</span><br>        <span class="hljs-comment">// 2. h == tail: 说明头节点可能是刚刚初始化的头节点，</span><br>        <span class="hljs-comment">// 或者是普通线程节点，但是此节点既然是头节点了，那么代表已经被唤醒了，阻塞队列没有其他节点了</span><br>        <span class="hljs-comment">// 所以这两种情况不需要进行唤醒后继节点</span><br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-comment">// head 如果能够被从 SIGNAL 设为 0，则 unpark head 的下一个节点，否则循环 recheck</span><br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <span class="hljs-comment">// loop to recheck cases</span><br>               <span class="hljs-comment">// 就是这里，唤醒 head 的后继节点，也就是阻塞队列中的第一个节点</span><br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-comment">// head 如果已经是 0，则把它设置为 PROPAGATE</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <span class="hljs-comment">// loop on failed CAS</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <span class="hljs-comment">// loop if head changed</span><br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="countdown">countDown</h3>
<p><img src="CountDownLatch%E9%87%8A%E6%94%BE.png" alt="CountDownLatch释放"></p>
<p><code>countDown()</code> -&gt; releaseShared(1) -&gt; tryRleaseShare(1) -&gt; doReleaseShare();</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">countDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 每次 countDown 都等于一次共享释放1</span><br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="releaseshared">releaseShared</h4>
<p>这里在完全退出的分支里，再次主动调用了 doReleaseShared</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 如果已经 state 为0，则直接返回；如果扣减不到0，也直接返回；如果扣减到0了，则执行 doReleaseShared</span><br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="tryreleaseshared">tryReleaseShared</h4>
<p>这个方法的返回值很有意思：true 意味着允许一个 acquire（不管是共享式还是互斥式的）得到一个 permit-是否要进入一个最终退出动作，这个动作只执行一次。否则，返回 false可能含有2个含义，已被扣减完，应该进入退出后状态；或者意味着先扣减得到中间态的 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>      <span class="hljs-comment">// Decrement count; signal when transition to zero</span><br>      <span class="hljs-comment">// 在 try release 系列里，这是唯一一个有自旋的</span><br>      <span class="hljs-keyword">for</span> (;;) &#123;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> getState();<br>          <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>              <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>          <span class="hljs-comment">// 这里直接做了减1，而不是减 releases</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">nextc</span> <span class="hljs-operator">=</span> c-<span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>              <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>      &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<h2 id="cyclicbarrier">CyclicBarrier</h2>
<p>cyclic 既有周期的意思，也有循环的意思。</p>
<p><img src="cyclicbarrier-1.png" alt="cyclicbarrier-1"><br>
<img src="cyclicbarrier-2.png" alt="cyclicbarrier-2"></p>
<blockquote>
<p>CyclicBarrier 的源码实现和 CountDownLatch 大相径庭，CountDownLatch 基于 AQS<br>
的共享模式的使用，而 CyclicBarrier 基于 Condition 来实现。</p>
</blockquote>
<p>这个类是一个很简单的交替地使用一个内置了 Lock 和 Condition 来维护一个 barrier waiting count 的实现。</p>
<h3 id="和countdownlatch-的区别">和CountDownLatch 的区别</h3>
<ol>
<li>CyclicBarrier 使用互斥而不是共享机制来实现多线程协同，共享状态是由 party 生成的 count。CyclicBarrier 依托 Condition。</li>
<li>而 CountDownLatch 通过共享而不是互斥来实现多线程协同，共享状态是 AQS 的 state。而 CountDownLatch 有自己的 sync。</li>
<li>CyclicBarrier 只需要每个内线程做完自己的事自动<strong>await</strong>，不需要 signal，到齐了自动就通过；CountDownLatch 让内线程<strong>countDown</strong>。CyclicBarrier 外线程等待这个到齐结果 join 所有内线程； CountDownLatch 对 latch 进行 <strong>await</strong>。</li>
</ol>
<h3 id="作者的官方示例">作者的官方示例</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solver</span> &#123;<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> N;<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">float</span>[][] data;<br>   <span class="hljs-keyword">final</span> CyclicBarrier barrier;<br><br>   <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>     <span class="hljs-type">int</span> myRow;<br>     Worker(<span class="hljs-type">int</span> row) &#123; myRow = row; &#125;<br>     <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-keyword">while</span> (!done()) &#123;<br>         processRow(myRow);<br><br>         <span class="hljs-keyword">try</span> &#123;<br>           barrier.await();<br>         &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>           <span class="hljs-keyword">return</span>;<br>         &#125; <span class="hljs-keyword">catch</span> (BrokenBarrierException ex) &#123;<br>           <span class="hljs-keyword">return</span>;<br>         &#125;<br>       &#125;<br>     &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Solver</span><span class="hljs-params">(<span class="hljs-type">float</span>[][] matrix)</span> &#123;<br>     data = matrix;<br>     N = matrix.length;<br>     <span class="hljs-type">Runnable</span> <span class="hljs-variable">barrierAction</span> <span class="hljs-operator">=</span><br>       <span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; mergeRows(...); &#125;&#125;;<br>     barrier = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(N, barrierAction);<br><br>     List&lt;Thread&gt; threads = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Thread&gt;(N);<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N; i++) &#123;<br>       <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(i));<br>       threads.add(thread);<br>       thread.start();<br>     &#125;<br><br>     <span class="hljs-comment">// wait until done</span><br>     <span class="hljs-keyword">for</span> (Thread thread : threads)<br>       thread.join();<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>在 Spring 里拿他来做测试：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pubSubLostConnectionTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">CyclicBarrier</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CyclicBarrier</span>(<span class="hljs-number">2</span>);<br>    channel.subscribe(message -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            latch.await(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        &#125;<br>    &#125;);<br>    <span class="hljs-built_in">this</span>.channel.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericMessage</span>&lt;&gt;(<span class="hljs-string">&quot;foo&quot;</span>));<br>    latch.await(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    latch.reset();<br>    <span class="hljs-type">BlockingQueueConsumer</span> <span class="hljs-variable">consumer</span> <span class="hljs-operator">=</span> (BlockingQueueConsumer) TestUtils.getPropertyValue(<span class="hljs-built_in">this</span>.channel,<br>            <span class="hljs-string">&quot;container.consumers&quot;</span>, Set.class).iterator().next();<br>    connectionFactory.destroy();<br>    waitForNewConsumer(<span class="hljs-built_in">this</span>.channel, consumer);<br>    <span class="hljs-built_in">this</span>.channel.send(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericMessage</span>&lt;&gt;(<span class="hljs-string">&quot;bar&quot;</span>));<br>    latch.await(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    <span class="hljs-built_in">this</span>.channel.destroy();<br>    <span class="hljs-built_in">this</span>.pubSubWithEP.destroy();<br>    <span class="hljs-built_in">this</span>.withEP.destroy();<br>    <span class="hljs-built_in">this</span>.pollableWithEP.destroy();<br>    assertThat(TestUtils.getPropertyValue(connectionFactory, <span class="hljs-string">&quot;connectionListener.delegates&quot;</span>, Collection.class)<br>            .size()).isEqualTo(<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有些地方还会有工具方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">waitAtBarrier</span><span class="hljs-params">(String barrierName, Map&lt;String, CyclicBarrier&gt; barriers)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        barriers.get(barrierName).await(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AssertionError</span>(<span class="hljs-string">&quot;Test didn&#x27;t complete: &quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="成员拆解">成员拆解</h3>
<p>首先，非 generation 的部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/** The lock for guarding barrier entry */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-comment">// 触动开关</span><br><span class="hljs-comment">/** Condition to wait on until tripped */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">trip</span> <span class="hljs-operator">=</span> lock.newCondition();<br><br><span class="hljs-comment">/** The number of parties */</span><br><span class="hljs-comment">// 这个数字不可扣减</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> parties;<br><br><span class="hljs-comment">/* The command to run when tripped */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable barrierCommand;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 这个数字可以扣减</span><br><span class="hljs-comment"> * Number of parties still waiting. Counts down from parties to 0</span><br><span class="hljs-comment"> * on each generation.  It is reset to parties on each new</span><br><span class="hljs-comment"> * generation or when broken.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> count;<br></code></pre></td></tr></table></figure>
<p>其次，generation 的部分：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   * Each use of the barrier is represented as a generation instance.</span><br><span class="hljs-comment">   * The generation changes whenever the barrier is tripped, or</span><br><span class="hljs-comment">   * is reset. There can be many generations associated with threads</span><br><span class="hljs-comment">   * using the barrier - due to the non-deterministic way the lock</span><br><span class="hljs-comment">   * may be allocated to waiting threads - but only one of these</span><br><span class="hljs-comment">   * can be active at a time (the one to which &#123;<span class="hljs-doctag">@code</span> count&#125; applies)</span><br><span class="hljs-comment">   * and all the rest are either broken or tripped.</span><br><span class="hljs-comment">   * There need not be an active generation if there has been a break</span><br><span class="hljs-comment">   * but no subsequent reset.</span><br><span class="hljs-comment">   */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Generation</span> &#123;<br>      <span class="hljs-type">boolean</span> <span class="hljs-variable">broken</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>  &#125;<br>  <br>    <span class="hljs-comment">/** The current generation */</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">generation</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();<br></code></pre></td></tr></table></figure>
<h3 id="构造器">构造器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a new &#123;<span class="hljs-doctag">@code</span> CyclicBarrier&#125; that will trip when the</span><br><span class="hljs-comment"> * given number of parties (threads) are waiting upon it, and which</span><br><span class="hljs-comment"> * will execute the given barrier action when the barrier is tripped,</span><br><span class="hljs-comment"> * performed by the last thread entering the barrier.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> parties the number of threads that must invoke &#123;<span class="hljs-doctag">@link</span> #await&#125;</span><br><span class="hljs-comment"> *        before the barrier is tripped</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> barrierAction the command to execute when the barrier is</span><br><span class="hljs-comment"> *        tripped, or &#123;<span class="hljs-doctag">@code</span> null&#125; if there is no action</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if &#123;<span class="hljs-doctag">@code</span> parties&#125; is less than 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties, Runnable barrierAction)</span> &#123;<br>    <span class="hljs-keyword">if</span> (parties &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    <span class="hljs-built_in">this</span>.parties = parties;<br>    <span class="hljs-built_in">this</span>.count = parties;<br>    <span class="hljs-built_in">this</span>.barrierCommand = barrierAction;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Creates a new &#123;<span class="hljs-doctag">@code</span> CyclicBarrier&#125; that will trip when the</span><br><span class="hljs-comment"> * given number of parties (threads) are waiting upon it, and</span><br><span class="hljs-comment"> * does not perform a predefined action when the barrier is tripped.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> parties the number of threads that must invoke &#123;<span class="hljs-doctag">@link</span> #await&#125;</span><br><span class="hljs-comment"> *        before the barrier is tripped</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException if &#123;<span class="hljs-doctag">@code</span> parties&#125; is less than 1</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">CyclicBarrier</span><span class="hljs-params">(<span class="hljs-type">int</span> parties)</span> &#123;<br>    <span class="hljs-built_in">this</span>(parties, <span class="hljs-literal">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="await">await</h3>
<p>这个方法既会返回，也会抛出异常。</p>
<p>它的返回值是：the arrival index of the current thread, where index getParties() - 1 indicates the first to arrive and zero indicates the last to arrive。也就是说，如果有5个线程在等，await == 4 意味着第一个返回，await == 0 意味着最后一个返回。然后可以这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里的 await 是支持 happen-before 语义的，在 await 返回的那一刻即返回</span><br><span class="hljs-keyword">if</span> (barrier.await() == <span class="hljs-number">0</span>) &#123;<br>   <span class="hljs-comment">// log the completion of this iteration</span><br> &#125;<br></code></pre></td></tr></table></figure>
<p>它有一个核心的方法，这个方法把所有的非计时转化为计时- ConditionObject 内部不是这样实现的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException &#123;<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">return</span> dowait(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>       &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>           <span class="hljs-comment">// 针对有签名但不处理的异常，我们包装为 error</span><br>           <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(toe); <span class="hljs-comment">// cannot happen</span><br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>所以我们有了计时的等待方法总能得到非计时的实现。</p>
<h3 id="dowait">dowait</h3>
<p>有4种方法可退出：<br>
- last thread arrives<br>
- 中断发生在任意一个等待线程，抛出 InterruptedException（自己被中断）或者 BrokenBarrierException （其他线程被中断）<br>
- 超时发生，抛出 BrokenBarrierException<br>
- 触发了 reset，抛出 BrokenBarrierException</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">dowait</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException, BrokenBarrierException,<br>               TimeoutException &#123;<br>        <span class="hljs-comment">// 这个内部框架在维护状态的时候，都是使用标准的 lock-check-await 的模式</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 把当前的 generation 取出来</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Generation</span> <span class="hljs-variable">g</span> <span class="hljs-operator">=</span> generation;<br><br>            <span class="hljs-comment">// 这个方法的前置检查抛出 generation 异常，作为栅栏破坏的响应，而不处理栅栏</span><br>            <span class="hljs-keyword">if</span> (g.broken)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br><br>            <span class="hljs-comment">// 一个线程检查出中断，要把其他线程破坏。所以被中断的线程是中断异常，被破坏的线程是破坏异常。中断线程可以处理栅栏。</span><br>            <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>                breakBarrier();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125;<br>            <br>            <span class="hljs-comment">// 在进行等待以前对 count 做共享减法，这个共享写的顺序能够体现在 index 里</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> --count;<br>            <br>            <span class="hljs-comment">// index 等于 0 是一个特定的事件，是最后一个线程才会触发的分支，这引出了一种写法，最后返回的分支写在等待的开头</span><br>            <span class="hljs-keyword">if</span> (index == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// tripped</span><br>                <span class="hljs-comment">// 维护一个 ranAction 状态</span><br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">ranAction</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">Runnable</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> barrierCommand;<br>                    <span class="hljs-keyword">if</span> (command != <span class="hljs-literal">null</span>)<br>                        command.run();<br>                    ranAction = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-comment">// 由最后一个线程驱动下一个 generation，理论上下一轮的 await 可以在这个时刻运行了。返回线程可以处理栅栏。</span><br>                    nextGeneration();<br>                    <span class="hljs-comment">// 这里的 return 是唯一的“无害动作”，如果这里插入任何维护状态的代码，下面的 breakBarrier 再破坏状态，可能会导致下一代的 wait 动作被集体破坏</span><br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 如果 ranAction 状态不正常，则还是要破坏栅栏</span><br>                    <span class="hljs-keyword">if</span> (!ranAction)<br>                        breakBarrier();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 非 last 动作，则只有3种方式返回</span><br>            <span class="hljs-comment">// loop until tripped, broken, interrupted, or timed out</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 区分计时和非计时的等待，然后在自旋里工作</span><br>                    <span class="hljs-keyword">if</span> (!timed)<br>                        trip.await();<br>                    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nanos &gt; <span class="hljs-number">0L</span>)<br>                        <span class="hljs-comment">// an estimate of the nanosTimeout value minus the time spent waiting upon return from this method. A positive value may be used as the argument to a subsequent call to this method to finish waiting out the desired time. A value less than or equal to zero indicates that no time remains.</span><br>                        <span class="hljs-comment">// 这个 nanos 可能成为负数，为我们超时异常提供了依据</span><br>                        nanos = trip.awaitNanos(nanos);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                    <span class="hljs-comment">// 如果此时本代仍然是同一代，则尝试破坏栅栏（这是为了让同一代里 breakBarrier 式退出 exactly once）</span><br>                    <span class="hljs-keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;<br>                        breakBarrier();<br>                        <span class="hljs-keyword">throw</span> ie;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// 如果不需要我们破坏动作，根据标准协议，收到 InterruptedException 我们也要中断线程，作为响应。</span><br>                        <span class="hljs-comment">// 我们要理解一个巨大的差别：在当代的中断我们是要忠实地履行方法签名的行为，抛出异常，不在当代则静默地中断自己</span><br>                        <span class="hljs-comment">// We&#x27;re about to finish waiting even if we had not</span><br>                        <span class="hljs-comment">// been interrupted, so this interrupt is deemed to</span><br>                        <span class="hljs-comment">// &quot;belong&quot; to subsequent execution.</span><br>                        Thread.currentThread().interrupt();<br>                    &#125;<br>                &#125;<br>                <br>                <span class="hljs-comment">// await 的正常返回带来的后置检查，这里的 g是当前代数</span><br>                <span class="hljs-keyword">if</span> (g.broken)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BrokenBarrierException</span>();<br>                <br>                <span class="hljs-comment">// 如果代数换了，就返回当前的次序，不管超时了（无意义）。只要�发生过nextGeneration，发生代切换，此处才得到许可可以出去，这又潜在要求 nextGeneration 执行替换一定发生在 signallAll 之前。但 nextGeneration 的实现却是先 signallAll 再替换 nextGeneration 的</span><br>                <span class="hljs-keyword">if</span> (g != generation)<br>                    <span class="hljs-comment">// 在这里编译器居然能保证 return 总是不漏，怎么做到的呢？</span><br>                    <span class="hljs-keyword">return</span> index;<br>                <br>                <span class="hljs-comment">//  如果排队中出现了超时，此时要处理一下</span><br>                <span class="hljs-keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                    breakBarrier();<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个方法的等待是由 await 类操作决定的，它的唤醒操作必然来自 signal 类操作，而这两类操作被隐藏在正常退出和异常退出里。</p>
<h3 id="异常退出-breakbarrier">异常退出 breakBarrier</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">breakBarrier</span><span class="hljs-params">()</span> &#123;<br>       <span class="hljs-comment">// 把当前的代破坏</span><br>       generation.broken = <span class="hljs-literal">true</span>;<br>       <span class="hljs-comment">// 把 count 复原为 parties</span><br>       count = parties;<br>       trip.signalAll();<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>异常退出是设置完状态再 signalAll。</p>
<h3 id="正常退出-nextgeneration">正常退出 nextGeneration</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">nextGeneration</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// signal completion of last generation</span><br>      trip.signalAll();<br>      <span class="hljs-comment">// set up next generation</span><br>      count = parties;<br>      generation = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Generation</span>();<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>异常退出是 signalAll 完再设置完状态。</p>
<h3 id="重置-reset">重置 reset</h3>
<p>等于先破坏栅栏再重置栅栏。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Resets the barrier to its initial state.  If any parties are</span><br><span class="hljs-comment"> * currently waiting at the barrier, they will return with a</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> BrokenBarrierException&#125;. Note that resets &lt;em&gt;after&lt;/em&gt;</span><br><span class="hljs-comment"> * a breakage has occurred for other reasons can be complicated to</span><br><span class="hljs-comment"> * carry out; threads need to re-synchronize in some other way,</span><br><span class="hljs-comment"> * and choose one to perform the reset.  It may be preferable to</span><br><span class="hljs-comment"> * instead create a new barrier for subsequent use.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 老线程要通过闭包里闭合的局部变量理解 break</span><br>        breakBarrier();   <span class="hljs-comment">// break the current generation</span><br>        <span class="hljs-comment">// 新线程使用隔离的 generation</span><br>        nextGeneration(); <span class="hljs-comment">// start a new generation</span><br>        <span class="hljs-comment">// reset 意味着 count 再次等于 parties</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="统计方法">统计方法</h3>
<h4 id="isbroken">isBroken</h4>
<p>这个方法实现了准确读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBroken</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> generation.broken;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h4 id="getnumberwaiting">getNumberWaiting</h4>
<p>这个方法也实现了准确读：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the number of parties currently waiting at the barrier.</span><br><span class="hljs-comment"> * This method is primarily useful for debugging and assertions.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> the number of parties currently blocked in &#123;<span class="hljs-doctag">@link</span> #await&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getNumberWaiting</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.lock;<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> parties - count;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="semaphore">Semaphore</h2>
<p>Semaphore 使用数字维护一个共享状态池，使用共享加解锁的思路来修改 state。</p>
<blockquote>
<p>创建 Semaphore 实例的时候，需要一个参数 permits，这个基本上可以确定是设置给 AQS 的 state 的，然后每个线程调用<br>
acquire 的时候，执行 state = state - 1，release 的时候执行 state = state +<br>
1，当然，acquire  的时候，如果 state = 0，说明没有资源了，需要等待其他线程 release。</p>
</blockquote>
<p>需要仔细设计的怎么阻塞与唤醒。</p>
<h3 id="官方示例">官方示例</h3>
<p>作者认为这是一个 permit pool。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pool</span> &#123;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MAX_AVAILABLE</span> <span class="hljs-operator">=</span> <span class="hljs-number">100</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(MAX_AVAILABLE, <span class="hljs-literal">true</span>);<br><br>   <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getItem</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     available.acquire();<br>     <span class="hljs-keyword">return</span> getNextAvailableItem();<br>   &#125;<br><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">putItem</span><span class="hljs-params">(Object x)</span> &#123;<br>     <span class="hljs-keyword">if</span> (markAsUnused(x))<br>       available.release();<br>   &#125;<br><br>   <span class="hljs-comment">// Not a particularly efficient data structure; just for demo</span><br>   <span class="hljs-keyword">protected</span> Object[] items = ... whatever kinds of items being managed<br>   <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span>[] used = <span class="hljs-keyword">new</span> <span class="hljs-title class_">boolean</span>[MAX_AVAILABLE];<br><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> Object <span class="hljs-title function_">getNextAvailableItem</span><span class="hljs-params">()</span> &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;<br>       <span class="hljs-keyword">if</span> (!used[i]) &#123;<br>          used[i] = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">return</span> items[i];<br>       &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// not reached</span><br>   &#125;<br><br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">markAsUnused</span><span class="hljs-params">(Object item)</span> &#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_AVAILABLE; ++i) &#123;<br>       <span class="hljs-keyword">if</span> (item == items[i]) &#123;<br>          <span class="hljs-keyword">if</span> (used[i]) &#123;<br>            used[i] = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>          &#125; <span class="hljs-keyword">else</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>       &#125;<br>     &#125;<br>     <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>在这个示例里对称很重要，在 op 以前就要 acquire permit，在 op 成功以后才 release permit。它的 state 恰好不是以互斥的方式 accumulated 的，是以共享的方式 accumulated 的。</p>
<p>mutex = binary semaphore = nonreentrant exclusive lock</p>
<p>这种锁是不计较 owner 的，在死锁恢复场景下尤其有用。比如有个线程 a 拿走了一个 permit 没有还，其他线程可以通过把自己的 permit 归还，来暂时制造流动性。</p>
<p>照理来讲，没有 IllegateMonitorStateException 的约束，多 release 也是有可能的，不一定需要严格按照 acquire 时线程得到的 permit进行归还。所以，CountDownLatch 和 CyclicBarrier 的state 是固定大小的，Semaphore不是。</p>
<h3 id="构造器">构造器</h3>
<p>因为信号量也是不易察觉的“类锁”的方案，所以它也有公平和非公平的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    sync = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">Semaphore</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>, <span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>(<span class="hljs-keyword">permits</span>) : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不公平抢锁可以减少调度，被称作 barging；公平抢锁可以减少饥饿。</p>
<h3 id="获取资源：四大-acquire-方法">获取资源：四大 acquire 方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>    sync.acquireShared(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">permits</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    sync.acquireSharedInterruptibly(<span class="hljs-keyword">permits</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireUninterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> <span class="hljs-keyword">permits</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">permits</span> &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>    sync.acquireShared(<span class="hljs-keyword">permits</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>有可中断和不可中断两大类 API，也有无参数和固定参数两大 API，不过 API 命名的习惯没有得到遵循，默认的 Semaphore 的方法是响应中断的。</p>
<h4 id="acquireshared">acquireShared</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这个方法很像 CountDownLatch 的 await，但少了检查中断的一部分。其中 doAcquireShared 和 CountDownLatch 一样都使用的 AQS 的原生实现。</p>
<h4 id="tryacquireshared">tryAcquireShared</h4>
<h5 id="公平">公平</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">if</span> (hasQueuedPredecessors())<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>        <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>            compareAndSetState(available, remaining))<br>            <span class="hljs-keyword">return</span> remaining;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>共享池模式使用 -1 和 1 来控制是否 doAcquireShare，所以这里返回 -1 意味着要入队，返回负数的 remaining 也是需要入队的。如果是正数则可以尝试 cas 一下。</p>
<h5 id="非公平">非公平</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>         <span class="hljs-keyword">return</span> nonfairTryAcquireShared(acquires);<br> &#125;<br> <br> <span class="hljs-comment">// 在父类里</span><br> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nonfairTryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> acquires)</span> &#123;<br>         <span class="hljs-keyword">for</span> (;;) &#123;<br>             <span class="hljs-type">int</span> <span class="hljs-variable">available</span> <span class="hljs-operator">=</span> getState();<br>             <span class="hljs-type">int</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> available - acquires;<br>             <span class="hljs-keyword">if</span> (remaining &lt; <span class="hljs-number">0</span> ||<br>                 compareAndSetState(available, remaining))<br>                 <span class="hljs-keyword">return</span> remaining;<br>         &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>公平和非公平的差别只在 hasQueuedPredecessors 的调用结果里。</p>
<h3 id="释放资源">释放资源</h3>
<p>不管用什么方式获取，释放总是用同一个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">release</span><span class="hljs-params">()</span> &#123;<br>    sync.releaseShared(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>releaseShared 和 doReleaseShared 仍然共用 AQS 的缺省实现，只有 tryReleaseShared 是使用 sync 实现。</p>
<h4 id="tryreleaseshared">tryReleaseShared</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> releases)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> getState();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> current + releases;<br>        <span class="hljs-comment">// 溢出，当然，我们一般也不会用这么大的数</span><br>        <span class="hljs-keyword">if</span> (next &lt; current) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&quot;Maximum permit count exceeded&quot;</span>);<br>        <span class="hljs-keyword">if</span> (compareAndSetState(current, next))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>获取当前的 state，按照 releases 来做加法。</p>
<h2 id="从执行器到线程池">从执行器到线程池</h2>
<blockquote>
<p>Pooling is the grouping together of resources (assets, equipment,<br>
personnel, effort, etc.) for the purposes of maximizing advantage or<br>
minimizing risk to the users. The term is used in finance, computing<br>
and equipment management.——wikipedia</p>
<p>“池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。</p>
<p>在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括：</p>
<p>内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection<br>
Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池(Object<br>
Pooling)：循环使用对象，减少资源在初始化和释放时的昂贵损耗。</p>
</blockquote>
<p>Doug Lea 对线程池的期待有：</p>
<ol>
<li>改善性能。</li>
<li>有界地利用资源（多次强调 bounds）。</li>
<li>提供统计。</li>
</ol>
<h3 id="执行器继承体系">执行器继承体系</h3>
<p>“设计良好的API应该简单、一致、可扩展。”</p>
<p><img src="ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="ThreadPoolExecutorUML类图.png"></p>
<p>我们将任务交给执行器，于是有了执行器；我们将执行器内部用 FutureTask 包装任务，于是有了同步转异步，异步转同步的设计，和多种 API；我们将执行器用线程池来实现，于是我们得到了 ThreadPoolExecutor。</p>
<ul>
<li>Executor：只定义&quot;执行&quot;契约</li>
<li>ExecutorService：定义生命周期、 多种任务类型（Runnable/Callable）、批量任务契约</li>
</ul>
<p><strong>这两层都是契约层，方法之间没有明确关联</strong>。</p>
<ul>
<li>AbstractExecutorService：只提供算法模板-这一层提供了方法在 execute 之上的实现，把 api 关联起来。但是唯独 execute 的实现空余了。</li>
<li>ThreadPoolExecutor：只实现 execute，并且围绕它搭建了一整套线程池的参考实现：Worker+状态机+队列。</li>
<li>FutureTask：只负责任务包装。但是它的<strong>两个父接口让它成为连接了 <code>execute(Runnable)</code>和<code>Future.get()</code>两个世界的桥梁</strong>。</li>
</ul>
<pre><code class="hljs mermaid">classDiagram
    class Executor &#123;
        &lt;&lt;interface&gt;&gt;
        +execute(Runnable command) void  // 基础执行契约
    &#125;
    
    class ExecutorService &#123;
        &lt;&lt;interface&gt;&gt;
        +submit(Callable~T~ task) Future~T~  // 新增：结果获取API
        +invokeAll(Collection~Callable~T~~ tasks) List~Future~T~~  // 新增：批量处理API
        +shutdown() void  // 新增：生命周期API
        +awaitTermination(long timeout, TimeUnit unit) boolean  // 新增：等待关闭API
    &#125;
    
    class AbstractExecutorService &#123;
        &lt;&lt;abstract&gt;&gt;
        # 所有高级功能都围绕 newTaskFor（有返回值和无返回值的任务类型） + execute 构建
        #newTaskFor(Callable~T~ callable) RunnableFuture~T~  // 新增：任务包装工厂API
        #newTaskFor(Runnable runnable, T value) RunnableFuture~T~  // 新增：任务包装工厂API
        
        +submit(Callable~T~ task) Future~T~  // 实现：包装+提交算法
        +invokeAll(Collection~Callable~T~~ tasks) List~Future~T~~  // 实现：批量包装+提交算法
        +invokeAny(Collection~Callable~T~~ tasks) T  // 实现：任意完成算法
        
        // 关键：execute() 是抽象的，留给子类实现
        ~execute(Runnable command) void
    &#125;
    
    class ThreadPoolExecutor &#123;
        -corePoolSize: int
        -maximumPoolSize: int
        -workQueue: BlockingQueue~Runnable~
        -workers: HashSet~Worker~
        
        +execute(Runnable command) void
        +shutdown() void
        +beforeExecute(Thread t, Runnable r) void
        +afterExecute(Runnable r, Throwable t) void
    &#125;
    
    class ForkJoinPool &#123;
        &lt;&lt;concrete&gt;&gt;
        -parallelism: int
        -workQueues: WorkQueue[]  // 工作窃取队列数组
        -commonPool: ForkJoinPool  // 静态共享池
        
        +execute(ForkJoinTask~?~ task) void  // 重载 execute，专用于 ForkJoinTask
        +submit(ForkJoinTask~T~ task) ForkJoinTask~T~  // 支持 ForkJoinTask 的 submit
        +invoke(ForkJoinTask~T~ task) T  // 同步调用并返回结果（核心方法）
        +shutdown() void
        +awaitTermination(...) boolean
        
        // 内部线程继承 ForkJoinWorkerThread
    &#125;
    
    class ForkJoinTask &#123;
        &lt;&lt;abstract&gt;&gt;
        -status: int
        +fork() ForkJoinTask~T~  // 异步执行（入队到当前线程的队列）
        +join() T  // 阻塞等待结果
        +invoke() T  // fork + join 的快捷方式
        +tryUnfork() boolean
        +quietlyComplete()
    &#125;
    
    class RecursiveTask &#123;
        &lt;&lt;abstract&gt;&gt;
        +compute() V  // 用户实现逻辑，返回结果
    &#125;
    
    class RecursiveAction &#123;
        &lt;&lt;abstract&gt;&gt;
        +compute() void  // 用户实现逻辑，无返回值
    &#125;
    
    class FutureTask &#123;
        -callable: Callable~V~
        -outcome: Object
        -state: int
        -runner: Thread
        +run() void
        +get() V
        +cancel(boolean mayInterruptIfRunning) boolean
    &#125;
    
    class Worker &#123;
        -thread: Thread
        -firstTask: Runnable
        +run() void
    &#125;
    
    class ForkJoinWorkerThread &#123;
        &lt;&lt;concrete&gt;&gt;
        -pool: ForkJoinPool
        -workQueue: WorkQueue
        +run() void  // 执行工作窃取循环
    &#125;
    
    %% 关系
    Executor &lt;|-- ExecutorService : &quot;adds lifecycle+results API&quot;
    ExecutorService &lt;|-- AbstractExecutorService : &quot;adds algorithm implementation&quot;
    AbstractExecutorService &lt;|-- ThreadPoolExecutor : &quot;adds thread pool strategy&quot;
    AbstractExecutorService &lt;|-- ForkJoinPool : &quot;adds work-stealing strategy&quot;
    
    AbstractExecutorService ..&gt; FutureTask : &quot;creates via newTaskFor()&quot;
    
    ThreadPoolExecutor o-- Worker : &quot;manages pool of&quot;
    Worker ..&gt; Runnable : &quot;executes tasks&quot;
    ThreadPoolExecutor ..&gt; FutureTask : &quot;executes via workers&quot;
    
    ForkJoinPool o-- ForkJoinWorkerThread : &quot;manages pool of&quot;
    ForkJoinWorkerThread ..&gt; WorkQueue : &quot;owns&quot;
    WorkQueue ..&gt; ForkJoinTask : &quot;holds tasks&quot;
    ForkJoinPool ..&gt; ForkJoinTask : &quot;executes via work-stealing&quot;
    
    ForkJoinTask &lt;|-- RecursiveTask : &quot;returns result&quot;
    ForkJoinTask &lt;|-- RecursiveAction : &quot;no result&quot;
    
    FutureTask ..|&gt; RunnableFuture : &quot;implements&quot;
    RunnableFuture --|&gt; Runnable : &quot;extends&quot;
    RunnableFuture --|&gt; Future : &quot;extends&quot;
    
    ForkJoinTask ..|&gt; Future : &quot;implements (indirectly via ForkJoinTask&lt;V&gt; extends Future&lt;V&gt;)&quot;
    ForkJoinTask ..|&gt; Serializable : &quot;implements&quot;</code></pre>
<h4 id="executor-接口">Executor 接口</h4>
<p>将任务提交和任务执行进行解耦（<strong>decoupling the execution mechanic</strong>）。用户无需关注如何创建线程，如何调度线程（scheduling）来执行任务，用户只需提供 Runnable 对象，将任务的运行逻辑提交到执行器(Executor)中，由 Executor 框架完成线程的调配和任务的执行部分。</p>
<p>JUC 里所有的解耦设计都不一定是异步的，它只是<strong>解耦</strong>，所以执行器本身也是可以同步执行的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">DirectExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br>    <span class="hljs-comment">// 这个类型只有这一个核心方法</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable r)</span> &#123;<br>     r.run();<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>一般而言可以认为，executor 会 spawns a new thread for each task.</p>
<h4 id="executorservice-接口">ExecutorService 接口</h4>
<p>增加了一些能力：</p>
<p>扩充执行任务的能力，补充可以为一个或一批异步任务<strong>生成 Future 的方法</strong>（），<strong>从这里开始执行器开始可以执行异步任务</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task)<br><span class="hljs-comment">// 则个 api 是很神奇的，本质上 runnable 是没有返回值的，这相当于帮我们给一个 runnable 带上一个线程运行结束的结果</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span><br><span class="hljs-comment">// 这个接口有一个神奇的特性，只有所有异步流程都执行完，才会返回，否则会 hang 住</span><br>&lt;T&gt; T <span class="hljs-title function_">invokeAny</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="hljs-comment">// 这个接口的超时ji&#x27;s</span><br>&lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br></code></pre></td></tr></table></figure>
<p>在上面的方法里，submit 能接收无结果的 Runnable、有结果的 Runnable、能返回结果的 Callable，再加上底层无返回结果的 execute，构成了4个基础的单任务api。</p>
<p>ExecutorService 还提供了管控线程池的方法，比如停止线程池的运行。</p>
<ul>
<li>shutdown 拒绝接收任务，触发 rejection policy。</li>
<li>shutdownNow 除了 shutdown 的功能以外，还会强制触发线程中断。</li>
</ul>
<p>Memory consistency effects：future.get 满足 JSL 定义的 Memory consistency properties，也就是 happens before relation。</p>
<p>理解 happens before relation 一定不要按照硬件的工作方式来理解（<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/67472344/java-volatile-and-final-volatile-as-flushing-all-memory-content">Flushing model is fundamentally flawed (it is just not how hardware works)</a>），最好从 JLS 的规范出发。</p>
<h4 id="abstractexecutorservice">AbstractExecutorService</h4>
<p>将执行任务的流程串联了起来，保证下层的实现只需关注一个执行任务的方法<code>execute</code>即可。其他契约的借口全都在这一层实现了：</p>
<ul>
<li>大部分的任务接口在这一层有了实现，它们最终都调向了 execute() 接口。</li>
<li>生命周期接口留给下一层。</li>
</ul>
<p>这一层大部分的方法实现都是这样的：</p>
<ol>
<li>把任务包装成 FutureTask。</li>
<li>用 execute 执行这个 FutureTask。因为这个 FutureTask 包住了原始的 run 方法，所以它的 exception 处理机制会比 UncaughtExceptionHandler 更快一步拦截异常。</li>
<li>把 FutureTask 实例阻塞或者不阻塞地在同步流程里直接返回。</li>
<li>外部调用者不断与这些 task 通讯决定是否状态完成。</li>
</ol>
<p>其中多种调用模式的层叠大概是这样的：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant User
    participant AbstractExecutorService
    participant ThreadPoolExecutor
    participant WorkerThread
    participant FutureTask
    
    User-&gt;&gt;AbstractExecutorService: invokeAll(tasks)
    loop for each task
        AbstractExecutorService-&gt;&gt;AbstractExecutorService: newTaskFor(task)
        AbstractExecutorService-&gt;&gt;FutureTask: new FutureTask(task)
        AbstractExecutorService-&gt;&gt;ThreadPoolExecutor: execute(futureTask)
        ThreadPoolExecutor-&gt;&gt;WorkerThread: 分配任务
        WorkerThread-&gt;&gt;FutureTask: futureTask.run()
        FutureTask-&gt;&gt;Task: callable.call()
        Task--&gt;&gt;FutureTask: 返回结果
        FutureTask-&gt;&gt;FutureTask: set(result)
    end
    
    AbstractExecutorService-&gt;&gt;AbstractExecutorService: for each future: future.get()
    loop for each future
        AbstractExecutorService-&gt;&gt;FutureTask: future.get()
        alt 任务已完成
            FutureTask--&gt;&gt;AbstractExecutorService: 立即返回结果
        else 任务未完成
            FutureTask--&gt;&gt;FutureTask: 挂起等待
            FutureTask-&gt;&gt;FutureTask: 任务完成后唤醒
            FutureTask--&gt;&gt;AbstractExecutorService: 返回结果
        end
    end
    
    AbstractExecutorService--&gt;&gt;User: 返回所有Future结果</code></pre>
<h5 id="threadpoolexecutor">ThreadPoolExecutor</h5>
<p>实现了 execute，围绕execute 的批量和异步化给出了一个经典的线程池实现。</p>
<p>将会一方面维护自身的生命周期，另一方面同时管理线程和任务，使两者良好的结合从而执行并行任务。</p>
<p><img src="ThreadPoolExecutor%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="ThreadPoolExecutor运行流程.png"></p>
<h5 id="forkjoinpool">ForkJoinPool</h5>
<p>这个线程池本身就是一个复杂框架，为 JDK 其他组件提供 yet another executor alternative。</p>
<p>这个框架有个特点：</p>
<ol>
<li>产生的线程默认是守护线程。</li>
<li>产生的线程会自动收缩-不存在空转的 core thread 问题。</li>
<li>公共线程池的名字一般叫“ForkJoinPool.commonPool-worker-1”。</li>
</ol>
<p>这里就要讨论到一个很多人忽略的问题：我们如何决定何时使用守护类线程。这类线程可以用来执行一些：</p>
<ol>
<li>临时执行的任务，这些任务之间如果存在父子关系更好。</li>
<li>后台监控类任务。</li>
<li>某些与 io 解耦的计算任务。</li>
</ol>
<p>这类线程池（包括守护线程本身）适合执行计算密集型任务，不适合执行 io 密集型任务，不然：</p>
<ol>
<li>工作线程池会在 JVM 关闭时被无声无息地杀死。</li>
<li>当其他非守护线程都结束后，这些守护线程的存在反而是 JVM 进入关闭态的理由。</li>
<li>典型的工作线程池就是 IO 线程池，和与他们绑定的计算线程池。</li>
</ol>
<p>初始化这类线程池有一些简单的工厂方法，比原始构造器更加可用：  <code>Executors.newWorkStealingPool(int parallelism)</code>。</p>
<p>更多内容见<a href="https://magicliang.github.io/2026/01/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3%EF%BC%9AForkJoinPool/">《线程池详解：ForkJoinPool》</a>。</p>
<h4 id="the-executors">The Executors</h4>
<blockquote>
<p>provides convenient factory methods for these Executors.</p>
</blockquote>
<h3 id="层次调用关系">层次调用关系</h3>
<h4 id="futuretask-作为线程池的核心任务载体">FutureTask 作为线程池的核心任务载体</h4>
<p>以  FutureTask 为核心，可以看出如下关系：</p>
<pre><code class="hljs mermaid">classDiagram
    class FutureTask &#123;
        -callable: Callable~V~
        -outcome: Object
        -state: int
        -runner: Thread
        
        +run() void
        +get() V
        +cancel(boolean) boolean
        +isDone() boolean
    &#125;
    
    class RunnableFuture &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    
    class Runnable &#123;
        &lt;&lt;interface&gt;&gt;
        +run() void
    &#125;
    
    class Future &#123;
        &lt;&lt;interface&gt;&gt;
        +get() V
        +cancel(boolean) boolean
        +isDone() boolean
    &#125;
    
    class Callable &#123;
        &lt;&lt;interface&gt;&gt;
        +call() V
    &#125;
    
    FutureTask ..|&gt; RunnableFuture : implements
    RunnableFuture --|&gt; Runnable : extends
    RunnableFuture --|&gt; Future : extends
    FutureTask o-- Callable : has
    FutureTask o-- Object : stores
    FutureTask o-- Thread : references</code></pre>
<ul>
<li>我们先产生一个新的 Future 接口，然后把 Runnable 和 Future 联合继承出 RunnableFuture。这两个类型一个是对内线程池使用，一个是对外对任务的使用者使用。</li>
<li>然后 RunnableFuture 有个经典实现类 FutureTask-这是两个经典的 RunnableFuture 的经典实现之一（<code>All Known Implementing Classes:FutureTask, SwingWorker</code>），可以认为 FutureTask 是可执行的 Future 的最忠实实现。它本身<strong>不是 Callble，但是包含 Callable</strong>。它的5个一级子成员：
<ul>
<li>callable</li>
<li>outCome 这个成员同时可以是 result 也可以是异常，由 report 自行决定处理方式</li>
<li>runner：用来状态检查，并持有它保证拥有中断能力、取消能力</li>
<li>state：这是线程池里出现的第一个状态，</li>
</ul>
</li>
<li>因为是 runnable 包着 callable，所以底层的运行模式大概是这样的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 之所以这样设计，本质上是因为 Thread 类底层也是 run，不支持 call</span><br>task.run() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行组合的 Callable</span><br>        outcome = callable.call();  <span class="hljs-comment">// &quot;Hello World&quot;</span><br>        state = NORMAL;            <span class="hljs-comment">// 状态转换</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        exception = e;             <span class="hljs-comment">// 存储异常</span><br>        state = EXCEPTIONAL;       <span class="hljs-comment">// 状态转换</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="thread-模型底层">Thread 模型底层</h5>
<p>之所以这样设计，实际上是因为 Thread 模型底层只支持 run 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java 从 1.0 开始就实现了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> Runnable target;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>            target.run();  <span class="hljs-comment">// 只能调用 run()，没有返回值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>底层的 cpp 源码是：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// HotSpot JVM 源码：thread.cpp</span><br><span class="hljs-built_in">JVM_ENTRY</span>(<span class="hljs-type">void</span>, <span class="hljs-built_in">JVM_StartThread</span>(JNIEnv* jni, jobject jthread))<br>  <span class="hljs-built_in">JVMWrapper</span>(<span class="hljs-string">&quot;JVM_StartThread&quot;</span>);<br>  <br>  <span class="hljs-comment">// 1. 从 Java 对象获取 C++ Thread 对象</span><br>  JavaThread* native_thread = java_lang_Thread::<span class="hljs-built_in">thread</span>(JNIHandles::<span class="hljs-built_in">resolve_non_null</span>(jthread));<br>  <br>  <span class="hljs-comment">// 2. 状态检查</span><br>  <span class="hljs-keyword">if</span> (native_thread-&gt;<span class="hljs-built_in">is_being_ext_suspended</span>()) &#123;<br>    native_thread-&gt;<span class="hljs-built_in">set_terminated_before_start</span>(<span class="hljs-literal">true</span>);<br>  &#125;<br>  <br>  <span class="hljs-comment">// 3. 创建操作系统线程</span><br>  <span class="hljs-keyword">if</span> (native_thread-&gt;<span class="hljs-built_in">osthread</span>() != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-comment">// 关键：调用 os::create_thread 创建 OS 线程</span><br>    <span class="hljs-keyword">if</span> (os::<span class="hljs-built_in">create_thread</span>(native_thread, java_thread)) &#123;<br>      <span class="hljs-comment">// 4. 设置线程状态为 INITIALIZED</span><br>      native_thread-&gt;<span class="hljs-built_in">set_state</span>(INITIALIZED);<br>      <br>      <span class="hljs-comment">// 5. 启动操作系统线程</span><br>      os::<span class="hljs-built_in">start_thread</span>(native_thread);<br>    &#125;<br>  &#125;<br>JVM_END<br><br><span class="hljs-comment">// Linux 实现 (os_linux.cpp)</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">os::create_thread</span><span class="hljs-params">(Thread* thread, ThreadType thr_type)</span> </span>&#123;<br>  <span class="hljs-comment">// 1. 创建 pthread_attr_t 属性</span><br>  <span class="hljs-type">pthread_attr_t</span> attr;<br>  <span class="hljs-built_in">pthread_attr_init</span>(&amp;attr);<br>  <br>  <span class="hljs-comment">// 2. 设置栈大小</span><br>  <span class="hljs-type">size_t</span> stack_size = ...; <span class="hljs-comment">// 根据线程类型设置</span><br>  <span class="hljs-built_in">pthread_attr_setstacksize</span>(&amp;attr, stack_size);<br>  <br>  <span class="hljs-comment">// 3. 关键：创建 pthread 线程</span><br>  <span class="hljs-type">pthread_t</span> tid;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;tid, &amp;attr, thread_native_entry, thread);<br>  <br>  <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 4. 保存线程 ID</span><br>    thread-&gt;<span class="hljs-built_in">set_thread_id</span>(tid);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 线程入口函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">thread_native_entry</span><span class="hljs-params">(Thread* thread)</span> </span>&#123;<br>  <span class="hljs-comment">// 1. 设置线程状态</span><br>  thread-&gt;<span class="hljs-built_in">set_state</span>(RUNNABLE);<br>  <br>  <span class="hljs-comment">// 2. 关键：调用 Java 层的 run() 方法</span><br>  thread-&gt;<span class="hljs-built_in">run</span>();<br>  <br>  <span class="hljs-comment">// 3. 线程结束处理</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// HotSpot JVM 中的关键结构，这个 javaThread 既持有操作系统线程句柄，也持有 Java 线程句柄。这样实现了平台无关性。</span><br><span class="hljs-comment">// JavaThread 确实是三位一体的设计：</span><br><span class="hljs-comment">// 1. JVM 层：JavaThread* 本身（管理 JVM 内部状态）</span><br><span class="hljs-comment">// 2. OS 层：OSThread* _osthread（操作系统资源）</span><br><span class="hljs-comment">// 3. Java 层：oop _threadObj（java.lang.Thread 对象）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaThread</span>: <span class="hljs-keyword">public</span> Thread &#123;<br><span class="hljs-keyword">private</span>:<br>  oop _threadObj;        <span class="hljs-comment">// 对应的 Java Thread 对象</span><br>  OSThread* _osthread;   <span class="hljs-comment">// 操作系统线程</span><br>  <span class="hljs-keyword">volatile</span> JavaThreadState _state; <span class="hljs-comment">// 线程状态</span><br>  <br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用 Java 层的 run() 方法</span><br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">thread_main_inner</span>();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_main_inner</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_java_lang_thread</span>()) &#123;<br>      <span class="hljs-comment">// 通过 JNI 调用 Java 层的 run() 方法</span><br>      JavaCalls::<span class="hljs-built_in">call_virtual</span>(<br>        &amp;result,<br>        klass,<br>        method,<br>        threadObj,<br>        CHECK<br>      );<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 通过 JNI 调用 Java 方法</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">call_run_method</span><span class="hljs-params">(JNIEnv* env, jobject jthread)</span> </span>&#123;<br>  jclass threadClass = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;java/lang/Thread&quot;</span>);<br>  jmethodID runMethod = env-&gt;<span class="hljs-built_in">GetMethodID</span>(threadClass, <span class="hljs-string">&quot;run&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>  <br>  <span class="hljs-comment">// 调用 Thread.run() 方法</span><br>  env-&gt;<span class="hljs-built_in">CallVoidMethod</span>(jthread, runMethod);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>整体调用的流程是从 java 到 cpp 再到 java 的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 调用链：</span><br>thread<span class="hljs-selector-class">.start</span>()<br>  → Thread<span class="hljs-selector-class">.start</span>() <span class="hljs-selector-attr">[Java]</span><br>  → <span class="hljs-built_in">start0</span>() <span class="hljs-selector-attr">[native]</span><br>  → <span class="hljs-built_in">JVM_StartThread</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → os::<span class="hljs-built_in">create_thread</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → <span class="hljs-built_in">pthread_create</span>() <span class="hljs-selector-attr">[Linux C]</span><br>  → <span class="hljs-built_in">thread_native_entry</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → JavaThread::<span class="hljs-built_in">run</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → JNI: <span class="hljs-built_in">CallVoidMethod</span>(threadObj, <span class="hljs-string">&quot;run&quot;</span>) <span class="hljs-selector-attr">[JNI]</span><br>  → Thread<span class="hljs-selector-class">.run</span>() <span class="hljs-selector-attr">[Java]</span><br>  → target<span class="hljs-selector-class">.run</span>() <span class="hljs-selector-attr">[Java]</span>  <span class="hljs-comment">// 最终调用用户代码</span><br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">classDiagram
    class JavaThread &#123;
        -OSThread* _osthread
        -oop _threadObj
        -JavaThreadState _state
        -address _stack_base
        -size_t _stack_size
        
        +run()
        +thread_main_inner()
        +osthread() OSThread*
        +threadObj() oop
    &#125;
    
    class OSThread &#123;
        -pthread_t _thread_id
        -int _thread_state
        
        +set_thread_id(pthread_t)
        +thread_id() pthread_t
    &#125;
    
    class JavaThreadObj &#123;
        &lt;&lt;Java Object&gt;&gt;
        -Runnable target
        -int threadStatus
        
        +start()
        +run()
    &#125;
    
    JavaThread o-- OSThread : &quot;持有操作系统线程&quot;
    JavaThread o-- JavaThreadObj : &quot;关联Java对象&quot;</code></pre>
<pre><code class="hljs mermaid">sequenceDiagram
    participant User as Java代码
    participant JVM as JVM(JavaThread)
    participant OS as 操作系统
    
    User-&gt;&gt;JVM: new Thread(runnable)
    JVM-&gt;&gt;JVM: 创建JavaThread对象
    JVM-&gt;&gt;JVM: 创建OSThread对象
    JVM-&gt;&gt;JVM: 关联JavaThread和OSThread
    
    User-&gt;&gt;JVM: thread.start()
    JVM-&gt;&gt;JVM: 检查状态(threadStatus)
    JVM-&gt;&gt;JVM: 添加到线程组
    JVM-&gt;&gt;JVM: 调用start0()(native)
    
    JVM-&gt;&gt;OS: os::create_thread()
    OS-&gt;&gt;OS: 创建pthread线程
    OS-&gt;&gt;OS: 设置入口为thread_native_entry
    
    OS--&gt;&gt;JVM: 线程创建成功
    JVM--&gt;&gt;User: start()返回
    
    Note over OS: 新线程开始执行
    OS-&gt;&gt;JVM: thread_native_entry(JavaThread*)
    JVM-&gt;&gt;JVM: 设置线程状态为RUNNABLE
    JVM-&gt;&gt;JVM: thread-&gt;run()
    JVM-&gt;&gt;JVM: thread_main_inner()
    
    JVM-&gt;&gt;JVM: JNI: 查找Thread.run()方法
    JVM-&gt;&gt;JVM: JavaCalls::call_virtual()
    
    JVM-&gt;&gt;User: 调用Thread.run()
    User-&gt;&gt;User: target.run()(如果target!=null)
    
    User--&gt;&gt;JVM: 返回
    JVM-&gt;&gt;JVM: 线程结束清理
    JVM-&gt;&gt;OS: 释放操作系统资源</code></pre>
<h5 id="futuretask-的-run">FutureTask 的 run()</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123;<br>    <br>    <span class="hljs-comment">// 同时实现 Runnable（可执行）和 Future（可获取结果）</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (state != NEW || !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset, <span class="hljs-literal">null</span>, Thread.currentThread()))<br>            <span class="hljs-keyword">return</span>;<br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            Callable&lt;V&gt; c = callable;<br>            <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>                V result;<br>                <span class="hljs-type">boolean</span> ran;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    result = c.call();  <span class="hljs-comment">// 执行实际任务（支持返回值）</span><br>                    ran = <span class="hljs-literal">true</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                    result = <span class="hljs-literal">null</span>;<br>                    ran = <span class="hljs-literal">false</span>;<br>                    setException(ex);  <span class="hljs-comment">// 设置异常</span><br>                &#125;<br>                <span class="hljs-keyword">if</span> (ran)<br>                    set(result);  <span class="hljs-comment">// 设置结果</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            runner = <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>            <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>                handlePossibleCancellationInterrupt(s);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="futuretask-的-runner">FutureTask 的 runner</h5>
<p>其中 runner 的注入/获取流程大致如下：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant ThreadA
    participant FutureTask
    participant ThreadB
    
    ThreadA-&gt;&gt;FutureTask: submit(task)
    FutureTask-&gt;&gt;FutureTask: state = NEW, runner = null
    
    ThreadB-&gt;&gt;FutureTask: execute(task) // 线程池线程
    FutureTask-&gt;&gt;FutureTask: CAS设置 runner = ThreadB
    FutureTask-&gt;&gt;ThreadB: 执行任务逻辑
    
    Note right of FutureTask: 此时 runner = ThreadB
    
    ThreadA-&gt;&gt;FutureTask: cancel(true)
    FutureTask-&gt;&gt;FutureTask: 检查 mayInterruptIfRunning = true
    FutureTask-&gt;&gt;ThreadB: runner.interrupt() // 使用runner字段
    
    ThreadB--&gt;&gt;FutureTask: 任务被中断
    FutureTask-&gt;&gt;FutureTask: state = INTERRUPTED
    FutureTask-&gt;&gt;FutureTask: runner = null // 清理引用
    
    Note right of FutureTask: 任务完成，runner = null</code></pre>
<h6 id="invokeall">invokeAll</h6>
<p><strong>invokeAll 是有界的</strong>，如果一次性提交了超过它界限的任务，即使这些任务是一瞬间执行的-invokeAll 也会触发拒绝，除非任务执行的速度比 for 循环调用底层的 execute 的速度还要快。</p>
<p>如果有得选，我们批量执行任务应该尽量采用 invokeAll，因为它带有这些特殊的代码块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; <span class="hljs-title function_">invokeAll</span><span class="hljs-params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="hljs-params">                                         <span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (tasks == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>        ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Future&lt;T&gt;&gt;(tasks.size());<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">done</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (Callable&lt;T&gt; t : tasks)<br>                futures.add(newTaskFor(t));<br><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> futures.size();<br><br>            <span class="hljs-comment">// Interleave time checks and calls to execute in case</span><br>            <span class="hljs-comment">// executor doesn&#x27;t have any/much parallelism.</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                execute((Runnable)futures.get(i));<br>                nanos = deadline - System.nanoTime();<br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                    <span class="hljs-keyword">return</span> futures;<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>                Future&lt;T&gt; f = futures.get(i);<br>                <span class="hljs-keyword">if</span> (!f.isDone()) &#123;<br>                    <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>)<br>                        <span class="hljs-keyword">return</span> futures;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-comment">// FutureTask 是可以重复获取的</span><br>                        f.get(nanos, TimeUnit.NANOSECONDS);<br>                    &#125; <span class="hljs-keyword">catch</span> (CancellationException ignore) &#123;<br>                    &#125; <span class="hljs-keyword">catch</span> (ExecutionException ignore) &#123;<br>                    &#125; <span class="hljs-keyword">catch</span> (TimeoutException toe) &#123;<br>                        <span class="hljs-keyword">return</span> futures;<br>                    &#125;<br>                    nanos = deadline - System.nanoTime();<br>                &#125;<br>            &#125;<br>            done = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> futures;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (!done)<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, size = futures.size(); i &lt; size; i++)                <br>                    <span class="hljs-comment">// 我们不鼓励 cancel java 线程，但是可以，而且鼓励 cancel Future</span><br>                    futures.get(i).cancel(<span class="hljs-literal">true</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<h6 id="两种针对-runnable-的-submit">两种针对 Runnable 的 submit</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 普通 submit(Runnable) - Future.get() 返回 null</span><br>Future&lt;?&gt; future3 = executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;普通任务&quot;</span>));<br><span class="hljs-type">Object</span> <span class="hljs-variable">result3</span> <span class="hljs-operator">=</span> future3.get(); <span class="hljs-comment">// result3 == null</span><br><br><span class="hljs-comment">// submit(Runnable, T result) - Future.get() 返回指定的结果</span><br>Future&lt;String&gt; future4 = executor.submit(() -&gt; System.out.println(<span class="hljs-string">&quot;带结果的任务&quot;</span>), <span class="hljs-string">&quot;自定义结果&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">result4</span> <span class="hljs-operator">=</span> future4.get(); <span class="hljs-comment">// result4 == &quot;自定义结果&quot;</span><br></code></pre></td></tr></table></figure>
<p>这里面使用到了2种适配器：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs scss">用户层：需要 <span class="hljs-built_in">submit</span>(Runnable, T result) 这样的高级API<br>       ↓<br>适配层：RunnableAdapter 提供语义适配<br>       ↓  <br>执行层：FutureTask 提供接口适配  <br>       ↓<br>基础层：ThreadPoolExecutor 只认 <span class="hljs-built_in">execute</span>(Runnable)<br></code></pre></td></tr></table></figure>
<p>也就是说，底层的 execute 本身要求一个包含 callable + result 的 runnbale - FutureTask（向底层的 execute api 适配，向外提供 Future 的 get、cancel 等能力），但是这样的 callable 最初又要经过 RunnableAdapter 从 Runnable 得来（向上向原始的没有返回值的 Runnable 适配）。</p>
<p>想象一个国际物流系统：</p>
<ul>
<li>FutureTask：相当于报关代理，将&quot;有特殊要求的货物&quot;（Callable）转换成&quot;标准集装箱&quot;（Runnable）以便运输</li>
<li>RunnableAdapter：相当于包装服务，将&quot;普通货物&quot;（Runnable）包装成&quot;带保价标签的货物&quot;（Callable），提供额外保障</li>
</ul>
<p>两类底层调用链：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 底层调用链</span><br><span class="hljs-comment">// 1. submit(callable) → new FutureTask(callable)</span><br><span class="hljs-comment">// 2. execute(futureTask) → futureTask.run()</span><br><span class="hljs-comment">// 3. futureTask.run() → callable.call() → return 42</span><br><span class="hljs-comment">// 4. future.get() → 42</span><br><br><span class="hljs-comment">// 底层调用链</span><br><span class="hljs-comment">// 1. submit(runnable, result) → Executors.callable(runnable, result) </span><br><span class="hljs-comment">//   → new RunnableAdapter(runnable, result)</span><br><span class="hljs-comment">// 2. new FutureTask(runnableAdapter) </span><br><span class="hljs-comment">//   → futureTask内部持有runnableAdapter</span><br><span class="hljs-comment">// 3. execute(futureTask) → futureTask.run()</span><br><span class="hljs-comment">// 4. futureTask.run() → runnableAdapter.call()</span><br><span class="hljs-comment">// 5. runnableAdapter.call() → runnable.run() + return successMessage</span><br><span class="hljs-comment">// 6. future.get() → successMessage</span><br></code></pre></td></tr></table></figure>
<h3 id="线程池如何维护自身状态">线程池如何维护自身状态</h3>
<p>线程池运行的状态，并不是用户显式设置的，而是伴随着线程池的运行，由内部来维护。线程池内部使用一个变量维护两个值：运行状态(runState)和线程数量 (workerCount)。在具体实现中，线程池将运行状态(runState)、线程数量 (workerCount)两个关键参数的维护放在了一起，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));<br></code></pre></td></tr></table></figure>
<p>ctl这个AtomicInteger类型，是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段， 它同时包含两部分的信息：线程池的运行状态 (runState) 和线程池内有效线程的数量 (workerCount)，高3位保存runState，低29位保存workerCount，两个变量之间互不干扰。用一个变量去存储两个值，可避免在做相关决策时，出现不一致的情况，<strong>不必为了维护两者的一致，而占用锁资源。通过阅读线程池源代码也可以发现，经常出现要同时判断线程池运行状态和线程数量的情况</strong>。线程池也提供了若干方法去供用户获得线程池当前的运行状态、线程个数。<strong>这里都使用的是位运算的方式，相比于基本运算，速度也会快很多</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br>        <span class="hljs-comment">// 29</span><br>        System.out.println(COUNT_BITS);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">shifted</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 1 与 29 个 0，所以左移意味着补 0，左移一位意味着补 1 个 0，左移 29 位意味着补 29 个 0，最后得到 30 位数：100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(shifted));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> shifted - <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 29个 1：11111111111111111111111111111</span><br>        System.out.println(Integer.toBinaryString(CAPACITY));<br>        <span class="hljs-comment">// 高 3 位为 1，低 29 位为 0：11100000000000000000000000000000，和 CAPACITY 低 29 位为 1，高 3 位为 0 恰好相反</span><br>        System.out.println(Integer.toBinaryString(~CAPACITY));<br>        System.out.println(Integer.toBinaryString(~CAPACITY));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// -1 意味着 32 个 1：11111111111111111111111111111111</span><br>        System.out.println(Integer.toBinaryString(-<span class="hljs-number">1</span>));<br>        <span class="hljs-comment">// 3 个 1 和 29 个 0：11100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(RUNNING));<br>        <br>        <span class="hljs-comment">// 重点：从后方补 0 的算法，可以把 state 的基准位从低位移到高位，这样大数的一部分就可以拿来表示有限状态了</span><br>        <br>        <span class="hljs-comment">// 0 不管位移多少位都是 0</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<br>        System.out.println(Integer.toBinaryString(SHUTDOWN));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 1 和 29 个 0：100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(STOP));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 10 和 29 个 0：1000000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(TIDYING));<br>        <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-comment">// 11 和 29 个 0：1100000000000000000000000000000</span><br>        System.out.println(Integer.toBinaryString(TERMINATED));<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> getCapacity();<br>        <span class="hljs-comment">// 把 CAPACITY 的补码按位与，这样高 32 位就可以被取出来</span><br>        <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; <br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> getCapacity();<br>        <span class="hljs-comment">// 低 32 位本身就是 workCount，这个 workCount 可以容纳很大的数</span><br>        <span class="hljs-keyword">return</span> c &amp; CAPACITY; <br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ctlOf</span><span class="hljs-params">(<span class="hljs-type">int</span> rs, <span class="hljs-type">int</span> wc)</span> &#123;<br>        <span class="hljs-keyword">return</span> rs | wc; <br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCapacity</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">shifted</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span> <span class="hljs-operator">=</span> shifted - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">return</span> CAPACITY;<br>    &#125;<br></code></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">运行状态</th>
<th style="text-align:center">状态描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RUNNING</td>
<td style="text-align:center">能接受新提交的任务，并且也能处理阻塞队列中的任务。</td>
</tr>
<tr>
<td style="text-align:center">SHUTDOWN</td>
<td style="text-align:center">关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。</td>
</tr>
<tr>
<td style="text-align:center">STOP</td>
<td style="text-align:center">不能接受新任务，【也不处理队列中的任务，会中断正在处理任务的线程。】增加了两条措施，是一个更严厉的状态，理论上只要线程被中断完，线程池就可以走向关闭</td>
</tr>
<tr>
<td style="text-align:center">TIDYING</td>
<td style="text-align:center">所有的任务都已终止了，workerCount (有效线程数) 为0，这个状态的意思不是整理中，而是整理完了。</td>
</tr>
<tr>
<td style="text-align:center">TERMINATED</td>
<td style="text-align:center">在terminated() 方法执行完后进入该状态。</td>
</tr>
</tbody>
</table>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程池生命周期.png"></p>
<p>其中 running 既是初始态，也是中间态，所以才有<code>private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</code>作为初始化块的一部分。</p>
<h4 id="尝试关闭线程池">尝试关闭线程池</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Transitions to TERMINATED state if either (SHUTDOWN and pool</span><br><span class="hljs-comment"> * and queue empty) or (STOP and pool empty).  If otherwise</span><br><span class="hljs-comment"> * eligible to terminate but workerCount is nonzero, interrupts an</span><br><span class="hljs-comment"> * idle worker to ensure that shutdown signals propagate. This</span><br><span class="hljs-comment"> * method must be called following any action that might make</span><br><span class="hljs-comment"> * termination possible -- reducing worker count or removing tasks</span><br><span class="hljs-comment"> * from the queue during shutdown. The method is non-private to</span><br><span class="hljs-comment"> * allow access from ScheduledThreadPoolExecutor.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryTerminate</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 注意这里有个自旋</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">//  尝试把把本线程池的状态改成 TIDYING -&gt; TERMINATED，所以正在 running、正在 shutdown 但队列未空、已经高于 TIDYING 都直接返回</span><br>        <span class="hljs-keyword">if</span> (isRunning(c) ||<br>            runStateAtLeast(c, TIDYING) ||<br>            (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">// 只要 wc&gt;0，就关闭并只关闭一个空闲线程（看起来这里是假设本方法通常是由线程退出来触发的，所以此处能够关掉一个就直接退出）</span><br>        <span class="hljs-keyword">if</span> (workerCountOf(c) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Eligible to terminate</span><br>            interruptIdleWorkers(ONLY_ONE);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 如果一个 worker 都没有了，就真的关闭本线程池</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这个地方做了一个多余操作，把 TIDYING 做一个 ctlOf 转化            // 先置为 TIDYING</span><br>            <span class="hljs-keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="hljs-number">0</span>))) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 通常是一个空钩子方法，这两个状态之间就差了一个钩子设计</span><br>                    terminated();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 再设置为 TERMINATED</span><br>                    ctl.set(ctlOf(TERMINATED, <span class="hljs-number">0</span>));<br>                    <span class="hljs-comment">// 已关闭才做 signalAll()</span><br>                    termination.signalAll();<br>                &#125;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-comment">// else retry on failed CAS</span><br>        <span class="hljs-comment">// 这里失败，下次再从外部进入 TIDYING -&gt; TERMINATED 的循环</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="线程池如何管理任务">线程池如何管理任务</h3>
<p>每个线程池的 Worker 管理的实质上是 FutureTask，它既是<code>Callable</code>（确切地说，wrap Callable），也是<code>Future</code>（一个最完美的任务是一个<code>RunnableFuture&lt;V&gt;</code>，用成员变量来帮助 <code>Runnable</code>来保存一个<code>Callable</code>的返回值，以供<code>Future</code>使用）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 一个可以取消的计算。</span><br><span class="hljs-comment">// 基本上只能完成一次，除非执行 runAndReset，执行完成不能再 cancel</span><br><span class="hljs-comment">// 只有计算执行完成 get 才可以获取结果，之前必然阻塞</span><br><span class="hljs-comment">// </span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * A cancellable asynchronous computation.  This class provides a base</span><br><span class="hljs-comment"> * implementation of &#123;<span class="hljs-doctag">@link</span> Future&#125;, with methods to start and cancel</span><br><span class="hljs-comment"> * a computation, query to see if the computation is complete, and</span><br><span class="hljs-comment"> * retrieve the result of the computation.  The result can only be</span><br><span class="hljs-comment"> * retrieved when the computation has completed; the &#123;<span class="hljs-doctag">@code</span> get&#125;</span><br><span class="hljs-comment"> * methods will block if the computation has not yet completed.  Once</span><br><span class="hljs-comment"> * the computation has completed, the computation cannot be restarted</span><br><span class="hljs-comment"> * or cancelled (unless the computation is invoked using</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> #runAndReset&#125;).</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;A &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; can be used to wrap a &#123;<span class="hljs-doctag">@link</span> Callable&#125; or</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Runnable&#125; object.  Because &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; implements</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> Runnable&#125;, a &#123;<span class="hljs-doctag">@code</span> FutureTask&#125; can be submitted to an</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@link</span> Executor&#125; for execution.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &lt;p&gt;In addition to serving as a standalone class, this class provides</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> protected&#125; functionality that may be useful when creating</span><br><span class="hljs-comment"> * customized task classes.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 1.5</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> Doug Lea</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> &lt;V&gt; The result type returned by this FutureTask&#x27;s &#123;<span class="hljs-doctag">@code</span> get&#125; methods</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FutureTask</span>&lt;V&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">RunnableFuture</span>&lt;V&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>线程池使用一个把 Runnable 转变为 Callable 的适配器（Callable 转 Runnable 理论上也是容易做到的，但应该没有必要转换），来兼容把 Runnable 传进 submit 的场景：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 把 runnable 和一个勉强的 result 包装成一个 callable，分三步</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>        <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>        <span class="hljs-built_in">this</span>.state = NEW;       <span class="hljs-comment">// ensure visibility of callable</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; Callable&lt;T&gt; <span class="hljs-title function_">callable</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>        <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt;(task, result);<br>    &#125;<br>    <br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RunnableAdapter</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">final</span> Runnable task;<br>        <span class="hljs-keyword">final</span> T result;<br>        RunnableAdapter(Runnable task, T result) &#123;<br>            <span class="hljs-built_in">this</span>.task = task;<br>            <span class="hljs-built_in">this</span>.result = result;<br>        &#125;<br>        <span class="hljs-comment">// 注意，这个 call() 是不抛出异常的，所以对 Java 而言，子类的签名里可以不继续抛出父类声明的异常，</span><br>        <span class="hljs-keyword">public</span> T <span class="hljs-title function_">call</span><span class="hljs-params">()</span> &#123;<br>            task.run();<br>            <span class="hljs-comment">// 组合逻辑在这一层</span><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>FutureTask 实现了 RunnableFuture，它本质上是一个携带 Runnable 和 state 的任务。</p>
<p>首先看它的状态：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The run state of this task, initially NEW.  The run state</span><br><span class="hljs-comment">     * transitions to a terminal state only in methods set,</span><br><span class="hljs-comment">     * setException, and cancel.  During completion, state may take on</span><br><span class="hljs-comment">     * transient values of COMPLETING (while outcome is being set) or</span><br><span class="hljs-comment">     * INTERRUPTING (only while interrupting the runner to satisfy a</span><br><span class="hljs-comment">     * cancel(true)). Transitions from these intermediate to final</span><br><span class="hljs-comment">     * states use cheaper ordered/lazy writes because values are unique</span><br><span class="hljs-comment">     * and cannot be further modified.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * Possible state transitions:</span><br><span class="hljs-comment">     * NEW -&gt; COMPLETING -&gt; NORMAL</span><br><span class="hljs-comment">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</span><br><span class="hljs-comment">     * NEW -&gt; CANCELLED</span><br><span class="hljs-comment">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NEW</span>          <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COMPLETING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">NORMAL</span>       <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">EXCEPTIONAL</span>  <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span>    <span class="hljs-operator">=</span> <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTING</span> <span class="hljs-operator">=</span> <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INTERRUPTED</span>  <span class="hljs-operator">=</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure>
<blockquote>
<p>值得一提的是，任务的中间状态是一个瞬态，它非常的短暂。而且任务的中间态并不代表任务正在执行，而是任务已经执行完了，正在设置最终的返回结果，所以可以这么说：<br>
只要state不处于 NEW 状态，就说明任务已经执行完毕。<br>
注意，<strong>这里的执行完毕是指传入的Callable对象的call方法执行完毕</strong>，<strong>或者抛出了异常</strong>。所以这里的COMPLETING的名字显得有点迷惑性，它并不意味着任务正在执行中，而意味着call方法已经执行完毕，正在设置任务执行的结果。</p>
</blockquote>
<p>换言之，只有 NEW 状态才是 cancellable 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Doug Lea 本身比较喜欢使用普通整数来制造状态机</span><br><span class="hljs-comment">// COMPLETING 和 INTERRUPTING 是 set state 和取消任务的中间态</span><br>    <br>    <span class="hljs-comment">/** The underlying callable; nulled out after running */</span><br>    <span class="hljs-keyword">private</span> Callable&lt;V&gt; callable;<br>    <br>    <span class="hljs-comment">// 异常和输出使用同一个 outcome，所以 outcome 不能是泛型，必须是 object</span><br>    <span class="hljs-comment">// 它是非 volatile 的，需要巧妙利用 state 读写</span><br>    <span class="hljs-comment">/** The result to return or exception to throw from get() */</span><br>    <span class="hljs-keyword">private</span> Object outcome; <span class="hljs-comment">// non-volatile, protected by state reads/writes</span><br>    <br>    <span class="hljs-comment">/** The thread running the callable; CASed during run() */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread runner;<br>    <br>    <span class="hljs-comment">/** Treiber stack of waiting threads */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WaitNode waiters;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Callable&lt;V&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">if</span> (callable == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-built_in">this</span>.callable = callable;<br>    <span class="hljs-comment">// ensure visibility of callable</span><br>    <span class="hljs-built_in">this</span>.state = NEW;       <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">FutureTask</span><span class="hljs-params">(Runnable runnable, V result)</span> &#123;<br>    <span class="hljs-built_in">this</span>.callable = Executors.callable(runnable, result);<br>            <span class="hljs-comment">// 把 volatile 变量写在写语句的最后，写在读语句的最前面，类似 monitorEnter 和 monitorExit 的语义，可以保证可见性</span><br>    <span class="hljs-comment">// ensure visibility of callable</span><br>    <span class="hljs-built_in">this</span>.state = NEW;       <br>&#125;<br></code></pre></td></tr></table></figure>
<p>它的状态管理方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCancelled</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state &gt;= CANCELLED;<br>    &#125;<br>    <span class="hljs-comment">// 只要不是 NEW 就是完成了</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isDone</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state != NEW;<br>    &#125;<br><br>    <br>    <span class="hljs-comment">// 移除并通知所有等待线程，</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Removes and signals all waiting threads, invokes done(), and</span><br><span class="hljs-comment">     * nulls out callable.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finishCompletion</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// assert state &gt; COMPLETING;</span><br>        <span class="hljs-comment">// 漂亮的声明和比对写法</span><br>        <span class="hljs-keyword">for</span> (WaitNode q; (q = waiters) != <span class="hljs-literal">null</span>;) &#123;<br>            <span class="hljs-comment">// 在 for 循环里用 cas 把 waiter 置空</span><br>            <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset, q, <span class="hljs-literal">null</span>)) &#123;        <br>                <span class="hljs-comment">// 在内层循环里把当前线程和 futureTask 的关系移除，并且</span><br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                    <span class="hljs-comment">// 在这个内存循环里面，要做的就是一个个遍历链表的 next，unpark 掉它们，并且 help gc</span><br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> q.thread;<br>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>                        q.thread = <span class="hljs-literal">null</span>;<br>                        LockSupport.unpark(t);<br>                    &#125;<br>                    <span class="hljs-type">WaitNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> q.next;<br>                    <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>                        <span class="hljs-keyword">break</span>;<br>                    q.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// unlink to help gc</span><br>                    q = next;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        done();<br>        <span class="hljs-comment">// 此处就是上面的 nulled 的意思了，任务进入终态以后 callable 也可以被回收</span><br>        callable = <span class="hljs-literal">null</span>;        <span class="hljs-comment">// to reduce footprint</span><br>    &#125;<br>    <br><span class="hljs-comment">// 通过使 permit 变成 available 的方式，使这个线程从 blocked 状态变成非 blocked 状态，或者下次调用 park 的时候非阻塞。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unpark</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">if</span> (thread != <span class="hljs-literal">null</span>)<br>            UNSAFE.unpark(thread);<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>实际被工作线程调度的 run 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-comment">// 如果不等于 new 或者 cas 把线程绑定到本 future task 上，就直接退出，这其实是一种幂等</span><br>       <span class="hljs-comment">// runner 的获取是从上下文里获得的</span><br>       <span class="hljs-keyword">if</span> (state != NEW ||<br>           !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                        <span class="hljs-literal">null</span>, Thread.currentThread()))<br>           <span class="hljs-keyword">return</span>;<br>       <span class="hljs-keyword">try</span> &#123;<br>           Callable&lt;V&gt; c = callable;<br>           <span class="hljs-comment">// 只有状态和 callable 完备才能把值设进来</span><br>           <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; state == NEW) &#123;<br>               V result;<br>               <span class="hljs-type">boolean</span> ran;<br>               <span class="hljs-keyword">try</span> &#123;<br>                   result = c.call();<br>                   ran = <span class="hljs-literal">true</span>;<br>               &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                   result = <span class="hljs-literal">null</span>;<br>                   ran = <span class="hljs-literal">false</span>;<br>                   <span class="hljs-comment">// 如果 run 出异常，就进入 setException 终态方法</span><br>                   setException(ex);<br>               &#125;<br>               <span class="hljs-keyword">if</span> (ran)<br>                   <span class="hljs-comment">// 否则，set result，走入另一种终态</span><br>                   set(result);<br>           &#125;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           <span class="hljs-comment">// runner must be non-null until state is settled to</span><br>           <span class="hljs-comment">// prevent concurrent calls to run()</span><br>           <span class="hljs-comment">// 执行完要把 runner 置空，这样上面那个 cas 对其他线程而言就会失败</span><br>           runner = <span class="hljs-literal">null</span>;<br>           <span class="hljs-comment">// state must be re-read after nulling runner to prevent</span><br>           <span class="hljs-comment">// leaked interrupts</span><br>           <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>           <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>               <span class="hljs-comment">// 可能有其他线程在 interrupting，在这里实现一套等待到  interrupted 的自旋 yield</span><br>               handlePossibleCancellationInterrupt(s);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>run 有一个重跑版本，这个版本会重复执行，但不会影响 get 的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Executes the computation without setting its result, and then</span><br><span class="hljs-comment"> * resets this future to initial state, failing to do so if the</span><br><span class="hljs-comment"> * computation encounters an exception or is cancelled.  This is</span><br><span class="hljs-comment"> * designed for use with tasks that intrinsically execute more</span><br><span class="hljs-comment"> * than once.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> &#123;<span class="hljs-doctag">@code</span> true&#125; if successfully run and reset</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">runAndReset</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (state != NEW ||<br>        !UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, runnerOffset,<br>                                     <span class="hljs-literal">null</span>, Thread.currentThread()))<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">ran</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Callable&lt;V&gt; c = callable;<br>        <span class="hljs-keyword">if</span> (c != <span class="hljs-literal">null</span> &amp;&amp; s == NEW) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                c.call(); <span class="hljs-comment">// don&#x27;t set result</span><br>                ran = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>                setException(ex);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// runner must be non-null until state is settled to</span><br>        <span class="hljs-comment">// prevent concurrent calls to run()</span><br>        runner = <span class="hljs-literal">null</span>;<br>        <span class="hljs-comment">// state must be re-read after nulling runner to prevent</span><br>        <span class="hljs-comment">// leaked interrupts</span><br>        s = state;<br>        <span class="hljs-keyword">if</span> (s &gt;= INTERRUPTING)<br>            handlePossibleCancellationInterrupt(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> ran &amp;&amp; s == NEW;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在 FutureTask 里有三类终态方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(V v)</span> &#123;<br>    <span class="hljs-comment">// 在两个 CAS 操作之间夹逼一个 outcome</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>        outcome = v;<br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, NORMAL); <span class="hljs-comment">// final state</span><br>        finishCompletion();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 几乎等同于 set，但夹逼的是把 Throwable 设进 outcome 里面</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setException</span><span class="hljs-params">(Throwable t)</span> &#123;<br>    <span class="hljs-comment">// 注意这里只能把 callable 内部的异常设置进 outcome 里面，如果本服务发生了 interrupt，则这里必然失败</span><br>    <span class="hljs-keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW, COMPLETING)) &#123;<br>        outcome = t;<br>        UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, EXCEPTIONAL); <span class="hljs-comment">// final state</span><br>        finishCompletion();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">// 从这个方法可以看出，中断也是 cancel 的一种</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">(<span class="hljs-type">boolean</span> mayInterruptIfRunning)</span> &#123;<br>    <span class="hljs-comment">// 在一个布尔表达式里面表达顺序结构</span><br>    <span class="hljs-keyword">if</span> (!(state == NEW &amp;&amp;<br>          UNSAFE.compareAndSwapInt(<span class="hljs-built_in">this</span>, stateOffset, NEW,<br>              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))<br>        <span class="hljs-comment">// 只能从 new 迁移到 INTERRUPTING 或者 CANCELLED，只要 cas 不成功，就返回 false。</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;    <span class="hljs-comment">// in case call to interrupt throws exception</span><br>        <span class="hljs-comment">// 如果取消带有中断标志</span><br>        <span class="hljs-keyword">if</span> (mayInterruptIfRunning) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> runner;<br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 强制中断这个线程</span><br>                    t.interrupt();<br>            &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-comment">// final state</span><br>                <span class="hljs-comment">// 不使用 cas，把本应用的状态设为已中断</span><br>                UNSAFE.putOrderedInt(<span class="hljs-built_in">this</span>, stateOffset, INTERRUPTED);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 所有的终态操作都有的一个操作</span><br>        finishCompletion();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果程序进入终态，则 get 终于可以得到合理的结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// get 的阻塞部分交给 awaitDone，而取值部分交给 report</span><br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-comment">// 比对状态</span><br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING)<br>        <span class="hljs-comment">// 进入计时的 awaitDone 流程，这里的计时结果是带有状态的，0L 意味着无限计时。</span><br>        s = awaitDone(<span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    <span class="hljs-comment">// 进入 report 流程</span><br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br>   <br><span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>    <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>    <span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>        (s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>    <span class="hljs-keyword">return</span> report(s);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>其中等待流程见：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Awaits completion or aborts on interrupt or timeout.</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> timed true if use timed waits</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> nanos time to wait, if timed</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@return</span> state upon completion</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">awaitDone</span><span class="hljs-params">(<span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> nanos)</span><br>     <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>     <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> timed ? System.nanoTime() + nanos : <span class="hljs-number">0L</span>;<br>     <span class="hljs-type">WaitNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>     <span class="hljs-type">boolean</span> <span class="hljs-variable">queued</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>     <span class="hljs-comment">// 这里通过自旋来实现计时等待</span><br>     <span class="hljs-keyword">for</span> (;;) &#123;<br>         <span class="hljs-comment">// 如果本线程被中断，则释放所有的 get 线程，然后抛出一个中断异常，这里引入了一个经典的设计模式，在 waiting  状态内发生 interrupt 的地方，响应中断的方式是清空中断位（而不是简单地 swap），并抛出中断异常</span><br>         <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>             <span class="hljs-comment">// 如果中断了（不正常退出），清空 waiter</span><br>             removeWaiter(q);<br>             <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>         &#125;<br><br>         <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>         <span class="hljs-comment">// 进入终态，返回 s</span><br>         <span class="hljs-keyword">if</span> (s &gt; COMPLETING) &#123;<br>             <span class="hljs-keyword">if</span> (q != <span class="hljs-literal">null</span>)<br>                 <span class="hljs-comment">// 清空等待栈的线程，waitnode 可以功成身退了，但只清空当前的 q 的 thread，并不做完整的 removeWaiter</span><br>                 q.thread = <span class="hljs-literal">null</span>;<br>             <span class="hljs-keyword">return</span> s;<br>         &#125;<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s == COMPLETING) <span class="hljs-comment">// cannot time out yet</span><br>             <span class="hljs-comment">// no-op</span><br>             Thread.<span class="hljs-keyword">yield</span>();<br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>)<br>             <span class="hljs-comment">// 这里生成了一个 waitnode，注意，这里的调用栈是等待线程 get -&gt; awaitDone()，所以此处会捕获get 线程进 waitnode 里，在本循环里产生了第一个 q 的节点。</span><br>             q = <span class="hljs-keyword">new</span> <span class="hljs-title class_">WaitNode</span>();<br>             <span class="hljs-comment">// 一般第一轮循环q 总是为 null 的，只有第二轮进入这个地方的，才会进入这个分支，而且这里可能会失败，如果失败也，这时候就会把</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!queued)<br>             <span class="hljs-comment">// 如果 q 不为空，且没有入队，则首先把当前的 waiters 放到当前的 q.next 里，然后把 q 放到本类型的 waiters 里（用新 q 代替老 waiter）</span><br>             queued = UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                                                  q.next = waiters, q);<br>         <span class="hljs-comment">// 前面两轮循环都走过了（前面两轮必须使 q 不为空，queued变成 true，才进入接下来的循环），接下来就进入 park 或者 parkNanos，看看会不会再被唤醒了</span><br>         <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (timed) &#123;<br>             nanos = deadline - System.nanoTime();<br>             <span class="hljs-comment">// 如果超时了（bu），清空 waiter</span><br>             <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                 removeWaiter(q);<br>                 <span class="hljs-keyword">return</span> state;<br>             &#125;<br>             <span class="hljs-comment">// 如果没有超时，本线程先驻留一下，驻留完进入下一个循环</span><br>             LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>         &#125;<br>         <span class="hljs-keyword">else</span><br>             <span class="hljs-comment">// 否则，无限驻留，直到下一个循环。下一个循环必须由 finishCompletion 里的 LockSupport.unpark(t); 触发</span><br>             LockSupport.park(<span class="hljs-built_in">this</span>);<br>     &#125;<br> &#125;<br> <br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Simple linked list nodes to record waiting threads in a Treiber</span><br><span class="hljs-comment">  * stack.  See other classes such as Phaser and SynchronousQueue</span><br><span class="hljs-comment">  * for more detailed explanation.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitNode</span> &#123;<br>     <span class="hljs-keyword">volatile</span> Thread thread;<br>     <span class="hljs-keyword">volatile</span> WaitNode next;<br>     WaitNode() &#123; thread = Thread.currentThread(); &#125;<br> &#125;<br> <br> <span class="hljs-comment">// 解掉链表，help gc</span><br> <span class="hljs-comment">/**</span><br><span class="hljs-comment">  * Tries to unlink a timed-out or interrupted wait node to avoid</span><br><span class="hljs-comment">  * accumulating garbage.  Internal nodes are simply unspliced</span><br><span class="hljs-comment">  * without CAS since it is harmless if they are traversed anyway</span><br><span class="hljs-comment">  * by releasers.  To avoid effects of unsplicing from already</span><br><span class="hljs-comment">  * removed nodes, the list is retraversed in case of an apparent</span><br><span class="hljs-comment">  * race.  This is slow when there are a lot of nodes, but we don&#x27;t</span><br><span class="hljs-comment">  * expect lists to be long enough to outweigh higher-overhead</span><br><span class="hljs-comment">  * schemes.</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">removeWaiter</span><span class="hljs-params">(WaitNode node)</span> &#123;<br>     <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>         node.thread = <span class="hljs-literal">null</span>;<br>         retry:<br>         <span class="hljs-keyword">for</span> (;;) &#123;          <span class="hljs-comment">// restart on removeWaiter race</span><br>             <span class="hljs-keyword">for</span> (<span class="hljs-type">WaitNode</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, q = waiters, s; q != <span class="hljs-literal">null</span>; q = s) &#123;<br>                 s = q.next;<br>                 <span class="hljs-keyword">if</span> (q.thread != <span class="hljs-literal">null</span>)<br>                     pred = q;<br>                 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>                     pred.next = s;<br>                     <span class="hljs-keyword">if</span> (pred.thread == <span class="hljs-literal">null</span>) <span class="hljs-comment">// check for race</span><br>                         <span class="hljs-keyword">continue</span> retry;<br>                 &#125;<br>                 <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!UNSAFE.compareAndSwapObject(<span class="hljs-built_in">this</span>, waitersOffset,<br>                                                       q, s))<br>                     <span class="hljs-keyword">continue</span> retry;<br>             &#125;<br>             <span class="hljs-keyword">break</span>;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>
<p>然后就把outcome 通过 report 传出来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这里使用 object 转 v，必然带来 warning</span><br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;<br>    <span class="hljs-keyword">if</span> (s == NORMAL)<br>        <span class="hljs-keyword">return</span> (V)x;<br>    <span class="hljs-keyword">if</span> (s &gt;= CANCELLED)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>();<br>    <span class="hljs-comment">// 我们在外部 get catch 的异常就是从这里抛出的。注意这个转型的用意，get 只有一个固定的执行异常，就是这个异常，表明错误来自计算过程内部</span><br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable)x);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="任务执行">任务执行</h4>
<h5 id="提交任务调度">提交任务调度</h5>
<ol>
<li>首先检测线程池运行状态，如果不是 RUNNING，则直接拒绝，线程池要保证在 RUNNING 的状态下执行任务。</li>
<li>如果workerCount &lt; corePoolSize，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= corePoolSize，且线程池内的阻塞队列未满，则将任务添加到该阻塞队列中。</li>
<li>如果workerCount &gt;= corePoolSize &amp;&amp; workerCount &lt; maximumPoolSize，且线程池内的阻塞队列已满，则创建并启动一个线程来执行新提交的任务。</li>
<li>如果workerCount &gt;= maximumPoolSize，并且线程池内的阻塞队列已满, 则根据拒绝策略来处理该任务, 默认的处理方式是直接抛异常。</li>
</ol>
<p><img src="%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.png" alt="任务调度流程.png"></p>
<h5 id="任务缓冲">任务缓冲</h5>
<p>任务缓冲模块是线程池能够管理任务的核心部分。<strong>线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将任务和线程两者解耦</strong>，不让两者直接关联，才可以做后续的分配工作。线程池中是以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。</p>
<p>阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是**（阻塞的本质即为此）：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。**阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p>
<p><img src="%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.png" alt="阻塞队列的工作原理.png"></p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">ArrayBlockingQueue</td>
<td style="text-align:center">一个用数组实现的有界阻塞队列，此队列按照先进先出(FIFO)的原则对元素进行排序。<strong>支持公平锁和非公平锁</strong>。</td>
</tr>
<tr>
<td style="text-align:center">DelayQueue</td>
<td style="text-align:center">一个实现PriorityBlockingQueue实现延迟获取的无界队列，在创建元素时，可以指定多久才能从队列中获取当前元素。只有延时期满后才能从队列中获取元素。</td>
</tr>
<tr>
<td style="text-align:center">LinkedBlockingDeque</td>
<td style="text-align:center">一个由链表结构组成的双向阻塞队列。队列头部和尾部都可以添加和移除元素，多线程并发时，<strong>可以将锁的竞争最多降到一半</strong>。</td>
</tr>
<tr>
<td style="text-align:center">LinkedBlockingQueue</td>
<td style="text-align:center">一个由链表结构组成的有界队列，此队列按照先进先出(FIFO)的原则对元素进行排序。此队列的默认长度为Integer.MAX_VALUE，<strong>所以默认创建的该队列有容量危险</strong>。</td>
</tr>
<tr>
<td style="text-align:center">LinkedTransferQueue</td>
<td style="text-align:center">一个由链表结构组成的无界阻塞队列，相当于其它队列，LinkedTransferQueue队列多了transfer和tryTransfer方法。</td>
</tr>
<tr>
<td style="text-align:center">PriorityBlockingQueue</td>
<td style="text-align:center">一个支持线程优先级排序的无界队列，默认自然序进行排序，也可以自定义实现compareTo()方法来指定元素排序规则，不能保证同优先级元素的顺序。</td>
</tr>
<tr>
<td style="text-align:center">SynchronousQueue</td>
<td style="text-align:center">一个不存储元素的阻塞队列，每一个put操作必须等待take操作，否则不能添加元素。支持公平锁和非公平锁。SynchronousQueue的一个使用场景是在线程池里。Executors.newCachedThreadPool()就使用了SynchronousQueue，这个线程池根据需要（新任务到来时）创建新的线程，如果有空闲线程则会重复使用，<strong>线程空闲了60秒后会被回收</strong>。</td>
</tr>
</tbody>
</table>
<h5 id="任务申请">任务申请</h5>
<blockquote>
<p>任务的执行有两种可能：一种是任务直接由新创建的线程执行。另一种是线程从任务队列中获取任务然后执行，执行完任务的空闲线程会再次去从队列中申请任务再去执行。第一种情况仅出现在线程初始创建的时候，第二种是线程获取任务绝大多数的情况。</p>
</blockquote>
<p>任务的执行主要有 submit-&gt;execute，submit 的主要逻辑是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="hljs-literal">null</span>);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Runnable task, T result)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException       &#123;<span class="hljs-doctag">@inheritDoc</span>&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-literal">null</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);<br>    execute(ftask);<br>    <span class="hljs-keyword">return</span> ftask;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>execute 的主要逻辑是：</p>
<p><img src="Worker%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1.png" alt="Worker执行任务.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法体现了线程池的任务调度策略的顶层设计：先 core 后 queue 后非 core 的设计思路。不过，这里面的 queue 的使用方案需要考虑线程池的状态。</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Executes the given task sometime in the future.  The task</span><br><span class="hljs-comment"> * may execute in a new thread or in an existing pooled thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * If the task cannot be submitted for execution, either because this</span><br><span class="hljs-comment"> * executor has been shutdown or because its capacity has been reached,</span><br><span class="hljs-comment"> * the task is handled by the current &#123;<span class="hljs-doctag">@code</span> RejectedExecutionHandler&#125;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> command the task to execute</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> RejectedExecutionException at discretion of</span><br><span class="hljs-comment"> *         &#123;<span class="hljs-doctag">@code</span> RejectedExecutionHandler&#125;, if the task</span><br><span class="hljs-comment"> *         cannot be accepted for execution</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> NullPointerException if &#123;<span class="hljs-doctag">@code</span> command&#125; is null</span><br><span class="hljs-comment"> */</span><br>execute(Runnable command) &#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * execute 本身也是一个经典的四步分发，线程管理就靠这一步了</span><br><span class="hljs-comment">     * Proceed in 3 steps:</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 1. If fewer than corePoolSize threads are running, try to</span><br><span class="hljs-comment">     * start a new thread with the given command as its first</span><br><span class="hljs-comment">     * task.  The call to addWorker atomically checks runState and</span><br><span class="hljs-comment">     * workerCount, and so prevents false alarms that would add</span><br><span class="hljs-comment">     * threads when it shouldn&#x27;t, by returning false.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 2. If a task can be successfully queued, then we still need</span><br><span class="hljs-comment">     * to double-check whether we should have added a thread</span><br><span class="hljs-comment">     * (because existing ones died since last checking) or that</span><br><span class="hljs-comment">     * the pool shut down since entry into this method. So we</span><br><span class="hljs-comment">     * recheck state and if necessary roll back the enqueuing if</span><br><span class="hljs-comment">     * stopped, or start a new thread if there are none.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 3. If we cannot queue task, then we try to add a new</span><br><span class="hljs-comment">     * thread.  If it fails, we know we are shut down or saturated</span><br><span class="hljs-comment">     * and so reject the task.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">recheck</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这需要用到<a href="#%E5%B0%9D%E8%AF%95%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B">尝试增加线程</a></p>
<h3 id="线程池如何管理线程">线程池如何管理线程</h3>
<p>核心线程的 idle 不影响核心线程的创建；非核心线程的 idle time 会导致它们退出。</p>
<h4 id="尝试增加线程">尝试增加线程</h4>
<p>注意 addWorker 只是 execute 的一个子分支而已。</p>
<p><img src="%E7%94%B3%E8%AF%B7%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="申请线程执行流程图.png"></p>
<p>Worker 可以被认为是线程和锁的结合体，它的使命就是不断地把 runnable 从缓冲队列里拿出来，放在自己的 thread 里执行，其中关键的方法是 addWorker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Checks if a new worker can be added with respect to current</span><br><span class="hljs-comment"> * pool state and the given bound (either core or maximum). If so,</span><br><span class="hljs-comment"> * the worker count is adjusted accordingly, and, if possible, a</span><br><span class="hljs-comment"> * new worker is created and started, running firstTask as its</span><br><span class="hljs-comment"> * first task. This method returns false if the pool is stopped or</span><br><span class="hljs-comment"> * eligible to shut down. It also returns false if the thread</span><br><span class="hljs-comment"> * factory fails to create a thread when asked.  If the thread</span><br><span class="hljs-comment"> * creation fails, either due to the thread factory returning</span><br><span class="hljs-comment"> * null, or due to an exception (typically OutOfMemoryError in</span><br><span class="hljs-comment"> * Thread.start()), we roll back cleanly.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> firstTask the task the new thread should run first (or</span><br><span class="hljs-comment"> * null if none). Workers are created with an initial first task</span><br><span class="hljs-comment"> * (in method execute()) to bypass queuing when there are fewer</span><br><span class="hljs-comment"> * than corePoolSize threads (in which case we always start one),</span><br><span class="hljs-comment"> * or when the queue is full (in which case we must bypass queue).</span><br><span class="hljs-comment"> * Initially idle threads are usually created via</span><br><span class="hljs-comment"> * prestartCoreThread or to replace other dying workers.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> core if true use corePoolSize as bound, else</span><br><span class="hljs-comment"> * maximumPoolSize. (A boolean indicator is used here rather than a</span><br><span class="hljs-comment"> * value to ensure reads of fresh values after checking other pool</span><br><span class="hljs-comment"> * state).</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> true if successful</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    <span class="hljs-comment">// retry 是外部自旋的标签。大自旋保证 rs 是稳定的，小自旋保证 wc 是稳定的，在双自旋里面保证 wc 的修改成功</span><br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 获取运行时状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>        <br>        <span class="hljs-comment">// 如果线程池关闭了，或者不是worker 的 firstTask 为空，但 workQueue 不空</span><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            ! (rs == SHUTDOWN &amp;&amp;<br>               firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>               ! workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 内层自旋</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                <span class="hljs-comment">// 其实 worker 里并没有 core 与否的属性，core 主要看比对哪个 PoolSize</span><br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 如果这次一个原子性地增加 WorkerCount 成功，则退出大自旋；否则还是在大自旋里做 cas 增加 workerCount</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">// 否则失败有两种可能：rc 变了，或者 wc 变了。看看当前 runState 是否还是大自旋的 runState</span><br>            c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-comment">// 如果不是则返回大自旋</span><br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// 如果是则 runState 不变，只是 wc 变了，在小自旋里重新获取 wc 即可</span><br>            <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// 在上层的 ctl 的修改是通过自旋来做的，不加锁，但下层就必须加锁了。这个设计实际上让 ctl 的修改和 worker 的修改解耦，实现了某种“最终一致”</span><br>    <br>    <span class="hljs-comment">// worker 的创建和添加是两个状态</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 外部传进来的 firstTask 可能为空，这里照样传进去</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-comment">// 在 Worker 构造器的内部携带的线程工厂创建的 thread 也可能为空</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 凡是修改线程池的 bookkeeping 操作，包含状态之外（比如 worker）的成员复杂流程修改的时候，都需要加锁</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// Recheck while holding lock.</span><br>                <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                <span class="hljs-comment">// shut down before lock acquired.</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-comment">// Tests if this thread is alive. A thread is alive if it has been started and has not yet died.</span><br>                    <span class="hljs-comment">// 这个方法本身是为了启动新线程，如果线程工厂不是启动新线程而是像线程池一样复用线程的话，线程就是 alive 的了（注意这个状态和线程的 status 还不一样），这时候线程池 addWorker 会失败</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable                   </span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-comment">// 更新簿记值</span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                <span class="hljs-comment">// 此时才开始线程</span><br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (! workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Rolls back the worker thread creation.</span><br><span class="hljs-comment"> * - removes worker from workers, if present</span><br><span class="hljs-comment"> * - decrements worker count</span><br><span class="hljs-comment"> * - rechecks for termination, in case the existence of this</span><br><span class="hljs-comment"> *   worker was holding up termination</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addWorkerFailed</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (w != <span class="hljs-literal">null</span>)<br>            workers.remove(w);<br>        decrementWorkerCount();<br>        <span class="hljs-comment">// 增加线程失败，会导致线程池终结</span><br>        tryTerminate();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Decrements the workerCount field of ctl. This is called only on</span><br><span class="hljs-comment"> * abrupt termination of a thread (see processWorkerExit). Other</span><br><span class="hljs-comment"> * decrements are performed within getTask.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decrementWorkerCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 减 worker count 的操作必须自旋到成功，这种小成员的自旋修改不需要 sleep！</span><br>    <span class="hljs-keyword">do</span> &#123;&#125; <span class="hljs-keyword">while</span> (! compareAndDecrementWorkerCount(ctl.get()));<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndIncrementWorkerCount</span><span class="hljs-params">(<span class="hljs-type">int</span> expect)</span> &#123;<br>    <span class="hljs-comment">// 因为 wc 在 32 位整数的低位，所以直接对 expect + 1 即可。</span><br>    <span class="hljs-keyword">return</span> ctl.compareAndSet(expect, expect + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="线程执行">线程执行</h4>
<p><img src="%E6%89%A7%E8%A1%8C%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B.png" alt="执行任务流程.png"></p>
<p>线程的执行强依赖于 worker 本身的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-comment">// worker 本身并不严重依赖自己的状态，所以不像线程池一样拥有一个 runState，但它持有一个 state，能够表达自身的锁状态。所以它自身拥有 -1、0、1 三种状态</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Class Worker mainly maintains interrupt control state for</span><br><span class="hljs-comment"> * threads running tasks, along with other minor bookkeeping.</span><br><span class="hljs-comment"> * This class opportunistically extends AbstractQueuedSynchronizer</span><br><span class="hljs-comment"> * to simplify acquiring and releasing a lock surrounding each</span><br><span class="hljs-comment"> * task execution.  This protects against interrupts that are</span><br><span class="hljs-comment"> * intended to wake up a worker thread waiting for a task from</span><br><span class="hljs-comment"> * instead interrupting a task being run.  We implement a simple</span><br><span class="hljs-comment"> * non-reentrant mutual exclusion lock rather than use</span><br><span class="hljs-comment"> * ReentrantLock because we do not want worker tasks to be able to</span><br><span class="hljs-comment"> * reacquire the lock when they invoke pool control methods like</span><br><span class="hljs-comment"> * setCorePoolSize.  Additionally, to suppress interrupts until</span><br><span class="hljs-comment"> * the thread actually starts running tasks, we initialize lock</span><br><span class="hljs-comment"> * state to a negative value, and clear it upon start (in</span><br><span class="hljs-comment"> * runWorker).</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span><br>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * This class will never be serialized, but we provide a</span><br><span class="hljs-comment">     * serialVersionUID to suppress a javac warning.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">6138294804551838833L</span>;<br><br>    <span class="hljs-comment">/** Thread this worker is running in.  Null if factory fails. */</span><br>    <span class="hljs-keyword">final</span> Thread thread;<br>    <span class="hljs-comment">/** Initial task to run.  Possibly null. */</span><br>    Runnable firstTask;<br>    <span class="hljs-comment">/** Per-thread task counter */</span><br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">long</span> completedTasks;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Creates with given first task and thread from ThreadFactory.</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> firstTask the first task (null if none)</span><br><span class="hljs-comment">     */</span><br>    Worker(Runnable firstTask) &#123;<br>        <span class="hljs-comment">// inhibit == prohibit，就是禁止中断的意思，中断前也要求锁</span><br>        setState(-<span class="hljs-number">1</span>); <span class="hljs-comment">// inhibit interrupts until runWorker</span><br>        <span class="hljs-built_in">this</span>.firstTask = firstTask;<br>        <span class="hljs-comment">// 这个方法是调用的线程池的 factory，</span><br>        <span class="hljs-built_in">this</span>.thread = getThreadFactory().newThread(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/** Delegates main run loop to outer runWorker  */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 这个方法是线程池里的方法，这样交互委托可以实现上下文的 merge，以当前的线程去读外部的上下文</span><br>        runWorker(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Lock methods</span><br>    <span class="hljs-comment">// 0 代表常态无锁</span><br>    <span class="hljs-comment">// 1 代表常态加锁</span><br>    <span class="hljs-comment">// The value 0 represents the unlocked state.</span><br>    <span class="hljs-comment">// The value 1 represents the locked state.</span><br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 启动的时候使用的-1 是一种“启动时才能使用的锁”，这里也包含进来了</span><br>        <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>    &#125;<br>    <br>    <span class="hljs-comment">// aqs 最关键的加锁方法，锁的标记位可以自定义</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        <span class="hljs-comment">// 这里体现了经典的设计模式，先 cas 把标记位加上去，然后绑定线程。这里要求线程安全的写只有锁的 cas，线程的归属却不是线程安全的</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>            setExclusiveOwnerThread(Thread.currentThread());<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> unused)</span> &#123;<br>        <span class="hljs-comment">// 恰好和上一个方法反过来</span><br>        setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>        <span class="hljs-comment">// 强制解锁，无 cas</span><br>        setState(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>        &#123; acquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>  &#123; <span class="hljs-keyword">return</span> tryAcquire(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>      &#123; release(<span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-comment">// 锁只支持互斥锁定模式，不支持共享锁定模式</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> isHeldExclusively(); &#125;<br>    <br>    <span class="hljs-comment">// 提供一种中断 worker（包括内部线程）的工作模式</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIfStarted</span><span class="hljs-params">()</span> &#123;<br>        Thread t;<br>        <span class="hljs-comment">// -1 和 1 不允许中断</span><br>        <span class="hljs-comment">// 在一个括号里实现了漂亮的取数操作</span><br>        <span class="hljs-keyword">if</span> (getState() &gt;= <span class="hljs-number">0</span> &amp;&amp; (t = thread) != <span class="hljs-literal">null</span> &amp;&amp;<br>        <span class="hljs-comment">// 线程没有被中断的时候可以被中断</span><br>        !t.isInterrupted()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                t.interrupt();<br>            &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在一个工作线程里，worker delegate 调用给线程池的 runWorker：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Main worker run loop.  Repeatedly gets tasks from queue and</span><br><span class="hljs-comment"> * executes them, while coping with a number of issues:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 1. We may start out with an initial task, in which case we</span><br><span class="hljs-comment"> * don&#x27;t need to get the first one. Otherwise, as long as pool is</span><br><span class="hljs-comment"> * running, we get tasks from getTask. If it returns null then the</span><br><span class="hljs-comment"> * worker exits due to changed pool state or configuration</span><br><span class="hljs-comment"> * parameters.  Other exits result from exception throws in</span><br><span class="hljs-comment"> * external code, in which case completedAbruptly holds, which</span><br><span class="hljs-comment"> * usually leads processWorkerExit to replace this thread.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 2. Before running any task, the lock is acquired to prevent</span><br><span class="hljs-comment"> * other pool interrupts while the task is executing, and then we</span><br><span class="hljs-comment"> * ensure that unless pool is stopping, this thread does not have</span><br><span class="hljs-comment"> * its interrupt set.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 3. Each task run is preceded by a call to beforeExecute, which</span><br><span class="hljs-comment"> * might throw an exception, in which case we cause thread to die</span><br><span class="hljs-comment"> * (breaking loop with completedAbruptly true) without processing</span><br><span class="hljs-comment"> * the task.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 4. Assuming beforeExecute completes normally, we run the task,</span><br><span class="hljs-comment"> * gathering any of its thrown exceptions to send to afterExecute.</span><br><span class="hljs-comment"> * We separately handle RuntimeException, Error (both of which the</span><br><span class="hljs-comment"> * specs guarantee that we trap) and arbitrary Throwables.</span><br><span class="hljs-comment"> * Because we cannot rethrow Throwables within Runnable.run, we</span><br><span class="hljs-comment"> * wrap them within Errors on the way out (to the thread&#x27;s</span><br><span class="hljs-comment"> * UncaughtExceptionHandler).  Any thrown exception also</span><br><span class="hljs-comment"> * conservatively causes thread to die.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 5. After task.run completes, we call afterExecute, which may</span><br><span class="hljs-comment"> * also throw an exception, which will also cause thread to</span><br><span class="hljs-comment"> * die. According to JLS Sec 14.20, this exception is the one that</span><br><span class="hljs-comment"> * will be in effect even if task.run throws.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * The net effect of the exception mechanics is that afterExecute</span><br><span class="hljs-comment"> * and the thread&#x27;s UncaughtExceptionHandler have as accurate</span><br><span class="hljs-comment"> * information as we can provide about any problems encountered by</span><br><span class="hljs-comment"> * user code.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">runWorker</span><span class="hljs-params">(Worker w)</span> &#123;<br>    <span class="hljs-comment">// 这里为什么不使用 worker 里面的线程呢？</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">wt</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-comment">// 做一个置换/置空操作</span><br>    <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> w.firstTask;<br>    w.firstTask = <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 在对象初始化的时候触发了加锁，在线程启动的时候触发了解锁。线程池的 shutdown 方法本身会 interrupt worker，这里不允许在锁周期里面 interrupt worker</span><br>    w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>    <span class="hljs-comment">// 突然完成默认为真</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">completedAbruptly</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// getTask 里封装了复杂的取任务流程，这里在一个表达式里面实现了漂亮的取任务操作</span><br>        <span class="hljs-comment">// 本线程只有在 getTask 取不到的时候才退出</span><br>        <span class="hljs-keyword">while</span> (task != <span class="hljs-literal">null</span> || (task = getTask()) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 只在 run 一个 task 的时候锁定自己一次，不可重入</span><br>            w.lock();<br>            <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>            <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>            <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>            <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>            <span class="hljs-comment">// 如果线程池本身已经进入停止及以后状态，则直接求 工作线程的中断状态。否则，做一轮线程的中断，再求线程池状态（中断居然会影响线程池的状态，很奇怪？），再求工作线程的中断状态。这里有一个比较炫技的地方，wt 和 currentThread 都是当前线程，但偏偏不使用 wt 里的线程        </span><br>            <span class="hljs-comment">// 这里的思想是：不能由命令触发中断，必须由状态触发中断</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                <span class="hljs-comment">// 或者</span><br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                <span class="hljs-comment">// 遇到这些情况，就要中断 wt，在这里。所以内部线程是由 getTask 内部的流程中断的，然后才去执行下面的 run，看看下面的 run 会不会响应</span><br>                wt.interrupt();<br>            <span class="hljs-comment">// 线程的中断也不会影响接下来的 task.run()</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通常这个方法是空方法</span><br>                beforeExecute(wt, task);<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">thrown</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// runnable.run()</span><br>                    task.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    <span class="hljs-comment">// 有这样的写法就意味着要在 finally 留存 thrown</span><br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// thrown 是给 afterExecute 准备的</span><br>                    afterExecute(task, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                task = <span class="hljs-literal">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 只有在 getTask 取不到的时候退出，这个值才是false，其他时候都算是“突然退出”</span><br>        completedAbruptly = <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 阻塞式获取任务。</span><br><span class="hljs-comment">// 遇到异常情况给上游的返回值是 null：</span><br><span class="hljs-comment">// 1. 有超过maximumPoolSize 的线程数，这时候返回 null 会导致它退出。</span><br><span class="hljs-comment">// 2. 线程池 stopped 了（由 shutdownNow 来触发，比 shutdown 更严厉），这时候线程池也会用 null 的方式指示线程有序退出</span><br><span class="hljs-comment">// 3. 线程池 shutdown，且队列为空（其实光是本条件就可以返回 null，只是如果线程池还在工作中，队列应该让 getTask 的线程阻塞等待）</span><br><span class="hljs-comment">// 4. 线程超时。真正的超时实际上有两种：线程数超过 core 且超时，连 core 都允许超时且超时</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Performs blocking or timed wait for a task, depending on</span><br><span class="hljs-comment"> * current configuration settings, or returns null if this worker</span><br><span class="hljs-comment"> * must exit because of any of:</span><br><span class="hljs-comment"> * 1. There are more than maximumPoolSize workers (due to</span><br><span class="hljs-comment"> *    a call to setMaximumPoolSize).</span><br><span class="hljs-comment"> * 2. The pool is stopped.</span><br><span class="hljs-comment"> * 3. The pool is shutdown and the queue is empty.</span><br><span class="hljs-comment"> * 4. This worker timed out waiting for a task, and timed-out</span><br><span class="hljs-comment"> *    workers are subject to termination (that is,</span><br><span class="hljs-comment"> *    &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut || workerCount &gt; corePoolSize&#125;)</span><br><span class="hljs-comment"> *    both before and after the timed wait, and if the queue is</span><br><span class="hljs-comment"> *    non-empty, this worker is not the last thread in the pool.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span> task, or null if the worker must exit, in which case</span><br><span class="hljs-comment"> *         workerCount is decremented</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">private</span> Runnable <span class="hljs-title function_">getTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">timedOut</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br>    <span class="hljs-comment">// 在自旋里面</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br>        <br>        <span class="hljs-comment">// 第一类情况返回 null</span><br>        <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br><br>        <span class="hljs-comment">// Are workers subject to culling? 是否要强制减少线程数？是的话就要引入计时了</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">timed</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut || wc &gt; corePoolSize;<br>        <span class="hljs-comment">// 超时返回 null 的场景，但注意这里要能减掉一个线程才能返回 null。</span><br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-comment">// 减线程数目（不一定成功，如 wc == 0 也可能进入这个语句块）</span><br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 不能减线程则 cas 失败，进入大循环里继续</span><br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="回收线程">回收线程</h4>
<blockquote>
<p>Worker是通过继承AQS，使用AQS来实现独占锁这个功能。没有使用可重入锁ReentrantLock，而是使用AQS，为的就是实现不可重入的特性去反映线程现在的执行状态。</p>
<p>1.lock方法一旦获取了独占锁，表示当前线程正在执行任务中。<br>
2.如果正在执行任务，则不应该中断线程。 3.如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断。 4.线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；如果线程是空闲状态则可以安全回收。</p>
</blockquote>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%BF%87%E7%A8%8B.png" alt="线程池回收线程的过程.png"><br>
<img src="%E7%BA%BF%E7%A8%8B%E9%94%80%E6%AF%81%E6%B5%81%E7%A8%8B.png" alt="线程销毁流程.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-comment">// 处理一些关闭和簿记工作：</span><br>   <span class="hljs-comment">// 1. 只能被从 worker 线程里调用，也就是说只能在 runWorker 方法里被调用</span><br>   <span class="hljs-comment">// 2. 先尝试把 workerCount 减一</span><br>   <span class="hljs-comment">// 3. 把 worker 从工作集里移除</span><br>   <span class="hljs-comment">// 4. 尝试终结线程池</span><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Performs cleanup and bookkeeping for a dying worker. Called</span><br><span class="hljs-comment">    * only from worker threads. Unless completedAbruptly is set,</span><br><span class="hljs-comment">    * assumes that workerCount has already been adjusted to account</span><br><span class="hljs-comment">    * for exit.  This method removes thread from worker set, and</span><br><span class="hljs-comment">    * possibly terminates the pool or replaces the worker if either</span><br><span class="hljs-comment">    * it exited due to user task exception or if fewer than</span><br><span class="hljs-comment">    * corePoolSize workers are running or queue is non-empty but</span><br><span class="hljs-comment">    * there are no workers.</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> w the worker</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> completedAbruptly if the worker died due to user exception</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-type">boolean</span> completedAbruptly)</span> &#123;<br>       <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>           <span class="hljs-comment">// 只要能够成功减一就行了</span><br>           decrementWorkerCount();<br>       <br>       <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>       mainLock.lock();<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">// 不管怎样退出，都把 worker 的完成任务数加总到线程池的总数里</span><br>           completedTaskCount += w.completedTasks;<br>           <span class="hljs-comment">// 移除本 worker</span><br>           workers.remove(w);<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           mainLock.unlock();<br>       &#125;<br>       <span class="hljs-comment">// 每个 worker 终结都尝试终结线程池</span><br>       tryTerminate(); <br><br>       <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>       <span class="hljs-comment">// 如果线程池没有真的被真的关闭，可以加减线程池里的线程</span><br>       <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>           <span class="hljs-comment">// 如果线程池正常关闭</span><br>           <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>               <span class="hljs-comment">// allowCoreThreadTimeOut 通常为 false，所以线程池的最小值应该是 corePoolSize，否则核心线程数可以归零</span><br>               <span class="hljs-type">int</span> <span class="hljs-variable">min</span> <span class="hljs-operator">=</span> allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>               <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                   <span class="hljs-comment">// 如果缓冲队列不空，则最小线程数需要维持在 1</span><br>                   min = <span class="hljs-number">1</span>;<br>               <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                   <span class="hljs-comment">// 如果当前工作线程数大于等于 min，则直接退出</span><br>                   <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>           &#125;<br>           <span class="hljs-comment">// 反之则认为工作线程数小于 min，需要增加非核心线程（增加非核心线程实际上也是在增加核心线程），这里的设计思想是任何一个线程退出都应该增加一个线程，所以就当作非核心线程增加了</span><br>           addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>       &#125;<br>   &#125;<br>   <br>   <span class="hljs-comment">// 这个方法在线程退出时只关闭一个【空闲线程】，但在线程池关闭等场景下，会关闭所有的空闲线程，这样线程池最终就关闭了-因为每个worker 退出的时候最少都会关闭一个空闲线程，全局的线程最终得以全部关闭。但线程池的核心参数如 keepAliveTime、corePoolSize、maximumPoolSize 有变化的时候，都会触发全部空闲线程关闭</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * Interrupts threads that might be waiting for tasks (as</span><br><span class="hljs-comment">    * indicated by not being locked) so they can check for</span><br><span class="hljs-comment">    * termination or configuration changes. Ignores</span><br><span class="hljs-comment">    * SecurityExceptions (in which case some threads may remain</span><br><span class="hljs-comment">    * uninterrupted).</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> onlyOne If true, interrupt at most one worker. This is</span><br><span class="hljs-comment">    * called only from tryTerminate when termination is otherwise</span><br><span class="hljs-comment">    * enabled but there are still other workers.  In this case, at</span><br><span class="hljs-comment">    * most one waiting worker is interrupted to propagate shutdown</span><br><span class="hljs-comment">    * signals in case all threads are currently waiting.</span><br><span class="hljs-comment">    * Interrupting any arbitrary thread ensures that newly arriving</span><br><span class="hljs-comment">    * workers since shutdown began will also eventually exit.</span><br><span class="hljs-comment">    * To guarantee eventual termination, it suffices to always</span><br><span class="hljs-comment">    * interrupt only one idle worker, but shutdown() interrupts all</span><br><span class="hljs-comment">    * idle workers so that redundant workers exit promptly, not</span><br><span class="hljs-comment">    * waiting for a straggler task to finish.</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interruptIdleWorkers</span><span class="hljs-params">(<span class="hljs-type">boolean</span> onlyOne)</span> &#123;<br>       <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>       mainLock.lock();<br>       <span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-keyword">for</span> (Worker w : workers) &#123;<br>               <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>               <span class="hljs-comment">// 能够被关闭的线程是一个能够拿到内部锁的线程</span><br>               <span class="hljs-keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;<br>                   <span class="hljs-keyword">try</span> &#123;<br>                       <span class="hljs-comment">// 中断，这个线程内部的工作线程能不能响应看 runnable 内部的实现了</span><br>                       t.interrupt();<br>                   &#125; <span class="hljs-keyword">catch</span> (SecurityException ignore) &#123;<br>                   &#125; <span class="hljs-keyword">finally</span> &#123;<br>                       w.unlock();<br>                   &#125;<br>               &#125;<br>               <span class="hljs-keyword">if</span> (onlyOne)<br>                   <span class="hljs-keyword">break</span>;<br>           &#125;<br>       &#125; <span class="hljs-keyword">finally</span> &#123;<br>           mainLock.unlock();<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>
<h3 id="线程池使用中可能遇到的问题">线程池使用中可能遇到的问题</h3>
<p>线程池的调参有几个难点：</p>
<ol>
<li>如果核心线程数过小，则吞吐可能不够，遇到流量矛刺可能导致 RejectExecutionException；但值得警惕的是，如果核心线程数很大，可能导致频繁的上下文切换和过多的资源消耗（不管是 cpu 时间片还是操作系统的内核线程）。</li>
<li>如果队列过长，导致请求数量增加时，大量任务堆积在队列中，任务执行时间过长，最终导致下游服务的大量调用超时失败。</li>
</ol>
<p>那么，如何计算这些参数呢？<br>
有一个基本的原则是：</p>
<ol>
<li>计算密集型的线程数本身应该尽量贴进 cpu 核数。</li>
<li>io 密集型的线程数要注意伸缩，要配合阻塞队列使用，要有承受拒绝失败的的准备。</li>
</ol>
<p>我们常见的计算方式主要来自于《Java并发编程实战》：</p>
<p><img src="%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F.png" alt="线程池计算公式.png"></p>
<p>现实中可选的线程数计算公式最好是取一个并发 qps 数和 cpu 数的折中。通常可以认为 单任务的 rt/1ms 可以得到单一线程的吞吐数，qps 除以吞吐数可以得到 qps 相应的线程数，但这个方案没有考虑cpu 核数和上下文切换的问题。所以这样算出来的线程数的实际 qps 表现应该低于理论 qps，但可以通过估算和压测不断让理论值逼近实际值。</p>
<h3 id="线程池的可替换方案">线程池的可替换方案</h3>
<p>其他可替代方案，都不如线程池的调优方案成熟（<strong>在可以使用新技术的前提下，我们是否还有调优旧方案的魄力呢？</strong>）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">描述</th>
<th style="text-align:center">优势</th>
<th style="text-align:center">劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Disruptor框架</td>
<td style="text-align:center">线程池内部是通过一个工作队列去维护任务的执行的，它有一个根本性的缺陷：连续争用问题。也就是多个线程在申请任务时，为了合理地分配任务要付出锁资源，对比快速的任务执行来说，这部分申请的损耗是巨大的。高性能进程间消息库LMAX使用了一个叫作环形缓冲的数据结构，用这种这个特殊的数据结构替代队列，将会避免申请任务时出现的连续争用状况。</td>
<td style="text-align:center">避免连续争用，性能更佳</td>
<td style="text-align:center">缺乏线程管理的能力，使用场景较少</td>
</tr>
<tr>
<td style="text-align:center">协程框架</td>
<td style="text-align:center">协程是一种用户态的轻量级线程，其拥有自己的寄存器上下文和栈，当调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。这种切换上下文的方式要小于线程的开销。在瓶颈侧重IO的情况，使用协程获得并发性要优于使用线程。</td>
<td style="text-align:center">侧重IO情况时，性能更佳。与多线程策略无冲突，可结合使用</td>
<td style="text-align:center">在Java中缺乏成熟的应用</td>
</tr>
<tr>
<td style="text-align:center">Actor框架</td>
<td style="text-align:center">Actor模型通过维护多个Actor去处理并发的任务，它放弃了直接使用线程去获取并发性，而是自己定义了一系列系统组件应该如何动作和交互的通用规则，不需要开发者直接使用线程。通过在原生的线程或协程的级别上做了更高层次的封装，只需要开发者关心每个Actor的逻辑即可实现并发操作。由于避免了直接使用锁，很大程度解决了传统并发编程模式下大量依赖悲观锁导致的资源竞争情况。</td>
<td style="text-align:center">无锁策略，性能更佳，避免直接使用线程，安全性更高</td>
<td style="text-align:center">在Java中缺乏成熟的应用，内部复杂，难以排查和调试</td>
</tr>
</tbody>
</table>
<p>缺乏管控能力就不适合调优。</p>
<h3 id="最终解决方案">最终解决方案</h3>
<p>通过监控线程池负载，制定告警策略：</p>
<ol>
<li>线程池活跃度 = activeCount/maximumPoolSize。看看这个值是不是趋近于 1。</li>
<li>监控队列的capacity 和 size 的比例。</li>
<li>监控 RejectExecutionException 的出现。</li>
</ol>
<p>加引入线程池动态管控能力，基于告警制定 sop，确定是否要动态调节线程数和拒绝策略。</p>
<p>如果还是解决不了问题，需要考虑全局动态扩容的方案。</p>
<p>这里的 activeCount 是每个 worker 是否互斥 held 的总数的统计：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getActiveCount</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// workers 是一个 HashSet，它是非线程安全的。</span><br>getActiveCount 需要遍历这个集合，如果不加全局的 mainLock，在遍历过程中如果有线程销毁或创建，会抛出 ConcurrentModificationException 或者读到错误的数据。所以 mainLock 是为了保护 workers 集合的遍历安全。<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (Worker w : workers)<br>                <span class="hljs-comment">// 在 ThreadPoolExecutor 的设计中，Worker 只要开始执行任务（runWorker 方法中），就会把自己锁住（lock）。</span><br>                <span class="hljs-comment">// 当 Worker 没有任务做，正在 getTask() 方法里阻塞等待（即空闲状态）时，它是**不加锁（unlocked）**的。</span><br>               <span class="hljs-comment">// 所以，isLocked() == true 等价于 “这个线程正在干活”。</span><br>getActiveCount 的目的就是统计“当前有多少个线程正在干活”，所以必须统计被锁住的 Worker。<br>                <span class="hljs-keyword">if</span> (w.isLocked())<br>                    ++n;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这里的 isLocked 意味着这个工作线程正在跑  task 的run，意味着可能是如下状态：RUNNABLE、BLOCKED、WAITING、TIMED_WAITING。</p>
<h2 id="线程组">线程组</h2>
<p>线程组提供一个“集合”，可以把一群线程归于一处，可以批量 interrupt/stop/suspend。<br>
但这个方案是很危险的，使用线程池和并发安全的 Collection 都可以管理好线程。</p>
<h3 id="原本设计目的">原本设计目的</h3>
<ul>
<li>资源管理：将相关线程组织在一起，便于批量操作</li>
<li>安全隔离：不同线程组可以有不同的安全策略</li>
<li>异常处理：提供组级别的未捕获异常处理</li>
<li>层次结构：支持线程组的嵌套（parent-child关系）</li>
</ul>
<h3 id="缺陷">缺陷</h3>
<ul>
<li>API设计不一致且不完整</li>
<li>线程安全问题</li>
<li>功能缺失</li>
<li>安全模型过时</li>
</ul>
<h3 id="替代方案">替代方案</h3>
<ul>
<li>Executor框架</li>
<li>CompletableFuture</li>
<li>ForkJoinPool</li>
</ul>
<h3 id="官方态度">官方态度</h3>
<ul>
<li>Java 17+：线程组API标记为<code>@Deprecated(forRemoval = true)</code></li>
<li>JEP 411：移除SecurityManager，线程组失去最后的存在意义</li>
<li>OpenJDK邮件列表：多次讨论完全移除线程组</li>
</ul>
<h2 id="completionstage">CompletionStage</h2>
<p>这是定义“可能是”异步计算的一个阶段，可能被其他阶段触发，也可以触发其他阶段。它是 CompletableFuture 的父接口。</p>
<p>它有一个特点，大量非 void 方法返回值都是 CompletionStage 类型，这样既允许 builder 模式，也允许各种 transformation 模式。</p>
<h2 id="completablefuture">CompletableFuture</h2>
<p>线程池的超时中断机制</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">invokeAll(tasks, <span class="hljs-number">300L</span>, TimeUnit.MILLISECONDS);<br></code></pre></td></tr></table></figure>
<p>会让这个类型中断提前返回：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">432369</span>-Caused by: java.lang.InterruptedException: <span class="hljs-literal">null</span><br><span class="hljs-number">432370</span>- at java.util.concurrent.CompletableFuture.reportGet(CompletableFuture.java:<span class="hljs-number">347</span>)<br><span class="hljs-number">432371</span>- at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:<span class="hljs-number">1915</span>)<br><span class="hljs-number">432372</span>- at org.apache.dubbo.rpc.AsyncRpcResult.get(AsyncRpcResult.java:<span class="hljs-number">196</span>)<br><span class="hljs-number">432373</span>- at org.apache.dubbo.rpc.protocol.AbstractInvoker.waitForResultIfSync(AbstractInvoker.java:<span class="hljs-number">266</span>)<br><span class="hljs-number">432374</span>- at org.apache.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:<span class="hljs-number">186</span>)<br><span class="hljs-number">432375</span>- at org.apache.dubbo.rpc.cluster.support.AbstractClusterInvoker.invokeWithContext(AbstractClusterInvoker.java:<span class="hljs-number">379</span>)<br><span class="hljs-number">432376</span>- at org.apache.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:<span class="hljs-number">81</span>)<br></code></pre></td></tr></table></figure>
<h1>小技巧</h1>
<h2 id="如何处理任务超时问题">如何处理任务超时问题</h2>
<h3 id="方法1：使用-futuretask-的实现">方法1：使用 FutureTask 的实现</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java">    Future&lt;Map&lt;String, Object&gt;&gt; future = executor.submit(() -&gt; getFeatures(context, zeusSceneId));<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 穷人版超时：最简单的超时不是使用 circuit breaker，而是使用 FutureTask 的缺省超时实现，这个方案取不到值的时候底层会返回 TimeoutException，只要捕获这个超时就可以走入 fallback 逻辑</span><br>                features.putAll(future.get(paramCollectTimeout, TimeUnit.MILLISECONDS));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException | TimeoutException e) &#123;<br>                <span class="hljs-comment">// fallback logic</span><br>            &#125;<br>            <br>    <span class="hljs-comment">// 其中 FutureTask 的实现是：</span><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>        <span class="hljs-keyword">if</span> (unit == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> state;<br>        <span class="hljs-comment">// 等待结束后抛出异常而不是空指针，否则调用 report 方法</span><br>        <span class="hljs-keyword">if</span> (s &lt;= COMPLETING &amp;&amp;<br>            (s = awaitDone(<span class="hljs-literal">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();<br>        <span class="hljs-keyword">return</span> report(s);<br>    &#125;<br>    <br><span class="hljs-comment">// 约等价于</span><br>其中超时底层的最简单实现是：<br><br>    <span class="hljs-keyword">public</span> V <span class="hljs-title function_">get</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException, ExecutionException, TimeoutException &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> unit.toNanos(timeout);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br>    <br>    <span class="hljs-comment">// 循环等待，直到任务完成或超时</span><br>    <span class="hljs-keyword">while</span> (state &lt;= COMPLETING) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> deadline - System.nanoTime();<br>        <span class="hljs-keyword">if</span> (remaining &lt;= <span class="hljs-number">0L</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeoutException</span>();  <span class="hljs-comment">// 超时了</span><br>        &#125;<br>        LockSupport.parkNanos(<span class="hljs-built_in">this</span>, remaining);  <span class="hljs-comment">// 等待指定时间</span><br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> report(state);  <span class="hljs-comment">// 返回结果</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="方法2：使用条件变量">方法2：使用条件变量</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发出调用</span><br>condition.await<br><span class="hljs-comment">// 非阻塞地调用 isDone 方法，抛出异常或取值</span><br><span class="hljs-comment">// 这是方法1 的泛化实现</span><br></code></pre></td></tr></table></figure>
<h3 id="方法3：使用-countdownlatch-cyclicbarrier">方法3：使用 countDownLatch/CyclicBarrier</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 发出调用</span><br>无锁的 await<br><span class="hljs-comment">// 非阻塞地调用 isDone 方法，抛出异常或取值，但要注意其他线程对 done 状态的维护</span><br></code></pre></td></tr></table></figure>
<p>这个方法不需要依赖于 ReentrantLock，是通过纯 AQS 实现的，见 CountDownLatch 源码。</p>
<h2 id="自定义线程池实现自定义中断">自定义线程池实现自定义中断</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">待补充<br></code></pre></td></tr></table></figure>
<h1>Java 异步执行中的异常处理与线程生命周期</h1>
<h2 id="从-futuretask-asyncuncaughtexceptionhandler-到-uncaughtexceptionhandler">从 FutureTask、AsyncUncaughtExceptionHandler 到 UncaughtExceptionHandler</h2>
<p>在 Java 并发和 Spring 异步执行模型中，异常处理涉及多个抽象层级：<br>
JVM 线程模型、JDK 并发工具以及 Spring 框架本身。</p>
<p>这些层级各自对异常承担不同职责，但它们的行为经常被混淆，典型问题包括：</p>
<ul>
<li>异步任务抛出的异常为何没有日志</li>
<li><code>UncaughtExceptionHandler</code> 在线程池中为何不生效</li>
<li><code>AsyncUncaughtExceptionHandler</code> 是否会影响线程生命周期</li>
</ul>
<p>本文从<strong>线程是否终止</strong>这一确定性问题出发，系统梳理三种机制的边界与协作方式。</p>
<hr>
<h2 id="一-线程是否终止的唯一判定标准">一、线程是否终止的唯一判定标准</h2>
<p>在 JVM 层面，线程是否终止只取决于一个条件：</p>
<blockquote>
<p><strong>是否存在未被捕获、并逃逸出 <code>Thread.run()</code> 的 <code>Throwable</code></strong>。从这个 run 出去以后，就进入 jvm 的cpp 代码的接管范围</p>
</blockquote>
<p>这一规则与使用何种框架无关。</p>
<h3 id="1-1-会导致线程终止的情况">1.1 会导致线程终止的情况</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<ul>
<li>异常未被捕获</li>
<li>异常逃逸出 run()</li>
<li>JVM 调用 UncaughtExceptionHandler</li>
<li>线程终止</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>
<p>源码位置：<a target="_blank" rel="noopener" href="https://hg.openjdk.org/jdk8u/jdk8u/hotspot/file/c55d012dd067/src/share/vm/runtime/thread.cpp#l1799">Thread 的实现</a><br>
还可以参考这个：<a target="_blank" rel="noopener" href="https://blog.csdn.net/chuyouyinghe/article/details/134306409">《01.崩溃捕获设计实践方案 crash方案》</a></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">JavaThread::exit</span><span class="hljs-params">(<span class="hljs-type">bool</span> destroy_vm)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_pending_exception</span>()) &#123;<br>        <span class="hljs-function">Handle <span class="hljs-title">exception</span><span class="hljs-params">(<span class="hljs-keyword">this</span>, pending_exception())</span></span>;<br>        <span class="hljs-built_in">clear_pending_exception</span>();<br>        <br>        <span class="hljs-comment">// 直接内联处理，无单独 uncaught_exception 方法</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">threadObj</span>() != <span class="hljs-literal">NULL</span>) &#123;<br>            Klass* klass = SystemDictionary::<span class="hljs-built_in">Thread_klass</span>();<br>            <span class="hljs-comment">// ... 通过 JNI 调用 Java 层 uncaughtException</span><br>            JavaCalls::<span class="hljs-built_in">call_virtual</span>(&amp;result, klass, <br>                                   vmSymbols::<span class="hljs-built_in">uncaughtException_name</span>(),<br>                                   vmSymbols::<span class="hljs-built_in">thread_throwable_void_signature</span>(),<br>                                   &amp;args, <span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant JVM as JVM(C++)
    participant JavaThread as JavaThread(C++)
    participant ThreadJava as java.lang.Thread
    
    JVM-&gt;&gt;JavaThread: 线程执行中抛出异常
    JavaThread-&gt;&gt;JavaThread: set_pending_exception(exception)
    JVM-&gt;&gt;JavaThread: 线程退出调用 exit()
    JavaThread-&gt;&gt;JavaThread: has_pending_exception()
    JavaThread-&gt;&gt;JavaThread: 直接在 exit() 中处理
    JavaThread-&gt;&gt;ThreadJava: JNI call_virtual(&quot;uncaughtException&quot;)
    ThreadJava-&gt;&gt;ThreadJava: 实际调用 java.lang.Thread.uncaughtException
    ThreadJava-&gt;&gt;ThreadJava: dispatchUncaughtException(e)
    ThreadJava-&gt;&gt;ThreadGroup: getUncaughtExceptionHandler()
    ThreadGroup-&gt;&gt;SystemErr: 默认处理</code></pre>
<h3 id="1-2-不会导致线程终止的情况">1.2 不会导致线程终止的情况</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// handled</span><br>    &#125;<br>&#125;).start();<br></code></pre></td></tr></table></figure>
<p>执行结果：</p>
<ul>
<li>异常被捕获</li>
<li>JVM 不介入</li>
<li>线程继续运行</li>
</ul>
<p>结论：</p>
<ul>
<li>异常是否被捕获，决定了线程是否终止；</li>
<li>异常由谁处理，并不决定线程生死。</li>
</ul>
<h2 id="二-futuretask-对异常传播路径的改变">二、FutureTask 对异常传播路径的改变</h2>
<p>理解线程池与 Spring 异步行为，必须先理解 FutureTask。</p>
<h3 id="2-1-execute-与-submit-的根本差异">2.1 execute 与 submit 的根本差异</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">executor.execute(runnable);<br>executor.submit(callable);<br></code></pre></td></tr></table></figure>
<p>差异不在返回值，而在执行结构：</p>
<ul>
<li><code>execute</code>：<code>Runnable</code>直接在线程中执行</li>
<li><code>submit</code>：任务先被包装为<code>FutureTask</code>，再执行</li>
</ul>
<h3 id="2-2-futuretask-中的异常拦截点">2.2 FutureTask 中的异常拦截点</h3>
<p>FutureTask.run() 的核心逻辑如下（简化）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        callable.call();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>        setException(ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>关键点：</p>
<ul>
<li>Throwable 被主动捕获</li>
<li>异常不会逃逸出 run()</li>
<li>JVM 不认为线程发生未捕获异常<br>
线程不会终止</li>
</ul>
<p>异常在这里已经脱离“线程异常”的语义。</p>
<h3 id="2-3-异常如何被重新抛出：report">2.3 异常如何被重新抛出：report()</h3>
<p>异常并未消失，而是作为执行结果存储：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">outcome = ex;<br>state = EXCEPTIONAL;<br></code></pre></td></tr></table></figure>
<p>在调用<code>Future.get()</code>时：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> V <span class="hljs-title function_">report</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> <span class="hljs-keyword">throws</span> ExecutionException &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">x</span> <span class="hljs-operator">=</span> outcome;<br>    <span class="hljs-keyword">if</span> (s == NORMAL)<br>        <span class="hljs-keyword">return</span> (V) x;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExecutionException</span>((Throwable) x);<br>&#125;<br></code></pre></td></tr></table></figure>
<p><code>report()</code>的职责是：</p>
<ul>
<li>将“执行结果状态”翻译为 Java 异常语义</li>
<li>将原始异常包装为 ExecutionException</li>
</ul>
<p>结论：</p>
<blockquote>
<p>FutureTask 将异常从“线程控制流”转移为“任务结果数据”。</p>
</blockquote>
<h2 id="三-uncaughtexceptionhandler-的职责边界">三、UncaughtExceptionHandler 的职责边界</h2>
<h3 id="3-1-触发条件">3.1 触发条件</h3>
<p><code>UncaughtExceptionHandler</code>仅在以下条件满足时被调用：</p>
<ul>
<li>异常未被捕获</li>
<li>异常逃逸出<code>Thread.run()</code></li>
<li>线程即将终止</li>
</ul>
<p>JVM 调用顺序为：</p>
<ol>
<li>Thread 自身的 handler</li>
<li>ThreadGroup</li>
<li>DefaultUncaughtExceptionHandler</li>
<li>JVM 默认 stderr</li>
</ol>
<h3 id="3-2-能力与限制">3.2 能力与限制</h3>
<p><code>UncaughtExceptionHandler</code>：</p>
<ul>
<li>无法阻止线程终止</li>
<li>无法恢复线程执行</li>
<li>仅用于日志、告警等系统级兜底</li>
</ul>
<p>在线程池中，只有 <code>execute()</code>且异常未被捕获时，才可能触发该 handler。</p>
<h2 id="四-spring-asyncuncaughtexceptionhandler-的作用范围">四、Spring AsyncUncaughtExceptionHandler 的作用范围</h2>
<h3 id="4-1-适用条件">4.1 适用条件</h3>
<p>Spring 明确限定：</p>
<ul>
<li>仅处理 @Async 标注的 void 方法</li>
<li>不处理返回 Future / CompletableFuture 的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Async</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">asyncTask</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;error&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-2-spring-的异常拦截方式">4.2 Spring 的异常拦截方式</h3>
<p>Spring 在异步调用边界处捕获异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    invokeMethod();<br>&#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>    asyncUncaughtExceptionHandler.handle(ex, method, params);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="4-3-对线程生命周期的影响">4.3 对线程生命周期的影响</h3>
<p><code>AsyncUncaughtExceptionHandler</code>：</p>
<ul>
<li>不会阻止线程终止</li>
<li>也不会导致线程终止</li>
</ul>
<p>原因是：</p>
<ul>
<li>异常已经被 Spring 捕获</li>
<li>JVM 无法感知未捕获异常</li>
<li>线程本身没有死亡条件</li>
</ul>
<p>结论：</p>
<ul>
<li>AsyncUncaughtExceptionHandler 只影响异常的业务处理路径，不影响线程生命周期。</li>
</ul>
<h2 id="五-三种异常路径的对比">五、三种异常路径的对比</h2>
<h3 id="5-1-async-void-方法">5.1 @Async void 方法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Async</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">task</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">方法执行<br> → Spring 捕获<br> → AsyncUncaughtExceptionHandler<br> → 线程继续运行<br></code></pre></td></tr></table></figure>
<h3 id="5-2-线程池execute">5.2 线程池<code>execute</code></h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">executor.execute(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Runnable.run<br> → 异常逃逸<br> → JVM<br> → UncaughtExceptionHandler<br> → 线程终止<br></code></pre></td></tr></table></figure>
<h3 id="5-3-线程池-submit">5.3 线程池 submit</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Future&lt;?&gt; future = executor.submit(() -&gt; &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>();<br>&#125;);<br></code></pre></td></tr></table></figure>
<p>异常路径：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">FutureTask.run<br> → <span class="hljs-keyword">catch</span> Throwable<br> → 异常存入 Future<br> → get() 时抛 ExecutionException<br></code></pre></td></tr></table></figure>
<h2 id="六-两种-handler-的推荐使用方式">六、两种 Handler 的推荐使用方式</h2>
<h3 id="6-1-asyncuncaughtexceptionhandler-业务层">6.1 AsyncUncaughtExceptionHandler（业务层）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAsync</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AsyncConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AsyncConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> AsyncUncaughtExceptionHandler <span class="hljs-title function_">getAsyncUncaughtExceptionHandler</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> (ex, method, params) -&gt; &#123;<br>            log.error(<span class="hljs-string">&quot;Async void method failed: &#123;&#125;&quot;</span>, method.getName(), ex);<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li>@Async void 方法</li>
<li>业务补偿、告警、日志</li>
</ul>
<h3 id="6-2-uncaughtexceptionhandler-系统层">6.2 UncaughtExceptionHandler（系统层）</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> r -&gt; &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r);<br>    t.setUncaughtExceptionHandler((thread, ex) -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Thread &#123;&#125; terminated&quot;</span>, thread.getName(), ex);<br>    &#125;);<br>    <span class="hljs-keyword">return</span> t;<br>&#125;;<br><br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>    <span class="hljs-number">4</span>, <span class="hljs-number">8</span>, <span class="hljs-number">60</span>, TimeUnit.SECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(),<br>    factory<br>);<br></code></pre></td></tr></table></figure>
<p>适用场景：</p>
<ul>
<li><code>execute()</code>执行的任务</li>
<li>系统级兜底监控</li>
</ul>
<h3 id="6-3-有返回值的异步任务">6.3 有返回值的异步任务</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">CompletableFuture<br>    .supplyAsync(<span class="hljs-built_in">this</span>::work, executor)<br>    .exceptionally(ex -&gt; &#123;<br>        log.error(<span class="hljs-string">&quot;Async failed&quot;</span>, ex);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;);<br></code></pre></td></tr></table></figure>
<p>必须显式消费异常，否则异常不会被观察到。</p>
<h2 id="结论">结论</h2>
<ol>
<li>线程是否终止，仅由异常是否逃逸到 JVM 决定</li>
<li>FutureTask 和 Spring 已在更高层捕获异常，因此不会触发 JVM 机制</li>
<li>AsyncUncaughtExceptionHandler 不控制线程生死，仅提供业务回调</li>
<li>UncaughtExceptionHandler 只用于处理线程终止前的系统级事件</li>
</ol>
<h1>Spring 的异步支持</h1>
<ul>
<li>如果只是<code>@EnableAsync</code>，Spring 会创建一个默认的 SimpleAsyncTaskExecutor（注意不是 ThreadPoolTaskExecutor）：
<ul>
<li><strong>每个任务都会创建新线程</strong></li>
<li>没有线程池复用</li>
<li>性能较差，不适合生产环境</li>
</ul>
</li>
<li>在这个基础上，再实现<code>AsyncConfigurer.getAsyncExecutor()</code>就可以让自己的线程池替代框架的 Bean。</li>
</ul>
<h2 id="threadpooltaskexecutor">ThreadPoolTaskExecutor</h2>
<p>ThreadPoolTaskExecutor 是 ExecutorConfigurationSupport 的子类，也包装了一个 ThreadPoolExecutor。</p>
<ul>
<li>ExecutorConfigurationSupport 作为基类提供了：
<ul>
<li>生命周期管理：实现了 InitializingBean, DisposableBean</li>
<li>配置管理：线程工厂、拒绝策略、优雅关闭等配置</li>
<li>模板方法：定义了初始化和销毁的标准流程</li>
</ul>
</li>
</ul>
<p>特别是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterPropertiesSet</span><span class="hljs-params">()</span> &#123;<br>    initialize();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isInfoEnabled()) &#123;<br>        <span class="hljs-built_in">this</span>.logger.info(<span class="hljs-string">&quot;Initializing ExecutorService &quot;</span> + (<span class="hljs-built_in">this</span>.beanName != <span class="hljs-literal">null</span> ? <span class="hljs-string">&quot; &#x27;&quot;</span> + <span class="hljs-built_in">this</span>.beanName + <span class="hljs-string">&quot;&#x27;&quot;</span> : <span class="hljs-string">&quot;&quot;</span>));<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.threadNamePrefixSet &amp;&amp; <span class="hljs-built_in">this</span>.beanName != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.setThreadNamePrefix(<span class="hljs-built_in">this</span>.beanName + <span class="hljs-string">&quot;-&quot;</span>);<br>    &#125;<br>    <br>    <span class="hljs-comment">// 调用子类的具体实现</span><br>    <span class="hljs-built_in">this</span>.executor = <span class="hljs-built_in">this</span>.initializeExecutor(<span class="hljs-built_in">this</span>.threadFactory, <span class="hljs-built_in">this</span>.rejectedExecutionHandler);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>所以在这个 bean 被使用以前，内部线程池要经过一个 afterPropertiesSet 驱动进行初始化和注入这个 ThreadPoolTaskExecutor 线程池外壳。</p>
<h2 id="threadpooltaskexecutor-内部线程池的替换">ThreadPoolTaskExecutor 内部线程池的替换</h2>
<h3 id="推荐：使用初始化器装饰">推荐：使用初始化器装饰</h3>
<p>initializeExecutor 初始化过程里会允许我们装饰这个线程池：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> ExecutorService <span class="hljs-title function_">initializeExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">        ThreadFactory threadFactory, RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;<br><br>    BlockingQueue&lt;Runnable&gt; queue = createQueue(<span class="hljs-built_in">this</span>.queueCapacity);<br><br>    ThreadPoolExecutor executor;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.taskDecorator != <span class="hljs-literal">null</span>) &#123;<br>        executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-built_in">this</span>.corePoolSize, <span class="hljs-built_in">this</span>.maxPoolSize, <span class="hljs-built_in">this</span>.keepAliveSeconds, TimeUnit.SECONDS,<br>                queue, threadFactory, rejectedExecutionHandler) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>                <span class="hljs-type">Runnable</span> <span class="hljs-variable">decorated</span> <span class="hljs-operator">=</span> taskDecorator.decorate(command);<br>                <span class="hljs-keyword">if</span> (decorated != command) &#123;<br>                    decoratedTaskMap.put(decorated, command);<br>                &#125;<br>                <span class="hljs-built_in">super</span>.execute(decorated);<br>            &#125;<br>        &#125;;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                <span class="hljs-built_in">this</span>.corePoolSize, <span class="hljs-built_in">this</span>.maxPoolSize, <span class="hljs-built_in">this</span>.keepAliveSeconds, TimeUnit.SECONDS,<br>                queue, threadFactory, rejectedExecutionHandler);<br><br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.allowCoreThreadTimeOut) &#123;<br>        executor.allowCoreThreadTimeOut(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">this</span>.threadPoolExecutor = executor;<br>    <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>java 线程池的装饰逻辑就是<strong>只覆盖一个</strong><code>public void execute(Runnable command)</code>即可。</p>
<p>这个方法本质上是<strong>一切线程池外部提交/执行操作的入口</strong>，所以<strong>它的执行线程是外部线程而已不是工作线程</strong>。</p>
<p>可以说<strong>这个壳的其他方法都只是包装一下普通线程的成员方法，但是这个 initializeExecutor 和 decorate 是这个壳特有的，是它存在的意义</strong>。</p>
<p>所有外部 command 在执行前都要被 decorate 一下，而且存在 decoratedTaskMap 里，模式是装饰后-&gt;原始命令。目前这个map没有用处，未来可能在用修饰后的任务找原始 Runnable 的时候会有用。</p>
<h3 id="其他代理">其他代理</h3>
<p>其他方法都是用<strong>类似的模式来代理的，而且不支持多态</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-type">Executor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> getThreadPoolExecutor();<br>    <span class="hljs-keyword">try</span> &#123;<br>        executor.execute(task);<br>    &#125;<br>    <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TaskRejectedException</span>(<span class="hljs-string">&quot;Executor [&quot;</span> + executor + <span class="hljs-string">&quot;] did not accept task: &quot;</span> + task, ex);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="如果我们要替换线程池实现">如果我们要替换线程池实现</h3>
<p>我们只能用反射来替换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(&quot;bizCommonTaskExecutor&quot;)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ThreadPoolTaskExecutor <span class="hljs-title function_">getAsyncExecutor</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建支持EagleEye上下文传递的ThreadPoolTaskExecutor</span><br>    <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">taskExecutor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> ThreadPoolExecutor <span class="hljs-title function_">initializeExecutor</span><span class="hljs-params">(</span><br><span class="hljs-params">                ThreadFactory threadFactory,</span><br><span class="hljs-params">                RejectedExecutionHandler rejectedExecutionHandler)</span> &#123;<br>            <span class="hljs-comment">// 创建阻塞队列</span><br>            BlockingQueue&lt;Runnable&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(QUEUE_CAPACITY);<br>            <br>            <span class="hljs-comment">// 创建支持EagleEye上下文传递的线程池</span><br>            <span class="hljs-type">EagleEyeContextAwareThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EagleEyeContextAwareThreadPoolExecutor</span>(<br>                CORE_POOL_SIZE,<br>                MAX_POOL_SIZE,<br>                KEEP_ALIVE_SECONDS,<br>                TimeUnit.SECONDS,<br>                queue,<br>                threadFactory,<br>                rejectedExecutionHandler<br>            );<br><br>            <span class="hljs-comment">// 使用反射将executor赋值给父类的private threadPoolExecutor字段，这是目前唯一的方法</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                java.lang.reflect.<span class="hljs-type">Field</span> <span class="hljs-variable">field</span> <span class="hljs-operator">=</span> ThreadPoolTaskExecutor.class.getDeclaredField(<span class="hljs-string">&quot;threadPoolExecutor&quot;</span>);<br>                field.setAccessible(<span class="hljs-literal">true</span>);<br>                field.set(<span class="hljs-built_in">this</span>, executor);<br>                <span class="hljs-comment">// 如果有必要，要存储老的 accessible，在 set 完了以后要还原</span><br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                LoggerUtils.error(LOGGER, <span class="hljs-string">&quot;Failed to set threadPoolExecutor via reflection&quot;</span>, e);<br>            &#125;<br>            <br>            <span class="hljs-keyword">return</span> executor;<br>        &#125;<br>    &#125;;<br>    <br>    <span class="hljs-comment">// 配置线程名前缀</span><br>    taskExecutor.setThreadNamePrefix(<span class="hljs-string">&quot;bd-common-async-&quot;</span>);<br>    <br>    <span class="hljs-comment">// 配置优雅停机</span><br>    taskExecutor.setWaitForTasksToCompleteOnShutdown(<span class="hljs-literal">true</span>);<br>    taskExecutor.setAwaitTerminationSeconds(AWAIT_TERMINATION_SECONDS);<br>    <br>    <span class="hljs-keyword">return</span> taskExecutor;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>我们不推荐使用这种做法，除非我们真的<strong>有增强 execute 以外的诉求</strong>。</p>
<h2 id="对线程池实行-trace-传递">对线程池实行 trace 传递</h2>
<h3 id="如果使用统一包装器">如果使用统一包装器</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 这个方法的第一层参数是 ThreadPoolTaskExecutor 的 execute 执行的时候的这个 command：</span><br><span class="hljs-comment">//              public void execute(Runnable command) &#123;</span><br><span class="hljs-comment">//                  Runnable decorated = taskDecorator.decorate(command);</span><br> taskExecutor.setTaskDecorator(runnable -&gt; &#123;<br>            <br>            <span class="hljs-comment">// 这里获取外部提交的时候的线程和上下文</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">submitThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>            <br>            <span class="hljs-comment">// 这里返回一个 runnable，给外部的 super.execute(decorated); 使用，这个方法就是原始线程池的 execute 了</span><br>            <span class="hljs-keyword">return</span> () -&gt; &#123;<br>                <span class="hljs-comment">// 这里开始执行的时候通常已经进入线程池的 worker 内部了</span><br>                <br>                <span class="hljs-comment">// 当拒绝策略为 CallerRunsPolicy 且在提交线程中执行时，直接运行即可</span><br>                <span class="hljs-keyword">if</span> (submitThread == Thread.currentThread()) &#123;<br>                    runnable.run();<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>                <span class="hljs-type">Object</span> <span class="hljs-variable">oldContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (oldContext == <span class="hljs-literal">null</span>) &#123;<br>                        needClean = <span class="hljs-literal">true</span>;<br>                        EagleEye.setRpcContext(rpcContext);<br>                    &#125;<br>                    <span class="hljs-comment">// 这是在内部线程 run 之前执行的围绕操作</span><br>                    runnable.run();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">if</span> (needClean) &#123;<br>                        EagleEye.clearRpcContext();<br>                    &#125;<br>                &#125;<br>            &#125;;<br>        &#125;);<br></code></pre></td></tr></table></figure>
<p>其中装饰器被调用的地方是就是上面的<a href="#%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E8%A3%85%E9%A5%B0">使用初始化器装饰</a>。</p>
<p>本质上 executor 共有三个入口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Runnable runnable, T value)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(runnable, value) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (EagleEye.currentRpcContext() == <span class="hljs-literal">null</span>) &#123;<br>                needClean = <span class="hljs-literal">true</span>;<br>                EagleEye.setRpcContext(rpcContext);<br>            &#125;<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (needClean) &#123;<br>                    EagleEye.clearRpcContext();<br>                &#125;<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> &lt;T&gt; RunnableFuture&lt;T&gt; <span class="hljs-title function_">newTaskFor</span><span class="hljs-params">(Callable&lt;T&gt; callable)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;T&gt;(callable) &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">needClean</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (EagleEye.currentRpcContext() == <span class="hljs-literal">null</span>) &#123;<br>                needClean = <span class="hljs-literal">true</span>;<br>                EagleEye.setRpcContext(rpcContext);<br>            &#125;<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-built_in">super</span>.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (needClean) &#123;<br>                    EagleEye.clearRpcContext();<br>                &#125;<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;<br>    &#125;;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable command)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">rpcContext</span> <span class="hljs-operator">=</span> EagleEye.currentRpcContext();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">gsid</span> <span class="hljs-operator">=</span> GsidUtil.getGsid();<br>    <span class="hljs-keyword">if</span> (command <span class="hljs-keyword">instanceof</span> FutureTask) &#123;<br>        <span class="hljs-built_in">super</span>.execute(command);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">super</span>.execute(() -&gt; &#123;<br>            EagleEye.setRpcContext(rpcContext);<br>            GsidUtil.setGsid(gsid);<br>            <span class="hljs-keyword">try</span> &#123;<br>                command.run();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                EagleEye.clearRpcContext();<br>                GsidUtil.clear();<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>前两个 newTaskFor 是其他 submit 方法到 execute 之前的底层方法。因为前两个入口最终都会调到<code>execute(Runnable command)</code>，所以它的内部要避开<code>if (command instanceof FutureTask) {</code>的场景。这个设计因此显得比较累赘。</p>
<p>实际上 decorator 的实现就是最佳的，最终只要实现一个 execute 的包装提交就行了。</p>
<p>这个实现里有一个地方要注意：执行完当前的 runnable 需要 clear，否则可能会出现以前有的遗留 traceId 污染的问题。</p>
<p>参考资料：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javadoop.com/post/AbstractQueuedSynchronizer">《一行一行源码分析清楚AbstractQueuedSynchronizer》</a></li>
<li><a target="_blank" rel="noopener" href="https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html">《Java线程池实现原理及其在美团业务中的实践》</a></li>
<li><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000016058789">《Keep Coding》</a></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3%EF%BC%9AForkJoinPool/" title="线程池详解：ForkJoinPool"><img class="cover" src="/2026/01/04/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3%EF%BC%9AForkJoinPool/java-thread-x-forkjoin-%E5%8F%AA%E5%8F%91%E7%94%9F%E5%9C%A8%E5%90%8C%E5%B1%82%E4%B9%8B%E9%97%B4.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-04</div><div class="info-item-2">线程池详解：ForkJoinPool</div></div><div class="info-2"><div class="info-item-1"> 前言：分治并行的诞生 ForkJoinPool 不是为了通用&quot;并行&quot;而设计，而是专门为分治并行（Divide-and-Conquer Parallelism）这一特定模式量身定制。分治算法（如快速排序、归并排序、树遍历）具有独特的执行模式：  任务天然形成树状结构 父任务派生子任务后需要等待结果 子任务之间通常无依赖关系 计算密集，无I/O阻塞  理解分治算法的执行特性，是理解 ForkJoinPool 设计的关键。传统线程池在处理这类任务时遇到根本性挑战，ForkJoinPool 正是为解决这些挑战而诞生。 1. 核心数据结构：ForkJoinPool的基石 1.1 ForkJoinPool：去中心化的调度器 数据结构定义 1234567891011121314151617181920212223public class ForkJoinPool extends AbstractExecutorService &#123;    // 64位控制状态：编码活跃线程数、空闲线程数、任务计数    volatile long ctl;        // 工作...</div></div></div></a><a class="pagination-related" href="/2026/01/18/%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E7%9A%84%E5%8E%86%E5%8F%B2/" title="异步进化的历史"><img class="cover" src="/2026/01/18/%E5%BC%82%E6%AD%A5%E8%BF%9B%E5%8C%96%E7%9A%84%E5%8E%86%E5%8F%B2/CompletableFuture%E6%89%A7%E8%A1%8C%E6%A0%91.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">异步进化的历史</div></div><div class="info-2"><div class="info-item-1">本文一部分来自于qwen，一部分来自于以下文章：  《CompletableFuture原理与实践-外卖商家端API的异步化》  Java 演进本质 graph LR     A[Java 5 Future] --&gt;|阻塞痛点| B[Guava ListenableFuture]     B --&gt;|回调地狱| C[CompletableFuture]     C --&gt;|流处理需求| D[RxJava]     D --&gt;|Spring整合| E[Reactor]          A --&gt;|范式转变| F[命令式-&gt;声明式]     B --&gt;|抽象提升| G[事件驱动-&gt;数据流]     C --&gt;|能力增强| H[组合-&gt;背压]     D &amp; E --&gt;|统一理念| I[异步即数据流]  控制流：阻塞等待 → 回调响应 → 声明式组合 → 响应式流 错误处理：分散try-catch → 回调onFailure → 链式exceptionally → 流式onError 组合能力：无 → 有限tr...</div></div></div></a><a class="pagination-related" href="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" title="无锁队列"><img class="cover" src="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">无锁队列</div></div><div class="info-2"><div class="info-item-1">Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。 * * &lt;p&gt;原理说明： * - 仅允许一个线程调用 &#123;@code offer()&#125;，一个线程调用 &#123;@code poll()&#125;。 * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。 * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系： *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。 * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad）， *   ...</div></div></div></a><a class="pagination-related" href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-19</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1"> 版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374），在 JDK 18 中相关代码已被移除。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级。但在深入讨论线程安全的分类之前，我们需要先理解 Java 内存模型——它是理解线程安全问题的理论基础。 Java 内存模型基础 Java 内存模型（Java Memory Model，JMM）是 Java 语言规范的一部分，定义了多线程程序中共享变量的访问规则。理解 JMM 是理解线程安全问题的基础。 为什么需要内存模型？ 现代计算机系统中，CPU 与主内存之间存在巨大的速度差异。为了弥补这一差距，硬件层面引入了多级缓存（L1、L...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-103.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题   Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return , break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.    这句话在 Java 的程序员世界里面已经成为老生常谈。却很少有人谈及，但到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。“不要滥用异常”好像一个猴子定律，人们忘记了为什么不能这么做，却不明白为什么不能这么做。   这几天读了一位同事写的好文[《Java虚拟机是如何处理异常的》][2]，深入地分析了 JVM 对异常跳转的处理过程: JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：“try-catch语句块几乎不会影响程序...</div></div></div></a><a class="pagination-related" href="/2017/11/03/JVM-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="JVM 的内存模型与线程"><img class="cover" src="/img/wall-paper-115.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-03</div><div class="info-item-2">JVM 的内存模型与线程</div></div><div class="info-2"><div class="info-item-1">1.性能何处寻   计算机的CPU比起其他所有的设备，都快得多，所以怎样尽量复用 CPU 的时间片，是压榨计算机性能的目标。多核和并发，使得阿姆达尔定律大显神威，超越摩尔定律成为提升系统性能的金科玉律 - 现在单核计算能力已经无法垂直提升，要水平提升核数来提升整体性能。 2.缓存一致性问题（Cache Coherence）   软件缓存，不过是硬件缓存的模仿，真正的缓存，早已存在于计算机的多级存储体系结构中。JVM 里，我们可以认为每个处理器都会在主内存（Main Memory）之外有高速缓存作为工作内存（Working memory）。除此之外，处理器和 JVM 都可能出现指令重排（Instruction Reorder）的的情况。工作内存是线程 Save 和 Load 的主要场所，主内存则是他们沟通的场所。 3.JVM 的对象信息   Java Object 除了基本的内存轮廓以外，还有：  Mark Word（对象的 Hash Code 的缓存值、GC标志、GC年龄、同步锁等信息）。 Klass Point（指向对象元数据信息的指针，指向 .class  的指针吗？不是，是...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">写在前面的话</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">管程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mesa-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">MESA 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-set-%E8%80%8C%E4%B8%8D%E7%94%A8-queue"><span class="toc-number">1.2.1.</span> <span class="toc-text">为什么用 set 而不用 queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">模型映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mesa-%E6%A8%A1%E5%9E%8B%E7%9A%84-signal-and-continue-%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. Mesa 模型的 “Signal and Continue” 语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-entry-set-%E9%94%81%E7%AB%9E%E4%BA%89-%E2%9D%8C-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E6%9C%89-timed-waiting"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. Entry Set（锁竞争）❌ 永远不会有 TIMED_WAITING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-wait-set-%E6%9D%A1%E4%BB%B6%E7%AD%89%E5%BE%85-%E2%9C%85-%E6%94%AF%E6%8C%81-timed-waiting"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. Wait Set（条件等待）✅ 支持 TIMED_WAITING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-jvisualvm-%E5%88%86%E7%B1%BB%E9%80%BB%E8%BE%91"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4. JVisualVM 分类逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E-os-%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">5. 线程状态与 OS 调度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Java 线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%97%E4%B8%BE"><span class="toc-number">2.1.</span> <span class="toc-text">线程状态列举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">2.1.1.</span> <span class="toc-text">NEW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runnable"><span class="toc-number">2.1.2.</span> <span class="toc-text">RUNNABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocked"><span class="toc-number">2.1.3.</span> <span class="toc-text">BLOCKED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waiting"><span class="toc-number">2.1.4.</span> <span class="toc-text">WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timed-waiting"><span class="toc-number">2.1.5.</span> <span class="toc-text">TIMED_WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#terminated"><span class="toc-number">2.1.6.</span> <span class="toc-text">TERMINATED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.7.</span> <span class="toc-text">几种线程状态的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">2.2.</span> <span class="toc-text">线程间方法的设计哲学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E7%9A%84%E5%88%87%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">特别的切换方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#locksupport-park"><span class="toc-number">2.3.1.</span> <span class="toc-text">LockSupport.park</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-number">2.3.2.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">2.3.3.</span> <span class="toc-text">join</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">JMM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">3.1.</span> <span class="toc-text">Volatile</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">JUC</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E4%BD%93%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.1.</span> <span class="toc-text">总体设计原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unsafe-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.2.</span> <span class="toc-text">Unsafe 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96-field"><span class="toc-number">4.2.1.</span> <span class="toc-text">获取 field</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#increaseandget-%E4%B8%8E-getandincrease"><span class="toc-number">4.2.2.</span> <span class="toc-text">increaseAndGet 与 getAndIncrease</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%94%81"><span class="toc-number">4.2.3.</span> <span class="toc-text">自旋锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.3.</span> <span class="toc-text">函数式接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-runnable-%E5%92%8C-callable"><span class="toc-number">4.3.1.</span> <span class="toc-text">区别 Runnable 和 Callable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#synchronized-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.4.</span> <span class="toc-text">synchronized 的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#locksupport"><span class="toc-number">4.5.</span> <span class="toc-text">LockSupport</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%B8%80%E8%87%B4%E6%80%A7%E6%95%88%E5%BA%94-memory-consistency-effects"><span class="toc-number">4.6.</span> <span class="toc-text">内存一致性效应（Memory consistency effects）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E6%B5%81%E9%94%81"><span class="toc-number">4.7.</span> <span class="toc-text">主流锁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">4.7.1.</span> <span class="toc-text">悲观锁与乐观锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aqs-abstractqueuedsynchronizer"><span class="toc-number">4.8.</span> <span class="toc-text">AQS（AbstractQueuedSynchronizer）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">4.8.1.</span> <span class="toc-text">AQS 的设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E8%AE%B0%E5%BF%86"><span class="toc-number">4.8.1.1.</span> <span class="toc-text">简要记忆</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs%E7%9A%84%E4%BA%94%E5%B1%82%E7%BB%93%E6%9E%84"><span class="toc-number">4.8.2.</span> <span class="toc-text">AQS的五层结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clh-queue"><span class="toc-number">4.8.3.</span> <span class="toc-text">CLH queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%92%E6%96%A5%E6%A1%86%E6%9E%B6%E7%9A%84%E6%A0%87%E5%87%86%E4%BC%AA%E4%BB%A3%E7%A0%81"><span class="toc-number">4.8.4.</span> <span class="toc-text">互斥框架的标准伪代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#node-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.8.5.</span> <span class="toc-text">Node 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">4.8.6.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E9%94%81"><span class="toc-number">4.8.6.1.</span> <span class="toc-text">加锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#clh-%E4%B8%BB%E6%A1%86%E6%9E%B6"><span class="toc-number">4.8.6.1.1.</span> <span class="toc-text">CLH 主框架</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#tryacquire"><span class="toc-number">4.8.6.1.1.1.</span> <span class="toc-text">tryAcquire</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#addwaiter"><span class="toc-number">4.8.6.1.1.2.</span> <span class="toc-text">addWaiter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#enq"><span class="toc-number">4.8.6.1.1.3.</span> <span class="toc-text">enq</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#acquirequeued"><span class="toc-number">4.8.6.1.1.4.</span> <span class="toc-text">acquireQueued</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#sethead"><span class="toc-number">4.8.6.1.1.5.</span> <span class="toc-text">setHead</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#shouldparkafterfailedacquire"><span class="toc-number">4.8.6.1.1.6.</span> <span class="toc-text">shouldParkAfterFailedAcquire</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#parkandcheckinterrupt"><span class="toc-number">4.8.6.1.1.7.</span> <span class="toc-text">parkAndCheckInterrupt</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#cancelacquire"><span class="toc-number">4.8.6.1.1.8.</span> <span class="toc-text">cancelAcquire</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">4.8.6.1.2.</span> <span class="toc-text">公平锁与非公平锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%85%AC%E5%B9%B3%E9%94%81%EF%BC%9A%E9%82%A3%E4%BA%9B-%E5%8F%8D%E7%9B%B4%E8%A7%89-%E7%9A%84%E5%9C%B0%E6%96%B9"><span class="toc-number">4.8.6.1.2.1.</span> <span class="toc-text">关于公平锁：那些“反直觉”的地方</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8D%E9%9C%80%E8%A6%81%E5%A4%8D%E6%9D%82%E7%9A%84%E9%9D%9E%E7%BA%BF%E6%80%A7%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">4.8.6.1.2.2.</span> <span class="toc-text">为什么非公平锁不需要复杂的非线性实现？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E6%98%AF%E7%BC%BA%E7%9C%81%E5%AE%9E%E7%8E%B0-%E4%B8%94%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%EF%BC%9F"><span class="toc-number">4.8.6.1.2.3.</span> <span class="toc-text">为什么非公平锁是缺省实现，且效率更高？</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%85%AC%E5%B9%B3%E9%94%81-%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.8.6.1.2.4.</span> <span class="toc-text">关于公平锁&#x2F;非公平锁的经典面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E9%94%81"><span class="toc-number">4.8.6.2.</span> <span class="toc-text">解锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#release"><span class="toc-number">4.8.6.2.1.</span> <span class="toc-text">release</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#tryrelease"><span class="toc-number">4.8.6.2.1.1.</span> <span class="toc-text">tryRelease</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#unparksuccessor"><span class="toc-number">4.8.6.2.1.2.</span> <span class="toc-text">unparkSuccessor</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E5%8D%A0%E4%B8%8E%E5%85%B1%E4%BA%AB"><span class="toc-number">4.8.6.3.</span> <span class="toc-text">独占与共享</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6"><span class="toc-number">4.8.7.</span> <span class="toc-text">条件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.8.7.1.</span> <span class="toc-text">条件对象</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">4.8.7.1.1.</span> <span class="toc-text">总结</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#await"><span class="toc-number">4.8.7.1.2.</span> <span class="toc-text">await</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#addconditionwaiter"><span class="toc-number">4.8.7.1.2.1.</span> <span class="toc-text">addConditionWaiter</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#fullyrelease"><span class="toc-number">4.8.7.1.2.2.</span> <span class="toc-text">fullyRelease</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#unlinkcancelledwaiters"><span class="toc-number">4.8.7.1.2.3.</span> <span class="toc-text">unlinkCancelledWaiters</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#isonsyncqueue"><span class="toc-number">4.8.7.1.2.4.</span> <span class="toc-text">isOnSyncQueue</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#isonsyncqueue"><span class="toc-number">4.8.7.1.2.5.</span> <span class="toc-text">isOnSyncQueue</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#transferaftercancelledwait"><span class="toc-number">4.8.7.1.2.6.</span> <span class="toc-text">transferAfterCancelledWait</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#reportinterruptafterwait"><span class="toc-number">4.8.7.1.2.7.</span> <span class="toc-text">reportInterruptAfterWait</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#signal"><span class="toc-number">4.8.7.1.3.</span> <span class="toc-text">signal</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#dosignal"><span class="toc-number">4.8.7.1.3.1.</span> <span class="toc-text">doSignal</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aqs-%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-number">4.8.8.</span> <span class="toc-text">AQS 与中断</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E4%B8%AD%E6%96%AD%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.8.8.1.</span> <span class="toc-text">两种中断模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E4%B8%AD%E6%96%AD%E7%9A%84%E6%A0%87%E5%87%86%E6%96%B9%E6%B3%95"><span class="toc-number">4.8.8.2.</span> <span class="toc-text">检测中断的标准方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E9%94%81%E7%9A%84%E8%AE%A1%E6%97%B6waiting%E6%96%B9%E6%B3%95"><span class="toc-number">4.8.8.3.</span> <span class="toc-text">非锁的计时waiting方法。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#locksupport-park-%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">4.8.8.4.</span> <span class="toc-text">LockSupport.park 的行为</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-%E4%B8%8E%E4%B8%AD%E6%96%AD"><span class="toc-number">4.8.8.5.</span> <span class="toc-text">lock 与中断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E6%96%B9%E6%B3%95"><span class="toc-number">4.8.8.6.</span> <span class="toc-text">内部方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#countdownlatch"><span class="toc-number">4.9.</span> <span class="toc-text">CountDownLatch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.9.1.</span> <span class="toc-text">初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await"><span class="toc-number">4.9.2.</span> <span class="toc-text">await</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#acquiresharedinterruptibly"><span class="toc-number">4.9.2.1.</span> <span class="toc-text">acquireSharedInterruptibly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryacquireshared"><span class="toc-number">4.9.2.2.</span> <span class="toc-text">tryAcquireShared</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doacquiresharedinterruptibly"><span class="toc-number">4.9.2.3.</span> <span class="toc-text">doAcquireSharedInterruptibly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setheadandpropagate"><span class="toc-number">4.9.2.4.</span> <span class="toc-text">setHeadAndPropagate</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#doreleaseshared"><span class="toc-number">4.9.2.5.</span> <span class="toc-text">doReleaseShared</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#countdown"><span class="toc-number">4.9.3.</span> <span class="toc-text">countDown</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#releaseshared"><span class="toc-number">4.9.3.1.</span> <span class="toc-text">releaseShared</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryreleaseshared"><span class="toc-number">4.9.3.2.</span> <span class="toc-text">tryReleaseShared</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cyclicbarrier"><span class="toc-number">4.10.</span> <span class="toc-text">CyclicBarrier</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8Ccountdownlatch-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.10.1.</span> <span class="toc-text">和CountDownLatch 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E8%80%85%E7%9A%84%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.10.2.</span> <span class="toc-text">作者的官方示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%88%90%E5%91%98%E6%8B%86%E8%A7%A3"><span class="toc-number">4.10.3.</span> <span class="toc-text">成员拆解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.10.4.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#await"><span class="toc-number">4.10.5.</span> <span class="toc-text">await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dowait"><span class="toc-number">4.10.6.</span> <span class="toc-text">dowait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA-breakbarrier"><span class="toc-number">4.10.7.</span> <span class="toc-text">异常退出 breakBarrier</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%B8%B8%E9%80%80%E5%87%BA-nextgeneration"><span class="toc-number">4.10.8.</span> <span class="toc-text">正常退出 nextGeneration</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BD%AE-reset"><span class="toc-number">4.10.9.</span> <span class="toc-text">重置 reset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E6%96%B9%E6%B3%95"><span class="toc-number">4.10.10.</span> <span class="toc-text">统计方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#isbroken"><span class="toc-number">4.10.10.1.</span> <span class="toc-text">isBroken</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#getnumberwaiting"><span class="toc-number">4.10.10.2.</span> <span class="toc-text">getNumberWaiting</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#semaphore"><span class="toc-number">4.11.</span> <span class="toc-text">Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E7%A4%BA%E4%BE%8B"><span class="toc-number">4.11.1.</span> <span class="toc-text">官方示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">4.11.2.</span> <span class="toc-text">构造器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E8%B5%84%E6%BA%90%EF%BC%9A%E5%9B%9B%E5%A4%A7-acquire-%E6%96%B9%E6%B3%95"><span class="toc-number">4.11.3.</span> <span class="toc-text">获取资源：四大 acquire 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#acquireshared"><span class="toc-number">4.11.3.1.</span> <span class="toc-text">acquireShared</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryacquireshared"><span class="toc-number">4.11.3.2.</span> <span class="toc-text">tryAcquireShared</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3"><span class="toc-number">4.11.3.2.1.</span> <span class="toc-text">公平</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%9D%9E%E5%85%AC%E5%B9%B3"><span class="toc-number">4.11.3.2.2.</span> <span class="toc-text">非公平</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90"><span class="toc-number">4.11.4.</span> <span class="toc-text">释放资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tryreleaseshared"><span class="toc-number">4.11.4.1.</span> <span class="toc-text">tryReleaseShared</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E6%89%A7%E8%A1%8C%E5%99%A8%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.12.</span> <span class="toc-text">从执行器到线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8%E7%BB%A7%E6%89%BF%E4%BD%93%E7%B3%BB"><span class="toc-number">4.12.1.</span> <span class="toc-text">执行器继承体系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#executor-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.12.1.1.</span> <span class="toc-text">Executor 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#executorservice-%E6%8E%A5%E5%8F%A3"><span class="toc-number">4.12.1.2.</span> <span class="toc-text">ExecutorService 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#abstractexecutorservice"><span class="toc-number">4.12.1.3.</span> <span class="toc-text">AbstractExecutorService</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#threadpoolexecutor"><span class="toc-number">4.12.1.3.1.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#forkjoinpool"><span class="toc-number">4.12.1.3.2.</span> <span class="toc-text">ForkJoinPool</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#the-executors"><span class="toc-number">4.12.1.4.</span> <span class="toc-text">The Executors</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB"><span class="toc-number">4.12.2.</span> <span class="toc-text">层次调用关系</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#futuretask-%E4%BD%9C%E4%B8%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%A0%B8%E5%BF%83%E4%BB%BB%E5%8A%A1%E8%BD%BD%E4%BD%93"><span class="toc-number">4.12.2.1.</span> <span class="toc-text">FutureTask 作为线程池的核心任务载体</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#thread-%E6%A8%A1%E5%9E%8B%E5%BA%95%E5%B1%82"><span class="toc-number">4.12.2.1.1.</span> <span class="toc-text">Thread 模型底层</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#futuretask-%E7%9A%84-run"><span class="toc-number">4.12.2.1.2.</span> <span class="toc-text">FutureTask 的 run()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#futuretask-%E7%9A%84-runner"><span class="toc-number">4.12.2.1.3.</span> <span class="toc-text">FutureTask 的 runner</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#invokeall"><span class="toc-number">4.12.2.1.3.1.</span> <span class="toc-text">invokeAll</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%92%88%E5%AF%B9-runnable-%E7%9A%84-submit"><span class="toc-number">4.12.2.1.3.2.</span> <span class="toc-text">两种针对 Runnable 的 submit</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%BB%B4%E6%8A%A4%E8%87%AA%E8%BA%AB%E7%8A%B6%E6%80%81"><span class="toc-number">4.12.3.</span> <span class="toc-text">线程池如何维护自身状态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.12.3.1.</span> <span class="toc-text">尝试关闭线程池</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E4%BB%BB%E5%8A%A1"><span class="toc-number">4.12.4.</span> <span class="toc-text">线程池如何管理任务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E6%89%A7%E8%A1%8C"><span class="toc-number">4.12.4.1.</span> <span class="toc-text">任务执行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6"><span class="toc-number">4.12.4.1.1.</span> <span class="toc-text">提交任务调度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%BC%93%E5%86%B2"><span class="toc-number">4.12.4.1.2.</span> <span class="toc-text">任务缓冲</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%BB%E5%8A%A1%E7%94%B3%E8%AF%B7"><span class="toc-number">4.12.4.1.3.</span> <span class="toc-text">任务申请</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%A6%82%E4%BD%95%E7%AE%A1%E7%90%86%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.12.5.</span> <span class="toc-text">线程池如何管理线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%9D%E8%AF%95%E5%A2%9E%E5%8A%A0%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.12.5.1.</span> <span class="toc-text">尝试增加线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%89%A7%E8%A1%8C"><span class="toc-number">4.12.5.2.</span> <span class="toc-text">线程执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%94%B6%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.12.5.3.</span> <span class="toc-text">回收线程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%BD%BF%E7%94%A8%E4%B8%AD%E5%8F%AF%E8%83%BD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">4.12.6.</span> <span class="toc-text">线程池使用中可能遇到的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88"><span class="toc-number">4.12.7.</span> <span class="toc-text">线程池的可替换方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%BB%88%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">4.12.8.</span> <span class="toc-text">最终解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%BB%84"><span class="toc-number">4.13.</span> <span class="toc-text">线程组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E6%9C%AC%E8%AE%BE%E8%AE%A1%E7%9B%AE%E7%9A%84"><span class="toc-number">4.13.1.</span> <span class="toc-text">原本设计目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7"><span class="toc-number">4.13.2.</span> <span class="toc-text">缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88"><span class="toc-number">4.13.3.</span> <span class="toc-text">替代方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E6%80%81%E5%BA%A6"><span class="toc-number">4.13.4.</span> <span class="toc-text">官方态度</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completionstage"><span class="toc-number">4.14.</span> <span class="toc-text">CompletionStage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#completablefuture"><span class="toc-number">4.15.</span> <span class="toc-text">CompletableFuture</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">小技巧</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%E4%BB%BB%E5%8A%A1%E8%B6%85%E6%97%B6%E9%97%AE%E9%A2%98"><span class="toc-number">5.1.</span> <span class="toc-text">如何处理任务超时问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%951%EF%BC%9A%E4%BD%BF%E7%94%A8-futuretask-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">方法1：使用 FutureTask 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%952%EF%BC%9A%E4%BD%BF%E7%94%A8%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">5.1.2.</span> <span class="toc-text">方法2：使用条件变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%953%EF%BC%9A%E4%BD%BF%E7%94%A8-countdownlatch-cyclicbarrier"><span class="toc-number">5.1.3.</span> <span class="toc-text">方法3：使用 countDownLatch&#x2F;CyclicBarrier</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%AD%E6%96%AD"><span class="toc-number">5.2.</span> <span class="toc-text">自定义线程池实现自定义中断</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">Java 异步执行中的异常处理与线程生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-futuretask-asyncuncaughtexceptionhandler-%E5%88%B0-uncaughtexceptionhandler"><span class="toc-number">6.1.</span> <span class="toc-text">从 FutureTask、AsyncUncaughtExceptionHandler 到 UncaughtExceptionHandler</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E7%BA%BF%E7%A8%8B%E6%98%AF%E5%90%A6%E7%BB%88%E6%AD%A2%E7%9A%84%E5%94%AF%E4%B8%80%E5%88%A4%E5%AE%9A%E6%A0%87%E5%87%86"><span class="toc-number">6.2.</span> <span class="toc-text">一、线程是否终止的唯一判定标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">6.2.1.</span> <span class="toc-text">1.1 会导致线程终止的情况</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E4%B8%8D%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%BA%BF%E7%A8%8B%E7%BB%88%E6%AD%A2%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-number">6.2.2.</span> <span class="toc-text">1.2 不会导致线程终止的情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-futuretask-%E5%AF%B9%E5%BC%82%E5%B8%B8%E4%BC%A0%E6%92%AD%E8%B7%AF%E5%BE%84%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-number">6.3.</span> <span class="toc-text">二、FutureTask 对异常传播路径的改变</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-execute-%E4%B8%8E-submit-%E7%9A%84%E6%A0%B9%E6%9C%AC%E5%B7%AE%E5%BC%82"><span class="toc-number">6.3.1.</span> <span class="toc-text">2.1 execute 与 submit 的根本差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-futuretask-%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA%E7%82%B9"><span class="toc-number">6.3.2.</span> <span class="toc-text">2.2 FutureTask 中的异常拦截点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-%E5%BC%82%E5%B8%B8%E5%A6%82%E4%BD%95%E8%A2%AB%E9%87%8D%E6%96%B0%E6%8A%9B%E5%87%BA%EF%BC%9Areport"><span class="toc-number">6.3.3.</span> <span class="toc-text">2.3 异常如何被重新抛出：report()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-uncaughtexceptionhandler-%E7%9A%84%E8%81%8C%E8%B4%A3%E8%BE%B9%E7%95%8C"><span class="toc-number">6.4.</span> <span class="toc-text">三、UncaughtExceptionHandler 的职责边界</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.4.1.</span> <span class="toc-text">3.1 触发条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E8%83%BD%E5%8A%9B%E4%B8%8E%E9%99%90%E5%88%B6"><span class="toc-number">6.4.2.</span> <span class="toc-text">3.2 能力与限制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-spring-asyncuncaughtexceptionhandler-%E7%9A%84%E4%BD%9C%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">6.5.</span> <span class="toc-text">四、Spring AsyncUncaughtExceptionHandler 的作用范围</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E9%80%82%E7%94%A8%E6%9D%A1%E4%BB%B6"><span class="toc-number">6.5.1.</span> <span class="toc-text">4.1 适用条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-spring-%E7%9A%84%E5%BC%82%E5%B8%B8%E6%8B%A6%E6%88%AA%E6%96%B9%E5%BC%8F"><span class="toc-number">6.5.2.</span> <span class="toc-text">4.2 Spring 的异常拦截方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E5%AF%B9%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">6.5.3.</span> <span class="toc-text">4.3 对线程生命周期的影响</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94-%E4%B8%89%E7%A7%8D%E5%BC%82%E5%B8%B8%E8%B7%AF%E5%BE%84%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">6.6.</span> <span class="toc-text">五、三种异常路径的对比</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-async-void-%E6%96%B9%E6%B3%95"><span class="toc-number">6.6.1.</span> <span class="toc-text">5.1 @Async void 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E7%BA%BF%E7%A8%8B%E6%B1%A0execute"><span class="toc-number">6.6.2.</span> <span class="toc-text">5.2 线程池execute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E7%BA%BF%E7%A8%8B%E6%B1%A0-submit"><span class="toc-number">6.6.3.</span> <span class="toc-text">5.3 线程池 submit</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD-%E4%B8%A4%E7%A7%8D-handler-%E7%9A%84%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">6.7.</span> <span class="toc-text">六、两种 Handler 的推荐使用方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-asyncuncaughtexceptionhandler-%E4%B8%9A%E5%8A%A1%E5%B1%82"><span class="toc-number">6.7.1.</span> <span class="toc-text">6.1 AsyncUncaughtExceptionHandler（业务层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-uncaughtexceptionhandler-%E7%B3%BB%E7%BB%9F%E5%B1%82"><span class="toc-number">6.7.2.</span> <span class="toc-text">6.2 UncaughtExceptionHandler（系统层）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E5%BC%82%E6%AD%A5%E4%BB%BB%E5%8A%A1"><span class="toc-number">6.7.3.</span> <span class="toc-text">6.3 有返回值的异步任务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-number">6.8.</span> <span class="toc-text">结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">Spring 的异步支持</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpooltaskexecutor"><span class="toc-number">7.1.</span> <span class="toc-text">ThreadPoolTaskExecutor</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadpooltaskexecutor-%E5%86%85%E9%83%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%9B%BF%E6%8D%A2"><span class="toc-number">7.2.</span> <span class="toc-text">ThreadPoolTaskExecutor 内部线程池的替换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A8%E8%8D%90%EF%BC%9A%E4%BD%BF%E7%94%A8%E5%88%9D%E5%A7%8B%E5%8C%96%E5%99%A8%E8%A3%85%E9%A5%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text">推荐：使用初始化器装饰</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E4%BB%A3%E7%90%86"><span class="toc-number">7.2.2.</span> <span class="toc-text">其他代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E6%88%91%E4%BB%AC%E8%A6%81%E6%9B%BF%E6%8D%A2%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.2.3.</span> <span class="toc-text">如果我们要替换线程池实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E8%A1%8C-trace-%E4%BC%A0%E9%80%92"><span class="toc-number">7.3.</span> <span class="toc-text">对线程池实行 trace 传递</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E4%BD%BF%E7%94%A8%E7%BB%9F%E4%B8%80%E5%8C%85%E8%A3%85%E5%99%A8"><span class="toc-number">7.3.1.</span> <span class="toc-text">如果使用统一包装器</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>