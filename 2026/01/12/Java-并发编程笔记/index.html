<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 并发编程笔记 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 MESA 模型 JAVA 采用 MESA 模型：  互斥（Mutual Exclusion">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 并发编程笔记">
<meta property="og:url" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。 管程 理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。 MESA 模型 JAVA 采用 MESA 模型：  互斥（Mutual Exclusion">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png">
<meta property="article:published_time" content="2026-01-12T14:28:12.000Z">
<meta property="article:modified_time" content="2026-01-25T13:31:37.824Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 并发编程笔记",
  "url": "https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
  "image": "https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png",
  "datePublished": "2026-01-12T14:28:12.000Z",
  "dateModified": "2026-01-25T13:31:37.824Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 并发编程笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 并发编程笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java 并发编程笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-12T14:28:12.000Z" title="Created 2026-01-12 22:28:12">2026-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-01-25T13:31:37.824Z" title="Updated 2026-01-25 21:31:37">2026-01-25</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">4.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>18mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><img src="juc.png" alt="juc.png"><br>
<a href="juc.xmind">juc.xmind</a></p>
<h1>写在前面的话</h1>
<p>并发编程最早的实践都在操作系统里。</p>
<h2 id="管程">管程</h2>
<p>理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。</p>
<h2 id="mesa-模型">MESA 模型</h2>
<p>JAVA 采用 MESA 模型：</p>
<ul>
<li>互斥（Mutual Exclusion）：通过锁机制保证同一时刻只有一个线程能进入管程内部执行。</li>
<li>同步（Synchronization）：利用条件变量（Condition Variable）实现线程间的等待与唤醒。</li>
<li>Signal and Continue：</li>
</ul>
<blockquote>
<p>当线程发出通知（signal/notify）时，它继续持有锁并运行，而被唤醒的线程仅仅是进入就绪队列，并不立即抢占 CPU。</p>
</blockquote>
<ul>
<li>必须使用 while 循环：</li>
</ul>
<blockquote>
<p>由于线程被唤醒后不一定立即执行，当它重新获得锁时，环境条件可能已发生变化，因此必须在一个 while 循环中重新检查等待条件（while<br>
(condition) { wait(); }）。</p>
</blockquote>
<h3 id="为什么用-set-而不用-queue">为什么用 set 而不用 queue</h3>
<ol>
<li>Queue 暗示 FIFO（先进先出）：</li>
</ol>
<ul>
<li>如果我们叫它 EntryQueue，开发者会本能地认为：先来的线程一定先拿到锁。</li>
<li>但实际上，Java 的 synchronized 是非公平锁（Non-fair Lock）。</li>
</ul>
<ol start="2">
<li>实际上更像“一堆人”而不是“一队人”：</li>
</ol>
<ul>
<li>在 JVM 的具体实现策略中，当锁被释放时，并不保证 EntrySet 中排在最前面的线程一定能抢到锁（可能被刚来的线程抢走，或者被随机唤醒）。</li>
<li>对于 WaitSet，notify() 唤醒的线程也不一定是先 wait() 的那个线程（取决于具体 JVM 实现）。</li>
<li>所以，用 Set（集合） 这个词能更准确地表达“这里有一群线程在等，但谁先出去不一定”的语义。</li>
</ul>
<p>总结：叫 Set 是为了告诉你，不要依赖它们的唤醒顺序。</p>
<h3 id="模型映射">模型映射</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Mesa 模型</th>
<th style="text-align:left">Mesa 语义</th>
<th style="text-align:left"><code>synchronized</code></th>
<th style="text-align:left"><code>ReentrantLock</code></th>
<th style="text-align:left">Java State</th>
<th style="text-align:left">超时</th>
<th style="text-align:left">JVisualVM</th>
<th style="text-align:left">底层机制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Entry Set</strong><br>(锁竞争)</td>
<td style="text-align:left">等待获取锁</td>
<td style="text-align:left">Monitor Entry List</td>
<td style="text-align:left">AQS Sync Queue</td>
<td style="text-align:left"><code>BLOCKED</code><br><code>WAITING (parking)</code></td>
<td style="text-align:left">否</td>
<td style="text-align:left">Monitor<br>Park</td>
<td style="text-align:left">ObjectMonitor<br>LockSupport.park()</td>
</tr>
<tr>
<td style="text-align:left"><strong>Wait Set</strong><br>(条件等待)</td>
<td style="text-align:left">等待条件满足</td>
<td style="text-align:left">Monitor Wait Set</td>
<td style="text-align:left">AQS Condition Queue</td>
<td style="text-align:left"><code>WAITING</code><br><code>TIMED_WAITING</code></td>
<td style="text-align:left">是</td>
<td style="text-align:left">Wait<br>Park</td>
<td style="text-align:left">ObjectMonitor<br>LockSupport.park()</td>
</tr>
<tr>
<td style="text-align:left"><strong>Owner</strong><br>(持有者)</td>
<td style="text-align:left">持有锁的线程</td>
<td style="text-align:left">Monitor Owner</td>
<td style="text-align:left">exclusiveOwnerThread</td>
<td style="text-align:left"><code>RUNNABLE</code></td>
<td style="text-align:left">-</td>
<td style="text-align:left">Running</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<h4 id="1-mesa-模型的-signal-and-continue-语义">1. Mesa 模型的 “Signal and Continue” 语义</h4>
<ul>
<li><code>notify()</code> / <code>signal()</code> 后，通知者<strong>继续持有锁</strong></li>
<li>被唤醒的线程从 Wait Set 移入 Entry Set，必须<strong>重新竞争锁</strong></li>
<li>唤醒路径：
<ul>
<li><code>synchronized</code>: Wait Set → Entry Set (<code>BLOCKED</code>) → Owner</li>
<li><code>ReentrantLock</code>: Condition Queue → Sync Queue (<code>WAITING</code>) → Owner</li>
</ul>
</li>
</ul>
<h4 id="2-entry-set-锁竞争-❌-永远不会有-timed-waiting">2. Entry Set（锁竞争）❌ 永远不会有 TIMED_WAITING</h4>
<ul>
<li><code>synchronized</code> 不支持超时</li>
<li><code>ReentrantLock.lock()</code> 不支持超时</li>
<li><code>tryLock(timeout)</code> 不进队列，在当前线程自旋</li>
</ul>
<h4 id="3-wait-set-条件等待-✅-支持-timed-waiting">3. Wait Set（条件等待）✅ 支持 TIMED_WAITING</h4>
<ul>
<li><code>wait(timeout)</code> / <code>await(timeout, unit)</code> 支持超时</li>
<li>设计哲学：条件等待是主动等待业务条件，需要&quot;等不到就放弃&quot;的语义</li>
</ul>
<h4 id="4-jvisualvm-分类逻辑">4. JVisualVM 分类逻辑</h4>
<ul>
<li><strong>Monitor</strong>: <code>synchronized</code> 的 <code>BLOCKED</code> 状态</li>
<li><strong>Park</strong>: <code>LockSupport.park()</code> 导致的 <code>WAITING</code> 状态</li>
<li><strong>Wait</strong>: <code>Object.wait()</code> 导致的 <code>WAITING</code> 状态</li>
</ul>
<h4 id="5-线程状态与-os-调度">5. 线程状态与 OS 调度</h4>
<ul>
<li><strong>RUNNABLE</strong> = OS Ready + OS Running（JVM 无法区分）</li>
<li><strong>BLOCKED</strong> / <strong>WAITING</strong>: 线程在 JVM 队列中，未持有 CPU</li>
<li>Ready Queue 是 OS 层面的，JVM 不可见</li>
</ul>
<h1>Java 线程状态</h1>
<p><img src="java-thread-state.png" alt="java-thread-state.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MesaMonitorExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionSatisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// === 等待者线程 (Thread-A) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWait</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// [阶段 1]：尝试进入 synchronized 块</span><br>        <span class="hljs-comment">// 状态详情：</span><br>        <span class="hljs-comment">// 1. Monitor 锁：未持有（正在 Entry Set 排队竞争）</span><br>        <span class="hljs-comment">// 2. CPU：未持有（被 OS 挂起）</span><br>        <span class="hljs-comment">// 3. Mesa Set：处于 Entry Set (入口队列/锁池)</span><br>        <span class="hljs-comment">// 4. 线程状态：BLOCKED</span><br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// ============================================================</span><br>            <span class="hljs-comment">// [微观状态间隙 - 从抢到锁到执行第一行代码]</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 1. 【Lock Acquired】：</span><br>            <span class="hljs-comment">//    Monitor 锁竞争成功。线程从 Entry Set 移出，成为 Owner。</span><br>            <span class="hljs-comment">//    Java 线程状态：BLOCKED -&gt; RUNNABLE。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 2. 【OS Scheduling (Ready)】：</span><br>            <span class="hljs-comment">//    虽然 Java 认为你是 RUNNABLE，但在 OS 看来，你只是进入了</span><br>            <span class="hljs-comment">//    &quot;CPU 就绪队列&quot; (Ready Queue)，正在等待分配时间片。JVM 本身并不理解 OS 的这个队列，所以 RUNNABLE 包含了“可以运行”和“正在运行”两种状态。</span><br>            <span class="hljs-comment">//    此时：持有锁 | 未持有 CPU | 状态：RUNNABLE (Ready)。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 3. 【Context Switch (Running)】：</span><br>            <span class="hljs-comment">//    OS 调度器选中了本线程，加载寄存器，PC 指针指向下一行指令。</span><br>            <span class="hljs-comment">//    此时：持有锁 | 持有 CPU | 状态：RUNNABLE (Running)。</span><br>            <span class="hljs-comment">// ============================================================</span><br>            <br>            <span class="hljs-comment">// [阶段 2]：真正执行代码</span><br>            <span class="hljs-comment">// 状态详情：持有锁 | 持有 CPU | Owner (持有者) | RUNNABLE (Running)</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Acquired lock, checking condition...&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (!conditionSatisfied) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Condition false, calling wait()...&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// [阶段 3：主动入冷宫 - 调用 wait()]</span><br>                    <span class="hljs-comment">// 状态详情（执行瞬间）：</span><br>                    <span class="hljs-comment">// 1. Monitor 锁：原子性释放</span><br>                    <span class="hljs-comment">// 2. CPU：主动放弃</span><br>                    <span class="hljs-comment">// 3. Mesa Set：从 Owner 移入 Wait Set (第一重队列)</span><br>                    <span class="hljs-comment">// 4. 线程状态：RUNNABLE -&gt; WAITING</span><br>                    <span class="hljs-comment">// 注意：此时线程完全“睡死”，必须等待 notify 救援</span><br>                    lock.wait(); <br>                    <br>                    <span class="hljs-comment">// ============================================================</span><br>                    <span class="hljs-comment">// [阶段 4：漫长的回归之路 - 穿越“两重队列”]</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 1. 【被 notify 唤醒时】：</span><br>                    <span class="hljs-comment">//    Thread-A 从 Wait Set 移出，直接被扔进 Entry Set (第二重队列)。</span><br>                    <span class="hljs-comment">//    因为锁还在通知者手里！</span><br>                    <span class="hljs-comment">//    此时状态：WAITING -&gt; BLOCKED。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 2. 【等待锁释放】：</span><br>                    <span class="hljs-comment">//    在 Entry Set 中排队，直到通知者离开 synchronized。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 3. 【竞争锁 &amp; OS 调度】：</span><br>                    <span class="hljs-comment">//    抢到锁 -&gt; BLOCKED 变 RUNNABLE (Ready) -&gt; 获得 CPU (Running)。</span><br>                    <span class="hljs-comment">// ============================================================</span><br><br>                    <span class="hljs-comment">// [阶段 5：重回舞台]</span><br>                    <span class="hljs-comment">// 此时 Thread-A 已经成功拿回了锁和 CPU</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Woke up, re-acquired lock.&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Condition met, doing work.&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// [阶段 6]：离开 synchronized 块</span><br>        <span class="hljs-comment">// 状态详情：释放锁 | 持有 CPU | 离开 Owner 变为 Outside | RUNNABLE</span><br>    &#125;<br><br>    <span class="hljs-comment">// === 通知者线程 (Thread-B) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doNotify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// [阶段 7]：获取锁</span><br>            <span class="hljs-comment">// 状态详情：持有锁 | 持有 CPU | Owner | RUNNABLE</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Acquired lock, changing condition...&quot;</span>);<br>            conditionSatisfied = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// [阶段 8：只管唤醒，不管开门]</span><br>            <span class="hljs-comment">// 状态详情（关键点）：</span><br>            <span class="hljs-comment">// 1. Monitor 锁：仍然持有！(Signal and Continue)</span><br>            <span class="hljs-comment">// 2. Mesa Set：Owner（Thread-B 还在舞台上）</span><br>            <span class="hljs-comment">// 3. 对 Thread-A 的影响：将 A 从 Wait Set 移入 Entry Set (BLOCKED)</span><br>            lock.notify(); <br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Notified, but STILL holding lock.&quot;</span>);<br>            <br>            <span class="hljs-comment">// 模拟 Thread-B 继续占用锁，此时 Thread-A 只能在 Entry Set 阻塞</span><br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>        &#125; <br>        <span class="hljs-comment">// [阶段 9：真正放手]</span><br>        <span class="hljs-comment">// 离开 synchronized 块，释放 Monitor 锁。</span><br>        <span class="hljs-comment">// 此时 Entry Set 里的 Thread-A 才有机会去抢锁，完成它的“回归之路”。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockExample</span> &#123;<br>    <span class="hljs-comment">// 显式锁（替代 synchronized）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 显式条件变量（替代 Object monitor methods）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionSatisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// === 等待者线程 (Thread-A) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAwait</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// [阶段 1]：尝试获取锁</span><br>        <span class="hljs-comment">// 状态详情：</span><br>        <span class="hljs-comment">// 1. AQS State：尝试 CAS 修改 state。</span><br>        <span class="hljs-comment">// 2. AQS Queue：如果失败，进入 AQS Sync Queue (同步队列) 排队。</span><br>        <span class="hljs-comment">// 3. 线程状态：BLOCKED (Parked)。</span><br>        lock.lock(); <br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ============================================================</span><br>            <span class="hljs-comment">// [微观状态间隙 - AQS 版]</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 1. 【Lock Acquired】：</span><br>            <span class="hljs-comment">//    CAS 成功，或被前驱节点唤醒。</span><br>            <span class="hljs-comment">//    线程从 AQS Sync Queue 移出 (Head 节点后继)。</span><br>            <span class="hljs-comment">//    State：BLOCKED -&gt; RUNNABLE。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 2. 【OS Scheduling】：</span><br>            <span class="hljs-comment">//    进入 OS Ready Queue，等待 CPU。JVM 本身并不理解 OS 的这个队列，所以 RUNNABLE 包含了“可以运行”和“正在运行”两种状态。</span><br>            <span class="hljs-comment">//    此时：持有 ReentrantLock | 未持有 CPU。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 3. 【Running】：</span><br>            <span class="hljs-comment">//    获得 CPU 时间片，开始执行下一行。</span><br>            <span class="hljs-comment">// ============================================================</span><br><br>            <span class="hljs-comment">// [阶段 2]：真正执行代码</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Acquired lock, checking condition...&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (!conditionSatisfied) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Condition false, calling await()...&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// [阶段 3：主动入冷宫 - 调用 await()]</span><br>                    <span class="hljs-comment">// 状态详情（执行瞬间）：</span><br>                    <span class="hljs-comment">// 1. Lock 释放：彻底释放锁（fullyRelease），无论重入多少次。</span><br>                    <span class="hljs-comment">// 2. Mesa 位置：</span><br>                    <span class="hljs-comment">//    a. 构造一个 Node，加入 Condition Queue (条件队列)。</span><br>                    <span class="hljs-comment">//    b. 线程被挂起 (LockSupport.park)。</span><br>                    <span class="hljs-comment">// 3. 线程状态：RUNNABLE -&gt; WAITING。</span><br>                    condition.await(); <br>                    <br>                    <span class="hljs-comment">// ============================================================</span><br>                    <span class="hljs-comment">// [阶段 4：AQS 内部的漫长回归之路]</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 1. 【Signal 发生时】：</span><br>                    <span class="hljs-comment">//    Thread-A 的 Node 从 Condition Queue 被“踢”到了 AQS Sync Queue 尾部。</span><br>                    <span class="hljs-comment">//    注意：此时它仅仅是换了个队排，锁还在 Signal 线程手里！</span><br>                    <span class="hljs-comment">//    状态：WAITING -&gt; BLOCKED (等待获取锁)。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 2. 【等待锁释放】：</span><br>                    <span class="hljs-comment">//    在 AQS Sync Queue 中自旋或挂起，直到轮到自己。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 3. 【抢锁成功】：</span><br>                    <span class="hljs-comment">//    acquireQueued 返回，从 await() 方法内部返回。</span><br>                    <span class="hljs-comment">// ============================================================</span><br><br>                    <span class="hljs-comment">// [阶段 5：重回舞台]</span><br>                    <span class="hljs-comment">// 此时 Thread-A 处于 AQS Sync Queue 的 Head 位置并拿到了锁</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Woke up, re-acquired lock.&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Condition met, doing work.&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// [阶段 6]：释放锁</span><br>            <span class="hljs-comment">// 必须在 finally 中释放！</span><br>            <span class="hljs-comment">// 动作：修改 AQS state，唤醒 AQS Sync Queue 中的下一个节点 (Successor)。</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// === 通知者线程 (Thread-B) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">()</span> &#123;<br>        lock.lock(); <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// [阶段 7]：持有锁执行业务</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Acquired lock, changing condition...&quot;</span>);<br>            conditionSatisfied = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// [阶段 8：只管迁移，不管开门]</span><br>            <span class="hljs-comment">// 关键点：signal() 仅仅是将节点从 Condition Queue 转移到 AQS Sync Queue。</span><br>            <span class="hljs-comment">// Thread-B **仍然持有锁**！</span><br>            <span class="hljs-comment">// Thread-A 此时在 AQS Sync Queue 尾部排队，状态从 WAITING 变为了 BLOCKED。</span><br>            condition.signal(); <br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Signaled, but STILL holding lock.&quot;</span>);<br>            <br>            <span class="hljs-comment">// 模拟业务耗时</span><br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// [阶段 9：真正放手]</span><br>            <span class="hljs-comment">// 释放锁 (state = 0)。</span><br>            <span class="hljs-comment">// 此时 AQS Sync Queue 里的 Thread-A (如果排在前面的话) 被 unpark 唤醒，</span><br>            <span class="hljs-comment">// 从而完成 await() 的返回。</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Releasing lock...&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="线程状态列举">线程状态列举</h2>
<h3 id="new">NEW</h3>
<p>没有启动过的线程。</p>
<h3 id="runnable">RUNNABLE</h3>
<ol>
<li>正在执行的线程。</li>
<li>可以被执行但没有拿到处理器资源。</li>
</ol>
<h3 id="blocked">BLOCKED</h3>
<p>blocked 其实是 blocked waiting。</p>
<ol>
<li>等待 monitor，进入 synchronized method/block</li>
<li>或者等 wait()/await()以后再次进入 synchronized method/block。解除 wait 以后以后不是直接 runnable，而是进入 blocked，如果 notify 后通知线程立刻离开同步块，则几乎不可能用程序观察到从 blocked 进入 runnable。如果通知者在 notify() 之后赖着不走（比如执行了一个耗时操作），或者同时有 100 个线程在竞争这把锁：
<ul>
<li>那个被唤醒的线程会长时间停留在 BLOCKED 状态，直到它抢到锁为止。可以通过 jstack 或者 Thread.getState() 清晰地观察到它处于 BLOCKED 状态。</li>
</ul>
</li>
</ol>
<h3 id="waiting">WAITING</h3>
<p>在调用这三种不计时方法以后，线程进入 waiting 态：</p>
<ul>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.park 我们经常在文档里看到的 thread lies dormant 就是被这个方法处理过的结果</li>
</ul>
<p>waiting 意味着一个线程在等待另一个线程做出某种 action。wait 在等其他对象 notify 和 notifyAll，join 在等其他线程终结。</p>
<p>如：<br>
<code>java.util.concurrent.LinkedBlockingQueue.take -&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await -&gt; java.util.concurrent.locks.LockSupport.park</code></p>
<p>Reentrantlock 的 lock 接口的栈帧则是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sun<span class="hljs-selector-class">.misc</span><span class="hljs-selector-class">.Unsafe</span><span class="hljs-selector-class">.park</span> 行: 不可用 <span class="hljs-selector-attr">[本地方法]</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.LockSupport</span><span class="hljs-selector-class">.park</span> 行: <span class="hljs-number">175</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.parkAndCheckInterrupt</span> 行: <span class="hljs-number">836</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquireQueued</span> 行: <span class="hljs-number">870</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquire</span> 行: <span class="hljs-number">1199</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span><span class="hljs-selector-class">.lock</span> 行: <span class="hljs-number">209</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.ReentrantLock</span><span class="hljs-selector-class">.lock</span> 行: <span class="hljs-number">285</span> <br></code></pre></td></tr></table></figure>
<p>jstack 总会告诉我们 waiting 的位置，比如等待某个 Condition 的 await 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;t1 before lock&quot;</span>);<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 此时 t1 是 Runnable</span><br>            queue.put(<span class="hljs-number">1</span>); <span class="hljs-comment">// 此时刺激主线程开始读 t2</span><br>            System.out.println(<span class="hljs-string">&quot;t1 begin to sleep&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1 prepare to release lock&quot;</span>);<br>        lock.unlock();<br>        System.out.println(<span class="hljs-string">&quot;t1 release lock&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t2 before lock&quot;</span>);<br>        <span class="hljs-comment">// 此时 t2 可能被 t1 阻塞，进入 waiting 状态</span><br>        lock.lock();<br>        System.out.println(<span class="hljs-string">&quot;t2 prepare to release lock&quot;</span>);<br>        lock.unlock();<br>        System.out.println(<span class="hljs-string">&quot;t2 release lock&quot;</span>);<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>    t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>    t1.start();<br>    t2.start();<br>    <span class="hljs-comment">// 此时主线程在等待一个信号来刺激自己往下走</span><br>    queue.take();<br>    <span class="hljs-comment">// 往下走的目的就是校验 t2 的状态</span><br>    <span class="hljs-keyword">while</span> (t2.isAlive()) &#123;<br>        System.out.println(t2.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对这个程序进行 thread dump，可以看出 ReentrantLock 就是依赖于 park 导致的 waiting：</p>
<p><img src="parking%E5%8D%B3waiting.png" alt="parking即waiting.png"><br>
<img src="sleeping%E5%8D%B3timed-waiting.png" alt="sleeping即timed-waiting.png"></p>
<p>如果使用 synchronized，则会显示 object monitor：</p>
<p><img src="object-monitor.png" alt="object-monitor.png"></p>
<p>所以 waiting 可能是在条件变量上等待，也可能是在 synchronizer 本身上等待，不可一概而论。</p>
<p>按照 jvisualvm 的分类方法，线程还可以分为：</p>
<ul>
<li>等待</li>
<li>驻留（park）</li>
<li>监视（monitor）</li>
</ul>
<h3 id="timed-waiting">TIMED_WAITING</h3>
<p>调用了计时方法，等待时间结束后才或者被其他唤醒方法唤醒结束等待。</p>
<ul>
<li>Thread.sleep</li>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUntil</li>
</ul>
<p>如：</p>
<p><code>java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take -&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos -&gt; java.util.concurrent.locks.LockSupport.parkNanos -&gt; sun.misc.Unsafe.park</code></p>
<p>除了 sleep 以外，jstack 总会告诉我们 time_waiting 的位置，比如等待某个 Condition 的 await 操作。</p>
<h3 id="terminated">TERMINATED</h3>
<p>终结的线程，执行已经结束了。</p>
<p>中断退出也是一种结束。</p>
<h3 id="几种线程状态的对比">几种线程状态的对比</h3>
<ol>
<li>blocked：线程想要获取锁进入临界区之前，会求锁，求不到锁会进入 entry_set，然后放弃 cpu。高并发时 blocked 会增多。</li>
<li>工作线程池开始伸缩，扩容的时候：jvm.thread.waiting.count 的数量会变少。过程是，core 线程先满，然后队列再满，这时候等待从队列里获取任务，waiting 在 take 动作上的线程已经降为0了，然后开始产生非core线程，线程数才开始增长。</li>
<li>工作吞吐变多，而调用下游的工作线程在阻塞的时候，jvm.thread.time_waiting.count 会变多，因为 rpc 框架自带超时，而这些超时是会让工作线程进行计时等待的。</li>
<li>流量变大的时候，2 和 3 可能同时发生。</li>
</ol>
<h2 id="线程间方法的设计哲学">线程间方法的设计哲学</h2>
<ol>
<li>通常：
<ol>
<li>静态方法 = “我要操作当前线程”（self-operation）。static 相当于 per thread，一个好记的例子是通常 ThreadLocal 设置为 static 的，这样每个线程可以分到一个它的实例，而不是每个线程在每个对象里分到它的实例。</li>
<li>实例方法 = “我要操作指定线程”（cross-thread operation）。</li>
</ol>
</li>
<li>这背后的逻辑是：
<ol>
<li>每个线程操作自己是比较安全的，static 可以默认在不指定对象的情况下操作自己。</li>
<li>而跨线程操作其他线程是比较危险的，因为其他线程的生死如果不是自然发展和结束的，很可能导致锁不释放，条件变量不正确设置，通知没有正确发出。这也就意味着系统可能死锁。
<ol>
<li>主动控制线程何时开始是安全的。</li>
<li>主动控制进程何时结束是危险的，因为你不能替他释放资源-这是禁止使用 stop、spend api 这类操作的全部理由。</li>
</ol>
</li>
<li>可以跨线程操作的是比较温和的操作：
<ol>
<li>start()：可以让程序员开启线程周期。</li>
<li>interrupt()：可以设置一个标志位，算是轻微的主动写入别的线程状态的一种低侵入的 api。</li>
<li>join(): 观测另一个对象的状态，通过内部自旋 wait 来等待另一个线程死亡。</li>
</ol>
</li>
<li>其他 static 方法：
<ol>
<li>yield()：主动让出 CPU，让同优先级线程有机会运行。是对调度器的&quot;建议&quot;，不保证效果。和 interrupt 的温和写入，但不必然强制操作形成对比。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="特别的切换方法">特别的切换方法</h2>
<h3 id="locksupport-park">LockSupport.park</h3>
<p>也就是线程挂起。</p>
<p>condition 的 await 底层调用的是 LockSupport.park。这个方法的参数是一个用作 monitor 的对象，会被设置到 Object 的特定 Offset 上。</p>
<p>park 只能带来 waiting。所以 sync 和 conditionObject 其实都让 thread waiting ，只不过代表 thread 的 node 处在的队列不一样而已-线程 node 在 sync queue 和 condition queue 都是 waiting。</p>
<h3 id="wait">wait</h3>
<p>这个方法是对 object 用的。</p>
<p>从 wait 中醒来会有伪唤醒的 case，所以醒来的时候一定要先检查唤醒条件是否已经得到满足。原理见<a href="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">《为什么条件锁会产生虚假唤醒现象（spurious wakeup）？》</a></p>
<h3 id="join">join</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待此线程终止，最多等待 millis 毫秒。超时值为 0 表示永久等待。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 设计巧妙之处（三个关键角色的分离）：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 当 th1 调用 th2.join() 时：</span><br><span class="hljs-comment"> * 1. 锁对象：th2（Thread 对象）</span><br><span class="hljs-comment"> * 2. 检查对象：th2（通过 isAlive() 检查）</span><br><span class="hljs-comment"> * 3. 等待线程：th1（调用 wait() 的线程）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 执行流程：</span><br><span class="hljs-comment"> * - th1 获取 th2 对象的 Monitor 锁</span><br><span class="hljs-comment"> * - th1 检查 th2.isAlive()</span><br><span class="hljs-comment"> * - th1 在 th2 对象上调用 wait()，释放锁并挂起</span><br><span class="hljs-comment"> * - th2 执行完毕时，JVM 自动调用 th2.notifyAll()</span><br><span class="hljs-comment"> * - th1 被唤醒，重新检查 th2.isAlive()（协作式逻辑）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * Thread 对象的特殊性：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 1. 普通对象（Object、String 等）：</span><br><span class="hljs-comment"> *    - 没有内置状态可以自动触发 notify()</span><br><span class="hljs-comment"> *    - wait/notify 完全由程序员手动控制</span><br><span class="hljs-comment"> *    - 适合作为条件变量</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 2. Thread 对象（特殊对象）：</span><br><span class="hljs-comment"> *    - 有内置状态：线程生命周期（NEW → RUNNABLE → TERMINATED）</span><br><span class="hljs-comment"> *    - 状态变化触发通知：线程终止时，JVM 自动调用 notifyAll()</span><br><span class="hljs-comment"> *    - 不适合作为条件变量：会出现程序设计之外的 notifyAll()</span><br><span class="hljs-comment"> *    - Javadoc 警告：&quot;不建议在 Thread 实例上使用 wait/notify/notifyAll&quot;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 为什么 JVM 要自动 notifyAll()？</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * - 设计目的：专门为 join() 而设计</span><br><span class="hljs-comment"> * - 常见需求：等待线程结束是非常常见的并发模式</span><br><span class="hljs-comment"> * - 简化编程：无需手动管理通知逻辑</span><br><span class="hljs-comment"> * - 设计哲学：Thread 对象代表执行流，生命周期结束是重要事件</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 协作式编程体现：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * - OS 调度（抢占式）：JVM/OS 决定何时给 th1 CPU 时间片</span><br><span class="hljs-comment"> * - 业务逻辑（协作式）：th1 主动检查 isAlive()，决定是否继续等待</span><br><span class="hljs-comment"> * - while 循环的意义：不是&quot;被唤醒就执行&quot;，而是&quot;醒来后检查条件&quot;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  millis 等待的毫秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException 如果 millis 为负数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException 如果当前线程被中断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 记录开始时间，用于计算已等待时长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 无超时版本：永久等待直到线程结束</span><br>        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 协作式编程的核心：while 循环主动检查条件</span><br>            <span class="hljs-comment">// - isAlive() 检查的是 this（th2）的状态</span><br>            <span class="hljs-comment">// - wait(0) 挂起的是调用线程（th1）</span><br>            <span class="hljs-comment">// - 使用 while 而非 if，防止伪唤醒（spurious wakeup）</span><br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-comment">// 调用线程（th1）在 this（th2）对象上等待</span><br>                <span class="hljs-comment">// 等价于：th2.wait(0)</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 释放 th2 对象的 Monitor 锁，th1 进入 WAITING 状态</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 可能的唤醒原因：</span><br>                <span class="hljs-comment">// 1. th2 结束，JVM 自动调用 th2.notifyAll()（Thread 对象的特殊性）</span><br>                <span class="hljs-comment">// 2. 伪唤醒（spurious wakeup）</span><br>                wait(<span class="hljs-number">0</span>);<br>                <br>                <span class="hljs-comment">// 被唤醒后，重新检查 isAlive()（协作式逻辑）</span><br>                <span class="hljs-comment">// 如果是伪唤醒且 th2 还活着，继续 wait</span><br>                <span class="hljs-comment">// 如果 th2 已死，退出循环</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 带超时版本：等待指定时间或线程结束</span><br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-comment">// 计算剩余等待时间</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis - now;<br>                <br>                <span class="hljs-comment">// 超时检查：如果已经等待了足够长的时间，退出循环</span><br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 调用线程（th1）在 this（th2）对象上等待 delay 毫秒</span><br>                <span class="hljs-comment">// 等价于：th2.wait(delay)</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 可能的唤醒原因：</span><br>                <span class="hljs-comment">// 1. th2 结束，JVM 自动调用 th2.notifyAll()</span><br>                <span class="hljs-comment">// 2. 超时时间到</span><br>                <span class="hljs-comment">// 3. 伪唤醒</span><br>                wait(delay);<br>                <br>                <span class="hljs-comment">// 更新已等待时长</span><br>                now = System.currentTimeMillis() - base;<br>                <br>                <span class="hljs-comment">// 循环继续，重新检查 isAlive() 和剩余时间（协作式逻辑）</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 退出方法时，释放 th2 对象的 Monitor 锁</span><br>        <span class="hljs-comment">// th1 继续执行后续代码</span><br>    &#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>线程的 join 相当于当前线程在另一个会死亡的线程对象上等待，在 while 循环里无限  wait，在超时或者该线程死亡的时候从 wait 里解脱出来。</li>
<li>每个 thread 对象的内置状态变成死亡的时候，JVM 会主动调用这个对象的 notifyAll，这和任意条件对象的 wait 和 notifyAll 由程序员自己控制是不一样的。</li>
</ol>
<p>关于 JMM、volatile、JUC、锁等内容，请参阅<a href="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">《线程安全与锁优化》</a>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" title="无锁队列"><img class="cover" src="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">无锁队列</div></div><div class="info-2"><div class="info-item-1">Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。 * * &lt;p&gt;原理说明： * - 仅允许一个线程调用 &#123;@code offer()&#125;，一个线程调用 &#123;@code poll()&#125;。 * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。 * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系： *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。 * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad）， *   ...</div></div></div></a><a class="pagination-related" href="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/" title="Java 线程池笔记"><img class="cover" src="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-24</div><div class="info-item-2">Java 线程池笔记</div></div><div class="info-2"><div class="info-item-1">从执行器到线程池  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia “池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。 在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括： 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection Pooling)：预先申请数据库连接，提升申请连接的速度，降低系统的开销。 实例池(Object Pooling)：循...</div></div></div></a><a class="pagination-related" href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-19</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1"> 版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374）。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级。但在深入讨论线程安全的分类之前，我们需要先理解 Java 内存模型——它是理解线程安全问题的理论基础。 Java 内存模型基础 Java 内存模型（Java Memory Model，JMM）是 Java 语言规范的一部分，定义了多线程程序中共享变量的访问规则。理解 JMM 是理解线程安全问题的基础。 为什么需要内存模型？ 现代计算机系统中，CPU 与主内存之间存在巨大的速度差异。为了弥补这一差距，硬件层面引入了多级缓存（L1、L2、L3 Cache）。这带来了一个问...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-158.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2017/11/03/JVM-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" title="JVM 的内存模型与线程"><img class="cover" src="/img/wall-paper-150.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-11-03</div><div class="info-item-2">JVM 的内存模型与线程</div></div><div class="info-2"><div class="info-item-1">JVM 的内存模型与线程 Java 内存模型（Java Memory Model, JMM）定义了多线程环境下共享变量的访问规则，是理解并发编程的基石。本文从硬件架构出发，逐步深入到 JMM 的核心机制与实践模式。 mindmap   root((JMM))     硬件基础       CPU缓存层次       缓存一致性协议     JMM 抽象       主内存 vs 工作内存       八种内存操作       happens-before 关系     关键保证       原子性       可见性       有序性     实践工具       volatile       synchronized       final 模式总览    # 模式名称 一句话口诀 适用场景     1 写刷读清 写入即刷盘，读取先清空 volatile / unlock 后的可见性   2 顺序锁 同把锁内，串行执行 synchronized 临界区保护   3 偏序传递 A先于B，B先于C，则A先于C happens-before 链式推理   4 不可变安全 构造完成前...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-20.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">上下文 卡表和 RSet（Remember Set），是 JVM 为了解决分代收集时，live set 扫描需要穿梭到不同的代的时候的效率问题。 使用缓存表来提高查询效率，是化顺序查找为部分随机查找的一种常用的设计思路。 例如，在传统的计算机体系结构中，当我们把内存分成页以后，会有一个页表，页表又会有一个快表，作为一个中间缓存项，来帮助我们查找我们需要使用的页表项（table entry）。 JVM 在进行垃圾收集的时候，有一项非常重要的工作就是确定这一次垃圾收集的对象到底有多少个，即确定 live set 的范围。 对于新生代垃圾收集器而言，这个问题又有其特殊之处。根据 JVM 的弱分代收集假设（weak generational hypothesis）的存在，每次垃圾收集的时候，新生代的扫描范围可能很大，但新生代的 live set 不应该太大。card table/Remember Set 的设计目的，就是尽量减少无用的垃圾扫描范围，使用类似操作系统或者数据库的脏页表的形式，来做类似快表的查询。 卡表（card table）  卡表是 CMS 的解决方案。 卡表通常在 JV...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">写在前面的话</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">管程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mesa-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">MESA 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-set-%E8%80%8C%E4%B8%8D%E7%94%A8-queue"><span class="toc-number">1.2.1.</span> <span class="toc-text">为什么用 set 而不用 queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">模型映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mesa-%E6%A8%A1%E5%9E%8B%E7%9A%84-signal-and-continue-%E8%AF%AD%E4%B9%89"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">1. Mesa 模型的 “Signal and Continue” 语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-entry-set-%E9%94%81%E7%AB%9E%E4%BA%89-%E2%9D%8C-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E6%9C%89-timed-waiting"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">2. Entry Set（锁竞争）❌ 永远不会有 TIMED_WAITING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-wait-set-%E6%9D%A1%E4%BB%B6%E7%AD%89%E5%BE%85-%E2%9C%85-%E6%94%AF%E6%8C%81-timed-waiting"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">3. Wait Set（条件等待）✅ 支持 TIMED_WAITING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-jvisualvm-%E5%88%86%E7%B1%BB%E9%80%BB%E8%BE%91"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">4. JVisualVM 分类逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E-os-%E8%B0%83%E5%BA%A6"><span class="toc-number">1.2.2.5.</span> <span class="toc-text">5. 线程状态与 OS 调度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Java 线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E5%88%97%E4%B8%BE"><span class="toc-number">2.1.</span> <span class="toc-text">线程状态列举</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">2.1.1.</span> <span class="toc-text">NEW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runnable"><span class="toc-number">2.1.2.</span> <span class="toc-text">RUNNABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocked"><span class="toc-number">2.1.3.</span> <span class="toc-text">BLOCKED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waiting"><span class="toc-number">2.1.4.</span> <span class="toc-text">WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timed-waiting"><span class="toc-number">2.1.5.</span> <span class="toc-text">TIMED_WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#terminated"><span class="toc-number">2.1.6.</span> <span class="toc-text">TERMINATED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.1.7.</span> <span class="toc-text">几种线程状态的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">2.2.</span> <span class="toc-text">线程间方法的设计哲学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E7%9A%84%E5%88%87%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.</span> <span class="toc-text">特别的切换方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#locksupport-park"><span class="toc-number">2.3.1.</span> <span class="toc-text">LockSupport.park</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-number">2.3.2.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">2.3.3.</span> <span class="toc-text">join</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>