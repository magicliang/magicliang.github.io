<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java 并发编程笔记 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。高层语言的并发模型都要基于底层系统对硬件抽象和并发的设计来设计和实现，不能超出操作系统允许的范围。所谓的高级抽象总体上是简化对 OS 底层机制的复杂调用。 并发与异步 本文聚焦并发（Concurrency），即多任务在同一时间段内的交替或并行执行，核心问题是资源共享、线程同步与协作。 **异步（Asynchronous）**是另">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 并发编程笔记">
<meta property="og:url" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="juc.xmind 写在前面的话 并发编程最早的实践都在操作系统里。高层语言的并发模型都要基于底层系统对硬件抽象和并发的设计来设计和实现，不能超出操作系统允许的范围。所谓的高级抽象总体上是简化对 OS 底层机制的复杂调用。 并发与异步 本文聚焦并发（Concurrency），即多任务在同一时间段内的交替或并行执行，核心问题是资源共享、线程同步与协作。 **异步（Asynchronous）**是另">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png">
<meta property="article:published_time" content="2026-01-12T14:28:12.000Z">
<meta property="article:modified_time" content="2026-02-20T13:15:47.289Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="多线程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java 并发编程笔记",
  "url": "https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/",
  "image": "https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png",
  "datePublished": "2026-01-12T14:28:12.000Z",
  "dateModified": "2026-02-20T13:15:47.289Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 并发编程笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Java 并发编程笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Java 并发编程笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-12T14:28:12.000Z" title="Created 2026-01-12 22:28:12">2026-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-20T13:15:47.289Z" title="Updated 2026-02-20 21:15:47">2026-02-20</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">18.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>71mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p><img src="juc.png" alt="juc.png"><br>
<a href="juc.xmind">juc.xmind</a></p>
<h1>写在前面的话</h1>
<p>并发编程最早的实践都在操作系统里。高层语言的并发模型都要基于底层系统对硬件抽象和并发的设计来设计和实现，不能超出操作系统允许的范围。所谓的高级抽象总体上是简化对 OS 底层机制的复杂调用。</p>
<h2 id="并发与异步">并发与异步</h2>
<p>本文聚焦<strong>并发（Concurrency）</strong>，即多任务在同一时间段内的交替或并行执行，核心问题是资源共享、线程同步与协作。</p>
<p>**异步（Asynchronous）**是另一维度：调用方发起操作后不等结果返回即继续执行，通过回调、Future或事件机制获取结果。异步可通过单线程事件循环实现，也可依托多线程并发实现。</p>
<p>二者关系：并发关注&quot;多任务如何执行与协调&quot;，异步关注&quot;调用是否阻塞等待&quot;。并发编程常涉及异步，但本文不展开异步编程模式（如响应式流、协程），相关内容请参阅<a href="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/#%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E7%9A%84%E8%BF%9B%E5%8C%96">《Java 线程池笔记》</a>。</p>
<h2 id="管程">管程</h2>
<p>理论和实践之间是有鸿沟的，要弥合这种鸿沟，通常需要我们去学习别人的实践。比如并发的标准设计思想来自于操作系统里的管程（monitor），我们应当学习管程，进而了解标准的并发模型-管理共享变量和线程（并发任务）间通信的基本理论模型。</p>
<h3 id="什么是管程">什么是管程</h3>
<p><strong>管程（Monitor）是一种并发编程的抽象数据结构</strong>，由 C.A.R. Hoare 和 Per Brinch Hansen 在 1970 年代提出。它比&quot;锁&quot;的概念更大——锁只是管程的一部分。</p>
<p><strong>管程的完整定义</strong>：</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">┌─────────────────────────────────────────────────────────────────────┐<br>│                        管程（Monitor）                               │<br>├─────────────────────────────────────────────────────────────────────┤<br>│                                                                     │<br>│  ┌─────────────────────────────────────────────────────────────┐   │<br>│  │                    <span class="hljs-number">1</span>. 共享数据（<span class="hljs-keyword">Shared</span> Data）                 │   │<br>│  │         被保护的数据结构/变量，只能通过管程的方法访问          │   │<br>│  └─────────────────────────────────────────────────────────────┘   │<br>│                              │                                      │<br>│                              ▼                                      │<br>│  ┌─────────────────────────────────────────────────────────────┐   │<br>│  │                    <span class="hljs-number">2</span>. 互斥机制（Mutual Exclusion）            │   │<br>│  │         同一时刻只有一个线程能执行管程内的代码                 │   │<br>│  │         即<span class="hljs-string">&quot;临界区&quot;</span>的保护                                      │   │<br>│  └─────────────────────────────────────────────────────────────┘   │<br>│                              │                                      │<br>│              ┌───────────────┴───────────────┐                     │<br>│              ▼                               ▼                      │<br>│  ┌───────────────────────┐     ┌───────────────────────┐          │<br>│  │  <span class="hljs-number">3</span>. 条件变量（Cond）  │     │  <span class="hljs-number">3</span>. 条件变量（Cond）  │          │<br>│  │     条件A: 等待队列   │     │     条件B: 等待队列   │  ...     │<br>│  │     <span class="hljs-keyword">wait</span>() / <span class="hljs-keyword">signal</span>() │     │     <span class="hljs-keyword">wait</span>() / <span class="hljs-keyword">signal</span>() │          │<br>│  └───────────────────────┘     └───────────────────────┘          │<br>│              │                               │                      │<br>│              └───────────────┬───────────────┘                     │<br>│                              ▼                                      │<br>│  ┌─────────────────────────────────────────────────────────────┐   │<br>│  │                    <span class="hljs-number">4</span>. 入口队列（Entry Queue）                 │   │<br>│  │         等待进入管程的线程，竞争获取执行权                     │   │<br>│  └─────────────────────────────────────────────────────────────┘   │<br>│                                                                     │<br>└─────────────────────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<p><strong>管程 ≠ 锁</strong>：</p>
<ul>
<li>锁只提供互斥，解决&quot;同一时刻只有一个线程进入&quot;</li>
<li>管程还提供条件同步，解决&quot;线程间协作等待&quot;</li>
</ul>
<h3 id="管程与-java-的映射">管程与 Java 的映射</h3>
<p>Java 中每个对象都可以作为管程：</p>
<table>
<thead>
<tr>
<th>管程概念</th>
<th>Java 实现</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>共享数据</td>
<td>对象的实例字段</td>
<td>被 <code>synchronized</code> 保护的数据</td>
</tr>
<tr>
<td>互斥机制</td>
<td><code>synchronized</code> / ObjectMonitor</td>
<td>进入/退出临界区</td>
</tr>
<tr>
<td>条件变量</td>
<td><code>Object.wait()/notify()/notifyAll()</code></td>
<td>线程间协作</td>
</tr>
<tr>
<td>入口队列</td>
<td>Entry Set</td>
<td>等待获取锁的线程集合</td>
</tr>
<tr>
<td>等待队列</td>
<td>Wait Set</td>
<td>调用 <code>wait()</code> 后的线程集合</td>
</tr>
</tbody>
</table>
<p><strong>[辨析] MESA 管程模型 vs MESI 缓存协议</strong></p>
<p>这是两个完全不同领域的概念，容易混淆：</p>
<ul>
<li>
<p><strong>MESA 模型</strong>（管程领域）：Xerox PARC 提出的管程实现模型，定义了如何用互斥锁和条件变量实现线程同步。Java 的 <code>synchronized</code> + <code>wait/notify</code> 就是 MESA 模型的典型实现。核心特点是：线程被唤醒后需要<strong>重新检查条件</strong>（因为 <code>notify</code> 不会传递信号，可能被&quot;丢失&quot;）。</p>
</li>
<li>
<p><strong>MESI 协议</strong>（硬件领域）：CPU 缓存一致性协议，用于保证多核 CPU 缓存之间的数据一致性。它定义了缓存行的四种状态（Modified/Exclusive/Shared/Invalid）。</p>
</li>
</ul>
<p>简单说：MESA 是<strong>软件层面的线程同步模型</strong>，MESI 是<strong>硬件层面的缓存一致性协议</strong>。它们解决不同层次的问题，但名字拼写相似容易混淆。</p>
<p><strong>关键洞察</strong>：</p>
<ul>
<li>Java 的 <code>synchronized</code> 是管程的<strong>互斥部分</strong></li>
<li>Java 的 <code>wait()/notify()</code> 是管程的<strong>条件同步部分</strong></li>
<li>两者结合才是完整的管程语义</li>
</ul>
<h3 id="管程的典型应用：生产者-消费者">管程的典型应用：生产者-消费者</h3>
<p>管程的经典应用是解决生产者-消费者问题：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs arcade">┌─────────────────────────────────────────────────────────────────────┐<br>│                    Monitor BoundedBuffer                            │<br>├─────────────────────────────────────────────────────────────────────┤<br>│  共享数据: <span class="hljs-built_in">buffer</span>[N], <span class="hljs-built_in">count</span>, <span class="hljs-keyword">in</span>, out                                │<br>├─────────────────────────────────────────────────────────────────────┤<br>│  条件变量: notFull (缓冲区不满), notEmpty (缓冲区不空)               │<br>├─────────────────────────────────────────────────────────────────────┤<br>│                                                                     │<br>│  put(item):                                                         │<br>│    synchronized(<span class="hljs-built_in">buffer</span>) &#123;                                           │<br>│      <span class="hljs-keyword">while</span> (<span class="hljs-built_in">count</span> == N) <span class="hljs-built_in">buffer</span>.wait();  <span class="hljs-comment">// notFull 等待             │</span><br>│      <span class="hljs-built_in">buffer</span>[<span class="hljs-keyword">in</span>] = item; <span class="hljs-built_in">count</span>++; <span class="hljs-keyword">in</span> = (<span class="hljs-keyword">in</span>+<span class="hljs-number">1</span>) % N;                   │<br>│      <span class="hljs-built_in">buffer</span>.notifyAll();                <span class="hljs-comment">// signal notEmpty          │</span><br>│    &#125;                                                                │<br>│                                                                     │<br>│  get():                                                             │<br>│    synchronized(<span class="hljs-built_in">buffer</span>) &#123;                                           │<br>│      <span class="hljs-keyword">while</span> (<span class="hljs-built_in">count</span> == <span class="hljs-number">0</span>) <span class="hljs-built_in">buffer</span>.wait();  <span class="hljs-comment">// notEmpty 等待            │</span><br>│      item = <span class="hljs-built_in">buffer</span>[out]; <span class="hljs-built_in">count</span>--; out = (out+<span class="hljs-number">1</span>) % N;                │<br>│      <span class="hljs-built_in">buffer</span>.notifyAll();                <span class="hljs-comment">// signal notFull           │</span><br>│      <span class="hljs-keyword">return</span> item;                                                   │<br>│    &#125;                                                                │<br>└─────────────────────────────────────────────────────────────────────┘<br><br>注意：Java 的 synchronized 只有单一 Wait Set，所以用 notifyAll() 唤醒所有等待者<br>     ReentrantLock 可以创建多个 Condition，实现精确唤醒<br></code></pre></td></tr></table></figure>
<h3 id="三种管程模型">三种管程模型</h3>
<p>历史上出现过三种管程模型，它们的区别在于 signal 后的行为：</p>
<table>
<thead>
<tr>
<th>模型</th>
<th>signal 后通知者行为</th>
<th>signal 后等待者行为</th>
<th>代表语言</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Hoare</strong></td>
<td>立即挂起，让出 CPU</td>
<td>立即获得锁并执行</td>
<td>理论模型，少用于实践</td>
</tr>
<tr>
<td><strong>Mesa</strong></td>
<td>继续执行，持有锁</td>
<td>进入入口队列，重新竞争锁</td>
<td><strong>Java</strong>、大多数现代语言</td>
</tr>
<tr>
<td><strong>Hansen</strong></td>
<td>signal 后立即退出管程</td>
<td>立即获得锁并执行</td>
<td>Concurrent Pascal</td>
</tr>
</tbody>
</table>
<p><strong>名称来源</strong>：Mesa 不是缩写，而是来自施乐帕洛阿尔托研究中心（Xerox PARC）于 1970 年代开发的 <strong>Mesa 编程语言</strong>。这门语言最早实现了这种 signal 后通知者继续执行的管程风格，后被 Java、C#、Modula-3 等语言采纳，成为工业界的主流管程实现。</p>
<p>Java 采用 Mesa 模型，这也是为什么被唤醒的线程必须在 <code>while</code> 循环中重新检查条件。</p>
<p><strong>Mesa 模型与操作系统层面的伪唤醒</strong>：Java 的管程实现无法消除操作系统层面的条件变量伪唤醒（spurious wakeup）现象——这是&quot;不能超出操作系统允许的范围&quot;的具体体现。因此 <code>wait()</code> 必须在 <code>while</code> 循环中，而非 <code>if</code> 语句中，以应对两种情况：（1）被 <code>notify</code> 唤醒后条件可能已被其他线程改变；（2）操作系统层面的伪唤醒。</p>
<h4 id="为什么-java-选择-mesa-而非-hoare-模型？">为什么 Java 选择 Mesa 而非 Hoare 模型？</h4>
<p>Hoare 模型理论上语义更清晰（唤醒即执行），但 Java 选择 Mesa 有以下原因：</p>
<ol>
<li><strong>实现简单</strong>：不需要在 signal 后立即切换线程上下文</li>
<li><strong>与 OS 调度器兼容</strong>：被唤醒线程进入入口队列，由 OS 调度器统一管理</li>
<li><strong>公平性更好</strong>：被唤醒线程重新竞争，避免新来的线程一直等待</li>
<li><strong>避免优先级反转</strong>：高优先级线程 signal 后继续执行，不会被低优先级的等待者阻塞</li>
</ol>
<p><strong>代价</strong>：开发者必须在 <code>while</code> 循环中重新检查条件，因为被唤醒后条件可能已被其他线程改变。</p>
<h2 id="mesa-模型">Mesa 模型</h2>
<p>Java 采用 Mesa 模型：</p>
<ul>
<li>互斥（Mutual Exclusion）：通过锁机制保证同一时刻只有一个线程能进入管程内部执行。</li>
<li>同步（Synchronization）：利用条件变量（Condition Variable）实现线程间的等待与唤醒。</li>
<li>Signal and Continue：</li>
</ul>
<blockquote>
<p>当线程发出通知（signal/notify）时，它继续持有锁并运行，而被唤醒的线程仅仅是进入就绪队列，并不立即抢占 CPU。</p>
</blockquote>
<ul>
<li>必须使用 while 循环：</li>
</ul>
<blockquote>
<p>由于线程被唤醒后不一定立即执行，当它重新获得锁时，环境条件可能已发生变化，因此必须在一个 while 循环中重新检查等待条件（while<br>
(condition) { wait(); }）。</p>
</blockquote>
<h3 id="为什么用-set-而不用-queue">为什么用 set 而不用 queue</h3>
<ol>
<li>Queue 暗示 FIFO（先进先出）：</li>
</ol>
<ul>
<li>如果我们叫它 EntryQueue，开发者会本能地认为：先来的线程一定先拿到锁。</li>
<li>但实际上，Java 的 synchronized 是非公平锁（Non-fair Lock）。</li>
</ul>
<ol start="2">
<li>实际上更像“一堆人”而不是“一队人”：</li>
</ol>
<ul>
<li>在 JVM 的具体实现策略中，当锁被释放时，并不保证 EntrySet 中排在最前面的线程一定能抢到锁（可能被刚来的线程抢走，或者被随机唤醒）。</li>
<li>对于 WaitSet，notify() 唤醒的线程也不一定是先 wait() 的那个线程（取决于具体 JVM 实现）。</li>
<li>所以，用 Set（集合） 这个词能更准确地表达“这里有一群线程在等，但谁先出去不一定”的语义。</li>
</ul>
<p>总结：叫 Set 是为了告诉你，不要依赖它们的唤醒顺序。</p>
<h3 id="entry-set-的命名含义">Entry Set 的命名含义</h3>
<p>一个常见的问题是：<strong>为什么等待的队列明明没有进入同步块，却叫 Entry Set？</strong></p>
<p>答案：<strong>Entry Set 的 “Entry” 不是指&quot;进入同步块&quot;，而是指&quot;进入管程的入口队列&quot;</strong>。</p>
<h4 id="从管程-monitor-的角度看">从管程（Monitor）的角度看</h4>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs mathematica">管程（<span class="hljs-built_in">Monitor</span>）就像一个<span class="hljs-string">&quot;房间&quot;</span>：<br>┌─────────────────────────────────────┐<br>│         管程（<span class="hljs-built_in">Monitor</span>）             │<br>│  ┌───────────────────────────────┐  │<br>│  │   <span class="hljs-variable">Entry</span> <span class="hljs-built_in">Set</span>（入口队列）        │  │ ← 等待进入房间的队列<br>│  │   <span class="hljs-operator">-</span> 线程在这里排队            │  │<br>│  │   <span class="hljs-operator">-</span> 还没有拿到<span class="hljs-string">&quot;入场券&quot;</span>（锁）  │  │<br>│  └───────────────────────────────┘  │<br>│              ↓ 获取锁                │<br>│  ┌───────────────────────────────┐  │<br>│  │   <span class="hljs-variable">Owner</span>（持有者）              │  │ ← 已经在房间里的人<br>│  │   <span class="hljs-operator">-</span> 持有锁的线程              │  │<br>│  │   <span class="hljs-operator">-</span> 正在执行临界区代码        │  │<br>│  └───────────────────────────────┘  │<br>│              ↓ 调用 <span class="hljs-variable">wait</span><span class="hljs-punctuation">(</span><span class="hljs-punctuation">)</span>           │<br>│  ┌───────────────────────────────┐  │<br>│  │   <span class="hljs-variable">Wait</span> <span class="hljs-built_in">Set</span>（等待队列）         │  │ ← 暂时离开房间的人<br>│  │   <span class="hljs-operator">-</span> 释放锁，等待条件          │  │<br>│  │   <span class="hljs-operator">-</span> 被唤醒后要重新排队        │  │<br>│  └───────────────────────────────┘  │<br>└─────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<h4 id="为什么叫-entry-set">为什么叫 Entry Set</h4>
<ol>
<li><strong>Entry = 入口</strong>：这是线程想要进入管程（Monitor）的<strong>入口排队区</strong></li>
<li><strong>还没进入</strong>：线程确实还没有进入管程内部（没有拿到锁）</li>
<li><strong>准备进入</strong>：但它们已经在管程的&quot;门口&quot;排队了</li>
</ol>
<h4 id="对比-wait-set">对比 Wait Set</h4>
<table>
<thead>
<tr>
<th>队列</th>
<th>位置</th>
<th>状态</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Entry Set</strong></td>
<td>管程<strong>外</strong>的入口</td>
<td>等待获取锁</td>
<td>想要进入管程的线程</td>
</tr>
<tr>
<td><strong>Wait Set</strong></td>
<td>管程<strong>内</strong>的休息区</td>
<td>等待条件满足</td>
<td>已经进入过管程，但暂时离开</td>
</tr>
</tbody>
</table>
<h4 id="一个形象的比喻">一个形象的比喻</h4>
<p>想象一个<strong>餐厅</strong>：</p>
<ul>
<li><strong>餐厅</strong> = 管程（Monitor）</li>
<li><strong>餐桌</strong> = 临界区资源</li>
<li><strong>座位</strong> = 锁</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs routeros">┌─────────────────────────────────────┐<br>│              餐厅                  │<br>│                                     │<br>│  【门口排队区】Entry <span class="hljs-built_in">Set</span>            │<br>│  - 顾客在这里排队等位              │<br>│  - 还没有拿到座位                  │<br>│  - 准备进入餐厅                    │<br>│              ↓ 空出座位             │<br>│  【用餐区】Owner                   │<br>│  - 已经拿到座位的顾客              │<br>│  - 正在用餐（执行代码）            │<br>│              ↓ 去洗手间            │<br>│  【洗手间】Wait <span class="hljs-built_in">Set</span>                │<br>│  - 暂时离开餐桌的顾客              │<br>│  - 等待<span class="hljs-string">&quot;洗手间空出来&quot;</span>（条件满足）  │<br>│  - 出来后要重新排队等座位          │<br>└─────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>Entry Set</strong> = 门口排队等位的顾客（还没拿到座位）</li>
<li><strong>Owner</strong> = 正在用餐的顾客（已经拿到座位）</li>
<li><strong>Wait Set</strong> = 去洗手间的顾客（暂时离开座位，回来要重新排队）</li>
</ul>
<h4 id="关键理解">关键理解</h4>
<ol>
<li>
<p><strong>Entry Set 的线程</strong>：</p>
<ul>
<li>想要进入管程</li>
<li>还没有拿到锁</li>
<li>在管程的<strong>入口</strong>排队</li>
<li>状态：<code>BLOCKED</code></li>
</ul>
</li>
<li>
<p><strong>Wait Set 的线程</strong>：</p>
<ul>
<li>已经进入过管程</li>
<li>主动释放锁（调用 <code>wait()</code>）</li>
<li>等待条件满足</li>
<li>被唤醒后要<strong>重新进入 Entry Set</strong> 排队</li>
<li>状态：<code>WAITING</code></li>
</ul>
</li>
</ol>
<p>所以，<strong>Entry Set 的命名是准确的</strong>：它是线程想要进入管程的<strong>入口队列</strong>，而不是&quot;已经进入同步块的队列&quot;。</p>
<h3 id="模型映射">模型映射</h3>
<table>
<thead>
<tr>
<th style="text-align:left">Mesa 模型</th>
<th style="text-align:left">Mesa 语义</th>
<th style="text-align:left"><code>synchronized</code></th>
<th style="text-align:left"><code>ReentrantLock</code></th>
<th style="text-align:left">Java State</th>
<th style="text-align:left">超时</th>
<th style="text-align:left">JVisualVM</th>
<th style="text-align:left">底层机制</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>Entry Set</strong><br>(锁竞争)</td>
<td style="text-align:left">等待获取锁</td>
<td style="text-align:left">Monitor Entry List</td>
<td style="text-align:left">AQS Sync Queue</td>
<td style="text-align:left"><code>BLOCKED</code><br><code>WAITING (parking)</code></td>
<td style="text-align:left">否</td>
<td style="text-align:left">Monitor<br>Park</td>
<td style="text-align:left">ObjectMonitor<br>LockSupport.park()</td>
</tr>
<tr>
<td style="text-align:left"><strong>Wait Set</strong><br>(条件等待)</td>
<td style="text-align:left">等待条件满足</td>
<td style="text-align:left">Monitor Wait Set</td>
<td style="text-align:left">AQS Condition Queue</td>
<td style="text-align:left"><code>WAITING</code><br><code>TIMED_WAITING</code></td>
<td style="text-align:left">是</td>
<td style="text-align:left">Wait<br>Park</td>
<td style="text-align:left">ObjectMonitor<br>LockSupport.park()</td>
</tr>
<tr>
<td style="text-align:left"><strong>Owner</strong><br>(持有者)</td>
<td style="text-align:left">持有锁的线程</td>
<td style="text-align:left">Monitor Owner</td>
<td style="text-align:left">exclusiveOwnerThread</td>
<td style="text-align:left"><code>RUNNABLE</code></td>
<td style="text-align:left">-</td>
<td style="text-align:left">Running</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<h4 id="管程视角-vs-java-线程状态">管程视角 vs Java 线程状态</h4>
<p>一个常见的问题是：<strong>按照 Mesa 模型，线程是否只有三种状态——Owner、Entry Set、Wait Set？</strong></p>
<p><strong>答案是：管程视角和 Java 线程状态是两个不同的抽象层次。</strong></p>
<p>从<strong>管程视角</strong>看，相对于某个特定管程，线程确实只有四种位置：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs routeros">┌─────────────────────────────────────────────────────────────────────┐<br>│                    管程视角的线程位置                                │<br>├─────────────────────────────────────────────────────────────────────┤<br>│                                                                     │<br>│  Outside ──→ Entry <span class="hljs-built_in">Set</span> ──→ Owner ──→ Wait <span class="hljs-built_in">Set</span> ──→ Entry <span class="hljs-built_in">Set</span> ──→ <span class="hljs-built_in">..</span>.│<br>│    │            │            │           │                          │<br>│    │            │            │           │                          │<br>│  未涉及       等待获取锁    持有锁      等待条件                     │<br>│  该管程       (想进进不去)  (在临界区)  (主动释放)                   │<br>│                                                                     │<br>│  注意：Outside 的线程可能正在执行其他代码，                          │<br>│        对当前管程来说<span class="hljs-string">&quot;不存在&quot;</span>                                       │<br>└─────────────────────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<p>但从 <strong>Java 线程状态</strong>看，有六种状态，且两者<strong>不是一一对应</strong>：</p>
<table>
<thead>
<tr>
<th>管程位置</th>
<th>对应的 Java 线程状态</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Outside</strong></td>
<td><code>NEW</code> / <code>RUNNABLE</code> / <code>TERMINATED</code></td>
<td>Outside 不等于&quot;空闲&quot;，线程可能在执行其他工作</td>
</tr>
<tr>
<td><strong>Entry Set</strong></td>
<td><code>BLOCKED</code>（synchronized）或 <code>WAITING</code>（ReentrantLock）</td>
<td>同一管程位置，Java 状态因实现不同而异</td>
</tr>
<tr>
<td><strong>Owner</strong></td>
<td><code>RUNNABLE</code></td>
<td>持有锁，正在执行临界区代码</td>
</tr>
<tr>
<td><strong>Wait Set</strong></td>
<td><code>WAITING</code> 或 <code>TIMED_WAITING</code></td>
<td>取决于是否使用超时版本的 wait</td>
</tr>
</tbody>
</table>
<p><strong>关键洞察</strong>：</p>
<ul>
<li>管程视角描述的是&quot;线程相对于管程的位置&quot;</li>
<li>Java 线程状态描述的是&quot;线程在其生命周期中的状态&quot;</li>
<li>一个在 Entry Set 中的线程（管程视角），在 Java 中可能是 <code>BLOCKED</code>（synchronized）也可能是 <code>WAITING</code>（ReentrantLock）</li>
</ul>
<h4 id="1-mesa-模型的-signal-and-continue-语义">1. Mesa 模型的 “Signal and Continue” 语义</h4>
<ul>
<li><code>notify()</code> / <code>signal()</code> 后，通知者<strong>继续持有锁</strong></li>
<li>被唤醒的线程从 Wait Set 移入 Entry Set，必须<strong>重新竞争锁</strong></li>
<li>唤醒路径：
<ul>
<li><code>synchronized</code>: Wait Set → Entry Set (<code>BLOCKED</code>) → Owner</li>
<li><code>ReentrantLock</code>: Condition Queue → Sync Queue (<code>WAITING</code>) → Owner</li>
</ul>
</li>
</ul>
<h4 id="2-entry-set-锁竞争-❌-永远不会有-timed-waiting">2. Entry Set（锁竞争）❌ 永远不会有 TIMED_WAITING</h4>
<ul>
<li><code>synchronized</code> 不支持超时</li>
<li><code>ReentrantLock.lock()</code> 不支持超时</li>
<li><code>tryLock(timeout)</code> 不进队列，在当前线程自旋</li>
</ul>
<h4 id="3-wait-set-条件等待-✅-支持-timed-waiting">3. Wait Set（条件等待）✅ 支持 TIMED_WAITING</h4>
<ul>
<li><code>wait(timeout)</code> / <code>await(timeout, unit)</code> 支持超时</li>
<li>设计哲学：条件等待是主动等待业务条件，需要&quot;等不到就放弃&quot;的语义</li>
</ul>
<h4 id="4-jvisualvm-分类逻辑">4. JVisualVM 分类逻辑</h4>
<ul>
<li><strong>Monitor</strong>: <code>synchronized</code> 的 <code>BLOCKED</code> 状态</li>
<li><strong>Park</strong>: <code>LockSupport.park()</code> 导致的 <code>WAITING</code> 状态</li>
<li><strong>Wait</strong>: <code>Object.wait()</code> 导致的 <code>WAITING</code> 状态</li>
</ul>
<h4 id="5-线程状态与-os-调度">5. 线程状态与 OS 调度</h4>
<ul>
<li><strong>RUNNABLE</strong> = OS Ready + OS Running（JVM 无法区分）</li>
<li><strong>BLOCKED</strong> / <strong>WAITING</strong>: 线程在 JVM 队列中，未持有 CPU<br>
Ready Queue 是 OS 层面的，JVM 不可见</li>
</ul>
<h1>Thread 模型底层实现</h1>
<p>在深入 Java 线程状态之前，有必要理解 Thread 模型的底层实现。Java Thread 之所以只支持 <code>run()</code> 方法而非 <code>call()</code>，是因为底层操作系统线程 API（如 pthread）的设计约束。</p>
<h2 id="java-thread-类的设计">Java Thread 类的设计</h2>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// java 从 1.0 开始就实现了</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> Runnable target;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Thread</span><span class="hljs-params">(Runnable target)</span> &#123;<br>        <span class="hljs-built_in">this</span>.target = target;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (target != <span class="hljs-literal">null</span>) &#123;<br>            target.run();  <span class="hljs-comment">// 只能调用 run()，没有返回值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="hotspot-jvm-中的线程创建">HotSpot JVM 中的线程创建</h2>
<p>底层的 cpp 源码是（以下代码为简化示意，基于 HotSpot JDK 11，不同版本实现可能有差异）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// HotSpot JVM 源码：thread.cpp (JDK 11)</span><br><span class="hljs-built_in">JVM_ENTRY</span>(<span class="hljs-type">void</span>, <span class="hljs-built_in">JVM_StartThread</span>(JNIEnv* jni, jobject jthread))<br>  <span class="hljs-built_in">JVMWrapper</span>(<span class="hljs-string">&quot;JVM_StartThread&quot;</span>);<br>  <br>  <span class="hljs-comment">// 1. 从 Java 对象获取 C++ Thread 对象</span><br>  JavaThread* native_thread = java_lang_Thread::<span class="hljs-built_in">thread</span>(JNIHandles::<span class="hljs-built_in">resolve_non_null</span>(jthread));<br>  <br>  <span class="hljs-comment">// 2. 状态检查</span><br>  <span class="hljs-keyword">if</span> (native_thread-&gt;<span class="hljs-built_in">is_being_ext_suspended</span>()) &#123;<br>    native_thread-&gt;<span class="hljs-built_in">set_terminated_before_start</span>(<span class="hljs-literal">true</span>);<br>  &#125;<br>  <br>  <span class="hljs-keyword">if</span> (native_thread != <span class="hljs-literal">NULL</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!native_thread-&gt;<span class="hljs-built_in">has_been_started</span>()) &#123;<br>      <span class="hljs-comment">// 3. 创建操作系统线程</span><br>      os::<span class="hljs-built_in">create_thread</span>(native_thread, thr_type, stack_size);<br>      <br>      <span class="hljs-comment">// 4. 设置线程状态为 INITIALIZED</span><br>      native_thread-&gt;<span class="hljs-built_in">set_state</span>(INITIALIZED);<br>      <br>      <span class="hljs-comment">// 5. 启动操作系统线程</span><br>      os::<span class="hljs-built_in">start_thread</span>(native_thread);<br>    &#125;<br>  &#125;<br>JVM_END<br><br><span class="hljs-comment">// Linux 实现 (os_linux.cpp)</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">os::create_thread</span><span class="hljs-params">(Thread* thread, ThreadType thr_type)</span> </span>&#123;<br>  <span class="hljs-comment">// 1. 创建 pthread_attr_t 属性</span><br>  <span class="hljs-type">pthread_attr_t</span> attr;<br>  <span class="hljs-built_in">pthread_attr_init</span>(&amp;attr);<br>  <br>  <span class="hljs-comment">// 2. 设置栈大小</span><br>  <span class="hljs-type">size_t</span> stack_size = ...; <span class="hljs-comment">// 根据线程类型设置</span><br>  <span class="hljs-built_in">pthread_attr_setstacksize</span>(&amp;attr, stack_size);<br>  <br>  <span class="hljs-comment">// 3. 关键：创建 pthread 线程</span><br>  <span class="hljs-type">pthread_t</span> tid;<br>  <span class="hljs-type">int</span> ret = <span class="hljs-built_in">pthread_create</span>(&amp;tid, &amp;attr, thread_native_entry, thread);<br>  <br>  <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 4. 保存线程 ID</span><br>    thread-&gt;<span class="hljs-built_in">set_thread_id</span>(tid);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 线程入口函数（entry point，而非回调）</span><br><span class="hljs-comment">// 入口函数：新线程被 OS 调度器首次选中执行时的起点（主动）</span><br><span class="hljs-comment">// 回调：注册一个函数，等某个异步事件完成后被调用（被动）</span><br><span class="hljs-comment">// pthread_create 的第三个参数指定的就是这个入口函数</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span>* <span class="hljs-title">thread_native_entry</span><span class="hljs-params">(Thread* thread)</span> </span>&#123;<br>  <span class="hljs-comment">// 1. 设置线程状态</span><br>  thread-&gt;<span class="hljs-built_in">set_state</span>(RUNNABLE);<br>  <br>  <span class="hljs-comment">// 2. 关键：调用 Java 层的 run() 方法</span><br>  thread-&gt;<span class="hljs-built_in">run</span>();<br>  <br>  <span class="hljs-comment">// 3. 线程结束处理</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// HotSpot JVM 中的关键结构，这个 javaThread 既持有操作系统线程句柄，也持有 Java 线程句柄。</span><br><span class="hljs-comment">// 这样实现了平台无关性。</span><br><span class="hljs-comment">// JavaThread 确实是三位一体的设计：</span><br><span class="hljs-comment">// 1. JVM 层：JavaThread* 本身（管理 JVM 内部状态）</span><br><span class="hljs-comment">// 2. OS 层：OSThread* _osthread（操作系统资源）</span><br><span class="hljs-comment">// 3. Java 层：oop _threadObj（java.lang.Thread 对象）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaThread</span>: <span class="hljs-keyword">public</span> Thread &#123;<br><span class="hljs-keyword">private</span>:<br>  oop _threadObj;        <span class="hljs-comment">// 对应的 Java Thread 对象</span><br>  OSThread* _osthread;   <span class="hljs-comment">// 操作系统线程</span><br>  <span class="hljs-keyword">volatile</span> JavaThreadState _state; <span class="hljs-comment">// 线程状态</span><br>  <br><span class="hljs-keyword">public</span>:<br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 调用 Java 层的 run() 方法</span><br>    <span class="hljs-keyword">this</span>-&gt;<span class="hljs-built_in">thread_main_inner</span>();<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_main_inner</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">has_java_lang_thread</span>()) &#123;<br>      <span class="hljs-comment">// 通过 JNI 调用 Java 层的 run() 方法</span><br>      JavaCalls::<span class="hljs-built_in">call_virtual</span>(<br>        &amp;result,<br>        klass,<br>        method,<br>        threadObj,<br>        CHECK<br>      );<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-comment">// 通过 JNI 调用 Java 方法</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">call_run_method</span><span class="hljs-params">(JNIEnv* env, jobject jthread)</span> </span>&#123;<br>  jclass threadClass = env-&gt;<span class="hljs-built_in">FindClass</span>(<span class="hljs-string">&quot;java/lang/Thread&quot;</span>);<br>  jmethodID runMethod = env-&gt;<span class="hljs-built_in">GetMethodID</span>(threadClass, <span class="hljs-string">&quot;run&quot;</span>, <span class="hljs-string">&quot;()V&quot;</span>);<br>  <br>  <span class="hljs-comment">// 调用 Thread.run() 方法</span><br>  env-&gt;<span class="hljs-built_in">CallVoidMethod</span>(jthread, runMethod);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="线程创建的调用链">线程创建的调用链</h2>
<p>整体调用的流程是从 Java 到 C++ 再到 Java 的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 调用链：</span><br>thread<span class="hljs-selector-class">.start</span>()<br>  → Thread<span class="hljs-selector-class">.start</span>() <span class="hljs-selector-attr">[Java]</span><br>  → <span class="hljs-built_in">start0</span>() <span class="hljs-selector-attr">[native]</span><br>  → <span class="hljs-built_in">JVM_StartThread</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → os::<span class="hljs-built_in">create_thread</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → <span class="hljs-built_in">pthread_create</span>() <span class="hljs-selector-attr">[Linux C]</span><br>  → <span class="hljs-built_in">thread_native_entry</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → JavaThread::<span class="hljs-built_in">run</span>() <span class="hljs-selector-attr">[JVM C++]</span><br>  → JNI: <span class="hljs-built_in">CallVoidMethod</span>(threadObj, <span class="hljs-string">&quot;run&quot;</span>) <span class="hljs-selector-attr">[JNI]</span><br>  → Thread<span class="hljs-selector-class">.run</span>() <span class="hljs-selector-attr">[Java]</span><br>  → target<span class="hljs-selector-class">.run</span>() <span class="hljs-selector-attr">[Java]</span>  <span class="hljs-comment">// 最终调用用户代码</span><br></code></pre></td></tr></table></figure>
<h2 id="javathread-三位一体设计">JavaThread 三位一体设计</h2>
<pre><code class="hljs mermaid">classDiagram
    class JavaThread &#123;
        -OSThread* _osthread
        -oop _threadObj
        -JavaThreadState _state
        -address _stack_base
        -size_t _stack_size
        
        +run()
        +thread_main_inner()
        +osthread() OSThread*
        +threadObj() oop
    &#125;
    
    class OSThread &#123;
        -pthread_t _thread_id
        -int _thread_state
        
        +set_thread_id(pthread_t)
        +thread_id() pthread_t
    &#125;
    
    class JavaThreadObj &#123;
        &lt;&lt;Java Object&gt;&gt;
        -Runnable target
        -int threadStatus
        
        +start()
        +run()
    &#125;
    
    JavaThread o-- OSThread : &quot;持有操作系统线程&quot;
    JavaThread o-- JavaThreadObj : &quot;关联Java对象&quot;</code></pre>
<h2 id="线程启动时序">线程启动时序</h2>
<pre><code class="hljs mermaid">sequenceDiagram
    participant User as Java代码
    participant JVM as JVM(JavaThread)
    participant OS as 操作系统
    
    User-&gt;&gt;JVM: new Thread(runnable)
    JVM-&gt;&gt;JVM: 创建JavaThread对象
    JVM-&gt;&gt;JVM: 创建OSThread对象
    JVM-&gt;&gt;JVM: 关联JavaThread和OSThread
    
    User-&gt;&gt;JVM: thread.start()
    JVM-&gt;&gt;JVM: 检查状态(threadStatus)
    JVM-&gt;&gt;JVM: 添加到线程组
    JVM-&gt;&gt;JVM: 调用start0()(native)
    
    JVM-&gt;&gt;OS: os::create_thread()
    OS-&gt;&gt;OS: 创建pthread线程
    OS-&gt;&gt;OS: 设置入口为thread_native_entry
    
    OS--&gt;&gt;JVM: 线程创建成功
    JVM--&gt;&gt;User: start()返回
    
    Note over OS: 新线程开始执行
    OS-&gt;&gt;JVM: thread_native_entry(JavaThread*)
    JVM-&gt;&gt;JVM: 设置线程状态为RUNNABLE
    JVM-&gt;&gt;JVM: thread-&gt;run()
    JVM-&gt;&gt;JVM: thread_main_inner()
    
    JVM-&gt;&gt;JVM: JNI: 查找Thread.run()方法
    JVM-&gt;&gt;JVM: JavaCalls::call_virtual()
    
    JVM-&gt;&gt;User: 调用Thread.run()
    User-&gt;&gt;User: target.run()(如果target!=null)
    
    User--&gt;&gt;JVM: 返回
    JVM-&gt;&gt;JVM: 线程结束清理
    JVM-&gt;&gt;OS: 释放操作系统资源</code></pre>
<p><strong>关键洞察</strong>：Java Thread 的 <code>run()</code> 方法无返回值的设计，直接源于 POSIX pthread 的线程入口函数签名 <code>void* (*)(void*)</code>——虽然有返回值，但 JVM 选择不使用它。这是&quot;高级抽象要基于底层系统&quot;的又一例证。后来 Java 5 引入的 <code>Callable&lt;V&gt;</code> 和 <code>Future&lt;V&gt;</code> 通过包装模式（FutureTask 包含 Callable）绕过了这一限制，实现了带返回值的异步任务。</p>
<h1>Java 线程状态</h1>
<p><strong>synchronized vs ReentrantLock 的等待-通知队列模型对比</strong></p>
<pre><code class="hljs mermaid">graph LR
    subgraph &quot;synchronized（内置 Monitor）&quot;
        direction TB
        ES1[&quot;Entry Set&lt;br&gt;(锁池)&lt;br&gt;BLOCKED&quot;] --&gt;|&quot;竞争成功&quot;| OW1[&quot;Owner&lt;br&gt;(持有锁)&lt;br&gt;RUNNABLE&quot;]
        OW1 --&gt;|&quot;wait()&quot;| WS1[&quot;Wait Set&lt;br&gt;(等待池)&lt;br&gt;WAITING&quot;]
        WS1 --&gt;|&quot;notify() /&lt;br&gt;notifyAll()&quot;| ES1
        OW1 --&gt;|&quot;退出 synchronized&quot;| ES1
    end
    
    subgraph &quot;ReentrantLock（AQS）&quot;
        direction TB
        SQ2[&quot;Sync Queue&lt;br&gt;(同步队列/CLH)&lt;br&gt;WAITING(park)&quot;] --&gt;|&quot;前驱释放锁&quot;| OW2[&quot;exclusiveOwnerThread&lt;br&gt;(持有锁)&lt;br&gt;RUNNABLE&quot;]
        OW2 --&gt;|&quot;await()&quot;| CQ2[&quot;Condition Queue&lt;br&gt;(条件队列)&lt;br&gt;WAITING(park)&quot;]
        CQ2 --&gt;|&quot;signal() /&lt;br&gt;signalAll()&quot;| SQ2
        OW2 --&gt;|&quot;unlock()&quot;| SQ2
    end</code></pre>
<blockquote>
<p><strong>关键差异</strong>：<code>synchronized</code> 竞争锁失败时线程状态为 <strong>BLOCKED</strong>，而 <code>ReentrantLock</code> 竞争锁失败时线程状态为 <strong>WAITING</strong>（通过 <code>LockSupport.park()</code> 实现）。这是 jstack 中看到 <code>parking</code> 和 <code>monitor</code> 的根本原因。</p>
</blockquote>
<p><strong>管程语义层面的差异</strong>：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th>synchronized</th>
<th>ReentrantLock</th>
</tr>
</thead>
<tbody>
<tr>
<td>条件变量数量</td>
<td>单一 Wait Set</td>
<td>多个 Condition（<code>newCondition()</code> 可创建任意数量）</td>
</tr>
<tr>
<td>条件唤醒精度</td>
<td><code>notifyAll()</code> 唤醒所有等待者</td>
<td><code>condition.signal()</code> 精确唤醒特定条件队列</td>
</tr>
<tr>
<td>管程粒度</td>
<td>对象级别（锁绑定到对象）</td>
<td>代码块级别（锁独立于对象）</td>
</tr>
<tr>
<td>可中断性</td>
<td>等待锁时不可中断（<code>BLOCKED</code>）</td>
<td><code>lockInterruptibly()</code> 可响应中断</td>
</tr>
</tbody>
</table>
<p><strong>关键洞察</strong>：当需要多个条件变量（如生产者-消费者中的&quot;不满&quot;和&quot;不空&quot;）时，<code>ReentrantLock</code> 的多 Condition 设计比 <code>synchronized</code> 的单一 Wait Set 更精确，避免不必要的唤醒。</p>
<p><img src="java-thread-state.png" alt="java-thread-state.png"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MesaMonitorExample</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionSatisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// === 等待者线程 (Thread-A) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWait</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// [阶段 1]：尝试进入 synchronized 块</span><br>        <span class="hljs-comment">// 状态详情：</span><br>        <span class="hljs-comment">// 1. Monitor 锁：未持有（正在 Entry Set 排队竞争）</span><br>        <span class="hljs-comment">// 2. CPU：未持有（被 OS 挂起）</span><br>        <span class="hljs-comment">// 3. Mesa Set：处于 Entry Set (入口队列/锁池)</span><br>        <span class="hljs-comment">// 4. 线程状态：BLOCKED</span><br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// ============================================================</span><br>            <span class="hljs-comment">// [微观状态间隙 - 从抢到锁到执行第一行代码]</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 1. 【Lock Acquired】：</span><br>            <span class="hljs-comment">//    Monitor 锁竞争成功。线程从 Entry Set 移出，成为 Owner。</span><br>            <span class="hljs-comment">//    Java 线程状态：BLOCKED -&gt; RUNNABLE。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 2. 【OS Scheduling (Ready)】：</span><br>            <span class="hljs-comment">//    虽然 Java 认为你是 RUNNABLE，但在 OS 看来，你只是进入了</span><br>            <span class="hljs-comment">//    &quot;CPU 就绪队列&quot; (Ready Queue)，正在等待分配时间片。JVM 本身并不理解 OS 的这个队列，所以 RUNNABLE 包含了“可以运行”和“正在运行”两种状态。</span><br>            <span class="hljs-comment">//    此时：持有锁 | 未持有 CPU | 状态：RUNNABLE (Ready)。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 3. 【Context Switch (Running)】：</span><br>            <span class="hljs-comment">//    OS 调度器选中了本线程，加载寄存器，PC 指针指向下一行指令。</span><br>            <span class="hljs-comment">//    此时：持有锁 | 持有 CPU | 状态：RUNNABLE (Running)。</span><br>            <span class="hljs-comment">// ============================================================</span><br>            <br>            <span class="hljs-comment">// [阶段 2]：真正执行代码</span><br>            <span class="hljs-comment">// 状态详情：持有锁 | 持有 CPU | Owner (持有者) | RUNNABLE (Running)</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Acquired lock, checking condition...&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (!conditionSatisfied) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Condition false, calling wait()...&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// [阶段 3：主动入冷宫 - 调用 wait()]</span><br>                    <span class="hljs-comment">// 状态详情（执行瞬间）：</span><br>                    <span class="hljs-comment">// 1. Monitor 锁：原子性释放</span><br>                    <span class="hljs-comment">// 2. CPU：主动放弃</span><br>                    <span class="hljs-comment">// 3. Mesa Set：从 Owner 移入 Wait Set (第一重队列)</span><br>                    <span class="hljs-comment">// 4. 线程状态：RUNNABLE -&gt; WAITING</span><br>                    <span class="hljs-comment">// 注意：此时线程完全“睡死”，必须等待 notify 救援</span><br>                    lock.wait(); <br>                    <br>                    <span class="hljs-comment">// ============================================================</span><br>                    <span class="hljs-comment">// [阶段 4：漫长的回归之路 - 穿越“两重队列”]</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 1. 【被 notify 唤醒时】：</span><br>                    <span class="hljs-comment">//    Thread-A 从 Wait Set 移出，直接被扔进 Entry Set (第二重队列)。</span><br>                    <span class="hljs-comment">//    因为锁还在通知者手里！</span><br>                    <span class="hljs-comment">//    此时状态：WAITING -&gt; BLOCKED。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 2. 【等待锁释放】：</span><br>                    <span class="hljs-comment">//    在 Entry Set 中排队，直到通知者离开 synchronized。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 3. 【竞争锁 &amp; OS 调度】：</span><br>                    <span class="hljs-comment">//    抢到锁 -&gt; BLOCKED 变 RUNNABLE (Ready) -&gt; 获得 CPU (Running)。</span><br>                    <span class="hljs-comment">// ============================================================</span><br><br>                    <span class="hljs-comment">// [阶段 5：重回舞台]</span><br>                    <span class="hljs-comment">// 此时 Thread-A 已经成功拿回了锁和 CPU</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Woke up, re-acquired lock.&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Condition met, doing work.&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// [阶段 6]：离开 synchronized 块</span><br>        <span class="hljs-comment">// 状态详情：释放锁 | 持有 CPU | 离开 Owner 变为 Outside | RUNNABLE</span><br>    &#125;<br><br>    <span class="hljs-comment">// === 通知者线程 (Thread-B) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doNotify</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">synchronized</span> (lock) &#123;<br>            <span class="hljs-comment">// [阶段 7]：获取锁</span><br>            <span class="hljs-comment">// 状态详情：持有锁 | 持有 CPU | Owner | RUNNABLE</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Acquired lock, changing condition...&quot;</span>);<br>            conditionSatisfied = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// [阶段 8：只管唤醒，不管开门]</span><br>            <span class="hljs-comment">// 状态详情（关键点）：</span><br>            <span class="hljs-comment">// 1. Monitor 锁：仍然持有！(Signal and Continue)</span><br>            <span class="hljs-comment">// 2. Mesa Set：Owner（Thread-B 还在舞台上）</span><br>            <span class="hljs-comment">// 3. 对 Thread-A 的影响：将 A 从 Wait Set 移入 Entry Set (BLOCKED)</span><br>            lock.notify(); <br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Notified, but STILL holding lock.&quot;</span>);<br>            <br>            <span class="hljs-comment">// 模拟 Thread-B 继续占用锁，此时 Thread-A 只能在 Entry Set 阻塞</span><br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>        &#125; <br>        <span class="hljs-comment">// [阶段 9：真正放手]</span><br>        <span class="hljs-comment">// 离开 synchronized 块，释放 Monitor 锁。</span><br>        <span class="hljs-comment">// 此时 Entry Set 里的 Thread-A 才有机会去抢锁，完成它的“回归之路”。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.locks.Condition;<br><span class="hljs-keyword">import</span> java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReentrantLockExample</span> &#123;<br>    <span class="hljs-comment">// 显式锁（替代 synchronized）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-comment">// 显式条件变量（替代 Object monitor methods）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">conditionSatisfied</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-comment">// === 等待者线程 (Thread-A) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAwait</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// [阶段 1]：尝试获取锁</span><br>        <span class="hljs-comment">// 状态详情：</span><br>        <span class="hljs-comment">// 1. AQS State：尝试 CAS 修改 state。</span><br>        <span class="hljs-comment">// 2. AQS Queue：如果失败，进入 AQS Sync Queue (同步队列) 排队。</span><br>        <span class="hljs-comment">// 3. 线程状态：BLOCKED (Parked)。</span><br>        lock.lock(); <br>        <br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// ============================================================</span><br>            <span class="hljs-comment">// [微观状态间隙 - AQS 版]</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 1. 【Lock Acquired】：</span><br>            <span class="hljs-comment">//    CAS 成功，或被前驱节点唤醒。</span><br>            <span class="hljs-comment">//    线程从 AQS Sync Queue 移出 (Head 节点后继)。</span><br>            <span class="hljs-comment">//    State：BLOCKED -&gt; RUNNABLE。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 2. 【OS Scheduling】：</span><br>            <span class="hljs-comment">//    进入 OS Ready Queue，等待 CPU。JVM 本身并不理解 OS 的这个队列，所以 RUNNABLE 包含了“可以运行”和“正在运行”两种状态。</span><br>            <span class="hljs-comment">//    此时：持有 ReentrantLock | 未持有 CPU。</span><br>            <span class="hljs-comment">//</span><br>            <span class="hljs-comment">// 3. 【Running】：</span><br>            <span class="hljs-comment">//    获得 CPU 时间片，开始执行下一行。</span><br>            <span class="hljs-comment">// ============================================================</span><br><br>            <span class="hljs-comment">// [阶段 2]：真正执行代码</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Acquired lock, checking condition...&quot;</span>);<br><br>            <span class="hljs-keyword">while</span> (!conditionSatisfied) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Condition false, calling await()...&quot;</span>);<br>                    <br>                    <span class="hljs-comment">// [阶段 3：主动入冷宫 - 调用 await()]</span><br>                    <span class="hljs-comment">// 状态详情（执行瞬间）：</span><br>                    <span class="hljs-comment">// 1. Lock 释放：彻底释放锁（fullyRelease），无论重入多少次。</span><br>                    <span class="hljs-comment">// 2. Mesa 位置：</span><br>                    <span class="hljs-comment">//    a. 构造一个 Node，加入 Condition Queue (条件队列)。</span><br>                    <span class="hljs-comment">//    b. 线程被挂起 (LockSupport.park)。</span><br>                    <span class="hljs-comment">// 3. 线程状态：RUNNABLE -&gt; WAITING。</span><br>                    condition.await(); <br>                    <br>                    <span class="hljs-comment">// ============================================================</span><br>                    <span class="hljs-comment">// [阶段 4：AQS 内部的漫长回归之路]</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 1. 【Signal 发生时】：</span><br>                    <span class="hljs-comment">//    Thread-A 的 Node 从 Condition Queue 被“踢”到了 AQS Sync Queue 尾部。</span><br>                    <span class="hljs-comment">//    注意：此时它仅仅是换了个队排，锁还在 Signal 线程手里！</span><br>                    <span class="hljs-comment">//    状态：WAITING -&gt; BLOCKED (等待获取锁)。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 2. 【等待锁释放】：</span><br>                    <span class="hljs-comment">//    在 AQS Sync Queue 中自旋或挂起，直到轮到自己。</span><br>                    <span class="hljs-comment">//</span><br>                    <span class="hljs-comment">// 3. 【抢锁成功】：</span><br>                    <span class="hljs-comment">//    acquireQueued 返回，从 await() 方法内部返回。</span><br>                    <span class="hljs-comment">// ============================================================</span><br><br>                    <span class="hljs-comment">// [阶段 5：重回舞台]</span><br>                    <span class="hljs-comment">// 此时 Thread-A 处于 AQS Sync Queue 的 Head 位置并拿到了锁</span><br>                    System.out.println(<span class="hljs-string">&quot;Thread-A: Woke up, re-acquired lock.&quot;</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    Thread.currentThread().interrupt();<br>                &#125;<br>            &#125;<br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-A: Condition met, doing work.&quot;</span>);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// [阶段 6]：释放锁</span><br>            <span class="hljs-comment">// 必须在 finally 中释放！</span><br>            <span class="hljs-comment">// 动作：修改 AQS state，唤醒 AQS Sync Queue 中的下一个节点 (Successor)。</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// === 通知者线程 (Thread-B) ===</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">()</span> &#123;<br>        lock.lock(); <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// [阶段 7]：持有锁执行业务</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Acquired lock, changing condition...&quot;</span>);<br>            conditionSatisfied = <span class="hljs-literal">true</span>;<br>            <br>            <span class="hljs-comment">// [阶段 8：只管迁移，不管开门]</span><br>            <span class="hljs-comment">// 关键点：signal() 仅仅是将节点从 Condition Queue 转移到 AQS Sync Queue。</span><br>            <span class="hljs-comment">// Thread-B **仍然持有锁**！</span><br>            <span class="hljs-comment">// Thread-A 此时在 AQS Sync Queue 尾部排队，状态从 WAITING 变为了 BLOCKED。</span><br>            condition.signal(); <br>            <br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Signaled, but STILL holding lock.&quot;</span>);<br>            <br>            <span class="hljs-comment">// 模拟业务耗时</span><br>            <span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;&#125;<br>            <br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// [阶段 9：真正放手]</span><br>            <span class="hljs-comment">// 释放锁 (state = 0)。</span><br>            <span class="hljs-comment">// 此时 AQS Sync Queue 里的 Thread-A (如果排在前面的话) 被 unpark 唤醒，</span><br>            <span class="hljs-comment">// 从而完成 await() 的返回。</span><br>            System.out.println(<span class="hljs-string">&quot;Thread-B: Releasing lock...&quot;</span>);<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="线程状态转换全景图">线程状态转换全景图</h2>
<p>上图展示了六种 Java 线程状态及其转换关系，下文详细解释每种状态的含义和触发条件。</p>
<pre><code class="hljs mermaid">stateDiagram-v2
    [*] --&gt; NEW : new Thread()
    NEW --&gt; RUNNABLE : start()
    
    RUNNABLE --&gt; BLOCKED : 等待 synchronized 锁
    BLOCKED --&gt; RUNNABLE : 获取到 Monitor 锁
    
    RUNNABLE --&gt; WAITING : wait() / join() / park()
    WAITING --&gt; BLOCKED : notify() / notifyAll() / join唤醒&lt;br&gt;(需重新竞争 Monitor 锁)
    WAITING --&gt; RUNNABLE : unpark()&lt;br&gt;(LockSupport场景，不涉及Monitor锁)
    
    RUNNABLE --&gt; TIMED_WAITING : sleep(ms) / wait(ms)&lt;br&gt;join(ms) / parkNanos()
    TIMED_WAITING --&gt; BLOCKED : 超时或被唤醒&lt;br&gt;(需重新竞争 synchronized 锁)
    TIMED_WAITING --&gt; RUNNABLE : 超时或被唤醒&lt;br&gt;(无需竞争锁)
    
    RUNNABLE --&gt; TERMINATED : run() 结束 / 异常退出
    
    note right of RUNNABLE
        包含 OS 层面的两个子状态：
        Ready（就绪）和 Running（运行中）
        JVM 无法区分这两者
    end note
    
    note right of BLOCKED
        仅由 synchronized 产生
        ReentrantLock 竞争锁时
        线程状态是 WAITING（park）
    end note</code></pre>
<h2 id="线程状态详解">线程状态详解</h2>
<h3 id="new">NEW</h3>
<p>没有启动过的线程。</p>
<h3 id="runnable">RUNNABLE</h3>
<ol>
<li>正在执行的线程。</li>
<li>可以被执行但没有拿到处理器资源。</li>
</ol>
<h3 id="blocked">BLOCKED</h3>
<p>blocked 其实是 blocked waiting。</p>
<ol>
<li>等待 monitor，进入 synchronized method/block</li>
<li>或者等 wait()/await()以后再次进入 synchronized method/block。解除 wait 以后以后不是直接 runnable，而是进入 blocked，如果 notify 后通知线程立刻离开同步块，则几乎不可能用程序观察到从 blocked 进入 runnable。如果通知者在 notify() 之后赖着不走（比如执行了一个耗时操作），或者同时有 100 个线程在竞争这把锁：
<ul>
<li>那个被唤醒的线程会长时间停留在 BLOCKED 状态，直到它抢到锁为止。可以通过 jstack 或者 Thread.getState() 清晰地观察到它处于 BLOCKED 状态。</li>
</ul>
</li>
</ol>
<h3 id="waiting">WAITING</h3>
<p>在调用这三种不计时方法以后，线程进入 waiting 态：</p>
<ul>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.park 我们经常在文档里看到的 thread lies dormant 就是被这个方法处理过的结果</li>
</ul>
<p>waiting 意味着一个线程在等待另一个线程做出某种 action。wait 在等其他对象 notify 和 notifyAll，join 在等其他线程终结。</p>
<p>如：<br>
<code>java.util.concurrent.LinkedBlockingQueue.take -&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.await -&gt; java.util.concurrent.locks.LockSupport.park</code></p>
<p>Reentrantlock 的 lock 接口的栈帧则是：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs stylus">sun<span class="hljs-selector-class">.misc</span><span class="hljs-selector-class">.Unsafe</span><span class="hljs-selector-class">.park</span> 行: 不可用 <span class="hljs-selector-attr">[本地方法]</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.LockSupport</span><span class="hljs-selector-class">.park</span> 行: <span class="hljs-number">175</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.parkAndCheckInterrupt</span> 行: <span class="hljs-number">836</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquireQueued</span> 行: <span class="hljs-number">870</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.AbstractQueuedSynchronizer</span><span class="hljs-selector-class">.acquire</span> 行: <span class="hljs-number">1199</span> <br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span>.ReentrantLock<span class="hljs-variable">$NonfairSync</span><span class="hljs-selector-class">.lock</span> 行: <span class="hljs-number">209</span><br>java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.ReentrantLock</span><span class="hljs-selector-class">.lock</span> 行: <span class="hljs-number">285</span> <br></code></pre></td></tr></table></figure>
<p>jstack 总会告诉我们 waiting 的位置，比如等待某个 Condition 的 await 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    BlockingQueue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1</span>);<br>    <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        System.out.println(<span class="hljs-string">&quot;t1 before lock&quot;</span>);<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 此时 t1 是 Runnable</span><br>            queue.put(<span class="hljs-number">1</span>); <span class="hljs-comment">// 此时刺激主线程开始读 t2</span><br>            System.out.println(<span class="hljs-string">&quot;t1 begin to sleep&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">1000000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t1 prepare to release lock&quot;</span>);<br>        lock.unlock();<br>        System.out.println(<span class="hljs-string">&quot;t1 release lock&quot;</span>);<br>    &#125;);<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;t2 before lock&quot;</span>);<br>        <span class="hljs-comment">// 此时 t2 可能被 t1 阻塞，进入 waiting 状态</span><br>        lock.lock();<br>        System.out.println(<span class="hljs-string">&quot;t2 prepare to release lock&quot;</span>);<br>        lock.unlock();<br>        System.out.println(<span class="hljs-string">&quot;t2 release lock&quot;</span>);<br>    &#125;);<br>    t1.setName(<span class="hljs-string">&quot;t1&quot;</span>);<br>    t2.setName(<span class="hljs-string">&quot;t2&quot;</span>);<br>    t1.start();<br>    t2.start();<br>    <span class="hljs-comment">// 此时主线程在等待一个信号来刺激自己往下走</span><br>    queue.take();<br>    <span class="hljs-comment">// 往下走的目的就是校验 t2 的状态</span><br>    <span class="hljs-keyword">while</span> (t2.isAlive()) &#123;<br>        System.out.println(t2.getState());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对这个程序进行 thread dump，可以看出 ReentrantLock 就是依赖于 park 导致的 waiting：</p>
<p><img src="parking%E5%8D%B3waiting.png" alt="parking即waiting.png"><br>
<img src="sleeping%E5%8D%B3timed-waiting.png" alt="sleeping即timed-waiting.png"></p>
<p>如果使用 synchronized，则会显示 object monitor：</p>
<p><img src="object-monitor.png" alt="object-monitor.png"></p>
<p>所以 waiting 可能是在条件变量上等待，也可能是在 synchronizer 本身上等待，不可一概而论。</p>
<p>按照 jvisualvm 的分类方法，线程还可以分为：</p>
<ul>
<li>等待</li>
<li>驻留（park）</li>
<li>监视（monitor）</li>
</ul>
<h3 id="timed-waiting">TIMED_WAITING</h3>
<p>调用了计时方法，等待时间结束后才或者被其他唤醒方法唤醒结束等待。</p>
<ul>
<li>Thread.sleep</li>
<li>Object.wait</li>
<li>Thread.join</li>
<li>LockSupport.parkNanos</li>
<li>LockSupport.parkUntil</li>
</ul>
<p>如：</p>
<p><code>java.util.concurrent.ScheduledThreadPoolExecutor$DelayedWorkQueue.take -&gt; java.util.concurrent.locks.AbstractQueuedSynchronizer$ConditionObject.awaitNanos -&gt; java.util.concurrent.locks.LockSupport.parkNanos -&gt; sun.misc.Unsafe.park</code></p>
<p>除了 sleep 以外，jstack 总会告诉我们 time_waiting 的位置，比如等待某个 Condition 的 await 操作。</p>
<h3 id="terminated">TERMINATED</h3>
<p>终结的线程，执行已经结束了。</p>
<p>中断退出也是一种结束。</p>
<h3 id="几种线程状态的对比">几种线程状态的对比</h3>
<ol>
<li>blocked：线程想要获取锁进入临界区之前，会求锁，求不到锁会进入 entry_set，然后放弃 cpu。高并发时 blocked 会增多。</li>
<li>工作线程池开始伸缩，扩容的时候：jvm.thread.waiting.count 的数量会变少。过程是，core 线程先满，然后队列再满，这时候等待从队列里获取任务，waiting 在 take 动作上的线程已经降为0了，然后开始产生非core线程，线程数才开始增长。</li>
<li>工作吞吐变多，而调用下游的工作线程在阻塞的时候，jvm.thread.time_waiting.count 会变多，因为 rpc 框架自带超时，而这些超时是会让工作线程进行计时等待的。</li>
<li>流量变大的时候，2 和 3 可能同时发生。</li>
</ol>
<h2 id="线程间方法的设计哲学">线程间方法的设计哲学</h2>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;静态方法（操作当前线程 - 安全）&quot;
        sleep[&quot;Thread.sleep()&quot;]
        yield[&quot;Thread.yield()&quot;]
        interrupted[&quot;Thread.interrupted()&quot;]
        currentThread[&quot;Thread.currentThread()&quot;]
    end
    
    subgraph &quot;实例方法（操作目标线程 - 需谨慎）&quot;
        subgraph &quot;安全操作&quot;
            start[&quot;start() - 开启生命周期&quot;]
            join[&quot;join() - 观测目标状态&quot;]
            interrupt[&quot;interrupt() - 设置标志位&quot;]
            getState[&quot;getState() / isAlive()&quot;]
        end
        subgraph &quot;危险操作（已废弃）&quot;
            stop[&quot;stop() - 强制终止&quot;]
            suspend[&quot;suspend() - 强制挂起&quot;]
            resume[&quot;resume() - 强制恢复&quot;]
        end
    end
    
    style stop fill:#ff6b6b,color:#fff
    style suspend fill:#ff6b6b,color:#fff
    style resume fill:#ff6b6b,color:#fff
    style start fill:#51cf66,color:#fff
    style join fill:#51cf66,color:#fff
    style interrupt fill:#ffd43b,color:#333</code></pre>
<ol>
<li>通常：
<ol>
<li>静态方法 = “我要操作当前线程”（self-operation）。static 相当于 per thread，一个好记的例子是通常 ThreadLocal 设置为 static 的，这样每个线程可以分到一个它的实例，而不是每个线程在每个对象里分到它的实例。</li>
<li>实例方法 = “我要操作指定线程”（cross-thread operation）。</li>
</ol>
</li>
<li>这背后的逻辑是：
<ol>
<li>每个线程操作自己是比较安全的，static 可以默认在不指定对象的情况下操作自己。</li>
<li>而跨线程操作其他线程是比较危险的，因为其他线程的生死如果不是自然发展和结束的，很可能导致锁不释放，条件变量不正确设置，通知没有正确发出。这也就意味着系统可能死锁。
<ol>
<li>主动控制线程何时开始是安全的。</li>
<li>主动控制进程何时结束是危险的，因为你不能替他释放资源-这是禁止使用 stop、spend api 这类操作的全部理由。</li>
</ol>
</li>
<li>可以跨线程操作的是比较温和的操作：
<ol>
<li>start()：可以让程序员开启线程周期。</li>
<li>interrupt()：可以设置一个标志位，算是轻微的主动写入别的线程状态的一种低侵入的 api。</li>
<li>join(): 观测另一个对象的状态，通过内部自旋 wait 来等待另一个线程死亡。</li>
</ol>
</li>
<li>其他 static 方法：
<ol>
<li>yield()：主动让出 CPU，让同优先级线程有机会运行。是对调度器的&quot;建议&quot;，不保证效果。和 interrupt 的温和写入，但不必然强制操作形成对比。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="线程中断机制深入解析">线程中断机制深入解析</h2>
<p>上一节我们提到，<code>interrupt()</code> 是一种&quot;温和的跨线程写入&quot;操作——它只是设置一个标志位，不会强制终止线程。这个看似简单的设计，背后隐藏着从操作系统信号机制到 JUC 框架的完整传递链路，也引发了 Java 社区关于&quot;中断线程还是取消任务&quot;的深层争论。本节将从 HotSpot 底层实现出发，逐层向上剖析 interrupt 的完整机制。</p>
<h3 id="从-hotspot-底层看-interrupt-的本质">从 HotSpot 底层看 interrupt 的本质</h3>
<h4 id="jvm-层面的数据结构">JVM 层面的数据结构</h4>
<p>在 HotSpot JVM 中，每个 Java 线程对应一个 <code>JavaThread</code> C++ 对象，其中维护着一个 <code>volatile</code> 的中断标志位：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// HotSpot JVM 简化示意（C++）</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JavaThread</span> : <span class="hljs-keyword">public</span> Thread &#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-type">bool</span> _interrupted;  <span class="hljs-comment">// 中断标志位——线程级别的全局状态</span><br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">interrupt</span><span class="hljs-params">()</span> </span>&#123;<br>        _interrupted = <span class="hljs-literal">true</span>;<br>        <span class="hljs-comment">// 如果线程正在阻塞（park/wait/sleep），唤醒它</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_blocked_on_park</span>()) &#123;<br>            <span class="hljs-built_in">unpark</span>();           <span class="hljs-comment">// 唤醒 LockSupport.park()</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_blocked_on_monitor</span>()) &#123;<br>            <span class="hljs-built_in">notify_monitor</span>();   <span class="hljs-comment">// 唤醒 Object.wait()</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_blocked_on_sleep</span>()) &#123;<br>            <span class="hljs-built_in">wakeup_sleep</span>();     <span class="hljs-comment">// 唤醒 Thread.sleep()</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">is_interrupted</span><span class="hljs-params">(<span class="hljs-type">bool</span> clear_interrupted)</span> </span>&#123;<br>        <span class="hljs-type">bool</span> old = _interrupted;<br>        <span class="hljs-keyword">if</span> (clear_interrupted) &#123;<br>            _interrupted = <span class="hljs-literal">false</span>;  <span class="hljs-comment">// Thread.interrupted() 走这个分支</span><br>        &#125;<br>        <span class="hljs-keyword">return</span> old;                <span class="hljs-comment">// isInterrupted() 走 clear=false 分支</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>关键洞察</strong>：<code>_interrupted</code> 是一个<strong>线程级别的全局布尔值</strong>，不是任务级别的。同一个线程上顺序执行的所有任务，共享这一个标志位。这是后续所有设计问题的根源。</p>
<h4 id="interrupt-与-unpark-的辨析">interrupt() 与 unpark() 的辨析</h4>
<p>一个常见的误解是认为 <code>Thread.interrupt()</code> 等价于&quot;设置中断标志位 + unpark()&quot;。虽然这个理解方向正确，但需要补充几个关键细节：</p>
<p><strong><code>interrupt()</code> 的完整动作分解</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">interrupt</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 动作 1：设置中断标志位（始终执行）</span><br>    <span class="hljs-built_in">this</span>._interrupted = <span class="hljs-literal">true</span>;<br>    <br>    <span class="hljs-comment">// 动作 2：根据线程当前状态，选择唤醒方式</span><br>    <span class="hljs-keyword">if</span> (is_blocked_on_park()) &#123;<br>        unpark();           <span class="hljs-comment">// LockSupport.park() 场景</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (is_blocked_on_monitor()) &#123;<br>        notify_monitor();   <span class="hljs-comment">// Object.wait() 场景</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (is_blocked_on_sleep()) &#123;<br>        wakeup_sleep();     <span class="hljs-comment">// Thread.sleep() 场景</span><br>    &#125;<br>    <span class="hljs-comment">// 注意：synchronized 等待锁时，无法唤醒！</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>关键差异点</strong>：</p>
<ol>
<li><strong><code>unpark()</code> 不是唯一唤醒方式</strong></li>
</ol>
<table>
<thead>
<tr>
<th>阻塞方式</th>
<th>唤醒机制</th>
<th>是否抛异常</th>
<th>标志位处理</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>LockSupport.park()</code></td>
<td><code>Unsafe.unpark()</code></td>
<td>❌ 不抛异常</td>
<td>✅ 保留标志</td>
</tr>
<tr>
<td><code>Object.wait()</code></td>
<td>ObjectMonitor 通知</td>
<td>✅ 抛 <code>InterruptedException</code></td>
<td>❌ 清除标志</td>
</tr>
<tr>
<td><code>Thread.sleep()</code></td>
<td>OS 信号唤醒</td>
<td>✅ 抛 <code>InterruptedException</code></td>
<td>❌ 清除标志</td>
</tr>
<tr>
<td><code>synchronized</code> 等待</td>
<td><strong>无法唤醒</strong></td>
<td>-</td>
<td>✅ 保留标志</td>
</tr>
</tbody>
</table>
<ol start="2">
<li><strong><code>unpark()</code> 的特殊语义</strong></li>
</ol>
<p><code>LockSupport.unpark()</code> 有一个重要特性：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 如果线程还没 park，unpark 会设置一个&quot;permit&quot;</span><br><span class="hljs-comment">// 下次 park() 会立即返回，不阻塞</span><br>LockSupport.unpark(thread);  <span class="hljs-comment">// 设置 permit = 1</span><br>LockSupport.park();          <span class="hljs-comment">// 检测到 permit，立即返回，不清除中断标志！</span><br></code></pre></td></tr></table></figure>
<p>这就是为什么 AQS 在 <code>acquireQueued()</code> 中必须用 <code>Thread.interrupted()</code>（清除版本）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();  <span class="hljs-comment">// 必须清除标志，否则 park() 会立即返回！</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ol start="3">
<li><strong><code>synchronized</code> 的特殊处理</strong></li>
</ol>
<p>这是最关键的区别：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// synchronized 等待锁时，interrupt() 无法唤醒！</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-comment">// 即使在等待锁的过程中被 interrupt()</span><br>    <span class="hljs-comment">// 也只是设置标志位，线程仍然在 BLOCKED 状态</span><br>    <span class="hljs-comment">// 必须等到获取锁后才能检查中断</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>原因</strong>：JVM 的 Monitor 实现基于操作系统的 mutex（如 Linux 的 <code>pthread_mutex</code>），而 OS mutex 不支持可中断的锁获取。这是&quot;高级抽象要基于底层系统&quot;的边界——Java 无法实现操作系统层面不支持的语义。</p>
<p>而 <code>ReentrantLock.lockInterruptibly()</code> 可以响应中断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    reentrantLock.lockInterruptibly();<br>    <span class="hljs-comment">// 等待锁时被 interrupt()，立即抛出 InterruptedException</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// 可以立即退出，不必等到获取锁</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>总结</strong>：</p>
<blockquote>
<p><code>Thread.interrupt()</code> = <strong>设置中断标志位</strong> + <strong>根据阻塞方式选择唤醒机制</strong>（unpark/OS信号/无法唤醒）</p>
</blockquote>
<p>这也是为什么&quot;interrupt 的行为不一致会增加心智负担&quot;——不同的阻塞方式响应方式完全不同！</p>
<pre><code class="hljs mermaid">graph TB
    INT[&quot;Thread.interrupt() 被调用&quot;]
    
    INT --&gt; SET[&quot;设置 _interrupted = true&quot;]
    SET --&gt; CHECK&#123;&quot;目标线程当前状态？&quot;&#125;
    
    CHECK --&gt;|&quot;RUNNABLE&lt;br/&gt;（正在运行）&quot;| DONE[&quot;仅设置标志位&lt;br/&gt;不做其他操作&quot;]
    CHECK --&gt;|&quot;WAITING&lt;br/&gt;（LockSupport.park）&quot;| UNPARK[&quot;调用 Unsafe.unpark()&lt;br/&gt;park() 立即返回&lt;br/&gt;不抛异常，保留标志&quot;]
    CHECK --&gt;|&quot;WAITING/TIMED_WAITING&lt;br/&gt;（wait/sleep/join）&quot;| NOTIFY[&quot;通过 OS 信号唤醒&lt;br/&gt;抛出 InterruptedException&lt;br/&gt;自动清除标志&quot;]
    CHECK --&gt;|&quot;BLOCKED&lt;br/&gt;（等待 synchronized）&quot;| IGNORE[&quot;无法唤醒&lt;br/&gt;仅设置标志位&lt;br/&gt;必须等到获取锁&quot;]
    CHECK --&gt;|&quot;NIO Channel&lt;br/&gt;（Selector.select）&quot;| CLOSE[&quot;关闭底层 fd&lt;br/&gt;抛出 ClosedByInterruptException&lt;br/&gt;Channel 被破坏&quot;]
    
    style IGNORE fill:#868e96,color:#fff
    style CLOSE fill:#ff6b6b,color:#fff
    style UNPARK fill:#51cf66,color:#fff
    style NOTIFY fill:#ffd43b,color:#333</code></pre>
<h4 id="操作系统层面的唤醒机制">操作系统层面的唤醒机制</h4>
<p>当线程处于不同的阻塞状态时，<code>interrupt()</code> 的唤醒路径不同：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs stylus">┌─────────────────────────────────────────────────────────────────┐<br>│                    Thread<span class="hljs-selector-class">.interrupt</span>() 的唤醒路径                 │<br>├─────────────────────────────────────────────────────────────────┤<br>│                                                                 │<br>│  设置 _interrupted = true                                       │<br>│       │                                                         │<br>│       ├── 线程在 RUNNABLE 状态                                   │<br>│       │   └── 仅设置标志位，不做其他操作                           │<br>│       │       线程需要自己检查 <span class="hljs-built_in">isInterrupted</span>()                    │<br>│       │                                                         │<br>│       ├── 线程在 Object<span class="hljs-selector-class">.wait</span>() / Thread<span class="hljs-selector-class">.sleep</span>() / Thread<span class="hljs-selector-class">.join</span>()  │<br>│       │   └── JVM 通过 OS 信号唤醒线程                            │<br>│       │       → 线程从 native 方法返回                            │<br>│       │       → 检测到 _interrupted == true                      │<br>│       │       → 清除标志位（_interrupted = false）                │<br>│       │       → 抛出 InterruptedException                       │<br>│       │                                                         │<br>│       ├── 线程在 LockSupport<span class="hljs-selector-class">.park</span>()                              │<br>│       │   └── JVM 调用 Unsafe<span class="hljs-selector-class">.unpark</span>()                           │<br>│       │       → <span class="hljs-built_in">park</span>() 立即返回                                  │<br>│       │       → 不抛异常，不清除标志位                             │<br>│       │       → 调用者需自行检查 Thread<span class="hljs-selector-class">.interrupted</span>()             │<br>│       │                                                         │<br>│       └── 线程在 NIO Channel 阻塞（如 Selector<span class="hljs-selector-class">.select</span>()）        │<br>│           └── 关闭底层 fd（文件描述符）                            │<br>│               → 抛出 ClosedByInterruptException                  │<br>│               → Channel 被关闭                                   │<br>│                                                                 │<br>└─────────────────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<p><strong>关于 fd 和 NIO 的特殊处理</strong>：当线程阻塞在 NIO 的 <code>Selector.select()</code> 或 <code>Channel.read()</code> 上时，底层实际上是在等待操作系统的文件描述符（fd）就绪。<code>interrupt()</code> 会关闭这个 fd，导致阻塞的 I/O 操作立即返回并抛出 <code>ClosedByInterruptException</code>。这是一种比较激进的唤醒方式——它不仅唤醒了线程，还<strong>破坏了 Channel</strong>，使其不可再用。</p>
<h4 id="cpu-出让与唤醒的本质">CPU 出让与唤醒的本质</h4>
<p>线程阻塞的本质是<strong>让出 CPU</strong>。不同的阻塞方式，让出 CPU 的机制不同：</p>
<pre><code class="hljs mermaid">graph TB
    subgraph &quot;阻塞方式与 CPU 出让&quot;
        PARK[&quot;LockSupport.park()&quot;]
        WAIT[&quot;Object.wait()&quot;]
        SLEEP[&quot;Thread.sleep()&quot;]
        IO[&quot;NIO Channel I/O&quot;]
        
        PARK --&gt;|&quot;Unsafe.park()&quot;| OS_FUTEX[&quot;OS: futex / pthread_cond_wait&lt;br/&gt;线程从运行队列移除&quot;]
        WAIT --&gt;|&quot;ObjectMonitor::wait()&quot;| OS_COND[&quot;OS: pthread_cond_wait&lt;br/&gt;释放 Monitor 锁 + 挂起&quot;]
        SLEEP --&gt;|&quot;os::sleep()&quot;| OS_SLEEP[&quot;OS: nanosleep / Sleep&lt;br/&gt;定时器到期后唤醒&quot;]
        IO --&gt;|&quot;epoll_wait / select&quot;| OS_IO[&quot;OS: I/O 多路复用&lt;br/&gt;等待 fd 就绪&quot;]
    end
    
    subgraph &quot;interrupt() 的唤醒方式&quot;
        UNPARK[&quot;Unsafe.unpark()&lt;br/&gt;→ 设置 permit = 1&quot;]
        NOTIFY[&quot;notify ObjectMonitor&lt;br/&gt;→ 从 WaitSet 移到 EntrySet&quot;]
        SIGNAL[&quot;发送信号&lt;br/&gt;→ 打断 nanosleep&quot;]
        CLOSE_FD[&quot;关闭 fd&lt;br/&gt;→ epoll 返回错误&quot;]
    end
    
    OS_FUTEX -.-&gt;|&quot;interrupt()&quot;| UNPARK
    OS_COND -.-&gt;|&quot;interrupt()&quot;| NOTIFY
    OS_SLEEP -.-&gt;|&quot;interrupt()&quot;| SIGNAL
    OS_IO -.-&gt;|&quot;interrupt()&quot;| CLOSE_FD
    
    style CLOSE_FD fill:#ff6b6b,color:#fff
    style UNPARK fill:#51cf66,color:#fff</code></pre>
<h3 id="三个-interrupt-相关方法的精确语义">三个 interrupt 相关方法的精确语义</h3>
<p>Java 提供了三个与中断相关的方法，它们的行为差异是大量 bug 的根源：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>类型</th>
<th>行为</th>
<th>是否清除标志</th>
<th>典型用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>interrupt()</code></td>
<td>实例方法</td>
<td>设置目标线程的中断标志为 <code>true</code>；若目标线程正在阻塞，则唤醒它</td>
<td>—</td>
<td>跨线程发送中断信号</td>
</tr>
<tr>
<td><code>isInterrupted()</code></td>
<td>实例方法</td>
<td>返回目标线程的中断状态</td>
<td><strong>否</strong></td>
<td>非破坏性地查询中断状态</td>
</tr>
<tr>
<td><code>Thread.interrupted()</code></td>
<td><strong>静态方法</strong></td>
<td>返回<strong>当前线程</strong>的中断状态</td>
<td><strong>是</strong></td>
<td>检查并消费中断信号</td>
</tr>
</tbody>
</table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 关键区别演示</span><br><span class="hljs-type">Thread</span> <span class="hljs-variable">targetThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>    <span class="hljs-comment">// 假设此线程已被 interrupt</span><br>    <br>    <span class="hljs-comment">// 查询方式 1：不清除标志</span><br>    targetThread.isInterrupted();   <span class="hljs-comment">// 返回 true，标志仍为 true</span><br>    targetThread.isInterrupted();   <span class="hljs-comment">// 返回 true，标志仍为 true</span><br>    <br>    <span class="hljs-comment">// 查询方式 2：清除标志（静态方法，操作当前线程）</span><br>    Thread.interrupted();           <span class="hljs-comment">// 返回 true，标志变为 false！</span><br>    Thread.interrupted();           <span class="hljs-comment">// 返回 false，因为上一次已清除</span><br>&#125;);<br></code></pre></td></tr></table></figure>
<p><strong><code>Thread.interrupted()</code> 的清除行为是设计上的双刃剑</strong>：它实现了&quot;检查并消费&quot;的语义——一次中断信号只能被消费一次。这在单层代码中是合理的，但在嵌套调用中会导致&quot;中断标志泄露&quot;问题（后文详述）。</p>
<h3 id="阻塞方法对-interrupt-的响应差异">阻塞方法对 interrupt 的响应差异</h3>
<p>不同的阻塞方法对 <code>interrupt()</code> 的响应方式截然不同，这种不一致性增加了开发者的心智负担：</p>
<pre><code class="hljs mermaid">flowchart TB
    INT[&quot;Thread.interrupt() 被调用&quot;]
    
    INT --&gt; CHECK&#123;&quot;目标线程&lt;br/&gt;当前状态？&quot;&#125;
    
    CHECK --&gt;|&quot;RUNNABLE&lt;br/&gt;（正在运行）&quot;| RUN[&quot;仅设置标志位&lt;br/&gt;不抛异常&lt;br/&gt;不清除标志&quot;]
    CHECK --&gt;|&quot;WAITING/TIMED_WAITING&lt;br/&gt;（wait/sleep/join）&quot;| BLOCK[&quot;抛出 InterruptedException&lt;br/&gt;清除中断标志&quot;]
    CHECK --&gt;|&quot;WAITING&lt;br/&gt;（LockSupport.park）&quot;| PARK_R[&quot;park() 立即返回&lt;br/&gt;不抛异常&lt;br/&gt;不清除标志&quot;]
    CHECK --&gt;|&quot;BLOCKED&lt;br/&gt;（等待 synchronized）&quot;| SYNC[&quot;无法响应中断&lt;br/&gt;仅设置标志位&lt;br/&gt;必须等到获取锁后才能检查&quot;]
    
    RUN --&gt; MANUAL[&quot;开发者需手动检查&lt;br/&gt;isInterrupted()&quot;]
    BLOCK --&gt; CATCH[&quot;catch 块中标志已清除&lt;br/&gt;开发者需手动恢复&quot;]
    PARK_R --&gt; AQS_CHECK[&quot;AQS 通过&lt;br/&gt;Thread.interrupted()&lt;br/&gt;检查并清除&quot;]
    SYNC --&gt; LATER[&quot;获取锁后才能&lt;br/&gt;检查中断状态&quot;]
    
    style BLOCK fill:#ff6b6b,color:#fff
    style PARK_R fill:#ffd43b,color:#333
    style SYNC fill:#868e96,color:#fff
    style RUN fill:#51cf66,color:#fff</code></pre>
<p>用代码展示这四种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 情况 A：线程在 wait/sleep/join 阻塞时收到 interrupt</span><br><span class="hljs-comment">// → 抛出 InterruptedException，清除中断标志</span><br><span class="hljs-keyword">try</span> &#123;<br>    Thread.sleep(<span class="hljs-number">10000</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// 进入这里时，中断标志已被清除为 false</span><br>    <span class="hljs-comment">// 如果不恢复，上层调用者将无法感知中断</span><br>    Thread.currentThread().interrupt(); <span class="hljs-comment">// 恢复中断标志</span><br>&#125;<br><br><span class="hljs-comment">// 情况 B：线程在运行时收到 interrupt</span><br><span class="hljs-comment">// → 不抛异常，需要手动检查</span><br><span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>    doWork(); <span class="hljs-comment">// 不会自动中断，需要在循环条件中检查</span><br>&#125;<br><br><span class="hljs-comment">// 情况 C：线程在 LockSupport.park() 时收到 interrupt</span><br><span class="hljs-comment">// → park() 立即返回，不抛异常，不清除标志</span><br>LockSupport.park();<br><span class="hljs-comment">// park 返回后，中断标志仍为 true</span><br><span class="hljs-comment">// AQS 在这里用 Thread.interrupted() 检查并清除</span><br><span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>    <span class="hljs-comment">// 记录中断状态，延迟处理</span><br>    interrupted = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 情况 D：线程在等待 synchronized 锁时收到 interrupt</span><br><span class="hljs-comment">// → 无法响应！必须等到获取锁后才能检查</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-comment">// 即使在等待锁的过程中被 interrupt，</span><br>    <span class="hljs-comment">// 也必须等到进入这里才能检查</span><br>    <span class="hljs-keyword">if</span> (Thread.currentThread().isInterrupted()) &#123;<br>        <span class="hljs-comment">// 处理中断</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>[PATTERN] 中断响应的三种模式</strong>：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>代表方法</th>
<th>行为</th>
<th>标志位处理</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>抛异常 + 清除</strong></td>
<td><code>wait()</code>, <code>sleep()</code>, <code>join()</code></td>
<td>立即抛出 <code>InterruptedException</code></td>
<td>自动清除，需手动恢复</td>
</tr>
<tr>
<td><strong>静默返回 + 保留</strong></td>
<td><code>LockSupport.park()</code></td>
<td>方法返回，不抛异常</td>
<td>保留标志，由调用者处理</td>
</tr>
<tr>
<td><strong>完全忽略</strong></td>
<td><code>synchronized</code> 等待</td>
<td>无法响应，继续等待</td>
<td>保留标志，获取锁后才能检查</td>
</tr>
</tbody>
</table>
<h3 id="中断恢复：为什么必须-thread-currentthread-interrupt">中断恢复：为什么必须 <code>Thread.currentThread().interrupt()</code></h3>
<p>当 <code>InterruptedException</code> 被捕获后，中断标志已被清除。如果当前代码只是&quot;路过&quot;（比如中间层、包装层），不是中断的最终处理者，就必须恢复中断标志，否则上层调用者将永远无法感知到中断的发生：</p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Caller as 上层调用者
    participant Middle as 中间层方法
    participant Sleep as Thread.sleep()
    participant External as 外部线程
    
    External-&gt;&gt;Middle: interrupt()
    Note over Middle: 中断标志 = true
    
    Middle-&gt;&gt;Sleep: sleep(10000)
    Note over Sleep: 检测到中断标志
    Sleep--&gt;&gt;Middle: 抛出 InterruptedException
    Note over Middle: 中断标志被清除为 false！
    
    alt 正确做法：恢复中断
        Middle-&gt;&gt;Middle: Thread.currentThread().interrupt()
        Note over Middle: 中断标志恢复为 true
        Middle--&gt;&gt;Caller: 返回（或抛出业务异常）
        Note over Caller: 可以检测到中断
    else 错误做法：吞掉异常
        Middle-&gt;&gt;Middle: log.error(&quot;interrupted&quot;)
        Note over Middle: 中断标志仍为 false
        Middle--&gt;&gt;Caller: 返回
        Note over Caller: 无法检测到中断！
    end</code></pre>
<p><strong>标准的中断处理模式</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 模式 1：传播异常（推荐，让调用者决定如何处理）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 直接让异常传播</span><br>&#125;<br><br><span class="hljs-comment">// 模式 2：恢复中断标志（当方法签名不能抛 InterruptedException 时）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        Thread.currentThread().interrupt(); <span class="hljs-comment">// 必须恢复！</span><br>        <span class="hljs-comment">// 然后选择：return、break、或抛出非受检异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Task interrupted&quot;</span>, e);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 模式 3：吞掉中断（几乎总是错误的）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-comment">// ❌ 空 catch 块——中断信号永久丢失</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="interrupt-在-aqs-中的传递机制">interrupt 在 AQS 中的传递机制</h3>
<p>AQS（<code>AbstractQueuedSynchronizer</code>）是 <code>java.util.concurrent</code> 的基石，它对 interrupt 的处理方式与 <code>Object.wait()</code> 截然不同，体现了两种完全不同的中断哲学。</p>
<h4 id="aqs-的-延迟中断-策略">AQS 的&quot;延迟中断&quot;策略</h4>
<p>AQS 的 <code>acquire()</code> 方法（非中断版本）采用<strong>延迟中断</strong>策略：先获取锁，再处理中断。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractQueuedSynchronizer.java（JDK 8）</span><br><br><span class="hljs-comment">// 入口方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        <span class="hljs-comment">// acquireQueued 返回 true 表示&quot;获取锁的过程中曾被中断过&quot;</span><br>        <span class="hljs-comment">// 此时锁已经获取成功，再补上一次 interrupt</span><br>        selfInterrupt();  <span class="hljs-comment">// → Thread.currentThread().interrupt()</span><br>&#125;<br><br><span class="hljs-comment">// 核心排队方法</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;  <span class="hljs-comment">// 记录是否曾被中断</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">predecessor</span> <span class="hljs-operator">=</span> node.predecessor();<br>        <span class="hljs-keyword">if</span> (predecessor == head &amp;&amp; tryAcquire(arg)) &#123;<br>            setHead(node);<br>            predecessor.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">return</span> interrupted;  <span class="hljs-comment">// 获取成功，返回中断记录</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(predecessor, node) &amp;&amp;<br>            parkAndCheckInterrupt())  <span class="hljs-comment">// park 并检查中断</span><br>            interrupted = <span class="hljs-literal">true</span>;       <span class="hljs-comment">// 记录中断，但不退出循环！</span><br>        <span class="hljs-comment">// 继续自旋尝试获取锁</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// park 并检查中断状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);        <span class="hljs-comment">// 阻塞，可被 unpark 或 interrupt 唤醒</span><br>    <span class="hljs-keyword">return</span> Thread.interrupted();   <span class="hljs-comment">// 检查并清除中断标志</span><br>    <span class="hljs-comment">// 注意：这里用的是 interrupted()（清除版本）</span><br>    <span class="hljs-comment">// 目的是：清除标志后继续自旋，避免 park() 立即返回</span><br>    <span class="hljs-comment">// 因为 park() 在中断标志为 true 时会立即返回（不阻塞）</span><br>&#125;<br></code></pre></td></tr></table></figure>
<pre><code class="hljs mermaid">sequenceDiagram
    participant T as 线程
    participant AQS as AQS
    participant Park as LockSupport
    participant Ext as 外部线程
    
    T-&gt;&gt;AQS: acquire(1)
    AQS-&gt;&gt;AQS: tryAcquire(1) → false
    AQS-&gt;&gt;AQS: addWaiter() 入队
    
    loop acquireQueued 自旋
        AQS-&gt;&gt;AQS: tryAcquire(1) → false
        AQS-&gt;&gt;Park: park(this)
        Note over T: 线程阻塞
        
        Ext-&gt;&gt;T: interrupt()
        Note over T: 中断标志 = true
        Park--&gt;&gt;AQS: park() 返回
        
        AQS-&gt;&gt;AQS: Thread.interrupted()
        Note over AQS: 返回 true，清除标志&lt;br/&gt;interrupted = true&lt;br/&gt;但不退出循环！
        
        AQS-&gt;&gt;AQS: tryAcquire(1) → false
        AQS-&gt;&gt;Park: park(this)
        Note over T: 标志已清除，可以再次阻塞
        
        Note over T: ... 最终获取到锁 ...
        AQS-&gt;&gt;AQS: tryAcquire(1) → true
    end
    
    AQS--&gt;&gt;T: return interrupted=true
    T-&gt;&gt;T: selfInterrupt()
    Note over T: 补上中断标志</code></pre>
<p><strong>为什么 AQS 要用 <code>Thread.interrupted()</code>（清除版本）而不是 <code>isInterrupted()</code>？</strong></p>
<p>因为 <code>LockSupport.park()</code> 有一个关键特性：<strong>如果中断标志为 <code>true</code>，<code>park()</code> 会立即返回而不阻塞</strong>。如果不清除标志，线程将陷入&quot;park → 立即返回 → 再 park → 立即返回&quot;的忙等待循环，浪费 CPU。</p>
<h4 id="aqs-的-立即中断-策略">AQS 的&quot;立即中断&quot;策略</h4>
<p>与 <code>acquire()</code> 不同，<code>acquireInterruptibly()</code> 采用<strong>立即中断</strong>策略：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 可中断版本</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <span class="hljs-comment">// 入口处就检查</span><br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg))<br>        doAcquireInterruptibly(arg);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.EXCLUSIVE);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">predecessor</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-keyword">if</span> (predecessor == head &amp;&amp; tryAcquire(arg)) &#123;<br>                setHead(node);<br>                predecessor.next = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(predecessor, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <span class="hljs-comment">// 直接抛异常！不再自旋</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        cancelAcquire(node);  <span class="hljs-comment">// 取消节点</span><br>        <span class="hljs-keyword">throw</span> t;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>两种策略的对比</strong>：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>策略</th>
<th>中断时行为</th>
<th>典型使用者</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>lock()</code> → <code>acquire()</code></td>
<td>延迟中断</td>
<td>记录中断，继续获取锁，成功后补 <code>selfInterrupt()</code></td>
<td><code>ReentrantLock.lock()</code></td>
</tr>
<tr>
<td><code>lockInterruptibly()</code> → <code>acquireInterruptibly()</code></td>
<td>立即中断</td>
<td>立即抛出 <code>InterruptedException</code>，取消排队</td>
<td><code>ReentrantLock.lockInterruptibly()</code></td>
</tr>
</tbody>
</table>
<h4 id="conditionobject-await-中的中断检查">ConditionObject.await() 中的中断检查</h4>
<p><code>Condition.await()</code> 的中断处理更加精细，它区分了&quot;在 signal 之前被中断&quot;和&quot;在 signal 之后被中断&quot;两种情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ConditionObject.await() 简化逻辑</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <span class="hljs-comment">// 入口检查</span><br>    <br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addConditionWaiter();      <span class="hljs-comment">// 加入条件队列</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> fullyRelease(node);   <span class="hljs-comment">// 完全释放锁</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">interruptMode</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;         <span class="hljs-comment">// 还没被 signal 转移到同步队列</span><br>        LockSupport.park(<span class="hljs-built_in">this</span>);<br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;                         <span class="hljs-comment">// 被中断，退出等待</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 重新获取锁（可能再次阻塞）</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <br>    <span class="hljs-comment">// 根据中断模式决定处理方式</span><br>    <span class="hljs-keyword">if</span> (interruptMode == THROW_IE)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();  <span class="hljs-comment">// signal 前被中断 → 抛异常</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interruptMode == REINTERRUPT)<br>        selfInterrupt();                   <span class="hljs-comment">// signal 后被中断 → 恢复标志</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="interrupt-与线程状态转换的关系">interrupt 与线程状态转换的关系</h3>
<p>interrupt 可以触发多种线程状态转换，但其影响取决于线程当前所处的状态。完整的线程状态转换图见前文<a href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%A8%E6%99%AF%E5%9B%BE">线程状态转换全景图</a>，此处重点分析 interrupt 对各状态的影响：</p>
<p><strong>interrupt 对不同状态线程的影响</strong>：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs isbl">┌─────────────────────────────────────────────────────────────────────┐<br>│                    <span class="hljs-function"><span class="hljs-title">interrupt</span>() 对不同状态的影响                       │</span><br><span class="hljs-function">├─────────────────────────────────────────────────────────────────────┤</span><br><span class="hljs-function">│  当前状态         │ <span class="hljs-title">interrupt</span>() 行为        │ 状态变化               │</span><br><span class="hljs-function">├───────────────────┼─────────────────────────┼───────────────────────┤</span><br><span class="hljs-function">│  <span class="hljs-variable">RUNNABLE</span>         │ 仅设置标志位            │ <span class="hljs-variable">RUNNABLE</span> → <span class="hljs-variable">RUNNABLE</span>   │</span><br><span class="hljs-function">│  <span class="hljs-variable">BLOCKED</span>          │ 仅设置标志位，无法唤醒   │ <span class="hljs-variable">BLOCKED</span> → <span class="hljs-variable">BLOCKED</span>     │</span><br><span class="hljs-function">│                   │ （必须等获取锁后检查）   │                       │</span><br><span class="hljs-function">│  <span class="hljs-title">WAITING</span>(<span class="hljs-variable">park</span>)    │ <span class="hljs-title">park</span>()返回，保留标志    │ <span class="hljs-variable">WAITING</span> → <span class="hljs-variable">RUNNABLE</span>    │</span><br><span class="hljs-function">│  <span class="hljs-title">WAITING</span>(<span class="hljs-variable">wait</span>)    │ 抛<span class="hljs-variable">IE</span>，清除标志          │ <span class="hljs-variable">WAITING</span> → <span class="hljs-variable">RUNNABLE</span>    │</span><br><span class="hljs-function">│  <span class="hljs-variable">TIMED_WAITING</span>    │ 抛<span class="hljs-variable">IE</span>或返回，取决于方法   │ <span class="hljs-variable">TIMED_WAITING</span> →       │</span><br><span class="hljs-function">│                   │                         │ <span class="hljs-variable">RUNNABLE</span>/<span class="hljs-variable">BLOCKED</span>      │</span><br><span class="hljs-function">└───────────────────┴─────────────────────────┴───────────────────────┘</span><br></code></pre></td></tr></table></figure>
<p><strong>关键区别：<code>synchronized</code> vs <code>ReentrantLock</code> 对中断的响应</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// synchronized：等待锁时无法响应中断</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>    <span class="hljs-comment">// 如果另一个线程持有 lock，当前线程进入 BLOCKED 状态</span><br>    <span class="hljs-comment">// 此时 interrupt() 只设置标志位，不能唤醒线程</span><br>    <span class="hljs-comment">// 必须等到获取锁后才能检查中断</span><br>&#125;<br><br><span class="hljs-comment">// ReentrantLock.lockInterruptibly()：等待锁时可以响应中断</span><br><span class="hljs-keyword">try</span> &#123;<br>    reentrantLock.lockInterruptibly();<br>    <span class="hljs-comment">// 如果等待过程中被 interrupt，立即抛出 InterruptedException</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-comment">// 可以立即响应中断，不必等到获取锁</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>这也是为什么在需要可中断的锁获取场景中，<code>ReentrantLock</code> 优于 <code>synchronized</code> 的原因之一。</p>
<h3 id="thread-interrupt-的五大设计缺陷">Thread.interrupt 的五大设计缺陷</h3>
<p>理解了 interrupt 的底层机制后，我们可以系统地分析它的设计缺陷。这些缺陷在简单场景中不明显，但在复杂的生产环境中会导致严重问题。</p>
<p><strong>五大缺陷概览</strong>：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs gradle">┌─────────────────────────────────────────────────────────────────────┐<br>│                  Thread.interrupt 五大设计缺陷                       │<br>├─────────────────────────────────────────────────────────────────────┤<br>│                                                                     │<br>│  缺陷一：中断粒度错误                                                │<br>│  ├── 问题：中断的是线程，而非任务                                    │<br>│  └── 后果：线程池中 interrupt 可能误伤正在执行的其他任务              │<br>│                                                                     │<br>│  缺陷二：中断标志易被吞掉                                            │<br>│  ├── 问题：第三方库捕获 IE 后不恢复中断标志                          │<br>│  └── 后果：上层调用者永远无法感知中断                                │<br>│                                                                     │<br>│  缺陷三：中断标志泄露                                                │<br>│  ├── 问题：子任务调用 Thread.interrupted() 清除了父任务的标志        │<br>│  └── 后果：父任务的中断信号被<span class="hljs-string">&quot;消费&quot;</span>，无法正确响应                    │<br>│                                                                     │<br>│  缺陷四：嵌套任务混乱                                                │<br>│  ├── 问题：无法区分中断来源（用户取消<span class="hljs-regexp">/超时/</span>线程池关闭）              │<br>│  └── 后果：不同来源需要不同处理，但中断机制无法区分                  │<br>│                                                                     │<br>│  缺陷五：行为不一致                                                  │<br>│  ├── 问题：wait<span class="hljs-regexp">/sleep/</span><span class="hljs-keyword">join</span> 抛异常清标志，park 静默保留               │<br>│  └── 后果：开发者需记住每种方法行为，是 bug 的温床                   │<br>│                                                                     │<br>│  根本原因：隐式全局状态（线程级标志）vs 显式任务状态                  │<br>└─────────────────────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<h4 id="缺陷一：中断的是线程-而非任务">缺陷一：中断的是线程，而非任务</h4>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs 1c">业务语义：我要取消<span class="hljs-string">&quot;下载文件这个任务&quot;</span><br>实现机制：我中断<span class="hljs-string">&quot;执行下载的线程&quot;</span><br><br>问题：一个线程可能同时执行多个任务！<br></code></pre></td></tr></table></figure>
<p>在线程池场景中，一个 Worker 线程会顺序执行多个任务。<code>Future.cancel(true)</code> 的实现是调用 <code>Thread.interrupt()</code>，但这个中断信号是发给线程的，不是发给任务的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>); <span class="hljs-comment">// 只有一个线程</span><br><br>Future&lt;?&gt; future1 = executor.submit(() -&gt; downloadFile(<span class="hljs-string">&quot;大文件.zip&quot;</span>));<br>Future&lt;?&gt; future2 = executor.submit(() -&gt; processData());<br><br><span class="hljs-comment">// 取消第一个任务</span><br>future1.cancel(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 调用 Worker 线程的 interrupt()</span><br><br><span class="hljs-comment">// 问题：如果 future1 已经完成，future2 正在执行，</span><br><span class="hljs-comment">// 那么 interrupt 信号会发给正在执行 future2 的线程！</span><br></code></pre></td></tr></table></figure>
<p><code>Future.cancel(true)</code> 的 Javadoc 明确警告：</p>
<blockquote>
<p>“There are no guarantees beyond best-effort attempts to stop processing actively executing tasks.”</p>
</blockquote>
<h4 id="缺陷二：中断标志容易被-吞掉">缺陷二：中断标志容易被&quot;吞掉&quot;</h4>
<p>第三方库或子任务可能捕获 <code>InterruptedException</code> 后不恢复中断标志，导致上层调用者永远无法感知中断：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 糟糕的第三方库实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">badLibraryMethod</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        doSomething();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 捕获所有异常，包括 InterruptedException</span><br>        log.error(<span class="hljs-string">&quot;Error&quot;</span>, e);<br>        <span class="hljs-comment">// 不恢复中断状态，也不重新抛出</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// Worker 线程调用这个方法</span><br><span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;<br>    badLibraryMethod(); <span class="hljs-comment">// 如果内部吞掉了 InterruptedException，</span><br>                        <span class="hljs-comment">// 这里的 isInterrupted() 检查将失效</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="缺陷三：中断标志泄露">缺陷三：中断标志泄露</h4>
<p>这是最隐蔽的问题。当子任务操作了中断标志（特别是使用 <code>Thread.interrupted()</code> 清除了标志），父任务将无法观察到中断信号：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 父任务：Worker 的主循环</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; <span class="hljs-comment">// 检查点 A</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">Task</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> getNextTask();<br>                task.run();  <span class="hljs-comment">// 子任务可能操作中断标志！</span><br>                <span class="hljs-comment">// 检查点 B：如果子任务调用了 Thread.interrupted()，</span><br>                <span class="hljs-comment">// 这里的循环条件判断就可能出错</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 子任务：错误地使用了 Thread.interrupted()</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">DownloadTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;  <span class="hljs-comment">// 读取并清除标志！</span><br>            System.out.println(<span class="hljs-string">&quot;下载被取消&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        download();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>泄露的执行流程：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs csharp">时间线  外部线程        Worker线程         中断标志    DownloadTask<br>  │        │              │                 │            │<br>  │        │              │ ←启动           <span class="hljs-literal">false</span>        │<br>  T1       │              │                 │            │<br>  │        │              │                 │            │<br>  <span class="hljs-function">T2    <span class="hljs-title">interrupt</span>() ────→ │                 │            │</span><br><span class="hljs-function">  │        │              │    设置标志 →  <span class="hljs-literal">true</span>          │</span><br><span class="hljs-function">  │        │              │                 │            │</span><br><span class="hljs-function">  T3       │         <span class="hljs-title">isInterrupted</span>()        │            │</span><br><span class="hljs-function">  │        │         返回<span class="hljs-literal">true</span>,进入循环体     │            │</span><br><span class="hljs-function">  │        │              │                 │            │</span><br><span class="hljs-function">  T4       │              │ ──task.<span class="hljs-title">run</span>()──→ │            │</span><br><span class="hljs-function">  │        │              │                 │            │</span><br><span class="hljs-function">  T5       │              │              <span class="hljs-title">interrupted</span>()   │</span><br><span class="hljs-function">  │        │              │              返回<span class="hljs-literal">true</span> ────→ <span class="hljs-literal">false</span></span><br><span class="hljs-function">  │        │              │              (<span class="hljs-params">清除标志！</span>)    │</span><br><span class="hljs-function">  │        │              │                 │            │</span><br><span class="hljs-function">  T6       │              │ ←──返回──────── │            │</span><br><span class="hljs-function">  │        │              │                 │            │</span><br><span class="hljs-function">  T7       │         <span class="hljs-title">isInterrupted</span>()        │            │</span><br><span class="hljs-function">  │        │         返回<span class="hljs-literal">false</span>!             │            │</span><br><span class="hljs-function">  │        │         (<span class="hljs-params">本应退出，却继续!</span>)     │            │</span><br><span class="hljs-function">  ↓        │              │                 │            │</span><br><span class="hljs-function"></span><br><span class="hljs-function">问题根源：子任务调用 Thread.<span class="hljs-title">interrupted</span>() 清除了父任务的中断标志</span><br></code></pre></td></tr></table></figure>
<p><strong>泄露的本质</strong>：子任务&quot;消费&quot;了本该属于父任务的中断信号。中断信号就像一封信，被中间人拆开读了还扔掉了，真正的收件人永远收不到。</p>
<h4 id="缺陷四：嵌套任务时的混乱">缺陷四：嵌套任务时的混乱</h4>
<p>在实际应用中，任务往往是层级嵌套的：</p>
<figure class="highlight isbl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs isbl">主任务：<span class="hljs-variable">DownloadAndProcessVideo</span><br>├── 子任务 <span class="hljs-number">1</span>：<span class="hljs-variable">DownloadVideo</span><br>│   ├── 子子任务 <span class="hljs-number">1.1</span>：<span class="hljs-function"><span class="hljs-title">DownloadSegment</span>(<span class="hljs-number">0</span>)</span><br>│   ├── 子子任务 <span class="hljs-number">1.2</span>：<span class="hljs-function"><span class="hljs-title">DownloadSegment</span>(<span class="hljs-number">1</span>)</span><br>│   └── 子子任务 <span class="hljs-number">1.3</span>：<span class="hljs-function"><span class="hljs-title">DownloadSegment</span>(<span class="hljs-number">2</span>)</span><br>├── 子任务 <span class="hljs-number">2</span>：<span class="hljs-variable">ExtractAudio</span><br>└── 子任务 <span class="hljs-number">3</span>：<span class="hljs-variable">MergeFiles</span><br></code></pre></td></tr></table></figure>
<p>当用户点击&quot;取消&quot;时，中断信号应该如何传播？使用 <code>Thread.interrupt()</code> 面临多重困境：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">downloadAndProcess</span><span class="hljs-params">(String videoId)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">video</span> <span class="hljs-operator">=</span> downloadVideo(videoId);  <span class="hljs-comment">// 可能调用 interruptible 方法</span><br>        <span class="hljs-type">File</span> <span class="hljs-variable">audio</span> <span class="hljs-operator">=</span> extractAudio(video);<br>        merge(video, audio);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-comment">// 这个中断是谁发的？</span><br>        <span class="hljs-comment">// A) 用户取消了整个 downloadAndProcess？</span><br>        <span class="hljs-comment">// B) downloadVideo 内部某个子操作超时？</span><br>        <span class="hljs-comment">// C) 线程池在 shutdown？</span><br>        <span class="hljs-comment">// 不同的来源，应该有不同的处理方式！</span><br>        cleanup();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="缺陷五：行为不一致增加心智负担">缺陷五：行为不一致增加心智负担</h4>
<p>前文已经详细分析了不同阻塞方法对 interrupt 的响应差异。总结来说：</p>
<ul>
<li><code>wait()</code>/<code>sleep()</code>/<code>join()</code>：抛异常 + 清除标志</li>
<li><code>LockSupport.park()</code>：静默返回 + 保留标志</li>
<li><code>synchronized</code> 等待：完全忽略</li>
<li>NIO Channel：抛异常 + 关闭 Channel</li>
</ul>
<p>开发者需要记住每种方法的行为，并在每个 catch 块中做出正确的处理决策。这种不一致性是 bug 的温床。</p>
<h3 id="替代方案：任务级取消机制">替代方案：任务级取消机制</h3>
<p>interrupt 的核心问题在于：<strong>取消的粒度是线程，而非任务</strong>。现代并发编程的趋势是将取消机制从线程级提升到任务级。</p>
<h4 id="abortcontroller-模式">AbortController 模式</h4>
<p>借鉴 Web 标准的 <code>AbortController</code>，可以为每个任务创建独立的取消控制器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 任务级取消控制器</span><br><span class="hljs-comment"> * 核心优势：每个任务有独立的取消状态，不共享线程级全局标志</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbortController</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">aborted</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Runnable&gt; listeners = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CopyOnWriteArrayList</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AbortController parent;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortController</span><span class="hljs-params">()</span> &#123; <span class="hljs-built_in">this</span>(<span class="hljs-literal">null</span>); &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">AbortController</span><span class="hljs-params">(AbortController parent)</span> &#123;<br>        <span class="hljs-built_in">this</span>.parent = parent;<br>        <span class="hljs-keyword">if</span> (parent != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (parent.isAborted()) &#123;<br>                abort(); <span class="hljs-comment">// 父已取消，子立即取消</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                parent.onAbort(<span class="hljs-built_in">this</span>::abort); <span class="hljs-comment">// 监听父取消事件</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/** 触发取消（幂等） */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">abort</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (aborted.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>            <span class="hljs-keyword">for</span> (Runnable listener : listeners) &#123;<br>                <span class="hljs-keyword">try</span> &#123; listener.run(); &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;&#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/** 查询状态——不会清除！这是与 Thread.interrupted() 的关键区别 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isAborted</span><span class="hljs-params">()</span> &#123; <span class="hljs-keyword">return</span> aborted.get(); &#125;<br><br>    <span class="hljs-comment">/** 注册取消回调 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onAbort</span><span class="hljs-params">(Runnable listener)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isAborted()) &#123; listener.run(); &#125;<br>        <span class="hljs-keyword">else</span> &#123; listeners.add(listener); &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/** 检查并抛出 */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">throwIfAborted</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isAborted()) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CancellationException</span>(<span class="hljs-string">&quot;Operation aborted&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>与 <code>Thread.interrupt</code> 的对比</strong>：</p>
<table>
<thead>
<tr>
<th>维度</th>
<th><code>Thread.interrupt</code></th>
<th><code>AbortController</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>取消对象</strong></td>
<td>线程（Thread）</td>
<td>任务（Task/Operation）</td>
</tr>
<tr>
<td><strong>状态存储</strong></td>
<td>线程对象的内部字段</td>
<td>独立的控制器对象</td>
</tr>
<tr>
<td><strong>作用范围</strong></td>
<td>整个线程生命周期</td>
<td>可控的代码块范围</td>
</tr>
<tr>
<td><strong>层级关系</strong></td>
<td>扁平（一个线程一个标志）</td>
<td>树形（父子控制器可关联）</td>
</tr>
<tr>
<td><strong>清除行为</strong></td>
<td><code>interrupted()</code> 会自动清除</td>
<td>持久状态，不会被清除</td>
</tr>
<tr>
<td><strong>隔离性</strong></td>
<td>无（共享线程标志）</td>
<td>有（每个任务独立控制器）</td>
</tr>
</tbody>
</table>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp">AbortController 的隔离机制：<br><br>┌─────────────────────────────────────────┐<br>│  Worker Thread                          │<br>│  ├─ AbortController workerCtrl          │<br>│  │   └─ isAborted() = <span class="hljs-literal">false</span>             │<br>│  │                                      │<br>│  │   ├─ <span class="hljs-function">Task <span class="hljs-title">A</span> (<span class="hljs-params">独立上下文</span>)              │</span><br><span class="hljs-function">│  │   │   ├─ AbortController ctrlA       │</span><br><span class="hljs-function">│  │   │   │   └─ <span class="hljs-title">isAborted</span>()</span> = <span class="hljs-literal">false</span>     │<br>│  │   │   └─ 只能看到 ctrlA 的状态       │<br>│  │   │                                  │<br>│  │   └─ <span class="hljs-function">Task <span class="hljs-title">B</span> (<span class="hljs-params">独立上下文</span>)              │</span><br><span class="hljs-function">│  │       ├─ AbortController ctrlB       │</span><br><span class="hljs-function">│  │       │   └─ <span class="hljs-title">isAborted</span>()</span> = <span class="hljs-literal">true</span>      │<br>│  │       └─ 只能看到 ctrlB 的状态       │<br>│  │                                      │<br>│  │   workerCtrl、ctrlA、ctrlB 完全独立  │<br>│  └─ 不会互相干扰                        │<br>└─────────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<h4 id="结构化并发-java-19">结构化并发（Java 19+）</h4>
<p>Java 从 JDK 19 开始引入结构化并发（<code>StructuredTaskScope</code>），将取消与代码作用域绑定，从语言层面解决了 interrupt 的设计缺陷：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Java 21+ 结构化并发：取消与作用域绑定，自动传播</span><br><span class="hljs-keyword">try</span> (<span class="hljs-type">var</span> <span class="hljs-variable">scope</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StructuredTaskScope</span>.ShutdownOnFailure()) &#123;<br>    Subtask&lt;String&gt; download = scope.fork(() -&gt; downloadFile());<br>    Subtask&lt;String&gt; process  = scope.fork(() -&gt; processData());<br><br>    scope.join();           <span class="hljs-comment">// 等待所有子任务</span><br>    scope.throwIfFailed();  <span class="hljs-comment">// 任一失败则取消其他</span><br><br>    <span class="hljs-comment">// 自动取消未完成的子任务，自动等待清理</span><br>&#125;<br><span class="hljs-comment">// 作用域结束，所有子任务保证已终止</span><br></code></pre></td></tr></table></figure>
<h4 id="kotlin-协程的取消">Kotlin 协程的取消</h4>
<p>Kotlin 协程提供了更优雅的取消机制，每个协程有自己的 <code>isActive</code> 状态：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">suspend</span> <span class="hljs-function"><span class="hljs-keyword">fun</span> <span class="hljs-title">downloadData</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">val</span> job = launch &#123;<br>        <span class="hljs-keyword">while</span> (isActive) &#123;  <span class="hljs-comment">// 类似 AbortController.isAborted()</span><br>            doWork()<br>        &#125;<br>    &#125;<br>    delay(<span class="hljs-number">1000</span>)<br>    job.cancel()  <span class="hljs-comment">// 发送取消信号，不会中断线程</span><br>    job.join()    <span class="hljs-comment">// 等待协程完成清理</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="interrupt-最佳实践">interrupt 最佳实践</h3>
<p>尽管 interrupt 有设计缺陷，但它仍然是当前 Java 生态的底层基础设施。以下是在不同场景下的最佳实践：</p>
<h4 id="规则一：永远不要吞掉-interruptedexception">规则一：永远不要吞掉 InterruptedException</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [错误]：空 catch 块</span><br><span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123; <span class="hljs-comment">/* 中断信号永久丢失 */</span> &#125;<br><br><span class="hljs-comment">// [正确]：恢复中断状态</span><br><span class="hljs-keyword">try</span> &#123; Thread.sleep(<span class="hljs-number">1000</span>); &#125;<br><span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    Thread.currentThread().interrupt();<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Task interrupted&quot;</span>, e);<br>&#125;<br><br><span class="hljs-comment">// [正确]：直接传播</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doWork</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>    Thread.sleep(<span class="hljs-number">1000</span>); <span class="hljs-comment">// 让调用者决定如何处理</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="规则二：优先使用-isinterrupted-而非-interrupted">规则二：优先使用 <code>isInterrupted()</code> 而非 <code>interrupted()</code></h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// [危险]：每次循环都清除标志</span><br><span class="hljs-keyword">while</span> (!Thread.interrupted()) &#123; doWork(); &#125;<br><br><span class="hljs-comment">// [安全]：只查询不清除</span><br><span class="hljs-keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123; doWork(); &#125;<br></code></pre></td></tr></table></figure>
<h4 id="规则三：区分-取消-和-中断">规则三：区分&quot;取消&quot;和&quot;中断&quot;</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 推荐：使用显式的取消标志，interrupt 仅作为唤醒机制</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CancellableTask</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cancel</span><span class="hljs-params">()</span> &#123;<br>        cancelled = <span class="hljs-literal">true</span>;<br>        workerThread.interrupt(); <span class="hljs-comment">// 仅用于唤醒阻塞</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (!cancelled) &#123;  <span class="hljs-comment">// 主要检查取消标志</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                doWork();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                Thread.currentThread().interrupt();<br>                <span class="hljs-comment">// interrupt 仅作为唤醒机制，继续循环检查 cancelled</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="决策树">决策树</h4>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">需要取消功能？<br>├── 简单场景（单次任务、无嵌套）<br>│   ├── 使用标准 Future / CompletableFuture<br>│   └── 遵循 <span class="hljs-built_in">int</span>errupt 最佳实践<br>│<br>├── 复杂场景（嵌套任务、需要级联取消）<br>│   ├── 能使用结构化并发（Java <span class="hljs-number">21</span>+）？<br>│   │   └── 使用 StructuredTaskScope<br>│   ├── 能使用响应式编程？<br>│   │   └── 使用 Project Reactor / RxJava<br>│   └── 否则<br>│       └── 自定义 AbortController 机制<br>│<br>└── 遗留系统维护<br>    └── 严格遵循 <span class="hljs-built_in">int</span>errupt 规则，逐步重构<br></code></pre></td></tr></table></figure>
<h3 id="线程池中的强制中断与拒绝机制">线程池中的强制中断与拒绝机制</h3>
<p>理解了 Thread.interrupt 的底层机制和最佳实践后，我们来看看在线程池这一典型应用场景中，interrupt 与拒绝策略是如何协同工作的。</p>
<h4 id="强制触发的完整场景分类">强制触发的完整场景分类</h4>
<p>在线程池中，存在多种会强制触发线程中断或拒绝新任务的场景。这些场景可以分为&quot;主动触发&quot;和&quot;系统被动触发&quot;两类：</p>
<p><strong>主动触发（用户代码显式调用）</strong>：</p>
<table>
<thead>
<tr>
<th>触发方式</th>
<th>作用范围</th>
<th>中断对象</th>
<th>典型应用</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>shutdownNow()</strong></td>
<td>整个线程池</td>
<td>所有工作线程</td>
<td>快速停止线程池</td>
</tr>
<tr>
<td><strong>Future.cancel(true)</strong></td>
<td>单个任务</td>
<td>指定任务的执行线程</td>
<td>取消异步任务</td>
</tr>
</tbody>
</table>
<p><strong>系统被动触发（内部机制自动触发）</strong>：</p>
<table>
<thead>
<tr>
<th>触发场景</th>
<th>触发条件</th>
<th>响应方式</th>
<th>影响范围</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>线程池饱和</strong></td>
<td>队列满 + 线程数达 maximumPoolSize</td>
<td>触发 RejectedExecutionHandler</td>
<td>当前被拒绝的任务</td>
</tr>
<tr>
<td><strong>awaitTermination 超时</strong></td>
<td>shutdown 后等待超时</td>
<td>强制关闭</td>
<td>等待线程</td>
</tr>
<tr>
<td><strong>ScheduledFutureTask 异常</strong></td>
<td>周期任务未捕获异常</td>
<td>终止任务调度</td>
<td>当前周期任务</td>
</tr>
<tr>
<td><strong>tryTerminate 自旋中断</strong></td>
<td>线程池终止过程中</td>
<td>中断空闲 Worker</td>
<td>空闲工作线程</td>
</tr>
</tbody>
</table>
<h4 id="shutdownnow-的中断流程">shutdownNow() 的中断流程</h4>
<p>当调用 shutdownNow() 时，线程池会遍历所有 Worker 线程并调用 interrupt()。关键点：</p>
<ul>
<li>shutdownNow() 对所有线程调用 interrupt()，但中断是否生效取决于任务代码如何响应</li>
<li>如果任务在 wait()/sleep() 中，会抛出 InterruptedException</li>
<li>如果任务在 synchronized 等待锁，必须等到获取锁后才能检查中断</li>
<li>如果任务在 LockSupport.park()，会立即返回</li>
</ul>
<h4 id="future-cancel-true-的中断流程">Future.cancel(true) 的中断流程</h4>
<p>Future.cancel(true) 的实现是调用执行该任务的线程的 interrupt()。重要警告：在线程池场景中，cancel(true) 存在&quot;误伤&quot;风险——如果任务已完成，线程可能正在执行下一个任务，interrupt() 信号会发给正在执行其他任务的线程。这就是&quot;中断粒度错误&quot;缺陷在线程池中的具体体现。</p>
<h4 id="拒绝策略的触发时机与选择">拒绝策略的触发时机与选择</h4>
<p>根据 ThreadPoolExecutor.execute() 的源码，当队列满且线程数达最大值时，会触发拒绝策略。</p>
<p><strong>四种内置拒绝策略对比</strong>：</p>
<table>
<thead>
<tr>
<th>策略</th>
<th>行为</th>
<th>适用场景</th>
<th>风险</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>AbortPolicy</strong></td>
<td>抛出 RejectedExecutionException</td>
<td>快速失败</td>
<td>任务丢失</td>
</tr>
<tr>
<td><strong>CallerRunsPolicy</strong></td>
<td>由调用者线程执行</td>
<td>削峰填谷</td>
<td>调用者线程阻塞</td>
</tr>
<tr>
<td><strong>DiscardPolicy</strong></td>
<td>静默丢弃任务</td>
<td>无感知丢弃</td>
<td>无反馈</td>
</tr>
<tr>
<td><strong>DiscardOldestPolicy</strong></td>
<td>丢弃队列中最老任务</td>
<td>优先级场景</td>
<td>重要任务可能丢失</td>
</tr>
</tbody>
</table>
<h4 id="周期任务异常导致的静默停止">周期任务异常导致的静默停止</h4>
<p>这是最常见的生产环境陷阱之一。如果周期任务抛出未捕获异常，会导致后续调度终止。</p>
<p><strong>必须遵循的铁律</strong>：周期任务必须捕获所有异常：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">scheduler.scheduleAtFixedRate(() -&gt; &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        riskyOperation();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        logger.error(<span class="hljs-string">&quot;Scheduled task failed, but will continue&quot;</span>, t);<br>    &#125;<br>&#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure>
<h4 id="与-interrupt-机制的关联">与 interrupt 机制的关联</h4>
<p>线程池中的强制中断与拒绝机制，本质上是对 Thread.interrupt 的上层封装：</p>
<ul>
<li>拒绝策略处理的是&quot;提交阶段&quot;的过载</li>
<li>中断机制处理的是&quot;执行阶段&quot;的取消</li>
<li>两者共同构成线程池的流量控制和生命周期管理</li>
</ul>
<h4 id="最佳实践总结">最佳实践总结</h4>
<ol>
<li>不要依赖强制中断来停止任务，任务应该支持检查中断标志并优雅退出</li>
<li>优先使用 cancel(false)，让正在执行的任务自然完成</li>
<li>合理选择拒绝策略，根据业务对任务丢失的容忍度选择</li>
<li>始终为周期任务捕获异常，避免任务静默停止</li>
</ol>
<p>这些实践与前面 interrupt 最佳实践章节的原则一致，体现了从底层机制到上层应用的一致性设计思想。</p>
<h3 id="interrupt-的历史演进">interrupt 的历史演进</h3>
<pre><code class="hljs mermaid">timeline
    title Java 线程取消机制的演进
    section Java 1.0 (1995)
        Thread.stop() : 强制终止（不安全）
        Thread.suspend/resume : 强制挂起/恢复（易死锁）
    section Java 1.2 (1998)
        Thread.interrupt() : 协作式中断
        stop/suspend 被废弃 : 标记为 @Deprecated
    section Java 5 (2004)
        Future.cancel(true) : 封装 interrupt
        ExecutorService : 线程池标准化
    section Java 7 (2011)
        ForkJoinPool : 工作窃取 + 取消传播
    section Java 8 (2014)
        CompletableFuture : 异步编排 + cancel
    section Java 9 (2017)
        Flow API : 响应式流 + Subscription.cancel()
    section Java 19-21 (2022-2023)
        StructuredTaskScope : 结构化取消
        Virtual Threads : 虚拟线程（每任务一线程，减少复用问题）</code></pre>
<p><strong>核心教训</strong>：</p>
<ol>
<li><strong>隐式状态是万恶之源</strong>：<code>Thread.interrupt</code> 的隐式全局状态导致了所有混乱。</li>
<li><strong>显式优于隐式</strong>：<code>AbortController</code> 的显式对象更易理解、测试、组合。</li>
<li><strong>组合性是关键</strong>：好的取消机制应该能优雅地组合（父子、并行、超时等）。</li>
<li><strong>资源安全优先</strong>：取消的最终目的是安全释放资源，不是立即停止线程。</li>
</ol>
<p><strong>[PATTERN] 中断机制的模式速查表</strong>：</p>
<table>
<thead>
<tr>
<th>遇到的问题</th>
<th>应用的模式</th>
<th>具体方案</th>
<th>关键注意点</th>
</tr>
</thead>
<tbody>
<tr>
<td>需要取消阻塞中的线程</td>
<td>协作式中断</td>
<td><code>interrupt()</code> + 正确的异常处理</td>
<td>永远不要吞掉 <code>InterruptedException</code></td>
</tr>
<tr>
<td>需要可中断的锁获取</td>
<td>AQS 立即中断</td>
<td><code>lockInterruptibly()</code></td>
<td>优于 <code>synchronized</code> 的中断响应</td>
</tr>
<tr>
<td>子任务可能吞掉中断</td>
<td>显式取消标志</td>
<td><code>volatile boolean cancelled</code> + <code>interrupt</code> 仅唤醒</td>
<td>取消标志是主信号，interrupt 是辅助唤醒</td>
</tr>
<tr>
<td>嵌套任务的级联取消</td>
<td>取消树</td>
<td><code>AbortController</code> 父子关联</td>
<td>每个任务独立控制器，自动级联</td>
</tr>
<tr>
<td>线程池中的任务取消</td>
<td>结构化并发</td>
<td><code>StructuredTaskScope</code>（Java 21+）</td>
<td>取消与作用域绑定，自动传播</td>
</tr>
</tbody>
</table>
<h2 id="特别的切换方法">特别的切换方法</h2>
<h3 id="locksupport-park">LockSupport.park</h3>
<p>也就是线程挂起。</p>
<p>condition 的 await 底层调用的是 LockSupport.park。这个方法的参数是一个用作 monitor 的对象，会被设置到 Object 的特定 Offset 上。</p>
<p>park 只能带来 waiting。所以 sync 和 conditionObject 其实都让 thread waiting ，只不过代表 thread 的 node 处在的队列不一样而已-线程 node 在 sync queue 和 condition queue 都是 waiting。</p>
<h4 id="juc-的统一阻塞原语">JUC 的统一阻塞原语</h4>
<p><code>LockSupport.park()/unpark()</code> 是 JUC 中绑大多数阻塞/唤醒机制的底层基础。与传统的 <code>Object.wait()/notify()</code> 相比，它有两个关键优势：</p>
<ol>
<li><strong>不需要持有监视器锁</strong>：<code>wait()</code> 必须在 <code>synchronized</code> 块内调用，而 <code>park()</code> 可以在任意位置调用</li>
<li><strong>unpark 可以先于 park 调用</strong>：如果先调用 <code>unpark(thread)</code>，后续该线程调用 <code>park()</code> 会立即返回（permit 机制）</li>
</ol>
<p><strong>JUC 中的两种使用模式</strong>：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>代表组件</th>
<th>调用路径</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>直接使用</strong></td>
<td><code>FutureTask.awaitDone()</code></td>
<td><code>LockSupport.park(this)</code> → <code>finishCompletion()</code> 中 <code>LockSupport.unpark(t)</code></td>
</tr>
<tr>
<td><strong>通过 AQS 间接使用</strong></td>
<td><code>ReentrantLock</code>、<code>Semaphore</code>、<code>CountDownLatch</code></td>
<td><code>AQS.parkAndCheckInterrupt()</code> → <code>AQS.unparkSuccessor()</code></td>
</tr>
</tbody>
</table>
<p><strong>设计约束</strong>：每个 <code>park()</code> 点都必须有对应的 <code>unpark()</code> 路径，否则线程会永久阻塞。这就是为什么 <code>FutureTask</code> 需要维护 <code>waiters</code> 链表（Treiber Stack）——记录所有等待线程的引用，确保 <code>finishCompletion()</code> 能遍历并 <code>unpark()</code> 每一个。</p>
<p><strong>例外情况</strong>：</p>
<ul>
<li><code>BlockingQueue</code> 实现（<code>ArrayBlockingQueue</code>、<code>LinkedBlockingQueue</code>）使用 <code>Condition.await()/signal()</code>，底层仍是 park/unpark</li>
<li><code>Thread.sleep()</code> 不使用 park，是独立的 native 实现</li>
<li><code>synchronized</code> 块的阻塞由 JVM 监视器实现，通过 Parker 最终调用 OS 原语（详见<a href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/#%E6%A0%B8%E5%BF%83%E9%97%AE%E9%A2%98%EF%BC%9AObjectMonitor-%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E%E5%92%8C%E5%94%A4%E9%86%92%E7%9A%84%EF%BC%9F">《线程安全与锁优化》</a>）</li>
</ul>
<h3 id="wait">wait</h3>
<p>这个方法是对 object 用的。</p>
<p>从 wait 中醒来会有伪唤醒的 case，所以醒来的时候一定要先检查唤醒条件是否已经得到满足。原理见<a href="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">《为什么条件锁会产生虚假唤醒现象（spurious wakeup）？》</a></p>
<h3 id="join">join</h3>
<p><strong>Thread.join() 执行流程</strong></p>
<pre><code class="hljs mermaid">sequenceDiagram
    participant th1 as 调用线程 (th1)
    participant th2 as 目标线程对象 (th2)
    participant JVM as JVM 运行时
    
    Note over th1,JVM: th1 调用 th2.join()
    
    th1-&gt;&gt;th2: synchronized(th2) 获取 Monitor 锁
    
    loop while (th2.isAlive())
        th1-&gt;&gt;th2: 检查 th2.isAlive()
        th2--&gt;&gt;th1: true（仍在运行）
        th1-&gt;&gt;th2: th2.wait(0) 释放锁，th1 进入 WAITING
        Note over th1: th1 挂起，释放 th2 的 Monitor 锁
        
        Note over th2: th2 继续执行任务...
    end
    
    th2-&gt;&gt;JVM: th2.run() 执行完毕
    JVM-&gt;&gt;th2: 线程终止，自动调用 th2.notifyAll()
    th2--&gt;&gt;th1: 唤醒 th1
    
    th1-&gt;&gt;th2: 重新获取 th2 的 Monitor 锁
    th1-&gt;&gt;th2: 检查 th2.isAlive()
    th2--&gt;&gt;th1: false（已终止）
    
    Note over th1: 退出 while 循环，join() 返回
    th1-&gt;&gt;th1: 继续执行后续代码</code></pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待此线程终止，最多等待 millis 毫秒。超时值为 0 表示永久等待。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 设计巧妙之处（三个关键角色的分离）：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 当 th1 调用 th2.join() 时：</span><br><span class="hljs-comment"> * 1. 锁对象：th2（Thread 对象）</span><br><span class="hljs-comment"> * 2. 检查对象：th2（通过 isAlive() 检查）</span><br><span class="hljs-comment"> * 3. 等待线程：th1（调用 wait() 的线程）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 执行流程：</span><br><span class="hljs-comment"> * - th1 获取 th2 对象的 Monitor 锁</span><br><span class="hljs-comment"> * - th1 检查 th2.isAlive()</span><br><span class="hljs-comment"> * - th1 在 th2 对象上调用 wait()，释放锁并挂起</span><br><span class="hljs-comment"> * - th2 执行完毕时，JVM 自动调用 th2.notifyAll()</span><br><span class="hljs-comment"> * - th1 被唤醒，重新检查 th2.isAlive()（协作式逻辑）</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 线程间接力式等待的本质：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * join() 可以理解为：在目标线程对象上，在一个 isAlive 循环里封装了一段接力式的 wait()。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 所谓&quot;接力式&quot;，指的是：</span><br><span class="hljs-comment"> * 1. 调用线程（th1）持有目标线程对象（th2）的锁</span><br><span class="hljs-comment"> * 2. 在 while 循环中不断检查 th2.isAlive()</span><br><span class="hljs-comment"> * 3. 如果还活着，就调用 th2.wait() 释放锁并挂起</span><br><span class="hljs-comment"> * 4. 被唤醒后，重新抢回锁，再次检查 isAlive()</span><br><span class="hljs-comment"> * 5. 重复这个过程，直到 th2 死亡</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 这是一种典型的&quot;协作式等待&quot;模式，而非&quot;抢占式等待&quot;。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 为什么 join() 里的 wait() 不会抛 IllegalMonitorStateException？</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 核心原因：join() 方法本身就是 synchronized 的！</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * public final synchronized void join(long millis) &#123; ... &#125;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * synchronized 修饰实例方法时：</span><br><span class="hljs-comment"> * - 锁对象 = this（即目标线程对象 th2）</span><br><span class="hljs-comment"> * - 调用 join() 的线程（th1）会先获取 th2 的锁</span><br><span class="hljs-comment"> * - 然后在持有锁的状态下调用 wait()，完全合法</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 对比普通代码：</span><br><span class="hljs-comment"> * // 错误示例：会抛 IllegalMonitorStateException</span><br><span class="hljs-comment"> * Thread t = new Thread(...);</span><br><span class="hljs-comment"> * t.start();</span><br><span class="hljs-comment"> * t.wait();  // ❌ 没有持有 t 的锁</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * // 正确示例：</span><br><span class="hljs-comment"> * Thread t = new Thread(...);</span><br><span class="hljs-comment"> * t.start();</span><br><span class="hljs-comment"> * synchronized(t) &#123;</span><br><span class="hljs-comment"> *     t.wait();  // ✅ 持有 t 的锁</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * // join() 的等价写法：</span><br><span class="hljs-comment"> * Thread t = new Thread(...);</span><br><span class="hljs-comment"> * t.start();</span><br><span class="hljs-comment"> * t.join();  // ✅ join() 内部已经是 synchronized 的</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * Thread 对象的特殊性：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 1. 普通对象（Object、String 等）：</span><br><span class="hljs-comment"> *    - 没有内置状态可以自动触发 notify()</span><br><span class="hljs-comment"> *    - wait/notify 完全由程序员手动控制</span><br><span class="hljs-comment"> *    - 适合作为条件变量</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 2. Thread 对象（特殊对象）：</span><br><span class="hljs-comment"> *    - 有内置状态：线程生命周期（NEW → RUNNABLE → TERMINATED）</span><br><span class="hljs-comment"> *    - 状态变化触发通知：线程终止时，JVM 自动调用 notifyAll()</span><br><span class="hljs-comment"> *    - 不适合作为条件变量：会出现程序设计之外的 notifyAll()</span><br><span class="hljs-comment"> *    - Javadoc 警告：&quot;不建议在 Thread 实例上使用 wait/notify/notifyAll&quot;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 为什么 JVM 要自动 notifyAll()？</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * - 设计目的：专门为 join() 而设计</span><br><span class="hljs-comment"> * - 常见需求：等待线程结束是非常常见的并发模式</span><br><span class="hljs-comment"> * - 简化编程：无需手动管理通知逻辑</span><br><span class="hljs-comment"> * - 设计哲学：Thread 对象代表执行流，生命周期结束是重要事件</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * 协作式编程体现：</span><br><span class="hljs-comment"> * ============================================================</span><br><span class="hljs-comment"> * - OS 调度（抢占式）：JVM/OS 决定何时给 th1 CPU 时间片</span><br><span class="hljs-comment"> * - 业务逻辑（协作式）：th1 主动检查 isAlive()，决定是否继续等待</span><br><span class="hljs-comment"> * - while 循环的意义：不是&quot;被唤醒就执行&quot;，而是&quot;醒来后检查条件&quot;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span>  millis 等待的毫秒数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalArgumentException 如果 millis 为负数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> InterruptedException 如果当前线程被中断</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">join</span><span class="hljs-params">(<span class="hljs-type">long</span> millis)</span><br>    <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 记录开始时间，用于计算已等待时长</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (millis &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;timeout value is negative&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 无超时版本：永久等待直到线程结束</span><br>        <span class="hljs-keyword">if</span> (millis == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 协作式编程的核心：while 循环主动检查条件</span><br>            <span class="hljs-comment">// - isAlive() 检查的是 this（th2）的状态</span><br>            <span class="hljs-comment">// - wait(0) 挂起的是调用线程（th1）</span><br>            <span class="hljs-comment">// - 使用 while 而非 if，防止伪唤醒（spurious wakeup）</span><br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-comment">// 调用线程（th1）在 this（th2）对象上等待</span><br>                <span class="hljs-comment">// 等价于：th2.wait(0)</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 释放 th2 对象的 Monitor 锁，th1 进入 WAITING 状态</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 可能的唤醒原因：</span><br>                <span class="hljs-comment">// 1. th2 结束，JVM 自动调用 th2.notifyAll()（Thread 对象的特殊性）</span><br>                <span class="hljs-comment">// 2. 伪唤醒（spurious wakeup）</span><br>                wait(<span class="hljs-number">0</span>);<br>                <br>                <span class="hljs-comment">// 被唤醒后，重新检查 isAlive()（协作式逻辑）</span><br>                <span class="hljs-comment">// 如果是伪唤醒且 th2 还活着，继续 wait</span><br>                <span class="hljs-comment">// 如果 th2 已死，退出循环</span><br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 带超时版本：等待指定时间或线程结束</span><br>            <span class="hljs-keyword">while</span> (isAlive()) &#123;<br>                <span class="hljs-comment">// 计算剩余等待时间</span><br>                <span class="hljs-type">long</span> <span class="hljs-variable">delay</span> <span class="hljs-operator">=</span> millis - now;<br>                <br>                <span class="hljs-comment">// 超时检查：如果已经等待了足够长的时间，退出循环</span><br>                <span class="hljs-keyword">if</span> (delay &lt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <br>                <span class="hljs-comment">// 调用线程（th1）在 this（th2）对象上等待 delay 毫秒</span><br>                <span class="hljs-comment">// 等价于：th2.wait(delay)</span><br>                <span class="hljs-comment">// </span><br>                <span class="hljs-comment">// 可能的唤醒原因：</span><br>                <span class="hljs-comment">// 1. th2 结束，JVM 自动调用 th2.notifyAll()</span><br>                <span class="hljs-comment">// 2. 超时时间到</span><br>                <span class="hljs-comment">// 3. 伪唤醒</span><br>                wait(delay);<br>                <br>                <span class="hljs-comment">// 更新已等待时长</span><br>                now = System.currentTimeMillis() - base;<br>                <br>                <span class="hljs-comment">// 循环继续，重新检查 isAlive() 和剩余时间（协作式逻辑）</span><br>            &#125;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 退出方法时，释放 th2 对象的 Monitor 锁</span><br>        <span class="hljs-comment">// th1 继续执行后续代码</span><br>    &#125;<br></code></pre></td></tr></table></figure>
<ol>
<li>线程的 join 相当于当前线程在另一个会死亡的线程对象上等待，在 while 循环里无限  wait，在超时或者该线程死亡的时候从 wait 里解脱出来。</li>
<li>每个 thread 对象的内置状态变成死亡的时候，JVM 会主动调用这个对象的 notifyAll，这和任意条件对象的 wait 和 notifyAll 由程序员自己控制是不一样的。</li>
</ol>
<p><strong>关于线程池、异步编程、CompletableFuture 等高级并发工具</strong>：join 主要用于简单的线程间等待，但对于复杂的并发任务编排，建议使用线程池和 CompletableFuture 等更强大的工具。详细内容请参阅<a href="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/">《Java 线程池笔记》</a>。</p>
<h2 id="虚拟线程对管程模型的影响-jdk-21">虚拟线程对管程模型的影响（JDK 21+）</h2>
<p>JDK 21 引入的虚拟线程（Virtual Threads）对传统管程模型带来了新的考量。</p>
<h3 id="pinned-问题">Pinned 问题</h3>
<p>虚拟线程在 <code>synchronized</code> 块内调用阻塞方法（如 <code>wait()</code>、<code>I/O</code> 操作）时，会被<strong>钉住（pinned）</strong>，无法让出载体线程：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs csharp">传统平台线程：<br>┌─────────────────────────────────────────────────────────────────────┐<br>│  synchronized (<span class="hljs-keyword">lock</span>) &#123;                                              │<br>│      <span class="hljs-keyword">lock</span>.wait();  <span class="hljs-comment">// 线程阻塞，但 OS 线程也被占用                   │</span><br>│  &#125;                  <span class="hljs-comment">// 无所谓，一个平台线程 = 一个 OS 线程            │</span><br>└─────────────────────────────────────────────────────────────────────┘<br><br>虚拟线程（synchronized 块内阻塞）：<br>┌─────────────────────────────────────────────────────────────────────┐<br>│  synchronized (<span class="hljs-keyword">lock</span>) &#123;                                              │<br>│      <span class="hljs-keyword">lock</span>.wait();  <span class="hljs-comment">// 虚拟线程被钉住，载体线程无法释放！             │</span><br>│  &#125;                  <span class="hljs-comment">// 载体线程被占用，无法执行其他虚拟线程           │</span><br>└─────────────────────────────────────────────────────────────────────┘<br><br>虚拟线程（ReentrantLock 块内阻塞）：<br>┌─────────────────────────────────────────────────────────────────────┐<br>│  <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();                                                       │<br>│  <span class="hljs-keyword">try</span> &#123;                                                              │<br>│      condition.<span class="hljs-keyword">await</span>();  <span class="hljs-comment">// 虚拟线程挂起，载体线程可以释放！         │</span><br>│  &#125; <span class="hljs-keyword">finally</span> &#123; <span class="hljs-keyword">lock</span>.unlock(); &#125;  <span class="hljs-comment">// 载体线程可执行其他虚拟线程         │</span><br>└─────────────────────────────────────────────────────────────────────┘<br></code></pre></td></tr></table></figure>
<h3 id="jdk-21-的实践建议">JDK 21+ 的实践建议</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
<th>原因</th>
</tr>
</thead>
<tbody>
<tr>
<td>虚拟线程中需要等待/通知</td>
<td><code>ReentrantLock</code> + <code>Condition</code></td>
<td>避免 pinned 问题</td>
</tr>
<tr>
<td>虚拟线程中的简单互斥</td>
<td><code>synchronized</code>（临界区短时）</td>
<td>可接受，但需确保无阻塞操作</td>
</tr>
<tr>
<td>高并发 I/O 场景</td>
<td>虚拟线程 + <code>ReentrantLock</code></td>
<td>最大化载体线程利用率</td>
</tr>
</tbody>
</table>
<p><strong>关键结论</strong>：虚拟线程环境下，管程的互斥部分（<code>synchronized</code>）可能成为性能瓶颈。这是 JDK 21 推荐在高并发场景使用 <code>ReentrantLock</code> 的原因之一。</p>
<p><strong>虚拟线程与操作系统层面的约束</strong>：虚拟线程在 <code>synchronized</code> 块内阻塞会被 Pinned，因为 <code>synchronized</code> 的实现依赖 OS mutex，无法让出载体线程。这再次印证了本文开篇的原则——高级抽象要基于底层系统，不能超出操作系统允许的范围。</p>
<p>关于 JMM、volatile、内存模型等内容，请参阅<a href="/2026/02/07/JVM-%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">《JVM 的内存模型与线程》</a>。关于 JUC、锁等内容，请参阅<a href="https://magicliang.github.io/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/">《线程安全与锁优化》</a>。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/">https://magicliang.github.io/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">多线程</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/12/Java-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/volatile%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E5%BD%B1%E5%93%8D.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/" title="无锁队列"><img class="cover" src="/2026/01/18/%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97/%E8%AE%A1%E7%AE%97%E6%9C%BACPU%E4%B8%8E%E7%BC%93%E5%AD%98%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-18</div><div class="info-item-2">无锁队列</div></div><div class="info-2"><div class="info-item-1">Java 一读一写（SPSC）：Memory Barrier + Volatile 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Single-Producer Single-Consumer (SPSC) 无锁环形队列。 * * &lt;p&gt;原理说明： * - 仅允许一个线程调用 &#123;@code offer()&#125;，一个线程调用 &#123;@code poll()&#125;。 * - 由于没有写竞争，无需 CAS；只需保证写操作对消费者可见。 * - 使用两个 volatile 索引（head/tail）建立 happens-before 关系： *   生产者写入元素 → volatile 写 tail → 消费者 volatile 读 tail → 读取元素。 * - 这本质上利用了 Java 内存模型中的“volatile 写-读”内存屏障（StoreLoad）， *   ...</div></div></div></a><a class="pagination-related" href="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/" title="Java 线程池笔记"><img class="cover" src="/2026/01/24/Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%AC%94%E8%AE%B0/ThreadPoolExecutorUML%E7%B1%BB%E5%9B%BE.png" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-24</div><div class="info-item-2">Java 线程池笔记</div></div><div class="info-2"><div class="info-item-1">从执行器到线程池（from executor interface to thread pool implementation）  Pooling is the grouping together of resources (assets, equipment, personnel, effort, etc.) for the purposes of maximizing advantage or minimizing risk to the users. The term is used in finance, computing and equipment management.——wikipedia “池化”思想不仅仅能应用在计算机领域，在金融、设备、人员管理、工作管理等领域也有相关的应用。 在计算机领域中的表现为：统一管理IT资源，包括服务器、存储、和网络资源等等。通过共享资源，使用户在低投入中获益。除去线程池，还有其他比较典型的几种使用策略包括： 内存池(Memory Pooling)：预先申请内存，提升申请内存速度，减少内存碎片。 连接池(Connection Pool...</div></div></div></a><a class="pagination-related" href="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/" title="线程安全与锁优化"><img class="cover" src="/2026/01/19/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/synchronized%E5%8E%9F%E7%90%86.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-01-19</div><div class="info-item-2">线程安全与锁优化</div></div><div class="info-2"><div class="info-item-1"> 版本说明：本文主要基于 JDK 6 ~ JDK 14 的 HotSpot 虚拟机实现。需要注意的是，从 JDK 15 开始，偏向锁已被默认关闭并标记为废弃（JEP 374）。如果你使用的是 JDK 15+，文中关于偏向锁的内容仅作为历史参考。  线程安全 什么是线程安全 “当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方法进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那么这个对象就是线程安全的。” 相对的线程安全，可以分成五个等级。但在深入讨论线程安全的分类之前，我们需要先理解 Java 内存模型——它是理解线程安全问题的理论基础。 Java 内存模型基础 Java 内存模型（Java Memory Model，JMM）是 Java 语言规范的一部分，定义了多线程程序中共享变量的访问规则。理解 JMM 是理解线程安全问题的基础。 为什么需要内存模型？ 现代计算机系统中，CPU 与主内存之间存在巨大的速度差异。为了弥补这一差距，硬件层面引入了多级缓存（L1、L2、L3 Cache）。这带来了一个问...</div></div></div></a><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-145.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-85.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">卡表和 RSet 问题定义：为什么需要跨区域引用记录 JVM 垃圾收集器的核心工作之一是确定 live set——哪些对象仍然存活、不可回收。确定 live set 的标准做法是从 GC Roots（栈帧中的局部变量、静态字段等）出发，沿引用链遍历所有可达对象。 问题在于：当堆被划分为多个区域（代、Region）并且只回收其中一部分时，如何高效地找到从&quot;不回收区域&quot;指向&quot;回收区域&quot;的引用？ 以 Young GC 为例：只回收新生代，但老年代中可能持有指向新生代对象的引用。如果不处理这些跨代引用，就会错误地回收仍被老年代引用的新生代对象。最朴素的做法是扫描整个老年代来找出这些引用——但老年代通常远大于新生代，这样做的代价过高，违背了分代收集&quot;只回收一部分堆&quot;的初衷。 卡表（Card Table）和 RSet（Remembered Set）正是为解决这个问题而设计的辅助数据结构。二者的关系并非互相替代，而是层次不同、协作互补：卡表是底层的脏标记机制，RSet 是建立在卡表之上的更高层索引结构。 核心概念速览 在深入细节之前，...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-37.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">写在前面的话</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-number">1.1.</span> <span class="toc-text">并发与异步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B"><span class="toc-number">1.2.</span> <span class="toc-text">管程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%AE%A1%E7%A8%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">什么是管程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E4%B8%8E-java-%E7%9A%84%E6%98%A0%E5%B0%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">管程与 Java 的映射</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E7%9A%84%E5%85%B8%E5%9E%8B%E5%BA%94%E7%94%A8%EF%BC%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-number">1.2.3.</span> <span class="toc-text">管程的典型应用：生产者-消费者</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E7%AE%A1%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.4.</span> <span class="toc-text">三种管程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-java-%E9%80%89%E6%8B%A9-mesa-%E8%80%8C%E9%9D%9E-hoare-%E6%A8%A1%E5%9E%8B%EF%BC%9F"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">为什么 Java 选择 Mesa 而非 Hoare 模型？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mesa-%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.3.</span> <span class="toc-text">Mesa 模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-set-%E8%80%8C%E4%B8%8D%E7%94%A8-queue"><span class="toc-number">1.3.1.</span> <span class="toc-text">为什么用 set 而不用 queue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#entry-set-%E7%9A%84%E5%91%BD%E5%90%8D%E5%90%AB%E4%B9%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">Entry Set 的命名含义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%8E%E7%AE%A1%E7%A8%8B-monitor-%E7%9A%84%E8%A7%92%E5%BA%A6%E7%9C%8B"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">从管程（Monitor）的角度看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AB-entry-set"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">为什么叫 Entry Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94-wait-set"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">对比 Wait Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%BD%A2%E8%B1%A1%E7%9A%84%E6%AF%94%E5%96%BB"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">一个形象的比喻</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%90%86%E8%A7%A3"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">关键理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B%E6%98%A0%E5%B0%84"><span class="toc-number">1.3.3.</span> <span class="toc-text">模型映射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E8%A7%86%E8%A7%92-vs-java-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">管程视角 vs Java 线程状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-mesa-%E6%A8%A1%E5%9E%8B%E7%9A%84-signal-and-continue-%E8%AF%AD%E4%B9%89"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">1. Mesa 模型的 “Signal and Continue” 语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-entry-set-%E9%94%81%E7%AB%9E%E4%BA%89-%E2%9D%8C-%E6%B0%B8%E8%BF%9C%E4%B8%8D%E4%BC%9A%E6%9C%89-timed-waiting"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">2. Entry Set（锁竞争）❌ 永远不会有 TIMED_WAITING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-wait-set-%E6%9D%A1%E4%BB%B6%E7%AD%89%E5%BE%85-%E2%9C%85-%E6%94%AF%E6%8C%81-timed-waiting"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">3. Wait Set（条件等待）✅ 支持 TIMED_WAITING</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-jvisualvm-%E5%88%86%E7%B1%BB%E9%80%BB%E8%BE%91"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">4. JVisualVM 分类逻辑</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B8%8E-os-%E8%B0%83%E5%BA%A6"><span class="toc-number">1.3.3.6.</span> <span class="toc-text">5. 线程状态与 OS 调度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">Thread 模型底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#java-thread-%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.1.</span> <span class="toc-text">Java Thread 类的设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hotspot-jvm-%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA"><span class="toc-number">2.2.</span> <span class="toc-text">HotSpot JVM 中的线程创建</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E7%9A%84%E8%B0%83%E7%94%A8%E9%93%BE"><span class="toc-number">2.3.</span> <span class="toc-text">线程创建的调用链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javathread-%E4%B8%89%E4%BD%8D%E4%B8%80%E4%BD%93%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.4.</span> <span class="toc-text">JavaThread 三位一体设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%90%AF%E5%8A%A8%E6%97%B6%E5%BA%8F"><span class="toc-number">2.5.</span> <span class="toc-text">线程启动时序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">Java 线程状态</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%A8%E6%99%AF%E5%9B%BE"><span class="toc-number">3.1.</span> <span class="toc-text">线程状态转换全景图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3"><span class="toc-number">3.2.</span> <span class="toc-text">线程状态详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">3.2.1.</span> <span class="toc-text">NEW</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#runnable"><span class="toc-number">3.2.2.</span> <span class="toc-text">RUNNABLE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#blocked"><span class="toc-number">3.2.3.</span> <span class="toc-text">BLOCKED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#waiting"><span class="toc-number">3.2.4.</span> <span class="toc-text">WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#timed-waiting"><span class="toc-number">3.2.5.</span> <span class="toc-text">TIMED_WAITING</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#terminated"><span class="toc-number">3.2.6.</span> <span class="toc-text">TERMINATED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">3.2.7.</span> <span class="toc-text">几种线程状态的对比</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%96%B9%E6%B3%95%E7%9A%84%E8%AE%BE%E8%AE%A1%E5%93%B2%E5%AD%A6"><span class="toc-number">3.3.</span> <span class="toc-text">线程间方法的设计哲学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90"><span class="toc-number">3.4.</span> <span class="toc-text">线程中断机制深入解析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E-hotspot-%E5%BA%95%E5%B1%82%E7%9C%8B-interrupt-%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.4.1.</span> <span class="toc-text">从 HotSpot 底层看 interrupt 的本质</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jvm-%E5%B1%82%E9%9D%A2%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">JVM 层面的数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#interrupt-%E4%B8%8E-unpark-%E7%9A%84%E8%BE%A8%E6%9E%90"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">interrupt() 与 unpark() 的辨析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2%E7%9A%84%E5%94%A4%E9%86%92%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.1.3.</span> <span class="toc-text">操作系统层面的唤醒机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#cpu-%E5%87%BA%E8%AE%A9%E4%B8%8E%E5%94%A4%E9%86%92%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-number">3.4.1.4.</span> <span class="toc-text">CPU 出让与唤醒的本质</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E4%B8%AA-interrupt-%E7%9B%B8%E5%85%B3%E6%96%B9%E6%B3%95%E7%9A%84%E7%B2%BE%E7%A1%AE%E8%AF%AD%E4%B9%89"><span class="toc-number">3.4.2.</span> <span class="toc-text">三个 interrupt 相关方法的精确语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E6%96%B9%E6%B3%95%E5%AF%B9-interrupt-%E7%9A%84%E5%93%8D%E5%BA%94%E5%B7%AE%E5%BC%82"><span class="toc-number">3.4.3.</span> <span class="toc-text">阻塞方法对 interrupt 的响应差异</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%81%A2%E5%A4%8D%EF%BC%9A%E4%B8%BA%E4%BB%80%E4%B9%88%E5%BF%85%E9%A1%BB-thread-currentthread-interrupt"><span class="toc-number">3.4.4.</span> <span class="toc-text">中断恢复：为什么必须 Thread.currentThread().interrupt()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interrupt-%E5%9C%A8-aqs-%E4%B8%AD%E7%9A%84%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.5.</span> <span class="toc-text">interrupt 在 AQS 中的传递机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#aqs-%E7%9A%84-%E5%BB%B6%E8%BF%9F%E4%B8%AD%E6%96%AD-%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.5.1.</span> <span class="toc-text">AQS 的&quot;延迟中断&quot;策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#aqs-%E7%9A%84-%E7%AB%8B%E5%8D%B3%E4%B8%AD%E6%96%AD-%E7%AD%96%E7%95%A5"><span class="toc-number">3.4.5.2.</span> <span class="toc-text">AQS 的&quot;立即中断&quot;策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#conditionobject-await-%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%AD%E6%A3%80%E6%9F%A5"><span class="toc-number">3.4.5.3.</span> <span class="toc-text">ConditionObject.await() 中的中断检查</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interrupt-%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.4.6.</span> <span class="toc-text">interrupt 与线程状态转换的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#thread-interrupt-%E7%9A%84%E4%BA%94%E5%A4%A7%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7"><span class="toc-number">3.4.7.</span> <span class="toc-text">Thread.interrupt 的五大设计缺陷</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E4%B8%80%EF%BC%9A%E4%B8%AD%E6%96%AD%E7%9A%84%E6%98%AF%E7%BA%BF%E7%A8%8B-%E8%80%8C%E9%9D%9E%E4%BB%BB%E5%8A%A1"><span class="toc-number">3.4.7.1.</span> <span class="toc-text">缺陷一：中断的是线程，而非任务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E4%BA%8C%EF%BC%9A%E4%B8%AD%E6%96%AD%E6%A0%87%E5%BF%97%E5%AE%B9%E6%98%93%E8%A2%AB-%E5%90%9E%E6%8E%89"><span class="toc-number">3.4.7.2.</span> <span class="toc-text">缺陷二：中断标志容易被&quot;吞掉&quot;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E4%B8%89%EF%BC%9A%E4%B8%AD%E6%96%AD%E6%A0%87%E5%BF%97%E6%B3%84%E9%9C%B2"><span class="toc-number">3.4.7.3.</span> <span class="toc-text">缺陷三：中断标志泄露</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E5%9B%9B%EF%BC%9A%E5%B5%8C%E5%A5%97%E4%BB%BB%E5%8A%A1%E6%97%B6%E7%9A%84%E6%B7%B7%E4%B9%B1"><span class="toc-number">3.4.7.4.</span> <span class="toc-text">缺陷四：嵌套任务时的混乱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E9%99%B7%E4%BA%94%EF%BC%9A%E8%A1%8C%E4%B8%BA%E4%B8%8D%E4%B8%80%E8%87%B4%E5%A2%9E%E5%8A%A0%E5%BF%83%E6%99%BA%E8%B4%9F%E6%8B%85"><span class="toc-number">3.4.7.5.</span> <span class="toc-text">缺陷五：行为不一致增加心智负担</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9A%E4%BB%BB%E5%8A%A1%E7%BA%A7%E5%8F%96%E6%B6%88%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.8.</span> <span class="toc-text">替代方案：任务级取消机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#abortcontroller-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.4.8.1.</span> <span class="toc-text">AbortController 模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E5%B9%B6%E5%8F%91-java-19"><span class="toc-number">3.4.8.2.</span> <span class="toc-text">结构化并发（Java 19+）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kotlin-%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8F%96%E6%B6%88"><span class="toc-number">3.4.8.3.</span> <span class="toc-text">Kotlin 协程的取消</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interrupt-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">3.4.9.</span> <span class="toc-text">interrupt 最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E4%B8%80%EF%BC%9A%E6%B0%B8%E8%BF%9C%E4%B8%8D%E8%A6%81%E5%90%9E%E6%8E%89-interruptedexception"><span class="toc-number">3.4.9.1.</span> <span class="toc-text">规则一：永远不要吞掉 InterruptedException</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E4%BA%8C%EF%BC%9A%E4%BC%98%E5%85%88%E4%BD%BF%E7%94%A8-isinterrupted-%E8%80%8C%E9%9D%9E-interrupted"><span class="toc-number">3.4.9.2.</span> <span class="toc-text">规则二：优先使用 isInterrupted() 而非 interrupted()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%84%E5%88%99%E4%B8%89%EF%BC%9A%E5%8C%BA%E5%88%86-%E5%8F%96%E6%B6%88-%E5%92%8C-%E4%B8%AD%E6%96%AD"><span class="toc-number">3.4.9.3.</span> <span class="toc-text">规则三：区分&quot;取消&quot;和&quot;中断&quot;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E6%A0%91"><span class="toc-number">3.4.9.4.</span> <span class="toc-text">决策树</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%9A%84%E5%BC%BA%E5%88%B6%E4%B8%AD%E6%96%AD%E4%B8%8E%E6%8B%92%E7%BB%9D%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.10.</span> <span class="toc-text">线程池中的强制中断与拒绝机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E8%A7%A6%E5%8F%91%E7%9A%84%E5%AE%8C%E6%95%B4%E5%9C%BA%E6%99%AF%E5%88%86%E7%B1%BB"><span class="toc-number">3.4.10.1.</span> <span class="toc-text">强制触发的完整场景分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#shutdownnow-%E7%9A%84%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.10.2.</span> <span class="toc-text">shutdownNow() 的中断流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#future-cancel-true-%E7%9A%84%E4%B8%AD%E6%96%AD%E6%B5%81%E7%A8%8B"><span class="toc-number">3.4.10.3.</span> <span class="toc-text">Future.cancel(true) 的中断流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E7%9A%84%E8%A7%A6%E5%8F%91%E6%97%B6%E6%9C%BA%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-number">3.4.10.4.</span> <span class="toc-text">拒绝策略的触发时机与选择</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%91%A8%E6%9C%9F%E4%BB%BB%E5%8A%A1%E5%BC%82%E5%B8%B8%E5%AF%BC%E8%87%B4%E7%9A%84%E9%9D%99%E9%BB%98%E5%81%9C%E6%AD%A2"><span class="toc-number">3.4.10.5.</span> <span class="toc-text">周期任务异常导致的静默停止</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-interrupt-%E6%9C%BA%E5%88%B6%E7%9A%84%E5%85%B3%E8%81%94"><span class="toc-number">3.4.10.6.</span> <span class="toc-text">与 interrupt 机制的关联</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%80%BB%E7%BB%93"><span class="toc-number">3.4.10.7.</span> <span class="toc-text">最佳实践总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interrupt-%E7%9A%84%E5%8E%86%E5%8F%B2%E6%BC%94%E8%BF%9B"><span class="toc-number">3.4.11.</span> <span class="toc-text">interrupt 的历史演进</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E5%88%AB%E7%9A%84%E5%88%87%E6%8D%A2%E6%96%B9%E6%B3%95"><span class="toc-number">3.5.</span> <span class="toc-text">特别的切换方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#locksupport-park"><span class="toc-number">3.5.1.</span> <span class="toc-text">LockSupport.park</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#juc-%E7%9A%84%E7%BB%9F%E4%B8%80%E9%98%BB%E5%A1%9E%E5%8E%9F%E8%AF%AD"><span class="toc-number">3.5.1.1.</span> <span class="toc-text">JUC 的统一阻塞原语</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wait"><span class="toc-number">3.5.2.</span> <span class="toc-text">wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#join"><span class="toc-number">3.5.3.</span> <span class="toc-text">join</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E7%BA%BF%E7%A8%8B%E5%AF%B9%E7%AE%A1%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%BD%B1%E5%93%8D-jdk-21"><span class="toc-number">3.6.</span> <span class="toc-text">虚拟线程对管程模型的影响（JDK 21+）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pinned-%E9%97%AE%E9%A2%98"><span class="toc-number">3.6.1.</span> <span class="toc-text">Pinned 问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jdk-21-%E7%9A%84%E5%AE%9E%E8%B7%B5%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.6.2.</span> <span class="toc-text">JDK 21+ 的实践建议</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>