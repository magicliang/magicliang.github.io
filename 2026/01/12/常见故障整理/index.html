<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>常见故障整理 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="手写 sql if 条件的字段为空则不应该拼接条件，是一个很容易被忽略的编程错误。如果线上发生了这个问题，则可能导致数据同步出错。 极度危险的错误 元素内容必须由格式正确的字符数据或标记组成，这通常是因为&gt;&#96;&#96;&lt;&#96;&#96;&gt;&#x3D;&#96;&#96;&lt;&#x3D;类的标签没有经过转义。 防止手写 sql 被注入 所有 condition 用（）圈起来。单独在 condition 里面拼装。用 and 来连接这">
<meta property="og:type" content="article">
<meta property="og:title" content="常见故障整理">
<meta property="og:url" content="https://magicliang.github.io/2026/01/12/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="手写 sql if 条件的字段为空则不应该拼接条件，是一个很容易被忽略的编程错误。如果线上发生了这个问题，则可能导致数据同步出错。 极度危险的错误 元素内容必须由格式正确的字符数据或标记组成，这通常是因为&gt;&#96;&#96;&lt;&#96;&#96;&gt;&#x3D;&#96;&#96;&lt;&#x3D;类的标签没有经过转义。 防止手写 sql 被注入 所有 condition 用（）圈起来。单独在 condition 里面拼装。用 and 来连接这">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/2026/01/12/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%95%B4%E7%90%86/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AAcoe.png">
<meta property="article:published_time" content="2026-01-12T13:16:19.000Z">
<meta property="article:modified_time" content="2026-02-11T09:18:00.539Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="奇思妙想">
<meta property="article:tag" content="捉虫">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/2026/01/12/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%95%B4%E7%90%86/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AAcoe.png"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "常见故障整理",
  "url": "https://magicliang.github.io/2026/01/12/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%95%B4%E7%90%86/",
  "image": "https://magicliang.github.io/2026/01/12/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%95%B4%E7%90%86/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AAcoe.png",
  "datePublished": "2026-01-12T13:16:19.000Z",
  "dateModified": "2026-02-11T09:18:00.539Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/01/12/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%95%B4%E7%90%86/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '常见故障整理',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/2026/01/12/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%95%B4%E7%90%86/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AAcoe.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">常见故障整理</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">常见故障整理</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-01-12T13:16:19.000Z" title="Created 2026-01-12 21:16:19">2026-01-12</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-11T09:18:00.539Z" title="Updated 2026-02-11 17:18:00">2026-02-11</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">34.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>134mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>手写 sql</h1>
<p>if 条件的字段为空则不应该拼接条件，是一个很容易被忽略的编程错误。如果线上发生了这个问题，则可能导致数据同步出错。</p>
<h2 id="极度危险的错误">极度危险的错误</h2>
<p>元素内容必须由格式正确的字符数据或标记组成，这通常是因为<code>&gt;``&lt;``&gt;=``&lt;=</code>类的标签没有经过转义。</p>
<h2 id="防止手写-sql-被注入">防止手写 sql 被注入</h2>
<p>所有 condition 用（）圈起来。单独在 condition 里面拼装。用 and 来连接这些 condition。</p>
<p>在最外围使用随机化的()来包裹整个 where 的条件，防止有人猜到()的层次。</p>
<h2 id="mybatis-的替换难点">mybatis 的替换难点</h2>
<p><code>#{}</code> 是预编译处理，<code>${}</code> 是直接替换。直接替换会有 sql 注入的风险。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// 原始方案</span><br>    <span class="hljs-meta">@Select(&quot;$&#123;nativeSql&#125;&quot;)</span><br>    Object <span class="hljs-title function_">nativeSql</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;nativeSql&quot;)</span> String nativeSql)</span>;<br><br>    <span class="hljs-comment">// 第一版方案</span><br>    <span class="hljs-meta">@Select(&quot;SELECT sum(distinctCidCnt) AS distinctCidCnt\n&quot;</span><br><span class="hljs-meta">            + &quot;FROM\n&quot;</span><br><span class="hljs-meta">            + &quot;(\n&quot;</span><br><span class="hljs-meta">            + &quot;    SELECT\n&quot;</span><br><span class="hljs-meta">            + &quot;        account_id,\n&quot;</span><br><span class="hljs-meta">            + &quot;        arrayUniq(groupArray(component_id)) AS distinctCidCnt\n&quot;</span><br><span class="hljs-meta">            + &quot;    FROM\n&quot;</span><br><span class="hljs-meta">            + &quot;    (\n&quot;</span><br><span class="hljs-meta">            + &quot;        SELECT\n&quot;</span><br><span class="hljs-meta">            + &quot;            account_id,\n&quot;</span><br><span class="hljs-meta">            + &quot;            arrayJoin(splitByString(&#x27;,&#x27;, component_id_list_str)) AS component_id\n&quot;</span><br><span class="hljs-meta">            + &quot;        FROM testtbl\n&quot;</span><br><span class="hljs-meta">            + &quot;        WHERE $&#123;params&#125;\n&quot;</span><br><span class="hljs-meta">            + &quot;    ) AS t\n&quot;</span><br><span class="hljs-meta">            + &quot;    GROUP BY account_id\n&quot;</span><br><span class="hljs-meta">            + &quot;) &quot;)</span><br>    Integer <span class="hljs-title function_">selectDistinctCidCnt</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;params&quot;)</span> String params)</span>;<br>    <br>    <br>    <span class="hljs-comment">// 第二种方案</span><br>    <br>    <span class="hljs-meta">@SelectProvider(type = CurrentSqlProvider.class, method = &quot;selectDistinctCidCnt&quot;)</span><br>    Integer <span class="hljs-title function_">selectDistinctCidCnt</span><span class="hljs-params">(String conditions)</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CurrentSqlProvider</span> &#123;<br><br>            <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DISTINCT_CID_CNT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;distinctCidCnt&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 一个针对下推查询用的sql，这个sql的逻辑是这样的：</span><br><span class="hljs-comment">     * 1. 先找拼接出来的条件查出全部的 component_id_list_str</span><br><span class="hljs-comment">     * 2. 使用 splitByString 按照 , 分割出 component_id</span><br><span class="hljs-comment">     * 3. 然后借用 arrayJoin 产生多行，每个 component_id 一行</span><br><span class="hljs-comment">     * 4. 使用 groupArray 在每个账户内把多行组成一个数组（不要尝试在 splitByString 生成数组，这个在 ck 里行不通，在 MySQL 里会比想象中复杂得多，这就是这个sql让人难受的地方）</span><br><span class="hljs-comment">     * 5. 使用 arrayUniq 在单个账户内把数组去重，计算长度</span><br><span class="hljs-comment">     * 6. 使用一个外部查询把数组间的数字加总起来</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SQL_TEMPLATE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;select sum(distinctCidCnt) as &quot;</span> + DISTINCT_CID_CNT + <span class="hljs-string">&quot;\n&quot;</span><br>                    + <span class="hljs-string">&quot;from\n&quot;</span><br>                    + <span class="hljs-string">&quot;(SELECT\n&quot;</span><br>                    + <span class="hljs-string">&quot;    account_id,\n&quot;</span><br>                    + <span class="hljs-string">&quot;    arrayUniq(groupArray(component_id)) AS distinctCidCnt\n&quot;</span><br>                    + <span class="hljs-string">&quot;FROM\n&quot;</span><br>                    + <span class="hljs-string">&quot;(\n&quot;</span><br>                    + <span class="hljs-string">&quot;    SELECT\n&quot;</span><br>                    + <span class="hljs-string">&quot;        account_id,\n&quot;</span><br>                    + <span class="hljs-string">&quot;        arrayJoin(splitByString(&#x27;,&#x27;, component_id_list_str)) AS component_id\n&quot;</span><br>                    + <span class="hljs-string">&quot;    FROM testtbl\n&quot;</span><br>                    + <span class="hljs-string">&quot;    WHERE %s \n&quot;</span><br>                    + <span class="hljs-string">&quot;) AS t\n&quot;</span><br>                    + <span class="hljs-string">&quot;GROUP BY account_id)&quot;</span>;<br><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">selectDistinctCidCnt</span><span class="hljs-params">(String conditions)</span> &#123;<br>                <span class="hljs-keyword">return</span> String.format(SQL_TEMPLATE, conditions);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 第三个方案</span><br>            <span class="hljs-meta">@Select(&quot;&lt;script&gt;&quot;</span><br><span class="hljs-meta">        + &quot;SELECT sum(distinctCidCnt) AS distinctCidCnt\n&quot;</span><br><span class="hljs-meta">        + &quot;FROM\n&quot;</span><br><span class="hljs-meta">        + &quot;(\n&quot;</span><br><span class="hljs-meta">        + &quot;    SELECT\n&quot;</span><br><span class="hljs-meta">        + &quot;        account_id,\n&quot;</span><br><span class="hljs-meta">        + &quot;        arrayUniq(groupArray(component_id)) AS distinctCidCnt\n&quot;</span><br><span class="hljs-meta">        + &quot;    FROM\n&quot;</span><br><span class="hljs-meta">        + &quot;    (\n&quot;</span><br><span class="hljs-meta">        + &quot;        SELECT\n&quot;</span><br><span class="hljs-meta">        + &quot;            account_id,\n&quot;</span><br><span class="hljs-meta">        + &quot;            arrayJoin(splitByString(&#x27;,&#x27;, component_id_list_str)) AS component_id\n&quot;</span><br><span class="hljs-meta">        + &quot;        FROM testtbl\n&quot;</span><br><span class="hljs-meta">        + &quot;        &lt;where&gt; 1=1&quot;</span><br><span class="hljs-meta">        + &quot;&lt;if test=&#x27;startDate != null&#x27;&gt;&quot;</span><br><span class="hljs-meta">        + &quot; AND partition_time &amp;gt;= #&#123;startDate&#125;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/if&gt;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;if test=&#x27;endDate != null&#x27;&gt;&quot;</span><br><span class="hljs-meta">        + &quot; AND partition_time &amp;lt;= #&#123;endDate&#125;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/if&gt;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;if test=&#x27;adgroupId != null&#x27;&gt;&quot;</span><br><span class="hljs-meta">        + &quot; AND adgroup_id = #&#123;adgroupId&#125;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/if&gt;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;if test=&#x27;opGroupNameList != null and opGroupNameList.size() &gt; 0&#x27;&gt;&quot;</span><br><span class="hljs-meta">        + &quot; AND op_group_name in &quot;</span><br><span class="hljs-meta">        + &quot;&lt;foreach item=&#x27;item&#x27; index=&#x27;index&#x27; collection=&#x27;opGroupNameList&#x27; open=&#x27;(&#x27; separator=&#x27;,&#x27; close=&#x27;)&#x27;&gt;&quot;</span><br><span class="hljs-meta">        + &quot;#&#123;item&#125;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/foreach&gt;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/if&gt;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;if test=&#x27;marketingTargetId != null&#x27;&gt;&quot;</span><br><span class="hljs-meta">        + &quot; AND marketing_target_id = #&#123;marketingTargetId&#125;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/if&gt;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;if test=&#x27;marketingTargetName != null&#x27;&gt;&quot;</span><br><span class="hljs-meta">        + &quot; AND marketing_target_name = #&#123;marketingTargetName&#125;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/if&gt;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;if test=&#x27;agentIds != null and agentIds.size() &gt; 0&#x27;&gt;&quot;</span><br><span class="hljs-meta">        + &quot; AND agent_id in &quot;</span><br><span class="hljs-meta">        + &quot;&lt;foreach item=&#x27;item&#x27; index=&#x27;index&#x27; collection=&#x27;agentIds&#x27; open=&#x27;(&#x27; separator=&#x27;,&#x27; close=&#x27;)&#x27;&gt;&quot;</span><br><span class="hljs-meta">        + &quot;#&#123;item&#125;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/foreach&gt;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/if&gt;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;if test=&#x27;accountId != null&#x27;&gt;&quot;</span><br><span class="hljs-meta">        + &quot; AND account_id = #&#123;accountId&#125;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/if&gt;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/where&gt;&quot;</span><br><span class="hljs-meta">        + &quot;    ) AS t\n&quot;</span><br><span class="hljs-meta">        + &quot;    GROUP BY account_id\n&quot;</span><br><span class="hljs-meta">        + &quot;) &quot;</span><br><span class="hljs-meta">        + &quot;&lt;/script&gt;&quot;)</span><br>Integer <span class="hljs-title function_">selectDistinctCidCnt</span><span class="hljs-params">(LocalDate startDate, LocalDate endDate, Long adgroupId, List&lt;String&gt; opGroupNameList</span><br><span class="hljs-params">        , Long marketingTargetId, String marketingTargetName, List&lt;Long&gt; agentIds, Long accountId)</span>;<br>        <br>    <span class="hljs-comment">// 最终方案</span><br>    <span class="hljs-meta">@Select(&quot;&lt;script&gt;&quot;</span><br><span class="hljs-meta">        + &quot;SELECT sum(distinctCidCnt) AS distinctCidCnt\n&quot;</span><br><span class="hljs-meta">        + &quot;FROM\n&quot;</span><br><span class="hljs-meta">        + &quot;(\n&quot;</span><br><span class="hljs-meta">        + &quot;    SELECT\n&quot;</span><br><span class="hljs-meta">        + &quot;        account_id,\n&quot;</span><br><span class="hljs-meta">        + &quot;        arrayUniq(groupArray(component_id)) AS distinctCidCnt\n&quot;</span><br><span class="hljs-meta">        + &quot;    FROM\n&quot;</span><br><span class="hljs-meta">        + &quot;    (\n&quot;</span><br><span class="hljs-meta">        + &quot;        SELECT\n&quot;</span><br><span class="hljs-meta">        + &quot;            account_id,\n&quot;</span><br><span class="hljs-meta">        + &quot;            arrayJoin(splitByString(&#x27;,&#x27;, component_id_list_str)) AS component_id\n&quot;</span><br><span class="hljs-meta">        + &quot;        FROM testtbl\n&quot;</span><br><span class="hljs-meta">        + &quot;        &lt;where&gt;&quot;</span><br><span class="hljs-meta">        + &quot; &lt;foreach collection=&#x27;conditions.entrySet()&#x27; item=&#x27;value&#x27; index=&#x27;key&#x27; separator=&#x27; AND &#x27;&gt;&quot;</span><br><span class="hljs-meta">        + &quot;$&#123;key&#125; $&#123;value&#125;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/foreach&gt;&quot;</span><br><span class="hljs-meta">        + &quot;&lt;/where&gt;&quot;</span><br><span class="hljs-meta">        + &quot;    ) AS t\n&quot;</span><br><span class="hljs-meta">        + &quot;    GROUP BY account_id\n&quot;</span><br><span class="hljs-meta">        + &quot;) &quot;</span><br><span class="hljs-meta">        + &quot;&lt;/script&gt;&quot;)</span><br>Integer <span class="hljs-title function_">selectDistinctCidCnt</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;conditions&quot;)</span> Map&lt;String, String&gt; conditions)</span>;<br></code></pre></td></tr></table></figure>
<p>对于 mybatis 的普通标签，注意<code>&amp;gt;=</code>，<code>&amp;lt;=</code>，必须使用foreach in，不能直接使用in，否则会<code>Invalid types for IN function: String and Tuple </code>。</p>
<p>如果使用最终方案，key 使用列名，value 使用操作符 + value 的方法，如<code>in (123)</code>或者<code>&gt;= '2024-11-11'</code>，不需要转义，但是需要尽量拼接上单引号和括号（不要改变语义），而且在生成语句的时候需要严格使用<code>${}</code>而不能使用<code>#{}</code>，for循环的item、index和 separator 也不能变。</p>
<h1>熔断和降级仍然导致 cpu 过高</h1>
<p>熔断和降级会导致大量的日志打印。</p>
<p>日志打印在高并发时可能遇到问题：</p>
<blockquote>
<p>ThrowableProxy.toExtendedStackTrace 内部会进行loadClass操作。</p>
<p>并且可以看到 ClassLoader 的 loadClass 在加载类时</p>
<p>1）首先会持有锁。</p>
<p>2）调用 findLoadedClass 看下是否类已经被加载过了</p>
<p>3）如果类没被加载过，根据双亲委派模型去加载类。</p>
<p>可以看到当某个类被加载过了，调用 findLoadedClass 会直接返回，锁也会被很快释放掉，无需经过双亲委派等后面的一系列步骤。</p>
<p>但是，在进行反射调用时，JVM 会进行优化，会动态生成名为 sun.reflect.GeneratedMethodAccessor<N> 的类，这个类无法通过 ClassLoader.loadClass 方法加载。</p>
<p>导致每次解析异常栈进行类加载时，锁占有的时间很长，最终导致阻塞。</p>
</blockquote>
<p>Java中对反射的优化</p>
<p>使用反射调用某个类的方法，jvm内部有两种方式</p>
<p>JNI：使用native方法进行反射操作。</p>
<p>pure-Java：生成bytecode进行反射操作，即生成类sun.reflect.GeneratedMethodAccessor<N>，它是一个被反射调用方法的包装类，代理不同的方法，类后缀序号会递增。这种方式第一次调用速度较慢，较之第一种会慢3-4倍，但是多次调用后速度会提升20倍</p>
<p>对于使用JNI的方式，因为每次都要调用native方法再返回，速度会比较慢。所以，当一个方法被反射调用的次数超过一定次数（默认15次）时，JVM内部会进行优化，使用第2种方法，来加快运行速度。</p>
<p>JVM有两个参数来控制这种优化</p>
<p>IDEA 里的 VM options：</p>
<p>-Dsun.reflect.inflationThreshold=<value><br>
value默认为15，即反射调用某个方法15次后，会由JNI的方式变为pure-java的方式</p>
<p>-Dsun.reflect.noInflation=true</p>
<p>默认为false。当设置为true时，表示在第一次反射调用时，就转为pure-java的方式</p>
<p>关于如何验证上面所说的反射优化以及两个参数的具体作用，可以参考R大的这篇博客https://rednaxelafx.iteye.com/blog/548536</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestMethodInvoke</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Class&lt;?&gt; clz = Class.forName(<span class="hljs-string">&quot;A&quot;</span>);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">o</span> <span class="hljs-operator">=</span> clz.newInstance();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> clz.getMethod(<span class="hljs-string">&quot;foo&quot;</span>, String.class);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            m.invoke(o, Integer.toString(i));<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">foo</span><span class="hljs-params">(String name)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, &quot;</span> + name);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> MethodAccessor <span class="hljs-title function_">acquireMethodAccessor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// First check to see if one has been created yet, and take it</span><br>        <span class="hljs-comment">// if so</span><br>        <span class="hljs-type">MethodAccessor</span> <span class="hljs-variable">tmp</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">if</span> (root != <span class="hljs-literal">null</span>) tmp = root.getMethodAccessor();<br>        <span class="hljs-keyword">if</span> (tmp != <span class="hljs-literal">null</span>) &#123;<br>            methodAccessor = tmp;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Otherwise fabricate one and propagate it up to the root</span><br>            tmp = reflectionFactory.newMethodAccessor(<span class="hljs-built_in">this</span>);<br>            setMethodAccessor(tmp);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> tmp;<br>    &#125;<br><br><span class="hljs-keyword">public</span> MethodAccessor <span class="hljs-title function_">newMethodAccessor</span><span class="hljs-params">(Method var1)</span> &#123;<br>        checkInitted();<br>        <span class="hljs-keyword">if</span> (noInflation &amp;&amp; !ReflectUtil.isVMAnonymousClass(var1.getDeclaringClass())) &#123;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">MethodAccessorGenerator</span>()).generateMethod(var1.getDeclaringClass(), var1.getName(), var1.getParameterTypes(), var1.getReturnType(), var1.getExceptionTypes(), var1.getModifiers());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">NativeMethodAccessorImpl</span> <span class="hljs-variable">var2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NativeMethodAccessorImpl</span>(var1);<br>            <span class="hljs-type">DelegatingMethodAccessorImpl</span> <span class="hljs-variable">var3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DelegatingMethodAccessorImpl</span>(var2);<br>            var2.setParent(var3);<br>            <span class="hljs-keyword">return</span> var3;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>这个方法不一定能够奏效。</p>
<p>如何关闭JVM对反射调用的优化？<br>
想关闭JVM对反射优化怎么办?</p>
<p>JVM中只提供了两个参数，因此，没有办法完全关闭反射优化。</p>
<p>一种能想到的接近于关闭反射优化的方法就是将inflationThreshold设为的一个特别大的数。</p>
<p>inflationThreshold是java中的int型值，可以考虑把其设置为Integer.MAX_VALUE ((2^31)-1)。</p>
<p>$ java -Dsun.reflect.inflationThreshold=2147483647 MyApp</p>
<p>两类触发条件：</p>
<ol>
<li>高并发打印异常栈日志(QPS&gt;50)；</li>
<li><strong>异常栈</strong>中包含反射相关的类(RPC中间件、aop)；</li>
</ol>
<p>解决方案，绕开 log4j里面的 ThrowableProxy.toExtendedStackTrace 对异常的处理流程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">logError</span><span class="hljs-params">(Logger logger, String message, Object... args)</span> &#123;<br>        <span class="hljs-keyword">if</span> (ArrayUtils.isEmpty(args)) &#123;<br>            logger.error(message);<br>            Monitor.logError(message, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> ArrayUtils.getLength(args);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> args[length - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">String</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> message;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>; i++) &#123;<br>            builder = StringUtils.replaceOnce(builder, replaceStr, String.valueOf(args[i]));<br>        &#125;<br>        <span class="hljs-comment">// 传入参数以异常结尾</span><br>        <span class="hljs-keyword">if</span> (last <span class="hljs-keyword">instanceof</span> Exception) &#123;<br>            logger.error(builder + <span class="hljs-string">&quot; exception msg=&#123;&#125;&quot;</span>, getStackTrace((Throwable) last));<br>            Monitor.logError(builder, (Throwable) last);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            logger.error(message, args);<br>            builder = StringUtils.replaceOnce(builder, replaceStr, String.valueOf(last));<br>            Monitor.logError(builder, <span class="hljs-keyword">new</span> <span class="hljs-title class_">BizException</span>());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getStackTrace</span><span class="hljs-params">(Throwable throwable)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">StringWriter</span> <span class="hljs-variable">sw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringWriter</span>();<br>            <span class="hljs-type">PrintWriter</span> <span class="hljs-variable">pw</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrintWriter</span>(sw, <span class="hljs-literal">true</span>);<br>            throwable.printStackTrace(pw);<br>            <span class="hljs-keyword">return</span> sw.getBuffer().toString();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>    &#125;<br><br>ExceptionUtil.logError(log, <span class="hljs-string">&quot;warden上传图片节点，解析图片内容为空, param:&#123;&#125;&quot;</span>, riskClaimParam, wardenRiskException);<br><br><br><span class="hljs-comment">// 第二种方法：去掉了 GeneratedMethodAccessor，不够好</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionUtils</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 过滤反射相关类，JVM反射优化后 log4j输出异常栈会因反复加载这些类block线程，尤其GeneratedMethodAccessor</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Throwable <span class="hljs-title function_">filterReflectTrace</span><span class="hljs-params">(Throwable e)</span> &#123;<br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> e;<br><br>        <span class="hljs-keyword">while</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>            StackTraceElement[] traces = cause.getStackTrace();<br>            List&lt;StackTraceElement&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (StackTraceElement element : traces) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> element.getClassName();<br>                <span class="hljs-keyword">if</span> (className.contains(<span class="hljs-string">&quot;GeneratedMethodAccessor&quot;</span>) || className.contains(<span class="hljs-string">&quot;DelegatingMethodAccessorImpl&quot;</span>)<br>                        || className.contains(<span class="hljs-string">&quot;NativeMethodAccessorImpl&quot;</span>)) &#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                list.add(element);<br>            &#125;<br>            StackTraceElement[] newTraces = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StackTraceElement</span>[list.size()];<br>            cause.setStackTrace(list.toArray(newTraces));<br><br>            cause = cause.getCause();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> e;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903663475900423">《一个关于log4j2的高并发问题》</a></li>
<li><a target="_blank" rel="noopener" href="https://issues.apache.org/jira/browse/LOG4J2-2391">apache的官方jira</a>。</li>
</ol>
<h1>老的表如果预先没有加好查询索引，则后续维护的 orm 用户更加容易忘记加</h1>
<p>缺慢查询告警则无法在性能恶化以前发现这个问题。</p>
<h1>nginx 集群的 tps 只有 18 万，不容易动态扩容。因为没有打招呼，所以没有扩容。前后端没有做过针对活动的限流调整。</h1>
<p>要针对活动对 PaaS、IaaS 层做预案设计，这种偏物理层面的非逻辑节点隐藏得特别深，容易被忽略。</p>
<h1>改配置无前置正确性校验和运营审核卡点</h1>
<p>要配上前置校验工具和卡点平台。</p>
<h1>不同业务没有做数据层面的隔离，而只做了应用层面的隔离</h1>
<p>错误雪崩无边界。</p>
<h1>MySQL 官方bug</h1>
<p>这是一个类似因果一致性达不到顺序一致性的问题。</p>
<p>相互矛盾的 dml 会使用同一个 commitid，因而在从库被并行执行，被并行执行时触发死锁。：<a target="_blank" rel="noopener" href="https://bugs.mysql.com/bug.php?id=89229">FLUSH PRIVILEGES may cause MTS deadlock</a></p>
<h1>平台有两种工作模式时，无缓存的工作模式没有经过深入测试</h1>
<p>无缓存的测试数据集比较小，分布不够散列，导致测试的结果不能匹配线上真实的大流量。</p>
<h1>动态配置服务</h1>
<p>广播失败，播放了缺省值。</p>
<h1>Java 7 的 code cache 问题</h1>
<p>根因：</p>
<ol>
<li>codecache打满且发生flush；</li>
<li>flush之后未操作过重启；</li>
<li>热点代码已从codecache中卸载。</li>
</ol>
<blockquote>
<p>Code cache flushing causes stop in compilation, contention on<br>
codecache lock and lots of wasted CPU cycles when the code cache gets<br>
full.</p>
<p>When uncommited codecache memory is less than the the size of the<br>
total memory on the freelist, we iterate the entire freelist for the<br>
largest block. This is done from ~8 places in the compiler broker. As<br>
long as the largest block is less than CodeCacheMinimumFreeSpace<br>
(1,5M) all compilation is halted and flushing is invoked. Since<br>
gathering a 1,5M continous freelist block will take some time,<br>
compilations is delayed, and regular flushing makes the freelist<br>
longer and longer. After a while it is very long, but still far from<br>
being continous. More and more time is spent iterating the freelist.<br>
All profile counters that overflow will end up checking the freelist.<br>
All compiler threads will check the freelist a few times before<br>
delaying compilation. In addition the freelist is accessed holding the<br>
codecache lock making the excessive iterating fully serilized. After a<br>
day or so a CPU core may spend 100% of its cycles banging the<br>
codecache locka and iterating the freelist. Also the application slows<br>
down when more and more code is flushed from the cache.</p>
<p>This problem is mostly mainfested with tiered compilation since we<br>
compile and reclaim a lot more code. A clear symptom is when the VM<br>
has stopped compiling even though it reports it has enough free code<br>
cache. The problem is worse with big codecaches since the freelist<br>
will be more fragmented and get much longer before finding a continous<br>
block.</p>
<p>Workaround: Turn of code cache flushing.</p>
<p>Solution is probably not to require continous free memory. The cause<br>
for the threshold is to gaurantee space for adapters, and they are<br>
usually small and will fit anyway.</p>
</blockquote>
<p>这个结论大致上认为：<br>
如果 uncommited codecache memory（未提交 codecache 内存）小于 the the size of the<br>
total memory on the freelist（这个设计很像 InnoDB 的 free list），JVM会去查找 freelist 寻找 largest block。姑且认为，这是一个线性数据结构。如果查找的结果，largest block 小于一个法定配置  CodeCacheMinimumFreeSpace (1,5M，comment 里的说法是 500k) ，JVM就会不安地 halt 住 all compilation，并且开始 flushing code cache。这个 flushing 第一持有锁，第二目标是构造一块连续的内存，大于等于 CodeCacheMinimumFreeSpace。因为 complier 是多线程的，但锁的存在让这个iterating fully serialized，所以 lock centention 出现了，因为 code cache 被清理了，所以 cpu utilization 会飙得非常高。这时候光看 JVM的内存状态诊断会发现，其实还有 enough free code cache。大的code cache 碎片化更严重，所以并不一定能解决这个问题。</p>
<p>一个潜在的解法是：允许 code cache 在非连续内存上工作。</p>
<p>这类问题不易复现的<a target="_blank" rel="noopener" href="https://bugs.openjdk.java.net/browse/JDK-8074288">原因之一</a>是：</p>
<blockquote>
<p>A DESCRIPTION OF THE PROBLEM :<br>
1.7 JVM’s (starting with Java 1.7.0_4) set ReservedCodeCacheSize option to the default value of 48MB. Once the Code Cache size reaches<br>
this limit, JVM switches the hotspot off <em>forever</em>.</p>
<p>This results in the immediate performance decrease for all not yet<br>
“compiled” code and gradual “slow” performance decrease for already<br>
“compiled” code which was “too long” time in the cache and is removed<br>
from cache later.</p>
<p>Unfortunately there is no way back - once the JVM decides to switch to<br>
the interpreted mode, it never switches back even if the CodeCache<br>
memory is freed again.</p>
</blockquote>
<p>如果 code cache “满了”，JVM 会关闭 JIT，所以这个 flushing 在折磨完人以后不会再出现。而应该被放在 code cache 里的代码分支，突然会变得很慢很慢。</p>
<p>只有重启这台机器，然后通过压测能够复现这个问题。</p>
<p>出现这个问题的时候，cpu 的监控和 code cache 的监控的抖动是一致的。</p>
<p>code cache 的<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1408773">简介</a>，注意 jcmd、nmt 对 code、code heap、profiled method、non-profiled method 等方法的描述。</p>
<h1>线程池的父子任务互相等待，导致线程池耗尽，从 worker 线程池一直阻塞到</h1>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/wFePJPkGv5v34GpalGOkYw">一次线程池引发的线上故障分析</a></p>
<p>dubbo 有一个专门的消息线程池的线程被用尽了：Thread pool is EXHAUSTED，按照一般线程池的使用规律：核心线程-缓存队列-最大线程-拒绝。此时应该是最大线程已经被用尽了。</p>
<p>大线程池被小线程池给阻塞死了，因为小线程池太小，大线程池多大都不够用。而且线程池内还有孙任务和子任务互锁-子线程池太小就好像一把锁一样。</p>
<p>核心的逻辑悖论是：<strong>父线程也是用线程池执行的，父线程先进入线程池是必然的</strong>。子线程如果一条都进入不了线程池，必然导致线程池的死锁。</p>
<p>解决方案就是引入父子线程池，或者使用 CompletableFuture 默认的 <code>commonPool</code>。很多bug就是用单一线程池代替<code>commonPool</code>造成的。</p>
<p>这篇文章的结论要辩证地接受，ThreadPerTaskExecutor 是个很危险的线程池。如果使用<code>commonPool</code>则 <code>CompletableFuture#join</code>方法在进入阻塞之前，判断当前线程是 ForkJoinWorkerThread线程则会在满足条件时先尝试补偿线程，确保有足够的线程去保证任务可以正常执行，这个知识点很重要。</p>
<p>CompletableFuture内部包含两种默认线程池，当 ForkJoinPool#getCommonPoolParallelism() 大于1时使用 ForkJoinPool 的 commonPool 线程池，反之则使用内部类 ThreadPerTaskExecutor 执行任务。</p>
<ul>
<li>ThreadPerTaskExecutor每次执行都会创建线程，因此不会出现任务等待线程空闲的情况。</li>
<li>commonPool是 ForkJoinPool内部包含的默认线程池，一般情况下并行数为 cpu核心数-1。</li>
</ul>
<p>ForkJoinPool创建的线程为 ForkJoinWorkerThread 类型，而 ForkJoinPool#managedBlock判断当前线程是 ForkJoinWorkerThread 类型时会调用 tryCompensate 方法，该方法在特定情况下会去补偿线程确保任务正常执行完成。</p>
<p>CompletableFuture 线程池可以正常执行是因为使用 ThreadPerTaskExecutor 时每次都会创建新的线程，而使用 commonPool时，在 CompletableFuture#join 进入阻塞之前会去尝试补偿线程。但是也不是无限补偿，当补偿达到一定次数后就会抛出异常。</p>
<p>使用 CompletableFuture 的默认线程池之所以不会出现互等的情况，是因为提交任务时，如果内部使用的是 ThreadPerTaskExecutor 是会不断创建新线程的，不会因为进入队列阻塞等待被执行而陷入等待。而如果内部使用的是 commonPool则 CompletableFuture#join 方法在进入阻塞之前，判断当前线程是 ForkJoinWorkerThread 线程则会在满足条件时先尝试补偿线程，确保有足够的线程去保证任务可以正常执行。</p>
<h1>ES 扩容到错误的机器，引发频发降级</h1>
<ol>
<li>在 SSD 机器上得到的经验不一定适用于 SATA 机器，SATA 机器的存在最终会导致误申请。</li>
<li>在业务高峰时迁移大分片可能导致业务的平响上升。自动迁移要有高低峰的限制。</li>
</ol>
<h1>nginx 的配置模块 lru cache不够用，导致部分配置丢失，导致流量偏移，拖垮中心单元</h1>
<p>敏感配置如果不可降级，怎么做好冗余？</p>
<h1>MySQL 里使用 bigint 表达自增 id，但 Java 代码里使用 Integer，导致 ORM 映射失败</h1>
<p>所有的数据库字段，最好统一生成，不要自己手写，很容易出错。</p>
<h1>beandefinition 里面依赖 bean</h1>
<p>循环依赖导致 Spring 启动失败，或者出现未正确初始化的 bean（某些 xml 的占位符不能被正确替换）。</p>
<h1>高流量的时候，大量的 IO 线程在线程池里等待任务</h1>
<p>这个问题可以用 jstack 定位：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.magicliang</span><span class="hljs-selector-class">.Service-5-thread-95</span>  WAITING waiting on java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.SynchronousQueue<span class="hljs-variable">$TransferStack</span>@<span class="hljs-number">66</span>c0a24a<br>at sun<span class="hljs-selector-class">.misc</span><span class="hljs-selector-class">.Unsafe</span><span class="hljs-selector-class">.park</span> (Native Method)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.locks</span><span class="hljs-selector-class">.LockSupport</span><span class="hljs-selector-class">.park</span>  (LockSupport<span class="hljs-selector-class">.java</span>:<span class="hljs-number">175</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.SynchronousQueue<span class="hljs-variable">$TransferStack</span><span class="hljs-selector-class">.awaitFulfill</span> (SynchronousQueue<span class="hljs-selector-class">.java</span>:<span class="hljs-number">458</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.SynchronousQueue<span class="hljs-variable">$TransferStack</span><span class="hljs-selector-class">.transfer</span> (SynchronousQueue<span class="hljs-selector-class">.java</span>:<span class="hljs-number">362</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.SynchronousQueue</span><span class="hljs-selector-class">.take</span>   (SynchronousQueue<span class="hljs-selector-class">.java</span>:<span class="hljs-number">924</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ThreadPoolExecutor</span><span class="hljs-selector-class">.getTask</span>  (ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1067</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span><span class="hljs-selector-class">.ThreadPoolExecutor</span><span class="hljs-selector-class">.runWorker</span>    (ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">1127</span>)<br>at java<span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.concurrent</span>.ThreadPoolExecutor<span class="hljs-variable">$Worker</span><span class="hljs-selector-class">.run</span>   (ThreadPoolExecutor<span class="hljs-selector-class">.java</span>:<span class="hljs-number">617</span>)<br>at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.Thread</span>.run<br></code></pre></td></tr></table></figure>
<p>线程池最好可伸可缩。</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/12972918/why-does-park-unpark-have-60-cpu-usage">Why does park/unpark have 60% CPU usage?</a></p>
<h1>读取过大的包</h1>
<p>这个问题可以用 jstack 定位：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">java.net.SocketInputStream.socketRead0(Native Method)<br></code></pre></td></tr></table></figure>
<h1>线下的自动化测试用例数据失效</h1>
<p>导致不断地重试引发流量毛刺，这个问题可以从业务接口的监控提前检测到。</p>
<h1>hashset 需要 hashcode 才能set，但一个空对象不能放进 hashcode 里面</h1>
<p>所以一个不能正常调用 hashcode 的数据结构不一定能够构造出散列类型的 value，所以无法形成 entry。</p>
<h1>Spring 代理问题</h1>
<p>jacocoInit 会导致某些 config 被代理，代理的结果就是其 public 成员只能用 getter 来访问。</p>
<p>解法是改切点表达式：<code>and !execution(* com.magicliang..*jacocoInit(..))</code></p>
<p>AspectJBeanFactoryPostProcessor 对切点表达式的处理出错也可能导致问题。</p>
<h1>mvn deploy release 仓库</h1>
<p>污染了版本号，导致 jar 特定版本被污染。</p>
<h1>类路径冲突</h1>
<ol>
<li>maven 里多了引用，导致低版本的依赖顶掉了高版本的依赖。导致高版本的依赖 classnotfound，很不符合直觉。</li>
<li>某些错误的配置文件也顶掉了特定的配置文件（只有 Spring 才能 merge config，log4j2 不可以）。</li>
</ol>
<h1>性能优化</h1>
<p>串行查询变并行查询-阿姆达尔定律生效中。</p>
<p>压力测试会让我们知道我们以前理解不了的性能瓶颈。到底发生在客户端，还是缓存，还是数据库？随机流量会制造随机热点。了解流量特性才能做高可用设计。</p>
<h1>Circular Dependencies in Spring</h1>
<p><a target="_blank" rel="noopener" href="https://www.baeldung.com/circular-dependencies-in-spring">constructor injection</a>会导致问题：</p>
<blockquote>
<p>BeanCurrentlyInCreationException: Error creating bean with name<br>
‘circularDependencyA’: Requested bean is currently in creation: Is<br>
there an unresolvable circular reference?</p>
</blockquote>
<p>解法用setter注入：</p>
<ul>
<li>单例作用域的setter循环依赖，能够解决</li>
<li>单例作用域的构造器循环依赖，不能解决</li>
<li>prototype作用域的循环依赖，不能解决</li>
</ul>
<h1>有时候 g1 会做进行若干个无用的 eden ygc，stw得毫无意义</h1>
<p>After an evacuation failure, G1 sometimes issues young-only gcs (maybe more than one) with zero sized eden (which accomplish nothing) before doing a full gc.</p>
<p><a target="_blank" rel="noopener" href="https://bugs.openjdk.java.net/browse/JDK-8165150">JDK-8165150</a></p>
<h1>IEEE 754 浮点数问题</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 2 的 53 次方加 1</span><br>        <span class="hljs-type">long</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-number">9007199254740992L</span> +<span class="hljs-number">1</span>;<br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>        map.put(<span class="hljs-string">&quot;1&quot;</span>, l);<br>        System.out.println(JsonUtils.toJson(map));<br>    &#125;<br><span class="hljs-comment">// 原始输出：&#123;&quot;1&quot;:9007199254740993&#125;</span><br></code></pre></td></tr></table></figure>
<p>只要使用标准 JsonParser 就会观察到 Json 的数据精度被截断。</p>
<h1>16g的结算服务的gc时间比8g的账单服务的gc时间少</h1>
<p>因为对象分代状况不一样。</p>
<h1>JacksonCache 导致的 ygc 频繁和线程 blocked</h1>
<ol>
<li>DeSerializerCache 的存在在单例 mapper 里可能有用，但如果 mapper 不是单例的就会有巨大的问题。</li>
<li>初始化缓存需要调用： java.lang.reflect.Executable.java的方法declaredAnnotation() 是 synchronized 的。</li>
</ol>
<h1>CMS 频繁 Major GC</h1>
<p>cms 频繁 gc 不一定是老年代达到了 CMSInitiatingOccupancyFraction，也可能是 ygc 产生的 promotion 本身不足以被老年代容纳。</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a322309b1d90?utm_campaign=hugo&amp;utm_medium=reader_share&amp;utm_content=note&amp;utm_source=weixin-timeline&amp;from=timeline&amp;isappinstalled=1">一个有意思的CMS问题</a></p>
<h1>MetaSpace 频繁超过高位水位线</h1>
<ol>
<li>MetaspaceSize 意味着开始 gc。可以查看监控里的 loadingclass 的数量，来确认有没有问题。</li>
<li>NativeMemory = direct buffer + metaspace。</li>
<li>oom 有三种：heap error、metaspace error、gc overhead。</li>
</ol>
<blockquote>
<p>Heap   PSYoungGen      total 10752K, used 4419K<br>
[0xffffffff6ac00000, 0xffffffff6b800000, 0xffffffff6b800000)<br>
eden space 9216K, 47% used<br>
[0xffffffff6ac00000,0xffffffff6b050d68,0xffffffff6b500000)<br>
from space 1536K, 0% used<br>
[0xffffffff6b680000,0xffffffff6b680000,0xffffffff6b800000)<br>
to   space 1536K, 0% used<br>
[0xffffffff6b500000,0xffffffff6b500000,0xffffffff6b680000)   ParOldGen       total 20480K, used 20011K<br>
[0xffffffff69800000, 0xffffffff6ac00000, 0xffffffff6ac00000)<br>
object space 20480K, 97% used<br>
[0xffffffff69800000,0xffffffff6ab8add8,0xffffffff6ac00000)   Metaspace       used 2425K, capacity 4498K, committed 4864K, reserved<br>
1056768K<br>
class space   used 262K, capacity 386K, committed 512K, reserved 1048576K</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/considerations.html#typical_heap_printout">解释</a>：</p>
<blockquote>
<p>In the line beginning with Metaspace, the used value is the amount of<br>
space used for loaded classes. The capacity value is the space<br>
available for metadata in currently allocated chunks. The committed<br>
value is the amount of space available for chunks. The reserved value<br>
is the amount of space reserved (but not necessarily committed) for<br>
metadata. The line beginning with class space line contains the<br>
corresponding values for the metadata for compressed class pointers.</p>
</blockquote>
<h1>并发优化失败，回退问题</h1>
<p>用大漏斗代替小漏斗，用第三个线程池代替第二层 eventloop 的线程池。</p>
<p>但第三层的线程池的 blockingqueue 太长，线程放大过高的时候会导任务分配不均衡，先到达的任务占据了大多数的线程池，后到达的任务拆解出来的子线程进入了 blockingqueue（所以子任务和父任务公用一个线程池是很危险的，只有 ForkJoinPool  能够妥善地解决这个问题）。</p>
<p>对于子任务本身倾斜度极高的任务而言，阿姆达尔定律决定并发优化微乎其微。</p>
<p>并发的转置大漏斗的容量规划一定要设计好。</p>
<p>不得已而为之的时候，应该使用聚合查询。</p>
<h1>Jedis 使用单调钟却发现超时</h1>
<p>jedis 工作线程频繁阻塞，单调钟执行触发了超时。</p>
<p>BinaryJedisClusterMultiKeyCommand 单线程检查调用是否超时的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">// Interleave time checks and calls to execute in case</span><br>            <span class="hljs-comment">// executor doesn&#x27;t have any/much parallelism.</span><br><span class="hljs-keyword">for</span> (Future&lt;Map&lt;<span class="hljs-type">byte</span>[], T&gt;&gt; task : tasks) &#123;<br>                <span class="hljs-built_in">this</span>.multiCommandExecutor.execute((Runnable) task);<br>                nanos = deadline - System.nanoTime();<br>                <span class="hljs-keyword">if</span> (nanos &lt;= <span class="hljs-number">0L</span>) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JedisException</span>(CLIENT_STATUS_BUSY_MESSAGE);<br>                &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>高吞吐导致大量 fgc</h1>
<p>mq 不断堆积，导致 ygc 和 fgc 次数非常多。<br>
而且产生了次生灾害，连接全死掉，必须通过重启解决。<br>
这其实暴露了 mq 客户端对连接的管理能力不够强。</p>
<h1><dependencyManagement>里找不到版本</h1>
<p>可以考虑引入某些 bom。</p>
<h1>mvcc 导致的事务隔离导致的查询错误</h1>
<p>同时退保导致退了子单却没有退总单。</p>
<ol>
<li>惊群多线程在事务里写后（非锁定）读</li>
<li>都读不到对方的写，导致判定错误，全部判定出错。</li>
</ol>
<p>解决方案，加锁，加数据库乐观锁（不太好，可能因为大家都兼容读共享锁，而导致升级为写互斥锁彼此死锁），或者加流程锁。</p>
<h1>MySQL 的时区问题</h1>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/chwilliam85/p/9528850.html">MySQL “java.lang.IllegalArgumentException: HOUR_OF_DAY: 2 -&gt; 3” 问题解析</a><br>
<a target="_blank" rel="noopener" href="https://bugs.mysql.com/bug.php?id=96276">Retrieval of DATETIME with value in DST lost hour causes error</a></p>
<p>在数据库连接串加上 &amp;serverTimezone=Asia/Shanghai 即可。</p>
<h1>mysql on duplicate key update 的时候触发 mybatis 的 bug</h1>
<p>根据<a target="_blank" rel="noopener" href="https://dev.mysql.com/doc/refman/8.0/en/insert-on-duplicate.html">官方文档</a>：</p>
<p>这种 bug 在自增主键上反而不容易出现，在并发插入唯一性索引的时候容易出现。</p>
<p>如果有多行冲突的话，每次 update 只能 update 一行而不是多行。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- If a=1 OR b=2 matches several rows, only one row is updated. In general, you should try to avoid using an ON DUPLICATE KEY UPDATE clause on tables with multiple unique indexes.</span><br><span class="hljs-operator">-</span> <span class="hljs-keyword">With</span> <span class="hljs-keyword">ON</span> DUPLICATE KEY <span class="hljs-keyword">UPDATE</span>, the affected<span class="hljs-operator">-</span><span class="hljs-keyword">rows</span> <span class="hljs-keyword">value</span> <span class="hljs-keyword">per</span> <span class="hljs-type">row</span> <span class="hljs-keyword">is</span> <span class="hljs-number">1</span> if the <span class="hljs-type">row</span> <span class="hljs-keyword">is</span> inserted <span class="hljs-keyword">as</span> a <span class="hljs-keyword">new</span> <span class="hljs-type">row</span>, <span class="hljs-number">2</span> if an existing <span class="hljs-type">row</span> <span class="hljs-keyword">is</span> updated<br><span class="hljs-keyword">UPDATE</span> t1 <span class="hljs-keyword">SET</span> c<span class="hljs-operator">=</span>c<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> a<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">OR</span> b<span class="hljs-operator">=</span><span class="hljs-number">2</span> LIMIT <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/mybatis/mybatis-3/issues/1523">Error occurred when I try to “INSERT INTO ~ ON DUPLICATE KEY UPDATE” with useGeneratedKeys. #1523</a></li>
<li><a target="_blank" rel="noopener" href="https://bugs.mysql.com/bug.php?id=90688">Statement.getGeneratedKeys() returns too many rows on INSERT … ON DUPLICATE KEY</a></li>
</ol>
<h1>not eligible for auto-proxying</h1>
<p>代理未成功，这个警告主要由 BeanPostProcessors 抛出。</p>
<h1>MySQL order by 性能优化</h1>
<p><a target="_blank" rel="noopener" href="https://www.percona.com/blog/2006/09/01/mysql-order-by-limit-performance-optimization/">MySQL ORDER BY LIMIT Performance Optimization</a></p>
<h1>Spring Context 在JUnit 下的加载顺序</h1>
<p>JUnitRunners -&gt; spring context junit -&gt; spring.test.context.support -&gt; loadContext:60, AbstractGenericContextLoader -&gt; refresh:531, AbstractApplicationContext -&gt; invokeBeanFactoryPostProcessors:705, AbstractApplicationContext -&gt; invokeBeanDefinitionRegistryPostProcessors:275, PostProcessorRegistrationDelegate -&gt; postProcessBeanDefinitionRegistry:232, ConfigurationClassPostProcessor -&gt; processConfigBeanDefinitions:327, ConfigurationClassPostProcessor -&gt; loadBeanDefinitionsForConfigurationClass:144, ConfigurationClassBeanDefinitionReader -&gt; loadBeanDefinitions:188, AbstractBeanDefinitionReader -&gt; registerBeanDefinitions:96, DefaultBeanDefinitionDocumentReader -&gt; BeanDefinitionParser</p>
<p>GenericApplicationContext</p>
<p>MergedContextConfiguration</p>
<p>beanDefinitions == bean<br>
beafactory = registry</p>
<h1>使用自定义的 PropertiesPlaceholderResolver 却导致 property 占位符填充不正常</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">PlaceholderResolver</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析配置信息</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> props</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title function_">resolve</span><span class="hljs-params">(Properties props)</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CustomizedPropertyPlaceholderConfigurer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">PropertyPlaceholderConfigurer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, String&gt; ctxPropertiesMap;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Properties props;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object <span class="hljs-title function_">getContextProperty</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-keyword">return</span> ctxPropertiesMap.get(name);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getPropertyString</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ctxPropertiesMap.get(name);<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> obj.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Properties <span class="hljs-title function_">getProps</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> props;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">getPropertyString</span><span class="hljs-params">(String name, String def)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ctxPropertiesMap.get(name);<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> def;<br>        &#125;<br>        <span class="hljs-keyword">return</span> obj.toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">getPropertyInt</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ctxPropertiesMap.get(name);<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.valueOf(obj.toString());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Boolean <span class="hljs-title function_">getPropertyBoolean</span><span class="hljs-params">(String name)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ctxPropertiesMap.get(name);<br>        <span class="hljs-keyword">if</span> (obj != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> Boolean.parseBoolean(obj.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title function_">getPropertyInt</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> def)</span> &#123;<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">obj</span> <span class="hljs-operator">=</span> ctxPropertiesMap.get(name);<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> def;<br>        &#125;<br>        <span class="hljs-keyword">return</span> Integer.valueOf(obj.toString());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processProperties</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props)</span> <span class="hljs-keyword">throws</span> BeansException &#123;<br>        <span class="hljs-built_in">super</span>.processProperties(beanFactoryToProcess, props);<br>        ctxPropertiesMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>        <span class="hljs-keyword">for</span> (Object key : props.keySet()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">keyStr</span> <span class="hljs-operator">=</span> key.toString();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> props.getProperty(keyStr);<br>            ctxPropertiesMap.put(keyStr, value);<br>        &#125;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">PropertiesPlaceholderResolver</span>().parse(ctxPropertiesMap);<br>        <span class="hljs-built_in">this</span>.props = props;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertiesPlaceholderResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">PlaceholderResolver</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_PLACEHOLDER_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;$&#123;&quot;</span>;<span class="hljs-comment">// 默认占位符前缀</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">DEFAULT_PLACEHOLDER_SUFFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#125;&quot;</span>;<span class="hljs-comment">// 默认占位符后缀</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">placeholderPrefix</span> <span class="hljs-operator">=</span> DEFAULT_PLACEHOLDER_PREFIX;<span class="hljs-comment">// 占位符前缀</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">placeholderSuffix</span> <span class="hljs-operator">=</span> DEFAULT_PLACEHOLDER_SUFFIX;<span class="hljs-comment">// 占位符后缀</span><br>    <span class="hljs-keyword">private</span> Properties config;<br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; visitedPlaceholders = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;String&gt;();<span class="hljs-comment">// 存放已访问的占位符，用于判断是否循环调用</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Map&lt;String, String&gt; <span class="hljs-title function_">resolve</span><span class="hljs-params">(Properties props)</span> &#123;<br>        Map&lt;String, String&gt; configure = readConfigure(props);<br>        <span class="hljs-built_in">this</span>.parse(configure);<br>        <span class="hljs-keyword">return</span> configure;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 读取配置</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, String&gt; <span class="hljs-title function_">readConfigure</span><span class="hljs-params">(Properties properties)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == properties) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;configure file is Null!&quot;</span>);<br>        &#125;<br>        Map&lt;String, String&gt; prop = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, String&gt;();<br>        <span class="hljs-keyword">if</span> (properties.isEmpty()) &#123;<br>            <span class="hljs-keyword">return</span> prop;<br>        &#125;<br>        Set&lt;Object&gt; keySet = properties.keySet();<br>        Iterator&lt;Object&gt; keys = keySet.iterator();<br>        <span class="hljs-keyword">while</span> (keys.hasNext()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.valueOf(keys.next());<br>            <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> properties.getProperty(key);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> != value) &#123;<br>                prop.put(key, value);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> prop;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析配置</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">parse</span><span class="hljs-params">(Map&lt;String, String&gt; config)</span> &#123;<br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, String&gt; entry : config.entrySet()) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">val</span> <span class="hljs-operator">=</span> parseValue(entry.getKey(), entry.getValue(), config);<br>            entry.setValue(val);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">parseValue</span><span class="hljs-params">(String key, String val, Map&lt;String, String&gt; config)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> val;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">beginIndex</span> <span class="hljs-operator">=</span> value.indexOf(placeholderPrefix);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">endIndex</span> <span class="hljs-operator">=</span> value.indexOf(placeholderSuffix);<br>        <span class="hljs-keyword">if</span> (beginIndex != -<span class="hljs-number">1</span> &amp;&amp; endIndex != -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">placeHolder</span> <span class="hljs-operator">=</span> value.substring(beginIndex, endIndex + placeholderSuffix.length());<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">placeHolderName</span> <span class="hljs-operator">=</span> value.substring(beginIndex + placeholderPrefix.length(), endIndex);<br>            <span class="hljs-keyword">if</span> (isCircleReferece(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>().append(key).append(placeHolderName))) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;Circular placeholder reference &#x27;&quot;</span> + placeHolder + <span class="hljs-string">&quot;&#x27; in property definitions&quot;</span>);<br>            &#125;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">placeHolderReplace</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">if</span> (config.get(placeHolderName) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (System.getProperty(placeHolderName) != <span class="hljs-literal">null</span>) &#123;<br>                    placeHolderReplace = System.getProperty(placeHolderName);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                placeHolderReplace = config.get(placeHolderName);<br>            &#125;<br>            value = value.replace(placeHolder, placeHolderReplace);<br>            value = parseValue(key, value, config);<br>        &#125;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断占位符是否循环引用</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCircleReferece</span><span class="hljs-params">(StringBuilder placeholder)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (count &lt; <span class="hljs-number">2</span>) &#123;<br>            count++;<br>            <span class="hljs-keyword">if</span> (!visitedPlaceholders.add(placeholder.reverse().toString())) &#123;<br>                <span class="hljs-comment">// 循环引用</span><br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (count != <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPlaceholderPrefix</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> placeholderPrefix;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPlaceholderPrefix</span><span class="hljs-params">(String placeholderPrefix)</span> &#123;<br>        <span class="hljs-built_in">this</span>.placeholderPrefix = placeholderPrefix;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getPlaceholderSuffix</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> placeholderSuffix;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPlaceholderSuffix</span><span class="hljs-params">(String placeholderSuffix)</span> &#123;<br>        <span class="hljs-built_in">this</span>.placeholderSuffix = placeholderSuffix;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> Properties <span class="hljs-title function_">getConfig</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> config;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setConfig</span><span class="hljs-params">(Properties config)</span> &#123;<br>        <span class="hljs-built_in">this</span>.config = config;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<h1>trade 重复交易问题</h1>
<p>一个业务事务没有校验在途的支付交易功能，导致事件驱动后重复执行交易。</p>
<p>在途支付要插入数据库，而且要有幂等生成和幂等检查的流程。</p>
<h1>创建不了 appender，所以导致appenderref 失败</h1>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">14</span>:<span class="hljs-number">05</span>:<span class="hljs-number">10</span>,<span class="hljs-number">732</span> <span class="hljs-selector-tag">main</span> ERROR Cannot access RandomAccessFile java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.FileNotFoundException</span>: /opt/logs/mobile/xxx<span class="hljs-selector-class">.log</span><br><br>java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.FileNotFoundException</span>: /opt/logs/mobile/xxx<span class="hljs-selector-class">.log</span>(No such file or directory)<br><br>    at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.RandomAccessFile</span><span class="hljs-selector-class">.open0</span>(Native Method)<br><br>    at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.RandomAccessFile</span><span class="hljs-selector-class">.open</span>(RandomAccessFile<span class="hljs-selector-class">.java</span>:<span class="hljs-number">316</span>)<br><br>    at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.RandomAccessFile</span>.&lt;init&gt;(RandomAccessFile<span class="hljs-selector-class">.java</span>:<span class="hljs-number">243</span>)<br><br>    at java<span class="hljs-selector-class">.io</span><span class="hljs-selector-class">.RandomAccessFile</span>.&lt;init&gt;(RandomAccessFile<span class="hljs-selector-class">.java</span>:<span class="hljs-number">124</span>)<br><br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.log4j</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.rolling</span>.RollingRandomAccessFileManager<span class="hljs-variable">$RollingRandomAccessFileManagerFactory</span><span class="hljs-selector-class">.createManager</span>(RollingRandomAccessFileManager<span class="hljs-selector-class">.java</span>:<span class="hljs-number">182</span>)<br><br><span class="hljs-number">2020</span>-<span class="hljs-number">07</span>-<span class="hljs-number">28</span> <span class="hljs-number">14</span>:<span class="hljs-number">05</span>:<span class="hljs-number">10</span>,<span class="hljs-number">741</span> <span class="hljs-selector-tag">main</span> ERROR Unable to invoke factory method <span class="hljs-keyword">in</span> class class org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.log4j</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.appender</span><span class="hljs-selector-class">.RollingRandomAccessFileAppender</span> <span class="hljs-keyword">for</span> element RollingRandomAccessFile. java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.InvocationTargetException</span><br><br>    at sun<span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke0</span>(Native Method)<br><br>    at sun<span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.NativeMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(NativeMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">62</span>)<br><br>    at sun<span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.DelegatingMethodAccessorImpl</span><span class="hljs-selector-class">.invoke</span>(DelegatingMethodAccessorImpl<span class="hljs-selector-class">.java</span>:<span class="hljs-number">43</span>)<br><br>    at java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.reflect</span><span class="hljs-selector-class">.Method</span><span class="hljs-selector-class">.invoke</span>(Method<span class="hljs-selector-class">.java</span>:<span class="hljs-number">498</span>)<br><br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.log4j</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.plugins</span><span class="hljs-selector-class">.util</span><span class="hljs-selector-class">.PluginBuilder</span><span class="hljs-selector-class">.build</span>(PluginBuilder<span class="hljs-selector-class">.java</span>:<span class="hljs-number">132</span>)<br><br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.log4j</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.AbstractConfiguration</span><span class="hljs-selector-class">.createPluginObject</span>(AbstractConfiguration<span class="hljs-selector-class">.java</span>:<span class="hljs-number">942</span>)<br><br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.log4j</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.AbstractConfiguration</span><span class="hljs-selector-class">.createConfiguration</span>(AbstractConfiguration<span class="hljs-selector-class">.java</span>:<span class="hljs-number">882</span>)<br><br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.log4j</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.AbstractConfiguration</span><span class="hljs-selector-class">.createConfiguration</span>(AbstractConfiguration<span class="hljs-selector-class">.java</span>:<span class="hljs-number">874</span>)<br><br>    at org<span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.logging</span><span class="hljs-selector-class">.log4j</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.config</span><span class="hljs-selector-class">.AbstractConfiguration</span><span class="hljs-selector-class">.doConfigure</span>(AbstractConfiguration<span class="hljs-selector-class">.java</span>:<span class="hljs-number">498</span>)<br>    <br>Caused by: java<span class="hljs-selector-class">.lang</span><span class="hljs-selector-class">.IllegalStateException</span>: ManagerFactory <span class="hljs-selector-attr">[org.apache.logging.log4j.core.appender.rolling.RollingRandomAccessFileManager$RollingRandomAccessFileManagerFactory@196a42c3]</span> unable to create manager <span class="hljs-keyword">for</span><br></code></pre></td></tr></table></figure>
<h1>日志性能问题</h1>
<h2 id="如果只是寻求日志异步化-log4j2-提供几个方案">如果只是寻求日志异步化，log4j2 提供几个方案</h2>
<ul>
<li>全局异步化 ：使用 Log4jContextSelector=org.apache.logging.log4j.core.async.AsyncLoggerContextSelector</li>
<li>局部异步化：</li>
<li>使用异步的 logger asyncAppender</li>
<li>使用异步的 appender asyncLogger</li>
</ul>
<h2 id="为什么不推荐使用全局异步化？">为什么不推荐使用全局异步化？</h2>
<p>全局异步化依赖于 Disruptor。</p>
<p>Disruptor 有两个缺点：</p>
<ul>
<li>它的 ring buffer 可能导致 OOM，而大部分的人都不熟悉它的性能调优（包括我在内）。</li>
<li>有些公司的中间件和日志组件没有打通和继承好 Disruptor，所以异步化可能会丢的东西都可能会丢（包括但不限于压测标记、mtraceid）。</li>
</ul>
<h2 id="不要使用-console">不要使用 console</h2>
<p>console里大量使用 synchronize，高并发时可能导致线程阻塞、请求堆积，进而产生其他雪崩问题。</p>
<h1>没有事务</h1>
<p>transactionManager 和 sessionFactory 没有使用同样抽象层次的 datasource。</p>
<h1>批量插入数据，导致 mybatis 报错</h1>
<p>参考： <a target="_blank" rel="noopener" href="https://www.it610.com/article/1296022583187152896.htm">批量insertOrUpdate或replace-into使用useGeneratedKeys报错简单分析</a></p>
<h1>归档的几种策略</h1>
<ol>
<li>先执行单次任务：一次性先归 30 天:</li>
<li>策略静态化：写死时间</li>
<li>用写死时间的 sql 查出最后一个 id。</li>
<li>用写死时间的 sql + and id &lt;= “最后一个 id” 生成一个一次性运行的任务。跑几天。</li>
<li>建立周期性任务。</li>
</ol>
<h1>大数据 sql 里的 bigint 与 string</h1>
<p>已知：bigint 可以转化为 string 而不丢失信息，反过来则会丢失信息。</p>
<p>教训：</p>
<ul>
<li>不要用隐式类型转换，要显式地这样做：</li>
<li>bigint &gt; bigint</li>
<li>string(bigint) &gt; string</li>
</ul>
<h1>运营配置错误</h1>
<p>缺乏内控流程。<br>
文案是错的，理赔是对的，证明元数据的配置和表达是割裂的。</p>
<h1>连接 KeepAlive 配置有误</h1>
<p>上游不优雅退出，下游大量报 Java IOException。</p>
<h1>因为 war 部署触发 log4j2 加载 jar 包全部信息引发线程阻塞</h1>
<blockquote>
<ol>
<li>JVM对反射的优化，导致该接口调用超过15次之后，异常栈中会有GeneratedMethodAccessor<N>类。</li>
<li>log4j2打印异常栈时，需要额外获取类的所属jar息，版本等额外信息，需要进行类加载。</li>
<li>在war包模式部署下，加载 GeneratedMethodAccessor<N> 类时，会同步线性扫描所有jar包，在此过程中会将该jar包中的所有文件构建成一个缓存（最耗时的部分），而jar包模式部署下则只需要一次文件读取，无此问题！</li>
<li>该缓存构建好之后，默认30s后就会被清理，导致之后的异常请求需要重新构建缓存，继续变慢。</li>
</ol>
</blockquote>
<h1>机器内部对环境判定错误</h1>
<p>导致mock程序在生产环境生效，产生不当调用甚至资损（未支付成功却误认为支付成功，这可能要求 mock 平台有留痕能力）。</p>
<ol>
<li>机器的环境判定一定要看容器的环境配置，去 agent 问。</li>
<li>通过编译脚本，在编译的时候把环境变量写到发布包里。</li>
<li>压测使用 mock 一定要把数据做好严格的隔离。</li>
</ol>
<h1>退款和关单乱序到达</h1>
<ol>
<li>没有加锁，没有并发控制，又退又关，造成资损。</li>
<li>要对不同流程加上对于同一个单据的短锁。</li>
</ol>
<h1>把天转成秒</h1>
<p>100年的天数转成秒，会导致 Integer 溢出。<br>
针对异常状况的兜底应当有斜率告警。<br>
要有调账机制。</p>
<h1>涉及外网的网关也可以连到外网的生产环境</h1>
<p>如果测试用例使用了真实的用户信息，测试订单发到了测试的gateway，测试的gateway发到外网的生产接口（比如外网的接口不分环境，或者误以为查询接口无需区分线上线下，或者误将交易当作查询接口）。</p>
<p>数据隔离和环境隔离要一起做。</p>
<h1>st 和 prod</h1>
<ol>
<li>代码版本不对。</li>
<li>交叉调用有可能导致逻辑不一致。</li>
<li>秘钥设计成一致的，很难通过验签拦截。特别要指出的是：线上线下的秘钥要专门隔离。</li>
</ol>
<p>参考：<a target="_blank" rel="noopener" href="https://ayonel.github.io/2020/03/09/log4j2-slow/">《一次log4j2的慢日志问题排查》</a></p>
<h1>ThreadLocal Context里携带过多的子上下文，子线程一直持有这些上下文，导致 fgc</h1>
<ol>
<li>上下文的主clear方法要完全清除对entry的引用。</li>
<li>子对象对context的引用要栈封闭。</li>
<li>子对象要慎用 InheritableThreadLocal，因为它会无意之中引用父线程的 InheritableThreadLocal 的 value。防止 ThreadLocal 内存泄漏的主要问题是，防止对 Value 的悬垂引用。</li>
</ol>
<h1>Spring 启动中数据源关闭的问题</h1>
<ol>
<li>Spring 中间件乱序启动，导致 Hystrix ConcurrencyStrategy自 重复注册</li>
<li>Hystrix ConcurrencyStrategy 在 ApplicationContextAware 里被手工注册，触发重复注册</li>
<li>Spring Context 启动失败</li>
<li>数据源关闭</li>
<li>刷数任务未关闭，导致 jdbc 异常。</li>
</ol>
<h1>没有开启 NettyIO 和平滑启动，导致 thrift client 启动大量时间消耗在 getConn 上</h1>
<p>突然打开灰度开关，导致 thrift client 所有连接都在 getConn，然后触发大量超时。</p>
<h1>无法弹性扩容，导致需要强依赖熔断降级</h1>
<p>zk 连接 sgagent 故障，导致 zk 无法更新，所有的云调度系统无法批量刷新配置信息，所有的拓扑变更（节点上线注册和离线）都无法执行，导致流量到来的时候无法处置。</p>
<p>这时候所有的对上接口的熔断和限流能力就尤为重要了，每个接口设计之初就要考虑好熔断和限流问题。</p>
<h1>Spring 在锁定 WebClassLoader 做字节码增强的时候，正好遇到 Web中间件自己也在锁定 WebClassLoader</h1>
<p>导致死锁。</p>
<h1>使用双查询条件导致 es build_scorer 耗时偏长</h1>
<p>keyword 使用跳表加速，但 integer 必须使用 bkdtree 排序。进行双条件查询的时候，integer 的查询会导致无序的 docId 大量进入内存，查询变得非常长。</p>
<p>ES 5.4 以后优化：</p>
<ul>
<li>结果集小：PointRangeQuery</li>
<li>结果集大：SortedSetDocValuesRangeQuery</li>
</ul>
<p>es 带有 explain 功能</p>
<h1>异步日志没有写 blocking = false</h1>
<p>大量打日志导致 long-mq。</p>
<h1>Netty 处理速度过慢</h1>
<p>导致输入编解码的缓冲区堆积过多数据，多次 Major GC 也无法回收内存，而吞吐会进一步变慢。</p>
<h1>Netty 的 inflate 缓冲区泄漏，导致 gc 异常</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/eclipse/jetty.project/issues/575">https://github.com/eclipse/jetty.project/issues/575</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> <span class="hljs-keyword">static</span> com.sun.btrace.BTraceUtils.*;<br><span class="hljs-keyword">import</span> com.sun.btrace.annotations.*;<br><br><span class="hljs-keyword">import</span> java.nio.ByteBuffer;<br><span class="hljs-keyword">import</span> java.lang.Thread;<br><br><span class="hljs-meta">@BTrace</span> <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BtracerInflater</span>&#123;<br> <span class="hljs-meta">@OnMethod(</span><br><span class="hljs-meta"> clazz=&quot;java.util.zip.Inflater&quot;,</span><br><span class="hljs-meta"> method=&quot;/.*/&quot;</span><br><span class="hljs-meta"> )</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">traceCacheBlock</span><span class="hljs-params">()</span>&#123;<br> println(<span class="hljs-string">&quot;Who call java.util.zip.Inflater&#x27;s methods :&quot;</span>);<br> jstack();<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>jdk8 会默认打开一些 internal cache，但 java9 修复了这个问题。</p>
<p>JarFile -&gt; ZipFile，ZipFile 会持有 Inflater，Inflater 会申请和持有堆外内存。在依赖的 jar包非常多的时候，会发生堆外内存泄漏。</p>
<h1>使用 stream 来优化 for 循环，但 Long 的 value 设值没有捕获异常</h1>
<p>对于原有的大 try catch 的分批重构需要仔细考察各个步骤的异常点，特别是更内部的异常要仔细看。</p>
<h1>在构造器里启动了线程，使用 run 而不是 start</h1>
<p>导致 context refresh 卡在倒数第二步，无法释放 startShutDownMonitor。</p>
<p>此时再启动了 Spring 自己的 shutdownhook，而 AbstractApplicationContext 的 close 也需要求 startShutDownMonitor。</p>
<p>这给我们一个启示，关闭线程可能从另一个视角访问启动的资源。</p>
<p>我们平时不注意在这两种看起来毫无关系的操作之间加锁，是因为 Spring 自身已经意识到了这一点，帮我们在外部加了锁。</p>
<h1>先 mkdir 生成一个目录，再试图用 ln -s 创建同一个目标目录</h1>
<p>第二个命令失败，软链接没有创建成功。日志挂载可以这样设计：</p>
<ol>
<li>设计 /data/log/${APP_NAME}。</li>
<li>从 1 生成 ${APP_PATH}/log 的软链接。</li>
<li>从 2 生成 ${APP_PATH}/logs 的软链接。</li>
<li>日志写入 2。</li>
<li>日志挂载的 volume 监控 1，log agent 读出日志。</li>
<li>挂载点必须是原始的目录，而不能是符号链接。</li>
</ol>
<h1>Play 里没有对 @ImplementedBy 加上 @Singleton</h1>
<p>导致配置对象实例在 Action 中被注入，进而导致内存溢出。</p>
<h1>Cos 没有加上内网地址</h1>
<p>内网访问和外网访问的逻辑是不一样的</p>
<h1>全部的拦截器拦截了不需要拦截的接口</h1>
<p>需要注意全拦截的表达式的逻辑</p>
<h1>header 不为空导致 Spring cors filter 工作不正常</h1>
<p>关键代码见 CorsUtils。</p>
<h1>搜索引擎同步延迟导致规则应用失败</h1>
<p>需要引入旁路主副本。</p>
<h1>ebean 为 @dbArray 的 null field 提供 emptyList</h1>
<p>导致无法判断未初始化，判空都失败。</p>
<h1>logfilter 过滤时没有处理好</h1>
<p>导致无法处理异步的 response body（只有 servlet 异步事件api 可以处理好它）和处理流式返回body（录制流出会导致空 body，而文件名可以 被header 的指定）。</p>
<p>好的 logfilter 要能读取二进制或者异步的 response。</p>
<h1>没有准备 @RequestBody 和 @Valid</h1>
<p>注入出错，解析出错。</p>
<h1>轮询算法使用 indexof 来判定位置</h1>
<p>nextPos = indexOf(lastUid) + 1</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> a b c a b c <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <br></code></pre></td></tr></table></figure>
<p>第二个 a 造成死循环：a b c a b c……</p>
<h1>ThreadPoolTaskExecutor 忘记加上 @Bean</h1>
<p>导致每个请求都带来一个 ThreadPoolTaskExecutor。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(name = &quot;executor&quot;)</span><br><span class="hljs-keyword">public</span> ThreadPoolTaskExecutor <span class="hljs-title function_">asyncServiceExecutor</span><span class="hljs-params">()</span> &#123;<br>    logger.info(<span class="hljs-string">&quot;start asyncServiceExecutor&quot;</span>);<br>    <span class="hljs-type">ThreadPoolTaskExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolTaskExecutor</span>();<br>    <span class="hljs-comment">//配置核心线程数</span><br>    executor.setCorePoolSize(<span class="hljs-number">4</span>);<br>    <span class="hljs-comment">//配置最大线程数</span><br>    executor.setMaxPoolSize(<span class="hljs-number">8</span>);<br>    <span class="hljs-comment">//配置队列大小</span><br>    executor.setQueueCapacity(MAX_REQUEST_IMPORT_PER_SEC);<br>    <span class="hljs-comment">//存活时长</span><br>    executor.setKeepAliveSeconds(<span class="hljs-number">10</span>);<br>    <span class="hljs-comment">//配置线程池中的线程的名称前缀</span><br>    executor.setThreadNamePrefix(<span class="hljs-string">&quot;thread-pool-&quot;</span>);<br><br>    <span class="hljs-comment">// rejection-policy：当pool已经达到max size的时候，如何处理新任务</span><br>    <span class="hljs-comment">// CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行</span><br>    executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.CallerRunsPolicy());<br>    <span class="hljs-comment">//执行初始化</span><br>    executor.initialize();<br>    <span class="hljs-keyword">return</span> executor;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>Cookie 没有加上 Path</h1>
<p>Play 的 Cookie 默认为 /，Spring 没有默认值。这导致 Spring 下 Cookie 不能重放。<br>
HttpOnly 同理。</p>
<h1>Spring MVC 不支持 application/javascript</h1>
<p>浏览器在 strict mime 检查的时候失败。<br>
解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">jsonpResult</span> <span class="hljs-operator">=</span><br>                    ServiceTag.SERVICE_TAG_LEADS.name() + <span class="hljs-string">&quot;(&quot;</span> + JacksonUtils.toJson(res) + <span class="hljs-string">&quot;)&quot;</span>;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">MediaType</span> <span class="hljs-variable">mediaType</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaType</span>(<span class="hljs-string">&quot;application&quot;</span>, <span class="hljs-string">&quot;javascript&quot;</span>);<br>            <span class="hljs-type">HttpHeaders</span> <span class="hljs-variable">headers</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpHeaders</span>();<br>            headers.setContentType(mediaType);<br>            headers.addAll(HttpHeaders.SET_COOKIE, Lists.newArrayList(mockLoginUserIdCookie.toString(),<br>                    noLoginCookie.toString()));<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseEntity</span>&lt;&gt;(jsonpResult, headers, HttpStatus.OK);<br></code></pre></td></tr></table></figure>
<h1>父子进程无法关闭</h1>
<ol>
<li><code>/bin/sh</code>作为 shebang 无法理解 kill sigterm。在docker里init进程也不会传递 kill 信号给子进程。</li>
<li>子进程没有 trap，收集不到父进程传过来的 kill。</li>
<li>父进程没有 wait，会导致僵尸。</li>
</ol>
<p>正确的做法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动业务进程</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;start biz process&quot;</span><br><span class="hljs-variable">$&#123;install_path&#125;</span>/bin/start.sh &amp; PID=$!<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;biz process started&quot;</span><br><br><span class="hljs-comment"># 等待程序启动</span><br><span class="hljs-built_in">sleep</span> 15<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start application <span class="hljs-variable">$PID</span> finished...&quot;</span><br><br><span class="hljs-comment"># 优化终止</span><br><span class="hljs-comment"># 处理信号</span><br><span class="hljs-function"><span class="hljs-title">handle_sig</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Received SIGNAL <span class="hljs-variable">$1</span> <span class="hljs-variable">$PID</span>&quot;</span> &gt;&gt; <span class="hljs-variable">$&#123;APP_PATH&#125;</span>/log/handleSig.<span class="hljs-built_in">log</span><br>    <span class="hljs-built_in">kill</span> -s <span class="hljs-variable">$1</span> <span class="hljs-variable">$PID</span><br>    <span class="hljs-built_in">wait</span> <span class="hljs-variable">$PID</span><br>&#125;<br><br><span class="hljs-comment"># trap 监听传递信号包装函数</span><br><span class="hljs-function"><span class="hljs-title">trap_sig</span></span>() &#123;<br>    <span class="hljs-keyword">for</span> sig <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span> ; <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;handle_sig <span class="hljs-variable">$sig</span>&quot;</span><br>        <span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;handle_sig <span class="hljs-variable">$sig</span>&quot;</span> <span class="hljs-variable">$sig</span><br>    <span class="hljs-keyword">done</span><br>&#125;<br><span class="hljs-comment"># trap的信号</span><br>trap_sig SIGINT SIGTERM SIGSEGV SIGUSR2<br><br><span class="hljs-comment"># 等待主进程回调执行完再退出</span><br><span class="hljs-built_in">wait</span> <span class="hljs-variable">$PID</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Leads application <span class="hljs-variable">$PID</span> ended...&quot;</span><br><span class="hljs-built_in">sleep</span> 30<br></code></pre></td></tr></table></figure>
<p>做法2：</p>
<p>启动真实的命令 <a target="_blank" rel="noopener" href="http://start.sh">start.sh</a>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-comment"># 限制core dump大小为4k，用于core dump监控</span><br><span class="hljs-built_in">ulimit</span> -c 4 -S<br><br><span class="hljs-comment"># 定义应用路径和配置</span><br>APP_PATH=<span class="hljs-string">&quot;/usr/local/services/app1&quot;</span><br>CONF_FILE=<span class="hljs-string">&quot;/usr/local/services/app1/conf/gopass.yaml&quot;</span><br>APP_NAME=<span class="hljs-string">&quot;app1&quot;</span><br><br><span class="hljs-comment"># 检查进程是否已运行</span><br>pid=`ps -f -C <span class="hljs-variable">$APP_NAME</span> | grep -w <span class="hljs-variable">$APP_NAME</span> | grep -v grep | <span class="hljs-built_in">wc</span> -l`<br><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;<span class="hljs-variable">$pid</span>&quot;</span> = <span class="hljs-string">&quot;0&quot;</span> ]; <span class="hljs-keyword">then</span><br>    <span class="hljs-comment"># 启动应用并记录PID</span><br>  <span class="hljs-built_in">nohup</span> <span class="hljs-built_in">env</span> NODE_IP=<span class="hljs-string">&quot;<span class="hljs-variable">$NODE_IP</span>&quot;</span> <span class="hljs-variable">$APP_PATH</span>/bin/<span class="hljs-variable">$APP_NAME</span> -c <span class="hljs-variable">$CONF_FILE</span> &gt;/dev/null 2&gt;&amp;1 &amp; PID=$!<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;started <span class="hljs-variable">$APP_NAME</span> <span class="hljs-variable">$PID</span>.&quot;</span><br><br>    <span class="hljs-comment"># 信号处理函数</span><br>    <span class="hljs-function"><span class="hljs-title">handle_sig</span></span>() &#123;<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Received SIGNAL <span class="hljs-variable">$1</span> <span class="hljs-variable">$PID</span>&quot;</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Received SIGNAL <span class="hljs-variable">$1</span> <span class="hljs-variable">$PID</span>&quot;</span> &gt;&gt; <span class="hljs-variable">$APP_PATH</span>/log/handleSig.<span class="hljs-built_in">log</span><br><br>        <span class="hljs-comment"># 查找实际进程ID</span><br>        lastpid=`ps -aux | grep <span class="hljs-variable">$APP_NAME</span> | grep -v grep | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span>`<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;lastpid <span class="hljs-variable">$lastpid</span>&quot;</span><br><br>        <span class="hljs-comment"># 转发信号给应用进程</span><br>        <span class="hljs-built_in">kill</span> -<span class="hljs-variable">$1</span> <span class="hljs-variable">$PID</span><br>        <span class="hljs-comment"># 等待子进程退出</span><br>        <span class="hljs-built_in">wait</span> <span class="hljs-variable">$PID</span><br>    &#125;<br><br>    <span class="hljs-comment"># 注册信号处理函数</span><br>    <span class="hljs-function"><span class="hljs-title">trap_sig</span></span>() &#123;<br>        <span class="hljs-keyword">for</span> sig <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span> ; <span class="hljs-keyword">do</span><br>            <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;handle_sig <span class="hljs-variable">$sig</span>&quot;</span><br>            <span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;handle_sig <span class="hljs-variable">$sig</span>&quot;</span> <span class="hljs-variable">$sig</span><br>        <span class="hljs-keyword">done</span><br>    &#125;<br><br>    <span class="hljs-comment"># 注册需要处理的信号</span><br>    trap_sig SIGINT SIGTERM SIGSEGV SIGUSR2<br><br>    <span class="hljs-comment"># 等待主进程退出</span><br>    <span class="hljs-built_in">wait</span> <span class="hljs-variable">$PID</span><br>    <span class="hljs-built_in">exit</span> 0<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;ERROR: <span class="hljs-variable">$APP_NAME</span> has been started:<span class="hljs-variable">$pid</span>&quot;</span><br><span class="hljs-built_in">exit</span> 1<br></code></pre></td></tr></table></figure>
<p>docker 的启动命令 docker_run.sh：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br><span class="hljs-built_in">source</span> /etc/profile<br><br><span class="hljs-comment"># 限制core文件大小为4k,用于进程coredump监控</span><br><span class="hljs-built_in">ulimit</span> -c 4 -S<br><br><span class="hljs-built_in">mkdir</span> /data/release<br><br><span class="hljs-comment"># 不同配置写入不同的值</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;prod&#x27;</span> &gt; /data/release/env<br><br><span class="hljs-comment"># 定义应用路径</span><br>APP_PATH=<span class="hljs-string">&quot;/usr/local/services/app1&quot;</span><br><br><span class="hljs-comment"># 启动应用进程</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;start <span class="hljs-variable">$APP_NAME</span> process&quot;</span><br><span class="hljs-comment"># 等价于：</span><br><span class="hljs-comment"># /usr/local/services/app1/bin/app1 -c /usr/local/services/app1/conf/gopass.yaml</span><br><span class="hljs-variable">$APP_PATH</span>/bin/start.sh &amp; PID=$!<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$APP_NAME</span> process started with PID <span class="hljs-variable">$PID</span>&quot;</span><br><br><span class="hljs-comment"># 等待应用启动</span><br><span class="hljs-built_in">sleep</span> 5<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start <span class="hljs-variable">$APP_NAME</span> application <span class="hljs-variable">$PID</span> finished...&quot;</span><br><br><span class="hljs-comment"># 信号处理函数</span><br><span class="hljs-function"><span class="hljs-title">handle_sig</span></span>() &#123;<br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Received SIGNAL <span class="hljs-variable">$1</span> <span class="hljs-variable">$PID</span>&quot;</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Received SIGNAL <span class="hljs-variable">$1</span> <span class="hljs-variable">$PID</span>&quot;</span> &gt;&gt; <span class="hljs-variable">$APP_PATH</span>/log/handleSig.<span class="hljs-built_in">log</span><br><br>    <span class="hljs-comment"># 转发信号给子进程</span><br>    <span class="hljs-built_in">kill</span> -<span class="hljs-variable">$1</span> <span class="hljs-variable">$PID</span><br>    <span class="hljs-comment"># 等待子进程退出</span><br>    <span class="hljs-built_in">wait</span> <span class="hljs-variable">$PID</span><br>&#125;<br><br><span class="hljs-comment"># 注册信号处理函数</span><br><span class="hljs-function"><span class="hljs-title">trap_sig</span></span>() &#123;<br>    <span class="hljs-keyword">for</span> sig <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;<span class="hljs-variable">$@</span>&quot;</span> ; <span class="hljs-keyword">do</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;handle_sig <span class="hljs-variable">$sig</span>&quot;</span><br>        <span class="hljs-built_in">trap</span> <span class="hljs-string">&quot;handle_sig <span class="hljs-variable">$sig</span>&quot;</span> <span class="hljs-variable">$sig</span><br>    <span class="hljs-keyword">done</span><br>&#125;<br><br><span class="hljs-comment"># 注册需要处理的信号</span><br>trap_sig SIGINT SIGTERM SIGSEGV SIGUSR2<br><br><span class="hljs-comment"># 等待子进程退出</span><br><span class="hljs-built_in">wait</span> <span class="hljs-variable">$PID</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$APP_NAME</span> application <span class="hljs-variable">$PID</span> ended...&quot;</span><br><span class="hljs-built_in">sleep</span> 5<br><br><br><span class="hljs-comment"># 这一段应该泡不到，暂时不考虑 nohup、trap 等多层父子进程托管的问题</span><br><span class="hljs-comment"># hold the container</span><br><span class="hljs-comment"># tail -f /usr/local/services/app1/conf/gopass.yaml</span><br></code></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="http://start.sh">start.sh</a> 和 docker_run.sh 分开，是为了在 <a target="_blank" rel="noopener" href="http://start.sh">start.sh</a> 之上多准备一个 <a target="_blank" rel="noopener" href="http://restart.sh">restart.sh</a>。</p>
<p>接下来到 dockerfile：</p>
<figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs docker"><span class="hljs-keyword">ENV</span> APP_PATH /usr/local/services/app1<br><br><span class="hljs-comment"># 创建目标路径并复制文件</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$&#123;APP_PATH&#125;</span> &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">chmod</span> 755 <span class="hljs-variable">$&#123;APP_PATH&#125;</span></span><br><br><span class="hljs-keyword">ENV</span> APP_NAME app1<br><span class="hljs-keyword">ENV</span> APP_PORT <span class="hljs-number">8111</span><br><br><span class="hljs-comment"># 提示所使用的端口</span><br><span class="hljs-keyword">EXPOSE</span> $&#123;APP_PORT&#125;<br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> <span class="hljs-variable">$&#123;APP_PATH&#125;</span></span><br><br><span class="hljs-comment"># 复制当前目录下的bin文件夹</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> bin <span class="hljs-variable">$&#123;APP_PATH&#125;</span>/bin</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> conf <span class="hljs-variable">$&#123;APP_PATH&#125;</span>/conf</span><br><br><span class="hljs-comment"># USER root</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> docker_run.sh /usr/bin/docker_run.sh</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> <span class="hljs-built_in">chmod</span> +x /usr/bin/docker_run.sh</span><br><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/usr/bin/docker_run.sh&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<p>最终进程间关系：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">init</span><span class="hljs-params">(PID <span class="hljs-number">1</span>: docker_run.sh)</span></span> <br>  → docker_run<span class="hljs-selector-class">.sh</span> <span class="hljs-number">1</span><br>    → start<span class="hljs-selector-class">.sh</span> <span class="hljs-number">35</span><br>      → <span class="hljs-built_in">app1</span>(实际业务进程) <span class="hljs-number">42</span><br></code></pre></td></tr></table></figure>
<p>在 docker 里已经看不见普通 init，进程号1本身就是entrypoint进程。在容器里感知不到进程0-scheduler。我们必须显示接管进程1，才能保证优雅关闭的信号最后走到 app1。</p>
<h1>bash 不识别 python 的 alias</h1>
<p>因为非交互式 shell 不支持 alias。</p>
<p>解决方法：使用一个 alias path，把它作为 path 的一部分。然后让 alias 作为这个 path 的软连接里出现。<code>sudo ln -sf /usr/bin/python3 /usr/bin/python</code></p>
<p><a target="_blank" rel="noopener" href="https://unix.stackexchange.com/questions/1496/why-doesnt-my-bash-script-recognize-aliases">《Why doesn’t my Bash script recognize aliases?》</a></p>
<h1>双配置难题 2 Configurations puzzle</h1>
<p>Spring的几个基础假设：</p>
<ul>
<li>任意@Bean 开头的方法，是一个工厂 bean 方法，它的调用流程是：
<ul>
<li>在调用任意的 @Bean 开头的方法之前，它依赖的 Configuration bean必须先初始化。</li>
<li>解析方法的参数bean：
<ul>
<li>调用构造器：适用于<code>@Component</code>类的Bean。</li>
<li>调用其他 <code>@Bean</code>方法。</li>
</ul>
</li>
<li>用参数 bean 调用方法。</li>
<li>把返回值注册为一个 bean。</li>
</ul>
</li>
<li>任意一个平凡 Bean  springConfiguration 的初始化流程是：
<ul>
<li>
<p>尝试通过 postProcessBeforeInstantiation 生成一个前代理：</p>
<ul>
<li>ask should skip（这是 ask advisor 1）：生成前代理以前要先列出当前 BeanFactory 里的 advisors（也就意味着所有的 MethodInterceptor 要先被找出来，装配出相应的 advisor），确认 springConfiguration 是否是一个 Aspect扩展点，是就skip。</li>
<li>对于大部分平凡 bean - 如 springConfiguration，不需要生成前代理-逻辑太复杂，先不解释。</li>
</ul>
</li>
<li>
<p>生成一个 bean 实例-但此时 bean 的构造没有 complete。</p>
</li>
<li>
<p>populateBean：注入所有的成员变量。</p>
</li>
<li>
<p>initialization：</p>
<ul>
<li>调用 postConstruct。</li>
<li>调用 afterPropertiesSet</li>
<li>调用 init 方法。</li>
</ul>
</li>
<li>
<p>尝试 postProcessAfterInitialization：</p>
<ul>
<li>再问一遍 should skip（这是 ask advisor 2）。</li>
<li>如果不shouldSkip，尝试 wrapIfNecessary 把它包装进一个 proxy（这是 ask advisor 3）。</li>
</ul>
</li>
</ul>
</li>
<li>任意一个 advisor 没有“尝试生成 postProcessBeforeInstantiation 一个前代理”这一过程。</li>
<li>任意一个  ask advisor 都是for循环，检索所有的 advisor 的构造。如果 advisor 构造不出来，则吞掉构造异常，把这个 advisor 相关的对象图涉及的 bean 都 destruct 掉，但这时候这些bean的构造器已经调用过了，而且因为这批对象图没有构造完成，所以下次需要从头开始通过构造器再调用一遍。</li>
<li>create Bean springConfiguration 会在一开始的时候就把 springConfiguration 设为 inCreation 状态，如果 springConfiguration 依赖于 Bar，而Bar 需要 ask advisor，advisor 又是 springConfiguration 里的 @Bean 开头的方法，又会尝试初始化 springConfiguration（即 1.a 提到的设定），而第二次尝试 create Bean springConfiguration 检查到 springConfiguration 的状态为 inCreation，就会抛出一个异常，毁掉这个初始化。</li>
<li>一个 @Configuration  bean 继承另一个 @Configuration  bean 以后，实际上 Spring 会初始化2个bean，但只会通过子类 bean 实例调用工厂方法，不会产生穿梭问题。</li>
</ul>
<p><img src="%E5%8F%8C%E9%85%8D%E7%BD%AE1.svg" alt="双配置1"><br>
<img src="%E5%8F%8C%E9%85%8D%E7%BD%AE2.svg" alt="双配置2"></p>
<p>结论：</p>
<ul>
<li>任意的 MethodInterceptor  的成员变量，可能被初始化一次，也可能被初始化无数次。因此：
<ul>
<li>所有的成员都应该是 @Lazy 的（最推荐的方案）。String 之类的基础类型是例外，首先它们是 final 的，不可用被 subClass，所以无法出现 lazyBean。其次是，它们也无法作为对象图的根。</li>
<li>所有依赖的成员的构造器都是幂等的，能抗无数次初始化。</li>
</ul>
</li>
<li>如果两个Configuration都有 @Bean 注解，那么 @Bean 注解带有的工厂方法可能会相互调用，产生奇怪的问题。如果条件允许，让 Configuration 类型互相继承也是一个好主意。</li>
<li>细心的读者已经发现了，任意一个 @Configuration  bean 是无法被自己生产的任意 advisor 环绕的，相当于一个裸 proxied instance（其他 advisor 仍然可以环绕这个 bean）。</li>
</ul>
<h1>枚举互相引用导致成员为空</h1>
<p><a target="_blank" rel="noopener" href="https://brickydev.com/posts/enum-circular-dependency-in-java/">https://brickydev.com/posts/enum-circular-dependency-in-java/</a></p>
<h1>Dozer 导致线上卡顿</h1>
<p>ReflectionUtils.findPropertyDescriptor 依赖于</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PropertyDescriptor</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> Class&lt;?&gt; getPropertyType() &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>es 查询被拒绝</h1>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;error&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;root_cause&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;search_phase_execution_exception&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;reason&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;phase&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;fetch&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;grouped&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;failed_shards&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;caused_by&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;es_rejected_execution_exception&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;reason&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;rejected execution of org.elasticsearch.common.util.concurrent.TimedRunnable@204d3d67 on QueueResizingEsThreadPoolExecutor[name = 1693273402005365932/search, queue capacity = 1000, min queue capacity = 1000, max queue capacity = 1000, frame size = 2000, targeted response rate = 1s, task execution EWMA = 335.7ms, adjustment amount = 50, org.elasticsearch.common.util.concurrent.QueueResizingEsThreadPoolExecutor@ae1b393[Running, pool size = 25, active threads = 25, queued tasks = 1195, completed tasks = 50356750]]&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;status&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">503</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>这种毛刺可能和瞬时io毛刺有关。有几种解决思路：</p>
<ol>
<li>调高线程数：在 cpu有富余的时候最简单。</li>
<li>调整 thread_pool.bulk.queue_size（文档写入队列大小，适用于5.6.4版本）、thread_pool.write.queue_size（文档写入队列大小，适用于6.4.3及以上版本）、thread_pool.search.queue_size（文档搜索队列大小）。让读写互相让步。</li>
<li>纵向扩展：在单一节点上加硬件。</li>
<li>横向扩展：加节点。</li>
</ol>
<p>在腾讯云上，1不被允许使用，而2被允许使用。<br>
3 和4 可以间接达成1，但如果只是瞬时毛刺，cpu/mem/io util 比较低的话，2也可以临时顶一下。<strong>queue的存在就是为了这种临时并发而设计出来的，使用旁路带宽也可以，并不一定要把总带宽加上去</strong>。</p>
<p>便宜的带宽量通常大，如果便宜的带宽用尽，则意味着系统必须 scale up/scale out了。</p>
<h1>left join 的时候没有提前做聚合</h1>
<p>a 表有多行，b表也有多行。</p>
<p>先把b表做聚合，但没有对a表做聚合。</p>
<p>对两个结果做 join，导致b表的结果被放大，放大以后再sum，导致数据大量增多。</p>
<p>解法：每张表把 join key 数据 aggregate 成一行，再join。</p>
<p>做这种设计的时候，要仔细思考：主表是一定有数据的，从表不一定有。</p>
<p>要join一起join。</p>
<h1>ws socket 双联</h1>
<p>ws是有状态连接。</p>
<p>微信sdk有bug，产生了两条物理连接。c持有物理连接1和2，而s1持有物理连接1，s2持有物理连接2。c往1推事件，1调用下游，下游回调到2，2往c回推事件，被c忽略。因为c的逻辑连接只有1。</p>
<p>解法：</p>
<ol>
<li>每次生成新的连接，要先断掉所有可能的连接，让最后的连接成为唯一的连接。</li>
<li>阻塞式重连，真正断联才重连。</li>
<li>在前端的日志里打出sessionid。后端不同服务器打出不同的服务器标识，让前端知道有状态连接的状态是什么。</li>
</ol>
<p>同一台机器，持有两条连接，也会有这样的问题-缩容不解决问题。</p>
<h1>过快过期的缓存，与过期的load函数</h1>
<p>缓存过期太快，导致load函数频繁穿透读数据库。load函数执行比较慢，导致 cpu 消耗在最底层的时候特别少（因为慢sql在等待io），但系统的输出时延很高。</p>
<h1>嵌套缓存死锁</h1>
<p>缓存的load方法里又调缓存。导致缓存自己的父子操作死锁。</p>
<h1>跑任务的时候没有处理好异步化问题</h1>
<ol>
<li>线程池太小，导致任务被主线程运行，这时候一个线程的异常就会导致主任务失败。所以主任务自己做好 catch 是重要的。</li>
<li>要让 context 不自动终止并退出，要让任务的执行全同步化并 catch 好。所以主动执行的任务要清楚context下什么地方是异步化的，context什么时候终止。</li>
</ol>
<h1>锁与标志位</h1>
<ol>
<li>在很多公司redis集群是有兜底超时时间的。</li>
<li>但在很多公司没有。</li>
<li>加标志位的超时可以很长，如果标志位支持直接覆写，没有 set nx 的语义会比较简单，这样标志位会成为不断增长延长的位。</li>
<li>锁的超时时间不能设计太长，因为发布一定会导致解锁丢失。这样产生的【黑窗口是需要补偿机制的】。</li>
<li>换锁一定会导致并发控制失效，新机器用新锁而老机器用老锁。这就是自发多线程调度的缺陷。如果使用集中式调度中间件，可以把这个问题交给他们处理。</li>
<li>标志位嵌套增加，是给系统增加更细的颗粒度细节，新发布的机器会受控制，而老机器不受控制，所以会有两种不同的行为，这里存在兼容问题。</li>
<li>嵌套标志位减少，则细颗粒度的控制行为会丢失，老机器更细而新机器更粗。如果可以丢弃更细的行为则系统设计无问题。</li>
</ol>
<h1>不被捕获的异常</h1>
<p>有时候诸如“bound must be greater than origin”的异常只有控制台才能看得到，在日志里看不到。如果流程意外中断而无日志，则可以考虑是不是发生了这类异常-特别是在线程池内发生的异常，<strong>退出更无声无息，所以线程池内的异常要注意捕获和记录</strong>。</p>
<h1>服务重启时大量空指针错误</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">java.util.concurrent.TimeoutException: <span class="hljs-literal">null</span><br>    at java.util.concurrent.CompletableFuture.timedGet(CompletableFuture.java:<span class="hljs-number">1784</span>)<br>    at java.util.concurrent.CompletableFuture.get(CompletableFuture.java:<span class="hljs-number">1928</span>)<br></code></pre></td></tr></table></figure>
<p>这意味着线程刚启动的时候内部的forkjoin线程池冷启动容易阻塞超时。</p>
<h1>使用静态变量来调整 feature toggle</h1>
<p>基于时间开始的特性开关是不适合用来赋值 static 变量的。因为类加载器只加载一次。<br>
正确的做法是使用 toggle 的时候实时计算。</p>
<h1>left join 的时候对 left join 的表的条件写在 join 之后</h1>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">a <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> b <span class="hljs-keyword">on</span> a.id<span class="hljs-operator">=</span>b.id <span class="hljs-keyword">where</span> a.dt<span class="hljs-operator">=</span><span class="hljs-number">20240801</span> <span class="hljs-keyword">AND</span> b.dt<span class="hljs-operator">=</span><span class="hljs-number">20240801</span><br></code></pre></td></tr></table></figure>
<p>最后的条件是错的。</p>
<p>如果要选择分区做左连接，需要</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">a <span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> b <span class="hljs-keyword">where</span> dt<span class="hljs-operator">=</span><span class="hljs-number">20240801</span>)t <span class="hljs-keyword">on</span> a.id<span class="hljs-operator">=</span>t.id <span class="hljs-keyword">where</span> a.dt<span class="hljs-operator">=</span><span class="hljs-number">20240801</span> <br></code></pre></td></tr></table></figure>
<h1>a b 表在内连接里做分区</h1>
<p>在优化前，内连接是直接求等来查，而且分区查询语句是并列在一起的，看起来一个查询很难同时用到 ab 两张物理表的索引。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span>  <span class="hljs-keyword">from</span> tbl_a a , tbl_b b <br><span class="hljs-keyword">where</span> a.id<span class="hljs-operator">=</span>b.id  <span class="hljs-keyword">and</span> a.con <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> a.date<span class="hljs-operator">=</span><span class="hljs-number">20240728</span> <span class="hljs-keyword">and</span> b.date<span class="hljs-operator">=</span><span class="hljs-number">20240728</span> <span class="hljs-keyword">and</span> b.greeting <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%head_content%&#x27;</span><br></code></pre></td></tr></table></figure>
<p>但优化的过程是把分区查询先查完，哪怕使用一个临时表来承接查询结果，也好过报错：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span>  <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tbl_a  <span class="hljs-keyword">where</span> <span class="hljs-type">date</span><span class="hljs-operator">=</span><span class="hljs-number">20240728</span>) a, <br>  (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tbl_b <span class="hljs-keyword">where</span> <span class="hljs-type">date</span><span class="hljs-operator">=</span><span class="hljs-number">20240728</span>) b <br><span class="hljs-keyword">where</span> a.id<span class="hljs-operator">=</span>b.id  <span class="hljs-keyword">and</span> a.con <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> b.greeting <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;%head_content%&#x27;</span><br></code></pre></td></tr></table></figure>
<p><strong>用更长的时间来换取更少的内存，如果要写联表查询，可以尝试把join去掉，用where的隐式join，但是把除了join以外的查询语句下推到子表查询里。</strong></p>
<p>错误为：</p>
<blockquote>
<p>Query threw SQLException:Code: 241, e.displayText() = DB::Exception:<br>
Memory limit (for query) exceeded: would use 9.32 GiB (attempt to<br>
allocate chunk of 4718848 bytes), maximum: 9.31 GiB:<br>
(avg_value_size_hint = 173.29541015625, avg_chars_size =<br>
198.3544921875, limit = 8192): (while reading column greeting): (while reading from part<br>
/data/clickhouse/clickhouse-server/store/0aa/0aaf2939-9927-4c36-8aaf-293999277c36/20240603_1_23_2/<br>
from mark 24 with max_rows_to_read = 8192): While executing<br>
MergeTreeThread (version 21.8.12.1)</p>
<p>2024.08.19 09:53:50.059401 [ 355361 ] {3b2967b5-bf01-4c61-bbe3-1b1966124220} <Error> executeQuery: Code:<br>
241, e.displayText() = DB::Exception: Memory limit (for query)<br>
exceeded: would use 9.32 GiB (attempt to allocate chunk of 6029696<br>
bytes), maximum: 9.31 GiB: (avg_value_size_hint = 130.3759994506836,<br>
avg_chars_size = 146.8511993408203, limit = 8192): (while reading<br>
column greeting): (while reading from part<br>
/data/clickhouse/clickhouse-server/store/0aa/0aaf2939-9927-4c36-8aaf-293999277c36/20240603_1_23_2/<br>
from mark 24 with max_rows_to_read = 8192): While executing<br>
MergeTreeThread (version 21.8.12.1) (from 11.163.8.64:15770) (in<br>
query: select distinct a.script_id, b.greeting from<br>
leads_db.chatbot_fmc_chat_day a,<br>
leads_db.chatbot_fmc_chat_groupmessage_day b where a.chat_id =<br>
b.chat_id and a.u_id = 45428689 and a.date between 20240813 and<br>
20240819 order by a.created_at desc), Stack trace (when copying this<br>
message, always include the lines below):</p>
</blockquote>
<p>注意看 in query。</p>
<h1>parallelStream 带来的异步化问题</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> executor.execute(() -&gt; &#123;<br>               <span class="hljs-comment">// 这个线程执行会导致丢失消息</span><br>            &#125;<br>    );<br>    <br>consumer.ack();<br></code></pre></td></tr></table></figure>
<p>解法：</p>
<ol>
<li>使用终端操作<br>
parallelStream()的大多数终端操作（如forEach, collect, reduce等）都是阻塞的。这意味着，当你调用这些操作时，它们会处理完所有元素后才返回。例如：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>List&lt;Integer&gt; doubled = list.parallelStream()<br>                            .map(i -&gt; i * <span class="hljs-number">2</span>)<br>                            .collect(Collectors.toList());<br>System.out.println(<span class="hljs-string">&quot;Completed: &quot;</span> + doubled);<br>在这个例子中，collect()是一个阻塞操作，它会等待所有的映射操作（map()）完成后才继续执行System.out.println()。<br></code></pre></td></tr></table></figure>
<ol start="2">
<li>使用 CountDownLatch<br>
如果你的 parallelStream() 操作是非终端操作，或者你需要在多个并行流之后执行一些操作，你可以使用CountDownLatch来同步：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(size);<br><br>list.parallelStream().forEach(i -&gt; &#123;<br>    <span class="hljs-comment">// 执行一些操作</span><br>    System.out.println(i * <span class="hljs-number">2</span>);<br>    latch.countDown(); <span class="hljs-comment">// 每完成一个元素，计数减一</span><br>&#125;);<br><br><span class="hljs-keyword">try</span> &#123;<br>    latch.await(); <span class="hljs-comment">// 等待直到所有元素处理完成</span><br>    System.out.println(<span class="hljs-string">&quot;All tasks completed.&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    Thread.currentThread().interrupt();<br>    System.out.println(<span class="hljs-string">&quot;Interrupted.&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<p>在这个例子中，每处理完一个元素，CountDownLatch的计数就减一。latch.await()会阻塞当前线程，直到计数器减到零。</p>
<ol start="3">
<li>使用CompletableFuture<br>
如果你想要更多的灵活性和控制，你可以使用CompletableFuture来处理并行流中的每个元素，并在所有的Future完成后继续执行：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);<br>List&lt;CompletableFuture&lt;Void&gt;&gt; futures = list.parallelStream()<br>    .map(i -&gt; CompletableFuture.runAsync(() -&gt; &#123;<br>        System.out.println(i * <span class="hljs-number">2</span>);<br>    &#125;))<br>    .collect(Collectors.toList());<br><br>CompletableFuture.allOf(futures.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">CompletableFuture</span>[<span class="hljs-number">0</span>])).join();<br>System.out.println(<span class="hljs-string">&quot;All tasks completed.&quot;</span>);<br>这里，每个元素的处理被封装在一个CompletableFuture中，CompletableFuture.allOf()等待所有的Future完成。<br></code></pre></td></tr></table></figure>
<h1>单例构造里抛出异常，导致单例始终不生成成功</h1>
<p>在 static 或者其他单例的流程里，带有下游依赖的构造器的调用，都是可能抛出异常的。如果不catch住异常很可能没有日志，也会频繁进入单例构造体。</p>
<h1>wait 被伪唤醒</h1>
<p>解法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> String <span class="hljs-title function_">receive</span><span class="hljs-params">()</span> &#123;<br>      <span class="hljs-comment">// 大部分的例子没有讲过为什么这个地方是必须的，实际上就算用来防止伪唤醒的。</span><br>      <span class="hljs-keyword">while</span> (transfer) &#123;<br>          <span class="hljs-keyword">try</span> &#123;<br>              wait();<br>          &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>              Thread.currentThread().interrupt(); <br>              System.err.println(<span class="hljs-string">&quot;Thread Interrupted&quot;</span>);<br>          &#125;<br>      &#125;<br><br>      <span class="hljs-comment">// 先修改条件变量</span><br>      transfer = <span class="hljs-literal">true</span>;<br>      <br>      <span class="hljs-type">String</span> <span class="hljs-variable">returnPacket</span> <span class="hljs-operator">=</span> packet;<br><br>     <span class="hljs-comment">// 再唤醒</span><br>      notifyAll();<br>      <span class="hljs-keyword">return</span> returnPacket;<br>  &#125;<br></code></pre></td></tr></table></figure>
<h1>已经有了一个清洗状态，仍然触发通话清洗</h1>
<p>缺乏终态设计思维，应该先问清楚是否允许从终态回撤回来。</p>
<p>如果不允许，那么哪些是不允许的，<strong>如果有必要，引入一个任务系统，围绕这个任务系统的状态来跟踪是否允许重新发起</strong>。</p>
<p>这个bug的问题就是删除了任务系统，以至于对于是否重新发起任务产生了错觉。有个任务系统还是好。</p>
<h1>文件名含有反斜杠导致 multipart 解析出错</h1>
<p><a target="_blank" rel="noopener" href="https://www.idc.net/help/238074/">multipart/mixed</a> 和 multipart/form-data 都使用part。</p>
<p>其中 multipart/mixed 使用混合格式为如下：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs nix">POST <span class="hljs-symbol">/someUrl</span><br><span class="hljs-params">Content-Type:</span> multipart<span class="hljs-symbol">/mixed</span><br><br><span class="hljs-operator">-</span>-edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp<br><span class="hljs-params">Content-Disposition:</span> form-data; <span class="hljs-attr">name</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;meta-data&quot;</span><br><span class="hljs-params">Content-Type:</span> application<span class="hljs-symbol">/json</span>; <span class="hljs-attr">charset</span><span class="hljs-operator">=</span>UTF-<span class="hljs-number">8</span><br><span class="hljs-params">Content-Transfer-Encoding:</span> <span class="hljs-number">8</span>bit<br><br>&#123;<br>    <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;value&quot;</span><br>&#125;<br><span class="hljs-operator">-</span>-edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp<br><span class="hljs-params">Content-Disposition:</span> form-data; <span class="hljs-attr">name</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;file-data&quot;</span>; <span class="hljs-attr">filename</span><span class="hljs-operator">=</span><span class="hljs-string">&quot;file.properties&quot;</span><br><span class="hljs-params">Content-Type:</span> text<span class="hljs-symbol">/xml</span><br><span class="hljs-params">Content-Transfer-Encoding:</span> <span class="hljs-number">8</span>bit<br>... File Data ...<br></code></pre></td></tr></table></figure>
<p>可以看出混合模式下文件的部分都是有文件名的，而参数部分是没有文件名的，spring 的<a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/web/webmvc/mvc-controller/ann-methods/multipart-forms.html">官方解决方案</a>是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">handle</span><span class="hljs-params">(<span class="hljs-meta">@RequestPart(&quot;meta-data&quot;)</span> MetaData metadata,</span><br><span class="hljs-params">        <span class="hljs-meta">@RequestPart(&quot;file-data&quot;)</span> MultipartFile file)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>但如果使用 getParameterMap，则需要取出 getParameterMap</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">parameterMap = request.getParameterMap();<br><br><span class="hljs-comment">// getParameterMap 的实现</span><br><br><span class="hljs-comment">// 这一段其实是用来解析 multipart/mixed 里没有文件名的value的</span><br>List&lt;FileItem&gt; items = upload.parseRequest(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServletRequestContext</span>(<span class="hljs-built_in">this</span>));<br><span class="hljs-keyword">for</span> (FileItem item : items) &#123;<br>    <span class="hljs-type">ApplicationPart</span> <span class="hljs-variable">part</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ApplicationPart</span>(item, location);<br>    parts.add(part);<br>    <span class="hljs-keyword">if</span> (part.getSubmittedFileName() == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> part.getName();<br>        value = part.getString(charset.name());<br>        parameters.addParameter(name, value);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// getSubmittedFileNamed 的视线  这时候如果一个文件是2\结尾的话</span><br><br> <span class="hljs-keyword">if</span> (fileName.indexOf(<span class="hljs-string">&#x27;\\&#x27;</span>) &gt; -<span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// This is a quoted-string</span><br>    fileName = HttpParser.unquote(fileName.trim());<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// This is a token</span><br>    fileName = fileName.trim();<br>  &#125;<br> <span class="hljs-keyword">return</span> fileName;<br> <br> <span class="hljs-comment">// unquote 的实现</span><br> <span class="hljs-comment">// Input (less surrounding quotes) ended with &#x27;\&#x27;. That is invalid so return null.</span><br></code></pre></td></tr></table></figure>
<p>框架就会把文件<code>2\</code>的二进制部分当成一个字符串参数写成 parameter value。这样我们就得到一个超大字符串。</p>
<p>对这个超大字符串做序列化的话，就可能直接导致<code>java.lang.OutOfMemoryError: Java heap space</code>。</p>
<p>跟踪过程需要使用arthas</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 观测调用栈</span><br><br>[arthas@14]$ trace com.magicliang.TraceIdFilter doFilter  -n 5 --skipJDKMethod <span class="hljs-literal">false</span><br><br>Press Q or Ctrl+C to abort.<br>Affect(class count: 1 , method count: 1) cost <span class="hljs-keyword">in</span> 1067 ms, listenerId: 2<br>`---ts=2024-10-09 15:21:35.455;thread_name=http-nio-18084-exec-2;<span class="hljs-built_in">id</span>=20;is_daemon=<span class="hljs-literal">true</span>;priority=5;TCCL=org.springframework.boot.web.embedded.tomcat.TomcatEmbeddedWebappClassLoader@4985cbcb<br>    `---[3545.892486ms] com.magicliang.TraceIdFilter:doFilter() [throws Exception]<br>        +---[0.00% 0.018533ms ] javax.servlet.http.HttpServletRequest:getQueryString() <span class="hljs-comment">#54</span><br>        +---[0.00% 0.015049ms ] javax.servlet.http.HttpServletRequest:getHeader() <span class="hljs-comment">#56</span><br>        +---[0.00% 0.113182ms ] java.util.UUID:randomUUID() <span class="hljs-comment">#60</span><br>        +---[0.00% 0.019305ms ] java.util.UUID:toString() <span class="hljs-comment">#60</span><br>        +---[0.01% 0.204589ms ] java.lang.String:replaceAll() <span class="hljs-comment">#60</span><br>        +---[0.00% 0.06099ms ] org.slf4j.MDC:put() <span class="hljs-comment">#60</span><br>        +---[0.00% 0.011841ms ] java.lang.StringBuilder:&lt;init&gt;() <span class="hljs-comment">#62</span><br>        +---[0.00% 0.035214ms ] javax.servlet.http.HttpServletRequest:getRequestURL() <span class="hljs-comment">#62</span><br>        +---[0.00% min=0.010585ms,max=0.02034ms,total=0.030925ms,count=2] java.lang.StringBuilder:append() <span class="hljs-comment">#62</span><br>        +---[0.00% 0.010128ms ] java.lang.StringBuilder:toString() <span class="hljs-comment">#62</span><br>        +---[29.02% 1029.140713ms ] javax.servlet.http.HttpServletRequest:getParameterMap() <span class="hljs-comment">#63</span><br>        +---[0.00% 0.059128ms ] javax.servlet.http.HttpServletRequest:getHeaderNames() <span class="hljs-comment">#64</span><br>        +---[0.00% 0.011504ms ] java.util.LinkedHashMap:&lt;init&gt;() <span class="hljs-comment">#65</span><br>        +---[0.01% min=0.003391ms,max=0.011622ms,total=0.184711ms,count=45] java.util.Enumeration:hasMoreElements() <span class="hljs-comment">#66</span><br>        +---[0.01% min=0.003621ms,max=0.013577ms,total=0.242376ms,count=44] java.util.Enumeration:nextElement() <span class="hljs-comment">#67</span><br>        +---[0.01% min=0.004387ms,max=0.022983ms,total=0.29524ms,count=44] javax.servlet.http.HttpServletRequest:getHeader() <span class="hljs-comment">#68</span><br>        +---[0.01% min=0.003608ms,max=0.02086ms,total=0.236318ms,count=44] java.util.Map:put() <span class="hljs-comment">#68</span><br>        +---[0.00% 0.02143ms ] javax.servlet.http.HttpServletRequest:getMethod() <span class="hljs-comment">#71</span><br>        +---[0.01% 0.352369ms ] com.magicliang.common.util.JsonUtil:toJsonStr() <span class="hljs-comment">#71</span><br>        +---[0.00% 0.012586ms ] java.util.Map:isEmpty() <span class="hljs-comment">#72</span><br>        +---[0.00% 0.005381ms ] java.lang.StringBuilder:&lt;init&gt;() <span class="hljs-comment">#72</span><br>        +---[0.00% 0.007702ms ] java.lang.StringBuilder:append() <span class="hljs-comment">#72</span><br>        +---[70.88% 2513.212256ms ] com.magicliang.common.util.JsonUtil:toJsonStr() <span class="hljs-comment">#72 [throws Exception]</span><br>        `---throw:java.lang.OutOfMemoryError <span class="hljs-comment">#-1 [Java heap space]</span><br>        <br><span class="hljs-comment"># 观测返回值</span><br>[arthas@14]$ watch javax.servlet.ServletRequest getParameterMap <span class="hljs-string">&#x27;&#123;params,returnObj,throwExp&#125;&#x27;</span>  -n 3  -x 3<br>Press Q or Ctrl+C to abort.<br>Affect(class count: 9 , method count: 4) cost <span class="hljs-keyword">in</span> 810 ms, listenerId: 3<br>method=org.apache.catalina.connector.Request.getParameterMap location=AtExit<br>ts=2024-10-09 15:22:53.912; [cost=357.263226ms] result=@ArrayList[<br>    @Object[][isEmpty=<span class="hljs-literal">true</span>;size=0],<br>    @ParameterMap[<br>        @String[files]:@String[][<br>            @String[ Object size exceeds size <span class="hljs-built_in">limit</span>: 10485760, try to specify -M size_limit <span class="hljs-keyword">in</span> your <span class="hljs-built_in">command</span>, check the <span class="hljs-built_in">help</span> <span class="hljs-built_in">command</span> <span class="hljs-keyword">for</span> more.<br><br></code></pre></td></tr></table></figure>
<h1>单一用户提交 qps 过高，导致消息队列被占满</h1>
<p>用户购买大量配额，一次性提交了大量的请求，但公用 topic 是无法被动态扩容的，所以这批请求阻塞了其他人。</p>
<p>解法：所有请求先本地落库，然后按照任务的优先级和饥饿程度动态调度。</p>
<p>这里面有一个扇出的问题的取舍。</p>
<p>有些模型天然就是推或者拉的，经典模型：</p>
<p>1 当推产生瓶颈，先只存储，然后想办法复制或者异步从存储里转移到通讯里（线程主动发 mq）。这样做在低扇出（即消费者广播范围不巨大）场景下足够了。<br>
2 如果主动转移或者广播成本太大，想办法只让用户读的时候，才查存储，实现错峰。这时候可以1在存储完成以后高速复制提高lazy查询的速率，2是也可以把推拉结合起来，延迟合并，如果拉遇到问题，又要回到1的推方案。</p>
<p>归根结底是，<strong>如果任意让一方执行会碰触瓶颈，就把主动权交到另一方去。</strong></p>
<h1>多任务处理系统前任务直接终止主任务</h1>
<p>任务有 init -&gt; terminate 状态。但任务中途不满足任务的时候，全流程是 init -&gt; terminate  -&gt; terminate -&gt; final 的方式执行的。并行任务没有办法直接确认其他任务的 terminate 是不是第二个 terminate，而又不执行另一个任务的检查操作，于是误判了任务全局 teminante。</p>
<p>这样多任务分别分离执行的好处是每个任务的颗粒度是由自身控制的。这样是好的范式。</p>
<p>但错误在于使用了同样的 terminate 状态，而无法区分是真 terminate 还是假terminate。</p>
<p>解法：关键是拥有<strong>检查所有任务都执行过了，最终失败的能力</strong>。</p>
<ol>
<li>每个任务在启动和结束的时候准备一个计数器，任务完成减少计数器，只有最后一个任务能让属于自身的计数器归零，成为终结任务。这个方法不好。这个方案上线的时候，需要考虑兼容问题，<strong>因为在途任务是无计数器的，就全程不带有计数器；新版本带有计数器，则任务在创始的时候就带有计数器，做好新旧任务的隔离。</strong></li>
<li>更好的解法是把 terminate 状态分离出来。中间失败和最终失败分离。<strong>最终失败按阶段论，而不考虑前置状态，这样就无需考虑兼容性问题</strong>。</li>
</ol>
<h1>滥用 ForkJoinPool</h1>
<p>这个线程池的线程会自动关闭，因为首先它有内置的 idle，其次它的线程都是守护线程。</p>
<p>所以很多人很多时候是不关这个线程池的。</p>
<p>最好还是要关，这样 idle 的时间也不用等。</p>
<h1>https 的外网端口被批量请求发起攻击</h1>
<p>通过 nginx 官方证书的方式，对外暴露一个https服务，然后后面接 clb，clb后再放置一组服务器。</p>
<p>因为不知名的原因，有正确参数（正确的存量 taskId）流量批量进入系统中，导致系统业务逻辑被触发，批量发送短信。</p>
<p>修改方案不是很好：改外网域名为内网ip调用，但是因为不能经过有官方证书的 nginx，所以必须使用 http，这样就放弃了通讯过程中的加密。</p>
<p>合理的方案是对每次请求做全签名，且做时间戳签名。</p>
<h1>服务冷启动 cpu 过高</h1>
<p>导致 CompletableFuture 全部超时。</p>
<p>阻塞原因是因为动态编译 codecache 太多，c2 线程占满了 cpu。</p>
<p>解法：</p>
<ol>
<li>主动预热再开量-注意绕开鉴权，但要使用单独的绕开鉴权的注解，不要破坏旧的注解和切面的关系。<strong>要实现代码预热比较简单，组件预热、连接预热、和数据预热非要mock流量不可</strong>。</li>
<li>减少 c2 线程的数量：默认为2。<strong>但也可以增加到3，似乎也能减少超时</strong>。<code>-XX:CICompilerCount=3 -XX:+PrintCompilation</code>。</li>
</ol>
<p>预热要隔离资源：比如单一容器使用的 redis resource pool 可能因为某个容器的预热被耗尽，解决方法是限制预热线程，让线程每次只持有1个连接，通过复用的方式来解决吞吐问题。</p>
<h1>在 select 语句里面重新定义了某个 column，where 受影响</h1>
<p><code> select CONCAT(product_id, ' ', vest_name) AS product_id,</code>导致<code>where product_id='abc'</code>什么都查不出来。</p>
<p>不要使用现有列名作为衍生列名。</p>
<h1>拼接 sql 的时候使用同一个 key</h1>
<p><code>&lt;a, &gt;= 1&gt;</code>会被<code>&lt;a, &lt;= 2&gt;</code>覆盖。</p>
<p>比较好的解法：<code>&lt;a &gt;=, 1&gt;</code>会被<code>&lt;a &lt;=, 2&gt;</code>覆盖。</p>
<h1>使用全量结果查询</h1>
<p>不够大胆的优化通常是害怕内存不够/查询太复杂而无法下推，导致查询速度慢。要把查询速度提起来最好的方法还是下推。</p>
<ol>
<li>如果必须分页查询，则全空间去重必须在近端做，这就导致大数据量传输。</li>
<li>对结果集的统计可以完全不group by，这样结果集不需要带有聚合列。</li>
<li>可以在一次查询产生多种不同维度的聚合结果，要善用mutiif/case when。</li>
<li>ck 很多时候不支持 double 子查询，只能分段。</li>
<li>按照业务场景（行业）拆分表，同构但数据分布不同，得到不同的查询范围。</li>
</ol>
<h1>生成查询数据的时候都是整数</h1>
<p><strong>提示出现了整形舍入</strong></p>
<p>最好的改法是都引入 BigDecimal 进行 divide 操作。</p>
<h1>前缀唯一索引冲突</h1>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sql">    <span class="hljs-keyword">constraint</span> idx_params<br>        <span class="hljs-keyword">unique</span> (params(<span class="hljs-number">500</span>)) comment <span class="hljs-string">&#x27;参数索引&#x27;</span>,<br>```        <br>        <br>产生的唯一索引很容易被超过<span class="hljs-number">500</span>个字符的重复字符串冲击。最好的方法是去掉这个索引，但是在插入前做严格的查询检查<span class="hljs-operator">-</span>用params做redis key。<br><br># 索引错误<br><br>在一个 <span class="hljs-keyword">for</span> 循环里寻求 <span class="hljs-number">1</span><span class="hljs-operator">-</span>based 的递增，但是基于 list 的取值操作，index 的起点设置为 <span class="hljs-number">1</span>，最终导致 OutOfBoundException。<br><br>教训：<br>凡是与容器迭代有关的index<br><span class="hljs-number">1.</span> 都必须是 <span class="hljs-number">0</span><span class="hljs-operator">-</span>based，增值算法必须内部解决。<br><span class="hljs-number">2.</span> 把 i 和 foreach loop 分离出来。<br><br># 没有栈帧的空指针<br><br>```bash<br>msg:java.lang.NullPointerException<br></code></pre></td></tr></table></figure>
<p>这种情况下不要加日志，要想的某些 integer 或者 enum 无法转出来，是拆箱类的错误。</p>
<ol>
<li>要想是不是有些field 应该为 Integer，被错误地设置为 int 了。</li>
<li>要想是不是某些值被错误地设为空了。</li>
<li>不要使用 throwable 来让 log4j打印日志，要用 exception。有时候 throwable.getMessage 都是有问题的。</li>
</ol>
<h1>错误地更新字段为 null</h1>
<p>有些 enitity 底层有 long 而不是 Long，在拷贝新的更新用对象，再使用<code>updateNonNullFields</code>类方法时，可能无意之中让更新用对象拥有了 long ownerId=0; 的默认值。</p>
<ol>
<li>所有的变更都要有提前记录反操作的日志。</li>
<li>如果有得选，用程序化地完整地还原并更新 entity 是最简单的。</li>
</ol>
<h1>在单端口多服务的时候，存在多个configuration</h1>
<p>只在一个 configuration 下新增必要 bean 会让核心 context 无法加载。应该在最公用的 configuration 里加上必要的 bean。</p>
<h1>大 Long 不相等</h1>
<p>java 包装器类型的常识：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">l1</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000551L</span>;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">l2</span> <span class="hljs-operator">=</span> <span class="hljs-number">10000551L</span>;<br>    <span class="hljs-comment">// false。对象比较内存地址，大数字无法使用缓存</span><br>    System.out.println(l1 == l2);<br>    <span class="hljs-comment">// true</span><br>    System.out.println(Objects.equals(l1,l2));<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>查询分区表不带有 impl_date</h1>
<p>查出来的结果放大了十几倍。</p>
<h1>更新配置格式不正确</h1>
<p>导致解析失败，甚至会触发服务启动失败：</p>
<p>只能兼容<code>[1]</code>，不能兼容<code>1</code>。</p>
<p>所以：</p>
<ol>
<li>要校验配置才用新值代替旧值。</li>
<li>配置如果是反序列化的，一定要注意是不是能兼容不带有符号的裸列表。</li>
</ol>
<h1>只 catch 了 exception 没有 catch error</h1>
<p>引用<code>org.skyscreamer.jsonassert.JSONAssert</code>，只catch exception，结果断言是以error的形式抛出的，不仅方法签名要修改，而且 catch return false 的逻辑没有生效。</p>
<p>这导致了很多 assertFalse 的断言测试因为抛出 error 而失败。</p>
<h1>特殊标记位导致安装目录不同，再导致 mockgen 找不到</h1>
<p><strong>没有调试器的时候，要善用二分法插入日志。</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 看起来走入两个分支都可以</span><br><span class="hljs-keyword">if</span> [ -n <span class="hljs-string">&quot;<span class="hljs-variable">$ENV_ID</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>    go install github.com/golang/mock/mockgen@v1.6.0<br><span class="hljs-keyword">else</span> <br>    go get github.com/golang/mock/mockgen@v1.6.0<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-comment"># 在特定的 go 版本以后，但实际上只有走入第一个分支，这里才能读到真正的 mockgen</span><br>mockgen=<span class="hljs-variable">$&#123;DP_ROOT&#125;</span>/tools/gobin/mockgen<br></code></pre></td></tr></table></figure>
<p>只有找得到真正的 mockgen 才能执行 mockgen 命令。</p>
<p>目录不同：</p>
<blockquote>
<p>go get：当使用 go get 安装包时，它将包下载到 GOPATH 中的 pkg/mod 目录。在这个目录中，Go Modules<br>
将下载和缓存所有的依赖项。如果你安装的是二进制工具，它们将被放在 GOPATH 的 bin 目录中。 例如，如果你的 GOPATH 是<br>
/home/user/go，并且你运行 go get <a target="_blank" rel="noopener" href="http://github.com/example/mypackage%EF%BC%8C%E5%8C%85%E5%B0%86%E8%A2%AB%E4%B8%8B%E8%BD%BD%E5%88%B0">github.com/example/mypackage，包将被下载到</a><br>
/home/user/go/pkg/mod 目录，而可执行文件（如果有的话）将被放在 /home/user/go/bin 目录。 go<br>
install：使用 go install 时，Go 会编译源代码并将生成的可执行文件安装到 GOPATH 的 bin 目录。如果你执行 go install <a target="_blank" rel="noopener" href="http://github.com/example/mytool%EF%BC%8C%E8%AF%A5%E5%B7%A5%E5%85%B7%E7%9A%84%E5%8F%AF%E6%89%A7%E8%A1%8C%E6%96%87%E4%BB%B6%E5%B0%86%E8%A2%AB%E5%AE%89%E8%A3%85%E5%88%B0">github.com/example/mytool，该工具的可执行文件将被安装到</a> /home/user/go/bin。</p>
</blockquote>
<h1>设计查询参数但是没有使用</h1>
<p>应该直接报错而不是继续执行，否则用户并不知道哪些参数没有起作用。</p>
<h1>go 的<code>v+%</code>占位符不能正确地显示数据类型</h1>
<p>打印 map可以得到<code>accountId=123</code>这样的输出，但是accountId是 int 或者 string 都可能输出这个值。不能从输出看数据类型。但是 go 打印map可以看到 value 为字符串的话有<code>accountId:&quot;1234&quot;</code>。</p>
<p>同理，url query params<code>&amp;json=[{&quot;a&quot;:123}]</code>本质上所有的 key 对应的 value都是字符串。这在 servlet 的 map 都是取出字符串的。</p>
<h1>不同模块共用配置文件导致启动失败</h1>
<p>业务模块依赖于 i18n模块，i18n模块依赖于 log 模块，log 模块依赖于 config 模块，config 模块依赖于 grpc.yaml，导致业务模块启动失败。</p>
<h1>无法解决的消息积压延迟</h1>
<ol>
<li>下游延迟超过3小时。</li>
<li>中游遇到分布式锁故障，不断扩容+扩大锁配置。</li>
<li>仍然无法消除下游的消息时延。</li>
<li>可能是某类消息本身带有很高的延迟。</li>
<li>无法找到整个消息的生命周期。</li>
</ol>
<h1>到处复制的配置文件应该 .gitignore</h1>
<p>很多测试需要 ./xxx.conf，所以需要到处拷贝配置文件-包括国际化素材。</p>
<p>到处拷贝可以，但是最好在 <a target="_blank" rel="noopener" href="http://build.sh">build.sh</a> 和 Dockerfile 里自动拷贝。平时手动拷贝的脚本，在本地可以导出拷贝，但是需要在项目根处 .gitignore。</p>
<h1>不能 mock 的测试</h1>
<p>基于嵌入的 go struct，不能被 gmock 改写 mock 行为。</p>
<p>所以要 mock 就尽可能使用组合，不要嵌入。</p>
<p>能够 mock 成解析好的文件，就不要依赖于原始的 byte[]。不是所有人都喜欢集成测试。</p>
<h1>生成s3的id时没有引入名字空间和签名</h1>
<p>很容易产生冲撞。好的格式可能是<code>/image/25610/fdkjfdkfjdl-1280-image.png</code>。</p>
<h1>生成基础数据的时候尽量让多层使用的数据在一个多层能够触摸到的位置声明</h1>
<p>是横向或者底层。如果不跨模块则横向就是放在一个文件夹即可。跨模块则要设计横向模块。否则容易产生循环引用-这在go语言的编译流程里尤其明显。</p>
<p>横向代表着破环。这比控制反转还要重要。</p>
<h1>配置 eks 的时候名称和 port 配置错误</h1>
<p>要搞清楚引用的服务的正确名字，和它对外的端口号，而不是更外部的端口号。</p>
<h1>闭包陷阱：循环中创建闭包的正确姿势</h1>
<h2 id="问题本质">问题本质</h2>
<p>在循环中创建闭包时，所有闭包会<strong>共享同一个循环变量</strong>，而不是各自拥有独立副本。这是因为闭包捕获的是变量的<strong>引用</strong>，而不是值。当循环快速执行时，后续迭代会覆盖变量的值，导致所有闭包都使用最后一次迭代的值。</p>
<p>这个问题与并发无关，与闭包闭合变量有关。如果闭包是当下执行，则不会有问题；如果闭包是延后执行。则会有“最后值”的问题。</p>
<h2 id="go-语言示例">Go 语言示例</h2>
<h3 id="错误做法">错误做法</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    validators := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;<br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> validators &#123;<br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            fmt.Println(v) <span class="hljs-comment">// 所有goroutine都会输出&quot;C&quot;</span><br>        &#125;()<br>    &#125;<br>    <br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="正确做法">正确做法</h3>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    validators := []<span class="hljs-type">string</span>&#123;<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>&#125;<br>    <br>    <span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> validators &#123;<br>        v := v <span class="hljs-comment">// 创建局部变量副本</span><br>        wg.Add(<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            <span class="hljs-keyword">defer</span> wg.Done()<br>            fmt.Println(v) <span class="hljs-comment">// 正确输出&quot;A&quot;, &quot;B&quot;, &quot;C&quot;</span><br>        &#125;()<br>    &#125;<br>    <br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="javascript-示例">JavaScript 示例</h2>
<h3 id="错误做法">错误做法</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// 输出三次&quot;3&quot;</span><br>  &#125;, <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="正确做法">正确做法</h3>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用闭包捕获当前值</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(j); <span class="hljs-comment">// 输出0,1,2</span><br>    &#125;, <span class="hljs-number">100</span>);<br>  &#125;)(i);<br>&#125;<br><br><span class="hljs-comment">// 使用let创建块级作用域</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i); <span class="hljs-comment">// 输出0,1,2</span><br>  &#125;, <span class="hljs-number">100</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="java-示例">Java 示例</h2>
<h3 id="错误做法">错误做法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Runnable&gt; tasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    tasks.add(() -&gt; &#123;<br>        System.out.println(i); <span class="hljs-comment">// 编译错误：i需要是final</span><br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="正确做法">正确做法</h3>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Runnable&gt; tasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">finalI</span> <span class="hljs-operator">=</span> i; <span class="hljs-comment">// 创建局部副本</span><br>    tasks.add(() -&gt; System.out.println(finalI)); <span class="hljs-comment">// 输出0,1,2</span><br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="最佳实践">最佳实践</h2>
<ol>
<li><strong>理解作用域</strong>：明确循环变量的作用域范围</li>
<li><strong>创建副本</strong>：在循环内部创建局部变量副本</li>
<li><strong>使用语言特性</strong>：
<ul>
<li>Go：使用 <code>v := v</code> 语法</li>
<li>JavaScript：使用 <code>let</code> 或 IIFE</li>
<li>Java：创建 final 局部变量</li>
</ul>
</li>
<li><strong>测试验证</strong>：在并发场景下测试循环逻辑</li>
<li><strong>代码审查</strong>：特别注意循环中的闭包使用</li>
</ol>
<h2 id="为什么重要">为什么重要</h2>
<p>闭包陷阱是开发中常见的<strong>并发错误源</strong>，它会导致：</p>
<ol>
<li>难以复现的随机bug</li>
<li>数据竞争和不一致</li>
<li>逻辑错误难以调试</li>
<li>生产环境中的严重问题</li>
</ol>
<p>通过理解闭包捕获机制并遵循最佳实践，可以避免这类问题，编写出更健壮的并发代码。</p>
<h1>请求的固定值不用枚举限制</h1>
<p>如果不做default报错，那么传错了错误的枚举用户也不知道出错。<br>
如果使用枚举来限定固定值，则框架会自动拒绝错误的常量。</p>
<h1>所有产生的可能被 url/uri 读取的名字，都要转义</h1>
<p>有一些文件、对象名字看起来平平无奇，但是它们会被拼成 url 的一部分。这时候他们的名字不安全就会产生问题。所以所有用户输入的url和名称都是需要进行 safehtml 的转义的。</p>
<h1>aws s3 的图片只能下载不能打开</h1>
<ol>
<li>Content-Type头缺失或错误
<ul>
<li>如果上传对象时没有设置正确的Content-Type头（如image/jpeg），浏览器无法识别文件类型。</li>
<li>默认情况下，S3会将未知类型文件视为application/octet-stream，触发下载行为</li>
</ul>
</li>
<li>Content-Disposition头设置
<ul>
<li>如果设置了Content-Disposition: attachment头，浏览器会强制下载文件</li>
<li>即使Content-Type正确，此头也会覆盖浏览器的默认显示行为</li>
</ul>
</li>
</ol>
<p>解法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> boto3<br><br>s3 = boto3.client(<span class="hljs-string">&#x27;s3&#x27;</span>)<br>s3.upload_file(<br>    <span class="hljs-string">&#x27;local_image.jpg&#x27;</span>,<br>    <span class="hljs-string">&#x27;your-bucket-name&#x27;</span>,<br>    <span class="hljs-string">&#x27;remote_image.jpg&#x27;</span>,<br>    ExtraArgs=&#123;<br>        <span class="hljs-string">&#x27;ContentType&#x27;</span>: <span class="hljs-string">&#x27;image/jpeg&#x27;</span>,  <span class="hljs-comment"># 正确设置内容类型</span><br>        <span class="hljs-string">&#x27;ContentDisposition&#x27;</span>: <span class="hljs-string">&#x27;inline&#x27;</span>  <span class="hljs-comment"># 设置内联显示</span><br>    &#125;<br>)<br></code></pre></td></tr></table></figure>
<p>修正存量图片</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修正Content-Type</span><br>aws s3 <span class="hljs-built_in">cp</span> s3://your-bucket/image.jpg s3://your-bucket/image.jpg \<br>  --content-type <span class="hljs-string">&quot;image/jpeg&quot;</span> \<br>  --metadata-directive REPLACE<br><br><span class="hljs-comment"># 移除强制下载设置</span><br>aws s3 <span class="hljs-built_in">cp</span> s3://your-bucket/image.jpg s3://your-bucket/image.jpg \<br>  --content-disposition <span class="hljs-string">&quot;inline&quot;</span> \<br>  --metadata-directive REPLACE<br></code></pre></td></tr></table></figure>
<p>配置 cloudfront：</p>
<ol>
<li>添加Content-Type到缓存键和原始请求策略</li>
<li>创建响应头策略：</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span>  <span class="hljs-attr">&quot;ResponseHeadersPolicyConfig&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>    <span class="hljs-attr">&quot;Name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;ImageDisplayPolicy&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;Comment&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;Force inline display for images&quot;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;ContentTypeOptions&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-attr">&quot;Override&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span> <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span>    <span class="hljs-attr">&quot;ContentDisposition&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span>      <span class="hljs-attr">&quot;Override&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span>      <span class="hljs-attr">&quot;Value&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;inline&quot;</span>    <span class="hljs-punctuation">&#125;</span>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<h1>逆拷贝错误</h1>
<p>查出一个 ORM 管理的对象a1，用深拷贝的方法得到一个新对象 a2。</p>
<p>把 a1 当做不可变对象作为参考，修改 a2，用 a2 来进行 update。</p>
<p>深拷贝理论上会把所有叶子节点的值全部重新拷贝一遍，但是不一定能拷贝句柄等单例或者堆外内存的指针指向的值。其次是深拷贝的结构可能是更简略的结构-除非深拷贝的对象是一个 map，否则很容易丢失 ORM 需要的管理状态。</p>
<p>这种拷贝会导致更新失败，而且对象可能被还原。</p>
<p>一个简单的解法是把 a2 作为不可变对象，把 a1 作为更新值。</p>
<h1>在 go 里返回 error 的时候返回 nil 对象</h1>
<p>在外围尝试对对象求值遇到空指针问题。</p>
<p>如果有可能尽量返回空对象，或者进行打日志或者求值操作的时候尽量做多层判空。</p>
<h1>并行化转化导致后续的转化器失衡</h1>
<p>转化器 t2 依赖于 t1 产出的 cid，但是因为 t2 和 t1 是并行执行的，所以有时候 t2 内部取到的 tid 为0。</p>
<p>使用转化器不要滥用 goroutine，如果可以需要使用 wait 表达依赖，如果可以也要使用串行解决问题。</p>
<h1>选错配置以后，覆盖了 content-type</h1>
<p>在使用 curl 而不是浏览器工具使用表单上传不一定会触发一个<code>multipart/form-data</code>的content-type，需要手动指定为好。</p>
<p>如果不指定，可能被一个大颗粒度配置覆盖为<code>application/json</code>。后端上传服务可能无法解析这个复杂表单。</p>
<p>所以：</p>
<ol>
<li>支持细颗粒度的接口配置。</li>
<li>要知道 content-type 不一定会自动生成。</li>
<li>不要随便覆写 content-type。</li>
</ol>
<h1>对于修复 body 的设计。</h1>
<p>在 go 里面读取了 form body 没有重置，会导致：<code>Failed to parse form: http: multipart handled by MultipartReader</code>。</p>
<p>对于<code>application/json</code>类型，以下代码是生效的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> buf bytes.Buffer<br>tee := io.TeeReader(r.Body, &amp;buf)<br>r.Body = io.NopCloser(tee)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// 确保恢复原始数据且可重复读取</span><br>    <span class="hljs-keyword">if</span> buf.Len() &gt; <span class="hljs-number">0</span> &#123;<br>        r.Body = io.NopCloser(bytes.NewReader(buf.Bytes()))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 处理空body情况</span><br>        r.Body = io.NopCloser(&amp;buf)<br>    &#125;<br>    log.InfoContextf(ctx, <span class="hljs-string">&quot;multipart form body restored, size: %d&quot;</span>, buf.Len())<br>&#125;()<br></code></pre></td></tr></table></figure>
<p>但对<code>multipart/form-data</code>就会出上述错误。</p>
<p>对于 JSON 格式的请求体，Go 的 net/http 包本身是“无知”的。它不提供像 r.ParseJSON() 这样的内置方法。我们通常使用的 json.NewDecoder(r.Body) 来自 encoding/json 包，它是一个独立的工具。这个解码器只关心一件事：从你提供给它的 io.Reader（即 r.Body）中读取字节流。它不会以任何方式改变 http.Request 对象的内部状态。</p>
<p>正因为这种无状态的特性，使用 io.TeeReader 的模式在这里非常有效。你可以用它将请求体的数据流完整地复制到一个缓冲区，然后在函数末尾通过 defer 语句，用缓冲区里的数据创建一个新的 io.Reader 来恢复 r.Body。后续的任何代码拿到的都是一个全新的、可读的、包含原始数据的请求体，因此可以被再次解析，相安无事。</p>
<p>而对于表单类型，可以对 Request 做重复读取的努力：</p>
<figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs golang"><span class="hljs-comment">//模拟中间件</span><br>r.ParseMultipartForm(<span class="hljs-number">32</span> &lt;&lt; <span class="hljs-number">20</span>)<br>s := r.FormValue(<span class="hljs-string">&quot;uid&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;form场景 中间件读到uid:&quot;</span> + s)<br><br><span class="hljs-comment">//模拟服务</span><br>r.ParseMultipartForm(<span class="hljs-number">32</span> &lt;&lt; <span class="hljs-number">20</span>)<br>s = r.FormValue(<span class="hljs-string">&quot;uid&quot;</span>)<br></code></pre></td></tr></table></figure>
<h1>初始化一个 client 遇到一个错误直接 panic</h1>
<ol>
<li>如果服务的错误可能是连接导致的，那么应该抛出错误/异常，而不是panic。</li>
<li>然后准备一个全局单例，每次请求都尝试求值或者初始化，这样初期失败不会搞垮程序，总有一次请求会帮助单例初始化成功。</li>
</ol>
<h1>建立 aws 的 alb 很多请求都超时</h1>
<p>通常超时是5s或者10s的倍数。</p>
<p>原因是：标准 vpc 带有4个子网，有1个子网是死胡同。如果负载均衡到这个死胡同，则请求会请求到超时时间附近才产生特定响应。</p>
<p>调试方法：<code>curl -vv</code>得到：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">* IPv4: 54.147.62.47, 52.44.233.252<br></code></pre></td></tr></table></figure>
<p>这里意味着 route 53 给了 2 个 ip 地址，然后用 curl 直接请求这2个地址，总有一个会得到死胡同结果。这时候就去aws去掉死胡同地址就可以了。</p>
<h1>http header 不能包含中文</h1>
<p><code>&quot;header key \&quot;http-x-account-name\&quot; contains value with non-printable ASCII characters&quot;</code>。</p>
<p>这是http规范。</p>
<p>两种解法：</p>
<ol>
<li>URL编码：url.QueryUnescape()</li>
<li>Base64：base64.StdEncoding.DecodeString()</li>
</ol>
<h1>伪注册</h1>
<p>a 节点占用ip1，上报 consul，未解注册，a 下线。</p>
<p>b 节点无意之中复用了 ip1，使用相同的端口和健康检查地址来上线，无意之中注册进了 a 节点的服务列表。</p>
<p>这个问题的根源是 consul 居然没有被动把这个ip地址下线，而把它休眠了。</p>
<p>解法：主动对 consul 反注册，不然最后服务实例列表会堆积如山。而且每次拉取 pod 都要拉取健康节点，尽量避免死请求。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 检查某个 ip 属于哪个 pod</span><br>kubectl get pods  -o wide -A|grep 10.0.203.138<br></code></pre></td></tr></table></figure>
<h1>设计限流器的时候没有考虑到下游系统错误</h1>
<ol>
<li>如果下游系统不可用，限流器可能频繁遇到失败，而上游仍然在重试。</li>
<li>考虑到上游会更疯狂重试，会更容易用掉限流器的配额。</li>
<li>这时候如果过滤掉系统错误和压测流量，保持限流配额不变，似乎是一种更精准的限流。</li>
</ol>
<h1>docker 容器不可启动</h1>
<ol>
<li>有些容器依赖于 k8s 注入环境变量，很难本地调试。</li>
<li>如果无法调试，则使用一个 <a target="_blank" rel="noopener" href="http://start.sh">start.sh</a> 作为托管进程。 1，保持服务能够进去启动，然后进去以后手工执行启动命令，如<code>/usr/local/services/app1/bin/app1 -c /usr/local/services/app1/conf/app1.yaml</code>。启动脚本要留着等价的启动命令。</li>
<li>生成测试部署的时候要一起生成测试 Service。</li>
</ol>
<h1>go redis 因为 tls 版本不可连接</h1>
<p>确认 tls 的协议：<code>openssl s_client -connect ip:port -debug</code>。</p>
<p>测试 redis 的 tls 功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">redis6-cli -h master.basic-valkey.cluster-1.use1.cache.amazonaws.com -p 6379 --tls --insecure<br>auth abc<br></code></pre></td></tr></table></figure>
<p>官方的方案，使用无证书连接：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 官方方案需要使用证书</span><br><span class="hljs-comment">// Load client cert</span><br>cert, err := tls.LoadX509KeyPair(<span class="hljs-string">&quot;redis_user.crt&quot;</span>, <span class="hljs-string">&quot;redis_user_private.key&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br><br><span class="hljs-comment">// Load CA cert</span><br>caCert, err := os.ReadFile(<span class="hljs-string">&quot;redis_ca.pem&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>&#125;<br>caCertPool := x509.NewCertPool()<br>caCertPool.AppendCertsFromPEM(caCert)<br><br>client := redis.NewClient(&amp;redis.Options&#123;<br>    Addr:     <span class="hljs-string">&quot;my-redis.cloud.redislabs.com:6379&quot;</span>,<br>    Username: <span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-comment">// use your Redis user. More info https://redis.io/docs/latest/operate/oss_and_stack/management/security/acl/</span><br>    Password: <span class="hljs-string">&quot;secret&quot;</span>, <span class="hljs-comment">// use your Redis password</span><br>    TLSConfig: &amp;tls.Config&#123;<br>        MinVersion:   tls.VersionTLS12,<br>        Certificates: []tls.Certificate&#123;cert&#125;,<br>        RootCAs:      caCertPool,<br>    &#125;,<br>&#125;)<br><br><span class="hljs-comment">//send SET command</span><br>err = client.Set(ctx, <span class="hljs-string">&quot;foo&quot;</span>, <span class="hljs-string">&quot;bar&quot;</span>, <span class="hljs-number">0</span>).Err()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125;<br><br><span class="hljs-comment">//send GET command and print the value</span><br>val, err := client.Get(ctx, <span class="hljs-string">&quot;foo&quot;</span>).Result()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;foo&quot;</span>, val)<br></code></pre></td></tr></table></figure>
<p>通常我们会因为使用 dialer 导致错误：</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs roboconf">redisOpt := &amp;goredis.Options&#123;<br>        <span class="hljs-attribute">Addr</span>: fmt<span class="hljs-variable">.Sprintf</span>(&quot;%s:%d&quot;, ip, port), // 使用标准地址格式<br>        Dialer: func(ctx context<span class="hljs-variable">.Context</span>, network, addr string) (net<span class="hljs-variable">.Conn</span>, error) &#123;<br>            netDialer := &amp;net<span class="hljs-variable">.Dialer</span>&#123;<br>                Timeout:   5 * time<span class="hljs-variable">.Second</span>, // 增加拨号超时时间<br>                KeepAlive: 2 * time<span class="hljs-variable">.Minute</span>,<br>            &#125;<br><br>            logger<span class="hljs-variable">.DefaultEngLogger</span><span class="hljs-variable">.Infof</span>(&quot;Dial GetServerBySid %s %s:%d, network: %s, addr: %s&quot;, metric<span class="hljs-variable">.DepLimitRedis</span>,<br>                ip, port, network, addr)<br>            return netDialer<span class="hljs-variable">.DialContext</span>(ctx, network, addr)<br>        &#125;,<br>        Password:     flowLimitConfig<span class="hljs-variable">.Auth</span>,<br>        DB:           flowLimitConfig<span class="hljs-variable">.DB</span>,<br>        MaxConnAge:   time<span class="hljs-variable">.Second</span> * time<span class="hljs-variable">.Duration</span>(60),<br>        ReadTimeout:  2 * time<span class="hljs-variable">.Second</span>, // 增加读超时<br>        WriteTimeout: 1 * time<span class="hljs-variable">.Second</span>, // 增加写超时<br>        PoolTimeout:  3 * time<span class="hljs-variable">.Second</span>, // 连接池获取连接超时<br>    &#125;<br><br>    if util<span class="hljs-variable">.GetEnv</span>() != constant<span class="hljs-variable">.Develop</span> &#123;<br>        logger<span class="hljs-variable">.DefaultEngLogger</span><span class="hljs-variable">.Infof</span>(&quot;enable tls&quot;)<br>        redisOpt<span class="hljs-variable">.TLSConfig</span> = &amp;tls<span class="hljs-variable">.Config</span>&#123;<br>            MinVersion:         tls<span class="hljs-variable">.VersionTLS</span>12,<br>            InsecureSkipVerify: true, // 对应 --insecure 参数<br>        &#125;<br>    &#125;<br><br>    redisClient := goredis<span class="hljs-variable">.NewClient</span>(redisOpt)<br>    logger<span class="hljs-variable">.DefaultEngLogger</span><span class="hljs-variable">.Infof</span>(&quot;goredis<span class="hljs-variable">.NewClient</span>(redisOpt): %+v&quot;, redisOpt)<br></code></pre></td></tr></table></figure>
<p>这个方案的缺点是，Dialer 会覆盖 redisOpt.TLSConfig 的配置。</p>
<p>所以要引入差异化的 dialer：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 1. 像之前一样，先准备好你的 redisOpt 和可能的 tls.Config</span><br>    redisOpt := &amp;goredis.Options&#123;<br>        Addr:         fmt.Sprintf(<span class="hljs-string">&quot;%s:%d&quot;</span>, ip, port),<br>        Password:     flowLimitConfig.Auth,<br>        DB:           flowLimitConfig.DB,<br>        MaxConnAge:   time.Second * time.Duration(<span class="hljs-number">60</span>),<br>        ReadTimeout:  <span class="hljs-number">2</span> * time.Second,<br>        WriteTimeout: <span class="hljs-number">1</span> * time.Second,<br>        PoolTimeout:  <span class="hljs-number">3</span> * time.Second,<br>    &#125;<br><br>    <span class="hljs-keyword">var</span> tlsConfig *tls.Config <span class="hljs-comment">// 先声明一个变量</span><br>    <span class="hljs-keyword">if</span> util.GetEnv() != constant.Develop &#123;<br>        logger.DefaultEngLogger.Infof(<span class="hljs-string">&quot;enable tls&quot;</span>)<br>        tlsConfig = &amp;tls.Config&#123;<br>            MinVersion:         tls.VersionTLS12,<br>            InsecureSkipVerify: <span class="hljs-literal">true</span>,<br>            <span class="hljs-comment">// 如果要修复安全问题，应该在这里加上 ServerName 和 RootCAs</span><br>            <span class="hljs-comment">// ServerName: ip,</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 2. 这是关键：在 Dialer 中处理 TLS 逻辑</span><br>    redisOpt.Dialer = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(ctx context.Context, network, addr <span class="hljs-type">string</span>)</span></span> (net.Conn, <span class="hljs-type">error</span>) &#123;<br>        <span class="hljs-comment">// 基础的 TCP 拨号器配置</span><br>        netDialer := &amp;net.Dialer&#123;<br>            Timeout:   <span class="hljs-number">5</span> * time.Second,<br>            KeepAlive: <span class="hljs-number">2</span> * time.Minute,<br>        &#125;<br><br>        <span class="hljs-comment">// 如果不需要 TLS (tlsConfig 是 nil)，就执行普通拨号</span><br>        <span class="hljs-keyword">if</span> tlsConfig == <span class="hljs-literal">nil</span> &#123;<br>            logger.DefaultEngLogger.Infof(<span class="hljs-string">&quot;Custom Dialer: Dialing plain TCP to network: %s, addr: %s&quot;</span>, network, addr)<br>            <span class="hljs-keyword">return</span> netDialer.DialContext(ctx, network, addr)<br>        &#125;<br><br>        <span class="hljs-comment">// 如果需要 TLS，则使用 tls.Dialer 来建立连接</span><br>        <span class="hljs-comment">// 它会使用我们的 netDialer 来建立底层 TCP 连接，然后自动完成 TLS 握手</span><br>        logger.DefaultEngLogger.Infof(<span class="hljs-string">&quot;Custom Dialer: Dialing with TLS network: %s, addr: %s&quot;</span>, network, addr)<br>        tlsDialer := &amp;tls.Dialer&#123;<br>            NetDialer: netDialer,<br>            Config:    tlsConfig,<br>        &#125;<br>        <span class="hljs-keyword">return</span> tlsDialer.DialContext(ctx, network, addr)<br>    &#125;<br><br>    <span class="hljs-comment">// 3. 告诉 go-redis 不要再处理 TLS，因为 Dialer 已经处理了</span><br>    <span class="hljs-comment">//    这一步非常重要，可以避免潜在的冲突。</span><br>    redisOpt.TLSConfig = <span class="hljs-literal">nil</span><br><br>    redisClient := goredis.NewClient(redisOpt)<br>    logger.DefaultEngLogger.Infof(<span class="hljs-string">&quot;goredis.NewClient(redisOpt): %+v&quot;</span>, redisOpt)<br></code></pre></td></tr></table></figure>
<p>go 的池化方案：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// StartAndGC 使用 Options 初始化redis，并在程序进程退出时关闭连接池。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cacher)</span></span> StartAndGC(options any) <span class="hljs-type">error</span> &#123;<br>    <span class="hljs-keyword">switch</span> opts := options.(<span class="hljs-keyword">type</span>) &#123;<br>    <span class="hljs-keyword">case</span> Options:<br>        <span class="hljs-keyword">if</span> opts.Ip == <span class="hljs-string">&quot;&quot;</span> || opts.Port == <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">return</span> errors.Wrap(errors.ThrowErrorWithMsg(context.Background(), errors.PlatformRedisConfIncompleteError,<br>                fmt.Sprintf(<span class="hljs-string">&quot;%+v&quot;</span>, redis_conf.RedisConfig)))<br>        &#125;<br>        <span class="hljs-keyword">if</span> opts.Network == <span class="hljs-string">&quot;&quot;</span> &#123;<br>            opts.Network = <span class="hljs-string">&quot;tcp&quot;</span><br>        &#125;<br><br>        <span class="hljs-keyword">if</span> opts.MaxIdle == <span class="hljs-number">0</span> &#123;<br>            opts.MaxIdle = <span class="hljs-number">3</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> opts.IdleTimeout == <span class="hljs-number">0</span> &#123;<br>            opts.IdleTimeout = <span class="hljs-number">300</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> opts.MaxConnLifetime == <span class="hljs-number">0</span> &#123;<br>            opts.MaxConnLifetime = time.Second * time.Duration(<span class="hljs-number">60</span>) <span class="hljs-comment">// 链接最长存活时间</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> opts.Marshal == <span class="hljs-literal">nil</span> &#123;<br>            c.marshal = json.Marshal<br>        &#125;<br>        <span class="hljs-keyword">if</span> opts.Unmarshal == <span class="hljs-literal">nil</span> &#123;<br>            c.unmarshal = util.SafeUnmarshal<br>        &#125;<br>        <span class="hljs-keyword">if</span> opts.Prefix != <span class="hljs-string">&quot;&quot;</span> &#123;<br>            c.prefix = opts.Prefix<br>        &#125;<br>        pool := &amp;redis.Pool&#123;<br>            MaxActive:       opts.MaxActive,<br>            MaxIdle:         opts.MaxIdle,<br>            IdleTimeout:     time.Duration(opts.IdleTimeout) * time.Second,<br>            MaxConnLifetime: opts.MaxConnLifetime,<br>            Dial: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> (redis.Conn, <span class="hljs-type">error</span>) &#123;<br>                ip := opts.Ip<br>                port := opts.Port<br>                log.Printf(<span class="hljs-string">&quot;StartAndGC Dial GetServerBySid %s %s:%d&quot;</span>, c.name, ip, port)<br><br>                <span class="hljs-comment">// 配置 TLS 参数</span><br>                <span class="hljs-keyword">var</span> tlsConfig *tls.Config<br>                <span class="hljs-keyword">if</span> opts.MinVersion != <span class="hljs-number">0</span> &#123;<br>                    tlsConfig = &amp;tls.Config&#123;<br>                        MinVersion:         opts.MinVersion,<br>                        InsecureSkipVerify: opts.InsecureSkipVerify,<br>                    &#125;<br>                &#125;<br><br>                <span class="hljs-keyword">var</span> conn redis.Conn<br>                <span class="hljs-keyword">var</span> err <span class="hljs-type">error</span><br><br>                <span class="hljs-keyword">if</span> tlsConfig != <span class="hljs-literal">nil</span> &#123;<br>                    <span class="hljs-comment">// 使用 TLS 连接</span><br>                    conn, err = redis.Dial(opts.Network,<br>                        fmt.Sprintf(<span class="hljs-string">&quot;%s:%d&quot;</span>, ip, port),<br>                        redis.DialUseTLS(<span class="hljs-literal">true</span>),<br>                        redis.DialTLSConfig(tlsConfig))<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 普通 TCP 连接</span><br>                    conn, err = redis.Dial(opts.Network,<br>                        fmt.Sprintf(<span class="hljs-string">&quot;%s:%d&quot;</span>, ip, port))<br>                &#125;<br><br>                <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>                &#125;<br><br>                <span class="hljs-comment">// 认证和选择数据库</span><br>                <span class="hljs-keyword">if</span> opts.Password != <span class="hljs-string">&quot;&quot;</span> &#123;<br>                    <span class="hljs-keyword">if</span> _, err := conn.Do(<span class="hljs-string">&quot;AUTH&quot;</span>, opts.Password); err != <span class="hljs-literal">nil</span> &#123;<br>                        conn.Close()<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">if</span> opts.Db &gt; <span class="hljs-number">0</span> &#123;<br>                    <span class="hljs-keyword">if</span> _, err := conn.Do(<span class="hljs-string">&quot;SELECT&quot;</span>, opts.Db); err != <span class="hljs-literal">nil</span> &#123;<br>                        conn.Close()<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> conn, <span class="hljs-literal">nil</span><br>            &#125;,<br><br>            TestOnBorrow: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(conn redis.Conn, t time.Time)</span></span> <span class="hljs-type">error</span> &#123;<br>                _, err := conn.Do(<span class="hljs-string">&quot;PING&quot;</span>)<br>                <span class="hljs-keyword">return</span> err<br>            &#125;,<br>        &#125;<br><br>        c.pool = pool<br>        c.closePool()<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>    <span class="hljs-keyword">default</span>:<br>        <span class="hljs-keyword">return</span> errors.Wrap(errors.ThrowErrorWithMsg(context.Background(), errors.PlatformUnsupportedOptionsError,<br>            fmt.Sprintf(<span class="hljs-string">&quot;%+v&quot;</span>, options)))<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>错误的限流器</h1>
<h2 id="只考虑单一维度-单一值">只考虑单一维度 + 单一值</h2>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">key_base_conf:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/v1.0/abc/cdf&quot;</span>  <span class="hljs-comment"># 接口路径</span><br>    <span class="hljs-attr">key:</span> <span class="hljs-string">RoleInfo.UID</span><br>    <span class="hljs-attr">value:</span> <span class="hljs-number">25610</span><br>    <span class="hljs-attr">qps:</span> <span class="hljs-number">2</span>                   <span class="hljs-comment"># 每秒请求限制</span><br>    <span class="hljs-attr">qpm:</span> <span class="hljs-number">5</span>                  <span class="hljs-comment"># 每分钟请求限制</span><br>    <span class="hljs-attr">qpd:</span> <span class="hljs-number">10</span>               <span class="hljs-comment"># 每天请求限制</span><br></code></pre></td></tr></table></figure>
<p>这样的设计的缺点是：一个 path似乎只能从一个角度来配置一个值而已，加一个值也不行，不想要使用 UID 维度也不行。</p>
<p>比较好的修改是</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;*&quot;</span>  <span class="hljs-comment"># 接口路径</span><br>  <span class="hljs-attr">key:</span> <span class="hljs-string">RoleInfo.UID</span><br>  <span class="hljs-attr">value:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">25610</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">25611</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">25612</span><br>  <span class="hljs-attr">qps:</span> <span class="hljs-number">20</span>                <span class="hljs-comment"># 每秒请求限制</span><br>  <span class="hljs-attr">qpm:</span> <span class="hljs-number">50</span>                <span class="hljs-comment"># 每分钟请求限制</span><br>  <span class="hljs-attr">qpd:</span> <span class="hljs-number">30</span>                <span class="hljs-comment"># 每天请求限制</span><br><span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">&quot;/v1.0/abc/cdf&quot;</span>  <span class="hljs-comment"># 接口路径</span><br>  <span class="hljs-attr">key:</span> <span class="hljs-string">RoleInfo.UID</span><br>  <span class="hljs-attr">value:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">25610</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">25611</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-number">25612</span><br>  <span class="hljs-attr">qps:</span> <span class="hljs-number">2</span>                 <span class="hljs-comment"># 每秒请求限制</span><br>  <span class="hljs-attr">qpm:</span> <span class="hljs-number">5</span>                 <span class="hljs-comment"># 每分钟请求限制</span><br>  <span class="hljs-attr">qpd:</span> <span class="hljs-number">3</span>                 <span class="hljs-comment"># 每天请求限制</span><br></code></pre></td></tr></table></figure>
<p>这样做可以引入缺省配置，批量路径配置，每个路径也可以有自己的多个元素配置。</p>
<p>这样就实现了全量的网状配置，每个配置内部也是多维的：</p>
<ol>
<li>qps</li>
<li>qpm</li>
<li>qpd</li>
</ol>
<h2 id="并发执行问题">并发执行问题</h2>
<p>一开始代码大概是这样写的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go">qpmLimiter := NewQPMLimiter(<span class="hljs-type">int</span>(qpm), p.limiter)<br>qpmRemaining, err := qpmLimiter.allow(ctx, contextInfo, key.key(), qpm)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br>qpdLimiter := NewQPDLimiter(<span class="hljs-type">int</span>(qpd), p.limiter)<br>qpdRemaining, err = qpdLimiter.allow(ctx, contextInfo, key.keyQpd(), qpd)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>    <span class="hljs-keyword">return</span> err<br>&#125;<br></code></pre></td></tr></table></figure>
<p>这就导致一个问题，如果在中间的一个 limiter 出错了，那么前面的 limiter 的配额已经扣减了，后面的 limiter却不扣减，这会导致配额不均匀扣减。</p>
<p>就公正的角度来讲，应该所有的配额都扣减，这又启发我们使用并发 goroutine。</p>
<p>我们使用并发 goroutine 的时候又遇到怎样决定什么才是真正的 remaining 的问题，又涉及动态比较哪个 remaining 最小的问题-这时候就必须在比较的时候加锁。</p>
<p>这又涉及到锁是加在比较的地方，还是加在扣减的地方的问题。最起码要加在比较的地方-如果能够实现锁错开的话。</p>
<h2 id="多个配置的-merge">多个配置的 merge</h2>
<p>一开始是同时取 path + <code>*</code>的配置进行并发扣减配额，但是后来发现应该允许用户用具体的 path override <code>*</code>的配置。</p>
<p>于是有了这个修改：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Plugin)</span></span> getMatchedRules(ctx *gopass.Context, path <span class="hljs-type">string</span>, contextInfo *mycontext.Context) ([]FlowLimitRule, []<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>    ctx.Logger.Infof(<span class="hljs-string">&quot;FlowLimitPlugin getMatchedRules started, path: %s&quot;</span>, path)<br>    <span class="hljs-keyword">defer</span> ctx.Logger.Infof(<span class="hljs-string">&quot;FlowLimitPlugin getMatchedRules completed, path: %s&quot;</span>, path)<br><br>    <span class="hljs-keyword">var</span> matchedRules []FlowLimitRule<br>    <span class="hljs-keyword">var</span> matchedVals []<span class="hljs-type">string</span><br>    seenKeys := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">bool</span>) <span class="hljs-comment">// Track processed rule.Key and contextVal combinations</span><br><br>    <span class="hljs-comment">// Process specific path rules first</span><br>    <span class="hljs-keyword">if</span> rules := p.standardFlowLimitMap[path]; rules != <span class="hljs-literal">nil</span> &#123;<br>        ctx.Logger.Infof(<span class="hljs-string">&quot;Checking specific path rules, found %d rules&quot;</span>, <span class="hljs-built_in">len</span>(rules.Rules))<br>        <span class="hljs-keyword">for</span> _, rule := <span class="hljs-keyword">range</span> rules.Rules &#123;<br>            <span class="hljs-keyword">if</span> rule.Key == <span class="hljs-string">&quot;&quot;</span> &#123;<br>                ctx.Logger.Debugf(<span class="hljs-string">&quot;Skipping rule with empty key&quot;</span>)<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            contextVal, err := contextInfo.GetStringByPath(ctx, rule.Key)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                ctx.Logger.Errorf(<span class="hljs-string">&quot;Failed to get context value, key: %s, err: %+v&quot;</span>, rule.Key, err)<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> rule.MatchValue(contextVal) &#123;<br>                ctx.Logger.Infof(<span class="hljs-string">&quot;Rule matched successfully, Key: %s, Value: %s&quot;</span>, rule.Key, contextVal)<br>                matchedRules = <span class="hljs-built_in">append</span>(matchedRules, rule)<br>                matchedVals = <span class="hljs-built_in">append</span>(matchedVals, contextVal)<br><br>                key := rule.Key + <span class="hljs-string">&quot;:&quot;</span> + contextVal <span class="hljs-comment">// Unique identifier: RoleInfo.UID:25610</span><br>                seenKeys[key] = <span class="hljs-literal">true</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ctx.Logger.Debugf(<span class="hljs-string">&quot;Rule value mismatch, Key: %s, Value: %s, Rule values: %v&quot;</span>, rule.Key, contextVal, rule.Value)<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ctx.Logger.Infof(<span class="hljs-string">&quot;No specific path rules found&quot;</span>)<br>    &#125;<br><br>    <span class="hljs-comment">// Process default path rules, only take the first matching rule</span><br>    <span class="hljs-keyword">if</span> rules := p.standardFlowLimitMap[defaultPath]; rules != <span class="hljs-literal">nil</span> &#123;<br>        ctx.Logger.Infof(<span class="hljs-string">&quot;Checking default path rules, found %d rules&quot;</span>, <span class="hljs-built_in">len</span>(rules.Rules))<br>        <span class="hljs-keyword">for</span> _, rule := <span class="hljs-keyword">range</span> rules.Rules &#123;<br>            <span class="hljs-keyword">if</span> rule.Key == <span class="hljs-string">&quot;&quot;</span> &#123;<br>                ctx.Logger.Debugf(<span class="hljs-string">&quot;Skipping rule with empty key&quot;</span>)<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            contextVal, err := contextInfo.GetStringByPath(ctx, rule.Key)<br>            <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>                ctx.Logger.Errorf(<span class="hljs-string">&quot;Failed to get context value, key: %s, err: %+v&quot;</span>, rule.Key, err)<br>                <span class="hljs-keyword">continue</span><br>            &#125;<br><br>            <span class="hljs-keyword">if</span> rule.MatchValue(contextVal) &#123;<br>                key := rule.Key + <span class="hljs-string">&quot;:&quot;</span> + contextVal <span class="hljs-comment">// Unique identifier: RoleInfo.UID:25610</span><br>                <span class="hljs-keyword">if</span> !seenKeys[key] &#123;<br>                    ctx.Logger.Infof(<span class="hljs-string">&quot;Default rule matched successfully, Key: %s, Value: %s&quot;</span>, rule.Key, contextVal)<br>                    matchedRules = <span class="hljs-built_in">append</span>(matchedRules, rule)<br>                    matchedVals = <span class="hljs-built_in">append</span>(matchedVals, contextVal)<br>                    <span class="hljs-keyword">break</span> <span class="hljs-comment">// Only take the first matching rule</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ctx.Logger.Debugf(<span class="hljs-string">&quot;Default rule already exists, Key: %s, Value: %s&quot;</span>, rule.Key, contextVal)<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ctx.Logger.Debugf(<span class="hljs-string">&quot;Default rule value mismatch, Key: %s, Value: %s, Rule values: %v&quot;</span>, rule.Key, contextVal, rule.Value)<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        ctx.Logger.Infof(<span class="hljs-string">&quot;No default path rules found&quot;</span>)<br>    &#125;<br><br>    ctx.Logger.Infof(<span class="hljs-string">&quot;Total matched rules: %d&quot;</span>, <span class="hljs-built_in">len</span>(matchedRules))<br>    <span class="hljs-keyword">return</span> matchedRules, matchedVals, <span class="hljs-literal">nil</span><br>&#125;<br><br></code></pre></td></tr></table></figure>
<p>大家就不会和<code>*</code>配置互相干扰。</p>
<p>这个算法还是不够好，更好的算法应该是：</p>
<ol>
<li>把限流的值升序排列。</li>
<li>串行执行。</li>
</ol>
<p>这样可以保证：</p>
<ol>
<li>通过低限流的值，会造成低限流的扣减。</li>
<li>低限流的扣减过了，高限流的值肯定也能扣减过。</li>
<li>如果扣减不通过，低限流的限流器第一个拒绝，这样所有的限流器本身并不做差异化的扣减：标准的限流器都是尝试扣减，通过再真扣减的。所以拒绝等于假性扣减。</li>
</ol>
<h2 id="怎样计算-used-和-remaining">怎样计算 used 和 remaining</h2>
<p>有多组规则就会有多个并发扣减，就会产生多个 used 和 remaining。</p>
<p>怎样表达为一组 used 和 remaining？</p>
<p>一开始 used 和 remaining 本来设计成平均值。但是实际上如果要放在响应头里提醒用户，应该还是所有规则配置里的最小值才是准确的，而且这个最小值还必须排除掉<code>*</code>，只在多组具体 path 规则里找最小值。</p>
<p>设计限流器的时候，一开始只考虑了 path + 单一维度 + 单一值的匹配法。</p>
<h2 id="重复调用问题">重复调用问题</h2>
<p>事实证明一个子插件是可能被重复调用2次的，这类带有写的操作的流程要注意幂等性，扣减类显然特别受这个问题的害。</p>
<h2 id="忘记排除特别的接口">忘记排除特别的接口</h2>
<p><code>/health</code>检查接口应该是无需限流的。但是可能被<code>*</code>囊括进限流里。</p>
<p>需要专门给被无线调用的接口设计白名单机制。</p>
<h2 id="正确的设计是">正确的设计是</h2>
<ol>
<li>完整的、自由的表达维度（具体覆盖模糊，具体值里最小的值获胜）</li>
<li>网状的碰撞-必定扣减，无遗漏。</li>
<li>剩余值里最小值获胜。</li>
<li>关键数据加锁检查。</li>
</ol>
<h1>对不涉及慢操作的for循环并发处理导致调试变得困难</h1>
<p>只有有迭代读数据库或者调用 io 的 rpc 操作的地方才适合并行化。</p>
<p>在其他地方并行化只会导致调试困难，而且变量读写跨各种 scope 会非常麻烦。</p>
<p>应该专门逆优化这些流程。</p>
<h1>子进程无法继承父进程的环境变量</h1>
<p>子进程只能继承父进程的“<strong>环境变量</strong>”，而不能继承父进程的“<strong>本地变量</strong>”或“<strong>Shell 变量</strong>”。</p>
<p>当一个变量在 Shell（如 Bash）中，被使用 export 命令标记为环境变量（Environment Variable）时，它就会被其后创建的所有子进程所继承。</p>
<ol>
<li>这样的变量可以被子进程天然继承。</li>
<li>如果不能被继承就这样使用临时环境（本地）变量<code>NODE_IP=&quot;192.168.1.10&quot; ./my-go-app</code>或者<code>nohup env NODE_IP=&quot;$NODE_IP&quot; $APP_PATH/bin/$APP_NAME -c $CONF_FILE &gt;/dev/null 2&gt;&amp;1 | tee -a stderr &amp; PID=$!</code>：</li>
<li>这样的变量是无法继承的：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这只是一个本地 Shell 变量</span><br>MY_SECRET_KEY=<span class="hljs-string">&quot;abc-123&quot;</span><br><br><span class="hljs-comment"># 启动一个新的子 Shell</span><br>bash<br><br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$MY_SECRET_KEY</span><br><span class="hljs-comment"># 输出将是空的，因为子 Shell 没有继承这个变量</span><br></code></pre></td></tr></table></figure>
<p>这个继承行为是由 Unix/Linux 的进程创建机制决定的：</p>
<ol>
<li><code>fork()</code>：当一个父进程调用<code>fork()</code>创建子进程时，操作系统会为子进程创建一份父进程环境的完整副本。这里的“环境”指的就是那些被 export 的环境变量。</li>
<li><code>exec()</code>：子进程接着调用<code>exec()</code>来执行一个新程序。<code>exec()</code> 会用新程序替换当前进程的代码和数据，但会保留那份继承来的环境副本。<br>
本地变量（未 export 的）不属于这份“环境”副本的一部分，因此在<code>fork()</code>时就不会被复制给子进程。</li>
</ol>
<table>
<thead>
<tr>
<th>变量类型</th>
<th>定义方式 (Bash)</th>
<th>是否能被子进程继承</th>
<th>典型场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>环境变量</strong></td>
<td><code>export VAR=&quot;value&quot;</code></td>
<td>是</td>
<td>需要跨进程共享的配置（如 <code>PATH</code>, <code>HOME</code>, <code>NODE_IP</code>）</td>
</tr>
<tr>
<td></td>
<td><code>VAR=&quot;value&quot; command</code></td>
<td>是（仅对 <code>command</code>）</td>
<td>为特定程序启动时注入临时配置（安全推荐）</td>
</tr>
<tr>
<td><strong>本地/Shell变量</strong></td>
<td><code>VAR=&quot;value&quot;</code></td>
<td>否</td>
<td>脚本内部临时变量（不影响其他程序）</td>
</tr>
</tbody>
</table>
<h1>怎样更散列</h1>
<p>文件名的散列程度决定了网络 cdn 和 s3 的分发均衡程度。</p>
<p>文件名 = uid + signature + timestamp</p>
<p>timestamp 是连续的，signature 是md5散列的，那么这个文件名是散列的吗？</p>
<p>高位散列而低位连续，整个数还是散列的。如果把signature移到前面，这个文件名会更散列，对分布式的 cdn更友好。</p>
<p>低位散列会产生尾部聚集问题。</p>
<h1>错误的 nohup</h1>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 这个命令不会阻塞后面的日志</span><br><span class="hljs-built_in">nohup</span> redis6-server conf/redis.conf &gt;/dev/null 2&gt;&amp;1<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;started redis-server&quot;</span><br><span class="hljs-comment"># 但是这个命令会阻塞后面的日志</span><br><span class="hljs-built_in">nohup</span> node <span class="hljs-variable">$APP_PATH</span>/bin/server.js &gt;/dev/null 2&gt;&amp;1<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;started server.js&quot;</span><br></code></pre></td></tr></table></figure>
<p>应该这样改：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> redis6-server conf/redis.conf &gt;/dev/null 2&gt;&amp;1 &amp;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;started redis-server&quot;</span><br><span class="hljs-built_in">nohup</span> node <span class="hljs-variable">$APP_PATH</span>/bin/server.js &gt;/dev/null 2&gt;&amp;1 &amp;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;started server.js&quot;</span><br></code></pre></td></tr></table></figure>
<h2 id="linux-后台进程管理方法一览">Linux 后台进程管理方法一览</h2>
<table>
<thead>
<tr>
<th>方法</th>
<th>命令示例</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>1. &amp; 符号</strong></td>
<td><code>command &amp;</code></td>
<td>最简单方式，立即返回控制权</td>
</tr>
<tr>
<td><strong>2. nohup + &amp;</strong></td>
<td><code>nohup command &amp;</code></td>
<td>终端断开后进程继续运行</td>
</tr>
<tr>
<td><strong>3. disown</strong></td>
<td><code>command &amp;</code><br><code>disown %1</code></td>
<td>将已启动的作业从 shell 作业列表中移除</td>
</tr>
<tr>
<td><strong>4. setsid</strong></td>
<td><code>setsid command</code></td>
<td>在新会话中运行命令（自动后台）</td>
</tr>
<tr>
<td><strong>5. screen/tmux</strong></td>
<td><code>screen -dmS mysession command</code></td>
<td>创建虚拟终端会话</td>
</tr>
<tr>
<td><strong>6. systemd 服务</strong></td>
<td><code>systemctl start my-service.service</code></td>
<td>专业的进程管理方式</td>
</tr>
<tr>
<td><strong>7. daemon 工具</strong></td>
<td><code>daemon command</code></td>
<td>专门的守护进程管理工具</td>
</tr>
<tr>
<td><strong>8. 双重 fork</strong></td>
<td><code>(command &amp;)</code></td>
<td>通过子 shell 实现后台（不推荐）</td>
</tr>
</tbody>
</table>
<h2 id="关键特性对比：">关键特性对比：</h2>
<pre><code class="hljs mermaid">graph TD
    A[终端关闭存活] --&gt; B(&amp;符号)
    A --&gt; C(nohup)
    A --&gt; D(disown)
    A --&gt; E(setsid)
    A --&gt; F(systemd)
    A --&gt; G(daemon)
    B -.-&gt; |否| H[进程终止]
    C --&gt; |是| I[继续运行]
    D --&gt; |是| I
    E --&gt; |是| I
    F --&gt; |是| I
    G --&gt; |是| I</code></pre>
<h2 id="使用建议：">使用建议：</h2>
<ol>
<li><strong>简单后台任务</strong> → <strong>&amp; 符号</strong> (<code>cmd &amp;</code>)</li>
<li><strong>持久化进程</strong> → <strong>nohup</strong> (<code>nohup cmd &amp;</code>)</li>
<li><strong>脱离终端控制</strong> → <strong>disown</strong> 或 <strong>setsid</strong></li>
<li><strong>生产环境服务</strong> → <strong>systemd</strong> 或 <strong>daemon 工具</strong></li>
<li><strong>会话管理</strong> → <strong>screen/tmux</strong></li>
</ol>
<blockquote>
<p>注意：双重 fork <code>(cmd &amp;)</code> 存在资源泄露风险，不建议在重要场景使用</p>
</blockquote>
<h1>修改配置文件的解析方式</h1>
<p>让原本非自然的路径映射模式改成自然的路径映射模式。</p>
<p>结果忘记把非自然的 json 改过来，导致解析文件出错。</p>
<p><code>ab_cd</code>原本是遵循<code>mod/act</code>模式的，实际上 path 应该是 <code>/a/b/c/d</code>，文件应该是<code>a_b_c_d.json</code>。</p>
<h1>尝试删除可能存在或不存在的文件</h1>
<p>我有一个删除脚本：<code>rm ${appPath}/-prod*</code><br>
这个路径下不一定有待删除文件，所以有时候会报：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">rm: cannot <span class="hljs-built_in">remove</span> <span class="hljs-string">&#x27;/conf/*-prod*&#x27;</span>: <span class="hljs-literal">No</span> such file <span class="hljs-keyword">or</span> directory<br></code></pre></td></tr></table></figure>
<p>怎样让 bash 实现存在才删除？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">find <span class="hljs-variable">$&#123;appPath&#125;</span>/ -maxdepth 1 -name <span class="hljs-string">&#x27;*-prod*&#x27;</span> -delete<br></code></pre></td></tr></table></figure>
<h1>aws 的 s3 的 object key 是否需要散列</h1>
<p>散列是为了不让请求打在同一个服务器的同一个磁盘上，避免局部热点。</p>
<p>但当代的aws<a target="_blank" rel="noopener" href="https://www.lastweekinaws.com/podcast/screaming-in-the-cloud/s3-and-the-evolution-of-storage-with-andy-warfield/">在2019以后应该不以前缀来决定访问的空间局部性</a>了，所以无需关注散列问题。</p>
<h1>从 form-data 里读数据无法写回</h1>
<p>本质上 form-data parse 以后是可以从同一个数据结构接口重复读取的，反而不需要像 json body 一样用写回的方式读取。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 尝试从请求体获取</span><br>contentType := r.Header.Get(<span class="hljs-string">&quot;Content-Type&quot;</span>)<br>mediaType, _, _ := mime.ParseMediaType(contentType)<br><span class="hljs-keyword">switch</span> mediaType &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>:<br>    <span class="hljs-comment">// @WARNING 不额外支持复杂格式,当前格式里的不做检查</span><br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;multipart/form-data&quot;</span>:<br>    <span class="hljs-comment">// 文件上传使用此格式，但也可以包含普通字段</span><br>    <span class="hljs-keyword">if</span> err := r.ParseMultipartForm(FormMaxMemory); err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> accountID := r.Form.Get(<span class="hljs-string">&quot;account_id&quot;</span>); accountID != <span class="hljs-string">&quot;&quot;</span> &#123;<br>            log.DebugContextf(ctx, <span class="hljs-string">&quot;get accountId from multipart/form-data param: %v&quot;</span>, accountID)<br>            <span class="hljs-keyword">return</span> accountID<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;application/json&quot;</span>:<br>    <span class="hljs-comment">// 安全解析JSON体</span><br>    <span class="hljs-comment">// 使用 TeeReader 避免消耗原始请求体</span><br>    <span class="hljs-keyword">var</span> buf bytes.Buffer<br>    tee := io.TeeReader(r.Body, &amp;buf)<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// 恢复原始请求体</span><br>        r.Body = io.NopCloser(&amp;buf)<br>    &#125;()<br><br>    <span class="hljs-comment">// RequestBody 请求体</span><br>    <span class="hljs-keyword">type</span> RequestBody <span class="hljs-keyword">struct</span> &#123;<br>        AccountID <span class="hljs-type">int64</span> <span class="hljs-string">`json:&quot;account_id&quot;`</span><br>    &#125;<br>    <span class="hljs-keyword">var</span> body RequestBody<br>    <span class="hljs-keyword">if</span> err := json.NewDecoder(tee).Decode(&amp;body); err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">if</span> body.AccountID != <span class="hljs-number">0</span> &#123;<br>            accountID := strconv.FormatInt(body.AccountID, <span class="hljs-number">10</span>)<br>            log.DebugContextf(ctx, <span class="hljs-string">&quot;get accountId from json body: %v&quot;</span>, accountID)<br>            <span class="hljs-keyword">return</span> accountID<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>
<h1>倒查索引慢了400倍</h1>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 只要0.11s的，只有200个数据。</span><br><span class="hljs-keyword">SELECT</span> update_tag <span class="hljs-keyword">FROM</span> thr_calc_route_20250715 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> update_tag <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> update_tag<br><span class="hljs-comment">-- 要4分钟，倒序显示的200个数据。</span><br><span class="hljs-keyword">SELECT</span> update_tag <span class="hljs-keyword">FROM</span> thr_calc_route_20250715 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> update_tag <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> update_tag <span class="hljs-keyword">DESC</span> <br><span class="hljs-comment">-- 要0.15s</span><br><span class="hljs-keyword">SELECT</span> update_tag <span class="hljs-keyword">FROM</span> (<span class="hljs-keyword">SELECT</span> update_tag <span class="hljs-keyword">FROM</span> thr_calc_route_20250715 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> update_tag) temp <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> update_tag <span class="hljs-keyword">DESC</span> <br></code></pre></td></tr></table></figure>
<p>结论， group by 单独查询还是可以快速，如果你依赖于 MySQL 自行逆排序会很慢，把结果集存起来再逆序 order by 就会快。</p>
<h1>非守护线程泄露，导致 jvm 关闭钩子泄露</h1>
<p>本来准备一个 JVM 关闭钩子线程要执行，但是一直没有被执行。<br>
原因是之前有其他线程泄露，阻止了 JVM 进入调用关闭钩子的流程。</p>
<h1>中间浮点数错误</h1>
<ul>
<li>Double.toString 并非对“字面量”本身友好，而是对能用最短十进制字符串无损还原为原 double 值的数友好。</li>
<li>常见字面量（如 0.1）虽在 double 中是近似值，但其对应的最短字符串恰好是 “0.1”，看起来干净。</li>
<li>而计算结果（如 0.1 + 0.2）常因浮点误差无法用简短十进制表示，Double.toString 只能输出更长的数字（如 “0.30000000000000004”）以保证精确 round-trip。</li>
<li>因此，表面“友好”与否，取决于该 double 值是否恰好有简洁的十进制表示，而非是否来自字面量。</li>
<li>Double.toString 始终忠实、一致：总是返回最短且可无损还原的十进制字符串。</li>
<li>正因如此，不应将 double 用作 BigDecimal 的构造种子，因为 new BigDecimal(double) 会固化其二进制误差。</li>
<li>推荐使用 new BigDecimal(String) 直接从十进制字符串初始化，确保语义精确。</li>
<li>若必须从 double 创建 BigDecimal，应使用 BigDecimal.valueOf(double)，它内部调用 Double.toString，能避免显式构造器的长尾误差，但仍无法消除 double 本身已有的计算误差。</li>
<li>同样，也不应将非字面量的 double（尤其是运算结果）直接转为字符串作为精确数值的表示或后续解析的“种子”，因为其字符串形式可能包含意外的小数位，误导用户或下游系统。</li>
<li>最佳实践：在需要精确十进制语义的场景（如金融、计量），绕过 double，直接用原始字符串或 BigDecimal 处理数值，避免任何中间浮点表示。</li>
</ul>
<h1>vscode mcp 无法启动</h1>
<p><code>npx npx @blife/bmap-c3-mcp-gateway@latest</code>这个命令没有响应是正常的。正常连接 mcp server就是静默等待输入 json的。</p>
<p>对某些 vscode 而言，.zshenv 也是重要的，需要加入一些路径补充，支持 GUI 读取环境变量以后启动（这一步不必要，下一步必要）：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Add Homebrew to PATH for GUI applications</span><br><span class="hljs-built_in">export</span> PATH=<span class="hljs-string">&quot;/opt/homebrew/bin:/opt/homebrew/sbin:<span class="hljs-variable">$PATH</span>&quot;</span><br></code></pre></td></tr></table></figure>
<p>启动后还不可以的话，就用软链接：<code>sudo ln -s /opt/homebrew/bin/npx /usr/local/bin/npx</code>。似乎只有这个位置的 npx 可以被 vscode 读到。</p>
<h1>插入覆盖语句在 MaxCompute 上执行失败</h1>
<p>一般语法是：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> OVERWRITE table_name (column_name)<br>select_statement<br></code></pre></td></tr></table></figure>
<p>对于一般的语句：</p>
<blockquote>
<p>如果SELECT语句中的列数比目标表的列数多，会写入失败；如果SELECT语句中的列数比目标表中的列数少，写入数据时，目标表中多出的列会自动填充默认值，无默认值时值为NULL。</p>
</blockquote>
<p>但是 MaxCompute 比较严格，如果增加了一列，但是在 select_statement 增加列，则执行任务会失败。</p>
<p>在这里面还有一个小细节，就是如果 gmtCreate 是<code>2025-11-11 00:00:00</code>的格式，比较大于号的时候，只要<code>&gt; 2025-11-11</code>就行了，这利用字典排序的字符串局部性，不引入空格，让脚本本身执行参数也不需要考虑对应空格的引号问题。</p>
<p>修正方法是，紧急在 select语句的末尾补一个<code>,NULL</code>作为默认值。</p>
<h1>对于已单元化的服务，出问题以后只降级一个服务，导致上游跨单元超时</h1>
<p>很多服务的超时时间是专门针对本单元设定的。如果单独切走下游，上游会因为流量漂移到另一个单元而超时。</p>
<p>针对这种情况，只能在网关层做全流量切换，把整个单元的流量都切走。</p>
<h1>在请求里新增兜底，没有评估上下游代码</h1>
<ol>
<li>没有评估上游给出的 sessionId 的正确性。</li>
<li>没有评估下游是否真的使用这个参数，怎么使用这个参数。</li>
<li>没有查看上下游日志有没有流量，看业务能否评估正确使用这些参数。</li>
<li>变更参数的逻辑一定要搞清楚这个<strong>参数所有的使用场景</strong>！</li>
<li>网关服务如果决定一个东西可能不是强依赖，可以把依赖的耦合交给下游重复实现，让它们成为强依赖，网关自己变成弱依赖。</li>
<li>强依赖也分哪个更强，最强的依赖无超时，弱一点的超时变短。超时时间的长度正相关于“多么不愿意因为得不到这个值而熔断”。</li>
</ol>
<h1>上线顺序错误导致消息消费失败</h1>
<p>生产者往消息里增加字段：</p>
<ol>
<li>如果新字段是新版消费者强依赖，当前消费者可忽略的，生产者先上。这种情况下有些消息会丢失，不走新流程产生错误。</li>
<li>如果新字段是新版消费者弱依赖，消费者先上，这种情况下不带有新字段的消息走入新流程，也可能产生错误。</li>
</ol>
<p>正确的发布方法：</p>
<p>阶段1：发布兼容版消费者 C（v1.5）<br>
消费者同时支持字段 a 和字段 b：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 消费者 v1.5（过渡版本）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">process_message</span>(<span class="hljs-params">message</span>):<br>    <span class="hljs-keyword">if</span> message.has(<span class="hljs-string">&#x27;b&#x27;</span>):  <span class="hljs-comment"># 新版消息</span><br>        query_service_d(message.b)<br>    <span class="hljs-keyword">elif</span> message.has(<span class="hljs-string">&#x27;a&#x27;</span>):  <span class="hljs-comment"># 旧版消息</span><br>        query_service_d(message.a)<br>    <span class="hljs-keyword">else</span>:<br>        log_error(<span class="hljs-string">&quot;Unknown message format&quot;</span>)<br></code></pre></td></tr></table></figure>
<p>阶段2：发布新版生产者 P（v2）<br>
生产者开始发送带字段 b 的消息。此时消费者 v1.5 可以正常处理。</p>
<p>阶段3：清理消费者代码（v2）<br>
确认所有旧消息处理完毕后，移除对字段 a 的支持。</p>
<p>如果 v2 是对v1的字段的语义升级，没有引入新字段，且 v1 消费流程能作为v2 消费流程的兜底，则先发生产者，消费者再发布，即使v2的消息走入v1的流程，消费仍然是无损的。</p>
<p>如果没有这种兜底流程，则要求消息里带有版本信息。</p>
<h1>新老流程不兼容</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 老流程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLeadsItem</span><span class="hljs-params">(SpuDTO spuDTO)</span> &#123;<br>        <span class="hljs-keyword">if</span> (spuDTO == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(isLeaveInformationItem);<br>    &#125;<br>    <br><span class="hljs-comment">// 错误的新流程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLeadsItem</span><span class="hljs-params">(SpuDTO spuDTO)</span> &#123;<br>        <span class="hljs-keyword">if</span> (spuDTO == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 新流程：仍然会被上面的短路影响</span><br>        <span class="hljs-keyword">if</span> () &#123;<br>            <span class="hljs-comment">// </span><br>        &#125;<br>       <br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(isLeaveInformationItem);<br>    &#125;<br>    <br><span class="hljs-comment">// 正确的新流程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLeadsItem</span><span class="hljs-params">(SpuDTO spuDTO)</span> &#123;<br>        <span class="hljs-comment">// 新流程：不被上面的短路影响</span><br>        <span class="hljs-keyword">if</span> () &#123;<br>            <span class="hljs-comment">// </span><br>        &#125;<br>        <br>        <span class="hljs-keyword">if</span> (spuDTO == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(isLeaveInformationItem);<br>    &#125;<br></code></pre></td></tr></table></figure>
<h1>刷数据两张依赖表生命周期不一样</h1>
<p>一张表的生命周期为一年，另一张表生命周期只有3天。</p>
<p>如果要找特别早的历史分区的数据，可以都使用最新的分区，使用创建时间定为早期的历史数据-<strong>如果全量表的历史分区只增不减，而且状态、时间之类的数据不会跨分区变动的话才可以这么做</strong>。</p>
<h1>查表出错</h1>
<ol>
<li>有些全量表上实际上上全天增量表，查询的时候需要按天查询当天数据。</li>
<li>有时候ai生成的 json 提取算法会带有 lower 查询条件，会导致这种提取算法对某些字符串比对查询条件失效，很难处理出来。</li>
</ol>
<h1>es 和 open search 不是所有字段都能查出来</h1>
<ol>
<li>有些字段不能直接用 &gt;= 拼接查询语句，最好用api</li>
<li>不是所有字段都有倒排索引，所以不是所有字段都可以拿来查询。</li>
</ol>
<h1>查询 redis 出错</h1>
<ol>
<li>各种 add、sadd api 实际上只返回操作成功的元素数量，而不是当前集合的元素数量。</li>
<li>当前集合的元素数量来自于 scard。</li>
<li>在 redis 操作的习惯里，出现异常也是靠返回0值之类的值来表达操作失败，这就意味着吞掉异常。吞掉异常以后，外部一定要学会判0，如果忘记判0，则有先后顺序的操作没有阻断：有些操作要求前一个失败不执行后一个，忘记判0意味着后一个可能成功，造成另一种不一致。如：sadd 返回1意味着增加成功一个元素，返回0意味着元素已存在于集合里，抛出异常可以捕获，包装成-1。在外部判断的时候可以认为-1才是失败，0算是一种幂等。</li>
<li>对redis而言，很多操作都是用幂等代替失败的，<strong>操作数代替成功或者失败的设计都要注意0值</strong>。</li>
</ol>
<h1>增量双写忘记迁移存量数据</h1>
<ol>
<li>存量设计同时写 kv + k set。</li>
<li>想要改成单写 k set。</li>
<li>新方案要先上双读新写：旧版本读 kv 来确定号码是不是1，新版本读号码是不是在 k set 里，双读先读 set 再读 k v，新版本只写 k set-这样老数据源不再有新增数据，便于下一步迁移。</li>
<li>然后把 kv 的数据尽量全部迁移进 k set 来。</li>
<li>然后把双读改成单写单读：只写 k set，只读 k set。</li>
</ol>
<h1>Map 里有 duplicate key 导致 map 生成失败，引入兜底逻辑</h1>
<p>上游传入的信息有 cityCode + cityName 去重，过滤器按照这两者去重后，再用 stream api 的 collector 来去重，但是遇到有些信息拿 cityCode 来写入 map 的时候，因为很多城市只是差了一个“市字”而共享 cityCode，而造成 duplicate key 的异常。走入了错误的兜底逻辑。</p>
<ol>
<li>数据在最初录入的时候就应该有表单的规格校验。</li>
<li>系统应该有帮助快速定位问题的保定行保障措施。</li>
</ol>
<h1>生成 traceId 忘记返回</h1>
<p>错误：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">traceId</span> <span class="hljs-operator">=</span> CONTENT_GSID_TL.get();<br><span class="hljs-comment">// 如果traceId为空，就创建一个traceId</span><br><span class="hljs-keyword">if</span> (StringUtils.isBlank(traceId)) &#123;<br>    CONTENT_GSID_TL.set(genGsid());<br>&#125;<br><span class="hljs-keyword">return</span> traceId;<br></code></pre></td></tr></table></figure>
<p>正确：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">traceId</span> <span class="hljs-operator">=</span> CONTENT_GSID_TL.get();<br><span class="hljs-comment">// 如果traceId为空，就创建一个traceId</span><br><span class="hljs-keyword">if</span> (StringUtils.isBlank(traceId)) &#123;<br>    traceId = genGsid();<br>    CONTENT_GSID_TL.set(traceId);<br>&#125;<br><span class="hljs-keyword">return</span> traceId;<br></code></pre></td></tr></table></figure>
<h1>回滚配置文件回滚到目标配置文件的前一版本</h1>
<ol>
<li>v2 进到v5出了问题，想要回滚到v2，选择 diamond 的特定配置历史 v1-v2。</li>
<li>选择回滚，得到了v1。</li>
<li>正确的做法是找到v2-v3的变动项，在这项上回滚。</li>
</ol>
<h1>生成配置文件，忘记在数组里写,</h1>
<ol>
<li>使用 FastJson parseArray，没有异常，仍然得到数组。</li>
<li>上线以前不要随便格式化代码，这样别人不会帮你查出逗号问题了。</li>
<li>修改线上的配置以前要检查新配置是对的-要引入 json validation，要确保是不是和其他人的错误混搭在一起。</li>
<li>要能够跨版本 diff json 配置文件，明确变更只和这一个错误修复有关，和其他修复无关。</li>
</ol>
<h1>fastjson 异常没有被吞掉</h1>
<ol>
<li>默认 fastjson 处理异常 json 数组就是会抛异常的。</li>
<li>所以不要使用判定结果为空来决定是否合理。</li>
<li>如果有可能，在设置 json 新值的时候熔断，不让错误的新值代替旧值，或者让应用带着错误的、空白的新值启动。-<strong>所以配置带有本地缓存的设计是重要的</strong>-这种本地缓存还能让系统平稳度过c/s之间的网络闪断抖动！</li>
</ol>
<p>像阿里的 diamond 本身是要求低频查询的，所以在监听变化以后再更新本地数据，长期查询本地数据是推荐的使用模式。</p>
<h1>上游传的参数的空值有歧义</h1>
<p>参数类型是 String，默认就用 isBlank 来校验。但是实际上它还是一个空数组的序列化结果，也就是是说<code>&quot;[]&quot;</code>也可能是一个空值。</p>
<h1>复制签名算法以前没有对待签名字段进行排序</h1>
<p>我们的签名本质上是对一个字符串进行签名，怎样把一个对象表达为一个字符串，是需要有规律的。</p>
<h1>修改日志的 logger 可能触发监控和告警减少</h1>
<ol>
<li>日志的 logger 变了以后，监控和告警可能跌0。</li>
</ol>
<h1>不重复的日期切面表达式</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(public * com.amap.us.leads.offline..*Service.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pureServiceMethods</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@Pointcut(&quot;execution(public * com.amap.us.leads.offline..*ServiceImpl.*(..))&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">serviceImplMethods</span><span class="hljs-params">()</span> &#123;<br>&#125;<br><br><span class="hljs-meta">@Around(&quot;pureServiceMethods() || serviceImplMethods()&quot;)</span><br><span class="hljs-keyword">public</span> Object <span class="hljs-title function_">logServiceExecution</span><span class="hljs-params">(ProceedingJoinPoint joinPoint)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>
<ul>
<li>Spring AOP 对每个连接点（join point）只会计算一次这个表达式<br>
即使连接点同时满足两个切点，只要整个 || 表达式结果为 true，通知就只执行一次。</li>
</ul>
<h1>invokeAll 就触发阻塞，而不是 future.get 的时候触发</h1>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">long</span> <span class="hljs-variable">concurrentStartTime</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>          <br>          <span class="hljs-comment">// 均衡任务执行时间，每个任务执行100ms</span><br>          List&lt;Future&lt;Pair&lt;String, Map&lt;String, String&gt;&gt;&gt;&gt; futureList = THREAD_POOL_EXECUTOR.invokeAll(tasks, <span class="hljs-number">300L</span>, TimeUnit.MILLISECONDS);<br>          <br>          <span class="hljs-comment">// 记录并发任务整体耗时</span><br>          <span class="hljs-type">long</span> <span class="hljs-variable">concurrentCost</span> <span class="hljs-operator">=</span> System.currentTimeMillis() - concurrentStartTime;<br>          LoggerUtil.info(LOGGER, <span class="hljs-string">&quot;NumberBindOutIdServiceImpl|fullOutIdInfo|concurrentTasks|bizType:&#123;&#125;|srcType:&#123;&#125;|taskCount:&#123;&#125;|totalCost:&#123;&#125;ms&quot;</span>,<br>              outIdInfo.getBizType(), outIdInfo.getSrcType(), tasks.size(), concurrentCost);<br><br>          <span class="hljs-keyword">for</span> (Future&lt;Pair&lt;String, Map&lt;String, String&gt;&gt;&gt; f : futureList) &#123;<br>              Pair&lt;String, Map&lt;String, String&gt;&gt; detailPair = f.get();<br>          &#125;<br></code></pre></td></tr></table></figure>
<p>这个日志打得是对的，这样就可以监控到超时。</p>
<p>这个 invokeAll 有两个特点：</p>
<ol>
<li>超时不准。看起来似乎 FutureTask.get() 的超时是准的，但是 invokeAll 有一个带有 cancel 的 finally，和提交线程池的submit等待过程，可能影响系统性能。这里的设计给我们的启示是，<strong>get本身才带有超时，在我们获得 Future 接口以前，包装不出其他阻塞或者超时 api。</strong></li>
<li>超时后会中断超时任务，一般的 FutureTask.get() 不带有这个功能。对于底层有 io 的任务而言，似乎主动帮我们中断 worker 线程能够帮助我们提前释放 cpu。</li>
</ol>
<h1>容灾脚本出错</h1>
<ol>
<li>容灾脚本没有写好备份，直接插入新的配置，导致老配置丢失。</li>
</ol>
<p>正确做法：新配置插入前先 rename 老的元素，回切脚本再复制回来。</p>
<ol start="2">
<li>收集 cpName 的时候没有做不同来源的 merge，导致只有一部分 cpName 被降级了。</li>
<li>容灾脚本不能在多中心执行，提供的多中心只是一个配置维度，是为了让容灾脚本读出来，然后想办法写到配置文件里，给特定的业务单元读出来用的。但是每次写配置中心，都是强广播到全部的配置订阅者节点上。</li>
<li>如果要在脚本的执行间通信，插入一个原节点之外的类似名字的兄弟节点作为备份，或者插入一个全局标志位，总是扩展性好，而不需要改原始读配置代码的做法。</li>
</ol>
<h1>突然出现的 success</h1>
<ol>
<li>原本代码里没有 boolean success。</li>
<li>突然出现这个 success 以后，构造器没有都 set true，导致某些接口返回 false。</li>
<li>接收响应的低代码平台代码能理解这个 success，导致请求失败。</li>
</ol>
<h1>修改读取配置的代码，但是上线未经测试</h1>
<p>有一个数据类型用错，导致启动本来正常的配置反而反序列化出错。</p>
<p>所有的“补强型”变更都应该在验证完了以后，验证原始流程。</p>
<p>这类问题的背后问题是，我们使用不同的反序列化工具：jackson/fastjson和对它们封装的 JsonUtil 对异常-错误格式、空值的处理路径是不一样的，如果不经过实验，我们无法确认我们的异常处理分支是不是会被激活走入，我们可能会制造无意中的异常或者忽视/吞没了异常。</p>
<h1>尝试使用枚举来实现策略模式，却无法引用成员变量</h1>
<p>为什么枚举无法访问外部类的Spring注入成员？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PaymentService paymentService;  <span class="hljs-comment">// Spring注入的Bean</span><br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">OrderStrategy</span> &#123;<br>        DISCOUNT &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// ❌ 编译错误：无法访问paymentService</span><br>                paymentService.process();<br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>核心原因：</p>
<ul>
<li>枚举的静态特性：枚举实例在类加载时就被创建，此时Spring容器还未初始化</li>
<li>生命周期不匹配：枚举是JVM级别的单例，而Spring Bean是容器级别的</li>
<li>枚举无法依赖注入：枚举不能被Spring管理，无法使用@Autowired</li>
</ul>
<p>方案1：通过方法参数传递依赖（最简单）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PaymentService paymentService;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">OrderStrategy</span> &#123;<br>        DISCOUNT &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(PaymentService service)</span> &#123;<br>                service.processDiscount();<br>            &#125;<br>        &#125;,<br>        NORMAL &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(PaymentService service)</span> &#123;<br>                service.processNormal();<br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(PaymentService service)</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleOrder</span><span class="hljs-params">(OrderStrategy strategy)</span> &#123;<br>        <span class="hljs-comment">// 传递依赖进去</span><br>        strategy.execute(paymentService);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>方案2：使用Spring管理的策略类 + 枚举作为Key（推荐）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 定义策略接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">OrderStrategy</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Order order)</span>;<br>    OrderType <span class="hljs-title function_">getType</span><span class="hljs-params">()</span>; <span class="hljs-comment">// 返回对应的枚举类型</span><br>&#125;<br><br><span class="hljs-comment">// 2. 枚举定义策略类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">OrderType</span> &#123;<br>    DISCOUNT,<br>    NORMAL,<br>    VIP<br>&#125;<br><br><span class="hljs-comment">// 3. 具体策略实现（可以注入依赖）</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderStrategy</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PaymentService paymentService;<br>    <br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> DiscountCalculator calculator;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Order order)</span> &#123;<br>        <span class="hljs-type">double</span> <span class="hljs-variable">discount</span> <span class="hljs-operator">=</span> calculator.calculate(order);<br>        paymentService.processDiscount(order, discount);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> OrderType <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> OrderType.DISCOUNT;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VipStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderStrategy</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> VipService vipService;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Order order)</span> &#123;<br>        vipService.processVipOrder(order);<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> OrderType <span class="hljs-title function_">getType</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> OrderType.VIP;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 4. 策略管理器（自动注册）</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderStrategyManager</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;OrderType, OrderStrategy&gt; strategyMap;<br>    <br>    <span class="hljs-comment">// Spring自动注入所有OrderStrategy实现类</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">OrderStrategyManager</span><span class="hljs-params">(List&lt;OrderStrategy&gt; strategies)</span> &#123;<br>        <span class="hljs-built_in">this</span>.strategyMap = strategies.stream()<br>            .collect(Collectors.toMap(<br>                OrderStrategy::getType,<br>                Function.identity()<br>            ));<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">executeStrategy</span><span class="hljs-params">(OrderType type, Order order)</span> &#123;<br>        <span class="hljs-type">OrderStrategy</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> strategyMap.get(type);<br>        <span class="hljs-keyword">if</span> (strategy == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unknown strategy: &quot;</span> + type);<br>        &#125;<br>        strategy.execute(order);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 5. 使用</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> OrderStrategyManager strategyManager;<br>    <br>    <span class="hljs-meta">@PostMapping(&quot;/order&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">createOrder</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Order order)</span> &#123;<br>        strategyManager.executeStrategy(order.getType(), order);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>方案3：使用自定义注解 + 自动注册（企业级方案）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1. 自定义注解</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> StrategyHandler &#123;<br>    OrderType <span class="hljs-title function_">value</span><span class="hljs-params">()</span>;<br>&#125;<br><br><span class="hljs-comment">// 2. 策略实现</span><br><span class="hljs-meta">@StrategyHandler(OrderType.DISCOUNT)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DiscountStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderStrategy</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PaymentService paymentService;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Order order)</span> &#123;<br>        paymentService.processDiscount(order);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 3. 自动注册器</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StrategyAutoRegistrar</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ApplicationContext context;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;OrderType, OrderStrategy&gt; strategyMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EnumMap</span>&lt;&gt;(OrderType.class);<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">registerAll</span><span class="hljs-params">()</span> &#123;<br>        Map&lt;String, Object&gt; beans = context.getBeansWithAnnotation(StrategyHandler.class);<br>        beans.values().forEach(bean -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> OrderStrategy strategy) &#123;<br>                <span class="hljs-type">StrategyHandler</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> bean.getClass().getAnnotation(StrategyHandler.class);<br>                strategyMap.put(annotation.value(), strategy);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> OrderStrategy <span class="hljs-title function_">getStrategy</span><span class="hljs-params">(OrderType type)</span> &#123;<br>        <span class="hljs-keyword">return</span> strategyMap.get(type);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>方案4：使用静态持有器模式（不推荐，但可用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> PaymentService paymentService;<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 初始化后设置到枚举的静态holder中</span><br>        OrderStrategy.setContext(<span class="hljs-built_in">this</span>);<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">OrderStrategy</span> &#123;<br>        DISCOUNT &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span> &#123;<br>                getContext().paymentService.process();<br>            &#125;<br>        &#125;;<br>        <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> OrderService context;<br>        <br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setContext</span><span class="hljs-params">(OrderService service)</span> &#123;<br>            context = service;<br>        &#125;<br>        <br>        <span class="hljs-keyword">protected</span> OrderService <span class="hljs-title function_">getContext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> context;<br>        &#125;<br>        <br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">()</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h1>从老接口设计新接口参数出错</h1>
<ol>
<li>没有查看老文档，一一检视。</li>
<li>没有查看下游的请求文档，看看有些参数是专门给下游用的-本应用本身是个网关型业务。</li>
<li>没有从日志看线上的 http 请求的端的一揽子参数。</li>
<li>php 项目的参数模式是多态的，不一定就是数组或者非数组的模式。</li>
</ol>
<h1>监控上线后没有在完整周期里看数据</h1>
<ol>
<li>不清楚真实的水位线在哪里，不好配上下界监控。</li>
<li>无法回答领导的问题-对问题的回答要达到-领导问你要像问产品一样，可以直接得到最佳的产品策略的答案。</li>
<li>没有办法回答波动情况，也不知道数据的关联关系。</li>
</ol>
<h1>重构线程池生成流程，去掉了 createRejectedExecutionHandler</h1>
<p>原本通过本线程来执行，现在报 RejectionException。<br>
Spring 的 TaskDecorator 不能拿来当拒绝策略来用，是拒绝策略决定了是否经过本线程执行。</p>
<h1>线程池调用 invokeAll 一次提交了大量任务，触发线程池拒绝</h1>
<p>任务本身不涉及io，只是内存里数据转换，使用串行执行吞吐率更高，上下文切换更少。但是如果一次提交这么多任务，就会造成 invokeAll 直接触发拒绝-因为提交任务到 execute 的速度通常会快于底层的 worker 线程处理任务的速度。</p>
<p>这样的设计其实是错误地模仿了 forkjoin 框架，把计算密集型的任务进行了无聊的拆解，只有用 callerRun 的策略的线程池能顶得住这样的拆解，一般情况下一个 for 循环的兼容性会更好。</p>
<p>如果要了解线程池的被调用情况，可以使用如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> RejectedExecutionHandler <span class="hljs-title function_">createRejectedExecutionHandler</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> (r, e) -&gt; &#123;<br>        <span class="hljs-comment">// 记录被拒绝的任务信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">taskType</span> <span class="hljs-operator">=</span> r.getClass().getSimpleName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">taskInfo</span> <span class="hljs-operator">=</span> r.toString();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> Thread.currentThread().getName();<br>        LoggerUtils.error(LOGGER, <span class="hljs-string">&quot;async task rejected and executed by caller thread. &quot;</span> +<br>                <span class="hljs-string">&quot;taskType=&#123;&#125;, taskInfo=&#123;&#125;, callerThread=&#123;&#125;, taskCount=&#123;&#125;, completedTaskCount=&#123;&#125;, &quot;</span> +<br>                <span class="hljs-string">&quot;largestPoolSize=&#123;&#125;, poolSize=&#123;&#125;, activeCount=&#123;&#125;, queueSize=&#123;&#125;&quot;</span>,<br>                taskType, taskInfo, threadName, e.getTaskCount(), e.getCompletedTaskCount(),<br>                e.getLargestPoolSize(), e.getPoolSize(), e.getActiveCount(), e.getQueue().size());<br>        <span class="hljs-keyword">if</span> (!e.isShutdown()) &#123;<br>            r.run();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>可以通过类路径来定位任务的蛛丝马迹。但是线程池本身要能够在 execute 传递线程上下文，而且要尽可能使用 Transmittable。</p>
<h1>错误的列名导致 sql 出错</h1>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 错误的sql</span><br><span class="hljs-keyword">SELECT</span><br>  <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span><br>  `leads_failed_retry_record`<br><span class="hljs-keyword">where</span><br>  `cp_name` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;residential_lkdcps_api&#x27;</span><br>  <span class="hljs-keyword">AND</span> <span class="hljs-string">&#x27;gmt_create&#x27;</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2025-12-30 00:00:00&#x27;</span><br>  <span class="hljs-keyword">AND</span> `retry_status` <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>  <span class="hljs-keyword">AND</span> `retry_times`  <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br><br><span class="hljs-comment">-- 正确的sql</span><br><span class="hljs-keyword">SELECT</span><br>  <span class="hljs-operator">*</span><br><span class="hljs-keyword">FROM</span><br>  `leads_failed_retry_record`<br><span class="hljs-keyword">where</span><br>  `cp_name` <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;residential_lkdcps_api&#x27;</span><br>  <span class="hljs-keyword">AND</span> `gmt_create` <span class="hljs-operator">&gt;=</span> <span class="hljs-string">&#x27;2025-12-30 00:00:00&#x27;</span><br>  <span class="hljs-keyword">AND</span> `retry_status` <span class="hljs-operator">=</span> <span class="hljs-number">2</span><br>  <span class="hljs-keyword">AND</span> `retry_times`  <span class="hljs-operator">&gt;</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>
<p><code>AND 'gmt_create' &gt;= '2025-12-30 00:00:00'</code>是个合法且永远正确的句子。</p>
<h1>敏感告警应该配置阈值为大于0</h1>
<p>而不是大于1。</p>
<h1>metaspace 提前 fgc</h1>
<p>原因：Metaspace 触发 Full GC 的条件是：committed memory &gt;= MetaspaceSize，而不是 used memory &gt;= MetaspaceSize。</p>
<h1>误以为是单机房执行的脚本被多机房执行</h1>
<ol>
<li>存在一个中心的配置文件。</li>
<li>容灾服务有若干个机房维度可以修改一个配置a。</li>
<li>在每个维度都执行一个脚本修改a，然后发布到那个中心一次。</li>
<li>因为存在多机房，所以a被不可重复执行的脚本修改了，导致脚本错乱。</li>
</ol>
<h1>环境配置隔离了操作</h1>
<p>设定了只在本环境读和写。生产环境配置了灰度状态，但是进入灰度状态的配置的环境是 ONLINE，不是 GRAY，这导致进入 GRAY 环境的流量读不到 GRAY 状态的配置。</p>
<p>解法：</p>
<ol>
<li>把所有流量导入 ONLINE 环境。</li>
<li>ONLINE 环境的可读状态是 ONLINE，GRAY 环境的可读状态是 GRAY。</li>
</ol>
<p>但是这样设计有个缺点，<strong>ONLINE 状态的配置在灰度上读不到了</strong>。</p>
<p>可以有一个折中的做法：</p>
<ol>
<li>任何线上版本在修改时，先 fork 出一个待上线的草稿版本，在这个版本上修改-<strong>类似 cow 的改表版本</strong>。</li>
<li>把这个改表版本改成灰度状态。</li>
<li>这样就有了2个环境都可读的配置行。</li>
<li>共享数据库的 env，但是使用不同的灰度状态来区分环境，实现环境隔离灰度能力的时候可以使用这种方法。</li>
<li>这种折中方法的缺点是：发布了生产以后，还需要专门再生成一个新的灰度版本给灰度环境用。</li>
</ol>
<p>还有一种折中的方法：</p>
<ol>
<li>先读灰度状态，读不到就读生产状态。</li>
<li>缺点是，以后不允许存在内容为空的灰度配置了。</li>
</ol>
<h1>表面上看上去配置在配置系统里</h1>
<p>但是搜索缓存都搜索不到。</p>
<p>这时候应该先想配置系统的缓存不可能长期出错。所以真实的配置可能存在另一个配置系统里，只是格式和主配置系统一致，而且被主配置系统的配置嵌套引用了。</p>
<h1>原始的日志文件里只有空格</h1>
<p>但是出现在 kibana 系统里以后出现了 tab 之类的制表符。经过 ELK 之类的方案提取，日志组件对日志的显示会让不可见字符相比起原始的日志文件有差别。</p>
<p>但是像 sunfire/xflash 的监控是能把制表符、空格都统一识别为一类空格的。</p>
<h1>配置反序列化类配错，导致反序列化出 {} 对象，然后再序列化丢失数据</h1>
<p>光是这样是不够的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">templateContentObj</span> <span class="hljs-operator">=</span> JSONObject.parseObject(templateContent, clazz);<br><span class="hljs-keyword">if</span> (templateContentObj == <span class="hljs-literal">null</span>) &#123;<br>    LoggerUtils.error(LOGGER, <span class="hljs-string">&quot;TemplateService|templateContentProcess|error|templateContentObjIsNull|nodeId:&#123;&#125;&quot;</span>, nodeId);<br>    <span class="hljs-keyword">return</span> templateContent;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>因为空对象不会得到 null 和异常。</p>
<p>需要加上如下实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmptyJson</span><span class="hljs-params">(Object obj)</span> &#123;<br>        <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> JSONObject.parseObject(JSONObject.toJSONString(obj));<br>        <span class="hljs-keyword">return</span> jsonObject.isEmpty();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isContentDiff</span><span class="hljs-params">(String original, Object obj)</span> &#123;<br>        <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> !JSONObject.parseObject(original).equals(JSONObject.parseObject(JSONObject.toJSONString(obj)));<br>    &#125;<br></code></pre></td></tr></table></figure>
<p>然后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; clazz = Class.forName(oldTemplateClass);<br>        <span class="hljs-type">Object</span> <span class="hljs-variable">templateContentObj</span> <span class="hljs-operator">=</span> JSONObject.parseObject(templateContent, clazz);<br>        <span class="hljs-keyword">if</span> (templateContentObj == <span class="hljs-literal">null</span>) &#123;<br>            LoggerUtils.error(LOGGER, <span class="hljs-string">&quot;TemplateService|templateContentProcess|error|templateContentObjIsNull|nodeId:&#123;&#125;&quot;</span>, nodeId);<br>            <span class="hljs-keyword">return</span> templateContent;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (isEmptyJson(templateContentObj) || isContentDiff(templateContent, templateContentObj)) &#123;<br>            LoggerUtils.error(LOGGER, <span class="hljs-string">&quot;TemplateService|templateContentProcess|error|invalidTemplateContentObj|nodeId:&#123;&#125;&quot;</span>, nodeId);<br>            <span class="hljs-keyword">return</span> templateContent;<br>        &#125;<br></code></pre></td></tr></table></figure>
<h1>ECMAScript 2015 的自动变量名语法导致重写逻辑错误</h1>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(&#123; interfaceType, bodyMapper, headerMapper &#125;);<br></code></pre></td></tr></table></figure>
<p>这样会导致匿名对象的成员变量名和当前变量名一致。<br>
如果我要把 headerMapper 改成 filteredHeaderMapper，是不是，匿名对象的 data 也会变成 filteredHeaderMapper，这样数据就对不上了。</p>
<h1>JSONObject.parseObject(templateContent, clazz) 得到多余的值</h1>
<p>比如某个 clazz 有个成员是 boolean 类型，原始的字符串里没有这个成员的值，得到的对象就会产生缺省的 false，再次序列化的时候字符串的值就不一致了。</p>
<p>错误的 jsondiff 函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isContentDiff</span><span class="hljs-params">(String original, Object obj)</span> &#123;<br>       <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> !JSONObject.parseObject(original).equals(JSONObject.parseObject(JSONObject.toJSONString(obj)));<br>   &#125;<br></code></pre></td></tr></table></figure>
<p>稍微正常一点的 jsondiff 函数：无。因为缺省 value 可能嵌套在很深的类结构里。</p>
<p>JSONObject 序列化和反序列化的异常情况实在太多，必须要拿典型的测试用例测试过才能发布上线：</p>
<ol>
<li>是否抛出异常。</li>
<li>什么情况下会返回空值。</li>
<li>什么情况下不返回空值会返回空对象。</li>
<li>是否自动赋缺省值。</li>
<li>是否会让某些 getter 方法有值。</li>
</ol>
<p>4 和 5 要求 jsondiff 的时候增加不比对的字段-ignoreKeys。</p>
<h1>迁移文档已经写了全部的待迁移配置，但是没有全部移动进灰度配置里</h1>
<p>所有文档在迁移到下一位置的时候都应该带上标志位，这样恢复中断的工作才有起点。</p>
<p>配置监控的时候一定要有漏配迁移配置的监控。</p>
<h1>如果确定不能使用某类灰度比对 diff 功能，坚决不能开启相关的配置</h1>
<p>假设有 template diff 和 object diff 两类 diff 能力。</p>
<p>在灰度放量以前，要检视所有的可以用某类 diff 能力，不能用某类 diff 能力的配置，区别出来，不用一次性全量配 diff。</p>
<p>这样会错失观察能用的基础 diff-template diff 的机会，而也不能用到 object diff。</p>
<p><strong>只有能走入特殊路径的场景，能够使用更深的配置，否则应该使用基础配置。</strong></p>
<h1>关闭灰度环境的 bug fix 和 报警</h1>
<p>有些正式流量会进入灰度环境产生灰度结果，有些 bug 只有灰度环境有。无意之中关闭了灰度环境的发布就会导致灰度环境出现错误结果。</p>
<p>而且因为调试关闭了灰度环境的告警，触发线上问题。</p>
<h1>灰度环境的其他 bug</h1>
<ol>
<li>灰度逻辑产生了新的数据记录，只能被灰度逻辑处理，但是后面又被生产旧代码处理了。</li>
<li>灰度依赖于下游各种单点，下游发布导致灰度故障。</li>
</ol>
<p>对于第一个问题的解是：</p>
<ol>
<li>流量路由。</li>
<li>数据库设计、处理流程设计要向前兼容-backward compatibility。也就是新的内容被老的流程读到，既不影响老的流程，也不影响后续再被新的流程处理。</li>
</ol>
<h1>hsf 不优雅关闭</h1>
<pre><code class="hljs mermaid">sequenceDiagram
    %% 修改前的场景
    rect rgb(255, 240, 240)
        Note over App, ConfigServer: 修改前：缺少优雅下线等待
        App-&gt;&gt;App: 执行 ./appctl.sh stop
        App-&gt;&gt;App: 调用 offline()
        App-&gt;&gt;App: offline_hsf() 发送注销请求
        App-&gt;&gt;ConfigServer: curl localhost:12201/hsf/offline
        ConfigServer--&gt;&gt;App: 返回成功
        App-&gt;&gt;App: offline() 立即返回 ❌
        App-&gt;&gt;App: stop() 继续执行，等待 15 秒
        App-&gt;&gt;App: stop_pandora_boot_by_supervisor()
        App-&gt;&gt;JVM: 发送 kill 信号
        JVM-&gt;&gt;JVM: 接收到 kill 信号
        JVM-&gt;&gt;JVM: HSF shutdown hook 触发
        JVM-&gt;&gt;JVM: 销毁 HSF 内部资源 ❌
        Note right of JVM: Directory 已被销毁
        ConfigServer-&gt;&gt;ConfigServer: 异步处理注销请求...
        Note right of ConfigServer: 还在处理中 ❌
        Consumer-&gt;&gt;ConfigServer: 获取服务列表
        ConfigServer--&gt;&gt;Consumer: 返回包含下线实例的地址 ❌
        Consumer-&gt;&gt;App: 发起 HSF 调用
        App-&gt;&gt;JVM: 尝试调用服务
        JVM--&gt;&gt;App: 抛出异常 ❌
        Note right of App: Directory already destroyed
    end

    %% 修改后的场景
    rect rgb(240, 255, 240)
        Note over App, ConfigServer: 修改后：添加 40 秒优雅下线等待
        App-&gt;&gt;App: 执行 ./appctl.sh stop
        App-&gt;&gt;App: 调用 offline()
        App-&gt;&gt;App: offline_hsf() 发送注销请求
        App-&gt;&gt;ConfigServer: curl localhost:12201/hsf/offline
        ConfigServer--&gt;&gt;App: 返回成功
        App-&gt;&gt;App: 等待 40 秒 ⭐
        Note right of App: ConfigServer 异步处理注销
        ConfigServer-&gt;&gt;ConfigServer: 从注册中心移除服务地址 ✅
        ConfigServer-&gt;&gt;ConfigServer: 通知消费者端
        Consumer-&gt;&gt;Consumer: 更新本地服务列表缓存 ✅
        Note right of Consumer: 新请求不再路由到此实例
        App-&gt;&gt;App: 等待完成
        App-&gt;&gt;App: stop() 继续执行，等待 15 秒
        App-&gt;&gt;App: stop_pandora_boot_by_supervisor()
        App-&gt;&gt;JVM: 发送 kill 信号
        JVM-&gt;&gt;JVM: 接收到 kill 信号
        JVM-&gt;&gt;JVM: HSF shutdown hook 触发
        JVM-&gt;&gt;JVM: 销毁 HSF 内部资源 ✅
        Note right of JVM: 此时已无新流量进入 ✅
    end</code></pre>
<p>解法：</p>
<ol>
<li>向注册中心注销自己。</li>
<li>等待足够长的事件。</li>
<li>再尝试对本容器/jvm 发出 stop/kill 信号。</li>
</ol>
<pre><code class="hljs mermaid">graph TD
    A[stop 命令] --&gt; B[offline 函数]
    B --&gt; C[offline_hsf 函数]
    C --&gt; D[等待 40 秒]
    D --&gt; E[stop 函数继续]
    E --&gt; F[等待 15 秒]
    F --&gt; G[stop nginx]
    G --&gt; H[stop tomcat]
    H --&gt; I[stop pandora boot]
    I --&gt; J[停止 supervisord]
    J --&gt; K[kill supervisord 进程]
    K --&gt; L[清理 GC 日志]
    L --&gt; M[清理 PID 文件]</code></pre>
<pre><code class="hljs mermaid">sequenceDiagram
    participant Script as appctl.sh
    participant HSF as HSF 服务
    participant Nginx as Nginx
    participant Tomcat as Tomcat
    participant JVM as Java 进程
    participant Supervisord as Supervisord

    Script-&gt;&gt;HSF: 1. offline_hsf() 注销服务
    Note over HSF: HSF Directory 被标记为销毁
    Script-&gt;&gt;Script: 2. 等待 40 秒
    Note over Script: ConfigServer 处理注销
    Script-&gt;&gt;Script: 3. 等待 15 秒
    Script-&gt;&gt;Nginx: 4. stop nginx
    Note over Nginx: Nginx 进程停止
    Script-&gt;&gt;Tomcat: 5. stop tomcat
    Note over Tomcat: Tomcat 进程停止
    Script-&gt;&gt;JVM: 6. stop java (supervisorctl stop)
    Note over JVM: JVM 接收停止信号
    JVM-&gt;&gt;JVM: HSF shutdown hook 触发
    Note over JVM: 销毁 HSF 内部资源
    JVM-&gt;&gt;JVM: Spring 容器关闭
    JVM-&gt;&gt;JVM: JVM 进程停止
    Script-&gt;&gt;Supervisord: 7. kill supervisord
    Note over Supervisord: Supervisord 进程停止</code></pre>
<p>metaq 问题也是类似的：</p>
<ol>
<li>需要自己主动向本地的端口发请求-而不是向远端的服务注册中心，让本地的 consumer 注销自己。</li>
<li>等待一定时间后，才开始 kill 其他组件。</li>
</ol>
<p>由此可以推导出如果基于 consul 来做服务注册与发布。优雅下线以前要先主动解注册自己。</p>
<h1>依赖于代码的 diamond 配置没有正确发布</h1>
<ol>
<li>先发了代码，然后才发现忘记发布配置，幸好代码是可以无配置发布的。</li>
<li>发布代码的时候，没有检查线上和线下的区别。</li>
</ol>
<p>正确的做法，不要用脑袋来组织 checklist，要通过原始的核心设计来推导依赖，特别是由复杂发布顺序的情况下。</p>
<h1>有缺省值的 MySQL 列插入不成功</h1>
<p>有一列的定义是<code>NOT NULL DEFAULT 1</code>，但是执行插入语句却出错了。</p>
<p>核心原因是使用了 MyBatis 普通 insert 类型的功能。普通 insert 会产生全部的插入列 values 列表，且那一列插入了 null。所以缺省值并不生效，系统会理解为我们有意想要插入 null，触发了 violation of constraint。</p>
<p>第一个直觉反应的解应该是使用 insertSelective 的方法，对未赋值的列一律不予插入。</p>
<p>除非我们<strong>有意要让代码检验出不合法的 null 值，或者需要显式插入 null</strong>，否则我们不应该使用普通 insert。</p>
<h1>常见的 axb 会和隐藏的 axn 冲突</h1>
<p>实际上一个设备号才代表一个唯一的 b-也就是普通用户。在一个 x 号码同时支持 axn 和 axb 的情况下，axn 和 axb 是冲突的，因为同一个b可能会从x号码打过来，那么应该使用哪个绑定关系呢？</p>
<p>新的 axn 会淘汰 axb，理论上 axb 也会淘汰老的 axb。</p>
<p>重复出现的 ax，bx，ab 冲突都应该被处理。</p>
<p>对于同一个商家而言，a1 和 a2 本身也是实际上也是同一个商家的重复绑定了。</p>
<p>**axb 冲突的本质是一个从一个方向越过 x 不能有任何分支。但是 a/b 可以有多个分支 x。**但是如果 axb的ab同时变换，axb又支持并发连接。</p>
<h1>hsf client 的调用，被上层线程池中断触发消息为 null 的 TimeOutException</h1>
<p>一个 hsf 的 client，本身有一个超时时间5s。<br>
但是这个 hsf client 本身在一个线程池里被调用，这个线程池有个超时的 invokeAll，超时时间为 2s。超过2s以后，线程池中断让 hsf client 的调用也中断。</p>
<pre><code class="hljs mermaid">flowchart TD
    A[发起HSF调用] --&gt; B[创建请求ID]
    B --&gt; C[设置客户端超时时间]
    C --&gt; D[创建超时任务]
    D --&gt; E[加入时间轮HashedWheelTimer]
    E --&gt; F[发送网络请求]
    
    subgraph 时间轮超时检测
        G[时间轮定时检测]
        G --&gt; H&#123;是否达到超时时间?&#125;
        H --&gt;|是| I[触发超时回调]
        I --&gt; J[构造HSFTimeOutException]
    end
    
    subgraph 外部线程中断
        K[外部线程池中断]
        K --&gt; L[调用Thread.interrupt]
        L --&gt; M[设置中断标志位]
        M --&gt; N[HSF检测中断状态]
        N --&gt; O[提前终止调用]
        O --&gt; P[抛出InterruptedException]
    end
    
    F -- 正常响应 --&gt; Q[返回结果]
    F -- 超时 --&gt; J
    F -- 中断 --&gt; P
    
    J --&gt; R[返回HSFTimeOutException]
    P --&gt; S[返回InterruptedException]
    
    style E fill:#FFE4B5,stroke:#333
    style G fill:#FFE4B5,stroke:#333</code></pre>
<h1>JPDA_ENABLE=1不应该在普通 dockerfile 里打开</h1>
<p>只有调试的时候需要使用这个配置，放在 dockerfile 里就对全环境生效了。如果不能实现差异化的预发远程调试，则每次用完都要把它注释掉。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/01/12/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%95%B4%E7%90%86/">https://magicliang.github.io/2026/01/12/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%95%B4%E7%90%86/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%8D%89%E8%99%AB/">捉虫</a><a class="post-meta__tags" href="/tags/%E5%A5%87%E6%80%9D%E5%A6%99%E6%83%B3/">奇思妙想</a></div><div class="post-share"><div class="social-share" data-image="/2026/01/12/%E5%B8%B8%E8%A7%81%E6%95%85%E9%9A%9C%E6%95%B4%E7%90%86/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E9%9C%80%E8%A6%81%E4%B8%80%E4%B8%AAcoe.png" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2022/05/10/%E4%B8%80%E4%B8%AA%E9%9A%90%E8%97%8F%E4%BA%8617%E5%B9%B4%E7%9A%84-JDK-Bug/" title="一个隐藏了17年的 JDK Bug"><img class="cover" src="/2022/05/10/%E4%B8%80%E4%B8%AA%E9%9A%90%E8%97%8F%E4%BA%8617%E5%B9%B4%E7%9A%84-JDK-Bug/%E4%BE%9D%E6%97%A7%E6%97%A0%E9%99%90%E9%98%BB%E5%A1%9E.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-10</div><div class="info-item-2">一个隐藏了17年的 JDK Bug</div></div><div class="info-2"><div class="info-item-1">摘要 本文介绍了发现JDK-8286463 : DiscardPolicy may block invokeAll forever的全过程。 问题起因 因为工作需要，笔者最近考虑利用 Java 标准文档里的标准 API做一个批量执行任务的框架：  这个 API 的语义是：  批量执行任务。 在任务执行完成（不管任务是被正常终止还是异常终止）后，批量返回一个持有任务状态的 Future 列表。  我们团队内部的代码里已经有了一个自定义线程池的工厂方法，大义是： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * 一个有缺陷的线程池构造器 * * @param corePoolSize      the number of threads to keep in the pool, even *                          if they are idle, unless &#123;@code allowCoreThreadTimeOut&#125; is ...</div></div></div></a><a class="pagination-related" href="/2025/01/13/%E7%81%B5%E6%9C%BA%E4%B8%80%E5%8A%A8%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/" title="灵机一动的程序设计"><img class="cover" src="/img/wall-paper-40.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-01-13</div><div class="info-item-2">灵机一动的程序设计</div></div><div class="info-2"><div class="info-item-1">怎样用此列表来排序彼列表 123456789101112131415161718192021222324252627282930313233private List&lt;TagGroup&gt; reorder(Long id, List&lt;TagGroup&gt; entities) &#123;    final AccountSettings accountSettings = getAccountSetting(            id);    final List&lt;Long&gt; tagGroupOrders = accountSettings.getTagGroupOrders();    // 根据 tagGroupOrders 里提供的 tagGroupId 对 entities 排序    if (CollectionUtils.isNotEmpty(tagGroupOrders)) &#123;        entities.sort((o1, o2) -&gt; &#123;            int index1 = tagGro...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">手写 sql</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%81%E5%BA%A6%E5%8D%B1%E9%99%A9%E7%9A%84%E9%94%99%E8%AF%AF"><span class="toc-number">1.1.</span> <span class="toc-text">极度危险的错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%AD%A2%E6%89%8B%E5%86%99-sql-%E8%A2%AB%E6%B3%A8%E5%85%A5"><span class="toc-number">1.2.</span> <span class="toc-text">防止手写 sql 被注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mybatis-%E7%9A%84%E6%9B%BF%E6%8D%A2%E9%9A%BE%E7%82%B9"><span class="toc-number">1.3.</span> <span class="toc-text">mybatis 的替换难点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">熔断和降级仍然导致 cpu 过高</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">老的表如果预先没有加好查询索引，则后续维护的 orm 用户更加容易忘记加</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">nginx 集群的 tps 只有 18 万，不容易动态扩容。因为没有打招呼，所以没有扩容。前后端没有做过针对活动的限流调整。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">改配置无前置正确性校验和运营审核卡点</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">不同业务没有做数据层面的隔离，而只做了应用层面的隔离</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">MySQL 官方bug</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">平台有两种工作模式时，无缓存的工作模式没有经过深入测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">动态配置服务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">Java 7 的 code cache 问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">线程池的父子任务互相等待，导致线程池耗尽，从 worker 线程池一直阻塞到</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">ES 扩容到错误的机器，引发频发降级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">nginx 的配置模块 lru cache不够用，导致部分配置丢失，导致流量偏移，拖垮中心单元</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">MySQL 里使用 bigint 表达自增 id，但 Java 代码里使用 Integer，导致 ORM 映射失败</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">beandefinition 里面依赖 bean</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">高流量的时候，大量的 IO 线程在线程池里等待任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">读取过大的包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">18.</span> <span class="toc-text">线下的自动化测试用例数据失效</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">19.</span> <span class="toc-text">hashset 需要 hashcode 才能set，但一个空对象不能放进 hashcode 里面</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">20.</span> <span class="toc-text">Spring 代理问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">21.</span> <span class="toc-text">mvn deploy release 仓库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">22.</span> <span class="toc-text">类路径冲突</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">23.</span> <span class="toc-text">性能优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">24.</span> <span class="toc-text">Circular Dependencies in Spring</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">25.</span> <span class="toc-text">有时候 g1 会做进行若干个无用的 eden ygc，stw得毫无意义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">26.</span> <span class="toc-text">IEEE 754 浮点数问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">27.</span> <span class="toc-text">16g的结算服务的gc时间比8g的账单服务的gc时间少</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">28.</span> <span class="toc-text">JacksonCache 导致的 ygc 频繁和线程 blocked</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">29.</span> <span class="toc-text">CMS 频繁 Major GC</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">30.</span> <span class="toc-text">MetaSpace 频繁超过高位水位线</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">31.</span> <span class="toc-text">并发优化失败，回退问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">32.</span> <span class="toc-text">Jedis 使用单调钟却发现超时</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">33.</span> <span class="toc-text">高吞吐导致大量 fgc</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">34.</span> <span class="toc-text">里找不到版本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">35.</span> <span class="toc-text">mvcc 导致的事务隔离导致的查询错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">36.</span> <span class="toc-text">MySQL 的时区问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">37.</span> <span class="toc-text">mysql on duplicate key update 的时候触发 mybatis 的 bug</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">38.</span> <span class="toc-text">not eligible for auto-proxying</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">39.</span> <span class="toc-text">MySQL order by 性能优化</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">40.</span> <span class="toc-text">Spring Context 在JUnit 下的加载顺序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">41.</span> <span class="toc-text">使用自定义的 PropertiesPlaceholderResolver 却导致 property 占位符填充不正常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">42.</span> <span class="toc-text">trade 重复交易问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">43.</span> <span class="toc-text">创建不了 appender，所以导致appenderref 失败</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">44.</span> <span class="toc-text">日志性能问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E6%9E%9C%E5%8F%AA%E6%98%AF%E5%AF%BB%E6%B1%82%E6%97%A5%E5%BF%97%E5%BC%82%E6%AD%A5%E5%8C%96-log4j2-%E6%8F%90%E4%BE%9B%E5%87%A0%E4%B8%AA%E6%96%B9%E6%A1%88"><span class="toc-number">44.1.</span> <span class="toc-text">如果只是寻求日志异步化，log4j2 提供几个方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%8E%A8%E8%8D%90%E4%BD%BF%E7%94%A8%E5%85%A8%E5%B1%80%E5%BC%82%E6%AD%A5%E5%8C%96%EF%BC%9F"><span class="toc-number">44.2.</span> <span class="toc-text">为什么不推荐使用全局异步化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E8%A6%81%E4%BD%BF%E7%94%A8-console"><span class="toc-number">44.3.</span> <span class="toc-text">不要使用 console</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">45.</span> <span class="toc-text">没有事务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">46.</span> <span class="toc-text">批量插入数据，导致 mybatis 报错</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">47.</span> <span class="toc-text">归档的几种策略</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">48.</span> <span class="toc-text">大数据 sql 里的 bigint 与 string</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">49.</span> <span class="toc-text">运营配置错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">50.</span> <span class="toc-text">连接 KeepAlive 配置有误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">51.</span> <span class="toc-text">因为 war 部署触发 log4j2 加载 jar 包全部信息引发线程阻塞</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">52.</span> <span class="toc-text">机器内部对环境判定错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">53.</span> <span class="toc-text">退款和关单乱序到达</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">54.</span> <span class="toc-text">把天转成秒</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">55.</span> <span class="toc-text">涉及外网的网关也可以连到外网的生产环境</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">56.</span> <span class="toc-text">st 和 prod</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">57.</span> <span class="toc-text">ThreadLocal Context里携带过多的子上下文，子线程一直持有这些上下文，导致 fgc</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">58.</span> <span class="toc-text">Spring 启动中数据源关闭的问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">59.</span> <span class="toc-text">没有开启 NettyIO 和平滑启动，导致 thrift client 启动大量时间消耗在 getConn 上</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">60.</span> <span class="toc-text">无法弹性扩容，导致需要强依赖熔断降级</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">61.</span> <span class="toc-text">Spring 在锁定 WebClassLoader 做字节码增强的时候，正好遇到 Web中间件自己也在锁定 WebClassLoader</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">62.</span> <span class="toc-text">使用双查询条件导致 es build_scorer 耗时偏长</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">63.</span> <span class="toc-text">异步日志没有写 blocking &#x3D; false</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">64.</span> <span class="toc-text">Netty 处理速度过慢</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">65.</span> <span class="toc-text">Netty 的 inflate 缓冲区泄漏，导致 gc 异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">66.</span> <span class="toc-text">使用 stream 来优化 for 循环，但 Long 的 value 设值没有捕获异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">67.</span> <span class="toc-text">在构造器里启动了线程，使用 run 而不是 start</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">68.</span> <span class="toc-text">先 mkdir 生成一个目录，再试图用 ln -s 创建同一个目标目录</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">69.</span> <span class="toc-text">Play 里没有对 @ImplementedBy 加上 @Singleton</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">70.</span> <span class="toc-text">Cos 没有加上内网地址</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">71.</span> <span class="toc-text">全部的拦截器拦截了不需要拦截的接口</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">72.</span> <span class="toc-text">header 不为空导致 Spring cors filter 工作不正常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">73.</span> <span class="toc-text">搜索引擎同步延迟导致规则应用失败</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">74.</span> <span class="toc-text">ebean 为 @dbArray 的 null field 提供 emptyList</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">75.</span> <span class="toc-text">logfilter 过滤时没有处理好</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">76.</span> <span class="toc-text">没有准备 @RequestBody 和 @Valid</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">77.</span> <span class="toc-text">轮询算法使用 indexof 来判定位置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">78.</span> <span class="toc-text">ThreadPoolTaskExecutor 忘记加上 @Bean</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">79.</span> <span class="toc-text">Cookie 没有加上 Path</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">80.</span> <span class="toc-text">Spring MVC 不支持 application&#x2F;javascript</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">81.</span> <span class="toc-text">父子进程无法关闭</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">82.</span> <span class="toc-text">bash 不识别 python 的 alias</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">83.</span> <span class="toc-text">双配置难题 2 Configurations puzzle</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">84.</span> <span class="toc-text">枚举互相引用导致成员为空</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">85.</span> <span class="toc-text">Dozer 导致线上卡顿</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">86.</span> <span class="toc-text">es 查询被拒绝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">87.</span> <span class="toc-text">left join 的时候没有提前做聚合</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">88.</span> <span class="toc-text">ws socket 双联</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">89.</span> <span class="toc-text">过快过期的缓存，与过期的load函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">90.</span> <span class="toc-text">嵌套缓存死锁</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">91.</span> <span class="toc-text">跑任务的时候没有处理好异步化问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">92.</span> <span class="toc-text">锁与标志位</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">93.</span> <span class="toc-text">不被捕获的异常</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">94.</span> <span class="toc-text">服务重启时大量空指针错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">95.</span> <span class="toc-text">使用静态变量来调整 feature toggle</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">96.</span> <span class="toc-text">left join 的时候对 left join 的表的条件写在 join 之后</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">97.</span> <span class="toc-text">a b 表在内连接里做分区</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">98.</span> <span class="toc-text">parallelStream 带来的异步化问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">99.</span> <span class="toc-text">单例构造里抛出异常，导致单例始终不生成成功</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">100.</span> <span class="toc-text">wait 被伪唤醒</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">101.</span> <span class="toc-text">已经有了一个清洗状态，仍然触发通话清洗</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">102.</span> <span class="toc-text">文件名含有反斜杠导致 multipart 解析出错</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">103.</span> <span class="toc-text">单一用户提交 qps 过高，导致消息队列被占满</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">104.</span> <span class="toc-text">多任务处理系统前任务直接终止主任务</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">105.</span> <span class="toc-text">滥用 ForkJoinPool</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">106.</span> <span class="toc-text">https 的外网端口被批量请求发起攻击</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">107.</span> <span class="toc-text">服务冷启动 cpu 过高</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">108.</span> <span class="toc-text">在 select 语句里面重新定义了某个 column，where 受影响</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">109.</span> <span class="toc-text">拼接 sql 的时候使用同一个 key</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">110.</span> <span class="toc-text">使用全量结果查询</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">111.</span> <span class="toc-text">生成查询数据的时候都是整数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">112.</span> <span class="toc-text">前缀唯一索引冲突</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">113.</span> <span class="toc-text">错误地更新字段为 null</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">114.</span> <span class="toc-text">在单端口多服务的时候，存在多个configuration</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">115.</span> <span class="toc-text">大 Long 不相等</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">116.</span> <span class="toc-text">查询分区表不带有 impl_date</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">117.</span> <span class="toc-text">更新配置格式不正确</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">118.</span> <span class="toc-text">只 catch 了 exception 没有 catch error</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">119.</span> <span class="toc-text">特殊标记位导致安装目录不同，再导致 mockgen 找不到</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">120.</span> <span class="toc-text">设计查询参数但是没有使用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">121.</span> <span class="toc-text">go 的v+%占位符不能正确地显示数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">122.</span> <span class="toc-text">不同模块共用配置文件导致启动失败</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">123.</span> <span class="toc-text">无法解决的消息积压延迟</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">124.</span> <span class="toc-text">到处复制的配置文件应该 .gitignore</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">125.</span> <span class="toc-text">不能 mock 的测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">126.</span> <span class="toc-text">生成s3的id时没有引入名字空间和签名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">127.</span> <span class="toc-text">生成基础数据的时候尽量让多层使用的数据在一个多层能够触摸到的位置声明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">128.</span> <span class="toc-text">配置 eks 的时候名称和 port 配置错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">129.</span> <span class="toc-text">闭包陷阱：循环中创建闭包的正确姿势</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E6%9C%AC%E8%B4%A8"><span class="toc-number">129.1.</span> <span class="toc-text">问题本质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go-%E8%AF%AD%E8%A8%80%E7%A4%BA%E4%BE%8B"><span class="toc-number">129.2.</span> <span class="toc-text">Go 语言示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%81%9A%E6%B3%95"><span class="toc-number">129.2.1.</span> <span class="toc-text">错误做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95"><span class="toc-number">129.2.2.</span> <span class="toc-text">正确做法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#javascript-%E7%A4%BA%E4%BE%8B"><span class="toc-number">129.3.</span> <span class="toc-text">JavaScript 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%81%9A%E6%B3%95"><span class="toc-number">129.3.1.</span> <span class="toc-text">错误做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95"><span class="toc-number">129.3.2.</span> <span class="toc-text">正确做法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#java-%E7%A4%BA%E4%BE%8B"><span class="toc-number">129.4.</span> <span class="toc-text">Java 示例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E5%81%9A%E6%B3%95"><span class="toc-number">129.4.1.</span> <span class="toc-text">错误做法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E5%81%9A%E6%B3%95"><span class="toc-number">129.4.2.</span> <span class="toc-text">正确做法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">129.5.</span> <span class="toc-text">最佳实践</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%87%8D%E8%A6%81"><span class="toc-number">129.6.</span> <span class="toc-text">为什么重要</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">130.</span> <span class="toc-text">请求的固定值不用枚举限制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">131.</span> <span class="toc-text">所有产生的可能被 url&#x2F;uri 读取的名字，都要转义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">132.</span> <span class="toc-text">aws s3 的图片只能下载不能打开</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">133.</span> <span class="toc-text">逆拷贝错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">134.</span> <span class="toc-text">在 go 里返回 error 的时候返回 nil 对象</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">135.</span> <span class="toc-text">并行化转化导致后续的转化器失衡</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">136.</span> <span class="toc-text">选错配置以后，覆盖了 content-type</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">137.</span> <span class="toc-text">对于修复 body 的设计。</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">138.</span> <span class="toc-text">初始化一个 client 遇到一个错误直接 panic</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">139.</span> <span class="toc-text">建立 aws 的 alb 很多请求都超时</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">140.</span> <span class="toc-text">http header 不能包含中文</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">141.</span> <span class="toc-text">伪注册</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">142.</span> <span class="toc-text">设计限流器的时候没有考虑到下游系统错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">143.</span> <span class="toc-text">docker 容器不可启动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">144.</span> <span class="toc-text">go redis 因为 tls 版本不可连接</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">145.</span> <span class="toc-text">错误的限流器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%80%83%E8%99%91%E5%8D%95%E4%B8%80%E7%BB%B4%E5%BA%A6-%E5%8D%95%E4%B8%80%E5%80%BC"><span class="toc-number">145.1.</span> <span class="toc-text">只考虑单一维度 + 单一值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E9%97%AE%E9%A2%98"><span class="toc-number">145.2.</span> <span class="toc-text">并发执行问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E9%85%8D%E7%BD%AE%E7%9A%84-merge"><span class="toc-number">145.3.</span> <span class="toc-text">多个配置的 merge</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E6%A0%B7%E8%AE%A1%E7%AE%97-used-%E5%92%8C-remaining"><span class="toc-number">145.4.</span> <span class="toc-text">怎样计算 used 和 remaining</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%A4%8D%E8%B0%83%E7%94%A8%E9%97%AE%E9%A2%98"><span class="toc-number">145.5.</span> <span class="toc-text">重复调用问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BF%98%E8%AE%B0%E6%8E%92%E9%99%A4%E7%89%B9%E5%88%AB%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="toc-number">145.6.</span> <span class="toc-text">忘记排除特别的接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%98%AF"><span class="toc-number">145.7.</span> <span class="toc-text">正确的设计是</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">146.</span> <span class="toc-text">对不涉及慢操作的for循环并发处理导致调试变得困难</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">147.</span> <span class="toc-text">子进程无法继承父进程的环境变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">148.</span> <span class="toc-text">怎样更散列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">149.</span> <span class="toc-text">错误的 nohup</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E5%90%8E%E5%8F%B0%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E6%96%B9%E6%B3%95%E4%B8%80%E8%A7%88"><span class="toc-number">149.1.</span> <span class="toc-text">Linux 后台进程管理方法一览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%89%B9%E6%80%A7%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">149.2.</span> <span class="toc-text">关键特性对比：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%BB%BA%E8%AE%AE%EF%BC%9A"><span class="toc-number">149.3.</span> <span class="toc-text">使用建议：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">150.</span> <span class="toc-text">修改配置文件的解析方式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">151.</span> <span class="toc-text">尝试删除可能存在或不存在的文件</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">152.</span> <span class="toc-text">aws 的 s3 的 object key 是否需要散列</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">153.</span> <span class="toc-text">从 form-data 里读数据无法写回</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">154.</span> <span class="toc-text">倒查索引慢了400倍</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">155.</span> <span class="toc-text">非守护线程泄露，导致 jvm 关闭钩子泄露</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">156.</span> <span class="toc-text">中间浮点数错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">157.</span> <span class="toc-text">vscode mcp 无法启动</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">158.</span> <span class="toc-text">插入覆盖语句在 MaxCompute 上执行失败</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">159.</span> <span class="toc-text">对于已单元化的服务，出问题以后只降级一个服务，导致上游跨单元超时</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">160.</span> <span class="toc-text">在请求里新增兜底，没有评估上下游代码</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">161.</span> <span class="toc-text">上线顺序错误导致消息消费失败</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">162.</span> <span class="toc-text">新老流程不兼容</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">163.</span> <span class="toc-text">刷数据两张依赖表生命周期不一样</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">164.</span> <span class="toc-text">查表出错</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">165.</span> <span class="toc-text">es 和 open search 不是所有字段都能查出来</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">166.</span> <span class="toc-text">查询 redis 出错</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">167.</span> <span class="toc-text">增量双写忘记迁移存量数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">168.</span> <span class="toc-text">Map 里有 duplicate key 导致 map 生成失败，引入兜底逻辑</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">169.</span> <span class="toc-text">生成 traceId 忘记返回</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">170.</span> <span class="toc-text">回滚配置文件回滚到目标配置文件的前一版本</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">171.</span> <span class="toc-text">生成配置文件，忘记在数组里写,</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">172.</span> <span class="toc-text">fastjson 异常没有被吞掉</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">173.</span> <span class="toc-text">上游传的参数的空值有歧义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">174.</span> <span class="toc-text">复制签名算法以前没有对待签名字段进行排序</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">175.</span> <span class="toc-text">修改日志的 logger 可能触发监控和告警减少</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">176.</span> <span class="toc-text">不重复的日期切面表达式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">177.</span> <span class="toc-text">invokeAll 就触发阻塞，而不是 future.get 的时候触发</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">178.</span> <span class="toc-text">容灾脚本出错</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">179.</span> <span class="toc-text">突然出现的 success</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">180.</span> <span class="toc-text">修改读取配置的代码，但是上线未经测试</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">181.</span> <span class="toc-text">尝试使用枚举来实现策略模式，却无法引用成员变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">182.</span> <span class="toc-text">从老接口设计新接口参数出错</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">183.</span> <span class="toc-text">监控上线后没有在完整周期里看数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">184.</span> <span class="toc-text">重构线程池生成流程，去掉了 createRejectedExecutionHandler</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">185.</span> <span class="toc-text">线程池调用 invokeAll 一次提交了大量任务，触发线程池拒绝</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">186.</span> <span class="toc-text">错误的列名导致 sql 出错</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">187.</span> <span class="toc-text">敏感告警应该配置阈值为大于0</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">188.</span> <span class="toc-text">metaspace 提前 fgc</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">189.</span> <span class="toc-text">误以为是单机房执行的脚本被多机房执行</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">190.</span> <span class="toc-text">环境配置隔离了操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">191.</span> <span class="toc-text">表面上看上去配置在配置系统里</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">192.</span> <span class="toc-text">原始的日志文件里只有空格</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">193.</span> <span class="toc-text">配置反序列化类配错，导致反序列化出 {} 对象，然后再序列化丢失数据</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">194.</span> <span class="toc-text">ECMAScript 2015 的自动变量名语法导致重写逻辑错误</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">195.</span> <span class="toc-text">JSONObject.parseObject(templateContent, clazz) 得到多余的值</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">196.</span> <span class="toc-text">迁移文档已经写了全部的待迁移配置，但是没有全部移动进灰度配置里</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">197.</span> <span class="toc-text">如果确定不能使用某类灰度比对 diff 功能，坚决不能开启相关的配置</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">198.</span> <span class="toc-text">关闭灰度环境的 bug fix 和 报警</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">199.</span> <span class="toc-text">灰度环境的其他 bug</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">200.</span> <span class="toc-text">hsf 不优雅关闭</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">201.</span> <span class="toc-text">依赖于代码的 diamond 配置没有正确发布</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">202.</span> <span class="toc-text">有缺省值的 MySQL 列插入不成功</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">203.</span> <span class="toc-text">常见的 axb 会和隐藏的 axn 冲突</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">204.</span> <span class="toc-text">hsf client 的调用，被上层线程池中断触发消息为 null 的 TimeOutException</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">205.</span> <span class="toc-text">JPDA_ENABLE&#x3D;1不应该在普通 dockerfile 里打开</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>