<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>G1/ZGC/Shenandoah 垃圾收集器对比 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="垃圾收集的核心挑战 垃圾收集器的设计始终面临三个核心指标的权衡：吞吐量、延迟和内存占用。这三个指标构成了一个不可能三角，优化其中一个指标往往需要牺牲其他指标。 吞吐量指单位时间内完成的工作量，通常用应用程序运行时间占总时间的比例来衡量。对于批处理任务、科学计算等场景，高吞吐量是首要目标。 延迟指垃圾收集造成的应用停顿时间。对于交互式应用、金融交易系统等对响应时间敏感的场景，低延迟至关重要。延迟通常">
<meta property="og:type" content="article">
<meta property="og:title" content="G1&#x2F;ZGC&#x2F;Shenandoah 垃圾收集器对比">
<meta property="og:url" content="https://magicliang.github.io/2026/02/07/G1-ZGC-Shenandoah-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%AF%B9%E6%AF%94/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="垃圾收集的核心挑战 垃圾收集器的设计始终面临三个核心指标的权衡：吞吐量、延迟和内存占用。这三个指标构成了一个不可能三角，优化其中一个指标往往需要牺牲其他指标。 吞吐量指单位时间内完成的工作量，通常用应用程序运行时间占总时间的比例来衡量。对于批处理任务、科学计算等场景，高吞吐量是首要目标。 延迟指垃圾收集造成的应用停顿时间。对于交互式应用、金融交易系统等对响应时间敏感的场景，低延迟至关重要。延迟通常">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-6.jpg">
<meta property="article:published_time" content="2026-02-07T02:00:00.000Z">
<meta property="article:modified_time" content="2026-02-07T08:51:20.025Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-6.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "G1/ZGC/Shenandoah 垃圾收集器对比",
  "url": "https://magicliang.github.io/2026/02/07/G1-ZGC-Shenandoah-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%AF%B9%E6%AF%94/",
  "image": "https://magicliang.github.io/img/wall-paper-6.jpg",
  "datePublished": "2026-02-07T02:00:00.000Z",
  "dateModified": "2026-02-07T08:51:20.025Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/02/07/G1-ZGC-Shenandoah-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%AF%B9%E6%AF%94/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'G1/ZGC/Shenandoah 垃圾收集器对比',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-6.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">G1/ZGC/Shenandoah 垃圾收集器对比</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">G1/ZGC/Shenandoah 垃圾收集器对比</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-02-07T02:00:00.000Z" title="Created 2026-02-07 10:00:00">2026-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-07T08:51:20.025Z" title="Updated 2026-02-07 16:51:20">2026-02-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">2.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>8mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="垃圾收集的核心挑战">垃圾收集的核心挑战</h2>
<p>垃圾收集器的设计始终面临三个核心指标的权衡：吞吐量、延迟和内存占用。这三个指标构成了一个不可能三角，优化其中一个指标往往需要牺牲其他指标。</p>
<p><strong>吞吐量</strong>指单位时间内完成的工作量，通常用应用程序运行时间占总时间的比例来衡量。对于批处理任务、科学计算等场景，高吞吐量是首要目标。</p>
<p><strong>延迟</strong>指垃圾收集造成的应用停顿时间。对于交互式应用、金融交易系统等对响应时间敏感的场景，低延迟至关重要。延迟通常关注最大停顿时间和停顿时间分布。</p>
<p><strong>内存占用</strong>指垃圾收集器为了完成收集工作所需的额外内存空间。内存受限的环境下，收集器自身的内存开销成为关键约束。</p>
<p>传统垃圾收集器在三者之间做出明确取舍：Serial 和 Parallel GC 追求高吞吐量，但停顿时间较长；CMS GC 降低停顿时间，但牺牲吞吐量并占用更多内存。现代收集器试图在三者之间找到更优的平衡点。</p>
<h2 id="g1-garbage-first-收集器">G1（Garbage First）收集器</h2>
<p>G1 收集器在 JDK 7u4 版本正式推出，是 JDK 9 之后的默认垃圾收集器。G1 的核心思想是打破传统分代收集的物理隔离，将堆内存划分为多个大小相等的 Region。</p>
<h3 id="region-化堆内存">Region 化堆内存</h3>
<p>G1 将堆内存划分为多个大小相等的独立区域，每个 Region 可以独立作为 Eden 区、Survivor 区或 Old 区。Region 的大小通常在 1MB 到 32MB 之间，数量可达数千个。这种设计带来两个优势：可预测的停顿时间和灵活的内存分配。</p>
<p>G1 通过跟踪每个 Region 的垃圾堆积效率，优先回收垃圾最多的 Region，这也是 “Garbage First” 名称的由来。这种策略确保在有限的时间内回收最多的内存空间。</p>
<h3 id="混合收集和并发标记">混合收集和并发标记</h3>
<p>G1 的收集过程分为 Young GC、Mixed GC 和 Full GC。Young GC 仅回收新生代 Region，Mixed GC 同时回收新生代和老年代 Region。Full GC 退化为单线程收集，应尽量避免。</p>
<p>G1 采用并发标记算法，标记过程分为三个阶段：初始标记、并发标记和最终标记。初始标记需要 STW（Stop-The-World），但只扫描 GC Roots 直接关联的对象；并发标记与应用程序并发执行；最终标记处理并发阶段遗留的引用变更。</p>
<h3 id="停顿时间目标">停顿时间目标</h3>
<p>G1 允许用户通过 <code>-XX:MaxGCPauseMillis</code> 参数设置期望的最大停顿时间，默认 200ms。G1 会根据历史数据预测每次收集能回收的 Region 数量，在停顿时间内尽可能多地回收垃圾。</p>
<p>如果实际停顿时间频繁超过目标，G1 会调整策略：减少每次回收的 Region 数量或提高收集频率。这种自适应机制使 G1 能够在动态变化的负载下维持相对稳定的停顿时间。</p>
<h3 id="卡表和-rset">卡表和 RSet</h3>
<p>跨代引用是分代收集的难点。G1 使用卡表和 RSet（Remembered Set）来高效处理跨代引用。卡表记录老年代中哪些卡页包含指向新生代的引用，每个卡页大小为 512 字节。</p>
<p>RSet 是每个 Region 独立维护的数据结构，记录其他 Region 中指向本 Region 的引用。RSet 的实现基于哈希表，存储引用来源 Region 的卡页索引。这种设计使 G1 能够避免全堆扫描，只扫描 RSet 记录的 Region。</p>
<h2 id="zgc-收集器">ZGC 收集器</h2>
<p>ZGC 在 JDK 11 中作为实验特性引入，JDK 15 正式发布。ZGC 的设计目标是实现亚毫秒级停顿，并支持 TB 级堆内存，同时保持合理的吞吐量。</p>
<h3 id="着色指针">着色指针</h3>
<p>ZGC 的核心创新是着色指针技术。ZGC 在 64 位指针中保留 42 位用于寻址，支持的最大堆内存为 16TB。剩余的 22 位用于存储元数据：4 位用于颜色标记（Finalizable、Remapped、Marked0、Marked1），18 位保留。</p>
<p>着色指针将对象的状态直接编码到指针中，无需额外的数据结构。当对象需要移动时，ZGC 修改指针的值而不是对象本身，这种设计消除了对象移动时的写屏障开销。</p>
<h3 id="读屏障">读屏障</h3>
<p>ZGC 在每次读取对象引用时插入读屏障。读屏障检查指针的颜色标记，如果发现指针指向的对象正在被移动，则触发转发操作，将指针更新到新位置。读屏障的开销极小，通常只需要几条 CPU 指令。</p>
<p>读屏障的实现依赖于 CPU 的 load barriers 指令（x86 架构的 lfence 指令）。ZGC 通过动态编译技术，在热点代码路径中内联读屏障，进一步降低开销。</p>
<h3 id="并发整理">并发整理</h3>
<p>ZGC 的最大特点是全并发的整理过程。传统收集器的对象整理需要 STW，而 ZGC 在应用程序运行的同时移动对象。当对象需要移动时，ZGC 在原位置保留转发指针，所有通过读屏障访问该对象的请求都会被重定向到新位置。</p>
<p>ZGC 使用多重映射技术，将对象的多个视图映射到同一个物理内存区域。这种设计使 ZGC 能够在不修改对象引用的情况下完成对象移动，极大降低了 STW 时间。</p>
<h3 id="亚毫秒级停顿和-tb-级堆">亚毫秒级停顿和 TB 级堆</h3>
<p>ZGC 的停顿时间通常在 1ms 以内，与堆大小无关。即使堆内存达到 TB 级别，ZGC 仍能维持亚毫秒级的停顿。这种特性使 ZGC 适用于对延迟极其敏感的大内存应用。</p>
<p>ZGC 的吞吐量略低于 Parallel GC，但显著优于 CMS 和 G1。根据官方基准测试，ZGC 的吞吐量约为 Parallel GC 的 70% 到 90%。</p>
<h2 id="shenandoah-收集器">Shenandoah 收集器</h2>
<p>Shenandoah 收集器由 Red Hat 开发，在 JDK 12 中作为实验特性引入。Shenandoah 的设计目标与 ZGC 类似，但采用不同的技术实现路径。</p>
<h3 id="brooks-转发指针">Brooks 转发指针</h3>
<p>Shenandoah 使用 Brooks 转发指针实现并发整理。每个对象头中额外存储一个转发指针字段，初始指向对象自身。当对象需要移动时，Shenandoah 更新转发指针指向新位置，同时保留原对象的内容。</p>
<p>通过转发指针，Shenandoah 能够在不修改对象引用的情况下完成对象移动。这种设计避免了 ZGC 需要的 CPU 特定指令，使 Shenandoah 具有更好的平台移植性。</p>
<h3 id="并发整理">并发整理</h3>
<p>Shenandoah 的整理过程包括并发标记、并发整理和并发更新引用三个阶段。并发标记阶段识别存活对象；并发整理阶段将存活对象移动到新的位置；并发更新引用阶段更新所有指向旧位置的引用。</p>
<p>Shenandoah 使用 Brooks 指针确保在整理过程中任何对旧对象的引用都能正确转发到新对象。转发指针的开销主要来自额外的间接访问，但现代 CPU 的分支预测和缓存机制能够有效降低这种开销。</p>
<h3 id="与-zgc-的异同">与 ZGC 的异同</h3>
<p>Shenandoah 和 ZGC 的设计目标高度一致，但实现路径不同。主要差异包括：Shenandoah 使用 Brooks 指针，ZGC 使用着色指针；Shenandoah 不依赖于 CPU 特定指令，ZGC 需要 load barriers 支持；Shenandoah 的对象头开销略大（增加转发指针字段），ZGC 的指针编码更复杂。</p>
<p>在性能方面，两家收集器的停顿时间都达到亚毫秒级别，吞吐量接近。Shenandoah 在某些场景下的延迟表现略优于 ZGC，但 ZGC 的平台优化更成熟。选择哪种收集器通常取决于具体的硬件环境和应用特性。</p>
<h2 id="对比表格">对比表格</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>G1</th>
<th>ZGC</th>
<th>Shenandoah</th>
</tr>
</thead>
<tbody>
<tr>
<td>最大停顿时间</td>
<td>200ms（可配置）</td>
<td>&lt;1ms</td>
<td>&lt;1ms</td>
</tr>
<tr>
<td>吞吐量</td>
<td>中等</td>
<td>较高</td>
<td>较高</td>
</tr>
<tr>
<td>最大堆内存</td>
<td>32GB</td>
<td>16TB</td>
<td>16TB</td>
</tr>
<tr>
<td>JDK 版本</td>
<td>7u4+</td>
<td>11+（15 正式）</td>
<td>12+</td>
</tr>
<tr>
<td>并发整理</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>适用场景</td>
<td>通用场景</td>
<td>低延迟大内存</td>
<td>低延迟大内存</td>
</tr>
<tr>
<td>CPU 要求</td>
<td>无</td>
<td>x86/ARM load barriers</td>
<td>无特定要求</td>
</tr>
<tr>
<td>内存开销</td>
<td>较低（RSet）</td>
<td>较低（着色指针）</td>
<td>较高（转发指针）</td>
</tr>
</tbody>
</table>
<h2 id="选型指导">选型指导</h2>
<h3 id="选择-g1-的场景">选择 G1 的场景</h3>
<p>G1 适用于大多数通用场景，特别是堆内存不超过 32GB、对停顿时间有适度要求的应用。如果应用运行在 JDK 8 或 JDK 9 环境，G1 是最成熟的选择。G1 的调优参数丰富，适合需要精细控制收集行为的场景。</p>
<h3 id="选择-zgc-的场景">选择 ZGC 的场景</h3>
<p>ZGC 适用于对延迟极其敏感、堆内存较大的应用。如果应用运行在支持 load barriers 的 CPU 架构上（x86、ARM），并且使用 JDK 11 或更高版本，ZGC 能够提供最优的延迟表现。典型场景包括金融交易系统、实时广告投放系统等。</p>
<h3 id="选择-shenandoah-的场景">选择 Shenandoah 的场景</h3>
<p>Shenandoah 适用于需要低延迟但硬件环境不支持 load barriers 的场景。如果应用运行在非 x86/ARM 架构上，或者使用 OpenJ9 等 JVM 实现，Shenandoah 是更好的选择。Shenandoah 也适用于需要更细粒度控制转发策略的场景。</p>
<h2 id="与传统收集器的演进关系">与传统收集器的演进关系</h2>
<p>Serial GC 是最早的垃圾收集器，采用单线程标记整理算法，适合单核 CPU 和小内存环境。Parallel GC 在 Serial GC 的基础上引入多线程，显著提高了吞吐量，成为 JDK 8 的默认收集器。</p>
<p>CMS GC 是第一个关注延迟的收集器，采用并发标记清除算法。CMS 降低了停顿时间，但存在内存碎片、CPU 占用高、浮动垃圾等问题，最终在 JDK 9 中被标记为过时。</p>
<p>G1、ZGC 和 Shenandoah 代表了垃圾收集技术的第三代演进。它们在降低延迟的同时，保持了合理的吞吐量和内存效率。这种演进反映了应用需求的变化：从追求吞吐量到追求低延迟，再到兼顾延迟、吞吐量和内存占用。</p>
<p>未来垃圾收集器的发展方向包括：更智能的自适应调优、更低的开销、更好的 NUMA 架构支持，以及与硬件特性的深度结合。AI 驱动的垃圾收集策略优化也可能成为下一个突破点。</p>
<h2 id="总结">总结</h2>
<p>现代垃圾收集器的演进体现了 JVM 技术的持续进步。G1 在通用场景下提供了平衡的性能表现；ZGC 和 Shenandoah 在低延迟场景下实现了突破性的改进。选择合适的垃圾收集器需要综合考虑应用特性、硬件环境、JDK 版本等多个因素。</p>
<p>垃圾收集器的设计始终是在权衡中寻找最优解。理解各种收集器的原理和适用场景，能够帮助开发者和运维人员做出更明智的选择，从而提升应用的整体性能和稳定性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/02/07/G1-ZGC-Shenandoah-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%AF%B9%E6%AF%94/">https://magicliang.github.io/2026/02/07/G1-ZGC-Shenandoah-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E5%AF%B9%E6%AF%94/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JVM/">JVM</a><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-6.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/23/%E6%98%82%E8%B4%B5%E7%9A%84%E5%BC%82%E5%B8%B8/" title="昂贵的异常"><img class="cover" src="/img/wall-paper-31.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-23</div><div class="info-item-2">昂贵的异常</div></div><div class="info-2"><div class="info-item-1">抛出问题 Joshua Bloch 在《Effective Java》的 Item 57 里明确地提到过，不要试图用 Exception 的跳转来代替正常的程序控制流。他列举了很多原因，但特别提到了抛出异常会使得整个程序运行变慢。抛出异常远比普通的 return、break 等操作对控制流、数据流的性能影响要大，它就只适合拿来作异常分支的控制语句，而不能拿来编写正常的逻辑。  Throwing exception is expensive.  这句话在 Java 的程序员世界里面已经成为老生常谈，却很少有人谈及到底抛出异常比正常的程序跳转返回慢在哪里，有多慢。&quot;不要滥用异常&quot;好像一个猴子定律，人们知道不能这么做，却不明白为什么不能这么做。 此前读了一位同事写的好文《Java虚拟机是如何处理异常的》，深入地分析了 JVM 对异常跳转的处理过程：JVM 会通过异常表的机制，优化异常抛出和正常返回之间的性能差异。仅从程序计数器的移动上来讲，抛出一个异常对栈帧的弹栈并不比直接返回更昂贵。写在前头的结论是：&quot;try-catch 语句块几乎不会影响程序运行性能！...</div></div></div></a><a class="pagination-related" href="/2018/10/13/%E5%8D%A1%E8%A1%A8%E5%92%8C-RSet/" title="卡表和 RSet"><img class="cover" src="/img/wall-paper-45.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-13</div><div class="info-item-2">卡表和 RSet</div></div><div class="info-2"><div class="info-item-1">卡表和 RSet 问题定义：为什么需要跨区域引用记录 JVM 垃圾收集器的核心工作之一是确定 live set——哪些对象仍然存活、不可回收。确定 live set 的标准做法是从 GC Roots（栈帧中的局部变量、静态字段等）出发，沿引用链遍历所有可达对象。 问题在于：当堆被划分为多个区域（代、Region）并且只回收其中一部分时，如何高效地找到从&quot;不回收区域&quot;指向&quot;回收区域&quot;的引用？ 以 Young GC 为例：只回收新生代，但老年代中可能持有指向新生代对象的引用。如果不处理这些跨代引用，就会错误地回收仍被老年代引用的新生代对象。最朴素的做法是扫描整个老年代来找出这些引用——但老年代通常远大于新生代，这样做的代价过高，违背了分代收集&quot;只回收一部分堆&quot;的初衷。 卡表（Card Table）和 RSet（Remembered Set）正是为解决这个问题而设计的辅助数据结构。二者的关系并非互相替代，而是层次不同、协作互补：卡表是底层的脏标记机制，RSet 是建立在卡表之上的更高层索引结构。 核心概念速览 在深入细节之前，...</div></div></div></a><a class="pagination-related" href="/2018/10/22/JDWP-%E4%B8%8E%E8%BF%9C%E7%A8%8B%E8%B0%83%E8%AF%95/" title="JDWP 与远程调试"><img class="cover" src="/img/wall-paper-18.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2018-10-22</div><div class="info-item-2">JDWP 与远程调试</div></div><div class="info-2"><div class="info-item-1">JDWP（Java Debug Wire Protocol），它提供了调试器和目标 JVM （target vm）之间的调试协议。 在 target vm 启动时，增加这个 JAVA_OPTS： 1JAVA_OPTS=&quot;-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=26310&quot; 在服务器端，增加 remote debuging 的时候使用如下配置： 12345678# Java 9 以上-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=*:8000# Java 5-8-agentlib:jdwp=transport=dt_socket,server=y,suspend=n,address=8000# Java 1.4.x -Xdebug -Xrunjdwp:transport=dt_socket,server=y,suspend=n,addre...</div></div></div></a><a class="pagination-related" href="/2019/09/05/%E9%87%8D%E8%BF%B0%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B/" title="重述双亲委派模型"><img class="cover" src="/img/wall-paper-26.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2019-09-05</div><div class="info-item-2">重述双亲委派模型</div></div><div class="info-2"><div class="info-item-1">何时加载类 根据 Java 语言规范（JLS §12.4），类或接口在首次主动使用时才会被初始化。主动使用包括以下情况：  遇到 new、getstatic、putstatic、invokestatic 等字节码指令时。这些指令分别对应创建对象实例、读取或设置静态字段、调用静态方法。 对类进行反射调用时，如 Class.forName() 或 Method.invoke()。 初始化某个类的子类时，父类会先被初始化（但父类接口不会）。 虚拟机启动时会先加载设置的主类，即包含 main() 方法的类。 使用 java.lang.invoke 包的动态语言支持特性时，如 MethodHandle 调用。  需要注意的是，被动引用（如通过数组引用、常量引用、访问子类的静态字段等）不会触发类初始化。 从 Java 到 cpp 源码分析 双亲委派模型的工作流程 双亲委派模型的核心逻辑在 java.lang.ClassLoader.loadClass(String name, boolean resolve) 方法中： 123456789101112131415161718192021222...</div></div></div></a><a class="pagination-related" href="/2020/03/08/JMX-%E6%B7%B1%E5%BA%A6%E5%8E%86%E9%99%A9/" title="JMX 深度历险"><img class="cover" src="/img/wall-paper-140.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-08</div><div class="info-item-2">JMX 深度历险</div></div><div class="info-2"><div class="info-item-1">JMX 常见指标 JVM 指标 系统指标    System 相关指标 描述     system.load.average 系统load，如果是docker，此指标收集的物理机的load   cpu.system.load.percent 系统所有进程占用cpu的百分比   cpu.jvm.load.percent jvm占用cpu的百分比   system.process.used.phyical.memory 系统使用的物理内存   system.process.used.swap.size 系统使用的swap内存    JVM 内存指标    JVM相关指标 描述     jvm.gc.count GC的次数   jvm.gc.time GC的时间，单位毫秒   jvm.younggc.count 年轻代GC的次数 ，包括的GC算法（Copy，ParNew，PS Scavenge，G1 Young Generation）   jvm.younggc.time 年轻代GC的时间，单位毫秒   jvm.fullgc.count 年老代GC的次数，包括的GC算法   jvm.f...</div></div></div></a><a class="pagination-related" href="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" title="现代垃圾收集器"><img class="cover" src="/2020/09/27/%E7%8E%B0%E4%BB%A3%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/%E6%94%B6%E9%9B%86%E5%99%A8%E5%88%86%E7%B1%BB.jpeg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2020-09-27</div><div class="info-item-2">现代垃圾收集器</div></div><div class="info-2"><div class="info-item-1">所有的垃圾收集器，都基于弱分代假设。实际的垃圾回收效率取决于堆内对象的分布状况。垃圾回收并不能解决内存泄漏或者应用程序逻辑的不良分配习惯问题，要处理 JVM 内存回收问题的根本方法是对程序进行调优。 有几个常用原则：  减少临时对象，尽量复用内存。 使用对象池。 主动提前释放对象。 主动 gc。 好的代码比 tuning 更重要。 选 gc 算法比 tuning 参数重要，tuning 参数是最后一步。  其他情况，可以通过 tuning garbage collector 来解决。 操作系统的影响  SWAP 可能会显著增加 GC 时间，因为被换出的堆还要被换入。  美团的实践 参考：  《从实际案例聊聊Java应用的GC优化》 《Java中9种常见的CMS GC问题分析与解决》   Minor GC Major GC Full GC  垃圾收集器分类    可以看到一个现象：在大部分时候，g1 比 CMS 快，但极端的百分位里，CMS 比 g1 快。 出处见这里。 常用工具 命令行终端   标准终端类：jps、jinfo、jstat、jstack、jmap 功能整合类：jcm...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8C%91%E6%88%98"><span class="toc-number">1.</span> <span class="toc-text">垃圾收集的核心挑战</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#g1-garbage-first-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">2.</span> <span class="toc-text">G1（Garbage First）收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#region-%E5%8C%96%E5%A0%86%E5%86%85%E5%AD%98"><span class="toc-number">2.1.</span> <span class="toc-text">Region 化堆内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B7%E5%90%88%E6%94%B6%E9%9B%86%E5%92%8C%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0"><span class="toc-number">2.2.</span> <span class="toc-text">混合收集和并发标记</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%9C%E9%A1%BF%E6%97%B6%E9%97%B4%E7%9B%AE%E6%A0%87"><span class="toc-number">2.3.</span> <span class="toc-text">停顿时间目标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%A1%E8%A1%A8%E5%92%8C-rset"><span class="toc-number">2.4.</span> <span class="toc-text">卡表和 RSet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#zgc-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">ZGC 收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9D%80%E8%89%B2%E6%8C%87%E9%92%88"><span class="toc-number">3.1.</span> <span class="toc-text">着色指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E5%B1%8F%E9%9A%9C"><span class="toc-number">3.2.</span> <span class="toc-text">读屏障</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%95%B4%E7%90%86"><span class="toc-number">3.3.</span> <span class="toc-text">并发整理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%9A%E6%AF%AB%E7%A7%92%E7%BA%A7%E5%81%9C%E9%A1%BF%E5%92%8C-tb-%E7%BA%A7%E5%A0%86"><span class="toc-number">3.4.</span> <span class="toc-text">亚毫秒级停顿和 TB 级堆</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#shenandoah-%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">4.</span> <span class="toc-text">Shenandoah 收集器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#brooks-%E8%BD%AC%E5%8F%91%E6%8C%87%E9%92%88"><span class="toc-number">4.1.</span> <span class="toc-text">Brooks 转发指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%95%B4%E7%90%86"><span class="toc-number">4.2.</span> <span class="toc-text">并发整理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E-zgc-%E7%9A%84%E5%BC%82%E5%90%8C"><span class="toc-number">4.3.</span> <span class="toc-text">与 ZGC 的异同</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E8%A1%A8%E6%A0%BC"><span class="toc-number">5.</span> <span class="toc-text">对比表格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E5%9E%8B%E6%8C%87%E5%AF%BC"><span class="toc-number">6.</span> <span class="toc-text">选型指导</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-g1-%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">6.1.</span> <span class="toc-text">选择 G1 的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-zgc-%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">6.2.</span> <span class="toc-text">选择 ZGC 的场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%89%E6%8B%A9-shenandoah-%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">6.3.</span> <span class="toc-text">选择 Shenandoah 的场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E6%BC%94%E8%BF%9B%E5%85%B3%E7%B3%BB"><span class="toc-number">7.</span> <span class="toc-text">与传统收集器的演进关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">8.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>