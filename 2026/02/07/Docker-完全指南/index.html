<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Docker 完全指南 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第1章：Docker 核心架构 Docker 是一种操作系统级别的虚拟化技术，它通过 Linux 内核的多项特性实现进程间的软隔离，而非传统虚拟机的硬件级虚拟化。理解 Docker 的核心架构，是掌握容器技术的第一步。 Docker 的四根柱子 Docker 的核心技术基于 Linux 内核的三大特性，加上一个标准化的容器格式： 1. Namespace（命名空间）—— 隔离 Namespace">
<meta property="og:type" content="article">
<meta property="og:title" content="Docker 完全指南">
<meta property="og:url" content="https://magicliang.github.io/2026/02/07/Docker-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="第1章：Docker 核心架构 Docker 是一种操作系统级别的虚拟化技术，它通过 Linux 内核的多项特性实现进程间的软隔离，而非传统虚拟机的硬件级虚拟化。理解 Docker 的核心架构，是掌握容器技术的第一步。 Docker 的四根柱子 Docker 的核心技术基于 Linux 内核的三大特性，加上一个标准化的容器格式： 1. Namespace（命名空间）—— 隔离 Namespace">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-112.jpg">
<meta property="article:published_time" content="2026-02-07T11:31:35.000Z">
<meta property="article:modified_time" content="2026-02-07T12:16:40.168Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Docker">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-112.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Docker 完全指南",
  "url": "https://magicliang.github.io/2026/02/07/Docker-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/",
  "image": "https://magicliang.github.io/img/wall-paper-112.jpg",
  "datePublished": "2026-02-07T11:31:35.000Z",
  "dateModified": "2026-02-07T12:16:40.168Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/02/07/Docker-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Docker 完全指南',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-112.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Docker 完全指南</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Docker 完全指南</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-02-07T11:31:35.000Z" title="Created 2026-02-07 19:31:35">2026-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-07T12:16:40.168Z" title="Updated 2026-02-07 20:16:40">2026-02-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">23.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>92mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1>第1章：Docker 核心架构</h1>
<p>Docker 是一种操作系统级别的虚拟化技术，它通过 Linux 内核的多项特性实现进程间的软隔离，而非传统虚拟机的硬件级虚拟化。理解 Docker 的核心架构，是掌握容器技术的第一步。</p>
<h2 id="docker-的四根柱子">Docker 的四根柱子</h2>
<p>Docker 的核心技术基于 Linux 内核的三大特性，加上一个标准化的容器格式：</p>
<h3 id="1-namespace-命名空间-隔离">1. Namespace（命名空间）—— 隔离</h3>
<p>Namespace 是 Linux 内核提供的资源隔离机制，Docker 利用它为每个容器创建独立的运行环境。Docker 使用的 Namespace 包括：</p>
<table>
<thead>
<tr>
<th>Namespace</th>
<th>隔离内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PID</strong></td>
<td>进程 ID</td>
<td>容器内的进程有独立的 PID 空间</td>
</tr>
<tr>
<td><strong>NET</strong></td>
<td>网络</td>
<td>独立的网络栈、IP 地址、端口</td>
</tr>
<tr>
<td><strong>MNT</strong></td>
<td>文件系统挂载点</td>
<td>独立的文件系统视图</td>
</tr>
<tr>
<td><strong>UTS</strong></td>
<td>主机名和域名</td>
<td>容器可以有自己的主机名</td>
</tr>
<tr>
<td><strong>IPC</strong></td>
<td>进程间通信</td>
<td>独立的信号量、消息队列</td>
</tr>
<tr>
<td><strong>USER</strong></td>
<td>用户和用户组</td>
<td>容器内的 root 可以映射为宿主机的普通用户</td>
</tr>
</tbody>
</table>
<h3 id="2-control-group-cgroup-资源限制">2. Control Group（cgroup）—— 资源限制</h3>
<p>cgroup 负责限制和监控容器的资源使用，包括：</p>
<ul>
<li><strong>CPU</strong>：限制 CPU 使用时间和核心数</li>
<li><strong>内存</strong>：限制内存使用量，超出限制时触发 OOM</li>
<li><strong>磁盘 I/O</strong>：限制读写速率</li>
<li><strong>网络带宽</strong>：限制网络流量</li>
</ul>
<h3 id="3-unionfs-联合文件系统-分层存储">3. UnionFS（联合文件系统）—— 分层存储</h3>
<p>UnionFS 是 Docker 镜像和容器文件系统的基础，它允许将多个目录挂载到同一个虚拟文件系统下，实现镜像的分层存储和共享。</p>
<h3 id="4-container-format-容器格式">4. Container Format（容器格式）</h3>
<p>Docker 将 Namespace、cgroup 和 UnionFS 封装成标准化的容器格式，最初使用 LXC，后来替换为自研的 libcontainer（现已演进为 runc）。</p>
<h2 id="容器-vs-虚拟机">容器 vs 虚拟机</h2>
<p>Docker 与传统虚拟机（Hypervisor）的核心区别在于隔离层级：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Docker 容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>隔离方式</strong></td>
<td>进程级软隔离</td>
<td>硬件级虚拟化</td>
</tr>
<tr>
<td><strong>内核</strong></td>
<td>共享宿主机内核</td>
<td>每个 VM 独立内核</td>
</tr>
<tr>
<td><strong>启动速度</strong></td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td><strong>资源开销</strong></td>
<td>极低</td>
<td>较高</td>
</tr>
<tr>
<td><strong>镜像大小</strong></td>
<td>MB 级</td>
<td>GB 级</td>
</tr>
<tr>
<td><strong>密度</strong></td>
<td>单机可运行数百个容器</td>
<td>单机通常数十个 VM</td>
</tr>
</tbody>
</table>
<p>Hypervisor 总是起多个内核，而 Docker 共享宿主机内核，这是两者最本质的区别。Docker 寻求的解决方案不是虚拟化，而是进程间的软隔离。</p>
<h2 id="docker-的一等公民">Docker 的一等公民</h2>
<p>Docker 中有四种核心资源对象，它们都可以被命名：</p>
<ul>
<li><strong>Container（容器/服务）</strong>：镜像的运行实例</li>
<li><strong>Image（镜像）</strong>：容器的只读模板</li>
<li><strong>Volume（数据卷）</strong>：持久化数据存储</li>
<li><strong>Network（网络）</strong>：容器间通信的虚拟网络</li>
</ul>
<p>在 Docker 中，服务名和容器名都可以代替 IP 地址进行通信。</p>
<h2 id="docker-架构演进">Docker 架构演进</h2>
<p>Docker 的设计者对基于 Docker 构建的软件架构有清晰的演进思路：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">Container</span> → Service → Swarm → Stack<br></code></pre></td></tr></table></figure>
<ul>
<li><strong>一个 Container</strong> = 一个进程的运行实例</li>
<li><strong>一个 Service</strong> = 一个镜像的多个运行时实例</li>
<li><strong>一个 Stack</strong> = 可以被编排在一起的多个服务，它们共享网络、数据卷等依赖</li>
<li><strong>Swarm</strong> = 将一池子容器变成一个逻辑上的 Docker 主机</li>
</ul>
<p>这种架构演进体现了 Docker 从单机容器化到分布式编排的发展路径。</p>
<h2 id="docker-engine-的-c-s-架构">Docker Engine 的 C/S 架构</h2>
<p>Docker Engine 采用经典的客户端-服务器（C/S）架构，由三个主要组件构成：</p>
<h3 id="docker-cli-客户端">Docker CLI（客户端）</h3>
<p>Docker CLI 是用户与 Docker 交互的命令行工具。它接收用户的命令（如 <code>docker run</code>、<code>docker build</code>），并将其转换为 REST API 调用发送给 Docker 守护进程。</p>
<h3 id="docker-daemon-守护进程">Docker Daemon（守护进程）</h3>
<p>Docker 守护进程（<code>dockerd</code>）是 Docker Engine 的核心组件，负责：</p>
<ul>
<li>监听 Docker API 请求</li>
<li>管理镜像、容器、网络、数据卷等对象</li>
<li>处理容器生命周期</li>
<li>与 containerd 和 runc 交互</li>
</ul>
<h3 id="rest-api">REST API</h3>
<p>REST API 提供了标准的 HTTP 接口，允许第三方程序与 Docker 守护进程通信。Docker CLI、Docker Compose、各种管理工具都通过这个 API 与 Docker 交互。</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs scss">┌─────────────┐<br>│ Docker CLI  │<br>└──────┬──────┘<br>       │ <span class="hljs-attribute">REST</span> API<br>       ▼<br>┌─────────────┐<br>│ Dockerd     │<br>│ (Daemon)    │<br>└──────┬──────┘<br>       │<br>       ├───────────┐<br>       │           │<br>       ▼           ▼<br>┌──────────┐  ┌─────────┐<br>│containerd│  │  runc   │<br>└──────────┘  └─────────┘<br></code></pre></td></tr></table></figure>
<h2 id="oci-标准">OCI 标准</h2>
<p>为了促进容器技术的标准化和互操作性，Docker 联合其他厂商成立了开放容器倡议（Open Container Initiative，OCI），并制定了两个核心规范：</p>
<h3 id="runtime-specification-运行时规范">Runtime Specification（运行时规范）</h3>
<p>定义了容器的运行时配置和生命周期管理，包括容器的文件系统 bundle 格式、创建/启动/停止/删除操作、状态查询、隔离和资源限制配置。</p>
<h3 id="image-specification-镜像规范">Image Specification（镜像规范）</h3>
<p>定义了容器镜像的格式和结构，包括镜像的清单（manifest）格式、配置（config）格式、层（layer）的存储和寻址方式、内容寻址存储（CAS）机制。</p>
<p>OCI 标准的核心实现：</p>
<ul>
<li><strong>runc</strong>：OCI 运行时规范的参考实现，负责容器的实际创建和运行</li>
<li><strong>containerd</strong>：工业级的容器运行时，负责镜像管理和容器生命周期管理</li>
</ul>
<p>通过遵循 OCI 标准，Docker 实现了与其他容器运行时（如 Podman、CRI-O）的互操作性，避免了厂商锁定。</p>
<hr>
<h1>第2章：镜像与分层存储</h1>
<p>Docker 镜像是容器化技术的核心概念，理解镜像的分层存储机制对于优化镜像大小、提高构建效率至关重要。</p>
<h2 id="联合文件系统-unionfs">联合文件系统（UnionFS）</h2>
<p>Docker 镜像采用联合文件系统（UnionFS）实现分层存储。一个 Docker 镜像由多个只读层（read-only layers）叠加而成，每一层代表 Dockerfile 中的一个指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">┌─────────────────────┐<br>│   Read-Write Layer  │  ← 容器启动时添加的读写层<br>├─────────────────────┤<br>│   Layer <span class="hljs-number">4</span> (<span class="hljs-keyword">CMD</span><span class="language-bash">)     │</span><br>├─────────────────────┤<br>│   Layer <span class="hljs-number">3</span> (<span class="hljs-keyword">COPY</span><span class="language-bash">)    │</span><br>├─────────────────────┤<br>│   Layer <span class="hljs-number">2</span> (<span class="hljs-keyword">RUN</span><span class="language-bash">)     │</span><br>├─────────────────────┤<br>│   Layer <span class="hljs-number">1</span> (<span class="hljs-keyword">FROM</span>)    │<br>└─────────────────────┘<br></code></pre></td></tr></table></figure>
<p><img src="docker-unionfs.png" alt="docker-unionfs"></p>
<p>每个镜像层都是一个独立的文件系统，包含了该层对应指令产生的所有文件和目录变更。</p>
<h3 id="删除文件的真相">删除文件的真相</h3>
<p>在 UnionFS 中，&quot;删除&quot;一个文件并不会真正从下层中移除它，而是在上层创建一个 whiteout 文件，标记该文件已被删除。即使我们在上层&quot;删除&quot;了某个文件，该文件仍然存在于下层中，镜像大小不会减小。</p>
<p>因此，最佳实践是在同一个 <code>RUN</code> 指令中完成安装和清理：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span><br><span class="language-bash">    apt-get install -y vim &amp;&amp; \</span><br><span class="language-bash">    apt-get clean &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br></code></pre></td></tr></table></figure>
<h2 id="容器的读写层">容器的读写层</h2>
<p>当容器启动时，Docker 会在镜像的顶部添加一个读写层（thin RW layer）。所有的写操作都发生在这个可写层中。</p>
<p><img src="ubuntu-layers.png" alt="ubuntu-layers"></p>
<p>多个容器可以基于同一个镜像启动，它们共享底层的只读镜像层，但各自拥有独立的读写层。这种设计带来了存储效率、启动速度和内存效率的巨大优势。</p>
<h2 id="copy-on-write-写时复制-策略">Copy On Write（写时复制）策略</h2>
<p>Docker 使用 COW 策略来优化性能和空间利用率：</p>
<ol>
<li><strong>读取文件</strong>：直接从下层的只读层读取</li>
<li><strong>修改文件</strong>：先将文件从只读层复制到读写层，再在读写层中修改</li>
<li><strong>删除文件</strong>：在读写层中创建 whiteout 文件</li>
</ol>
<p>通常，应该让容器自己的 writable layer 变得非常薄——所谓的 thin RW layer。</p>
<h2 id="存储驱动">存储驱动</h2>
<p>Docker 通过存储驱动（Storage Driver）来实现 UnionFS 的功能。</p>
<h3 id="常见存储驱动">常见存储驱动</h3>
<table>
<thead>
<tr>
<th>存储驱动</th>
<th>特点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>overlay2</strong></td>
<td>当代默认驱动，性能优异</td>
<td>生产环境推荐</td>
</tr>
<tr>
<td><strong>overlay</strong></td>
<td>overlay2 的前身</td>
<td>旧系统兼容</td>
</tr>
<tr>
<td><strong>aufs</strong></td>
<td>最早的存储驱动，稳定</td>
<td>旧系统兼容</td>
</tr>
<tr>
<td><strong>devicemapper</strong></td>
<td>块级存储</td>
<td>RHEL/CentOS 旧版本</td>
</tr>
<tr>
<td><strong>btrfs</strong></td>
<td>文件系统级支持</td>
<td>需要底层文件系统支持</td>
</tr>
<tr>
<td><strong>ZFS</strong></td>
<td>企业级文件系统</td>
<td>需要底层文件系统支持</td>
</tr>
</tbody>
</table>
<h3 id="存储驱动选择优先级">存储驱动选择优先级</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">btrfs/zfs → overlay2 → overlay → aufs/devicemapper<br></code></pre></td></tr></table></figure>
<p>在当代，默认的存储驱动总是 overlay2，而以前则是 aufs。</p>
<h2 id="容器大小">容器大小</h2>
<p><code>docker ps -s</code> 命令可以显示容器的磁盘使用情况，包含两个大小指标：</p>
<ul>
<li><strong>SIZE</strong>：容器读写层的大小</li>
<li><strong>VIRTUAL SIZE</strong>：镜像只读层的大小 + 容器读写层的大小</li>
</ul>
<h2 id="镜像层次存储位置">镜像层次存储位置</h2>
<p>Docker 将镜像和容器数据存储在 <code>/var/lib/docker/</code> 目录下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /var/lib/docker/aufs/layers<br></code></pre></td></tr></table></figure>
<p><img src="docker-image-reference-parent.png" alt="docker-image-reference-parent"></p>
<h3 id="查看镜像层次">查看镜像层次</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">history</span> nginx:latest<br></code></pre></td></tr></table></figure>
<hr>
<h1>第3章：容器生命周期</h1>
<p>理解容器的生命周期是有效管理容器的关键。Docker 容器从创建到销毁经历多个状态，每个状态都有其特定的用途和转换条件。</p>
<h2 id="容器状态机">容器状态机</h2>
<table>
<thead>
<tr>
<th>状态</th>
<th>触发操作</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Created</strong></td>
<td><code>docker create</code></td>
<td>容器已创建但未启动，仅初始化文件系统层</td>
</tr>
<tr>
<td><strong>Running</strong></td>
<td><code>docker start</code> / <code>docker run</code></td>
<td>容器正在运行，进程处于活动状态</td>
</tr>
<tr>
<td><strong>Paused</strong></td>
<td><code>docker pause</code></td>
<td>容器进程被暂停，CPU 暂停但内存保留（cgroup freezer）</td>
</tr>
<tr>
<td><strong>Stopped</strong></td>
<td><code>docker stop</code></td>
<td>容器进程正常终止（发送 SIGTERM，等待优雅退出）</td>
</tr>
<tr>
<td><strong>Exited</strong></td>
<td>进程结束 / <code>docker kill</code></td>
<td>容器进程强制终止（SIGKILL）或自行退出</td>
</tr>
<tr>
<td><strong>Restarting</strong></td>
<td><code>docker restart</code></td>
<td>容器正在重启（先 stop 再 start）</td>
</tr>
</tbody>
</table>
<h2 id="stop-vs-pause-的核心区别">stop vs pause 的核心区别</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>docker stop</th>
<th>docker pause</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>进程状态</strong></td>
<td>完全终止</td>
<td>冻结（暂停）</td>
</tr>
<tr>
<td><strong>资源释放</strong></td>
<td>释放 CPU、内存、PID 等</td>
<td>仅释放 CPU，内存保留</td>
</tr>
<tr>
<td><strong>数据持久性</strong></td>
<td>读写层保留（需手动删除容器）</td>
<td>所有状态（包括内存）保留</td>
</tr>
<tr>
<td><strong>恢复速度</strong></td>
<td>慢（需重新启动进程）</td>
<td>快（从冻结点即时恢复）</td>
</tr>
<tr>
<td><strong>信号处理</strong></td>
<td>触发 SIGTERM/SIGKILL</td>
<td>无信号，直接冻结</td>
</tr>
<tr>
<td><strong>恢复方式</strong></td>
<td><code>docker start</code></td>
<td><code>docker unpause</code></td>
</tr>
<tr>
<td><strong>恢复后行为</strong></td>
<td>从 ENTRYPOINT 重新开始</td>
<td>从冻结点继续</td>
</tr>
<tr>
<td><strong>底层机制</strong></td>
<td>SIGTERM → 等待 → SIGKILL</td>
<td>cgroup freezer</td>
</tr>
</tbody>
</table>
<h3 id="docker-stop-的工作原理">docker stop 的工作原理</h3>
<ol>
<li>向容器的主进程（PID 1）发送 <code>SIGTERM</code> 信号</li>
<li>等待 10 秒（默认）让进程优雅退出</li>
<li>如果进程未退出，发送 <code>SIGKILL</code> 强制终止</li>
</ol>
<h3 id="docker-pause-unpause-的工作原理">docker pause / unpause 的工作原理</h3>
<p>通过 cgroup 的 freezer 子系统冻结/解冻容器内的所有进程，属于内核级操作，完全透明且高效。</p>
<h3 id="stop-后-start-的行为">stop 后 start 的行为</h3>
<ul>
<li>重新启动原来的进程（使用原有的 ENTRYPOINT 和 CMD 配置）</li>
<li><strong>不重新初始化文件系统</strong>：容器读写层中的所有文件保持不变</li>
<li>已写入的数据仍然存在</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --name <span class="hljs-built_in">test</span> -it alpine sh -c <span class="hljs-string">&quot;echo &#x27;初始日志&#x27; &gt; /log.txt &amp;&amp; cat /log.txt&quot;</span><br>docker stop <span class="hljs-built_in">test</span><br>docker start <span class="hljs-built_in">test</span><br>docker <span class="hljs-built_in">exec</span> <span class="hljs-built_in">test</span> <span class="hljs-built_in">cat</span> /log.txt  <span class="hljs-comment"># 仍可看到&quot;初始日志&quot;</span><br><br>docker <span class="hljs-built_in">rm</span> -f <span class="hljs-built_in">test</span><br>docker run --name <span class="hljs-built_in">test</span> -it alpine <span class="hljs-built_in">cat</span> /log.txt  <span class="hljs-comment"># 报错：文件不存在</span><br></code></pre></td></tr></table></figure>
<h2 id="后台运行容器的陷阱">后台运行容器的陷阱</h2>
<p>直接使用 <code>docker run -d</code> 启动容器时，容器可能会立即退出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d ubuntu:20.04  <span class="hljs-comment"># 容器会立即退出！</span><br></code></pre></td></tr></table></figure>
<p>原因：没有 <code>-t</code> 的 unattached 状态下，bash 会因为没有交互式终端而立即退出。</p>
<p>正确用法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 方法1：使用 -t 分配伪终端</span><br>docker run -td ubuntu:20.04<br><br><span class="hljs-comment"># 方法2：指定一个持续运行的命令</span><br>docker run -d ubuntu:20.04 <span class="hljs-built_in">tail</span> -f /dev/null<br><br><span class="hljs-comment"># 进入容器（exec 必须有 startup command 参数）</span><br>docker <span class="hljs-built_in">exec</span> -it &lt;container_id&gt; /bin/bash<br></code></pre></td></tr></table></figure>
<h2 id="docker-exec-vs-docker-attach">docker exec vs docker attach</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>docker exec</th>
<th>docker attach</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>创建新进程</strong></td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td><strong>连接到现有进程</strong></td>
<td>否</td>
<td>是（连接到 PID 1）</td>
</tr>
<tr>
<td><strong>退出后容器状态</strong></td>
<td>不影响</td>
<td>可能导致容器退出</td>
</tr>
<tr>
<td><strong>使用场景</strong></td>
<td>调试、执行命令</td>
<td>查看主进程输出</td>
</tr>
</tbody>
</table>
<p><strong>注意</strong>：使用 <code>docker attach</code> 时，如果主进程是 bash，使用 <code>Ctrl+D</code> 退出会导致容器退出。应该使用 <code>Ctrl+P</code> + <code>Ctrl+Q</code> 来分离而不退出。</p>
<h2 id="cmd-与-entrypoint">CMD 与 ENTRYPOINT</h2>
<p>CMD 和 ENTRYPOINT 都是<strong>容器命令化工具</strong>，让容器像可执行文件一样工作，接受参数，产生特定的输出。</p>
<h3 id="cmd-指令">CMD 指令</h3>
<p>CMD 提供容器启动时的默认命令，<strong>会被 <code>docker run</code> 结尾的参数覆盖</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Dockerfile: CMD [&quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot;]</span><br>docker run nginx:latest              <span class="hljs-comment"># 使用默认 CMD</span><br>docker run nginx:latest <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-comment"># 覆盖 CMD</span><br></code></pre></td></tr></table></figure>
<h3 id="entrypoint-指令">ENTRYPOINT 指令</h3>
<p>ENTRYPOINT 定义容器的入口点，<strong>不会被覆盖</strong>，<code>docker run</code> 结尾的参数会作为 ENTRYPOINT 的参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Dockerfile: ENTRYPOINT [&quot;curl&quot;]  CMD [&quot;-s&quot;, &quot;https://www.google.com&quot;]</span><br>docker run mycurl                                    <span class="hljs-comment"># 执行: curl -s https://www.google.com</span><br>docker run mycurl -s https://www.baidu.com           <span class="hljs-comment"># 执行: curl -s https://www.baidu.com</span><br></code></pre></td></tr></table></figure>
<h3 id="cmd-与-entrypoint-的关系">CMD 与 ENTRYPOINT 的关系</h3>
<ul>
<li>CMD 可以为 ENTRYPOINT 提供默认参数</li>
<li>一个容器最好只有一个 CMD 和一个 ENTRYPOINT</li>
<li>子镜像的 CMD 会覆盖父镜像的 CMD</li>
</ul>
<h3 id="exec-模式-vs-shell-模式">Exec 模式 vs Shell 模式</h3>
<p>这是理解 CMD 和 ENTRYPOINT 的关键：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>Exec 模式 <code>[&quot;nginx&quot;]</code></th>
<th>Shell 模式 <code>nginx</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>PID 1</strong></td>
<td>nginx 就是 PID 1</td>
<td><code>/bin/sh</code> 是 PID 1</td>
</tr>
<tr>
<td><strong>信号处理</strong></td>
<td>正确接收 SIGTERM</td>
<td>nginx 收不到信号</td>
</tr>
<tr>
<td><strong>环境变量</strong></td>
<td>不能直接使用</td>
<td>可以使用</td>
</tr>
<tr>
<td><strong>推荐度</strong></td>
<td>✅ 推荐</td>
<td>❌ 不推荐</td>
</tr>
</tbody>
</table>
<p>当执行 <code>docker stop</code> 时，Exec 模式的 nginx 会收到 SIGTERM 并优雅退出，而 Shell 模式的 nginx 不会收到信号，最终会被 SIGKILL 强制终止。</p>
<h3 id="特殊情况：entrypoint-为-bin-bash">特殊情况：ENTRYPOINT 为 /bin/bash</h3>
<p>如果 ENTRYPOINT 设置为 <code>/bin/bash</code>，容器最终成为一个 bash 命令，适用于需要灵活交互的场景。如果使用 sshd，还可以通过端口映射 SSH 进入容器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it -p 52022:22 myimage<br><span class="hljs-comment"># 容器内启动 sshd: /usr/sbin/sshd</span><br><span class="hljs-comment"># 本地 SSH: ssh -p 52022 root@localhost</span><br></code></pre></td></tr></table></figure>
<h2 id="重启策略-restart-policy">重启策略（Restart Policy）</h2>
<p>重启策略控制容器在退出后是否自动重启，是保障服务高可用的重要机制。</p>
<h3 id="四种重启策略">四种重启策略</h3>
<table>
<thead>
<tr>
<th>策略</th>
<th>行为</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>no</strong></td>
<td>不自动重启（默认）</td>
<td>一次性任务、测试容器</td>
</tr>
<tr>
<td><strong>on-failure[:max-retries]</strong></td>
<td>仅在非零退出码时重启，可限制最大重试次数</td>
<td>可能崩溃的服务</td>
</tr>
<tr>
<td><strong>always</strong></td>
<td>总是重启，包括手动 docker stop 后 daemon 重启时</td>
<td>长期运行的关键服务</td>
</tr>
<tr>
<td><strong>unless-stopped</strong></td>
<td>总是重启，但手动 docker stop 后 daemon 重启时不再启动</td>
<td>可临时停止的服务</td>
</tr>
</tbody>
</table>
<h3 id="使用场景说明">使用场景说明</h3>
<ul>
<li><strong>no</strong>：适用于批处理任务、构建容器等不需要持续运行的场景</li>
<li><strong>on-failure</strong>：适用于应用可能因错误退出但需要自动恢复的场景，避免正常退出时重启</li>
<li><strong>always</strong>：适用于必须持续运行的服务，如 Web 服务器、数据库等</li>
<li><strong>unless-stopped</strong>：适用于需要自动重启但允许管理员手动停止的场景</li>
</ul>
<h3 id="on-failure-的-max-retries-参数">on-failure 的 max-retries 参数</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 最多重启 5 次</span><br>docker run --restart=on-failure:5 myapp<br><br><span class="hljs-comment"># 查看重启次数</span><br>docker inspect -f <span class="hljs-string">&#x27;&#123;&#123;.RestartCount&#125;&#125;&#x27;</span> mycontainer<br></code></pre></td></tr></table></figure>
<h3 id="always-vs-unless-stopped-的关键区别">always vs unless-stopped 的关键区别</h3>
<table>
<thead>
<tr>
<th>行为</th>
<th>always</th>
<th>unless-stopped</th>
</tr>
</thead>
<tbody>
<tr>
<td>容器异常退出</td>
<td>重启</td>
<td>重启</td>
</tr>
<tr>
<td>手动 docker stop</td>
<td>停止</td>
<td>停止</td>
</tr>
<tr>
<td>Docker daemon 重启后</td>
<td><strong>重启</strong></td>
<td><strong>不重启</strong></td>
</tr>
</tbody>
</table>
<p><strong>关键差异</strong>：当用户手动执行 <code>docker stop</code> 后，如果 Docker daemon 重启（如系统重启），<code>always</code> 策略会自动重启容器，而 <code>unless-stopped</code> 不会。</p>
<h3 id="配置方式">配置方式</h3>
<h4 id="docker-run-命令">docker run 命令</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --restart=always nginx<br>docker run -d --restart=on-failure:5 myapp<br>docker run -d --restart=unless-stopped redis<br></code></pre></td></tr></table></figure>
<h4 id="docker-compose-yml">docker-compose.yml</h4>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">nginx:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>  <br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">on-failure:5</span><br></code></pre></td></tr></table></figure>
<h4 id="动态修改运行中的容器">动态修改运行中的容器</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改已有容器的重启策略</span><br>docker update --restart=always mycontainer<br><br><span class="hljs-comment"># 查看重启策略</span><br>docker inspect -f <span class="hljs-string">&#x27;&#123;&#123;.HostConfig.RestartPolicy.Name&#125;&#125;&#x27;</span> mycontainer<br></code></pre></td></tr></table></figure>
<h3 id="生产环境建议">生产环境建议</h3>
<ol>
<li><strong>关键服务使用 always</strong>：确保服务在异常退出或 daemon 重启后自动恢复</li>
<li><strong>避免无限重启循环</strong>：结合健康检查（HEALTHCHECK）和重启策略</li>
<li><strong>监控重启次数</strong>：频繁重启可能表示应用问题，需要告警</li>
<li><strong>使用 unless-stopped 提升运维灵活性</strong>：允许管理员手动停止维护，daemon 重启后不会自动启动</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看容器重启次数和上次重启时间</span><br>docker inspect -f <span class="hljs-string">&#x27;RestartCount: &#123;&#123;.RestartCount&#125;&#125;, StartedAt: &#123;&#123;.State.StartedAt&#125;&#125;&#x27;</span> mycontainer<br></code></pre></td></tr></table></figure>
<hr>
<h1>第4章：数据持久化</h1>
<p>容器本身是临时的，当容器被删除时，其读写层中的所有数据都会丢失。数据持久化是容器化应用必须解决的核心问题。</p>
<h2 id="为什么需要数据持久化">为什么需要数据持久化</h2>
<p>Docker 镜像是由多个文件系统（只读层）叠加而成。当我们启动一个容器的时候，Docker 会加载只读镜像层并在其上添加一个读写层。如果运行中的容器修改了现有文件，该文件将从只读层复制到读写层（COW）。当删除 Docker 容器并通过该镜像重新启动时，之前的更改将会丢失。</p>
<p>换言之，<strong>删除容器的时候要记得顺便删除数据卷</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除全部容器连带的数据卷</span><br>docker ps -aq | xargs docker <span class="hljs-built_in">rm</span> -f -v<br><span class="hljs-comment"># 删除遗留而不用的数据卷</span><br>docker volume prune<br></code></pre></td></tr></table></figure>
<p>容器的 Volume 不是为了持久化自己的状态。docker 自己的可读写层的状态另有存储的地方。<strong>Volume 是为了把容器及容器产生的数据分离出来</strong>。</p>
<h2 id="三种持久化方式概览">三种持久化方式概览</h2>
<p><img src="docker-storage.webp" alt="docker-storage"></p>
<table>
<thead>
<tr>
<th>方式</th>
<th>存储位置</th>
<th>管理方式</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Volume</strong></td>
<td><code>/var/lib/docker/volumes/</code></td>
<td>Docker 管理</td>
<td>数据持久化、容器间共享</td>
</tr>
<tr>
<td><strong>Bind Mount</strong></td>
<td>宿主机任意路径</td>
<td>用户管理</td>
<td>开发环境、配置文件共享</td>
</tr>
<tr>
<td><strong>tmpfs Mount</strong></td>
<td>宿主机内存</td>
<td>临时存储</td>
<td>敏感数据、临时缓存</td>
</tr>
</tbody>
</table>
<h2 id="volume-数据卷">Volume（数据卷）</h2>
<p><strong>Volumes 是 Docker 持久化数据最佳的选择</strong>。</p>
<h3 id="volume-的核心特性">Volume 的核心特性</h3>
<ul>
<li>存储在 <code>/var/lib/docker/volumes/</code>，由 Docker 守护进程管控</li>
<li>生命周期与容器互不干涉，容器删除后 Volume 仍然存在</li>
<li>命名卷 vs 匿名卷：Docker 会给匿名卷起一个随机名字</li>
<li>不能在已运行的容器上追加创建数据卷</li>
<li>支持远程存储（volume driver）</li>
</ul>
<h3 id="创建-volume">创建 Volume</h3>
<p>Volume 必须在容器初始化时就创建，只能在 <code>docker run</code> 或者 Dockerfile 里面指定数据卷：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 单参数：在容器中创建 /data 目录</span><br>docker run -it --name container-test -h CONTAINER -v /data debian /bin/bash<br><br><span class="hljs-comment"># 双参数：指定主机目录映射（从外到内）</span><br>docker run -v /home/adrian/data:/data debian <span class="hljs-built_in">ls</span> /data<br><br><span class="hljs-comment"># 使用 --mount（推荐，新用户应优先使用）</span><br>docker run -d --mount <span class="hljs-built_in">source</span>=myvol2,target=/app nginx:latest<br></code></pre></td></tr></table></figure>
<h3 id="docker-run-v-的参数顺序">docker run -v 的参数顺序</h3>
<p><code>docker run -v</code> 和 <code>-p</code> 的选项后接的参数都是<strong>从外到内</strong>的（host:container），而 <code>docker inspect</code> 的显示结果则是<strong>从内到外</strong>的（container:host）。</p>
<h3 id="dockerfile-中的-volume-指令">Dockerfile 中的 VOLUME 指令</h3>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> debian:wheezy<br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /data</span><br></code></pre></td></tr></table></figure>
<p><strong>重要限制</strong>：Dockerfile 中只能使用单参数形式，不能指定主机目录（可移植性考虑）。指定主机目录映射应该在 <code>docker-compose.yml</code> 中完成。</p>
<h3 id="pre-populate-data-数据预填充">Pre-populate Data（数据预填充）</h3>
<p>当空的 Volume 挂载到容器中已有数据的目录时，Docker 会自动将容器目录中的数据复制到 Volume 中。但 Bind Mount 不具备这个特性——Bind Mount 会直接遮盖容器内目标目录的原有内容。</p>
<h3 id="volume-常用命令">Volume 常用命令</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建卷</span><br>docker volume create my-vol<br><br><span class="hljs-comment"># 列出卷</span><br>docker volume <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 查看卷详情</span><br>docker volume inspect my-vol<br><br><span class="hljs-comment"># 删除卷</span><br>docker volume <span class="hljs-built_in">rm</span> my-vol<br><br><span class="hljs-comment"># 清理未使用的卷</span><br>docker volume prune<br></code></pre></td></tr></table></figure>
<h3 id="数据卷备份与恢复">数据卷备份与恢复</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 备份数据卷</span><br>docker run --<span class="hljs-built_in">rm</span> --volumes-from dbstore -v $(<span class="hljs-built_in">pwd</span>):/backup ubuntu tar cvf /backup/backup.tar /dbdata<br><br><span class="hljs-comment"># 恢复数据卷</span><br>docker run -v /dbdata --name dbstore2 ubuntu /bin/bash<br>docker run --<span class="hljs-built_in">rm</span> --volumes-from dbstore2 -v $(<span class="hljs-built_in">pwd</span>):/backup ubuntu bash -c <span class="hljs-string">&quot;cd /dbdata &amp;&amp; tar xvf /backup/backup.tar --strip 1&quot;</span><br></code></pre></td></tr></table></figure>
<h2 id="bind-mount">Bind Mount</h2>
<p>Bind Mount 将宿主机文件系统中的任意目录或文件挂载到容器中。</p>
<h3 id="核心特点">核心特点</h3>
<ul>
<li>路径不存在会自动创建</li>
<li>不具备 pre-populate data 特性，会直接遮盖容器内目标目录原有内容</li>
<li>容器有完全修改权限，存在安全隐患</li>
<li>与宿主机文件系统耦合</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d -it --name devtest \<br>  --mount <span class="hljs-built_in">type</span>=<span class="hljs-built_in">bind</span>,<span class="hljs-built_in">source</span>=<span class="hljs-string">&quot;<span class="hljs-subst">$(pwd)</span>&quot;</span>/target,target=/app \<br>  nginx:latest<br></code></pre></td></tr></table></figure>
<h2 id="tmpfs-mount">tmpfs Mount</h2>
<p>tmpfs Mount 将数据存储在宿主机的内存中，不持久化到磁盘。适用于存储敏感数据和临时缓存。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --tmpfs /tmp nginx<br></code></pre></td></tr></table></figure>
<h2 id="volume-vs-bind-mount-对比">Volume vs Bind Mount 对比</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>Volume</th>
<th>Bind Mount</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>设计目的</strong></td>
<td>数据隔离</td>
<td>数据共享</td>
</tr>
<tr>
<td><strong>管理方式</strong></td>
<td>Docker 管理</td>
<td>用户管理</td>
</tr>
<tr>
<td><strong>跨平台</strong></td>
<td>通用</td>
<td>依赖宿主机路径</td>
</tr>
<tr>
<td><strong>数据预填充</strong></td>
<td>支持</td>
<td>不支持</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>较高</td>
<td>较低</td>
</tr>
</tbody>
</table>
<p><strong>选择建议</strong>：</p>
<ul>
<li>容器间转移状态 → 使用 Volume</li>
<li>宿主机和容器共享状态 → 使用 Bind Mount</li>
<li>生产环境 → 优先使用 Volume</li>
<li>开发环境 → 可以使用 Bind Mount</li>
</ul>
<hr>
<h1>第5章：网络模型</h1>
<p>Docker 提供了灵活的网络模型，支持容器间通信、容器与外部网络的连接，以及跨主机通信。</p>
<h2 id="容器网络模型-cnm">容器网络模型（CNM）</h2>
<p>Docker 的网络功能基于容器网络模型（Container Networking Model，CNM）设计，这是一个抽象的网络架构模型，定义了容器网络的三个核心组件：</p>
<ol>
<li>
<p><strong>Sandbox（沙箱）</strong></p>
<ul>
<li>代表容器的网络栈，包含网络接口（NIC）、路由表、DNS 配置等</li>
<li>基于 Linux Network Namespace 实现，提供网络隔离</li>
<li>一个 Sandbox 可以包含多个 Endpoint</li>
</ul>
</li>
<li>
<p><strong>Endpoint（端点）</strong></p>
<ul>
<li>容器与网络的连接点，类似虚拟网卡</li>
<li>通过 veth pair（虚拟以太网对）实现容器与宿主机的连接</li>
<li>一个 Endpoint 只能连接到一个 Network</li>
</ul>
</li>
<li>
<p><strong>Network（网络）</strong></p>
<ul>
<li>一组可以相互通信的 Endpoint 集合</li>
<li>由网络驱动（bridge、overlay、macvlan 等）实现</li>
<li>支持跨主机的分布式网络</li>
</ul>
</li>
</ol>
<p>CNM 的设计使得 Docker 可以支持多种网络驱动，同时保持统一的 API 和管理方式。</p>
<h2 id="docker-网络驱动类型">Docker 网络驱动类型</h2>
<table>
<thead>
<tr>
<th>网络驱动</th>
<th>描述</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>bridge</strong></td>
<td>默认驱动，通过虚拟网桥连接容器</td>
<td>单机容器通信</td>
</tr>
<tr>
<td><strong>host</strong></td>
<td>容器共享宿主机网络栈</td>
<td>高性能网络需求</td>
</tr>
<tr>
<td><strong>none</strong></td>
<td>容器无网络访问</td>
<td>完全隔离的容器</td>
</tr>
<tr>
<td><strong>overlay</strong></td>
<td>跨主机通信网络</td>
<td>Swarm 集群</td>
</tr>
<tr>
<td><strong>macvlan</strong></td>
<td>为容器分配 MAC 地址</td>
<td>需要容器像物理机一样出现在网络中</td>
</tr>
</tbody>
</table>
<h2 id="bridge-网络-默认模式">Bridge 网络（默认模式）</h2>
<p>Bridge 是 Docker 的默认网络模式，它创建一个虚拟网桥（<code>docker0</code>），所有连接到该网络的容器都通过这个网桥通信。</p>
<h3 id="docker0-网桥">docker0 网桥</h3>
<p><code>docker0</code> 是 Docker 守护进程启动时自动创建的默认虚拟网桥，它是 Docker Bridge 网络的核心组件。</p>
<h4 id="docker0-的特点">docker0 的特点</h4>
<ul>
<li><strong>自动创建</strong>：Docker 守护进程首次启动时自动创建</li>
<li><strong>默认网关</strong>：通常分配 IP 地址 <code>172.17.0.1</code>，作为该网络的网关</li>
<li><strong>虚拟交换机</strong>：类似物理交换机，负责连接所有容器</li>
<li><strong>NAT 功能</strong>：通过 iptables 实现网络地址转换，使容器能够访问外部网络</li>
</ul>
<h4 id="查看-docker0-信息">查看 docker0 信息</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 ip 命令查看</span><br>ip addr show docker0<br><br><span class="hljs-comment"># 使用 ifconfig 查看</span><br>ifconfig docker0<br><br><span class="hljs-comment"># 查看网桥详细信息</span><br>brctl show docker0<br></code></pre></td></tr></table></figure>
<h4 id="docker0-的工作原理">docker0 的工作原理</h4>
<p>当容器启动并使用默认 bridge 网络时：</p>
<ol>
<li>Docker 创建一对 veth（虚拟以太网）设备</li>
<li>一端连接到容器内的 <code>eth0</code> 接口</li>
<li>另一端连接到宿主机的 <code>docker0</code> 网桥</li>
<li><code>docker0</code> 作为二层交换机，转发容器间的流量</li>
<li>通过 iptables NAT 规则，实现容器与外部网络的通信</li>
</ol>
<h3 id="veth-pair-机制">veth pair 机制</h3>
<p>Docker 使用 veth pair（虚拟以太网对）实现容器与宿主机的网络连接：</p>
<ul>
<li>一端在容器内，显示为 <code>eth0</code></li>
<li>一端在宿主机上，连接到 <code>docker0</code> 网桥</li>
</ul>
<h3 id="iptables-nat-规则">iptables NAT 规则</h3>
<p>Docker 通过 iptables 实现容器访问外部网络，主要涉及三个关键的 NAT 链：</p>
<h4 id="prerouting-链">PREROUTING 链</h4>
<p>处理进入宿主机的数据包，在路由决策之前进行目标地址转换（DNAT）：</p>
<ul>
<li>将目标地址为宿主机 IP 和映射端口的数据包转发到容器</li>
<li>例如：当外部访问 <code>宿主机IP:8080</code> 时，PREROUTING 链将目标地址转换为 <code>容器IP:80</code></li>
</ul>
<h4 id="postrouting-链">POSTROUTING 链</h4>
<p>处理离开容器的数据包，在路由决策之后进行源地址转换（MASQUERADE）：</p>
<ul>
<li>将容器发出的数据包的源 IP 伪装为宿主机 IP</li>
<li>这样外部网络只能看到宿主机 IP，无法知道容器 IP</li>
<li>确保容器能够访问外部网络，并且外部网络的响应能够返回到宿主机</li>
</ul>
<h4 id="forward-链">FORWARD 链</h4>
<p>控制数据包的转发，允许或拒绝数据包在容器和外部网络之间传输：</p>
<ul>
<li>决定是否允许数据包通过宿主机转发</li>
<li>Docker 默认允许转发，但可以通过 <code>--icc=false</code> 禁止容器间通信</li>
</ul>
<h4 id="查看-iptables-规则">查看 iptables 规则</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看 NAT 表中的 DOCKER 链</span><br><span class="hljs-built_in">sudo</span> iptables -t nat -L -n -v | grep DOCKER<br><br><span class="hljs-comment"># 查看 FORWARD 链</span><br><span class="hljs-built_in">sudo</span> iptables -L FORWARD -n -v | grep DOCKER<br><br><span class="hljs-comment"># 查看所有 Docker 相关规则</span><br><span class="hljs-built_in">sudo</span> iptables-save | grep DOCKER<br></code></pre></td></tr></table></figure>
<h4 id="流量转发配置">流量转发配置</h4>
<p>确保容器能够访问外部网络，需要开启 IP 转发：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 临时开启 IP 转发</span><br><span class="hljs-built_in">sudo</span> sysctl net.ipv4.conf.all.forwarding=1<br><br><span class="hljs-comment"># 永久开启 IP 转发</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;net.ipv4.conf.all.forwarding=1&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/sysctl.conf<br><span class="hljs-built_in">sudo</span> sysctl -p<br><br><span class="hljs-comment"># 设置 FORWARD 链的默认策略为 ACCEPT</span><br><span class="hljs-built_in">sudo</span> iptables -P FORWARD ACCEPT<br></code></pre></td></tr></table></figure>
<h4 id="iptables-规则示例">iptables 规则示例</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># DNAT 规则（外部访问容器）</span><br><span class="hljs-comment"># 当访问宿主机 8080 端口时，转发到容器 172.17.0.2:80</span><br>-A DOCKER -d 0.0.0.0/0 -p tcp -m tcp --dport 8080 -j DNAT --to-destination 172.17.0.2:80<br><br><span class="hljs-comment"># MASQUERADE 规则（容器访问外部）</span><br><span class="hljs-comment"># 容器访问外部网络时，源 IP 伪装为宿主机 IP</span><br>-A POSTROUTING -s 172.17.0.0/16 ! -o docker0 -j MASQUERADE<br></code></pre></td></tr></table></figure>
<h3 id="自定义-bridge-网络">自定义 bridge 网络</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network create --driver bridge mybridge<br>docker run -d --network mybridge --name container1 nginx<br>docker run -d --network mybridge --name container2 nginx<br><br><span class="hljs-comment"># 容器间可以通过名称通信（自动 DNS 解析）</span><br>docker <span class="hljs-built_in">exec</span> container1 ping container2<br></code></pre></td></tr></table></figure>
<p>自定义网络的优势：DNS 解析、网络隔离、自动发现。</p>
<h3 id="docker-proxy-进程">docker-proxy 进程</h3>
<p>当容器使用端口映射（<code>-p</code> 或 <code>-P</code>）时，Docker 会为每个映射的端口启动一个 <code>docker-proxy</code> 进程，这是一个用户态的 TCP/UDP 代理。</p>
<h4 id="docker-proxy-的作用">docker-proxy 的作用</h4>
<p>docker-proxy 负责将宿主机的端口流量转发到容器内部，主要用于处理以下场景：</p>
<ol>
<li><strong>Hairpin NAT 问题</strong>：当宿主机自身访问容器映射的端口时（如 <code>curl localhost:8080</code>），docker-proxy 能够正确处理流量回环</li>
<li><strong>用户态端口转发</strong>：提供简单的端口转发机制，不依赖内核特性</li>
</ol>
<h4 id="为什么需要-docker-proxy">为什么需要 docker-proxy</h4>
<p>虽然 iptables 的 DNAT 规则可以实现端口转发，但存在 hairpin NAT 的限制：从宿主机访问自己的映射端口时，部分内核版本无法正确处理回环流量。docker-proxy 通过用户态代理解决了这个问题。</p>
<h4 id="禁用-docker-proxy">禁用 docker-proxy</h4>
<p>可以通过修改 <code>/etc/docker/daemon.json</code> 禁用 docker-proxy：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;userland-proxy&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;userland-proxy-path&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;/usr/bin/docker-proxy&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>禁用后，Docker 将完全依赖 iptables 的 hairpin NAT 功能（需要内核 3.6+ 支持）。</p>
<h4 id="性能对比">性能对比</h4>
<table>
<thead>
<tr>
<th>方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>docker-proxy</strong></td>
<td>兼容性好，处理 hairpin NAT</td>
<td>用户态转发，性能较差，占用额外进程</td>
</tr>
<tr>
<td><strong>iptables only</strong></td>
<td>内核态转发，性能高，无额外进程</td>
<td>依赖内核版本，部分场景兼容性问题</td>
</tr>
</tbody>
</table>
<p><strong>建议</strong>：生产环境中，如果内核版本支持且无兼容性问题，可以禁用 docker-proxy 提升性能。</p>
<h3 id="icc-inter-container-communication-控制">ICC（Inter-Container Communication）控制</h3>
<p>ICC 控制决定同一 bridge 网络上的容器之间是否可以直接通信。</p>
<h4 id="禁止容器间通信">禁止容器间通信</h4>
<p>通过启动 dockerd 时添加 <code>--icc=false</code> 参数，可以禁止同一 bridge 网络上容器间的直接通信：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 修改 Docker daemon 配置</span><br><span class="hljs-comment"># /etc/docker/daemon.json</span><br>&#123;<br>  <span class="hljs-string">&quot;icc&quot;</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>Docker 会在 iptables 中添加 DROP 规则，阻止容器间的流量。</p>
<h4 id="与-link-的历史配合-已废弃">与 --link 的历史配合（已废弃）</h4>
<p>在旧版本中，当 <code>--icc=false</code> 时，容器间通信被完全禁止。此时需要使用 <code>--link</code> 参数显式允许特定容器间的通信：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 旧方式（已废弃）</span><br>docker run -d --name web --<span class="hljs-built_in">link</span> db:db nginx<br></code></pre></td></tr></table></figure>
<p><code>--link</code> 会：</p>
<ul>
<li>在目标容器中添加源容器的 DNS 记录</li>
<li>允许源容器访问目标容器的特定端口</li>
<li>注入环境变量</li>
</ul>
<p><strong>注意</strong>：<code>--link</code> 已被废弃，现代 Docker 应使用自定义网络替代。</p>
<h4 id="自定义网络天然隔离的优势">自定义网络天然隔离的优势</h4>
<p>自定义网络提供了更灵活的隔离机制：</p>
<ol>
<li><strong>默认隔离</strong>：不同自定义网络之间的容器无法直接通信</li>
<li><strong>网络内互通</strong>：同一自定义网络内的容器可以自由通信</li>
<li><strong>无需 --link</strong>：通过内置 DNS 解析实现容器名称访问</li>
<li><strong>精细化控制</strong>：可以动态连接/断开容器到网络</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建两个隔离的网络</span><br>docker network create frontend<br>docker network create backend<br><br><span class="hljs-comment"># 将容器连接到不同网络实现隔离</span><br>docker network connect frontend web<br>docker network connect backend db<br><br><span class="hljs-comment"># 动态断开连接</span><br>docker network disconnect frontend web<br></code></pre></td></tr></table></figure>
<h3 id="默认-bridge-vs-自定义-bridge-的差异">默认 bridge vs 自定义 bridge 的差异</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>默认 bridge</th>
<th>自定义 bridge</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>DNS 解析支持</strong></td>
<td>❌ 不支持（只能用 IP 或 --link）</td>
<td>✅ 支持容器名称解析</td>
</tr>
<tr>
<td><strong>网络隔离性</strong></td>
<td>❌ 所有容器在同一网络，无隔离</td>
<td>✅ 不同网络天然隔离</td>
</tr>
<tr>
<td><strong>–link 支持</strong></td>
<td>✅ 支持（已废弃）</td>
<td>❌ 不需要</td>
</tr>
<tr>
<td><strong>ICC 控制粒度</strong></td>
<td>❌ 全局控制（–icc=false 影响所有）</td>
<td>✅ 按网络隔离</td>
</tr>
<tr>
<td><strong>运行时连接/断开</strong></td>
<td>❌ 不支持</td>
<td>✅ 支持动态连接/断开</td>
</tr>
<tr>
<td><strong>环境变量共享</strong></td>
<td>✅ 通过 --link 注入</td>
<td>❌ 不共享</td>
</tr>
<tr>
<td><strong>推荐使用场景</strong></td>
<td>简单测试、单容器</td>
<td>生产环境、多容器应用</td>
</tr>
</tbody>
</table>
<p><strong>建议</strong>：在生产环境中始终使用自定义 bridge 网络，避免使用默认 bridge 和 --link。</p>
<h2 id="host-网络模式">Host 网络模式</h2>
<p>容器共享宿主机的网络栈，无网络隔离，最高性能，但端口不能冲突。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -d --network host nginx<br></code></pre></td></tr></table></figure>
<h2 id="overlay-网络-swarm-模式">Overlay 网络（Swarm 模式）</h2>
<p>Overlay 网络是 Docker Swarm 的核心网络功能，支持跨主机容器通信，使分布在不同主机上的容器能够像在同一台主机上一样通信。</p>
<h3 id="vxlan-技术">VXLAN 技术</h3>
<p>Overlay 网络基于 VXLAN（Virtual Extensible LAN）技术实现：</p>
<ul>
<li><strong>封装方式</strong>：将二层以太网帧封装在 UDP 数据包中，通过三层网络传输</li>
<li><strong>VNI 标识</strong>：使用 24 位的 VNI（VXLAN Network Identifier），支持 1600 万个虚拟网络</li>
<li><strong>性能</strong>：相比传统 VLAN，VXLAN 提供了更好的扩展性和灵活性</li>
<li><strong>端口</strong>：默认使用 UDP 4789 端口进行数据传输</li>
</ul>
<h3 id="swarm-的两个内部网络">Swarm 的两个内部网络</h3>
<p>Docker Swarm 模式下，会自动创建两个内部网络：</p>
<ol>
<li>
<p><strong>ingress 网络</strong></p>
<ul>
<li>处理 Swarm 集群的流量路由</li>
<li>实现服务发现和负载均衡</li>
<li>所有发布的服务都会连接到这个网络</li>
</ul>
</li>
<li>
<p><strong>docker_gwbridge 网络</strong></p>
<ul>
<li>连接不同 Docker 守护进程的桥接网络</li>
<li>处理容器与外部网络的通信</li>
<li>提供 NAT 功能，使容器能够访问外部网络</li>
</ul>
</li>
</ol>
<h3 id="创建-overlay-网络的先决条件">创建 Overlay 网络的先决条件</h3>
<p>在创建 Overlay 网络之前，需要确保以下端口开放：</p>
<table>
<thead>
<tr>
<th>端口</th>
<th>协议</th>
<th>用途</th>
</tr>
</thead>
<tbody>
<tr>
<td>2377</td>
<td>TCP</td>
<td>Swarm 集群管理通信</td>
</tr>
<tr>
<td>7946</td>
<td>TCP/UDP</td>
<td>节点发现和路由</td>
</tr>
<tr>
<td>4789</td>
<td>UDP</td>
<td>VXLAN 数据传输</td>
</tr>
</tbody>
</table>
<h3 id="创建-overlay-网络">创建 Overlay 网络</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 初始化 Swarm 集群</span><br>docker swarm init<br><br><span class="hljs-comment"># 创建可附加的 Overlay 网络</span><br>docker network create --driver overlay --attachable myoverlay<br><br><span class="hljs-comment"># 创建加密的 Overlay 网络</span><br>docker network create --driver overlay --opt encrypted mysecure<br><br><span class="hljs-comment"># 创建带有子网的 Overlay 网络</span><br>docker network create --driver overlay --subnet 10.10.0.0/24 --attachable mysubnet<br><br><span class="hljs-comment"># 使用 Overlay 网络创建服务</span><br>docker service create --name myservice --network myoverlay nginx<br></code></pre></td></tr></table></figure>
<h3 id="attachable-参数">–attachable 参数</h3>
<p>默认情况下，Overlay 网络只能被 Swarm 服务使用。添加 <code>--attachable</code> 参数后，独立的容器也可以加入到 Overlay 网络中：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建可附加的 Overlay 网络</span><br>docker network create --driver overlay --attachable myoverlay<br><br><span class="hljs-comment"># 将独立容器连接到 Overlay 网络</span><br>docker run -d --network myoverlay --name mycontainer nginx<br><br><span class="hljs-comment"># 将运行中的容器连接到 Overlay 网络</span><br>docker network connect myoverlay existing_container<br></code></pre></td></tr></table></figure>
<h3 id="加密传输">加密传输</h3>
<p>通过 <code>--opt encrypted</code> 参数启用 IPSec 加密，保护容器间的通信安全：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建加密的 Overlay 网络</span><br>docker network create --driver overlay --opt encrypted mysecure<br><br><span class="hljs-comment"># 查看网络加密状态</span><br>docker network inspect mysecure | grep encrypted<br></code></pre></td></tr></table></figure>
<p>加密使用 AES GCM 算法，虽然会增加一定的性能开销，但提供了更好的安全性。</p>
<h3 id="定制-ingress-网络">定制 ingress 网络</h3>
<p>如果需要定制 ingress 网络（例如修改子网），可以按照以下步骤：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 查看当前 ingress 网络配置</span><br>docker network inspect ingress<br><br><span class="hljs-comment"># 2. 删除默认的 ingress 网络</span><br>docker network <span class="hljs-built_in">rm</span> ingress<br><br><span class="hljs-comment"># 3. 重新创建自定义的 ingress 网络</span><br>docker network create \<br>  --driver overlay \<br>  --ingress \<br>  --subnet 10.11.0.0/16 \<br>  --opt com.docker.network.bridge.name=ingress \<br>  ingress<br></code></pre></td></tr></table></figure>
<h3 id="绕过路由网格：dnsrr-模式">绕过路由网格：DNSRR 模式</h3>
<p>默认情况下，Swarm 使用路由网格（Routing Mesh）实现负载均衡。如果需要绕过路由网格，可以使用 DNSRR（DNS Round Robin）模式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建使用 DNSRR 模式的服务</span><br>docker service create \<br>  --name myservice \<br>  --network myoverlay \<br>  --endpoint-mode dnsrr \<br>  nginx<br></code></pre></td></tr></table></figure>
<p>DNSRR 模式下：</p>
<ul>
<li>不使用 VIP（Virtual IP）</li>
<li>直接通过 DNS 轮询返回所有容器的 IP 地址</li>
<li>客户端需要自己处理负载均衡</li>
<li>适合需要直接访问特定容器的场景</li>
</ul>
<h2 id="端口映射">端口映射</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 映射单个端口</span><br>docker run -d -p 8080:80 nginx<br><br><span class="hljs-comment"># 映射多个端口</span><br>docker run -d -p 8080:80 -p 8443:443 nginx<br><br><span class="hljs-comment"># 绑定到特定 IP</span><br>docker run -d -p 127.0.0.1:8080:80 nginx<br><br><span class="hljs-comment"># 随机端口映射</span><br>docker run -d -p 80 nginx<br><br><span class="hljs-comment"># 映射 UDP 端口</span><br>docker run -d -p 53:53/udp bind9<br></code></pre></td></tr></table></figure>
<h2 id="网络管理命令">网络管理命令</h2>
<p>Docker 提供了丰富的网络管理命令，用于创建、连接、断开和监控网络。</p>
<h3 id="docker-network-create">docker network create</h3>
<p>创建自定义网络，支持指定子网、网关等参数：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建基本的 bridge 网络</span><br>docker network create mybridge<br><br><span class="hljs-comment"># 指定子网和网关</span><br>docker network create --subnet 192.168.100.0/24 --gateway 192.168.100.1 mysubnet<br><br><span class="hljs-comment"># 指定 IP 范围</span><br>docker network create --subnet 192.168.100.0/24 --ip-range 192.168.100.128/25 myrange<br><br><span class="hljs-comment"># 指定网络选项</span><br>docker network create --opt com.docker.network.bridge.name=docker1 myopt<br><br><span class="hljs-comment"># 创建 IPv6 网络</span><br>docker network create --ipv6 --subnet 2001:db8::/64 myipv6<br></code></pre></td></tr></table></figure>
<h3 id="docker-network-connect">docker network connect</h3>
<p>将容器连接到网络，支持指定 IP 和别名：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 将容器连接到网络</span><br>docker network connect mynetwork mycontainer<br><br><span class="hljs-comment"># 指定容器的 IP 地址</span><br>docker network connect --ip 192.168.100.10 mynetwork mycontainer<br><br><span class="hljs-comment"># 指定多个 IP 地址</span><br>docker network connect --ip 192.168.100.10 --ip6 2001:db8::10 mynetwork mycontainer<br><br><span class="hljs-comment"># 指定网络别名（容器可以通过别名被访问）</span><br>docker network connect --<span class="hljs-built_in">alias</span> db --<span class="hljs-built_in">alias</span> database mynetwork mycontainer<br><br><span class="hljs-comment"># 指定链接别名（兼容旧版 --link）</span><br>docker network connect --<span class="hljs-built_in">link</span> othercontainer:<span class="hljs-built_in">alias</span> mynetwork mycontainer<br></code></pre></td></tr></table></figure>
<h3 id="docker-network-disconnect">docker network disconnect</h3>
<p>将容器从网络中断开：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 断开容器连接</span><br>docker network disconnect mynetwork mycontainer<br><br><span class="hljs-comment"># 强制断开连接（即使容器正在运行）</span><br>docker network disconnect -f mynetwork mycontainer<br></code></pre></td></tr></table></figure>
<h3 id="docker-network-inspect">docker network inspect</h3>
<p>查看网络的详细信息，支持格式化输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看网络详细信息</span><br>docker network inspect mynetwork<br><br><span class="hljs-comment"># 格式化输出（只显示 IPAM 配置）</span><br>docker network inspect --format <span class="hljs-string">&#x27;&#123;&#123;.IPAM&#125;&#125;&#x27;</span> mynetwork<br><br><span class="hljs-comment"># 格式化输出（只显示连接的容器）</span><br>docker network inspect --format <span class="hljs-string">&#x27;&#123;&#123;range .Containers&#125;&#125;&#123;&#123;.Name&#125;&#125; &#123;&#123;end&#125;&#125;&#x27;</span> mynetwork<br><br><span class="hljs-comment"># 使用 Go 模板输出 JSON 格式</span><br>docker network inspect --format <span class="hljs-string">&#x27;&#123;&#123;json .Containers&#125;&#125;&#x27;</span> mynetwork | jq<br></code></pre></td></tr></table></figure>
<h3 id="docker-network-ls">docker network ls</h3>
<p>列出所有网络：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有网络</span><br>docker network <span class="hljs-built_in">ls</span><br><br><span class="hljs-comment"># 只显示网络 ID</span><br>docker network <span class="hljs-built_in">ls</span> -q<br><br><span class="hljs-comment"># 显示详细信息</span><br>docker network <span class="hljs-built_in">ls</span> --no-trunc<br></code></pre></td></tr></table></figure>
<h3 id="docker-network-prune">docker network prune</h3>
<p>删除未使用的网络：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除所有未使用的网络</span><br>docker network prune<br><br><span class="hljs-comment"># 强制删除（不提示确认）</span><br>docker network prune -f<br><br><span class="hljs-comment"># 删除超过 24 小时未使用的网络</span><br>docker network prune --filter <span class="hljs-string">&quot;until=24h&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="docker-network-rm">docker network rm</h3>
<p>删除指定的网络：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 删除网络</span><br>docker network <span class="hljs-built_in">rm</span> mynetwork<br><br><span class="hljs-comment"># 删除多个网络</span><br>docker network <span class="hljs-built_in">rm</span> mynetwork1 mynetwork2<br><br><span class="hljs-comment"># 强制删除</span><br>docker network <span class="hljs-built_in">rm</span> -f mynetwork<br></code></pre></td></tr></table></figure>
<h2 id="docker-dns-服务">Docker DNS 服务</h2>
<p>Docker 内置了 DNS 服务器，为容器提供服务发现功能，使容器能够通过名称相互访问。</p>
<h3 id="docker-内置-dns-服务器">Docker 内置 DNS 服务器</h3>
<p>Docker 为每个容器提供一个内置的 DNS 服务器，地址为 <code>127.0.0.11</code>。这个 DNS 服务器：</p>
<ul>
<li>自动解析同一网络中其他容器的名称</li>
<li>支持 A 记录（名称 → IP 地址）</li>
<li>支持 SRV 记录（服务端口）</li>
<li>支持 PTR 记录（反向查询）</li>
<li>在自定义网络中自动启用</li>
</ul>
<h3 id="查看容器-dns-配置">查看容器 DNS 配置</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看容器的 DNS 配置</span><br>docker <span class="hljs-built_in">exec</span> &lt;container&gt; <span class="hljs-built_in">cat</span> /etc/resolv.conf<br><br><span class="hljs-comment"># 输出示例：</span><br><span class="hljs-comment"># nameserver 127.0.0.11</span><br><span class="hljs-comment"># options ndots:0</span><br></code></pre></td></tr></table></figure>
<h3 id="服务发现功能">服务发现功能</h3>
<p>在自定义网络中，容器可以通过名称相互发现：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建自定义网络</span><br>docker network create mynetwork<br><br><span class="hljs-comment"># 启动两个容器</span><br>docker run -d --name web --network mynetwork nginx<br>docker run -d --name db --network mynetwork postgres<br><br><span class="hljs-comment"># 在 web 容器中通过名称访问 db 容器</span><br>docker <span class="hljs-built_in">exec</span> web ping db<br>docker <span class="hljs-built_in">exec</span> web curl http://db:5432<br></code></pre></td></tr></table></figure>
<h3 id="支持的-dns-记录类型">支持的 DNS 记录类型</h3>
<p>Docker DNS 服务器支持以下记录类型：</p>
<ol>
<li>
<p><strong>A 记录</strong>：将容器名称映射到 IP 地址</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查询 A 记录</span><br>docker <span class="hljs-built_in">exec</span> web nslookup db<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>SRV 记录</strong>：提供服务的端口信息</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查询 SRV 记录</span><br>docker <span class="hljs-built_in">exec</span> web nslookup -<span class="hljs-built_in">type</span>=SRV _web._tcp.mynetwork<br></code></pre></td></tr></table></figure>
</li>
<li>
<p><strong>PTR 记录</strong>：反向 DNS 查询</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查询 PTR 记录</span><br>docker <span class="hljs-built_in">exec</span> web nslookup 172.18.0.2<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="swarm-模式下的-dns-负载均衡">Swarm 模式下的 DNS 负载均衡</h3>
<p>在 Docker Swarm 模式下，DNS 服务器提供负载均衡功能：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建 Swarm 服务</span><br>docker service create --name web --replicas 3 --network mynetwork nginx<br><br><span class="hljs-comment"># DNS 返回 VIP（Virtual IP）</span><br>docker <span class="hljs-built_in">exec</span> client nslookup web<br><br><span class="hljs-comment"># DNS 返回所有容器的 IP（DNSRR 模式）</span><br>docker service create --name web --replicas 3 --network mynetwork --endpoint-mode dnsrr nginx<br></code></pre></td></tr></table></figure>
<h3 id="自定义-dns-服务器">自定义 DNS 服务器</h3>
<p>可以为容器指定自定义的 DNS 服务器：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 指定 DNS 服务器</span><br>docker run -d --dns 8.8.8.8 --dns 8.8.4.4 nginx<br><br><span class="hljs-comment"># 指定 DNS 搜索域</span><br>docker run -d --dns-search example.com nginx<br><br><span class="hljs-comment"># 指定 DNS 选项</span><br>docker run -d --dns-opt <span class="hljs-built_in">timeout</span>:2 --dns-opt attempts:3 nginx<br><br><span class="hljs-comment"># 组合使用</span><br>docker run -d \<br>  --dns 8.8.8.8 \<br>  --dns 8.8.4.4 \<br>  --dns-search example.com \<br>  --dns-search internal.example.com \<br>  --dns-opt <span class="hljs-built_in">timeout</span>:2 \<br>  nginx<br></code></pre></td></tr></table></figure>
<h3 id="dns-问题排查">DNS 问题排查</h3>
<p>当容器无法解析域名时，可以按以下步骤排查：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 检查容器的 DNS 配置</span><br>docker <span class="hljs-built_in">exec</span> &lt;container&gt; <span class="hljs-built_in">cat</span> /etc/resolv.conf<br><br><span class="hljs-comment"># 2. 测试 DNS 解析</span><br>docker <span class="hljs-built_in">exec</span> &lt;container&gt; nslookup google.com<br><br><span class="hljs-comment"># 3. 检查网络连接</span><br>docker <span class="hljs-built_in">exec</span> &lt;container&gt; ping 8.8.8.8<br><br><span class="hljs-comment"># 4. 检查容器是否在自定义网络中</span><br>docker network inspect &lt;network&gt;<br><br><span class="hljs-comment"># 5. 检查 Docker 守护进程的 DNS 配置</span><br><span class="hljs-built_in">cat</span> /etc/docker/daemon.json<br><br><span class="hljs-comment"># 6. 重启 Docker 守护进程</span><br><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure>
<h3 id="常见-dns-问题">常见 DNS 问题</h3>
<ol>
<li>
<p><strong>默认 bridge 网络不支持容器名称解析</strong></p>
<ul>
<li>解决方案：使用自定义网络</li>
</ul>
</li>
<li>
<p><strong>容器无法解析外部域名</strong></p>
<ul>
<li>检查宿主机的 DNS 配置</li>
<li>使用 <code>--dns</code> 参数指定 DNS 服务器</li>
</ul>
</li>
<li>
<p><strong>容器间无法通过名称访问</strong></p>
<ul>
<li>确保容器在同一个自定义网络中</li>
<li>检查容器名称是否正确</li>
</ul>
</li>
</ol>
<h2 id="link-的废弃">–link 的废弃</h2>
<p><code>--link</code> 是旧版本的容器连接方式，已被废弃。应该使用自定义网络替代，自定义网络提供了 DNS 解析、网络隔离和自动发现等更好的功能。</p>
<h2 id="macvlan-网络详解">macvlan 网络详解</h2>
<p>macvlan 网络驱动允许容器直接连接到宿主机的物理网络接口，使容器拥有独立的 MAC 地址和 IP 地址，就像物理网络中的独立设备一样。</p>
<h3 id="工作原理">工作原理</h3>
<p>macvlan 在宿主机的物理网络接口上创建多个虚拟接口，每个虚拟接口都有：</p>
<ul>
<li><strong>独立的 MAC 地址</strong>：每个容器拥有唯一的 MAC 地址</li>
<li><strong>独立的 IP 地址</strong>：每个容器可以配置独立的 IP</li>
<li><strong>直接连接物理网络</strong>：无需 NAT 转换，直接与物理网络通信</li>
</ul>
<h3 id="创建-macvlan-网络">创建 macvlan 网络</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建 macvlan 网络</span><br>docker network create -d macvlan \<br>  --subnet=192.168.1.0/24 \<br>  --gateway=192.168.1.1 \<br>  --ip-range=192.168.1.192/27 \<br>  -o parent=eth0 \<br>  mymacvlan<br><br><span class="hljs-comment"># 使用 macvlan 网络启动容器</span><br>docker run -d --network mymacvlan --ip 192.168.1.200 nginx<br></code></pre></td></tr></table></figure>
<h3 id="macvlan-的优点">macvlan 的优点</h3>
<ul>
<li><strong>独立 MAC 地址</strong>：容器在网络上表现为独立设备</li>
<li><strong>高性能</strong>：无 NAT 转换开销，直接访问物理网络</li>
<li><strong>网络透明</strong>：外部网络可以直接访问容器</li>
<li><strong>支持广播</strong>：支持网络广播和组播</li>
</ul>
<h3 id="macvlan-的缺点">macvlan 的缺点</h3>
<ul>
<li><strong>需要物理接口支持</strong>：物理接口必须支持 promiscuous 模式</li>
<li><strong>MAC 地址表限制</strong>：交换机的 MAC 地址表大小可能限制容器数量</li>
<li><strong>宿主机无法直接通信</strong>：宿主机无法直接与 macvlan 容器通信</li>
<li><strong>网络隔离性差</strong>：所有容器在同一物理网络上</li>
</ul>
<h3 id="宿主机与-macvlan-容器通信">宿主机与 macvlan 容器通信</h3>
<p>由于 macvlan 容器无法直接与宿主机通信，可以通过创建 shim 接口解决：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在宿主机上创建 shim 接口</span><br>ip <span class="hljs-built_in">link</span> add mymacvlan-shim <span class="hljs-built_in">link</span> eth0 <span class="hljs-built_in">type</span> macvlan mode bridge<br>ip addr add 192.168.1.250/32 dev mymacvlan-shim<br>ip <span class="hljs-built_in">link</span> <span class="hljs-built_in">set</span> mymacvlan-shim up<br></code></pre></td></tr></table></figure>
<h2 id="缺省桥接网络配置">缺省桥接网络配置</h2>
<p>可以通过修改 Docker daemon 配置文件（<code>/etc/docker/daemon.json</code>）来自定义默认 bridge 网络的配置。</p>
<h3 id="配置项说明">配置项说明</h3>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;bip&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;172.26.0.1/16&quot;</span><span class="hljs-punctuation">,</span>              <span class="hljs-comment">// bridge IP 地址</span><br>  <span class="hljs-attr">&quot;fixed-cidr&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;172.26.0.0/16&quot;</span><span class="hljs-punctuation">,</span>        <span class="hljs-comment">// 容器 IP 地址范围</span><br>  <span class="hljs-attr">&quot;fixed-cidr-v6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2001:db8::/64&quot;</span><span class="hljs-punctuation">,</span>     <span class="hljs-comment">// IPv6 地址范围</span><br>  <span class="hljs-attr">&quot;mtu&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1500</span><span class="hljs-punctuation">,</span>                          <span class="hljs-comment">// 最大传输单元</span><br>  <span class="hljs-attr">&quot;default-gateway&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;172.26.0.1&quot;</span><span class="hljs-punctuation">,</span>      <span class="hljs-comment">// 默认网关</span><br>  <span class="hljs-attr">&quot;dns&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><span class="hljs-string">&quot;8.8.8.8&quot;</span><span class="hljs-punctuation">,</span> <span class="hljs-string">&quot;8.8.4.4&quot;</span><span class="hljs-punctuation">]</span>         <span class="hljs-comment">// DNS 服务器</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<h3 id="配置步骤">配置步骤</h3>
<ol>
<li>编辑 <code>/etc/docker/daemon.json</code></li>
<li>添加或修改上述配置项</li>
<li>重启 Docker daemon：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>修改配置后需要重启 Docker daemon 才能生效</li>
<li>修改 <code>bip</code> 会影响所有使用默认 bridge 网络的容器</li>
<li>建议在生产环境中使用自定义网络而非默认 bridge</li>
</ul>
<h2 id="容器-ip-地址指定">容器 IP 地址指定</h2>
<p>在某些场景下，可能需要为容器指定固定的 IP 地址。</p>
<h3 id="使用-docker-network-connect-指定-ip">使用 docker network connect 指定 IP</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建自定义网络</span><br>docker network create --subnet 172.20.0.0/16 mynetwork<br><br><span class="hljs-comment"># 启动容器</span><br>docker run -d --name mycontainer nginx<br><br><span class="hljs-comment"># 将容器连接到网络并指定 IP</span><br>docker network connect --ip 172.20.0.10 mynetwork mycontainer<br><br><span class="hljs-comment"># 指定多个 IP 地址</span><br>docker network connect --ip 172.20.0.10 --ip6 2001:db8::10 mynetwork mycontainer<br></code></pre></td></tr></table></figure>
<h3 id="使用-docker-run-指定-ip">使用 docker run 指定 IP</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建自定义网络</span><br>docker network create --subnet 172.20.0.0/16 mynetwork<br><br><span class="hljs-comment"># 启动容器并指定 IP</span><br>docker run -d \<br>  --network mynetwork \<br>  --ip 172.20.0.10 \<br>  --name mycontainer \<br>  nginx<br></code></pre></td></tr></table></figure>
<h3 id="注意事项">注意事项</h3>
<ul>
<li>只能在自定义网络中指定 IP 地址</li>
<li>指定的 IP 必须在网络配置的子网范围内</li>
<li>IP 地址不能与网络中其他容器冲突</li>
<li>修改 IP 地址需要先断开容器连接，然后重新连接</li>
</ul>
<h2 id="ipv6-支持">IPv6 支持</h2>
<p>Docker 支持为容器分配 IPv6 地址，使容器能够使用 IPv6 网络通信。</p>
<h3 id="启用-ipv6-支持">启用 IPv6 支持</h3>
<p>需要在 Docker daemon 配置文件中启用 IPv6：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;ipv6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;fixed-cidr-v6&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2001:db8::/64&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<h3 id="创建-ipv6-网络">创建 IPv6 网络</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建支持 IPv6 的网络</span><br>docker network create \<br>  --ipv6 \<br>  --subnet 2001:db8::/64 \<br>  myipv6network<br><br><span class="hljs-comment"># 启动容器并分配 IPv6 地址</span><br>docker run -d --network myipv6network --name mycontainer nginx<br><br><span class="hljs-comment"># 指定 IPv6 地址</span><br>docker run -d \<br>  --network myipv6network \<br>  --ip6 2001:db8::10 \<br>  --name mycontainer \<br>  nginx<br></code></pre></td></tr></table></figure>
<h3 id="验证-ipv6-配置">验证 IPv6 配置</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看容器的 IPv6 地址</span><br>docker <span class="hljs-built_in">exec</span> mycontainer ip -6 addr<br><br><span class="hljs-comment"># 测试 IPv6 连通性</span><br>docker <span class="hljs-built_in">exec</span> mycontainer ping6 2001:4860:4860::8888<br></code></pre></td></tr></table></figure>
<h3 id="参考链接">参考链接</h3>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/config/daemon/ipv6/">Docker IPv6 官方文档</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/network/ipv6/">IPv6 网络最佳实践</a></li>
</ul>
<h1>第6章：Dockerfile 最佳实践</h1>
<p>Dockerfile 是构建 Docker 镜像的核心配置文件，编写高质量的 Dockerfile 不仅能够减小镜像体积，还能提升构建速度和运行安全性。</p>
<h2 id="基础结构示例">基础结构示例</h2>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 使用具体版本标签，避免使用 latest</span><br><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine<br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 复制依赖文件（利用构建缓存）</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> package*.json ./</span><br><br><span class="hljs-comment"># 安装依赖</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm ci --only=production &amp;&amp; \</span><br><span class="language-bash">    npm cache clean --force</span><br><br><span class="hljs-comment"># 复制应用代码</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-comment"># 设置环境变量</span><br><span class="hljs-keyword">ENV</span> NODE_ENV=production \<br>    PORT=<span class="hljs-number">3000</span><br><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span><br><br><span class="hljs-comment"># 健康检查</span><br><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> --interval=30s --<span class="hljs-built_in">timeout</span>=3s --start-period=5s --retries=3 \</span><br><span class="language-bash">    CMD curl -f http://localhost:3000/health || <span class="hljs-built_in">exit</span> 1</span><br><br><span class="hljs-comment"># 启动命令</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;server.js&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<h2 id="多阶段构建-multi-stage-build">多阶段构建（Multi-stage Build）</h2>
<p>多阶段构建可以显著减小镜像体积，最终镜像只包含运行时所需的文件：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 构建阶段</span><br><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine AS builder<br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> package*.json ./</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm ci</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm run build</span><br><br><span class="hljs-comment"># 生产阶段</span><br><span class="hljs-keyword">FROM</span> nginx:alpine<br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /app/dist /usr/share/nginx/html</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span><br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;nginx&quot;</span>, <span class="hljs-string">&quot;-g&quot;</span>, <span class="hljs-string">&quot;daemon off;&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<h2 id="最佳实践详解">最佳实践详解</h2>
<h3 id="1-使用具体版本标签-避免-latest">1. 使用具体版本标签，避免 latest</h3>
<p><code>latest</code> 是一个浮动标签，随时可能指向不同的版本，影响可重现性和 CI/CD 稳定性。</p>
<h3 id="2-合并-run-指令减少层数">2. 合并 RUN 指令减少层数</h3>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 推荐</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; \</span><br><span class="language-bash">    apt-get install -y curl &amp;&amp; \</span><br><span class="language-bash">    apt-get clean &amp;&amp; \</span><br><span class="language-bash">    <span class="hljs-built_in">rm</span> -rf /var/lib/apt/lists/*</span><br></code></pre></td></tr></table></figure>
<h3 id="3-利用构建缓存">3. 利用构建缓存</h3>
<p>将变化少的指令放在前面，变化多的指令放在后面。先复制 <code>package.json</code> 安装依赖，再复制源代码。</p>
<h3 id="4-使用-dockerignore">4. 使用 .dockerignore</h3>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">node_modules<br>.git<br>.env<br>*.md<br>test<br>coverage<br></code></pre></td></tr></table></figure>
<h3 id="5-最小化镜像体积">5. 最小化镜像体积</h3>
<ul>
<li><strong>alpine</strong>：约 5MB，体积最小</li>
<li><strong>slim</strong>：约 70MB，兼容性好</li>
<li><strong>完整版</strong>：约 200MB+</li>
</ul>
<h3 id="6-非-root-用户运行">6. 非 root 用户运行</h3>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">RUN</span><span class="language-bash"> addgroup -g 1001 -S nodejs &amp;&amp; \</span><br><span class="language-bash">    adduser -S nodejs -u 1001</span><br><span class="hljs-keyword">USER</span> nodejs<br></code></pre></td></tr></table></figure>
<h2 id="arg-vs-env">ARG vs ENV</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>ARG</th>
<th>ENV</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>作用范围</strong></td>
<td>仅在构建时有效</td>
<td>构建时和运行时都有效</td>
</tr>
<tr>
<td><strong>覆盖方式</strong></td>
<td><code>--build-arg</code></td>
<td><code>docker run -e</code></td>
</tr>
<tr>
<td><strong>典型用途</strong></td>
<td>构建时的配置参数</td>
<td>应用运行时的环境变量</td>
</tr>
</tbody>
</table>
<h2 id="copy-vs-add">COPY vs ADD</h2>
<ul>
<li><strong>COPY</strong>：简单的文件复制，推荐使用</li>
<li><strong>ADD</strong>：支持自动解压 tar 文件和远程 URL 下载，仅在需要这些功能时使用</li>
</ul>
<h2 id="健康检查">健康检查</h2>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">HEALTHCHECK</span><span class="language-bash"> --interval=30s --<span class="hljs-built_in">timeout</span>=3s --start-period=5s --retries=3 \</span><br><span class="language-bash">    CMD curl -f http://localhost:8000/health || <span class="hljs-built_in">exit</span> 1</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看容器健康状态</span><br>docker inspect --format=<span class="hljs-string">&#x27;&#123;&#123;json .State.Health&#125;&#125;&#x27;</span> my-container | jq<br><br><span class="hljs-comment"># 查看健康状态</span><br>docker ps --format <span class="hljs-string">&quot;table &#123;&#123;.Names&#125;&#125;	&#123;&#123;.Status&#125;&#125;&quot;</span><br></code></pre></td></tr></table></figure>
<h2 id="buildkit-构建增强">BuildKit 构建增强</h2>
<p>BuildKit 是 Docker 18.09+ 引入的下一代构建引擎，提供了更快的构建速度、更好的缓存机制和更安全的构建方式。Docker 23.0+ 版本中，BuildKit 已成为默认构建引擎。</p>
<h3 id="启用-buildkit">启用 BuildKit</h3>
<p>在 Docker Desktop 中，BuildKit 默认已启用。在 Linux 系统上，可以通过以下方式启用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 临时启用</span><br>DOCKER_BUILDKIT=1 docker build -t myapp .<br><br><span class="hljs-comment"># 永久启用（修改 daemon.json）</span><br>&#123;<br>  <span class="hljs-string">&quot;features&quot;</span>: &#123;<br>    <span class="hljs-string">&quot;buildkit&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="缓存挂载-mount-type-cache">缓存挂载（–mount=type=cache）</h3>
<p>缓存挂载可以加速包管理器安装，避免每次构建重新下载依赖。缓存数据不会写入镜像层，显著减小镜像体积。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># apt 缓存</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> --mount=<span class="hljs-built_in">type</span>=cache,target=/var/cache/apt,sharing=locked \</span><br><span class="language-bash">    --mount=<span class="hljs-built_in">type</span>=cache,target=/var/lib/apt,sharing=locked \</span><br><span class="language-bash">    apt-get update &amp;&amp; apt-get install -y curl</span><br><br><span class="hljs-comment"># npm 缓存</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> --mount=<span class="hljs-built_in">type</span>=cache,target=/root/.npm \</span><br><span class="language-bash">    npm ci --only=production</span><br><br><span class="hljs-comment"># pip 缓存</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> --mount=<span class="hljs-built_in">type</span>=cache,target=/root/.cache/pip \</span><br><span class="language-bash">    pip install --no-cache-dir -r requirements.txt</span><br><br><span class="hljs-comment"># Maven 缓存</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> --mount=<span class="hljs-built_in">type</span>=cache,target=/root/.m2 \</span><br><span class="language-bash">    mvn clean package</span><br></code></pre></td></tr></table></figure>
<h3 id="secret-挂载-mount-type-secret">Secret 挂载（–mount=type=secret）</h3>
<p>Secret 挂载允许在构建时安全地使用密钥和凭证（如 npm token、pip 私有源凭证），这些敏感信息不会写入镜像层。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># Dockerfile</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> --mount=<span class="hljs-built_in">type</span>=secret,<span class="hljs-built_in">id</span>=npm_token,target=/root/.npmrc \</span><br><span class="language-bash">    npm ci --registry=https://registry.npmjs.org</span><br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> --mount=<span class="hljs-built_in">type</span>=secret,<span class="hljs-built_in">id</span>=pip_conf,target=/root/.pip/pip.conf \</span><br><span class="language-bash">    pip install -r requirements.txt</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 构建时传递 secret</span><br>docker build \<br>  --secret <span class="hljs-built_in">id</span>=npm_token,src=<span class="hljs-variable">$HOME</span>/.npmrc \<br>  --secret <span class="hljs-built_in">id</span>=pip_conf,src=<span class="hljs-variable">$HOME</span>/.pip/pip.conf \<br>  -t myapp .<br></code></pre></td></tr></table></figure>
<h3 id="ssh-挂载-mount-type-ssh">SSH 挂载（–mount=type=ssh）</h3>
<p>SSH 挂载允许在构建时使用宿主机的 SSH agent 密钥，适用于从私有 Git 仓库克隆代码等场景。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># Dockerfile</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> --mount=<span class="hljs-built_in">type</span>=ssh \</span><br><span class="language-bash">    git <span class="hljs-built_in">clone</span> git@github.com:myorg/private-repo.git /app</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 构建时启用 SSH agent 转发</span><br>docker build \<br>  --ssh default \<br>  -t myapp .<br></code></pre></td></tr></table></figure>
<h3 id="构建输出导出-output">构建输出导出（–output）</h3>
<p><code>--output</code> 参数可以将构建产物直接导出到本地文件系统，而非打包为镜像。适用于 CI/CD 中只需要编译产物的场景。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 导出构建产物到本地目录</span><br>docker build \<br>  --output <span class="hljs-built_in">type</span>=<span class="hljs-built_in">local</span>,dest=./build \<br>  -f Dockerfile.build \<br>  .<br><br><span class="hljs-comment"># 导出为 tar 归档</span><br>docker build \<br>  --output <span class="hljs-built_in">type</span>=tar,dest=build.tar \<br>  -f Dockerfile.build \<br>  .<br></code></pre></td></tr></table></figure>
<h3 id="内联缓存-cache-from-cache-to">内联缓存（–cache-from / --cache-to）</h3>
<p>内联缓存允许跨构建共享缓存层，在 CI/CD 场景中利用 registry 缓存加速构建。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 构建时使用远程缓存</span><br>docker build \<br>  --cache-from myregistry.com/myapp:cache \<br>  --cache-to <span class="hljs-built_in">type</span>=registry,ref=myregistry.com/myapp:cache,mode=max \<br>  -t myapp:latest .<br></code></pre></td></tr></table></figure>
<h3 id="heredoc-语法">Heredoc 语法</h3>
<p>Docker BuildKit 支持使用 heredoc 语法编写多行脚本，简化复杂的 RUN 指令。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># syntax=docker/dockerfile:1</span><br><br><span class="hljs-keyword">FROM</span> alpine<br><br><span class="hljs-keyword">RUN</span><span class="language-bash"> &lt;&lt;<span class="hljs-string">EOF</span></span><br>    echo <span class="hljs-string">&quot;Installing dependencies...&quot;</span><br>    apk <span class="hljs-keyword">add</span><span class="language-bash"><span class="hljs-string"> --no-cache curl git</span></span><br>    echo <span class="hljs-string">&quot;Configuration complete&quot;</span><br>    cat &gt; /etc/config.conf &lt;&lt;EOM<br>    setting1=value1<br>    setting2=value2<br>    EOM<br>    echo <span class="hljs-string">&quot;Done&quot;</span><br>EOF<br></code></pre></td></tr></table></figure>
<p>heredoc 语法使脚本更易读，避免了大量反斜杠续行符的使用。</p>
<hr>
<h1>第7章：Docker Compose 编排</h1>
<p>Docker Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 YAML 文件配置应用的服务，然后使用一个命令即可创建并启动所有服务。</p>
<h2 id="基础命令">基础命令</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 后台启动所有服务</span><br>docker compose up -d<br><br><span class="hljs-comment"># 停止所有服务</span><br>docker compose stop<br><br><span class="hljs-comment"># 停止并删除容器、网络、卷</span><br>docker compose down -v<br><br><span class="hljs-comment"># 强制删除运行中的容器</span><br>docker compose <span class="hljs-built_in">kill</span><br><br><span class="hljs-comment"># 查看服务状态</span><br>docker compose ps<br><br><span class="hljs-comment"># 查看服务日志</span><br>docker compose logs -f<br></code></pre></td></tr></table></figure>
<h2 id="v1-到-v2-的变化">V1 到 V2 的变化</h2>
<table>
<thead>
<tr>
<th>特性</th>
<th>V1</th>
<th>V2</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>命令格式</strong></td>
<td><code>docker-compose</code>（连字符）</td>
<td><code>docker compose</code>（空格）</td>
</tr>
<tr>
<td><strong>集成方式</strong></td>
<td>独立二进制文件</td>
<td>Docker CLI 插件</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较慢</td>
<td>更快</td>
</tr>
</tbody>
</table>
<h2 id="docker-compose-yml-基本结构">docker-compose.yml 基本结构</h2>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./html:/usr/share/nginx/html:ro</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">frontend</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">app</span><br><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./app</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">NODE_ENV=$&#123;NODE_ENV:-development&#125;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DB_HOST=db</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">frontend</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-attr">db:</span><br>        <span class="hljs-attr">condition:</span> <span class="hljs-string">service_healthy</span><br><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:15-alpine</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_DB=myapp</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_USER=$&#123;DB_USER:-user&#125;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">POSTGRES_PASSWORD=$&#123;DB_PASSWORD:-password&#125;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">postgres_data:/var/lib/postgresql/data</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span><br>    <span class="hljs-attr">healthcheck:</span><br>      <span class="hljs-attr">test:</span> [<span class="hljs-string">&quot;CMD-SHELL&quot;</span>, <span class="hljs-string">&quot;pg_isready -U postgres&quot;</span>]<br>      <span class="hljs-attr">interval:</span> <span class="hljs-string">10s</span><br>      <span class="hljs-attr">timeout:</span> <span class="hljs-string">5s</span><br>      <span class="hljs-attr">retries:</span> <span class="hljs-number">5</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">frontend:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br>  <span class="hljs-attr">backend:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br><br><span class="hljs-attr">volumes:</span><br>  <span class="hljs-attr">postgres_data:</span><br></code></pre></td></tr></table></figure>
<p><strong>重要</strong>：在 <code>docker-compose.yml</code> 中可以指定 volume mapping（主机目录到容器目录的映射），这是 Dockerfile 做不到的。</p>
<h2 id="环境变量管理">环境变量管理</h2>
<p>Docker Compose 支持通过 <code>.env</code> 文件管理环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs env">NODE_ENV=production<br>DB_USER=admin<br>DB_PASSWORD=secret123<br></code></pre></td></tr></table></figure>
<h2 id="depends-on-与服务启动顺序">depends_on 与服务启动顺序</h2>
<p><code>depends_on</code> 只控制启动顺序，不等待服务完全就绪。对于需要等待服务就绪的场景，应该使用健康检查。</p>
<h2 id="profiles-的使用">Profiles 的使用</h2>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">profiles:</span> [<span class="hljs-string">development</span>, <span class="hljs-string">staging</span>]<br>  <span class="hljs-attr">app-prod:</span><br>    <span class="hljs-attr">profiles:</span> [<span class="hljs-string">production</span>]<br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker compose --profile development up -d<br>docker compose --profile production up -d<br></code></pre></td></tr></table></figure>
<h2 id="多文件-override">多文件 Override</h2>
<p>Docker Compose 支持通过 <code>-f</code> 参数指定多个 compose 文件，后面的文件会覆盖前面的配置。这种机制使得我们可以在不同环境间灵活切换配置。</p>
<h3 id="f-参数指定多个文件">-f 参数指定多个文件</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 指定多个 compose 文件，后面的文件覆盖前面的配置</span><br>docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d<br></code></pre></td></tr></table></figure>
<h3 id="docker-compose-override-yml-自动加载">docker-compose.override.yml 自动加载</h3>
<p>当 <code>docker-compose.yml</code> 同目录下存在 <code>docker-compose.override.yml</code> 时，Docker Compose 会自动加载并合并这两个文件。这是本地开发环境的最佳实践：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># docker-compose.yml（基础配置）</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000:3000&quot;</span><br></code></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># docker-compose.override.yml（本地开发覆盖）</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">.:/app</span>  <span class="hljs-comment"># 挂载源代码实现热重载</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DEBUG=true</span><br></code></pre></td></tr></table></figure>
<h3 id="环境分离最佳实践">环境分离最佳实践</h3>
<p>推荐使用 base + 环境特定文件的结构：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">project</span>/<br>├── docker-compose.yml           <span class="hljs-comment"># 基础配置（所有环境共享）</span><br>├── docker-compose.dev.yml       <span class="hljs-comment"># 开发环境配置</span><br>├── docker-compose.prod.yml      <span class="hljs-comment"># 生产环境配置</span><br>└── docker-compose.<span class="hljs-keyword">test</span>.yml      <span class="hljs-comment"># 测试环境配置</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开发环境</span><br>docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d<br><br><span class="hljs-comment"># 生产环境</span><br>docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d<br><br><span class="hljs-comment"># 测试环境</span><br>docker compose -f docker-compose.yml -f docker-compose.test.yml up -d<br></code></pre></td></tr></table></figure>
<h3 id="配置合并规则">配置合并规则</h3>
<ul>
<li>后面的文件覆盖前面的同名配置</li>
<li>数组和对象会进行深度合并</li>
<li>标量和数组会完全替换</li>
</ul>
<h2 id="扩展字段-x-前缀">扩展字段（x- 前缀）</h2>
<p>Docker Compose 支持使用 YAML 锚点和 <code>x-</code> 前缀定义可复用的配置块，有效减少重复代码。</p>
<h3 id="yaml-锚点与别名">YAML 锚点与别名</h3>
<p>YAML 锚点（<code>&amp;anchor</code>）和别名（<code>*alias</code>）允许我们定义一次配置，然后在多处引用：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">x-common-env:</span> <span class="hljs-string">&amp;common-env</span><br>  <span class="hljs-attr">NODE_ENV:</span> <span class="hljs-string">production</span><br>  <span class="hljs-attr">LOG_LEVEL:</span> <span class="hljs-string">info</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-string">&lt;&lt;:</span> <span class="hljs-string">*common-env</span><br>      <span class="hljs-attr">PORT:</span> <span class="hljs-number">3000</span><br>  <br>  <span class="hljs-attr">api:</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-string">&lt;&lt;:</span> <span class="hljs-string">*common-env</span><br>      <span class="hljs-attr">PORT:</span> <span class="hljs-number">4000</span><br></code></pre></td></tr></table></figure>
<h3 id="x-前缀公共配置块">x- 前缀公共配置块</h3>
<p>使用 <code>x-</code> 前缀定义可复用的公共配置，Docker Compose 会忽略这些字段，但可以用于 YAML 锚点引用：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><br><span class="hljs-comment"># 公共配置块</span><br><span class="hljs-attr">x-common-logging:</span> <span class="hljs-string">&amp;common-logging</span><br>  <span class="hljs-attr">driver:</span> <span class="hljs-string">&quot;json-file&quot;</span><br>  <span class="hljs-attr">options:</span><br>    <span class="hljs-attr">max-size:</span> <span class="hljs-string">&quot;10m&quot;</span><br>    <span class="hljs-attr">max-file:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">x-common-deploy:</span> <span class="hljs-string">&amp;common-deploy</span><br>  <span class="hljs-attr">resources:</span><br>    <span class="hljs-attr">limits:</span><br>      <span class="hljs-attr">cpus:</span> <span class="hljs-string">&#x27;0.5&#x27;</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">512M</span><br>    <span class="hljs-attr">reservations:</span><br>      <span class="hljs-attr">cpus:</span> <span class="hljs-string">&#x27;0.25&#x27;</span><br>      <span class="hljs-attr">memory:</span> <span class="hljs-string">256M</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">logging:</span> <span class="hljs-string">*common-logging</span><br>    <span class="hljs-attr">deploy:</span> <span class="hljs-string">*common-deploy</span><br>  <br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./app</span><br>    <span class="hljs-attr">logging:</span> <span class="hljs-string">*common-logging</span><br>    <span class="hljs-attr">deploy:</span> <span class="hljs-string">*common-deploy</span><br></code></pre></td></tr></table></figure>
<h3 id="减少重复的完整示例">减少重复的完整示例</h3>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><br><span class="hljs-attr">x-base-service:</span> <span class="hljs-string">&amp;base-service</span><br>  <span class="hljs-attr">restart:</span> <span class="hljs-string">unless-stopped</span><br>  <span class="hljs-attr">networks:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">frontend</span><br>  <span class="hljs-attr">logging:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">&quot;json-file&quot;</span><br>    <span class="hljs-attr">options:</span><br>      <span class="hljs-attr">max-size:</span> <span class="hljs-string">&quot;10m&quot;</span><br>      <span class="hljs-attr">max-file:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-string">&lt;&lt;:</span> <span class="hljs-string">*base-service</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80:80&quot;</span><br>  <br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-string">&lt;&lt;:</span> <span class="hljs-string">*base-service</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./app</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">NODE_ENV=$&#123;NODE_ENV:-production&#125;</span><br>  <br>  <span class="hljs-attr">worker:</span><br>    <span class="hljs-string">&lt;&lt;:</span> <span class="hljs-string">*base-service</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">./worker</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">node</span> <span class="hljs-string">worker.js</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">frontend:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br></code></pre></td></tr></table></figure>
<h2 id="资源限制">资源限制</h2>
<p>Docker Compose 支持通过 <code>deploy.resources</code> 限制容器的 CPU 和内存使用，防止资源耗尽。</p>
<h3 id="deploy-resources-配置">deploy.resources 配置</h3>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">deploy:</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">limits:</span><br>          <span class="hljs-attr">cpus:</span> <span class="hljs-string">&#x27;0.5&#x27;</span>      <span class="hljs-comment"># CPU 上限（0.5 核）</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">512M</span>     <span class="hljs-comment"># 内存上限</span><br>        <span class="hljs-attr">reservations:</span><br>          <span class="hljs-attr">cpus:</span> <span class="hljs-string">&#x27;0.25&#x27;</span>     <span class="hljs-comment"># CPU 保留（保证至少 0.25 核）</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">256M</span>     <span class="hljs-comment"># 内存保留</span><br></code></pre></td></tr></table></figure>
<h3 id="简写形式-compose-v2">简写形式（Compose V2）</h3>
<p>Compose V2 支持更简洁的写法：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">mem_limit:</span> <span class="hljs-string">512m</span>        <span class="hljs-comment"># 内存上限</span><br>    <span class="hljs-attr">cpus:</span> <span class="hljs-number">0.5</span>              <span class="hljs-comment"># CPU 上限</span><br></code></pre></td></tr></table></figure>
<h3 id="与-cgroup-的关系">与 cgroup 的关系</h3>
<p>Docker 通过 Linux cgroup（Control Group）实现资源限制：</p>
<ul>
<li><strong>CPU 限制</strong>：通过 cgroup 的 <code>cpu</code> 和 <code>cpuacct</code> 子系统实现</li>
<li><strong>内存限制</strong>：通过 cgroup 的 <code>memory</code> 子系统实现</li>
<li><strong>limits vs reservations</strong>：
<ul>
<li><code>limits</code>：硬限制，超过会被 OOM Killer 杀掉</li>
<li><code>reservations</code>：软限制，保证资源可用性，但不强制</li>
</ul>
</li>
</ul>
<h3 id="完整示例">完整示例</h3>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">deploy:</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">limits:</span><br>          <span class="hljs-attr">cpus:</span> <span class="hljs-string">&#x27;1.0&#x27;</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">1G</span><br>        <span class="hljs-attr">reservations:</span><br>          <span class="hljs-attr">cpus:</span> <span class="hljs-string">&#x27;0.5&#x27;</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">512M</span><br>  <br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">deploy:</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">limits:</span><br>          <span class="hljs-attr">cpus:</span> <span class="hljs-string">&#x27;2.0&#x27;</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">2G</span><br>        <span class="hljs-attr">reservations:</span><br>          <span class="hljs-attr">cpus:</span> <span class="hljs-string">&#x27;1.0&#x27;</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">1G</span><br>  <br>  <span class="hljs-attr">worker:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">worker:latest</span><br>    <span class="hljs-attr">deploy:</span><br>      <span class="hljs-attr">resources:</span><br>        <span class="hljs-attr">limits:</span><br>          <span class="hljs-attr">cpus:</span> <span class="hljs-string">&#x27;0.5&#x27;</span><br>          <span class="hljs-attr">memory:</span> <span class="hljs-string">256M</span><br></code></pre></td></tr></table></figure>
<h2 id="compose-watch-开发模式">Compose Watch（开发模式）</h2>
<p>Docker Compose 2.22+ 引入了 <code>develop.watch</code> 功能，提供了比传统 volume 挂载更强大的开发模式。</p>
<h3 id="三种-action">三种 Action</h3>
<table>
<thead>
<tr>
<th>Action</th>
<th>说明</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>sync</strong></td>
<td>文件同步到容器</td>
<td>静态资源、配置文件</td>
</tr>
<tr>
<td><strong>rebuild</strong></td>
<td>重新构建镜像</td>
<td>依赖变更（package.json）</td>
</tr>
<tr>
<td><strong>sync+restart</strong></td>
<td>同步后重启服务</td>
<td>代码变更需要重启</td>
</tr>
</tbody>
</table>
<h3 id="compose-watch-的优势">Compose Watch 的优势</h3>
<p>相比传统的 volume 挂载开发模式，Compose Watch 具有以下优势：</p>
<ul>
<li><strong>不需要宿主机依赖</strong>：不需要在宿主机安装 Node.js、Python 等运行时</li>
<li><strong>跨平台一致性</strong>：开发环境与生产环境完全一致</li>
<li><strong>性能更好</strong>：智能同步，避免全量文件系统监控</li>
<li><strong>更灵活</strong>：支持不同的同步策略</li>
</ul>
<h3 id="完整配置示例">完整配置示例</h3>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">develop:</span><br>      <span class="hljs-attr">watch:</span><br>        <span class="hljs-comment"># 监听静态文件，同步到容器</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">./src</span><br>          <span class="hljs-attr">target:</span> <span class="hljs-string">/app/src</span><br>          <span class="hljs-attr">action:</span> <span class="hljs-string">sync</span><br>        <br>        <span class="hljs-comment"># 监听依赖文件，重新构建</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">package.json</span><br>          <span class="hljs-attr">action:</span> <span class="hljs-string">rebuild</span><br>        <br>        <span class="hljs-comment"># 监听配置文件，同步并重启</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">./config</span><br>          <span class="hljs-attr">target:</span> <span class="hljs-string">/app/config</span><br>          <span class="hljs-attr">action:</span> <span class="hljs-string">sync+restart</span><br>        <br>        <span class="hljs-comment"># 排除特定文件</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">./src</span><br>          <span class="hljs-attr">target:</span> <span class="hljs-string">/app/src</span><br>          <span class="hljs-attr">action:</span> <span class="hljs-string">sync</span><br>          <span class="hljs-attr">ignore:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">node_modules/</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">.git/</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">dist/</span><br></code></pre></td></tr></table></figure>
<h3 id="docker-compose-watch-命令">docker compose watch 命令</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动 watch 模式</span><br>docker compose watch<br><br><span class="hljs-comment"># 启动特定服务的 watch 模式</span><br>docker compose watch app<br><br><span class="hljs-comment"># 后台运行</span><br>docker compose watch --detach<br><br><span class="hljs-comment"># 查看日志</span><br>docker compose logs -f<br></code></pre></td></tr></table></figure>
<h3 id="与传统开发模式对比">与传统开发模式对比</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>Volume 挂载</th>
<th>Compose Watch</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>宿主机依赖</strong></td>
<td>需要安装运行时</td>
<td>不需要</td>
</tr>
<tr>
<td><strong>跨平台一致性</strong></td>
<td>差</td>
<td>好</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>较好（文件系统级）</td>
<td>好（智能同步）</td>
</tr>
<tr>
<td><strong>配置复杂度</strong></td>
<td>简单</td>
<td>中等</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>快速原型</td>
<td>生产级开发</td>
</tr>
</tbody>
</table>
<h3 id="实际应用场景">实际应用场景</h3>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Node.js 应用开发</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">build:</span> <span class="hljs-string">.</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3000:3000&quot;</span><br>    <span class="hljs-attr">develop:</span><br>      <span class="hljs-attr">watch:</span><br>        <span class="hljs-comment"># 源代码变更：同步并重启</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">./src</span><br>          <span class="hljs-attr">target:</span> <span class="hljs-string">/app/src</span><br>          <span class="hljs-attr">action:</span> <span class="hljs-string">sync+restart</span><br>          <span class="hljs-attr">ignore:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">node_modules/</span><br>        <br>        <span class="hljs-comment"># 依赖变更：重新构建</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">package.json</span><br>          <span class="hljs-attr">action:</span> <span class="hljs-string">rebuild</span><br>        <br>        <span class="hljs-comment"># 静态资源：仅同步</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-attr">path:</span> <span class="hljs-string">./public</span><br>          <span class="hljs-attr">target:</span> <span class="hljs-string">/app/public</span><br>          <span class="hljs-attr">action:</span> <span class="hljs-string">sync</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动开发环境</span><br>docker compose watch<br><br><span class="hljs-comment"># 修改代码后自动同步并重启</span><br><span class="hljs-comment"># 修改 package.json 后自动重新构建</span><br><span class="hljs-comment"># 修改静态资源后自动同步</span><br></code></pre></td></tr></table></figure>
<hr>
<h1>第8章：Docker in Docker</h1>
<p>Docker in Docker（简称 DinD）是指在 Docker 容器内部运行 Docker 守护进程的能力。最适合的领域是持续集成领域，不断地在容器内部产生子容器，加速交付流程。</p>
<h2 id="dind-的原始目的">DinD 的原始目的</h2>
<p>DinD 最初是为了 Docker 自身的开发测试，简化开发流程（避免反复停止/启动 Docker 守护进程）。</p>
<h2 id="正确的-dind-启动方式">正确的 DinD 启动方式</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 必须使用 dind 镜像</span><br>docker run --privileged -d docker:dind<br><br><span class="hljs-comment"># exec 进入容器</span><br>docker <span class="hljs-built_in">exec</span> -it &lt;container_name&gt; /bin/sh<br><br><span class="hljs-comment"># 在容器里再跑一个容器</span><br>docker run -it ubuntu /bin/bash<br></code></pre></td></tr></table></figure>
<h2 id="dind-的主要问题">DinD 的主要问题</h2>
<table>
<thead>
<tr>
<th>问题类型</th>
<th>具体问题</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>安全问题</strong></td>
<td>内外 Docker 的 LSM（SELinux/AppArmor）冲突，需 <code>--privileged</code> 赋予过高权限</td>
</tr>
<tr>
<td><strong>存储驱动冲突</strong></td>
<td>内外存储驱动不兼容（如 AUFS 嵌套），嵌套操作易失败</td>
</tr>
<tr>
<td><strong>缓存与状态管理</strong></td>
<td>内层缓存与宿主机隔离，重启丢失，需重新拉取镜像</td>
</tr>
<tr>
<td><strong>共享目录风险</strong></td>
<td>挂载 <code>/var/lib/docker</code> 导致数据竞争和损坏（Docker 要求独占访问）</td>
</tr>
</tbody>
</table>
<h2 id="替代方案：挂载-docker-socket">替代方案：挂载 Docker Socket</h2>
<p>将宿主机的 <code>/var/run/docker.sock</code> 挂载到容器内，容器内的 docker CLI 直接与宿主机的 Docker 守护进程通信：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -v /var/run/docker.sock:/var/run/docker.sock -ti docker<br></code></pre></td></tr></table></figure>
<p>在容器内执行 <code>docker run ubuntu</code>，实际会在宿主机上启动一个容器，而非在容器内嵌套启动容器——容器启动的容器是宿主机的&quot;兄弟&quot;而非&quot;子容器&quot;。</p>
<h3 id="对比表">对比表</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>挂载 Socket</th>
<th>Docker-in-Docker (DinD)</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>隔离性</strong></td>
<td>与宿主机共享（无隔离）</td>
<td>完全隔离</td>
</tr>
<tr>
<td><strong>存储驱动兼容性</strong></td>
<td>无冲突</td>
<td>可能不兼容</td>
</tr>
<tr>
<td><strong>镜像/容器缓存共享</strong></td>
<td>共享宿主机缓存</td>
<td>独立缓存</td>
</tr>
<tr>
<td><strong>安全性</strong></td>
<td>权限可控</td>
<td>需 <code>--privileged</code></td>
</tr>
<tr>
<td><strong>典型场景</strong></td>
<td>CI/CD 构建、测试</td>
<td>Docker 自身开发测试</td>
</tr>
</tbody>
</table>
<h2 id="现代方案：sysbox">现代方案：Sysbox</h2>
<p>Sysbox 是一个开源的容器运行时，无需 <code>--privileged</code> 标志即可安全运行 DinD，提供接近虚拟机的隔离级别。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --runtime=sysbox-runc -d docker:dind<br></code></pre></td></tr></table></figure>
<h2 id="关键结论">关键结论</h2>
<ul>
<li><strong>避免滥用 DinD</strong>：除非必须完全隔离的 Docker 环境，否则优先选择挂载 Socket 方案</li>
<li><strong>安全性优先</strong>：使用 Sysbox 替代 <code>--privileged</code> 模式</li>
<li><strong>缓存共享</strong>：通过挂载 Socket 或 Sysbox 共享镜像缓存，提升 CI/CD 效率</li>
</ul>
<hr>
<h1>第9章：日志与调试</h1>
<p>日志管理和调试是容器运维中的重要环节。</p>
<h2 id="日志基础">日志基础</h2>
<p>Docker 自动捕获容器内所有输出到 stdout 和 stderr 的内容。</p>
<h3 id="默认日志驱动-json-file">默认日志驱动（json-file）</h3>
<p>Docker 默认将日志以 JSON 格式存储在宿主机上：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/docker/</span>containers<span class="hljs-regexp">/&lt;容器ID&gt;/</span>&lt;容器ID&gt;-json.log<br></code></pre></td></tr></table></figure>
<h3 id="日志轮转配置">日志轮转配置</h3>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;log-driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;json-file&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;log-opts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;max-size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10m&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;max-file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;5&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p><strong>未配置轮转的风险</strong>：日志文件持续增长，最终占满磁盘。</p>
<h3 id="自定义日志驱动">自定义日志驱动</h3>
<p>使用 syslog/fluentd/none 等自定义日志驱动会导致 <code>docker logs</code> 命令失效。</p>
<h3 id="直接写入文件的日志">直接写入文件的日志</h3>
<p>如果容器内进程将日志直接写入文件（而非 stdout/stderr），需要通过 <code>docker exec</code> 进入容器查看或挂载宿主机目录。</p>
<h2 id="日志命令">日志命令</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker logs &lt;container_id&gt;                    <span class="hljs-comment"># 查看全部日志</span><br>docker logs --<span class="hljs-built_in">tail</span> 100 &lt;container_id&gt;         <span class="hljs-comment"># 查看最后100行</span><br>docker logs -f &lt;container_id&gt;                 <span class="hljs-comment"># 实时跟踪日志</span><br>docker logs -t &lt;container_id&gt;                 <span class="hljs-comment"># 显示时间戳</span><br>docker logs --since 10m &lt;container_id&gt;        <span class="hljs-comment"># 查看最近10分钟</span><br>docker logs --since 2024-01-01T00:00:00 --<span class="hljs-keyword">until</span> 2024-01-02T00:00:00 &lt;container_id&gt;<br></code></pre></td></tr></table></figure>
<h2 id="调试命令">调试命令</h2>
<h3 id="docker-inspect">docker inspect</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看容器/镜像详细信息</span><br>docker inspect &lt;container_id&gt;<br><br><span class="hljs-comment"># 使用 -f 模板语法提取特定信息</span><br>docker inspect -f <span class="hljs-string">&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27;</span> &lt;container_id&gt;<br>docker inspect -f <span class="hljs-string">&#x27;&#123;&#123;.State.Status&#125;&#125;&#x27;</span> &lt;container_id&gt;<br></code></pre></td></tr></table></figure>
<p><code>docker inspect</code> 既可以查看容器，也可以查看镜像。</p>
<h3 id="docker-stats">docker stats</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker stats              <span class="hljs-comment"># 查看所有容器的资源使用</span><br>docker stats --no-stream  <span class="hljs-comment"># 只显示一次</span><br></code></pre></td></tr></table></figure>
<h3 id="docker-top-docker-cp-docker-port-docker-diff">docker top / docker cp / docker port / docker diff</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker top &lt;container_id&gt;                                    <span class="hljs-comment"># 容器内进程</span><br>docker <span class="hljs-built_in">cp</span> &lt;container_id&gt;:/path/to/file /host/path            <span class="hljs-comment"># 从容器复制到宿主机</span><br>docker <span class="hljs-built_in">cp</span> /host/path &lt;container_id&gt;:/container/path          <span class="hljs-comment"># 从宿主机复制到容器</span><br>docker port &lt;container_id&gt;                                   <span class="hljs-comment"># 端口映射</span><br>docker diff &lt;container_id&gt;                                   <span class="hljs-comment"># 文件系统变更（A=添加/D=删除/C=修改）</span><br></code></pre></td></tr></table></figure>
<h2 id="高级调试">高级调试</h2>
<h3 id="strace-调试">strace 调试</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --security-opt seccomp:unconfined --cap-add=SYS_PTRACE myimage /bin/bash<br></code></pre></td></tr></table></figure>
<h3 id="进入容器网络命名空间">进入容器网络命名空间</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run -it --net=container:&lt;container_id&gt; --pid=container:&lt;container_id&gt; --privileged ubuntu bash<br></code></pre></td></tr></table></figure>
<h3 id="docker-events">docker events</h3>
<p>实时查看 Docker 事件流：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker events<br>docker events --since 10m<br>docker events --filter <span class="hljs-string">&#x27;event=stop&#x27;</span><br></code></pre></td></tr></table></figure>
<h3 id="docker-system-df">docker system df</h3>
<p>查看 Docker 使用的磁盘空间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker system <span class="hljs-built_in">df</span><br>docker system <span class="hljs-built_in">df</span> -v<br></code></pre></td></tr></table></figure>
<hr>
<h1>第10章：系统维护与清理</h1>
<p>随着 Docker 的使用，系统会积累大量未使用的镜像、容器、网络和卷，占用大量磁盘空间。</p>
<h2 id="全面清理">全面清理</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 清理所有未使用的资源（包括镜像和卷）</span><br>docker system prune -a --volumes<br><br><span class="hljs-comment"># 强制清理（不询问确认）</span><br>docker system prune -a --volumes -f<br></code></pre></td></tr></table></figure>
<h2 id="分类清理">分类清理</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 镜像</span><br>docker image prune -a<br><br><span class="hljs-comment"># 容器</span><br>docker container prune<br>docker <span class="hljs-built_in">rm</span> -f $(docker ps -a -q)<br><br><span class="hljs-comment"># 网络</span><br>docker network prune<br><br><span class="hljs-comment"># 卷</span><br>docker volume prune<br><br><span class="hljs-comment"># 删除容器时带 -v 删除关联数据卷</span><br>docker ps -aq | xargs docker <span class="hljs-built_in">rm</span> -f -v<br></code></pre></td></tr></table></figure>
<h2 id="系统信息">系统信息</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker info           <span class="hljs-comment"># Docker 系统信息</span><br>docker version        <span class="hljs-comment"># Docker 版本</span><br>docker system <span class="hljs-built_in">df</span>      <span class="hljs-comment"># 磁盘使用情况</span><br>docker system <span class="hljs-built_in">df</span> -v   <span class="hljs-comment"># 详细磁盘使用</span><br></code></pre></td></tr></table></figure>
<h2 id="磁盘空间排查思路">磁盘空间排查思路</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1. 查看总体使用情况</span><br>docker system <span class="hljs-built_in">df</span><br><br><span class="hljs-comment"># 2. 查找大的日志文件</span><br>find /var/lib/docker/containers -name <span class="hljs-string">&quot;*-json.log&quot;</span> -<span class="hljs-built_in">exec</span> <span class="hljs-built_in">ls</span> -lh &#123;&#125; \;<br><br><span class="hljs-comment"># 3. 查看镜像占用</span><br>docker images --format <span class="hljs-string">&quot;table &#123;&#123;.Repository&#125;&#125;\t&#123;&#123;.Tag&#125;&#125;\t&#123;&#123;.Size&#125;&#125;&quot;</span><br><br><span class="hljs-comment"># 4. 查看容器占用</span><br>docker ps -as<br></code></pre></td></tr></table></figure>
<h2 id="定期清理策略建议">定期清理策略建议</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># cleanup-docker.sh</span><br>docker container prune -f<br>docker network prune -f<br>docker image prune -f<br>docker builder prune -f<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Docker cleanup completed at <span class="hljs-subst">$(date)</span>&quot;</span><br></code></pre></td></tr></table></figure>
<p>配合 cron 定期执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 每天凌晨 2 点执行清理</span><br>0 2 * * * /path/to/cleanup-docker.sh &gt;&gt; /var/log/docker-cleanup.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure>
<h2 id="镜像瘦身实战">镜像瘦身实战</h2>
<p>镜像体积直接影响部署速度、存储成本和安全性。本节介绍实用的镜像瘦身工具和最佳实践。</p>
<h3 id="dive-工具">dive 工具</h3>
<p>dive 是一个分析 Docker 镜像每一层内容的工具，可以帮助发现镜像中的冗余文件和空间浪费。</p>
<h4 id="安装方式">安装方式</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># macOS</span><br>brew install dive<br><br><span class="hljs-comment"># Linux (Ubuntu/Debian)</span><br>wget https://github.com/wagoodman/dive/releases/latest/download/dive_0.12.0_linux_amd64.deb<br><span class="hljs-built_in">sudo</span> apt install ./dive_0.12.0_linux_amd64.deb<br><br><span class="hljs-comment"># Go 安装</span><br>go install github.com/wagoodman/dive@latest<br><br><span class="hljs-comment"># Docker 方式</span><br>docker run --<span class="hljs-built_in">rm</span> -it -v /var/run/docker.sock:/var/run/docker.cfg wagoodman/dive:latest &lt;image&gt;<br></code></pre></td></tr></table></figure>
<h4 id="基本使用">基本使用</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 分析镜像</span><br>dive &lt;image&gt;<br><br><span class="hljs-comment"># 分析 tar 包</span><br>dive &lt;tar-file&gt;<br></code></pre></td></tr></table></figure>
<p>dive 会显示左右两个面板：</p>
<ul>
<li><strong>左侧</strong>：镜像的每一层文件系统</li>
<li><strong>右侧</strong>：当前层与上一层的差异（新增/删除/修改的文件）</li>
</ul>
<h4 id="ci-集成">CI 集成</h4>
<p>在 CI/CD 流程中，dive 可以作为质量门禁：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># CI 模式：如果镜像效率低于阈值则返回非零退出码</span><br>dive --ci &lt;image&gt;<br><br><span class="hljs-comment"># 设置最低效率分数（0-100）</span><br>dive --ci --threshold=0.9 &lt;image&gt;<br><br><span class="hljs-comment"># 仅显示效率评分</span><br>dive --ci &lt;image&gt;<br></code></pre></td></tr></table></figure>
<h4 id="效率评分指标">效率评分指标</h4>
<p>dive 会计算 <strong>Image Efficiency Score</strong>（0-100），评分标准包括：</p>
<ul>
<li><strong>浪费空间</strong>：删除但仍在镜像中的文件</li>
<li><strong>重复文件</strong>：在多层中重复出现的文件</li>
<li><strong>未使用的文件</strong>：镜像中存在但未被使用的内容</li>
</ul>
<p>理想情况下，效率评分应达到 90% 以上。</p>
<h3 id="基础镜像大小对比">基础镜像大小对比</h3>
<p>选择合适的基础镜像是瘦身的第一步：</p>
<table>
<thead>
<tr>
<th>基础镜像</th>
<th>大小</th>
<th>包含内容</th>
<th>适用场景</th>
<th>安全性</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>scratch</strong></td>
<td>~0 MB</td>
<td>空镜像，无文件系统</td>
<td>Go/Rust 等静态编译语言</td>
<td>最高（无攻击面）</td>
</tr>
<tr>
<td><strong>distroless</strong></td>
<td>~50-150 MB</td>
<td>最小化运行时，无 shell</td>
<td>Java/Node.js/Python 生产环境</td>
<td>高（无调试工具）</td>
</tr>
<tr>
<td><strong>alpine</strong></td>
<td>~5-10 MB</td>
<td>BusyBox + musl libc</td>
<td>需要包管理器的场景</td>
<td>中等（历史漏洞较多）</td>
</tr>
<tr>
<td><strong>slim</strong></td>
<td>~100-200 MB</td>
<td>精简版发行版（debian-slim、python-slim）</td>
<td>Python/Node.js 开发</td>
<td>中等</td>
</tr>
<tr>
<td><strong>full</strong></td>
<td>~500 MB+</td>
<td>完整发行版（ubuntu、debian）</td>
<td>调试、开发环境</td>
<td>低（攻击面大）</td>
</tr>
</tbody>
</table>
<h3 id="scratch-基础镜像">scratch 基础镜像</h3>
<p>scratch 是 Docker 提供的空镜像，完全不包含任何文件系统。适用于 Go、Rust 等可以静态编译的语言。</p>
<h4 id="go-应用示例">Go 应用示例</h4>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 多阶段构建</span><br><span class="hljs-keyword">FROM</span> golang:<span class="hljs-number">1.21</span>-alpine AS builder<br><br><span class="hljs-comment"># 禁用 CGO 以生成静态二进制文件</span><br><span class="hljs-keyword">ENV</span> CGO_ENABLED=<span class="hljs-number">0</span><br><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 复制依赖文件</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> go.mod go.sum ./</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go mod download</span><br><br><span class="hljs-comment"># 复制源代码并构建</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> go build -ldflags=<span class="hljs-string">&quot;-s -w&quot;</span> -o myapp .</span><br><br><span class="hljs-comment"># 使用 scratch 作为最终镜像</span><br><span class="hljs-keyword">FROM</span> scratch<br><br><span class="hljs-comment"># 复制二进制文件（从 builder 阶段）</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /app/myapp /myapp</span><br><br><span class="hljs-comment"># 复制 CA 证书（如果需要 HTTPS）</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /etc/ssl/certs/ca-certificates.crt /etc/ssl/certs/</span><br><br><span class="hljs-comment"># 设置非 root 用户（scratch 中没有用户，仅推荐做法）</span><br><span class="hljs-keyword">USER</span> <span class="hljs-number">65534</span>:<span class="hljs-number">65534</span><br><br><span class="hljs-comment"># 暴露端口</span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><br><span class="hljs-comment"># 运行应用</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;/myapp&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<p><strong>关键点</strong>：</p>
<ul>
<li><code>CGO_ENABLED=0</code> 确保生成静态二进制文件</li>
<li><code>-ldflags=&quot;-s -w&quot;</code> 去除调试信息，进一步减小体积</li>
<li>复制 CA 证书以支持 HTTPS 请求</li>
</ul>
<h3 id="distroless-镜像">distroless 镜像</h3>
<p>Google 提供的 distroless 镜像只包含应用程序及其运行时依赖，不包含 shell、包管理器、调试工具等。</p>
<h4 id="java-应用示例">Java 应用示例</h4>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> maven:<span class="hljs-number">3.9</span>-eclipse-temurin-<span class="hljs-number">17</span> AS builder<br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> pom.xml .</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> mvn dependency:go-offline</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> src ./src</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> mvn clean package -DskipTests</span><br><br><span class="hljs-comment"># 使用 distroless Java 运行时</span><br><span class="hljs-keyword">FROM</span> gcr.io/distroless/java17-debian12<br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /app/target/myapp.jar /app/myapp.jar</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">8080</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/app/myapp.jar&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<h4 id="node-js-应用示例">Node.js 应用示例</h4>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine AS builder<br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> package*.json ./</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm ci --only=production</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm run build</span><br><br><span class="hljs-comment"># 使用 distroless Node.js 运行时</span><br><span class="hljs-keyword">FROM</span> gcr.io/distroless/nodejs18-debian12<br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /app/dist /app/dist</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /app/node_modules /app/node_modules</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;/app/dist/index.js&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<h4 id="调试-distroless-镜像">调试 distroless 镜像</h4>
<p>由于 distroless 不包含 shell，无法使用 <code>docker exec</code> 进入容器。调试方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 :debug 标签的镜像（包含 busybox shell）</span><br>FROM gcr.io/distroless/java17-debian12:debug<br><br><span class="hljs-comment"># 临时覆盖镜像进行调试</span><br>kubectl run debug-shell --image=gcr.io/distroless/java17-debian12:debug -it -- sh<br></code></pre></td></tr></table></figure>
<h3 id="镜像瘦身检查清单">镜像瘦身检查清单</h3>
<p>以下最佳实践可以显著减小镜像体积：</p>
<ul>
<li>[ ] <strong>使用多阶段构建</strong>：分离构建环境和运行环境，只保留最终产物</li>
<li>[ ] <strong>合并 RUN 指令</strong>：减少镜像层数，使用 <code>&amp;&amp;</code> 连接多个命令</li>
<li>[ ] <strong>清理包管理器缓存</strong>：在 <code>apt-get</code>/<code>yum</code> 后执行清理命令</li>
<li>[ ] <strong>使用 alpine 或 distroless</strong>：选择最小化基础镜像</li>
<li>[ ] <strong>添加 .dockerignore</strong>：排除不需要的文件（node_modules、.git 等）</li>
<li>[ ] <strong>移除调试工具</strong>：生产环境不包含 gcc、gdb 等工具</li>
<li>[ ] <strong>使用 --no-install-recommends</strong>：避免安装推荐依赖</li>
<li>[ ] <strong>固定版本标签</strong>：使用具体版本而非 latest</li>
<li>[ ] <strong>使用 .dockerignore</strong>：排除构建上下文中的不必要文件</li>
<li>[ ] <strong>清理构建缓存</strong>：使用 <code>--no-cache</code> 或 <code>--build-arg</code> 清理缓存</li>
</ul>
<h4 id="完整示例">完整示例</h4>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># .dockerignore</span><br>node_modules<br>npm-debug.log<br>.git<br>.gitignore<br>README.md<br>.<span class="hljs-keyword">env</span><br></code></pre></td></tr></table></figure>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine AS builder<br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 先复制依赖文件，利用缓存</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> package*.json ./</span><br><br><span class="hljs-comment"># 使用 --no-cache 和 --prefer-offline 优化</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm ci --only=production --prefer-offline</span><br><br><span class="hljs-keyword">COPY</span><span class="language-bash"> . .</span><br><br><span class="hljs-comment"># 构建应用</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> npm run build</span><br><br><span class="hljs-comment"># 生产镜像</span><br><span class="hljs-keyword">FROM</span> gcr.io/distroless/nodejs18-debian12<br><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><br><span class="hljs-comment"># 只复制必要文件</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /app/dist ./dist</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /app/node_modules ./node_modules</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --from=builder /app/package.json ./package.json</span><br><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">3000</span><br><br><span class="hljs-comment"># 使用数组语法避免 shell 包装</span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;dist/index.js&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<hr>
<h1>第11章：Label 与资源管理</h1>
<p>Label 是键值对形式的 metadata，贯穿于 Docker 各个资源，包括引擎、镜像、容器、卷、网络、Swarm 节点、服务等。类似 consul 的标签。</p>
<h2 id="label-的命名规范">Label 的命名规范</h2>
<h3 id="键格式">键格式</h3>
<p>只可以包含字母和数字，以及 <code>.</code>、<code>-</code>。推荐使用类似于 Java 那种反向域名格式：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.example</span><span class="hljs-selector-class">.mytag</span><br>org<span class="hljs-selector-class">.myproject</span>.owner<br></code></pre></td></tr></table></figure>
<h3 id="值格式">值格式</h3>
<p>必须是字符串，除了普通字符串外，还可以是 JSON、XML、CSV 或者 YAML（需要先进行序列化）。</p>
<h2 id="label-vs-tag">Label vs Tag</h2>
<ul>
<li><strong>Tag</strong> 代表版本</li>
<li><strong>Label</strong> 代表属性</li>
</ul>
<p>当资源很少的时候，我们可以直接对一个个资源进行操作。但在管理很多资源的时候，经常需要针对某一类的资源进行操作，这种情况下会使用 Label 来帮助实现。</p>
<h2 id="label-的过滤用法">Label 的过滤用法</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查找特定 label 的容器</span><br>docker ps --filter <span class="hljs-string">&quot;label=environment=production&quot;</span><br><br><span class="hljs-comment"># 查找特定 label 的镜像</span><br>docker images --filter <span class="hljs-string">&quot;label=com.example.version=1.0.0&quot;</span><br><br><span class="hljs-comment"># 查找特定 label 的卷</span><br>docker volume <span class="hljs-built_in">ls</span> --filter <span class="hljs-string">&quot;label=com.example.backup=daily&quot;</span><br><br><span class="hljs-comment"># 组合过滤</span><br>docker ps --filter <span class="hljs-string">&quot;label=environment=production&quot;</span> --filter <span class="hljs-string">&quot;label=owner=team-a&quot;</span><br></code></pre></td></tr></table></figure>
<h2 id="在-dockerfile-中使用-label-指令">在 Dockerfile 中使用 LABEL 指令</h2>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> maintainer=<span class="hljs-string">&quot;team@example.com&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> version=<span class="hljs-string">&quot;1.0.0&quot;</span> \</span><br><span class="language-bash">      description=<span class="hljs-string">&quot;My Application&quot;</span> \</span><br><span class="language-bash">      vendor=<span class="hljs-string">&quot;Example Company&quot;</span></span><br></code></pre></td></tr></table></figure>
<h2 id="oci-标准-label-约定">OCI 标准 Label 约定</h2>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.created=<span class="hljs-string">&quot;2024-01-01T00:00:00Z&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.authors=<span class="hljs-string">&quot;team@example.com&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.source=<span class="hljs-string">&quot;https://github.com/example/myapp&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.version=<span class="hljs-string">&quot;1.0.0&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.title=<span class="hljs-string">&quot;My Application&quot;</span></span><br><span class="hljs-keyword">LABEL</span><span class="language-bash"> org.opencontainers.image.description=<span class="hljs-string">&quot;My awesome application&quot;</span></span><br></code></pre></td></tr></table></figure>
<h2 id="自动化管理示例">自动化管理示例</h2>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在构建时自动添加 label</span><br>docker build \<br>  --label <span class="hljs-string">&quot;org.opencontainers.image.created=<span class="hljs-subst">$(date -u +&#x27;%Y-%m-%dT%H:%M:%SZ&#x27;)</span>&quot;</span> \<br>  --label <span class="hljs-string">&quot;org.opencontainers.image.revision=<span class="hljs-subst">$(git rev-parse HEAD)</span>&quot;</span> \<br>  -t myapp:<span class="hljs-variable">$&#123;VERSION&#125;</span> .<br><br><span class="hljs-comment"># 停止所有开发环境的容器</span><br>docker stop $(docker ps -q --filter <span class="hljs-string">&quot;label=environment=development&quot;</span>)<br><br><span class="hljs-comment"># 自动备份带有特定 label 的卷</span><br><span class="hljs-keyword">for</span> volume <span class="hljs-keyword">in</span> $(docker volume <span class="hljs-built_in">ls</span> -q --filter <span class="hljs-string">&quot;label=com.example.backup=daily&quot;</span>); <span class="hljs-keyword">do</span><br>    docker run --<span class="hljs-built_in">rm</span> -v <span class="hljs-variable">$volume</span>:/data -v $(<span class="hljs-built_in">pwd</span>):/backup alpine \<br>    tar czf /backup/<span class="hljs-variable">$volume</span>-$(<span class="hljs-built_in">date</span> +%Y%m%d).tar.gz /data<br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>
<hr>
<h1>第12章：Docker 安全</h1>
<p>容器安全是生产环境部署的关键环节。本章将深入介绍 Docker 的安全机制和最佳实践。</p>
<h2 id="容器安全的核心原则">容器安全的核心原则</h2>
<p>容器安全应遵循以下四个核心原则：</p>
<ul>
<li><strong>最小权限原则</strong>：只赋予容器运行所需的最小权限，避免使用 root 或过度 capabilities</li>
<li><strong>最小攻击面</strong>：减少容器内安装的软件包，使用精简的基础镜像</li>
<li><strong>纵深防御</strong>：多层安全防护，包括镜像扫描、运行时限制、网络隔离等</li>
<li><strong>不可变基础设施</strong>：容器一旦部署不应修改，需要更新时替换新容器</li>
</ul>
<h2 id="非-root-运行">非 root 运行</h2>
<p>默认情况下，Docker 容器以 root 用户运行，这带来严重的安全风险。应尽可能使用非 root 用户运行容器。</p>
<h3 id="dockerfile-中的-user-指令">Dockerfile 中的 USER 指令</h3>
<p>在 Dockerfile 中使用 <code>USER</code> 指令指定运行用户：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine<br><span class="hljs-comment"># 创建非 root 用户</span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> addgroup -g 1001 -S nodejs &amp;&amp; \</span><br><span class="language-bash">    adduser -S nodejs -u 1001</span><br><span class="hljs-comment"># 设置工作目录</span><br><span class="hljs-keyword">WORKDIR</span><span class="language-bash"> /app</span><br><span class="hljs-comment"># 复制文件并设置权限</span><br><span class="hljs-keyword">COPY</span><span class="language-bash"> --<span class="hljs-built_in">chown</span>=nodejs:nodejs . .</span><br><span class="hljs-comment"># 切换到非 root 用户</span><br><span class="hljs-keyword">USER</span> nodejs<br><span class="hljs-keyword">CMD</span><span class="language-bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;app.js&quot;</span>]</span><br></code></pre></td></tr></table></figure>
<h3 id="docker-run-user-参数">docker run --user 参数</h3>
<p>在运行时指定用户：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 UID:GID 运行</span><br>docker run --user 1000:1000 nginx:alpine<br><br><span class="hljs-comment"># 使用用户名运行（需要在镜像中存在）</span><br>docker run --user nodejs myapp:latest<br></code></pre></td></tr></table></figure>
<h3 id="rootless-docker-模式">Rootless Docker 模式</h3>
<p>Rootless Docker 允许非 root 用户运行 Docker 守护进程，无需 sudo 权限。</p>
<h4 id="安装配置方式">安装配置方式</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 rootless 软件包</span><br>curl -fsSL https://get.docker.com/rootless | sh<br><br><span class="hljs-comment"># 配置环境变量（添加到 ~/.bashrc 或 ~/.zshrc）</span><br><span class="hljs-built_in">export</span> PATH=/home/<span class="hljs-variable">$USER</span>/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">export</span> DOCKER_HOST=unix:///run/user/$(<span class="hljs-built_in">id</span> -u)/docker.sock<br><br><span class="hljs-comment"># 启动 dockerd</span><br>systemctl --user start docker<br>systemctl --user <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure>
<h4 id="工作原理">工作原理</h4>
<p>Rootless Docker 使用以下技术实现隔离：</p>
<ul>
<li><strong>User Namespace Remapping</strong>：容器内的 root 映射为宿主机的非 root 用户</li>
<li><strong>cgroup v2</strong>：用户级别的资源控制</li>
<li><strong>fuse-overlayfs</strong>：支持 overlay 存储驱动</li>
</ul>
<h4 id="限制">限制</h4>
<p>Rootless Docker 有以下限制：</p>
<ul>
<li>不能绑定 1024 以下的端口（需要使用反向代理或 <code>setcap</code>）</li>
<li>部分存储驱动不支持（不支持 aufs、btrfs）</li>
<li>不支持 AppArmor、SELinux（依赖用户命名空间隔离）</li>
</ul>
<h2 id="能力管理-linux-capabilities">能力管理（Linux Capabilities）</h2>
<p>Linux Capabilities 将 root 权限细分为多个独立的能力，Docker 默认会丢弃部分危险 capabilities，但仍保留一些必要能力。</p>
<h3 id="docker-默认赋予的-capabilities-列表">Docker 默认赋予的 capabilities 列表</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看容器默认 capabilities</span><br>docker run --<span class="hljs-built_in">rm</span> alpine capsh --<span class="hljs-built_in">print</span><br></code></pre></td></tr></table></figure>
<p>Docker 默认赋予以下 capabilities：</p>
<ul>
<li><code>CAP_CHOWN</code>：修改文件所有者</li>
<li><code>CAP_DAC_OVERRIDE</code>：绕过文件权限检查</li>
<li><code>CAP_FSETID</code>：设置 setuid/setgid 位</li>
<li><code>CAP_FOWNER</code>：绕过文件所有者检查</li>
<li><code>CAP_MKNOD</code>：创建设备文件</li>
<li><code>CAP_NET_RAW</code>：使用 raw socket</li>
<li><code>CAP_SETGID</code>：设置组 ID</li>
<li><code>CAP_SETUID</code>：设置用户 ID</li>
<li><code>CAP_SETFCAP</code>：设置文件 capabilities</li>
<li><code>CAP_SETPCAP</code>：修改进程 capabilities</li>
<li><code>CAP_NET_BIND_SERVICE</code>：绑定 1024 以下端口</li>
<li><code>CAP_SYS_CHROOT</code>：使用 chroot</li>
<li><code>CAP_KILL</code>：发送信号给任意进程</li>
<li><code>CAP_AUDIT_WRITE</code>：写入审计日志</li>
</ul>
<h3 id="cap-drop-all-cap-add-最小权限模式">–cap-drop ALL + --cap-add 最小权限模式</h3>
<p>最佳实践是先丢弃所有 capabilities，然后只添加必要的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 丢弃所有 capabilities，只添加绑定端口的能力</span><br>docker run --cap-drop ALL --cap-add NET_BIND_SERVICE nginx:alpine<br><br><span class="hljs-comment"># 丢弃所有 capabilities，完全无特权运行</span><br>docker run --cap-drop ALL myapp:latest<br></code></pre></td></tr></table></figure>
<h3 id="常用-capabilities-说明表格">常用 capabilities 说明表格</h3>
<table>
<thead>
<tr>
<th>Capability</th>
<th>说明</th>
<th>典型用途</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>NET_BIND_SERVICE</code></td>
<td>绑定 1024 以下端口</td>
<td>Web 服务器</td>
</tr>
<tr>
<td><code>NET_RAW</code></td>
<td>使用 raw socket</td>
<td>ping、traceroute</td>
</tr>
<tr>
<td><code>SYS_PTRACE</code></td>
<td>使用 ptrace 调试</td>
<td>调试工具</td>
</tr>
<tr>
<td><code>CHOWN</code></td>
<td>修改文件所有者</td>
<td>文件管理</td>
</tr>
<tr>
<td><code>DAC_OVERRIDE</code></td>
<td>绕过文件权限检查</td>
<td>需要访问任意文件</td>
</tr>
<tr>
<td><code>SYS_ADMIN</code></td>
<td>系统管理权限（危险）</td>
<td>挂载文件系统</td>
</tr>
<tr>
<td><code>SYS_TIME</code></td>
<td>修改系统时间</td>
<td>时间同步</td>
</tr>
</tbody>
</table>
<h2 id="seccomp-配置文件">Seccomp 配置文件</h2>
<p>Seccomp（Secure Computing Mode）限制容器可以调用的系统调用，是内核级别的安全机制。</p>
<h3 id="默认-seccomp-profile-的作用">默认 seccomp profile 的作用</h3>
<p>Docker 默认启用 seccomp profile，禁止约 44 个危险系统调用，包括：</p>
<ul>
<li><code>kexec_load</code>：加载新内核</li>
<li><code>swapon</code>：启用 swap</li>
<li><code>swapoff</code>：禁用 swap</li>
<li><code>reboot</code>：重启系统</li>
<li><code>init_module</code>：加载内核模块</li>
<li><code>delete_module</code>：删除内核模块</li>
</ul>
<h3 id="自定义-seccomp-profile-的使用方式">自定义 seccomp profile 的使用方式</h3>
<p>创建自定义 seccomp profile（JSON 格式）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;defaultAction&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SCMP_ACT_ERRNO&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;syscalls&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;chmod&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SCMP_ACT_ALLOW&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-punctuation">&#123;</span><br>      <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;chown&quot;</span><span class="hljs-punctuation">,</span><br>      <span class="hljs-attr">&quot;action&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;SCMP_ACT_ALLOW&quot;</span><br>    <span class="hljs-punctuation">&#125;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>使用自定义 profile：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --security-opt seccomp=/path/to/profile.json myapp:latest<br></code></pre></td></tr></table></figure>
<h3 id="security-opt-seccomp-unconfined-的风险">–security-opt seccomp=unconfined 的风险</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 禁用 seccomp 限制（不推荐）</span><br>docker run --security-opt seccomp=unconfined myapp:latest<br></code></pre></td></tr></table></figure>
<p>禁用 seccomp 会使容器可以调用所有系统调用，严重降低安全性。</p>
<h2 id="apparmor-selinux">AppArmor / SELinux</h2>
<p>AppArmor（Ubuntu/Debian）和 SELinux（RHEL/CentOS）是强制访问控制系统，限制程序的访问权限。</p>
<h3 id="docker-默认的-apparmor-profile">Docker 默认的 AppArmor profile</h3>
<p>Docker 默认使用 <code>docker-default</code> AppArmor profile：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看容器使用的 AppArmor profile</span><br>docker inspect --format=<span class="hljs-string">&#x27;&#123;&#123;.HostConfig.AppArmorProfile&#125;&#125;&#x27;</span> &lt;container_id&gt;<br></code></pre></td></tr></table></figure>
<h3 id="自定义-profile-的加载方式">自定义 profile 的加载方式</h3>
<p>创建自定义 AppArmor profile：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建 profile 文件</span><br><span class="hljs-built_in">cat</span> &gt; /etc/apparmor.d/docker-myapp &lt;&lt;<span class="hljs-string">EOF</span><br><span class="hljs-string">#include &lt;tunables/global&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">profile docker-myapp flags=(attach_disconnected,mediate_deleted) &#123;</span><br><span class="hljs-string">  #include &lt;abstractions/base&gt;</span><br><span class="hljs-string">  </span><br><span class="hljs-string">  deny /proc/** w,</span><br><span class="hljs-string">  deny /sys/** w,</span><br><span class="hljs-string">  </span><br><span class="hljs-string">  /app/** r,</span><br><span class="hljs-string">  /tmp/** rw,</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">EOF</span><br><br><span class="hljs-comment"># 加载 profile</span><br><span class="hljs-built_in">sudo</span> apparmor_parser -r /etc/apparmor.d/docker-myapp<br><br><span class="hljs-comment"># 使用 profile 运行容器</span><br>docker run --security-opt apparmor=docker-myapp myapp:latest<br></code></pre></td></tr></table></figure>
<h3 id="selinux-标签-z-和-z">SELinux 标签（:z 和 :Z）</h3>
<p>在 SELinux 系统上，使用 <code>:z</code> 和 <code>:Z</code> 标签自动设置正确的 SELinux 上下文：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># :z - 共享标签（多个容器可共享挂载点）</span><br>docker run -v /host/data:/container/data:z myapp:latest<br><br><span class="hljs-comment"># :Z - 私有标签（每个容器有独立标签）</span><br>docker run -v /host/data:/container/data:Z myapp:latest<br></code></pre></td></tr></table></figure>
<h2 id="只读文件系统">只读文件系统</h2>
<p>将容器文件系统设置为只读，防止运行时修改，提高安全性。</p>
<h3 id="read-only-标志">–read-only 标志</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --read-only nginx:alpine<br></code></pre></td></tr></table></figure>
<h3 id="配合-tmpfs-挂载可写目录">配合 tmpfs 挂载可写目录</h3>
<p>只读文件系统会导致某些应用无法运行（需要写入临时文件），应配合 tmpfs 使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker run --read-only \<br>  --tmpfs /tmp \<br>  --tmpfs /run \<br>  --tmpfs /var/cache/nginx \<br>  nginx:alpine<br></code></pre></td></tr></table></figure>
<h3 id="完整的命令示例">完整的命令示例</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 运行只读容器，挂载必要的可写目录</span><br>docker run -d \<br>  --name myapp \<br>  --read-only \<br>  --tmpfs /tmp \<br>  --tmpfs /var/run \<br>  --tmpfs /app/cache \<br>  -p 8080:80 \<br>  myapp:latest<br></code></pre></td></tr></table></figure>
<h2 id="镜像安全扫描">镜像安全扫描</h2>
<p>镜像安全扫描工具可以发现镜像中的已知漏洞（CVE）。</p>
<h3 id="docker-scout-docker-官方">docker scout（Docker 官方）</h3>
<p>Docker Scout 是 Docker 官方提供的镜像扫描工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 扫描本地镜像</span><br>docker scout quickscan nginx:alpine<br><br><span class="hljs-comment"># 扫描远程镜像</span><br>docker scout quickscan nginx:latest<br><br><span class="hljs-comment"># 查看漏洞详情</span><br>docker scout cves nginx:alpine<br><br><span class="hljs-comment"># CI/CD 中使用（遇到漏洞时失败）</span><br>docker scout quickscan --exit-code nginx:alpine<br></code></pre></td></tr></table></figure>
<h3 id="trivy-aqua-security">Trivy（Aqua Security）</h3>
<p>Trivy 是开源的全栈安全扫描工具：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 Trivy</span><br>brew install trivy  <span class="hljs-comment"># macOS</span><br><span class="hljs-comment"># 或</span><br>wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | <span class="hljs-built_in">sudo</span> apt-key add -<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deb https://aquasecurity.github.io/trivy-repo/deb <span class="hljs-subst">$(lsb_release -sc)</span> main&quot;</span> | <span class="hljs-built_in">sudo</span> <span class="hljs-built_in">tee</span> -a /etc/apt/sources.list.d/trivy.list<br><span class="hljs-built_in">sudo</span> apt-get update<br><span class="hljs-built_in">sudo</span> apt-get install trivy<br><br><span class="hljs-comment"># 扫描镜像</span><br>trivy image nginx:alpine<br><br><span class="hljs-comment"># 扫描文件系统</span><br>trivy fs /path/to/project<br><br><span class="hljs-comment"># 扫描配置文件</span><br>trivy config .<br><br><span class="hljs-comment"># 只显示高危漏洞</span><br>trivy image --severity HIGH,CRITICAL nginx:alpine<br><br><span class="hljs-comment"># 输出 JSON 格式</span><br>trivy image --format json --output report.json nginx:alpine<br></code></pre></td></tr></table></figure>
<h3 id="snyk-container">Snyk Container</h3>
<p>Snyk 提供商业级的容器安全扫描：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 Snyk CLI</span><br>npm install -g snyk<br><br><span class="hljs-comment"># 认证</span><br>snyk auth<br><br><span class="hljs-comment"># 扫描镜像</span><br>snyk container <span class="hljs-built_in">test</span> nginx:alpine<br><br><span class="hljs-comment"># 监控镜像（持续扫描）</span><br>snyk container monitor nginx:alpine<br><br><span class="hljs-comment"># CI/CD 中使用（遇到漏洞时失败）</span><br>snyk container <span class="hljs-built_in">test</span> --severity-threshold=high nginx:alpine<br></code></pre></td></tr></table></figure>
<h3 id="ci-cd-集成建议">CI/CD 集成建议</h3>
<p>在 CI/CD 流程中集成镜像扫描：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># GitHub Actions 示例</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">Docker</span> <span class="hljs-string">Image</span> <span class="hljs-string">Scan</span><br><span class="hljs-attr">on:</span> [<span class="hljs-string">push</span>, <span class="hljs-string">pull_request</span>]<br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">scan:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v3</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">image</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">docker</span> <span class="hljs-string">build</span> <span class="hljs-string">-t</span> <span class="hljs-string">myapp:$&#123;&#123;</span> <span class="hljs-string">github.sha</span> <span class="hljs-string">&#125;&#125;</span> <span class="hljs-string">.</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Scan</span> <span class="hljs-string">with</span> <span class="hljs-string">Trivy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">aquasecurity/trivy-action@master</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">image-ref:</span> <span class="hljs-string">myapp:$&#123;&#123;</span> <span class="hljs-string">github.sha</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-attr">format:</span> <span class="hljs-string">&#x27;sarif&#x27;</span><br>          <span class="hljs-attr">output:</span> <span class="hljs-string">&#x27;trivy-results.sarif&#x27;</span><br>          <span class="hljs-attr">severity:</span> <span class="hljs-string">&#x27;HIGH,CRITICAL&#x27;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Upload</span> <span class="hljs-string">Trivy</span> <span class="hljs-string">results</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">github/codeql-action/upload-sarif@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">sarif_file:</span> <span class="hljs-string">&#x27;trivy-results.sarif&#x27;</span><br></code></pre></td></tr></table></figure>
<h2 id="docker-content-trust-dct">Docker Content Trust（DCT）</h2>
<p>Docker Content Trust 提供镜像签名和验证机制，确保镜像的完整性和来源可信。</p>
<h3 id="镜像签名和验证机制">镜像签名和验证机制</h3>
<p>DCT 使用数字签名技术，确保：</p>
<ul>
<li>镜像未被篡改</li>
<li>镜像来自可信的发布者</li>
<li>镜像的标签指向正确的镜像 ID</li>
</ul>
<h3 id="docker-content-trust-1-环境变量">DOCKER_CONTENT_TRUST=1 环境变量</h3>
<p>启用 Docker Content Trust：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启用 DCT</span><br><span class="hljs-built_in">export</span> DOCKER_CONTENT_TRUST=1<br><br><span class="hljs-comment"># 推送镜像时会自动签名</span><br>docker push myregistry.com/myapp:latest<br><br><span class="hljs-comment"># 拉取镜像时会自动验证签名</span><br>docker pull myregistry.com/myapp:latest<br></code></pre></td></tr></table></figure>
<h3 id="notary-的角色">Notary 的角色</h3>
<p>Notary 是 Docker 使用的签名和验证服务：</p>
<ul>
<li><strong>签名</strong>：将镜像的 digest 和签名存储到 Notary 服务器</li>
<li><strong>验证</strong>：拉取镜像时从 Notary 服务器获取签名并验证</li>
<li><strong>密钥管理</strong>：管理签名密钥（离线根密钥、在线标签密钥）</li>
</ul>
<h3 id="签名流程说明">签名流程说明</h3>
<ol>
<li><strong>生成密钥对</strong>：首次推送时自动生成签名密钥</li>
<li><strong>签名镜像</strong>：推送时使用私钥对镜像 digest 签名</li>
<li><strong>存储签名</strong>：签名存储到 Notary 服务器</li>
<li><strong>验证镜像</strong>：拉取时从 Notary 获取签名并验证</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 手动管理密钥</span><br>docker trust key generate myapp-key<br>docker trust signer add myapp-key myregistry.com/myapp<br><br><span class="hljs-comment"># 查看签名信息</span><br>docker trust inspect myregistry.com/myapp:latest<br><br><span class="hljs-comment"># 撤销签名</span><br>docker trust revoke myregistry.com/myapp:latest<br></code></pre></td></tr></table></figure>
<h2 id="网络安全">网络安全</h2>
<p>Docker 网络隔离是容器安全的重要组成部分。</p>
<h3 id="internal-网络-禁止外部访问">internal 网络（禁止外部访问）</h3>
<p>使用 <code>internal</code> 网络模式禁止容器访问外部网络：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">internal</span><br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:14</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">internal</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">internal:</span><br>    <span class="hljs-attr">internal:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 禁止访问外部网络</span><br></code></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 命令行创建 internal 网络</span><br>docker network create --driver bridge --internal my-internal-network<br>docker run --network my-internal-network myapp:latest<br></code></pre></td></tr></table></figure>
<h3 id="限制容器间通信-icc">限制容器间通信（ICC）</h3>
<p>默认情况下，同一网络内的容器可以互相通信。可以通过 <code>--icc=false</code> 禁止：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">// /etc/docker/daemon.json</span><br><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;icc&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>重启 Docker 后生效：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure>
<h3 id="使用自定义网络隔离">使用自定义网络隔离</h3>
<p>为不同服务创建独立的网络：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:alpine</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">frontend</span><br>  <br>  <span class="hljs-attr">app:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">myapp:latest</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">frontend</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span><br>  <br>  <span class="hljs-attr">db:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">postgres:14</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">backend</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">frontend:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br>  <span class="hljs-attr">backend:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br>    <span class="hljs-attr">internal:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 后端网络禁止外部访问</span><br></code></pre></td></tr></table></figure>
<h2 id="安全最佳实践检查清单">安全最佳实践检查清单</h2>
<p>以下是 Docker 安全的最佳实践检查清单：</p>
<ul>
<li>[ ] <strong>使用非 root 用户运行容器</strong>：在 Dockerfile 中使用 <code>USER</code> 指令或 <code>docker run --user</code></li>
<li>[ ] <strong>使用精简的基础镜像</strong>：优先使用 <code>alpine</code>、<code>distroless</code> 等精简镜像</li>
<li>[ ] <strong>最小化 capabilities</strong>：使用 <code>--cap-drop ALL --cap-add &lt;必需能力&gt;</code></li>
<li>[ ] <strong>启用 seccomp 限制</strong>：不使用 <code>--security-opt seccomp=unconfined</code></li>
<li>[ ] <strong>使用 AppArmor/SELinux</strong>：为关键应用配置强制访问控制</li>
<li>[ ] <strong>文件系统只读</strong>：使用 <code>--read-only</code> 配合 <code>--tmpfs</code> 挂载</li>
<li>[ ] <strong>扫描镜像漏洞</strong>：在 CI/CD 中集成 Trivy 或 docker scout</li>
<li>[ ] <strong>启用 Docker Content Trust</strong>：设置 <code>DOCKER_CONTENT_TRUST=1</code></li>
<li>[ ] <strong>网络隔离</strong>：使用自定义网络，避免使用默认 bridge 网络</li>
<li>[ ] <strong>定期更新镜像</strong>：及时更新基础镜像和依赖包</li>
<li>[ ] <strong>限制资源使用</strong>：设置 CPU 和内存限制，防止资源耗尽攻击</li>
<li>[ ] <strong>审计日志</strong>：启用 Docker 审计日志，监控异常行为</li>
</ul>
<hr>
<h1>第13章：镜像仓库与分发</h1>
<p>镜像仓库是 Docker 生态系统中不可或缺的一环，它负责镜像的存储、分发和管理。从公共的 Docker Hub 到企业级的私有 Registry，再到创新的 P2P 分发方案，本章将全面介绍镜像仓库的各种形态和最佳实践。</p>
<h2 id="镜像命名规范">镜像命名规范</h2>
<p>理解 Docker 镜像的命名规范是使用镜像仓库的基础。一个完整的镜像名称由多个部分组成：</p>
<h3 id="完整格式">完整格式</h3>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-string">[registry/]</span>[<span class="hljs-keyword">namespace</span>/]<span class="hljs-symbol">repository</span>[:<span class="hljs-symbol">tag</span>|@<span class="hljs-symbol">digest</span>]<br></code></pre></td></tr></table></figure>
<h3 id="各部分说明">各部分说明</h3>
<table>
<thead>
<tr>
<th>部分</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>registry</strong></td>
<td>镜像仓库地址，默认为 <a target="_blank" rel="noopener" href="http://docker.io">docker.io</a></td>
<td><code>docker.io</code>, <code>ghcr.io</code>, <code>registry.example.com:5000</code></td>
</tr>
<tr>
<td><strong>namespace</strong></td>
<td>命名空间/用户名，官方镜像为 library（可省略）</td>
<td><code>library</code>, <code>nginx</code>, <code>mycompany</code></td>
</tr>
<tr>
<td><strong>repository</strong></td>
<td>仓库名</td>
<td><code>nginx</code>, <code>python</code>, <code>myapp</code></td>
</tr>
<tr>
<td><strong>tag</strong></td>
<td>镜像标签，默认为 latest</td>
<td><code>latest</code>, <code>1.21.0</code>, <code>alpine</code>, <code>v2.0.0</code></td>
</tr>
<tr>
<td><strong>digest</strong></td>
<td>镜像内容的哈希值（SHA256）</td>
<td><code>sha256:abc123...</code></td>
</tr>
</tbody>
</table>
<h3 id="命名示例">命名示例</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 完整格式</span><br>docker.io/library/nginx:latest<br><br><span class="hljs-comment"># 省略 registry（默认 docker.io）</span><br>nginx:latest<br><br><span class="hljs-comment"># 省略 namespace（官方镜像）</span><br>nginx:1.21.0<br><br><span class="hljs-comment"># 私有仓库</span><br>registry.example.com:5000/mycompany/myapp:v2.0.0<br><br><span class="hljs-comment"># 使用 digest（精确版本）</span><br>nginx@sha256:abc123def456...<br><br><span class="hljs-comment"># 多个标签指向同一镜像</span><br>myapp:1.0.0<br>myapp:stable<br>myapp:latest<br></code></pre></td></tr></table></figure>
<h3 id="tag-vs-digest">Tag vs Digest</h3>
<ul>
<li><strong>Tag</strong>：可变的、易读的版本标识（如 <code>latest</code>, <code>v1.0</code>）</li>
<li><strong>Digest</strong>：不可变的、精确的内容哈希值</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看镜像的 digest</span><br>docker inspect nginx:1.21.0 | jq -r <span class="hljs-string">&#x27;.[0].RepoDigests&#x27;</span><br><br><span class="hljs-comment"># 使用 digest 拉取镜像（确保内容一致）</span><br>docker pull nginx@sha256:abc123def456...<br></code></pre></td></tr></table></figure>
<h2 id="docker-hub">Docker Hub</h2>
<p>Docker Hub 是 Docker 官方提供的公共镜像仓库，也是全球最大的 Docker 镜像分发平台。</p>
<h3 id="公共仓库与私有仓库">公共仓库与私有仓库</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>限制</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>公共仓库</strong></td>
<td>任何人都可以拉取的镜像</td>
<td>Rate Limiting 限制</td>
</tr>
<tr>
<td><strong>私有仓库</strong></td>
<td>只有授权用户可以访问的镜像</td>
<td>免费账户有限制，付费账户无限制</td>
</tr>
</tbody>
</table>
<h3 id="官方镜像与认证镜像">官方镜像与认证镜像</h3>
<h4 id="官方镜像-official-images">官方镜像（Official Images）</h4>
<p>由 Docker 官方或上游项目维护的镜像，具有以下特点：</p>
<ul>
<li>使用 <code>library</code> 命名空间（可省略）</li>
<li>经过安全扫描和最佳实践审查</li>
<li>提供多种变体（alpine、slim 等）</li>
<li>示例：<code>nginx</code>, <code>python</code>, <code>redis</code></li>
</ul>
<h4 id="认证镜像-verified-publisher">认证镜像（Verified Publisher）</h4>
<p>由经过 Docker 验证的组织发布的镜像：</p>
<ul>
<li>显示蓝色 ✓ 标记</li>
<li>保证来源可信</li>
<li>示例：<code>bitnami/nginx</code>, <code>redhat/ubi8</code></li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 搜索官方镜像</span><br>docker search --filter <span class="hljs-string">&quot;is-official=true&quot;</span> nginx<br><br><span class="hljs-comment"># 搜索认证镜像</span><br>docker search --filter <span class="hljs-string">&quot;is-automated=true&quot;</span> bitnami<br></code></pre></td></tr></table></figure>
<h3 id="自动构建-automated-builds">自动构建（Automated Builds）</h3>
<p>将 GitHub 或 GitLab 仓库与 Docker Hub 关联，代码推送后自动构建镜像：</p>
<p><strong>优点：</strong></p>
<ul>
<li>构建过程透明可审计</li>
<li>Dockerfile 与代码同一仓库管理</li>
<li>支持多个架构自动构建</li>
</ul>
<p><strong>配置步骤：</strong></p>
<ol>
<li>在 Docker Hub 创建 Automated Build</li>
<li>关联 GitHub/GitLab 仓库</li>
<li>指定 Dockerfile 路径和构建上下文</li>
<li>设置构建触发规则（分支、标签）</li>
</ol>
<h3 id="rate-limiting-策略">Rate Limiting 策略</h3>
<p>Docker Hub 对匿名用户和免费账户实施了速率限制：</p>
<table>
<thead>
<tr>
<th>用户类型</th>
<th>限制</th>
<th>窗口期</th>
</tr>
</thead>
<tbody>
<tr>
<td>匿名用户</td>
<td>100 次/6 小时</td>
<td>6 小时</td>
</tr>
<tr>
<td>免费账户</td>
<td>200 次/6 小时</td>
<td>6 小时</td>
</tr>
<tr>
<td>付费账户</td>
<td>无限制</td>
<td>-</td>
</tr>
</tbody>
</table>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看剩余配额</span><br>docker search nginx --<span class="hljs-built_in">limit</span> 1 | grep <span class="hljs-string">&quot;LIMIT&quot;</span><br><br><span class="hljs-comment"># 登录后提升配额</span><br>docker login<br><br><span class="hljs-comment"># 检查当前登录状态</span><br>docker info | grep <span class="hljs-string">&quot;Registry Mirrors&quot;</span><br></code></pre></td></tr></table></figure>
<h3 id="常用命令">常用命令</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 登录 Docker Hub</span><br>docker login<br><span class="hljs-comment"># 输入用户名和密码（或 access token）</span><br><br><span class="hljs-comment"># 推送镜像</span><br>docker tag myapp:1.0.0 username/myapp:1.0.0<br>docker push username/myapp:1.0.0<br><br><span class="hljs-comment"># 拉取镜像</span><br>docker pull nginx:latest<br>docker pull nginx@sha256:abc123...<br><br><span class="hljs-comment"># 搜索镜像</span><br>docker search nginx<br>docker search --filter <span class="hljs-string">&quot;stars=100&quot;</span> --filter <span class="hljs-string">&quot;is-official=true&quot;</span> python<br><br><span class="hljs-comment"># 退出登录</span><br>docker <span class="hljs-built_in">logout</span><br></code></pre></td></tr></table></figure>
<h2 id="私有-registry">私有 Registry</h2>
<p>企业内部通常需要部署私有镜像仓库，以满足安全、合规和性能要求。</p>
<h3 id="快速搭建-registry">快速搭建 Registry</h3>
<p>使用官方 <code>registry:2</code> 镜像快速部署：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 基础部署（HTTP，仅用于测试）</span><br>docker run -d \<br>  -p 5000:5000 \<br>  --name registry \<br>  -v /data/registry:/var/lib/registry \<br>  registry:2<br><br><span class="hljs-comment"># 推送镜像到私有仓库</span><br>docker tag myapp:1.0.0 localhost:5000/myapp:1.0.0<br>docker push localhost:5000/myapp:1.0.0<br><br><span class="hljs-comment"># 拉取镜像</span><br>docker pull localhost:5000/myapp:1.0.0<br></code></pre></td></tr></table></figure>
<h3 id="配置-tls-证书">配置 TLS 证书</h3>
<p>生产环境必须使用 HTTPS：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成自签名证书</span><br><span class="hljs-built_in">mkdir</span> -p /data/certs<br>openssl req -newkey rsa:4096 -nodes -sha256 \<br>  -keyout /data/certs/domain.key \<br>  -x509 -days 365 \<br>  -out /data/certs/domain.crt \<br>  -subj <span class="hljs-string">&quot;/CN=registry.example.com&quot;</span><br><br><span class="hljs-comment"># 使用 TLS 启动 Registry</span><br>docker run -d \<br>  -p 5000:5000 \<br>  --name registry \<br>  -v /data/certs:/certs \<br>  -v /data/registry:/var/lib/registry \<br>  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \<br>  -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \<br>  registry:2<br></code></pre></td></tr></table></figure>
<h3 id="配置基本认证">配置基本认证</h3>
<p>使用 <code>htpasswd</code> 实现用户认证：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 htpasswd 工具</span><br>apt-get install apache2-utils<br><br><span class="hljs-comment"># 创建用户和密码</span><br><span class="hljs-built_in">mkdir</span> -p /data/auth<br>htpasswd -Bbn user1 password1 &gt; /data/auth/htpasswd<br>htpasswd -Bbn user2 password2 &gt;&gt; /data/auth/htpasswd<br><br><span class="hljs-comment"># 启动带认证的 Registry</span><br>docker run -d \<br>  -p 5000:5000 \<br>  --name registry \<br>  -v /data/auth:/auth \<br>  -v /data/certs:/certs \<br>  -v /data/registry:/var/lib/registry \<br>  -e REGISTRY_AUTH=htpasswd \<br>  -e <span class="hljs-string">&quot;REGISTRY_AUTH_HTPASSWD_REALM=Registry Realm&quot;</span> \<br>  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd \<br>  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \<br>  -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \<br>  registry:2<br><br><span class="hljs-comment"># 登录私有仓库</span><br>docker login registry.example.com:5000<br></code></pre></td></tr></table></figure>
<h3 id="存储后端配置">存储后端配置</h3>
<p>Registry 支持多种存储后端：</p>
<h4 id="1-本地存储-默认">1. 本地存储（默认）</h4>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">storage:</span><br>  <span class="hljs-attr">filesystem:</span><br>    <span class="hljs-attr">rootdirectory:</span> <span class="hljs-string">/var/lib/registry</span><br></code></pre></td></tr></table></figure>
<h4 id="2-aws-s3">2. AWS S3</h4>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">storage:</span><br>  <span class="hljs-attr">s3:</span><br>    <span class="hljs-attr">accesskey:</span> <span class="hljs-string">AWS_ACCESS_KEY</span><br>    <span class="hljs-attr">secretkey:</span> <span class="hljs-string">AWS_SECRET_KEY</span><br>    <span class="hljs-attr">region:</span> <span class="hljs-string">us-west-2</span><br>    <span class="hljs-attr">bucket:</span> <span class="hljs-string">my-registry-bucket</span><br>    <span class="hljs-attr">regionendpoint:</span> <span class="hljs-string">https://s3.example.com</span><br>    <span class="hljs-attr">encrypt:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">secure:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">v4auth:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">chunksize:</span> <span class="hljs-number">5242880</span><br></code></pre></td></tr></table></figure>
<h4 id="3-azure-blob-storage">3. Azure Blob Storage</h4>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">storage:</span><br>  <span class="hljs-attr">azure:</span><br>    <span class="hljs-attr">accountname:</span> <span class="hljs-string">accountname</span><br>    <span class="hljs-attr">accountkey:</span> <span class="hljs-string">base64encodedaccountkey</span><br>    <span class="hljs-attr">container:</span> <span class="hljs-string">containername</span><br></code></pre></td></tr></table></figure>
<h4 id="4-google-cloud-storage">4. Google Cloud Storage</h4>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">storage:</span><br>  <span class="hljs-attr">gcs:</span><br>    <span class="hljs-attr">bucket:</span> <span class="hljs-string">bucketname</span><br>    <span class="hljs-attr">keyfile:</span> <span class="hljs-string">/path/to/keyfile</span><br>    <span class="hljs-attr">rootdirectory:</span> <span class="hljs-string">/gcs/object/name/prefix</span><br>    <span class="hljs-attr">chunksize:</span> <span class="hljs-number">5242880</span><br></code></pre></td></tr></table></figure>
<h3 id="docker-compose-部署示例">Docker Compose 部署示例</h3>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3.8&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry:2</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">registry</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5000:5000&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_STORAGE_DELETE_ENABLED=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_HTTP_TLS_KEY=/certs/domain.key</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_AUTH=htpasswd</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_AUTH_HTPASSWD_PATH=/auth/htpasswd</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_AUTH_HTPASSWD_REALM=Registry</span> <span class="hljs-string">Realm</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/registry:/var/lib/registry</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/certs:/certs:ro</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./data/auth:/auth:ro</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">registry-net</span><br><br>  <span class="hljs-attr">registry-ui:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">joxit/docker-registry-ui:latest</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">registry-ui</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:80&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SINGLE_REGISTRY=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_TITLE=My</span> <span class="hljs-string">Private</span> <span class="hljs-string">Registry</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">DELETE_IMAGES=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SHOW_CONTENT_DIGEST=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">NGINX_PROXY_PASS_URL=https://registry:5000</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">SHOW_CATALOG_NB_TAGS=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">CATALOG_MIN_BRANCHES=1</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">CATALOG_MAX_BRANCHES=1</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TAGLIST_PAGE_SIZE=100</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">REGISTRY_SECURED=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">CATALOG_ELEMENTS_LIMIT=1000</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">registry</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">registry-net</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">registry-net:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span><br></code></pre></td></tr></table></figure>
<h2 id="harbor-企业级仓库">Harbor 企业级仓库</h2>
<p>Harbor 是 VMware 开源的企业级 Docker Registry，提供了比官方 Registry 更丰富的功能。</p>
<h3 id="核心特性">核心特性</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>RBAC</strong></td>
<td>基于角色的访问控制，支持项目和用户级别的权限管理</td>
</tr>
<tr>
<td><strong>漏洞扫描</strong></td>
<td>集成 Trivy、Clair 等扫描引擎，自动检测镜像漏洞</td>
</tr>
<tr>
<td><strong>镜像复制</strong></td>
<td>支持跨 Registry 的镜像同步和复制</td>
</tr>
<tr>
<td><strong>审计日志</strong></td>
<td>记录所有操作日志，满足合规要求</td>
</tr>
<tr>
<td><strong>Webhook</strong></td>
<td>支持镜像推送、删除等事件的通知</td>
</tr>
<tr>
<td><strong>Notary</strong></td>
<td>内容信任机制，确保镜像来源可信</td>
</tr>
<tr>
<td><strong>Helm Chart 仓库</strong></td>
<td>支持 Helm Chart 的存储和分发</td>
</tr>
<tr>
<td><strong>OIDC/LDAP</strong></td>
<td>支持企业级认证集成</td>
</tr>
</tbody>
</table>
<h3 id="harbor-vs-docker-registry">Harbor vs Docker Registry</h3>
<table>
<thead>
<tr>
<th>特性</th>
<th>Docker Registry</th>
<th>Harbor</th>
</tr>
</thead>
<tbody>
<tr>
<td>基础功能</td>
<td>✓</td>
<td>✓</td>
</tr>
<tr>
<td>Web UI</td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td>权限管理</td>
<td>基础</td>
<td>RBAC</td>
</tr>
<tr>
<td>漏洞扫描</td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td>镜像复制</td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td>审计日志</td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td>内容信任</td>
<td>需要 Notary</td>
<td>集成</td>
</tr>
<tr>
<td>Helm 支持</td>
<td>✗</td>
<td>✓</td>
</tr>
<tr>
<td>部署复杂度</td>
<td>简单</td>
<td>中等</td>
</tr>
</tbody>
</table>
<h3 id="基本部署">基本部署</h3>
<h4 id="在线安装">在线安装</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载 Harbor 安装包</span><br>wget https://github.com/goharbor/harbor/releases/download/v2.10.0/harbor-online-installer-v2.10.0.tgz<br>tar -zxvf harbor-online-installer-v2.10.0.tgz<br><span class="hljs-built_in">cd</span> harbor<br><br><span class="hljs-comment"># 编辑配置文件</span><br><span class="hljs-built_in">cp</span> harbor.yml.tmpl harbor.yml<br>vim harbor.yml<br><br><span class="hljs-comment"># 配置示例</span><br>hostname: harbor.example.com<br>http:<br>  port: 80<br>https:<br>  port: 443<br>  certificate: /data/cert/harbor.crt<br>  private_key: /data/cert/harbor.key<br>harbor_admin_password: Harbor12345<br>database:<br>  password: root123<br>  max_idle_conns: 100<br>  max_open_conns: 900<br>data_volume: /data<br>trivy:<br>  ignore_unfixed: <span class="hljs-literal">false</span><br>  skip_update: <span class="hljs-literal">false</span><br>  offline_scan: <span class="hljs-literal">false</span><br>  security_check: vuln<br>  insecure: <span class="hljs-literal">false</span><br><br><span class="hljs-comment"># 执行安装脚本</span><br>./install.sh --with-trivy --with-notary --with-chartmuseum<br></code></pre></td></tr></table></figure>
<h4 id="docker-compose-部署">Docker Compose 部署</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启动 Harbor</span><br>docker-compose up -d<br><br><span class="hljs-comment"># 停止 Harbor</span><br>docker-compose down<br><br><span class="hljs-comment"># 重新配置</span><br>docker-compose down -v<br>./prepare<br>docker-compose up -d<br></code></pre></td></tr></table></figure>
<h3 id="使用-harbor">使用 Harbor</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 登录 Harbor</span><br>docker login harbor.example.com<br><br><span class="hljs-comment"># 推送镜像</span><br>docker tag myapp:1.0.0 harbor.example.com/myproject/myapp:1.0.0<br>docker push harbor.example.com/myproject/myapp:1.0.0<br><br><span class="hljs-comment"># 拉取镜像</span><br>docker pull harbor.example.com/myproject/myapp:1.0.0<br><br><span class="hljs-comment"># 查看镜像扫描结果</span><br><span class="hljs-comment"># 通过 Web UI 或 API 查看漏洞扫描报告</span><br></code></pre></td></tr></table></figure>
<h2 id="多架构镜像-multi-arch">多架构镜像（Multi-arch）</h2>
<p>随着 ARM 架构的普及，支持多架构的镜像变得越来越重要。</p>
<h3 id="manifest-list-的概念">Manifest List 的概念</h3>
<p>Manifest List 是一个包含多个架构 manifest 的引用列表，Docker 会根据宿主机架构自动选择合适的镜像：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker pull nginx:latest<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 AMD64 上自动选择 nginx:latest (linux/amd64)</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 ARM64 上自动选择 nginx:latest (linux/arm64)</span><br></code></pre></td></tr></table></figure>
<h3 id="docker-buildx-工具">docker buildx 工具</h3>
<p><code>buildx</code> 是 Docker 的下一代构建工具，支持多平台构建和更强大的缓存机制：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 启用 buildx（Docker 19.03+）</span><br>docker buildx version<br><br><span class="hljs-comment"># 创建新的 builder 实例</span><br>docker buildx create --name mybuilder --use<br><br><span class="hljs-comment"># 启动 builder</span><br>docker buildx inspect --bootstrap<br><br><span class="hljs-comment"># 查看支持的架构</span><br>docker buildx imagetools inspect nginx:latest<br></code></pre></td></tr></table></figure>
<h3 id="构建多架构镜像">构建多架构镜像</h3>
<h4 id="使用-buildx-构建并推送">使用 buildx 构建并推送</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 构建多架构镜像并推送到 Docker Hub</span><br>docker buildx build \<br>  --platform linux/amd64,linux/arm64,linux/arm/v7 \<br>  -t username/myapp:1.0.0 \<br>  --push \<br>  .<br><br><span class="hljs-comment"># 构建并推送到私有仓库</span><br>docker buildx build \<br>  --platform linux/amd64,linux/arm64 \<br>  -t registry.example.com/myapp:1.0.0 \<br>  --push \<br>  .<br><br><span class="hljs-comment"># 本地构建（不推送）</span><br>docker buildx build \<br>  --platform linux/amd64,linux/arm64 \<br>  -t myapp:1.0.0 \<br>  --load \<br>  .<br></code></pre></td></tr></table></figure>
<h4 id="跨平台构建模拟">跨平台构建模拟</h4>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在 AMD64 上构建 ARM64 镜像</span><br>docker buildx build \<br>  --platform linux/arm64 \<br>  -t myapp:arm64 \<br>  .<br><br><span class="hljs-comment"># 查看构建的 manifest</span><br>docker buildx imagetools inspect myapp:1.0.0<br></code></pre></td></tr></table></figure>
<h3 id="docker-manifest-命令">docker manifest 命令</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建 manifest list</span><br>docker manifest create myapp:1.0.0 \<br>  myapp:1.0.0-amd64 \<br>  myapp:1.0.0-arm64 \<br>  myapp:1.0.0-arm<br><br><span class="hljs-comment"># 注释 manifest</span><br>docker manifest annotate myapp:1.0.0 \<br>  myapp:1.0.0-amd64 --os linux --<span class="hljs-built_in">arch</span> amd64<br>docker manifest annotate myapp:1.0.0 \<br>  myapp:1.0.0-arm64 --os linux --<span class="hljs-built_in">arch</span> arm64<br>docker manifest annotate myapp:1.0.0 \<br>  myapp:1.0.0-arm --os linux --<span class="hljs-built_in">arch</span> arm --variant v7<br><br><span class="hljs-comment"># 推送 manifest</span><br>docker manifest push myapp:1.0.0<br><br><span class="hljs-comment"># 查看 manifest</span><br>docker manifest inspect myapp:1.0.0<br><br><span class="hljs-comment"># 删除 manifest</span><br>docker manifest <span class="hljs-built_in">rm</span> myapp:1.0.0<br></code></pre></td></tr></table></figure>
<h3 id="完整的多架构构建流程">完整的多架构构建流程</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>VERSION=1.0.0<br>IMAGE_NAME=myapp<br><br><span class="hljs-comment"># 构建各架构镜像</span><br>docker build --platform linux/amd64 -t <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-amd64 .<br>docker build --platform linux/arm64 -t <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-arm64 .<br>docker build --platform linux/arm/v7 -t <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-arm .<br><br><span class="hljs-comment"># 推送各架构镜像</span><br>docker push <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-amd64<br>docker push <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-arm64<br>docker push <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-arm<br><br><span class="hljs-comment"># 创建 manifest list</span><br>docker manifest create <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span> \<br>  <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-amd64 \<br>  <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-arm64 \<br>  <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-arm<br><br><span class="hljs-comment"># 注释 manifest</span><br>docker manifest annotate <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span> \<br>  <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-amd64 --os linux --<span class="hljs-built_in">arch</span> amd64<br>docker manifest annotate <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span> \<br>  <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-arm64 --os linux --<span class="hljs-built_in">arch</span> arm64<br>docker manifest annotate <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span> \<br>  <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-arm --os linux --<span class="hljs-built_in">arch</span> arm --variant v7<br><br><span class="hljs-comment"># 推送 manifest list</span><br>docker manifest push <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span><br><br><span class="hljs-comment"># 为 latest 标签创建 manifest</span><br>docker manifest create <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:latest \<br>  <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-amd64 \<br>  <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-arm64 \<br>  <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:<span class="hljs-variable">$&#123;VERSION&#125;</span>-arm<br><br>docker manifest push <span class="hljs-variable">$&#123;IMAGE_NAME&#125;</span>:latest<br></code></pre></td></tr></table></figure>
<h2 id="镜像加速器">镜像加速器</h2>
<p>在国内使用 Docker Hub 时，由于网络原因，拉取镜像速度较慢。使用镜像加速器可以显著提升速度。</p>
<h3 id="国内常用镜像源">国内常用镜像源</h3>
<table>
<thead>
<tr>
<th>提供商</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>阿里云</td>
<td><code>https://[your-id].mirror.aliyuncs.com</code></td>
</tr>
<tr>
<td>腾讯云</td>
<td><code>https://mirror.ccs.tencentyun.com</code></td>
</tr>
<tr>
<td>网易</td>
<td><code>https://hub-mirror.c.163.com</code></td>
</tr>
<tr>
<td>中科大</td>
<td><code>https://docker.mirrors.ustc.edu.cn</code></td>
</tr>
<tr>
<td>Docker 中国</td>
<td><code>https://registry.docker-cn.com</code></td>
</tr>
</tbody>
</table>
<h3 id="配置方式">配置方式</h3>
<p>编辑 Docker 守护进程配置文件 <code>/etc/docker/daemon.json</code>：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://your-id.mirror.aliyuncs.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;https://mirror.ccs.tencentyun.com&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-string">&quot;https://hub-mirror.c.163.com&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;max-concurrent-downloads&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;log-driver&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;json-file&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;log-level&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;warn&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;log-opts&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;max-size&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;10m&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;max-file&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;3&quot;</span><br>  <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<p>重启 Docker 服务：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Linux</span><br><span class="hljs-built_in">sudo</span> systemctl daemon-reload<br><span class="hljs-built_in">sudo</span> systemctl restart docker<br><br><span class="hljs-comment"># macOS</span><br><span class="hljs-comment"># 打开 Docker Desktop -&gt; Settings -&gt; Docker Engine</span><br><span class="hljs-comment"># 添加上面的 registry-mirrors 配置</span><br></code></pre></td></tr></table></figure>
<h3 id="验证加速器">验证加速器</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看 Docker 信息</span><br>docker info<br><br><span class="hljs-comment"># 输出中应该包含 Registry Mirrors</span><br><span class="hljs-comment"># Registry Mirrors:</span><br><span class="hljs-comment">#   https://your-id.mirror.aliyuncs.com/</span><br><span class="hljs-comment">#   https://mirror.ccs.tencentyun.com/</span><br><br><span class="hljs-comment"># 测试拉取速度（对比使用加速器前后的速度）</span><br><span class="hljs-keyword">time</span> docker pull nginx:latest<br></code></pre></td></tr></table></figure>
<h3 id="私有仓库的镜像加速">私有仓库的镜像加速</h3>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://your-id.mirror.aliyuncs.com&quot;</span><br>  <span class="hljs-punctuation">]</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;insecure-registries&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;registry.example.com:5000&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure>
<h2 id="镜像分发策略">镜像分发策略</h2>
<p>随着容器规模的扩大，传统的镜像分发方式面临性能瓶颈。本章介绍几种优化镜像分发的策略。</p>
<h3 id="传统推拉模式的瓶颈">传统推拉模式的瓶颈</h3>
<p><strong>问题：</strong></p>
<ul>
<li>每个节点独立从仓库拉取镜像，重复下载相同数据</li>
<li>网络带宽消耗大，尤其是在大规模集群部署时</li>
<li>仓库服务器压力大</li>
<li>冷启动时间长</li>
</ul>
<p><strong>场景示例：</strong></p>
<ul>
<li>100 个节点同时拉取 1GB 的镜像</li>
<li>总网络流量：100GB</li>
<li>如果仓库带宽为 1Gbps，需要约 13 分钟</li>
</ul>
<h3 id="p2p-分发方案">P2P 分发方案</h3>
<h4 id="dragonfly-阿里巴巴开源">Dragonfly（阿里巴巴开源）</h4>
<p>Dragonfly 是一个基于 P2P 的文件分发系统，支持 Docker 镜像分发：</p>
<p><strong>核心特性：</strong></p>
<ul>
<li>P2P 分发，减少重复下载</li>
<li>支持断点续传</li>
<li>自动镜像预热</li>
<li>与 Kubernetes 集成</li>
</ul>
<p><strong>部署方式：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 Helm 安装 Dragonfly</span><br>helm repo add dragonfly https://dragonflyoss.github.io/helm-charts/<br>helm install dragonfly dragonfly/dragonfly --namespace dragonfly-system --create-namespace<br><br><span class="hljs-comment"># 配置 Docker 使用 Dragonfly</span><br><span class="hljs-comment"># 添加 /etc/docker/daemon.json</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;http://127.0.0.1:65001&quot;</span><br>  ]<br>&#125;<br><br><span class="hljs-comment"># 重启 Docker</span><br><span class="hljs-built_in">sudo</span> systemctl restart docker<br></code></pre></td></tr></table></figure>
<p><strong>使用效果：</strong></p>
<ul>
<li>100 个节点拉取 1GB 镜像</li>
<li>总网络流量：约 1-2GB（P2P 分享）</li>
<li>时间：约 1-2 分钟</li>
</ul>
<h4 id="kraken-uber-开源">Kraken（Uber 开源）</h4>
<p>Kraken 是 Uber 开源的 P2P Docker registry，专为大规模集群设计：</p>
<p><strong>核心特性：</strong></p>
<ul>
<li>完全兼容 Docker Registry API</li>
<li>支持 BitTorrent 协议</li>
<li>集成安全扫描</li>
<li>监控和告警</li>
</ul>
<p><strong>部署示例：</strong></p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># docker-compose.yml</span><br><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;3&#x27;</span><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">kraken-origin:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">uber/kraken-origin:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8080:80&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ORIGIN_PORT=80</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ORIGIN_TLS_CERT=/certs/cert.pem</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">ORIGIN_TLS_KEY=/certs/key.pem</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">./certs:/certs</span><br><br>  <span class="hljs-attr">kraken-tracker:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">uber/kraken-tracker:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6969:6969&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TRACKER_PORT=6969</span><br><br>  <span class="hljs-attr">kraken-peer:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">uber/kraken-peer:latest</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;8081:8080&quot;</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PEER_PORT=8080</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">PEER_TRACKER=http://kraken-tracker:6969</span><br></code></pre></td></tr></table></figure>
<h3 id="镜像预热策略">镜像预热策略</h3>
<p>提前将镜像分发到各节点，减少部署时的等待时间：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用 kubectl 预热镜像</span><br>kubectl create -f image-pull-job.yaml<br><br><span class="hljs-comment"># image-pull-job.yaml</span><br>apiVersion: batch/v1<br>kind: Job<br>metadata:<br>  name: image-pull-job<br>spec:<br>  template:<br>    spec:<br>      containers:<br>      - name: image-pull<br>        image: myapp:1.0.0<br>        <span class="hljs-built_in">command</span>: [<span class="hljs-string">&quot;sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo &#x27;Image pulled successfully&#x27;&quot;</span>]<br>      restartPolicy: OnFailure<br></code></pre></td></tr></table></figure>
<h3 id="懒加载-lazy-pulling">懒加载（Lazy Pulling）</h3>
<p>懒加载技术允许容器在启动时只下载需要的文件，而不是整个镜像。</p>
<h4 id="stargz">Stargz</h4>
<p>Stargz 是 Google 开源的镜像懒加载方案：</p>
<p><strong>工作原理：</strong></p>
<ul>
<li>将镜像转换为 stargz 格式</li>
<li>容器启动时按需下载文件</li>
<li>减少初始下载时间</li>
</ul>
<p><strong>使用方式：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 stargzify</span><br>go install github.com/containerd/stargz-snapshotter/cmd/stargzify@latest<br><br><span class="hljs-comment"># 转换镜像</span><br>stargzify myapp:1.0.0 myapp:1.0.0-stargz<br><br><span class="hljs-comment"># 运行时需要配置 containerd 使用 stargz snapshotter</span><br></code></pre></td></tr></table></figure>
<h4 id="nydus">Nydus</h4>
<p>Nydus 是蚂蚁集团开源的镜像懒加载方案，兼容 OCI 标准：</p>
<p><strong>核心特性：</strong></p>
<ul>
<li>支持多种存储后端（本地、OSS、NAS）</li>
<li>镜像按需加载</li>
<li>支持镜像加密</li>
<li>与 Kubernetes 集成</li>
</ul>
<p><strong>部署方式：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 安装 nydus-image</span><br>wget https://github.com/dragonflyoss/nydus/releases/download/v2.2.0/nydus-image-v2.2.0-linux-amd64<br><span class="hljs-built_in">chmod</span> +x nydus-image-v2.2.0-linux-amd64<br><span class="hljs-built_in">sudo</span> <span class="hljs-built_in">mv</span> nydus-image-v2.2.0-linux-amd64 /usr/local/bin/nydus-image<br><br><span class="hljs-comment"># 转换镜像</span><br>nydus-image create --<span class="hljs-built_in">source</span> myapp:1.0.0 --output myapp:1.0.0-nydus<br><br><span class="hljs-comment"># 运行时需要配置 containerd 使用 nydus snapshotter</span><br></code></pre></td></tr></table></figure>
<p><strong>性能对比：</strong></p>
<table>
<thead>
<tr>
<th>方案</th>
<th>镜像大小</th>
<th>启动时间</th>
<th>首次下载</th>
</tr>
</thead>
<tbody>
<tr>
<td>传统镜像</td>
<td>1GB</td>
<td>10s</td>
<td>1GB</td>
</tr>
<tr>
<td>Stargz</td>
<td>1.1GB</td>
<td>2s</td>
<td>200MB</td>
</tr>
<tr>
<td>Nydus</td>
<td>1.05GB</td>
<td>1.5s</td>
<td>150MB</td>
</tr>
</tbody>
</table>
<h3 id="分发策略选择建议">分发策略选择建议</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>推荐方案</th>
</tr>
</thead>
<tbody>
<tr>
<td>小规模集群（&lt; 10 节点）</td>
<td>传统推拉 + 镜像加速器</td>
</tr>
<tr>
<td>中等规模集群（10-100 节点）</td>
<td>P2P 分发</td>
</tr>
<tr>
<td>大规模集群（&gt; 100 节点）</td>
<td>P2P + 懒加载</td>
</tr>
<tr>
<td>资源受限环境</td>
<td>懒加载</td>
</tr>
<tr>
<td>需要快速启动</td>
<td>懒加载 + 预热</td>
</tr>
</tbody>
</table>
<hr>
<p><img src="docker.png" alt="docker"><br>
<a href="docker.xmind">docker.xmind</a></p>
<h1>参考资料</h1>
<ul>
<li><a target="_blank" rel="noopener" href="http://dockone.io/article/128">深入理解Docker Volume（一）</a></li>
<li><a target="_blank" rel="noopener" href="http://dockone.io/article/129">深入理解Docker Volume（二）</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/admin/volumes/volumes/#differences-between--v-and---mount-behavior">Docker 官方文档 - Volumes</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.docker.com/storage/storagedriver/#container-size-on-disk">Docker 官方文档 - Storage drivers</a></li>
<li><a target="_blank" rel="noopener" href="http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/">Using Docker-in-Docker for CI? Think twice</a></li>
<li><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/30209776/docker-container-will-automatically-stop-after-docker-run-d">Docker Container Auto Stop</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/02/07/Docker-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/">https://magicliang.github.io/2026/02/07/Docker-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-112.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/31/%E6%8A%8A-Unix-%E7%9A%84-Domain-Socket-%E8%BD%AC%E6%88%90%E5%8F%AF%E6%9C%AC%E5%9C%B0%E8%AE%BF%E9%97%AE%E7%9A%84-TCP-%E7%AB%AF%E5%8F%A3/" title="把 Unix 的 Domain Socket 转成可本地访问的 TCP 端口"><img class="cover" src="/img/wall-paper-171.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-31</div><div class="info-item-2">把 Unix 的 Domain Socket 转成可本地访问的 TCP 端口</div></div><div class="info-2"><div class="info-item-1">使用管道命令的做法： 1socat -d TCP-LISTEN:2376,range=127.0.0.1/32,reuseaddr,fork UNIX:/var/run/docker.sock 简洁的做法（使用守护进程而不是使用管道命令） 1docker run -d -v /var/run/docker.sock:/var/run/docker.sock -p 127.0.0.1:2375:2375 bobrik/socat TCP-LISTEN:2375,fork UNIX-CONNECT:/var/run/docker.sock 从容器内往外看的主机，对应外部主机就是 127.0.0.1的端口 ping docker.for.mac.localhost 通常结果是192.168.65.1。 值得参考的文：  http://brieflyx.me/2015/linux-tools/socat-introduction/  </div></div></div></a><a class="pagination-related" href="/2026/02/07/Kubernetes-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/" title="Kubernetes 核心概念"><img class="cover" src="/img/wall-paper-57.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-07</div><div class="info-item-2">Kubernetes 核心概念</div></div><div class="info-2"><div class="info-item-1">从 Docker 到 Kubernetes 的演进 Docker 的出现彻底改变了应用程序的打包和部署方式。通过容器化技术，开发人员能够将应用程序及其依赖项打包到一个轻量级的、可移植的容器中，确保了&quot;一次构建，到处运行&quot;的一致性体验。然而，随着容器化应用的规模扩大，单机容器管理的局限性逐渐显现。 在单机环境中，Docker 提供了容器生命周期管理、资源隔离、网络配置等基础功能。但当应用规模扩展到多台服务器时，运维团队面临诸多挑战：跨主机的容器调度、服务发现、负载均衡、故障自愈、滚动升级、资源配额等问题变得日益复杂。手工管理几十甚至上百个容器不仅效率低下，而且容易出错。 容器编排平台应运而生。Kubernetes（K8s）作为容器编排领域的领导者，提供了一个完整的平台，用于自动化部署、扩展和管理容器化应用。它解决了多机环境下的核心问题：自动化调度、服务发现、负载均衡、存储编排、自动扩缩容、滚动更新和回滚、自我修复等。Kubernetes 不仅是一个编排工具，更是一个云原生应用的基础设施平台。 Kubernetes 架构 Kubernetes 采用主从架构，由控制...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">第1章：Docker 核心架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E7%9A%84%E5%9B%9B%E6%A0%B9%E6%9F%B1%E5%AD%90"><span class="toc-number">1.1.</span> <span class="toc-text">Docker 的四根柱子</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-namespace-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4-%E9%9A%94%E7%A6%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">1. Namespace（命名空间）—— 隔离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-control-group-cgroup-%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text">2. Control Group（cgroup）—— 资源限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-unionfs-%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-%E5%88%86%E5%B1%82%E5%AD%98%E5%82%A8"><span class="toc-number">1.1.3.</span> <span class="toc-text">3. UnionFS（联合文件系统）—— 分层存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-container-format-%E5%AE%B9%E5%99%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.4.</span> <span class="toc-text">4. Container Format（容器格式）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8-vs-%E8%99%9A%E6%8B%9F%E6%9C%BA"><span class="toc-number">1.2.</span> <span class="toc-text">容器 vs 虚拟机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E7%9A%84%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91"><span class="toc-number">1.3.</span> <span class="toc-text">Docker 的一等公民</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B"><span class="toc-number">1.4.</span> <span class="toc-text">Docker 架构演进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-engine-%E7%9A%84-c-s-%E6%9E%B6%E6%9E%84"><span class="toc-number">1.5.</span> <span class="toc-text">Docker Engine 的 C&#x2F;S 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-cli-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.5.1.</span> <span class="toc-text">Docker CLI（客户端）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-daemon-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">1.5.2.</span> <span class="toc-text">Docker Daemon（守护进程）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rest-api"><span class="toc-number">1.5.3.</span> <span class="toc-text">REST API</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oci-%E6%A0%87%E5%87%86"><span class="toc-number">1.6.</span> <span class="toc-text">OCI 标准</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#runtime-specification-%E8%BF%90%E8%A1%8C%E6%97%B6%E8%A7%84%E8%8C%83"><span class="toc-number">1.6.1.</span> <span class="toc-text">Runtime Specification（运行时规范）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#image-specification-%E9%95%9C%E5%83%8F%E8%A7%84%E8%8C%83"><span class="toc-number">1.6.2.</span> <span class="toc-text">Image Specification（镜像规范）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">第2章：镜像与分层存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%81%94%E5%90%88%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-unionfs"><span class="toc-number">2.1.</span> <span class="toc-text">联合文件系统（UnionFS）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E7%9A%84%E7%9C%9F%E7%9B%B8"><span class="toc-number">2.1.1.</span> <span class="toc-text">删除文件的真相</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%9A%84%E8%AF%BB%E5%86%99%E5%B1%82"><span class="toc-number">2.2.</span> <span class="toc-text">容器的读写层</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy-on-write-%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6-%E7%AD%96%E7%95%A5"><span class="toc-number">2.3.</span> <span class="toc-text">Copy On Write（写时复制）策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8"><span class="toc-number">2.4.</span> <span class="toc-text">存储驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">常见存储驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E9%80%89%E6%8B%A9%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">2.4.2.</span> <span class="toc-text">存储驱动选择优先级</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.5.</span> <span class="toc-text">容器大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%B1%82%E6%AC%A1%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.6.</span> <span class="toc-text">镜像层次存储位置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E5%B1%82%E6%AC%A1"><span class="toc-number">2.6.1.</span> <span class="toc-text">查看镜像层次</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">第3章：容器生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-number">3.1.</span> <span class="toc-text">容器状态机</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stop-vs-pause-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8C%BA%E5%88%AB"><span class="toc-number">3.2.</span> <span class="toc-text">stop vs pause 的核心区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-stop-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.1.</span> <span class="toc-text">docker stop 的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-pause-unpause-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">3.2.2.</span> <span class="toc-text">docker pause &#x2F; unpause 的工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stop-%E5%90%8E-start-%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-number">3.2.3.</span> <span class="toc-text">stop 后 start 的行为</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E5%AE%B9%E5%99%A8%E7%9A%84%E9%99%B7%E9%98%B1"><span class="toc-number">3.3.</span> <span class="toc-text">后台运行容器的陷阱</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-exec-vs-docker-attach"><span class="toc-number">3.4.</span> <span class="toc-text">docker exec vs docker attach</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cmd-%E4%B8%8E-entrypoint"><span class="toc-number">3.5.</span> <span class="toc-text">CMD 与 ENTRYPOINT</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cmd-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.1.</span> <span class="toc-text">CMD 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#entrypoint-%E6%8C%87%E4%BB%A4"><span class="toc-number">3.5.2.</span> <span class="toc-text">ENTRYPOINT 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cmd-%E4%B8%8E-entrypoint-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">3.5.3.</span> <span class="toc-text">CMD 与 ENTRYPOINT 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exec-%E6%A8%A1%E5%BC%8F-vs-shell-%E6%A8%A1%E5%BC%8F"><span class="toc-number">3.5.4.</span> <span class="toc-text">Exec 模式 vs Shell 模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5%EF%BC%9Aentrypoint-%E4%B8%BA-bin-bash"><span class="toc-number">3.5.5.</span> <span class="toc-text">特殊情况：ENTRYPOINT 为 &#x2F;bin&#x2F;bash</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5-restart-policy"><span class="toc-number">3.6.</span> <span class="toc-text">重启策略（Restart Policy）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E7%A7%8D%E9%87%8D%E5%90%AF%E7%AD%96%E7%95%A5"><span class="toc-number">3.6.1.</span> <span class="toc-text">四种重启策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E8%AF%B4%E6%98%8E"><span class="toc-number">3.6.2.</span> <span class="toc-text">使用场景说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#on-failure-%E7%9A%84-max-retries-%E5%8F%82%E6%95%B0"><span class="toc-number">3.6.3.</span> <span class="toc-text">on-failure 的 max-retries 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#always-vs-unless-stopped-%E7%9A%84%E5%85%B3%E9%94%AE%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.4.</span> <span class="toc-text">always vs unless-stopped 的关键区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">3.6.5.</span> <span class="toc-text">配置方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-run-%E5%91%BD%E4%BB%A4"><span class="toc-number">3.6.5.1.</span> <span class="toc-text">docker run 命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-compose-yml"><span class="toc-number">3.6.5.2.</span> <span class="toc-text">docker-compose.yml</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E4%BF%AE%E6%94%B9%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E5%AE%B9%E5%99%A8"><span class="toc-number">3.6.5.3.</span> <span class="toc-text">动态修改运行中的容器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E5%BB%BA%E8%AE%AE"><span class="toc-number">3.6.6.</span> <span class="toc-text">生产环境建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">第4章：数据持久化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">为什么需要数据持久化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%96%B9%E5%BC%8F%E6%A6%82%E8%A7%88"><span class="toc-number">4.2.</span> <span class="toc-text">三种持久化方式概览</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volume-%E6%95%B0%E6%8D%AE%E5%8D%B7"><span class="toc-number">4.3.</span> <span class="toc-text">Volume（数据卷）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#volume-%E7%9A%84%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">4.3.1.</span> <span class="toc-text">Volume 的核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-volume"><span class="toc-number">4.3.2.</span> <span class="toc-text">创建 Volume</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-run-v-%E7%9A%84%E5%8F%82%E6%95%B0%E9%A1%BA%E5%BA%8F"><span class="toc-number">4.3.3.</span> <span class="toc-text">docker run -v 的参数顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dockerfile-%E4%B8%AD%E7%9A%84-volume-%E6%8C%87%E4%BB%A4"><span class="toc-number">4.3.4.</span> <span class="toc-text">Dockerfile 中的 VOLUME 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pre-populate-data-%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A1%AB%E5%85%85"><span class="toc-number">4.3.5.</span> <span class="toc-text">Pre-populate Data（数据预填充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volume-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">4.3.6.</span> <span class="toc-text">Volume 常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%8D%B7%E5%A4%87%E4%BB%BD%E4%B8%8E%E6%81%A2%E5%A4%8D"><span class="toc-number">4.3.7.</span> <span class="toc-text">数据卷备份与恢复</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bind-mount"><span class="toc-number">4.4.</span> <span class="toc-text">Bind Mount</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E7%82%B9"><span class="toc-number">4.4.1.</span> <span class="toc-text">核心特点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tmpfs-mount"><span class="toc-number">4.5.</span> <span class="toc-text">tmpfs Mount</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volume-vs-bind-mount-%E5%AF%B9%E6%AF%94"><span class="toc-number">4.6.</span> <span class="toc-text">Volume vs Bind Mount 对比</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">第5章：网络模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B-cnm"><span class="toc-number">5.1.</span> <span class="toc-text">容器网络模型（CNM）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E7%BD%91%E7%BB%9C%E9%A9%B1%E5%8A%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text">Docker 网络驱动类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bridge-%E7%BD%91%E7%BB%9C-%E9%BB%98%E8%AE%A4%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text">Bridge 网络（默认模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker0-%E7%BD%91%E6%A1%A5"><span class="toc-number">5.3.1.</span> <span class="toc-text">docker0 网桥</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker0-%E7%9A%84%E7%89%B9%E7%82%B9"><span class="toc-number">5.3.1.1.</span> <span class="toc-text">docker0 的特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-docker0-%E4%BF%A1%E6%81%AF"><span class="toc-number">5.3.1.2.</span> <span class="toc-text">查看 docker0 信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker0-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.3.1.3.</span> <span class="toc-text">docker0 的工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#veth-pair-%E6%9C%BA%E5%88%B6"><span class="toc-number">5.3.2.</span> <span class="toc-text">veth pair 机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iptables-nat-%E8%A7%84%E5%88%99"><span class="toc-number">5.3.3.</span> <span class="toc-text">iptables NAT 规则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#prerouting-%E9%93%BE"><span class="toc-number">5.3.3.1.</span> <span class="toc-text">PREROUTING 链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#postrouting-%E9%93%BE"><span class="toc-number">5.3.3.2.</span> <span class="toc-text">POSTROUTING 链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forward-%E9%93%BE"><span class="toc-number">5.3.3.3.</span> <span class="toc-text">FORWARD 链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B-iptables-%E8%A7%84%E5%88%99"><span class="toc-number">5.3.3.4.</span> <span class="toc-text">查看 iptables 规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91%E9%85%8D%E7%BD%AE"><span class="toc-number">5.3.3.5.</span> <span class="toc-text">流量转发配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iptables-%E8%A7%84%E5%88%99%E7%A4%BA%E4%BE%8B"><span class="toc-number">5.3.3.6.</span> <span class="toc-text">iptables 规则示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-bridge-%E7%BD%91%E7%BB%9C"><span class="toc-number">5.3.4.</span> <span class="toc-text">自定义 bridge 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-proxy-%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.3.5.</span> <span class="toc-text">docker-proxy 进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-proxy-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">5.3.5.1.</span> <span class="toc-text">docker-proxy 的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81-docker-proxy"><span class="toc-number">5.3.5.2.</span> <span class="toc-text">为什么需要 docker-proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E7%94%A8-docker-proxy"><span class="toc-number">5.3.5.3.</span> <span class="toc-text">禁用 docker-proxy</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">5.3.5.4.</span> <span class="toc-text">性能对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#icc-inter-container-communication-%E6%8E%A7%E5%88%B6"><span class="toc-number">5.3.6.</span> <span class="toc-text">ICC（Inter-Container Communication）控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%81%E6%AD%A2%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">5.3.6.1.</span> <span class="toc-text">禁止容器间通信</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8E-link-%E7%9A%84%E5%8E%86%E5%8F%B2%E9%85%8D%E5%90%88-%E5%B7%B2%E5%BA%9F%E5%BC%83"><span class="toc-number">5.3.6.2.</span> <span class="toc-text">与 --link 的历史配合（已废弃）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E5%A4%A9%E7%84%B6%E9%9A%94%E7%A6%BB%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">5.3.6.3.</span> <span class="toc-text">自定义网络天然隔离的优势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4-bridge-vs-%E8%87%AA%E5%AE%9A%E4%B9%89-bridge-%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-number">5.3.7.</span> <span class="toc-text">默认 bridge vs 自定义 bridge 的差异</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#host-%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.4.</span> <span class="toc-text">Host 网络模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#overlay-%E7%BD%91%E7%BB%9C-swarm-%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.5.</span> <span class="toc-text">Overlay 网络（Swarm 模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vxlan-%E6%8A%80%E6%9C%AF"><span class="toc-number">5.5.1.</span> <span class="toc-text">VXLAN 技术</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swarm-%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%86%85%E9%83%A8%E7%BD%91%E7%BB%9C"><span class="toc-number">5.5.2.</span> <span class="toc-text">Swarm 的两个内部网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-overlay-%E7%BD%91%E7%BB%9C%E7%9A%84%E5%85%88%E5%86%B3%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.5.3.</span> <span class="toc-text">创建 Overlay 网络的先决条件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-overlay-%E7%BD%91%E7%BB%9C"><span class="toc-number">5.5.4.</span> <span class="toc-text">创建 Overlay 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#attachable-%E5%8F%82%E6%95%B0"><span class="toc-number">5.5.5.</span> <span class="toc-text">–attachable 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%AF%86%E4%BC%A0%E8%BE%93"><span class="toc-number">5.5.6.</span> <span class="toc-text">加密传输</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E5%88%B6-ingress-%E7%BD%91%E7%BB%9C"><span class="toc-number">5.5.7.</span> <span class="toc-text">定制 ingress 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87%E8%B7%AF%E7%94%B1%E7%BD%91%E6%A0%BC%EF%BC%9Adnsrr-%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.5.8.</span> <span class="toc-text">绕过路由网格：DNSRR 模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84"><span class="toc-number">5.6.</span> <span class="toc-text">端口映射</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4"><span class="toc-number">5.7.</span> <span class="toc-text">网络管理命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-network-create"><span class="toc-number">5.7.1.</span> <span class="toc-text">docker network create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-network-connect"><span class="toc-number">5.7.2.</span> <span class="toc-text">docker network connect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-network-disconnect"><span class="toc-number">5.7.3.</span> <span class="toc-text">docker network disconnect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-network-inspect"><span class="toc-number">5.7.4.</span> <span class="toc-text">docker network inspect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-network-ls"><span class="toc-number">5.7.5.</span> <span class="toc-text">docker network ls</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-network-prune"><span class="toc-number">5.7.6.</span> <span class="toc-text">docker network prune</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-network-rm"><span class="toc-number">5.7.7.</span> <span class="toc-text">docker network rm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-dns-%E6%9C%8D%E5%8A%A1"><span class="toc-number">5.8.</span> <span class="toc-text">Docker DNS 服务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E5%86%85%E7%BD%AE-dns-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">5.8.1.</span> <span class="toc-text">Docker 内置 DNS 服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E7%9C%8B%E5%AE%B9%E5%99%A8-dns-%E9%85%8D%E7%BD%AE"><span class="toc-number">5.8.2.</span> <span class="toc-text">查看容器 DNS 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E5%8A%9F%E8%83%BD"><span class="toc-number">5.8.3.</span> <span class="toc-text">服务发现功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%AF%E6%8C%81%E7%9A%84-dns-%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.8.4.</span> <span class="toc-text">支持的 DNS 记录类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#swarm-%E6%A8%A1%E5%BC%8F%E4%B8%8B%E7%9A%84-dns-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">5.8.5.</span> <span class="toc-text">Swarm 模式下的 DNS 负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-dns-%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">5.8.6.</span> <span class="toc-text">自定义 DNS 服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dns-%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5"><span class="toc-number">5.8.7.</span> <span class="toc-text">DNS 问题排查</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81-dns-%E9%97%AE%E9%A2%98"><span class="toc-number">5.8.8.</span> <span class="toc-text">常见 DNS 问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#link-%E7%9A%84%E5%BA%9F%E5%BC%83"><span class="toc-number">5.9.</span> <span class="toc-text">–link 的废弃</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#macvlan-%E7%BD%91%E7%BB%9C%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.10.</span> <span class="toc-text">macvlan 网络详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">5.10.1.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-macvlan-%E7%BD%91%E7%BB%9C"><span class="toc-number">5.10.2.</span> <span class="toc-text">创建 macvlan 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#macvlan-%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">5.10.3.</span> <span class="toc-text">macvlan 的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#macvlan-%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">5.10.4.</span> <span class="toc-text">macvlan 的缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8E-macvlan-%E5%AE%B9%E5%99%A8%E9%80%9A%E4%BF%A1"><span class="toc-number">5.10.5.</span> <span class="toc-text">宿主机与 macvlan 容器通信</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%BA%E7%9C%81%E6%A1%A5%E6%8E%A5%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE"><span class="toc-number">5.11.</span> <span class="toc-text">缺省桥接网络配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E9%A1%B9%E8%AF%B4%E6%98%8E"><span class="toc-number">5.11.1.</span> <span class="toc-text">配置项说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%AD%A5%E9%AA%A4"><span class="toc-number">5.11.2.</span> <span class="toc-text">配置步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.11.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8-ip-%E5%9C%B0%E5%9D%80%E6%8C%87%E5%AE%9A"><span class="toc-number">5.12.</span> <span class="toc-text">容器 IP 地址指定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-docker-network-connect-%E6%8C%87%E5%AE%9A-ip"><span class="toc-number">5.12.1.</span> <span class="toc-text">使用 docker network connect 指定 IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-docker-run-%E6%8C%87%E5%AE%9A-ip"><span class="toc-number">5.12.2.</span> <span class="toc-text">使用 docker run 指定 IP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">5.12.3.</span> <span class="toc-text">注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ipv6-%E6%94%AF%E6%8C%81"><span class="toc-number">5.13.</span> <span class="toc-text">IPv6 支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E7%94%A8-ipv6-%E6%94%AF%E6%8C%81"><span class="toc-number">5.13.1.</span> <span class="toc-text">启用 IPv6 支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA-ipv6-%E7%BD%91%E7%BB%9C"><span class="toc-number">5.13.2.</span> <span class="toc-text">创建 IPv6 网络</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81-ipv6-%E9%85%8D%E7%BD%AE"><span class="toc-number">5.13.3.</span> <span class="toc-text">验证 IPv6 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-number">5.13.4.</span> <span class="toc-text">参考链接</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">第6章：Dockerfile 最佳实践</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">6.1.</span> <span class="toc-text">基础结构示例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%98%B6%E6%AE%B5%E6%9E%84%E5%BB%BA-multi-stage-build"><span class="toc-number">6.2.</span> <span class="toc-text">多阶段构建（Multi-stage Build）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E8%AF%A6%E8%A7%A3"><span class="toc-number">6.3.</span> <span class="toc-text">最佳实践详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8%E5%85%B7%E4%BD%93%E7%89%88%E6%9C%AC%E6%A0%87%E7%AD%BE-%E9%81%BF%E5%85%8D-latest"><span class="toc-number">6.3.1.</span> <span class="toc-text">1. 使用具体版本标签，避免 latest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%90%88%E5%B9%B6-run-%E6%8C%87%E4%BB%A4%E5%87%8F%E5%B0%91%E5%B1%82%E6%95%B0"><span class="toc-number">6.3.2.</span> <span class="toc-text">2. 合并 RUN 指令减少层数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A9%E7%94%A8%E6%9E%84%E5%BB%BA%E7%BC%93%E5%AD%98"><span class="toc-number">6.3.3.</span> <span class="toc-text">3. 利用构建缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8-dockerignore"><span class="toc-number">6.3.4.</span> <span class="toc-text">4. 使用 .dockerignore</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%9C%80%E5%B0%8F%E5%8C%96%E9%95%9C%E5%83%8F%E4%BD%93%E7%A7%AF"><span class="toc-number">6.3.5.</span> <span class="toc-text">5. 最小化镜像体积</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E9%9D%9E-root-%E7%94%A8%E6%88%B7%E8%BF%90%E8%A1%8C"><span class="toc-number">6.3.6.</span> <span class="toc-text">6. 非 root 用户运行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arg-vs-env"><span class="toc-number">6.4.</span> <span class="toc-text">ARG vs ENV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copy-vs-add"><span class="toc-number">6.5.</span> <span class="toc-text">COPY vs ADD</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5"><span class="toc-number">6.6.</span> <span class="toc-text">健康检查</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#buildkit-%E6%9E%84%E5%BB%BA%E5%A2%9E%E5%BC%BA"><span class="toc-number">6.7.</span> <span class="toc-text">BuildKit 构建增强</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%AF%E7%94%A8-buildkit"><span class="toc-number">6.7.1.</span> <span class="toc-text">启用 BuildKit</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E6%8C%82%E8%BD%BD-mount-type-cache"><span class="toc-number">6.7.2.</span> <span class="toc-text">缓存挂载（–mount&#x3D;type&#x3D;cache）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#secret-%E6%8C%82%E8%BD%BD-mount-type-secret"><span class="toc-number">6.7.3.</span> <span class="toc-text">Secret 挂载（–mount&#x3D;type&#x3D;secret）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ssh-%E6%8C%82%E8%BD%BD-mount-type-ssh"><span class="toc-number">6.7.4.</span> <span class="toc-text">SSH 挂载（–mount&#x3D;type&#x3D;ssh）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%BE%93%E5%87%BA%E5%AF%BC%E5%87%BA-output"><span class="toc-number">6.7.5.</span> <span class="toc-text">构建输出导出（–output）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E8%81%94%E7%BC%93%E5%AD%98-cache-from-cache-to"><span class="toc-number">6.7.6.</span> <span class="toc-text">内联缓存（–cache-from &#x2F; --cache-to）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#heredoc-%E8%AF%AD%E6%B3%95"><span class="toc-number">6.7.7.</span> <span class="toc-text">Heredoc 语法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">第7章：Docker Compose 编排</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4"><span class="toc-number">7.1.</span> <span class="toc-text">基础命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#v1-%E5%88%B0-v2-%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">7.2.</span> <span class="toc-text">V1 到 V2 的变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-compose-yml-%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">7.3.</span> <span class="toc-text">docker-compose.yml 基本结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%AE%A1%E7%90%86"><span class="toc-number">7.4.</span> <span class="toc-text">环境变量管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#depends-on-%E4%B8%8E%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8%E9%A1%BA%E5%BA%8F"><span class="toc-number">7.5.</span> <span class="toc-text">depends_on 与服务启动顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#profiles-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">7.6.</span> <span class="toc-text">Profiles 的使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%96%87%E4%BB%B6-override"><span class="toc-number">7.7.</span> <span class="toc-text">多文件 Override</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#f-%E5%8F%82%E6%95%B0%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA%E6%96%87%E4%BB%B6"><span class="toc-number">7.7.1.</span> <span class="toc-text">-f 参数指定多个文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-compose-override-yml-%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD"><span class="toc-number">7.7.2.</span> <span class="toc-text">docker-compose.override.yml 自动加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8E%AF%E5%A2%83%E5%88%86%E7%A6%BB%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5"><span class="toc-number">7.7.3.</span> <span class="toc-text">环境分离最佳实践</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%90%88%E5%B9%B6%E8%A7%84%E5%88%99"><span class="toc-number">7.7.4.</span> <span class="toc-text">配置合并规则</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E5%AD%97%E6%AE%B5-x-%E5%89%8D%E7%BC%80"><span class="toc-number">7.8.</span> <span class="toc-text">扩展字段（x- 前缀）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#yaml-%E9%94%9A%E7%82%B9%E4%B8%8E%E5%88%AB%E5%90%8D"><span class="toc-number">7.8.1.</span> <span class="toc-text">YAML 锚点与别名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#x-%E5%89%8D%E7%BC%80%E5%85%AC%E5%85%B1%E9%85%8D%E7%BD%AE%E5%9D%97"><span class="toc-number">7.8.2.</span> <span class="toc-text">x- 前缀公共配置块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.8.3.</span> <span class="toc-text">减少重复的完整示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-number">7.9.</span> <span class="toc-text">资源限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#deploy-resources-%E9%85%8D%E7%BD%AE"><span class="toc-number">7.9.1.</span> <span class="toc-text">deploy.resources 配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%86%99%E5%BD%A2%E5%BC%8F-compose-v2"><span class="toc-number">7.9.2.</span> <span class="toc-text">简写形式（Compose V2）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E-cgroup-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">7.9.3.</span> <span class="toc-text">与 cgroup 的关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.9.4.</span> <span class="toc-text">完整示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#compose-watch-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.10.</span> <span class="toc-text">Compose Watch（开发模式）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E7%A7%8D-action"><span class="toc-number">7.10.1.</span> <span class="toc-text">三种 Action</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#compose-watch-%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-number">7.10.2.</span> <span class="toc-text">Compose Watch 的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E9%85%8D%E7%BD%AE%E7%A4%BA%E4%BE%8B"><span class="toc-number">7.10.3.</span> <span class="toc-text">完整配置示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-compose-watch-%E5%91%BD%E4%BB%A4"><span class="toc-number">7.10.4.</span> <span class="toc-text">docker compose watch 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E4%BC%A0%E7%BB%9F%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">7.10.5.</span> <span class="toc-text">与传统开发模式对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.10.6.</span> <span class="toc-text">实际应用场景</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">第8章：Docker in Docker</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#dind-%E7%9A%84%E5%8E%9F%E5%A7%8B%E7%9B%AE%E7%9A%84"><span class="toc-number">8.1.</span> <span class="toc-text">DinD 的原始目的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%A3%E7%A1%AE%E7%9A%84-dind-%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">8.2.</span> <span class="toc-text">正确的 DinD 启动方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dind-%E7%9A%84%E4%B8%BB%E8%A6%81%E9%97%AE%E9%A2%98"><span class="toc-number">8.3.</span> <span class="toc-text">DinD 的主要问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%BF%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9A%E6%8C%82%E8%BD%BD-docker-socket"><span class="toc-number">8.4.</span> <span class="toc-text">替代方案：挂载 Docker Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E8%A1%A8"><span class="toc-number">8.4.1.</span> <span class="toc-text">对比表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8E%B0%E4%BB%A3%E6%96%B9%E6%A1%88%EF%BC%9Asysbox"><span class="toc-number">8.5.</span> <span class="toc-text">现代方案：Sysbox</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E7%BB%93%E8%AE%BA"><span class="toc-number">8.6.</span> <span class="toc-text">关键结论</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">第9章：日志与调试</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%9F%BA%E7%A1%80"><span class="toc-number">9.1.</span> <span class="toc-text">日志基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4%E6%97%A5%E5%BF%97%E9%A9%B1%E5%8A%A8-json-file"><span class="toc-number">9.1.1.</span> <span class="toc-text">默认日志驱动（json-file）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E8%BD%AE%E8%BD%AC%E9%85%8D%E7%BD%AE"><span class="toc-number">9.1.2.</span> <span class="toc-text">日志轮转配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E6%97%A5%E5%BF%97%E9%A9%B1%E5%8A%A8"><span class="toc-number">9.1.3.</span> <span class="toc-text">自定义日志驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6%E7%9A%84%E6%97%A5%E5%BF%97"><span class="toc-number">9.1.4.</span> <span class="toc-text">直接写入文件的日志</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%91%BD%E4%BB%A4"><span class="toc-number">9.2.</span> <span class="toc-text">日志命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4"><span class="toc-number">9.3.</span> <span class="toc-text">调试命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-inspect"><span class="toc-number">9.3.1.</span> <span class="toc-text">docker inspect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-stats"><span class="toc-number">9.3.2.</span> <span class="toc-text">docker stats</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-top-docker-cp-docker-port-docker-diff"><span class="toc-number">9.3.3.</span> <span class="toc-text">docker top &#x2F; docker cp &#x2F; docker port &#x2F; docker diff</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E8%B0%83%E8%AF%95"><span class="toc-number">9.4.</span> <span class="toc-text">高级调试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#strace-%E8%B0%83%E8%AF%95"><span class="toc-number">9.4.1.</span> <span class="toc-text">strace 调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E5%85%A5%E5%AE%B9%E5%99%A8%E7%BD%91%E7%BB%9C%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4"><span class="toc-number">9.4.2.</span> <span class="toc-text">进入容器网络命名空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-events"><span class="toc-number">9.4.3.</span> <span class="toc-text">docker events</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-system-df"><span class="toc-number">9.4.4.</span> <span class="toc-text">docker system df</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">第10章：系统维护与清理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E9%9D%A2%E6%B8%85%E7%90%86"><span class="toc-number">10.1.</span> <span class="toc-text">全面清理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%E6%B8%85%E7%90%86"><span class="toc-number">10.2.</span> <span class="toc-text">分类清理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">10.3.</span> <span class="toc-text">系统信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF"><span class="toc-number">10.4.</span> <span class="toc-text">磁盘空间排查思路</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9A%E6%9C%9F%E6%B8%85%E7%90%86%E7%AD%96%E7%95%A5%E5%BB%BA%E8%AE%AE"><span class="toc-number">10.5.</span> <span class="toc-text">定期清理策略建议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%98%A6%E8%BA%AB%E5%AE%9E%E6%88%98"><span class="toc-number">10.6.</span> <span class="toc-text">镜像瘦身实战</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dive-%E5%B7%A5%E5%85%B7"><span class="toc-number">10.6.1.</span> <span class="toc-text">dive 工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F"><span class="toc-number">10.6.1.1.</span> <span class="toc-text">安装方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-number">10.6.1.2.</span> <span class="toc-text">基本使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ci-%E9%9B%86%E6%88%90"><span class="toc-number">10.6.1.3.</span> <span class="toc-text">CI 集成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%88%E7%8E%87%E8%AF%84%E5%88%86%E6%8C%87%E6%A0%87"><span class="toc-number">10.6.1.4.</span> <span class="toc-text">效率评分指标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F%E5%A4%A7%E5%B0%8F%E5%AF%B9%E6%AF%94"><span class="toc-number">10.6.2.</span> <span class="toc-text">基础镜像大小对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#scratch-%E5%9F%BA%E7%A1%80%E9%95%9C%E5%83%8F"><span class="toc-number">10.6.3.</span> <span class="toc-text">scratch 基础镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#go-%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.6.3.1.</span> <span class="toc-text">Go 应用示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#distroless-%E9%95%9C%E5%83%8F"><span class="toc-number">10.6.4.</span> <span class="toc-text">distroless 镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#java-%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.6.4.1.</span> <span class="toc-text">Java 应用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#node-js-%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.6.4.2.</span> <span class="toc-text">Node.js 应用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B0%83%E8%AF%95-distroless-%E9%95%9C%E5%83%8F"><span class="toc-number">10.6.4.3.</span> <span class="toc-text">调试 distroless 镜像</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%98%A6%E8%BA%AB%E6%A3%80%E6%9F%A5%E6%B8%85%E5%8D%95"><span class="toc-number">10.6.5.</span> <span class="toc-text">镜像瘦身检查清单</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%A4%BA%E4%BE%8B"><span class="toc-number">10.6.5.1.</span> <span class="toc-text">完整示例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">第11章：Label 与资源管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#label-%E7%9A%84%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">11.1.</span> <span class="toc-text">Label 的命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%94%AE%E6%A0%BC%E5%BC%8F"><span class="toc-number">11.1.1.</span> <span class="toc-text">键格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E6%A0%BC%E5%BC%8F"><span class="toc-number">11.1.2.</span> <span class="toc-text">值格式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#label-vs-tag"><span class="toc-number">11.2.</span> <span class="toc-text">Label vs Tag</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#label-%E7%9A%84%E8%BF%87%E6%BB%A4%E7%94%A8%E6%B3%95"><span class="toc-number">11.3.</span> <span class="toc-text">Label 的过滤用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9C%A8-dockerfile-%E4%B8%AD%E4%BD%BF%E7%94%A8-label-%E6%8C%87%E4%BB%A4"><span class="toc-number">11.4.</span> <span class="toc-text">在 Dockerfile 中使用 LABEL 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oci-%E6%A0%87%E5%87%86-label-%E7%BA%A6%E5%AE%9A"><span class="toc-number">11.5.</span> <span class="toc-text">OCI 标准 Label 约定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AE%A1%E7%90%86%E7%A4%BA%E4%BE%8B"><span class="toc-number">11.6.</span> <span class="toc-text">自动化管理示例</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">第12章：Docker 安全</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8%E5%AE%89%E5%85%A8%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E5%88%99"><span class="toc-number">12.1.</span> <span class="toc-text">容器安全的核心原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E-root-%E8%BF%90%E8%A1%8C"><span class="toc-number">12.2.</span> <span class="toc-text">非 root 运行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dockerfile-%E4%B8%AD%E7%9A%84-user-%E6%8C%87%E4%BB%A4"><span class="toc-number">12.2.1.</span> <span class="toc-text">Dockerfile 中的 USER 指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-run-user-%E5%8F%82%E6%95%B0"><span class="toc-number">12.2.2.</span> <span class="toc-text">docker run --user 参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rootless-docker-%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.2.3.</span> <span class="toc-text">Rootless Docker 模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">12.2.3.1.</span> <span class="toc-text">安装配置方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">12.2.3.2.</span> <span class="toc-text">工作原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%90%E5%88%B6"><span class="toc-number">12.2.3.3.</span> <span class="toc-text">限制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%BD%E5%8A%9B%E7%AE%A1%E7%90%86-linux-capabilities"><span class="toc-number">12.3.</span> <span class="toc-text">能力管理（Linux Capabilities）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E9%BB%98%E8%AE%A4%E8%B5%8B%E4%BA%88%E7%9A%84-capabilities-%E5%88%97%E8%A1%A8"><span class="toc-number">12.3.1.</span> <span class="toc-text">Docker 默认赋予的 capabilities 列表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cap-drop-all-cap-add-%E6%9C%80%E5%B0%8F%E6%9D%83%E9%99%90%E6%A8%A1%E5%BC%8F"><span class="toc-number">12.3.2.</span> <span class="toc-text">–cap-drop ALL + --cap-add 最小权限模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8-capabilities-%E8%AF%B4%E6%98%8E%E8%A1%A8%E6%A0%BC"><span class="toc-number">12.3.3.</span> <span class="toc-text">常用 capabilities 说明表格</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#seccomp-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">12.4.</span> <span class="toc-text">Seccomp 配置文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%BB%98%E8%AE%A4-seccomp-profile-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">12.4.1.</span> <span class="toc-text">默认 seccomp profile 的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-seccomp-profile-%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">12.4.2.</span> <span class="toc-text">自定义 seccomp profile 的使用方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#security-opt-seccomp-unconfined-%E7%9A%84%E9%A3%8E%E9%99%A9"><span class="toc-number">12.4.3.</span> <span class="toc-text">–security-opt seccomp&#x3D;unconfined 的风险</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apparmor-selinux"><span class="toc-number">12.5.</span> <span class="toc-text">AppArmor &#x2F; SELinux</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-%E9%BB%98%E8%AE%A4%E7%9A%84-apparmor-profile"><span class="toc-number">12.5.1.</span> <span class="toc-text">Docker 默认的 AppArmor profile</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89-profile-%E7%9A%84%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F"><span class="toc-number">12.5.2.</span> <span class="toc-text">自定义 profile 的加载方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#selinux-%E6%A0%87%E7%AD%BE-z-%E5%92%8C-z"><span class="toc-number">12.5.3.</span> <span class="toc-text">SELinux 标签（:z 和 :Z）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E8%AF%BB%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">12.6.</span> <span class="toc-text">只读文件系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#read-only-%E6%A0%87%E5%BF%97"><span class="toc-number">12.6.1.</span> <span class="toc-text">–read-only 标志</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E5%90%88-tmpfs-%E6%8C%82%E8%BD%BD%E5%8F%AF%E5%86%99%E7%9B%AE%E5%BD%95"><span class="toc-number">12.6.2.</span> <span class="toc-text">配合 tmpfs 挂载可写目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%91%BD%E4%BB%A4%E7%A4%BA%E4%BE%8B"><span class="toc-number">12.6.3.</span> <span class="toc-text">完整的命令示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%AE%89%E5%85%A8%E6%89%AB%E6%8F%8F"><span class="toc-number">12.7.</span> <span class="toc-text">镜像安全扫描</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-scout-docker-%E5%AE%98%E6%96%B9"><span class="toc-number">12.7.1.</span> <span class="toc-text">docker scout（Docker 官方）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#trivy-aqua-security"><span class="toc-number">12.7.2.</span> <span class="toc-text">Trivy（Aqua Security）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#snyk-container"><span class="toc-number">12.7.3.</span> <span class="toc-text">Snyk Container</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ci-cd-%E9%9B%86%E6%88%90%E5%BB%BA%E8%AE%AE"><span class="toc-number">12.7.4.</span> <span class="toc-text">CI&#x2F;CD 集成建议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-content-trust-dct"><span class="toc-number">12.8.</span> <span class="toc-text">Docker Content Trust（DCT）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E7%AD%BE%E5%90%8D%E5%92%8C%E9%AA%8C%E8%AF%81%E6%9C%BA%E5%88%B6"><span class="toc-number">12.8.1.</span> <span class="toc-text">镜像签名和验证机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-content-trust-1-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F"><span class="toc-number">12.8.2.</span> <span class="toc-text">DOCKER_CONTENT_TRUST&#x3D;1 环境变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#notary-%E7%9A%84%E8%A7%92%E8%89%B2"><span class="toc-number">12.8.3.</span> <span class="toc-text">Notary 的角色</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%BE%E5%90%8D%E6%B5%81%E7%A8%8B%E8%AF%B4%E6%98%8E"><span class="toc-number">12.8.4.</span> <span class="toc-text">签名流程说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8"><span class="toc-number">12.9.</span> <span class="toc-text">网络安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#internal-%E7%BD%91%E7%BB%9C-%E7%A6%81%E6%AD%A2%E5%A4%96%E9%83%A8%E8%AE%BF%E9%97%AE"><span class="toc-number">12.9.1.</span> <span class="toc-text">internal 网络（禁止外部访问）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%99%90%E5%88%B6%E5%AE%B9%E5%99%A8%E9%97%B4%E9%80%9A%E4%BF%A1-icc"><span class="toc-number">12.9.2.</span> <span class="toc-text">限制容器间通信（ICC）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E7%BB%9C%E9%9A%94%E7%A6%BB"><span class="toc-number">12.9.3.</span> <span class="toc-text">使用自定义网络隔离</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%E6%A3%80%E6%9F%A5%E6%B8%85%E5%8D%95"><span class="toc-number">12.10.</span> <span class="toc-text">安全最佳实践检查清单</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">第13章：镜像仓库与分发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="toc-number">13.1.</span> <span class="toc-text">镜像命名规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E6%A0%BC%E5%BC%8F"><span class="toc-number">13.1.1.</span> <span class="toc-text">完整格式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E9%83%A8%E5%88%86%E8%AF%B4%E6%98%8E"><span class="toc-number">13.1.2.</span> <span class="toc-text">各部分说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E7%A4%BA%E4%BE%8B"><span class="toc-number">13.1.3.</span> <span class="toc-text">命名示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tag-vs-digest"><span class="toc-number">13.1.4.</span> <span class="toc-text">Tag vs Digest</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-hub"><span class="toc-number">13.2.</span> <span class="toc-text">Docker Hub</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%85%B1%E4%BB%93%E5%BA%93%E4%B8%8E%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93"><span class="toc-number">13.2.1.</span> <span class="toc-text">公共仓库与私有仓库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F%E4%B8%8E%E8%AE%A4%E8%AF%81%E9%95%9C%E5%83%8F"><span class="toc-number">13.2.2.</span> <span class="toc-text">官方镜像与认证镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%98%E6%96%B9%E9%95%9C%E5%83%8F-official-images"><span class="toc-number">13.2.2.1.</span> <span class="toc-text">官方镜像（Official Images）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A4%E8%AF%81%E9%95%9C%E5%83%8F-verified-publisher"><span class="toc-number">13.2.2.2.</span> <span class="toc-text">认证镜像（Verified Publisher）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E6%9E%84%E5%BB%BA-automated-builds"><span class="toc-number">13.2.3.</span> <span class="toc-text">自动构建（Automated Builds）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rate-limiting-%E7%AD%96%E7%95%A5"><span class="toc-number">13.2.4.</span> <span class="toc-text">Rate Limiting 策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">13.2.5.</span> <span class="toc-text">常用命令</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%81%E6%9C%89-registry"><span class="toc-number">13.3.</span> <span class="toc-text">私有 Registry</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA-registry"><span class="toc-number">13.3.1.</span> <span class="toc-text">快速搭建 Registry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE-tls-%E8%AF%81%E4%B9%A6"><span class="toc-number">13.3.2.</span> <span class="toc-text">配置 TLS 证书</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81"><span class="toc-number">13.3.3.</span> <span class="toc-text">配置基本认证</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE"><span class="toc-number">13.3.4.</span> <span class="toc-text">存储后端配置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8-%E9%BB%98%E8%AE%A4"><span class="toc-number">13.3.4.1.</span> <span class="toc-text">1. 本地存储（默认）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-aws-s3"><span class="toc-number">13.3.4.2.</span> <span class="toc-text">2. AWS S3</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-azure-blob-storage"><span class="toc-number">13.3.4.3.</span> <span class="toc-text">3. Azure Blob Storage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-google-cloud-storage"><span class="toc-number">13.3.4.4.</span> <span class="toc-text">4. Google Cloud Storage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-compose-%E9%83%A8%E7%BD%B2%E7%A4%BA%E4%BE%8B"><span class="toc-number">13.3.5.</span> <span class="toc-text">Docker Compose 部署示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#harbor-%E4%BC%81%E4%B8%9A%E7%BA%A7%E4%BB%93%E5%BA%93"><span class="toc-number">13.4.</span> <span class="toc-text">Harbor 企业级仓库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7"><span class="toc-number">13.4.1.</span> <span class="toc-text">核心特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#harbor-vs-docker-registry"><span class="toc-number">13.4.2.</span> <span class="toc-text">Harbor vs Docker Registry</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E9%83%A8%E7%BD%B2"><span class="toc-number">13.4.3.</span> <span class="toc-text">基本部署</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85"><span class="toc-number">13.4.3.1.</span> <span class="toc-text">在线安装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#docker-compose-%E9%83%A8%E7%BD%B2"><span class="toc-number">13.4.3.2.</span> <span class="toc-text">Docker Compose 部署</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-harbor"><span class="toc-number">13.4.4.</span> <span class="toc-text">使用 Harbor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%9E%B6%E6%9E%84%E9%95%9C%E5%83%8F-multi-arch"><span class="toc-number">13.5.</span> <span class="toc-text">多架构镜像（Multi-arch）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#manifest-list-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">13.5.1.</span> <span class="toc-text">Manifest List 的概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-buildx-%E5%B7%A5%E5%85%B7"><span class="toc-number">13.5.2.</span> <span class="toc-text">docker buildx 工具</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%A4%9A%E6%9E%B6%E6%9E%84%E9%95%9C%E5%83%8F"><span class="toc-number">13.5.3.</span> <span class="toc-text">构建多架构镜像</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-buildx-%E6%9E%84%E5%BB%BA%E5%B9%B6%E6%8E%A8%E9%80%81"><span class="toc-number">13.5.3.1.</span> <span class="toc-text">使用 buildx 构建并推送</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%9E%84%E5%BB%BA%E6%A8%A1%E6%8B%9F"><span class="toc-number">13.5.3.2.</span> <span class="toc-text">跨平台构建模拟</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#docker-manifest-%E5%91%BD%E4%BB%A4"><span class="toc-number">13.5.4.</span> <span class="toc-text">docker manifest 命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E6%95%B4%E7%9A%84%E5%A4%9A%E6%9E%B6%E6%9E%84%E6%9E%84%E5%BB%BA%E6%B5%81%E7%A8%8B"><span class="toc-number">13.5.5.</span> <span class="toc-text">完整的多架构构建流程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%99%A8"><span class="toc-number">13.6.</span> <span class="toc-text">镜像加速器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BD%E5%86%85%E5%B8%B8%E7%94%A8%E9%95%9C%E5%83%8F%E6%BA%90"><span class="toc-number">13.6.1.</span> <span class="toc-text">国内常用镜像源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E6%96%B9%E5%BC%8F"><span class="toc-number">13.6.2.</span> <span class="toc-text">配置方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AA%8C%E8%AF%81%E5%8A%A0%E9%80%9F%E5%99%A8"><span class="toc-number">13.6.3.</span> <span class="toc-text">验证加速器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E7%9A%84%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F"><span class="toc-number">13.6.4.</span> <span class="toc-text">私有仓库的镜像加速</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5"><span class="toc-number">13.7.</span> <span class="toc-text">镜像分发策略</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E7%BB%9F%E6%8E%A8%E6%8B%89%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%93%B6%E9%A2%88"><span class="toc-number">13.7.1.</span> <span class="toc-text">传统推拉模式的瓶颈</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#p2p-%E5%88%86%E5%8F%91%E6%96%B9%E6%A1%88"><span class="toc-number">13.7.2.</span> <span class="toc-text">P2P 分发方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dragonfly-%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E5%BC%80%E6%BA%90"><span class="toc-number">13.7.2.1.</span> <span class="toc-text">Dragonfly（阿里巴巴开源）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#kraken-uber-%E5%BC%80%E6%BA%90"><span class="toc-number">13.7.2.2.</span> <span class="toc-text">Kraken（Uber 开源）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%95%9C%E5%83%8F%E9%A2%84%E7%83%AD%E7%AD%96%E7%95%A5"><span class="toc-number">13.7.3.</span> <span class="toc-text">镜像预热策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%87%92%E5%8A%A0%E8%BD%BD-lazy-pulling"><span class="toc-number">13.7.4.</span> <span class="toc-text">懒加载（Lazy Pulling）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#stargz"><span class="toc-number">13.7.4.1.</span> <span class="toc-text">Stargz</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#nydus"><span class="toc-number">13.7.4.2.</span> <span class="toc-text">Nydus</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%8F%91%E7%AD%96%E7%95%A5%E9%80%89%E6%8B%A9%E5%BB%BA%E8%AE%AE"><span class="toc-number">13.7.5.</span> <span class="toc-text">分发策略选择建议</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">参考资料</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>