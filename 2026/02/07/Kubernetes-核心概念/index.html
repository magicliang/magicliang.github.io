<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Kubernetes 核心概念 | 守株阁</title><meta name="author" content="magicliang"><meta name="copyright" content="magicliang"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="从 Docker 到 Kubernetes 的演进 Docker 的出现彻底改变了应用程序的打包和部署方式。通过容器化技术，开发人员能够将应用程序及其依赖项打包到一个轻量级的、可移植的容器中，确保了&quot;一次构建，到处运行&quot;的一致性体验。然而，随着容器化应用的规模扩大，单机容器管理的局限性逐渐显现。 在单机环境中，Docker 提供了容器生命周期管理、资源隔离、网络配置等基础功能。">
<meta property="og:type" content="article">
<meta property="og:title" content="Kubernetes 核心概念">
<meta property="og:url" content="https://magicliang.github.io/2026/02/07/Kubernetes-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/index.html">
<meta property="og:site_name" content="守株阁">
<meta property="og:description" content="从 Docker 到 Kubernetes 的演进 Docker 的出现彻底改变了应用程序的打包和部署方式。通过容器化技术，开发人员能够将应用程序及其依赖项打包到一个轻量级的、可移植的容器中，确保了&quot;一次构建，到处运行&quot;的一致性体验。然而，随着容器化应用的规模扩大，单机容器管理的局限性逐渐显现。 在单机环境中，Docker 提供了容器生命周期管理、资源隔离、网络配置等基础功能。">
<meta property="og:locale">
<meta property="og:image" content="https://magicliang.github.io/img/wall-paper-133.jpg">
<meta property="article:published_time" content="2026-02-07T01:00:00.000Z">
<meta property="article:modified_time" content="2026-02-07T08:51:20.039Z">
<meta property="article:author" content="magicliang">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="Kubernetes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://magicliang.github.io/img/wall-paper-133.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Kubernetes 核心概念",
  "url": "https://magicliang.github.io/2026/02/07/Kubernetes-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/",
  "image": "https://magicliang.github.io/img/wall-paper-133.jpg",
  "datePublished": "2026-02-07T01:00:00.000Z",
  "dateModified": "2026-02-07T08:51:20.039Z",
  "author": [
    {
      "@type": "Person",
      "name": "magicliang",
      "url": "https://magicliang.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://magicliang.github.io/2026/02/07/Kubernetes-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=5.5.2"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@7.1.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'undefined')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":1,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: 'Copy Successful',
    error: 'Copy Failed',
    noSupport: 'Browser Not Supported'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  dateSuffix: {
    just: 'Just now',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: magicliang","link":"Link: ","source":"Source: 守株阁","info":"Copyright belongs to the author. For commercial use, please contact the author for authorization. For non-commercial use, please indicate the source."}},
  lightbox: 'null',
  Snackbar: {"chs_to_cht":"You have switched to Traditional Chinese","cht_to_chs":"You have switched to Simplified Chinese","day_to_night":"You have switched to Dark Mode","night_to_day":"You have switched to Light Mode","bgLight":"#49b1f5","bgDark":"#2d3035","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.12.0/dist/infinitegrid.min.js',
    buttonText: 'Load More'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Kubernetes 核心概念',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 8.1.1"><link rel="alternate" href="/atom.xml" title="守株阁" type="application/atom+xml">
<link href="https://cdn.bootcss.com/KaTeX/0.11.1/katex.min.css" rel="stylesheet" /></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      if ($loadingBox.classList.contains('loaded')) return
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()

  if (document.readyState === 'complete') {
    preloader.endLoading()
  } else {
    window.addEventListener('load', preloader.endLoading)
    document.addEventListener('DOMContentLoaded', preloader.endLoading)
    // Add timeout protection: force end after 7 seconds
    setTimeout(preloader.endLoading, 7000)
  }

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/wall-paper-133.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">守株阁</span></a><a class="nav-page-title" href="/"><span class="site-name">Kubernetes 核心概念</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  Back to Home</span></span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">Kubernetes 核心概念</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2026-02-07T01:00:00.000Z" title="Created 2026-02-07 09:00:00">2026-02-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2026-02-07T08:51:20.039Z" title="Updated 2026-02-07 16:51:20">2026-02-07</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word Count:</span><span class="word-count">3.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading Time:</span><span>12mins</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post Views:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h2 id="从-docker-到-kubernetes-的演进">从 Docker 到 Kubernetes 的演进</h2>
<p>Docker 的出现彻底改变了应用程序的打包和部署方式。通过容器化技术，开发人员能够将应用程序及其依赖项打包到一个轻量级的、可移植的容器中，确保了&quot;一次构建，到处运行&quot;的一致性体验。然而，随着容器化应用的规模扩大，单机容器管理的局限性逐渐显现。</p>
<p>在单机环境中，Docker 提供了容器生命周期管理、资源隔离、网络配置等基础功能。但当应用规模扩展到多台服务器时，运维团队面临诸多挑战：跨主机的容器调度、服务发现、负载均衡、故障自愈、滚动升级、资源配额等问题变得日益复杂。手工管理几十甚至上百个容器不仅效率低下，而且容易出错。</p>
<p>容器编排平台应运而生。Kubernetes（K8s）作为容器编排领域的领导者，提供了一个完整的平台，用于自动化部署、扩展和管理容器化应用。它解决了多机环境下的核心问题：自动化调度、服务发现、负载均衡、存储编排、自动扩缩容、滚动更新和回滚、自我修复等。Kubernetes 不仅是一个编排工具，更是一个云原生应用的基础设施平台。</p>
<h2 id="kubernetes-架构">Kubernetes 架构</h2>
<p>Kubernetes 采用主从架构，由控制平面和工作节点组成。</p>
<h3 id="控制平面">控制平面</h3>
<p>控制平面负责集群的决策和全局管理，包含以下核心组件：</p>
<p><strong>API Server</strong> 是整个系统的统一入口，提供 RESTful API 接口。所有内部组件、用户和外部系统都通过 API Server 与集群交互。它负责认证、授权、准入控制，并将请求持久化到 etcd。</p>
<p><strong>etcd</strong> 是一个高可用的键值存储，用于存储集群的所有配置数据和状态信息。它是 Kubernetes 的唯一事实来源，确保了集群状态的一致性和可靠性。etcd 采用 Raft 共识算法，保证了分布式环境下的一致性和可用性。</p>
<p><strong>Scheduler</strong> 负责将新创建的 Pod 调度到合适的工作节点上。调度决策基于资源需求、硬件约束、亲和性和反亲和性规则、数据局部性、工作负载干扰等多种因素。调度器通过 watch API 监听未调度的 Pod，并为其选择最优节点。</p>
<p><strong>Controller Manager</strong> 运行多个控制器进程，每个控制器负责维护特定资源的期望状态。包括节点控制器、副本控制器、端点控制器、服务账户和令牌控制器等。控制器通过 API Server 监听资源变化，并不断调整实际状态以匹配期望状态。</p>
<h3 id="工作节点">工作节点</h3>
<p>工作节点负责运行容器化应用，包含以下组件：</p>
<p><strong>kubelet</strong> 是工作节点上的代理，负责与控制平面通信。它接收并执行来自 API Server 的指令，管理节点上的 Pod 生命周期，定期向控制平面报告节点和 Pod 的状态。kubelet 还负责挂载卷、下载镜像、运行容器等操作。</p>
<p><strong>kube-proxy</strong> 是网络代理，负责维护节点上的网络规则。它实现了 Service 的负载均衡和服务发现功能，通过 iptables 或 IPVS 规则将流量转发到正确的 Pod。kube-proxy 监听 Service 和 Endpoints 的变化，实时更新网络规则。</p>
<p><strong>Container Runtime</strong> 负责运行容器。Kubernetes 支持多种容器运行时，包括 Docker、containerd、CRI-O 等。容器运行时通过容器运行时接口（CRI）与 kubelet 交互，负责拉取镜像、创建和启动容器、监控容器状态等。</p>
<h2 id="核心资源对象">核心资源对象</h2>
<h3 id="pod">Pod</h3>
<p>Pod 是 Kubernetes 中最小的可部署单元，也是最小的调度单元。一个 Pod 可以包含一个或多个紧密协作的容器，这些容器共享网络命名空间、存储卷和生命周期。Pod 内的容器可以通过 localhost 相互通信，共享存储卷中的数据。</p>
<p>Pod 的设计理念是支持多容器协同工作模式，其中最典型的是 sidecar 模式。主容器负责核心业务逻辑，sidecar 容器负责辅助功能，如日志收集、监控代理、代理转发等。这种模式实现了关注点分离，提高了系统的模块化和可维护性。</p>
<p>Pod 是临时的、可替换的。当 Pod 所在节点故障或 Pod 本身出现问题时，控制器会创建新的 Pod 替换它。Pod 的 IP 地址是动态分配的，因此不应该直接依赖 Pod IP 进行服务发现。</p>
<h3 id="deployment">Deployment</h3>
<p>Deployment 是用于管理无状态应用的工作负载资源。它提供了声明式的更新方式，允许用户定义应用的期望状态，由控制器负责维护实际状态与期望状态的一致性。</p>
<p>Deployment 支持 Pod 的副本管理，确保指定数量的 Pod 副本始终运行。当 Pod 故障或节点失效时，Deployment 控制器会自动创建新的 Pod 替换失效的 Pod。</p>
<p>Deployment 支持滚动更新和回滚。当更新应用镜像或配置时，Deployment 会逐步替换旧版本的 Pod，确保在整个更新过程中始终有足够数量的 Pod 可用。如果更新失败或发现问题，可以轻松回滚到之前的版本。</p>
<h3 id="service">Service</h3>
<p>Service 定义了一种访问一组 Pod 的策略，解决了 Pod 动态 IP 带来的服务发现问题。Service 为一组功能相同的 Pod 提供一个固定的访问入口，通过标签选择器来确定要代理的 Pod 集合。</p>
<p>Service 支持多种类型：</p>
<p><strong>ClusterIP</strong> 是默认类型，为服务分配一个集群内部的虚拟 IP 地址，只能在集群内部访问。这是最常用的服务类型，用于集群内部的服务间通信。</p>
<p><strong>NodePort</strong> 在每个节点上开放一个端口，将外部流量转发到 Service。通过 <code>&lt;NodeIP&gt;:&lt;NodePort&gt;</code> 可以从集群外部访问服务。NodePort 是 ClusterIP 的超集，会自动创建一个 ClusterIP。</p>
<p><strong>LoadBalancer</strong> 在 NodePort 的基础上，向云服务商申请一个负载均衡器，将外部流量分发到各个节点的 NodePort。LoadBalancer 适用于需要对外暴露服务的场景。</p>
<p>Service 通过 kube-proxy 实现负载均衡，默认采用轮询算法。Service 的 Endpoints 会被自动维护，当 Pod 健康状态变化时，Endpoints 列表会相应更新。</p>
<h3 id="ingress">Ingress</h3>
<p>Ingress 是一个 API 对象，用于管理集群外部访问服务的规则，特别是 HTTP 和 HTTPS 协议的七层路由。Ingress 充当集群的入口点，根据请求的主机名、路径等规则将流量路由到不同的 Service。</p>
<p>Ingress 支持基于主机名的虚拟主机，可以在同一个 IP 地址上托管多个域名。支持基于路径的路由，根据 URL 路径将请求分发到不同的后端服务。支持 TLS 终止，可以在 Ingress 层面处理 SSL/TLS 加密解密，减轻后端服务的负担。</p>
<p>Ingress 需要配合 Ingress Controller 使用，常见的 Ingress Controller 包括 Nginx Ingress Controller、Traefik、HAProxy Ingress 等。</p>
<h3 id="configmap-和-secret">ConfigMap 和 Secret</h3>
<p>ConfigMap 用于存储非敏感的配置数据，以键值对的形式组织。ConfigMap 可以作为环境变量、命令行参数或配置文件挂载到 Pod 中。ConfigMap 的设计实现了配置与镜像的解耦，使得同一个镜像可以通过不同的 ConfigMap 在不同环境下运行。</p>
<p>Secret 类似于 ConfigMap，用于存储敏感信息，如密码、OAuth 令牌、SSH 密钥等。Secret 数据在存储和传输时会进行 Base64 编码，在使用时可以挂载为文件或环境变量。需要注意的是，Secret 的 Base64 编码并不是加密，在生产环境中应该结合 RBAC 和加密机制使用。</p>
<p>ConfigMap 和 Secret 支持热更新，当配置内容变化时，挂载的文件会自动更新。但环境变量形式的 ConfigMap 不会自动更新，需要重启 Pod 才能生效。</p>
<h3 id="persistentvolume-和-persistentvolumeclaim">PersistentVolume 和 PersistentVolumeClaim</h3>
<p>PersistentVolume（PV）是集群中的一块存储，由管理员预先配置或通过存储类动态创建。PV 是集群级别的资源，独立于 Pod 的生命周期存在。PV 支持多种存储类型，包括 NFS、iSCSI、Ceph、云存储（AWS EBS、GCE PD、Azure Disk）等。</p>
<p>PersistentVolumeClaim（PVC）是用户对存储的请求，类似于 Pod 对计算资源的请求。PVC 声明了所需的存储容量、访问模式（ReadWriteOnce、ReadOnlyMany、ReadWriteMany）等需求。PVC 会与合适的 PV 进行绑定，或者通过存储类动态创建新的 PV。</p>
<p>PV 和 PVC 的设计实现了存储的供应与使用的解耦。开发人员通过 PVC 申请存储，不需要关心底层存储的具体实现。管理员可以灵活配置不同类型的 PV，满足不同应用的存储需求。</p>
<h3 id="namespace">Namespace</h3>
<p>Namespace 提供了在一个物理集群中创建多个虚拟集群的能力，实现了资源隔离和配额管理。通过 Namespace，可以将集群资源划分为多个逻辑组，不同的团队或项目可以在各自的 Namespace 中工作，避免资源冲突。</p>
<p>Namespace 提供了作用域隔离，资源名称在同一个 Namespace 内必须唯一，但在不同 Namespace 中可以重复。Namespace 还支持资源配额和限制范围，可以限制 Namespace 中的资源使用量，防止单个 Namespace 占用过多资源。</p>
<p>Kubernetes 集群默认创建了几个 Namespace：default 用于没有指定 Namespace 的资源，kube-system 用于 Kubernetes 系统组件，kube-public 用于公共资源。</p>
<h2 id="声明式-api-与控制器模式">声明式 API 与控制器模式</h2>
<p>Kubernetes 采用声明式 API 设计，这是其架构的核心特点之一。声明式 API 要求用户描述期望的状态，而不是描述如何达到该状态。例如，用户声明需要运行 3 个 Nginx 副本，而不是描述如何创建、启动和监控这 3 个副本。</p>
<p>控制器模式是实现声明式 API 的关键机制。控制器不断监控集群的实际状态，并将其与用户声明的期望状态进行比较。如果两者不一致，控制器会采取行动使实际状态向期望状态收敛。这个过程称为 Reconciliation Loop（协调循环）。</p>
<p>Reconciliation Loop 的工作流程如下：控制器通过 API Server 监听资源的变化事件，包括创建、更新、删除操作。当检测到变化时，控制器获取当前的期望状态和实际状态。如果两者不一致，控制器执行相应的操作，如创建、删除、更新资源，使实际状态逐步接近期望状态。</p>
<p>声明式 API 和控制器模式带来了诸多优势：自动化的自我修复能力，当实际状态偏离期望状态时自动纠正；更好的可扩展性，控制器可以并行处理多个资源；简化的操作模型，用户只需要声明期望状态，不需要关心实现细节；最终一致性，系统保证最终达到期望状态，但不保证中间过程。</p>
<h2 id="网络模型">网络模型</h2>
<p>Kubernetes 的网络模型遵循扁平化网络原则，具有以下核心特性：每个 Pod 都拥有一个独立的 IP 地址，Pod 之间可以直接通信，无需 NAT（网络地址转换）。所有节点都可以与所有 Pod 通信，无需 NAT。Pod 看到的自己的 IP 地址与其他 Pod 看到的它的 IP 地址相同。</p>
<p>这种网络模型简化了应用的开发和部署。应用不需要因为容器化而进行特殊的网络适配，可以像在传统网络环境中一样工作。服务发现和负载均衡也变得简单，因为每个 Pod 都有独立的 IP 地址。</p>
<p>Kubernetes 通过 CNI（Container Network Interface）插件实现网络模型。CNI 定义了一套标准接口，允许不同的网络插件与 Kubernetes 集成。常见的 CNI 插件包括 Calico、Flannel、Weave Net、Cilium 等。</p>
<p>这些插件采用不同的网络实现方式：Flannel 使用 VXLAN 或 UDP 封装，简单易用；Calico 基于 BGP 协议，支持网络策略；Weave Net 创建覆盖网络，自动发现节点；Cilium 基于 eBPF，提供高性能和网络策略支持。</p>
<p>Kubernetes 的网络模型还支持网络策略（Network Policy），用于控制 Pod 之间的网络流量。网络策略可以基于标签选择器定义允许或拒绝的流量规则，实现微隔离和安全域划分。</p>
<h2 id="调度策略">调度策略</h2>
<p>Kubernetes 的调度器负责将 Pod 分配到合适的工作节点上，调度决策基于多种策略和约束。</p>
<p><strong>nodeSelector</strong> 是最简单的调度约束，通过标签选择器指定 Pod 只能调度到具有特定标签的节点上。例如，可以指定 Pod 只调度到 SSD 磁盘的节点上。nodeSelector 提供了基本的节点选择能力，但灵活性有限。</p>
<p><strong>亲和性和反亲和性</strong> 提供了更细粒度的调度控制。节点亲和性（Node Affinity）分为 required（硬性要求）和 preferred（软性偏好）两种。required 节点亲和性类似于 nodeSelector，但支持更复杂的匹配规则；preferred 节点亲和性在满足条件时优先调度，但不强制要求。</p>
<p>Pod 亲和性和反亲和性（Pod Affinity/Anti-Affinity）基于 Pod 的标签进行调度决策。Pod 亲和性用于将相关的 Pod 调度到同一个节点或拓扑域中，以减少网络延迟和提升性能。Pod 反亲和性用于将互斥的 Pod 分散到不同的节点或拓扑域中，以提高可用性和容错能力。</p>
<p><strong>污点和容忍度</strong> 提供了一种灵活的节点调度控制机制。污点（Taint）应用于节点，表示该节点具有特殊属性或限制。容忍度（Taint Toleration）应用于 Pod，表示 Pod 可以容忍具有特定污点的节点。</p>
<p>污点有三个效果：NoSchedule 表示除非 Pod 具有对应的容忍度，否则不会调度到该节点；PreferNoSchedule 表示尽量不调度到该节点，但在资源紧张时可以调度；NoExecute 表示不仅阻止新 Pod 调度，还会驱逐没有容忍度的现有 Pod。</p>
<p>污点和容忍度常用于以下场景：专用节点，为特定用途的节点添加污点，防止普通 Pod 调度；具有特殊硬件的节点，如 GPU 节点；节点维护，在维护前添加 NoExecute 污点，驱逐所有 Pod；节点故障检测，自动为故障节点添加污点。</p>
<p>调度器还支持优先级和抢占机制。高优先级的 Pod 可以抢占低优先级 Pod 的资源，确保关键应用能够及时运行。这为多租户环境下的资源分配提供了更好的保障。</p>
<h2 id="总结">总结</h2>
<p>Kubernetes 作为云原生应用的核心平台，通过声明式 API、控制器模式、丰富的资源对象和灵活的调度策略，为容器化应用提供了完整的运行时环境。从单机容器管理到集群编排的演进，反映了分布式系统发展的必然趋势。掌握 Kubernetes 的核心概念，是构建现代化、可扩展、高可用应用的基础。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>Author: </span><span class="post-copyright-info"><a href="https://magicliang.github.io">magicliang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>Link: </span><span class="post-copyright-info"><a href="https://magicliang.github.io/2026/02/07/Kubernetes-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/">https://magicliang.github.io/2026/02/07/Kubernetes-%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>Copyright Notice: </span><span class="post-copyright-info">All articles on this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless otherwise stated.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Docker/">Docker</a><a class="post-meta__tags" href="/tags/Kubernetes/">Kubernetes</a></div><div class="post-share"><div class="social-share" data-image="/img/wall-paper-133.jpg" data-sites="facebook,x,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2017/10/31/%E6%8A%8A-Unix-%E7%9A%84-Domain-Socket-%E8%BD%AC%E6%88%90%E5%8F%AF%E6%9C%AC%E5%9C%B0%E8%AE%BF%E9%97%AE%E7%9A%84-TCP-%E7%AB%AF%E5%8F%A3/" title="把 Unix 的 Domain Socket 转成可本地访问的 TCP 端口"><img class="cover" src="/img/wall-paper-154.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2017-10-31</div><div class="info-item-2">把 Unix 的 Domain Socket 转成可本地访问的 TCP 端口</div></div><div class="info-2"><div class="info-item-1">使用管道命令的做法： 1socat -d TCP-LISTEN:2376,range=127.0.0.1/32,reuseaddr,fork UNIX:/var/run/docker.sock 简洁的做法（使用守护进程而不是使用管道命令） 1docker run -d -v /var/run/docker.sock:/var/run/docker.sock -p 127.0.0.1:2375:2375 bobrik/socat TCP-LISTEN:2375,fork UNIX-CONNECT:/var/run/docker.sock 从容器内往外看的主机，对应外部主机就是 127.0.0.1的端口 ping docker.for.mac.localhost 通常结果是192.168.65.1。 值得参考的文：  http://brieflyx.me/2015/linux-tools/socat-introduction/  </div></div></div></a><a class="pagination-related" href="/2026/02/07/Docker-%E5%AE%8C%E5%85%A8%E6%8C%87%E5%8D%97/" title="Docker 完全指南"><img class="cover" src="/img/wall-paper-142.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-07</div><div class="info-item-2">Docker 完全指南</div></div><div class="info-2"><div class="info-item-1">第1章：Docker 核心架构 Docker 是一种操作系统级别的虚拟化技术，它通过 Linux 内核的多项特性实现进程间的软隔离，而非传统虚拟机的硬件级虚拟化。理解 Docker 的核心架构，是掌握容器技术的第一步。 Docker 的四根柱子 Docker 的核心技术基于 Linux 内核的三大特性，加上一个标准化的容器格式： 1. Namespace（命名空间）—— 隔离 Namespace 是 Linux 内核提供的资源隔离机制，Docker 利用它为每个容器创建独立的运行环境。Docker 使用的 Namespace 包括：    Namespace 隔离内容 说明     PID 进程 ID 容器内的进程有独立的 PID 空间   NET 网络 独立的网络栈、IP 地址、端口   MNT 文件系统挂载点 独立的文件系统视图   UTS 主机名和域名 容器可以有自己的主机名   IPC 进程间通信 独立的信号量、消息队列   USER 用户和用户组 容器内的 root 可以映射为宿主机的普通用户    2. Control Group（cgroup）—— 资源限制 cgr...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Contents</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E-docker-%E5%88%B0-kubernetes-%E7%9A%84%E6%BC%94%E8%BF%9B"><span class="toc-number">1.</span> <span class="toc-text">从 Docker 到 Kubernetes 的演进</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#kubernetes-%E6%9E%B6%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text">Kubernetes 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%B9%B3%E9%9D%A2"><span class="toc-number">2.1.</span> <span class="toc-text">控制平面</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E8%8A%82%E7%82%B9"><span class="toc-number">2.2.</span> <span class="toc-text">工作节点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1"><span class="toc-number">3.</span> <span class="toc-text">核心资源对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#pod"><span class="toc-number">3.1.</span> <span class="toc-text">Pod</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#deployment"><span class="toc-number">3.2.</span> <span class="toc-text">Deployment</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#service"><span class="toc-number">3.3.</span> <span class="toc-text">Service</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ingress"><span class="toc-number">3.4.</span> <span class="toc-text">Ingress</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#configmap-%E5%92%8C-secret"><span class="toc-number">3.5.</span> <span class="toc-text">ConfigMap 和 Secret</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#persistentvolume-%E5%92%8C-persistentvolumeclaim"><span class="toc-number">3.6.</span> <span class="toc-text">PersistentVolume 和 PersistentVolumeClaim</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#namespace"><span class="toc-number">3.7.</span> <span class="toc-text">Namespace</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E5%BC%8F-api-%E4%B8%8E%E6%8E%A7%E5%88%B6%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.</span> <span class="toc-text">声明式 API 与控制器模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.</span> <span class="toc-text">网络模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">6.</span> <span class="toc-text">调度策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">7.</span> <span class="toc-text">总结</span></a></li></ol></div></div></div></div></main><footer id="footer"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;&nbsp;2017 - 2026 By magicliang</span><span class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 8.1.1</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.5.2</a></span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Reading Mode"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="Toggle Between Traditional and Simplified Chinese">簡</button><button id="darkmode" type="button" title="Toggle Between Light and Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle Between Single-column and Double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="Settings"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back to Top"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=5.5.2"></script><script src="/js/main.js?v=5.5.2"></script><script src="/js/tw_cn.js?v=5.5.2"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar@0.1.16/dist/snackbar.min.js"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const config = mermaidSrc.dataset.config ? JSON.parse(mermaidSrc.dataset.config) : {}
      if (!config.theme) {
        config.theme = theme
      }
      const mermaidThemeConfig = `%%{init: ${JSON.stringify(config)}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid@11.12.1/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script></div><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.6/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="/"></script></div></body></html>